import Quaternion from "./Quaternion";
import { IVector3, IVector4 } from "./IVector";
import { TypedArray } from "../../commontypes/CommonTypes";
import { IMutableQuaternion, ILogQuaternion, IQuaternion } from "./IQuaternion";
import { IMatrix44 } from "./IMatrix";
export default class MutableQuaternion extends Quaternion implements IMutableQuaternion {
    constructor(x?: number | TypedArray | IVector3 | IVector4 | IQuaternion | ILogQuaternion | Array<number> | null, y?: number, z?: number, w?: number);
    set x(x: number);
    get x(): number;
    set y(y: number);
    get y(): number;
    set z(z: number);
    get z(): number;
    set w(w: number);
    get w(): number;
    static identity(): MutableQuaternion;
    static dummy(): MutableQuaternion;
    static invert(quat: IQuaternion): MutableQuaternion;
    static qlerp(l_quat: IQuaternion, r_quat: IQuaternion, ratio: number): MutableQuaternion;
    static lerp(l_quat: IQuaternion, r_quat: IQuaternion, ratio: number): MutableQuaternion;
    static axisAngle(vec: IVector3, radian: number): MutableQuaternion;
    static fromMatrix(mat: IMatrix44): MutableQuaternion;
    static fromPosition(vec: IVector3): MutableQuaternion;
    static add(l_quat: IQuaternion, r_quat: IQuaternion): MutableQuaternion;
    static subtract(l_quat: IQuaternion, r_quat: IQuaternion): MutableQuaternion;
    static multiply(l_quat: IQuaternion, r_quat: IQuaternion): MutableQuaternion;
    static multiplyNumber(quat: IQuaternion, value: number): MutableQuaternion;
    static divideNumber(quat: IQuaternion, value: number): MutableQuaternion;
    raw(): TypedArray;
    setAt(i: number, value: number): this;
    setComponents(x: number, y: number, z: number, w: number): this;
    copyComponents(quat: IQuaternion): this;
    identity(): this;
    normalize(): this;
    invert(): this;
    qlerp(l_quat: IQuaternion, r_quat: IQuaternion, ratio: number): this;
    lerp(l_quat: IQuaternion, r_quat: IQuaternion, ratio: number): this;
    axisAngle(vec: IVector3, radian: number): this;
    fromMatrix(mat: IMatrix44): this;
    fromPosition(vec: IVector3): this;
    add(quat: IQuaternion): this;
    subtract(quat: IQuaternion): this;
    multiply(quat: IQuaternion): this;
    multiplyNumber(value: number): this;
    divideNumber(value: number): this;
    clone(): MutableQuaternion;
}
