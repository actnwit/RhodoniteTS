var aC=Object.create;var bl=Object.defineProperty;var sC=Object.getOwnPropertyDescriptor;var lC=Object.getOwnPropertyNames;var cC=Object.getPrototypeOf,fC=Object.prototype.hasOwnProperty;var Fv=m=>{throw TypeError(m)};var uC=(m,n,t)=>n in m?bl(m,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):m[n]=t;var h=(m,n)=>bl(m,"name",{value:n,configurable:!0}),tu=(m=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(m,{get:(n,t)=>(typeof require!="undefined"?require:n)[t]}):m)(function(m){if(typeof require!="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+m+'" is not supported')});var C=(m,n)=>()=>(m&&(n=m(m=0)),n);var mC=(m,n)=>()=>(n||m((n={exports:{}}).exports,n),n.exports),Qa=(m,n)=>{for(var t in n)bl(m,t,{get:n[t],enumerable:!0})},_C=(m,n,t,o)=>{if(n&&typeof n=="object"||typeof n=="function")for(let r of lC(n))!fC.call(m,r)&&r!==t&&bl(m,r,{get:()=>n[r],enumerable:!(o=sC(n,r))||o.enumerable});return m};var Hm=(m,n,t)=>(t=m!=null?aC(cC(m)):{},_C(n||!m||!m.__esModule?bl(t,"default",{value:m,enumerable:!0}):t,m));var f=(m,n,t)=>uC(m,typeof n!="symbol"?n+"":n,t),Lv=(m,n,t)=>n.has(m)||Fv("Cannot "+t);var Do=(m,n,t)=>(Lv(m,n,"read from private field"),t?t.call(m):n.get(m)),Yr=(m,n,t)=>n.has(m)?Fv("Cannot add the same private member more than once"):n instanceof WeakSet?n.add(m):n.set(m,t),Fr=(m,n,t,o)=>(Lv(m,n,"write to private field"),o?o.call(m,t):n.set(m,t),t);function dC(m){return m*180/Math.PI}function hC(m){return m*Math.PI/180}function qm(m){return(m&m-1)==0}function xC(m,n){return qm(m)&&qm(n)}function vC(m,n,t,o,r){m=(m+1)/2,n=(n+1)/2,t=(t+1)/2,o=(o+1)/2;let i=Math.floor(m*(r-1)),a=Math.floor(n*(r-1)),l=(i*r+a)/r,c=Math.floor(t*(r-1)),u=Math.floor(o*(r-1)),d=(c*r+u)/r;return[l,d]}function gC(m){let n=1;m<0&&(n=-1),m=Math.abs(m);let t=1/(1+.3275911*m),o=1-((((1.061405429*t+-1.453152027)*t+1.421413741)*t+-.284496736)*t+.254829592)*t*Math.exp(-m*m);return n*o}function yC(m){let n,t=0;return n=-Math.log((1-m)*(1+m)),n<5?(n=n-2.5,t=281022636e-16,t=343273939e-15+t*n,t=-35233877e-13+t*n,t=-439150654e-14+t*n,t=.00021858087+t*n,t=-.00125372503+t*n,t=-.00417768164+t*n,t=.246640727+t*n,t=1.50140941+t*n):(n=Math.sqrt(n)-3,t=-.000200214257,t=.000100950558+t*n,t=.00134934322+t*n,t=-.00367342844+t*n,t=.00573950773+t*n,t=-.0076224613+t*n,t=.00943887047+t*n,t=1.00167406+t*n,t=2.83297682+t*n),t*m}function bC(m,n,t){return .5*(1+gC((m-n)/(t*Math.sqrt(2))))}function AC(m,n,t){return t*Math.sqrt(2)*yC(2*m-1)+n}function IC(m,n,t){let r=0,i=0,a=0,s=0,l=0,c=0,u=0,_=0,d=0,p=0;for(let x=0;x<3;x++){n.setAt(x,x,1);for(let v=0;v<x;v++)n.setAt(x,v,0),n.setAt(v,x,0)}for(let x=0;x<3;x++)t.setAt(x,m.at(x,x));r=0;for(let x=0;x<3;x++)r+=Math.abs(t.at(x));r=r*r;for(let x=0;x<50;x++){i=0;for(let v=0;v<3;v++)for(let y=v+1;y<3;y++)i+=Math.abs(m.at(v,y));if(i==0)return 0;x<4?p=.2*i/(3*3):p=0;for(let v=0;v<3;v++)for(let y=v+1;y<3;y++)if(c=100*Math.abs(m.at(v,y)),x>4&&Math.abs(t.at(v))+c==Math.abs(t.at(v))&&Math.abs(t.at(y))+c==Math.abs(t.at(y)))m.setAt(v,y,0);else if(Math.abs(m.at(v,y))>p){u=t.at(y)-t.at(v),Math.abs(u)+c==Math.abs(u)?l=m.at(v,y)/u:(d=.5*u/m.at(v,y),d<0?l=-1/(Math.sqrt(1+d*d)-d):l=1/(Math.sqrt(1+d*d)+d)),s=1/Math.sqrt(1+l*l),a=l*s,_=l*m.at(v,y),m.setAt(v,y,0),t.setAt(v,t.at(v)-_),t.setAt(y,t.at(y)+_);for(let g=0;g<v;g++)l=m.at(g,v),m.setAt(g,v,s*l-a*m.at(g,y)),m.setAt(g,y,a*l+s*m.at(g,y));for(let g=v+1;g<y;g++)l=m.at(v,g),m.setAt(v,g,s*l-a*m.at(g,y)),m.setAt(g,y,a*l+s*m.at(g,y));for(let g=y+1;g<3;g++)l=m.at(v,g),m.setAt(v,g,s*l-a*m.at(y,g)),m.setAt(y,g,a*l+s*m.at(y,g));for(let g=0;g<3;g++)l=n.at(g,v),n.setAt(g,v,s*l-a*n.at(g,y)),n.setAt(g,y,a*l+s*n.at(g,y))}}return-1}function SC(m){return Number.isInteger(m)?`${m}.0`:""+m}function TC(m){return Math.abs(m)<1e-5?m=0:.99999<m&&m<1.00001?m=1:-1.00001<m&&m<-.99999&&(m=-1),m}function EC(m){let n=Number.parseFloat(m).toFixed(7);return m>=0?" "+n:n}function CC(m){return Math.round(m*1e7)/1e7}function wC(m,n,t){return m*(1-t)+n*t}function RC({kernelSize:m,variance:n,mean:t=0,effectiveDigit:o=4}){let r=Math.ceil(m/2),i=new Array(r),a=0;for(let u=0;u<r;u++)i[u]=Math.exp(-((u-t)**2)/(2*n)),a+=i[u];a*=2,m/2%2!==0&&(a-=i[0]);let s=new Array(m),l=0,c=Math.pow(10,o);for(let u=0;u<r-1;u++){let _=i[r-1-u]/a;_*=c,_=Math.round(_),_/=c,s[u]=_,s[m-1-u]=_,l+=2*_}if(m%2===0){let u=(1-l)/2;s[r-1]=u,s[r]=u}else{let u=1-l;s[r-1]=u}return s}var pC,Y,nn=C(()=>{"use strict";h(dC,"radianToDegree");h(hC,"degreeToRadian");pC=h(()=>h(function(n){let t=new Float32Array(1),o=new Int32Array(t.buffer);t[0]=n;let r=o[0],i=r>>16&32768,a=r>>12&2047,s=r>>23&255;return s<103?i:s>142?(i|=31744,i|=(s==255?0:1)&&r&8388607,i):s<113?(a|=2048,i|=(a>>114-s)+(a>>113-s&1),i):(i|=s-112<<10|a>>1,i+=a&1,i)},"toHalf"),"toHalfFloat");h(qm,"isPowerOfTwo");h(xC,"isPowerOfTwoTexture");h(vC,"packNormalizedVec4ToVec2");h(gC,"erf");h(yC,"invErf");h(bC,"gaussianCdf");h(AC,"invGaussianCdf");h(IC,"computeEigenValuesAndVectors");h(SC,"convertToStringAsGLSLFloat");h(TC,"nearZeroToZero");h(EC,"financial");h(CC,"roundAsFloat");h(wC,"lerp");h(RC,"computeGaussianDistributionRatioWhoseSumIsOne");Y=Object.freeze({radianToDegree:dC,degreeToRadian:hC,toHalfFloat:pC,isPowerOfTwo:qm,isPowerOfTwoTexture:xC,packNormalizedVec4ToVec2:vC,convertToStringAsGLSLFloat:SC,nearZeroToZero:TC,gaussianCdf:bC,invGaussianCdf:AC,computeEigenValuesAndVectors:IC,computeGaussianDistributionRatioWhoseSumIsOne:RC,roundAsFloat:CC,financial:EC,lerp:wC})});function de({typeList:m,index:n}){let t=m.find(o=>o.index===n);if(t)return t}function Te({typeList:m,str:n}){let t=m.find(o=>o.str.toLowerCase()===n.toLowerCase());if(t)return t}function jm({typeList:m,str:n}){let t=m.find(o=>o.str===n);if(t)return t}var ko,fe,st=C(()=>{"use strict";ko=class ko{constructor({index:n,str:t,noCheckStrUnique:o}){f(this,"index");f(this,"symbol");f(this,"str");if(ko.__indices.get(this.constructor)==null&&ko.__indices.set(this.constructor,[]),ko.__strings.get(this.constructor)==null&&ko.__strings.set(this.constructor,[]),ko.__indices.get(this.constructor).indexOf(n)!==-1)throw new Error("Dont use duplicate index.");if(o!==!0&&ko.__strings.get(this.constructor).indexOf(t)!==-1)throw new Error("Dont use duplicate str.");this.index=n,this.str=t,this.symbol=Symbol(t),ko.__indices.get(this.constructor).push(n),ko.__strings.get(this.constructor).push(t)}toString(){return this.str}toJSON(){return this.index}};h(ko,"EnumClass"),f(ko,"__indices",new Map),f(ko,"__strings",new Map);fe=ko;h(de,"_from");h(Te,"_fromString");h(jm,"_fromStringCaseSensitively")});var nu,Xa,NC,ki,N,me=C(()=>{"use strict";(function(m){m[m.Debug=0]="Debug",m[m.Info=1]="Info",m[m.Warn=2]="Warn",m[m.Error=3]="Error",m[m.Assert=4]="Assert"})(nu||(nu={}));NC=(Xa=class{constructor(){f(this,"message","");f(this,"timestamp",0);f(this,"logLevel",1)}},h(Xa,"Log"),Xa),ki=class ki{static __common(n,t){if(!this.isAccumulateLog&&!this.isRichLog)return n;let o=new NC;return o.message=n,o.timestamp=Date.now(),o.logLevel=t,this.isAccumulateLog&&this.__messages.push(o),this.__formatLogs(o)}static __clearAccumulatedLog(){this.__messages=[]}static __formatLogs(n){if(!this.isRichLog)return n.message;let o=new Intl.DateTimeFormat(void 0,{year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit"}).format(n.timestamp);return`Rn[${this.__getLogLevelText(n.logLevel)}][${o}]: ${n.message}`}static __getLogLevelText(n){return nu[n]}static error(n){if(this.logLevel<=3){let t=this.__common(n,3);return console.error(t),t}}static warn(n){if(this.logLevel<=2){let t=this.__common(n,2);return console.warn(t),t}}static info(n){if(this.logLevel<=1){let t=this.__common(n,1);return console.info(t),t}}static debug(n){if(this.logLevel<=0){let t=this.__common(n,0);return console.debug(t),t}}static assert(n,t){if(this.logLevel<=4){let o=this.__common(t,4);return console.assert(n,o),o}}static getAccumulatedLog(){return this.__messages.map(n=>this.__formatLogs(n))}};h(ki,"Logger"),f(ki,"__messages",[]),f(ki,"logLevel",2),f(ki,"isRichLog",!1),f(ki,"isAccumulateLog",!1);N=ki});function PC(m){return de({typeList:Al,index:m})}function MC(m){return Te({typeList:Al,str:m})}function DC(m){let n="";switch(m){case 1:n="scalar";break;case 2:n="vec2";break;case 3:n="vec3";break;case 4:n="vec4";break;default:N.error("not found appropriate Vectors")}return Te({typeList:Al,str:n})}function BC(m){let n=m;switch(m){case"bool":n="scalar";break;case"int":n="scalar";break;case"float":n="scalar";break;case"ivec2":n="vec2";break;case"ivec3":n="vec3";break;case"ivec4":n="vec4";break;case"sampler2D":n="TEXTURE_2D";break;case"sampler2DShadow":n="TEXTURE_2D_SHADOW";break;case"sampler2DRect":n="TEXTURE_2D_RECT";break;case"samplerCube":n="TEXTURE_CUBE_MAP";break;case"sampler2DArray":n="TEXTURE_2D_ARRAY";break}return Te({typeList:Al,str:n})}function FC(m){let n=m;switch(m){case"bool":n="scalar";break;case"i32":n="scalar";break;case"u32":n="scalar";break;case"f32":n="scalar";break;case"vec2<f32>":n="vec2";break;case"vec3<f32>":n="vec3";break;case"vec4<f32>":n="vec4";break;case"mat2x2<f32>":n="mat2";break;case"mat3x3<f32>":n="mat3";break;case"mat4x4<f32>":n="mat4";break;case"vec2<i32>":n="vec2";break;case"vec3<i32>":n="vec3";break;case"vec4<i32>":n="vec4";break;case"mat2x2<i32>":n="mat2";break;case"mat3x3<i32>":n="mat3";break;case"mat4x4<i32>":n="mat4";break;case"sampler_2d":n="TEXTURE_2D";break;case"sampler_2d_shadow":n="TEXTURE_2D_SHADOW";break;case"sampler_cube":n="TEXTURE_CUBE_MAP";break;case"sampler_2d_array":n="TEXTURE_2D_ARRAY";break}return Te({typeList:Al,str:n})}function LC(m){switch(m){case 1:return"SCALAR";case 2:return"VEC2";case 3:return"VEC3";case 4:return"VEC4";case 9:return"MAT3";case 16:return"MAT4";default:throw new Error("Invalid componentN")}}function VC(m){switch(m){case 1:return"SCALAR";case 2:return"VEC2";case 3:return"VEC3";case 4:return"VEC4";default:throw new Error("Invalid componentN")}}function zC(m){switch(m){case 4:return"VEC4";case 9:return"MAT3";case 16:return"MAT4";default:throw new Error("Invalid componentN")}}function GC(m){switch(m){case 1:return Ym;case 2:return Km;case 3:return Zm;case 4:return Jm;default:throw new Error("Invalid componentN")}}function OC(m){return m===t_||m===n_||m===o_||m===r_||m===f_||m===i_||m===a_||m===s_}function UC(m){return m===$m||m===e_||m===l_||m===c_||m===Uv}var Ha,fn,Vv,Ym,Km,Zm,Jm,zv,Gv,Ov,$m,e_,t_,n_,o_,r_,i_,a_,s_,l_,c_,Uv,f_,Al,b,se=C(()=>{"use strict";st();me();fn=(Ha=class extends fe{constructor({index:t,str:o,glslStr:r,hlslStr:i,wgsl:a,webgpu:s,numberOfComponents:l,vec4SizeOfProperty:c,isArray:u=!1}){super({index:t,str:o});f(this,"__numberOfComponents");f(this,"__glslStr");f(this,"__hlslStr");f(this,"__webgpuStr");f(this,"__wgslStr");f(this,"__isArray");f(this,"__vec4SizeOfProperty");f(this,"__dummyStr");this.__numberOfComponents=l,this.__glslStr=r,this.__hlslStr=i,this.__vec4SizeOfProperty=c,this.__isArray=u,this.__webgpuStr=s,this.__wgslStr=a,this.__dummyStr=o}get webgpu(){return this.__webgpuStr}get wgsl(){return this.__wgslStr}getNumberOfComponents(){return this.__numberOfComponents}getGlslStr(t){return t.index===5126||t.index===5127||this===b.Texture2D||this===b.Texture2DShadow||this===b.Texture2DRect||this===b.TextureCube||this===b.Texture2DArray?this.__glslStr:t.index===5120||t.index===5122||t.index===5124?this===b.Scalar||this===b.ScalarArray?"int":"i"+this.__glslStr:t.index===35670?"bool":"unknown"}getGlslInitialValue(t){if(t.index===5126||t.index===5127){if(this===b.Scalar)return"0.0";if(this.__numberOfComponents===2)return this.__glslStr+"(0.0, 0.0)";if(this.__numberOfComponents===3)return this.__glslStr+"(0.0, 0.0, 0.0)";if(this.__numberOfComponents===4)return this.__glslStr+"(0.0, 0.0, 0.0, 0.0)";if(this.__numberOfComponents===9)return this.__glslStr+"(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)";if(this.__numberOfComponents===16)return this.__glslStr+"(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)"}else if(t.index===5120||t.index===5122||t.index===5124){if(this===b.Scalar)return"0";if(this.__numberOfComponents===2)return this.__glslStr+"(0, 0)";if(this.__numberOfComponents===3)return this.__glslStr+"(0, 0, 0)";if(this.__numberOfComponents===4)return this.__glslStr+"(0, 0, 0, 0)";if(this.__numberOfComponents===9)return this.__glslStr+"(0, 0, 0, 0, 0, 0, 0, 0, 0)";if(this.__numberOfComponents===16)return this.__glslStr+"(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)"}else if(t.index===35670){if(this===b.Scalar)return"false";if(this.__numberOfComponents===2)return this.__glslStr+"(false, false)";if(this.__numberOfComponents===3)return this.__glslStr+"(false, false, false)";if(this.__numberOfComponents===4)return this.__glslStr+"(false, false, false, false)"}return"unknown"}getWgslInitialValue(t){let o=this.toWGSLType(t);if(t.index===5126||t.index===5127){if(this===b.Scalar)return"0.0";if(this.__numberOfComponents===2)return o+"(0.0, 0.0)";if(this.__numberOfComponents===3)return o+"(0.0, 0.0, 0.0)";if(this.__numberOfComponents===4)return o+"(0.0, 0.0, 0.0, 0.0)";if(this.__numberOfComponents===9)return o+"(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)";if(this.__numberOfComponents===16)return o+"(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)"}else if(t.index===5120||t.index===5122||t.index===5124){if(this===b.Scalar)return"0";if(this.__numberOfComponents===2)return o+"(0, 0)";if(this.__numberOfComponents===3)return o+"(0, 0, 0)";if(this.__numberOfComponents===4)return o+"(0, 0, 0, 0)";if(this.__numberOfComponents===9)return o+"(0, 0, 0, 0, 0, 0, 0, 0, 0)";if(this.__numberOfComponents===16)return o+"(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)"}else if(t.index===35670){if(this===b.Scalar)return"false";if(this.__numberOfComponents===2)return o+"(false, false)";if(this.__numberOfComponents===3)return o+"(false, false, false)";if(this.__numberOfComponents===4)return o+"(false, false, false, false)"}return"unknown"}toWGSLType(t){return this.__wgslStr.replace("#",t.wgsl)}getVec4SizeOfProperty(){return this.__vec4SizeOfProperty}},h(Ha,"CompositionTypeClass"),Ha),Vv=new fn({index:-1,str:"UNKNOWN",glslStr:"unknown",hlslStr:"unknown",wgsl:"unknown",webgpu:"unknown",numberOfComponents:0,vec4SizeOfProperty:0}),Ym=new fn({index:0,str:"SCALAR",glslStr:"float",hlslStr:"float",wgsl:"#",webgpu:"",numberOfComponents:1,vec4SizeOfProperty:1}),Km=new fn({index:1,str:"VEC2",glslStr:"vec2",hlslStr:"float2",wgsl:"vec2<#>",webgpu:"x2",numberOfComponents:2,vec4SizeOfProperty:1}),Zm=new fn({index:2,str:"VEC3",glslStr:"vec3",hlslStr:"float3",wgsl:"vec3<#>",webgpu:"x3",numberOfComponents:3,vec4SizeOfProperty:1}),Jm=new fn({index:3,str:"VEC4",glslStr:"vec4",hlslStr:"float4",wgsl:"vec4<#>",webgpu:"x4",numberOfComponents:4,vec4SizeOfProperty:1}),zv=new fn({index:4,str:"MAT2",glslStr:"mat2",hlslStr:"float2x2",wgsl:"mat2x2<#>",webgpu:"unknown",numberOfComponents:4,vec4SizeOfProperty:2}),Gv=new fn({index:5,str:"MAT3",glslStr:"mat3",hlslStr:"float3x3",wgsl:"mat3x3<#>",webgpu:"unknown",numberOfComponents:9,vec4SizeOfProperty:3}),Ov=new fn({index:6,str:"MAT4",glslStr:"mat4",hlslStr:"float4x4",wgsl:"mat4x4<#>",webgpu:"unknown",numberOfComponents:16,vec4SizeOfProperty:4}),$m=new fn({index:7,str:"TEXTURE_2D",glslStr:"sampler2D",hlslStr:"Texture2D",wgsl:"texture_2d",webgpu:"texture_2d",numberOfComponents:1,vec4SizeOfProperty:1}),e_=new fn({index:8,str:"TEXTURE_CUBE_MAP",glslStr:"samplerCube",hlslStr:"TextureCube",wgsl:"texture_cube",webgpu:"texture_cube",numberOfComponents:1,vec4SizeOfProperty:1}),t_=new fn({index:9,str:"SCALAR_ARRAY",glslStr:"float",hlslStr:"float",wgsl:"#",webgpu:"unknown",numberOfComponents:1,vec4SizeOfProperty:1,isArray:!0}),n_=new fn({index:10,str:"VEC2_ARRAY",glslStr:"vec2",hlslStr:"float2",wgsl:"vec2<#>",webgpu:"unknown",numberOfComponents:2,vec4SizeOfProperty:1,isArray:!0}),o_=new fn({index:11,str:"VEC3_ARRAY",glslStr:"vec3",hlslStr:"float3",wgsl:"vec3<#>",webgpu:"unknown",numberOfComponents:3,vec4SizeOfProperty:1,isArray:!0}),r_=new fn({index:12,str:"VEC4_ARRAY",glslStr:"vec4",hlslStr:"float4",wgsl:"vec4<#>",webgpu:"unknown",numberOfComponents:4,vec4SizeOfProperty:1,isArray:!0}),i_=new fn({index:13,str:"MAT4_ARRAY",glslStr:"mat4",hlslStr:"float4x4",wgsl:"mat4x4<#>",webgpu:"unknown",numberOfComponents:16,vec4SizeOfProperty:4,isArray:!0}),a_=new fn({index:14,str:"MAT3_ARRAY",glslStr:"mat3",hlslStr:"float3x3",wgsl:"mat3x3<#>",webgpu:"unknown",numberOfComponents:9,vec4SizeOfProperty:3,isArray:!0}),s_=new fn({index:15,str:"MAT2_ARRAY",glslStr:"mat2",hlslStr:"float2x2",wgsl:"mat2x2<#>",webgpu:"unknown",numberOfComponents:4,vec4SizeOfProperty:2,isArray:!0}),l_=new fn({index:16,str:"TEXTURE_2D_SHADOW",glslStr:"highp sampler2DShadow",hlslStr:"Texture2D",wgsl:"texture_2d",webgpu:"texture_2d",numberOfComponents:1,vec4SizeOfProperty:1}),c_=new fn({index:17,str:"TEXTURE_2D_RECT",glslStr:"sampler2DRect",hlslStr:"Texture2D",wgsl:"texture_2d",webgpu:"texture_2d",numberOfComponents:1,vec4SizeOfProperty:1}),Uv=new fn({index:18,str:"TEXTURE_2D_ARRAY",glslStr:"sampler2DArray",hlslStr:"Texture2DArray",wgsl:"texture_2d_array",webgpu:"texture_2d_array",numberOfComponents:1,vec4SizeOfProperty:1}),f_=new fn({index:19,str:"MAT4x3_ARRAY",glslStr:"mat4x3",hlslStr:"float4x3",wgsl:"mat4x3<#>",webgpu:"unknown",numberOfComponents:12,vec4SizeOfProperty:3,isArray:!0}),Al=[Vv,Ym,Km,Zm,Jm,zv,Gv,Ov,n_,o_,r_,t_,s_,a_,i_,$m,l_,c_,e_,f_];h(PC,"from");h(MC,"fromString");h(DC,"vectorFrom");h(BC,"fromGlslString");h(FC,"fromWgslString");h(LC,"toGltf2AccessorCompositionTypeString");h(VC,"toGltf2AnimationAccessorCompositionTypeString");h(zC,"toGltf2SquareMatrixAccessorCompositionTypeString");h(GC,"toGltf2AnimationAccessorCompositionType");h(OC,"isArray");h(UC,"isTexture");b=Object.freeze({Unknown:Vv,Scalar:Ym,Vec2:Km,Vec3:Zm,Vec4:Jm,Mat2:zv,Mat3:Gv,Mat4:Ov,ScalarArray:t_,Vec2Array:n_,Vec3Array:o_,Vec4Array:r_,Mat2Array:s_,Mat3Array:a_,Mat4Array:i_,Texture2D:$m,Texture2DShadow:l_,TextureCube:e_,Texture2DRect:c_,Texture2DArray:Uv,Mat4x3Array:f_,from:PC,fromString:MC,vectorFrom:DC,fromGlslString:BC,fromWgslString:FC,isArray:OC,isTexture:UC,toGltf2AnimationAccessorCompositionType:GC,toGltf2AccessorCompositionTypeString:LC,toGltf2AnimationAccessorCompositionTypeString:VC,toGltf2SquareMatrixAccessorCompositionTypeString:zC})});var u_,pr,qa=C(()=>{"use strict";u_=class u_{constructor(){f(this,"_v",new Float32Array)}get x(){return this._v[0]}get glslStrAsFloat(){throw new Error("Method not implemented.")}get glslStrAsInt(){throw new Error("Method not implemented.")}isEqual(n,t){throw new Error("Method not implemented.")}isStrictEqual(n){throw new Error("Method not implemented.")}length(){throw new Error("Method not implemented.")}lengthSquared(){throw new Error("Method not implemented.")}lengthTo(n){throw new Error("Method not implemented.")}dot(n){throw new Error("Method not implemented.")}at(n){return this._v[n]}toString(){throw new Error("Method not implemented.")}toStringApproximately(){throw new Error("Method not implemented.")}flattenAsArray(){throw new Error("Method not implemented.")}isDummy(){return this._v.length===0}v(n){return this._v[n]}isTheSourceSame(n){return this._v.buffer===n}get className(){return this.constructor.name}get bytesPerComponent(){throw new Error("Method not implemented.")}};h(u_,"AbstractVector");pr=u_});var __,Wi,ja,S,Il,m_,kC,WC,ye=C(()=>{"use strict";nn();se();qa();me();__=class __ extends pr{constructor(n,{type:t}){super(),this._v=n}get x(){return this._v[0]}get y(){return this._v[1]}get z(){return this._v[2]}get w(){return 1}get glslStrAsFloat(){return`vec3(${Y.convertToStringAsGLSLFloat(this._v[0])}, ${Y.convertToStringAsGLSLFloat(this._v[1])}, ${Y.convertToStringAsGLSLFloat(this._v[2])})`}get glslStrAsInt(){return`ivec3(${Math.floor(this._v[0])}, ${Math.floor(this._v[1])}, ${Math.floor(this._v[2])})`}static get compositionType(){return b.Vec3}static lengthSquared(n){return n.lengthSquared()}static lengthBtw(n,t){return n.lengthTo(t)}static angleOfVectors(n,t){let o=n.length()*t.length();o===0&&N.error("length of a vector is 0!");let r=n.dot(t)/o;return Math.acos(r)}static _zero(n){return this._fromCopyArray([0,0,0],n)}static _one(n){return this._fromCopyArray([1,1,1],n)}static _dummy(n){return new this(new n([]),{type:n})}static _normalize(n,t){let o=n.length();return this._divide(n,o,t)}static normalizeTo(n,t){let o=n.length();return this.divideTo(n,o,t),t}static _add(n,t,o){let r=n._v[0]+t._v[0],i=n._v[1]+t._v[1],a=n._v[2]+t._v[2];return this._fromCopyArray([r,i,a],o)}static addTo(n,t,o){return o._v[0]=n._v[0]+t._v[0],o._v[1]=n._v[1]+t._v[1],o._v[2]=n._v[2]+t._v[2],o}static _subtract(n,t,o){let r=n._v[0]-t._v[0],i=n._v[1]-t._v[1],a=n._v[2]-t._v[2];return this._fromCopyArray([r,i,a],o)}static subtractTo(n,t,o){return o._v[0]=n._v[0]-t._v[0],o._v[1]=n._v[1]-t._v[1],o._v[2]=n._v[2]-t._v[2],o}static _multiply(n,t,o){let r=n._v[0]*t,i=n._v[1]*t,a=n._v[2]*t;return this._fromCopyArray([r,i,a],o)}static multiplyTo(n,t,o){return o._v[0]=n._v[0]*t,o._v[1]=n._v[1]*t,o._v[2]=n._v[2]*t,o}static _multiplyVector(n,t,o){let r=n._v[0]*t._v[0],i=n._v[1]*t._v[1],a=n._v[2]*t._v[2];return this._fromCopyArray([r,i,a],o)}static multiplyVectorTo(n,t,o){return o._v[0]=n._v[0]*t._v[0],o._v[1]=n._v[1]*t._v[1],o._v[2]=n._v[2]*t._v[2],o}static _multiplyMatrix4(n,t,o){let r=n._v[0],i=n._v[1],a=n._v[2],s=1/(t._v[3]*r+t._v[7]*i+t._v[11]*a+t._v[15]),l=(t._v[0]*r+t._v[4]*i+t._v[8]*a+t._v[12])*s,c=(t._v[1]*r+t._v[5]*i+t._v[9]*a+t._v[13])*s,u=(t._v[2]*r+t._v[6]*i+t._v[10]*a+t._v[14])*s;return this._fromCopyArray([l,c,u],o)}static _divide(n,t,o){let r,i,a;return t!==0?(r=n._v[0]/t,i=n._v[1]/t,a=n._v[2]/t):(N.error("0 division occurred!"),r=1/0,i=1/0,a=1/0),this._fromCopyArray([r,i,a],o)}static divideTo(n,t,o){return t!==0?(o._v[0]=n._v[0]/t,o._v[1]=n._v[1]/t,o._v[2]=n._v[2]/t):(N.error("0 division occurred!"),o._v[0]=1/0,o._v[1]=1/0,o._v[2]=1/0),o}static _divideVector(n,t,o){let r,i,a;return t._v[0]!==0&&t._v[1]!==0&&t._v[2]!==0?(r=n._v[0]/t._v[0],i=n._v[1]/t._v[1],a=n._v[2]/t._v[2]):(N.error("0 division occurred!"),r=t._v[0]===0?1/0:n._v[0]/t._v[0],i=t._v[1]===0?1/0:n._v[1]/t._v[1],a=t._v[2]===0?1/0:n._v[2]/t._v[2]),this._fromCopyArray([r,i,a],o)}static divideVectorTo(n,t,o){return t._v[0]!==0&&t._v[1]!==0&&t._v[2]!==0?(o._v[0]=n._v[0]/t._v[0],o._v[1]=n._v[1]/t._v[1],o._v[2]=n._v[2]/t._v[2]):(N.error("0 division occurred!"),o._v[0]=t._v[0]===0?1/0:n._v[0]/t._v[0],o._v[1]=t._v[1]===0?1/0:n._v[1]/t._v[1],o._v[2]=t._v[2]===0?1/0:n._v[2]/t._v[2]),o}static dot(n,t){return n.dot(t)}static _cross(n,t,o){let r=n._v[1]*t._v[2]-n._v[2]*t._v[1],i=n._v[2]*t._v[0]-n._v[0]*t._v[2],a=n._v[0]*t._v[1]-n._v[1]*t._v[0];return this._fromCopyArray([r,i,a],o)}static crossTo(n,t,o){let r=n._v[1]*t._v[2]-n._v[2]*t._v[1],i=n._v[2]*t._v[0]-n._v[0]*t._v[2],a=n._v[0]*t._v[1]-n._v[1]*t._v[0];return o.setComponents(r,i,a)}static _multiplyQuaternion(n,t,o){let r=n._v[0]*2,i=n._v[1]*2,a=n._v[2]*2,s=n._v[0]*r,l=n._v[1]*i,c=n._v[2]*a,u=n._v[0]*i,_=n._v[0]*a,d=n._v[1]*a,p=n._v[3]*r,x=n._v[3]*i,v=n._v[3]*a,y=(1-(l+c))*t._v[0]+(u-v)*t._v[1]+(_+x)*t._v[2],g=(u+v)*t._v[0]+(1-(s+c))*t._v[1]+(d-p)*t._v[2],E=(_-x)*t._v[0]+(d+p)*t._v[1]+(1-(s+l))*t._v[2];return this._fromCopyArray([y,g,E],o)}static multiplyQuaternionTo(n,t,o){let r=n._v[0]*2,i=n._v[1]*2,a=n._v[2]*2,s=n._v[0]*r,l=n._v[1]*i,c=n._v[2]*a,u=n._v[0]*i,_=n._v[0]*a,d=n._v[1]*a,p=n._v[3]*r,x=n._v[3]*i,v=n._v[3]*a,y=(1-(l+c))*t._v[0]+(u-v)*t._v[1]+(_+x)*t._v[2],g=(u+v)*t._v[0]+(1-(s+c))*t._v[1]+(d-p)*t._v[2],E=(_-x)*t._v[0]+(d+p)*t._v[1]+(1-(s+l))*t._v[2];return o.setComponents(y,g,E)}toString(){return"("+this._v[0]+", "+this._v[1]+", "+this._v[2]+")"}toStringApproximately(){return Y.financial(this._v[0])+" "+Y.financial(this._v[1])+" "+Y.financial(this._v[2])+`
`}flattenAsArray(){return[this._v[0],this._v[1],this._v[2]]}isDummy(){return this._v.length===0}isEqual(n,t=Number.EPSILON){return Math.abs(n._v[0]-this._v[0])<t&&Math.abs(n._v[1]-this._v[1])<t&&Math.abs(n._v[2]-this._v[2])<t}isStrictEqual(n){return this._v[0]===n._v[0]&&this._v[1]===n._v[1]&&this._v[2]===n._v[2]}at(n){return this._v[n]}length(){return Math.hypot(this._v[0],this._v[1],this._v[2])}lengthSquared(){return this._v[0]**2+this._v[1]**2+this._v[2]**2}lengthTo(n){let t=this._v[0]-n._v[0],o=this._v[1]-n._v[1],r=this._v[2]-n._v[2];return Math.hypot(t,o,r)}dot(n){return this._v[0]*n._v[0]+this._v[1]*n._v[1]+this._v[2]*n._v[2]}get className(){return"Vector3"}clone(){return new this.constructor(new this._v.constructor([this._v[0],this._v[1],this._v[2]],0,0))}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}static _lerp(n,t,o,r){return new this(new r([n._v[0]*(1-o)+t._v[0]*o,n._v[1]*(1-o)+t._v[1]*o,n._v[2]*(1-o)+t._v[2]*o]),{type:r})}static _fromCopyArray3(n,t){return new this(new t(n),{type:t})}static _fromCopy3(n,t,o,r){return new this(new r([n,t,o]),{type:r})}static _fromCopyArray(n,t){return new this(new t(n.slice(0,3)),{type:t})}static _fromCopyVector3(n,t){return new this(new t([n._v[0],n._v[1],n._v[2]]),{type:t})}static _fromCopyVector4(n,t){return new this(new t([n._v[0],n._v[1],n._v[2]]),{type:t})}static _fromVector2(n,t){return new this(new t([n._v[0],n._v[1],0]),{type:t})}};h(__,"Vector3_");Wi=__,ja=class ja extends Wi{constructor(n){super(n,{type:Float32Array})}static fromCopyArray3(n){return super._fromCopyArray3(n,Float32Array)}static fromCopy3(n,t,o){return super._fromCopy3(n,t,o,Float32Array)}static fromCopy1(n){return super._fromCopy3(n,n,n,Float32Array)}static fromCopyArray(n){return super._fromCopyArray(n,Float32Array)}static fromCopyVector3(n){return super._fromCopyVector3(n,Float32Array)}static fromCopyVector4(n){return super._fromCopyVector4(n,Float32Array)}static fromArrayBuffer(n){return new ja(new Float32Array(n))}static fromFloat32Array(n){return new ja(n)}static fromCopyFloat32Array(n){return new ja(n.slice(0))}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(n){return super._normalize(n,Float32Array)}static add(n,t){return super._add(n,t,Float32Array)}static subtract(n,t){return super._subtract(n,t,Float32Array)}static multiply(n,t){return super._multiply(n,t,Float32Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float32Array)}static multiplyMatrix4(n,t){return super._multiplyMatrix4(n,t,Float32Array)}static divide(n,t){return super._divide(n,t,Float32Array)}static divideVector(n,t){return super._divideVector(n,t,Float32Array)}static cross(n,t){return super._cross(n,t,Float32Array)}static multiplyQuaternion(n,t){return super._multiplyQuaternion(n,t,Float32Array)}static lerp(n,t,o){return super._lerp(n,t,o,Float32Array)}};h(ja,"Vector3");S=ja,Il=class Il extends Wi{constructor(n){super(n,{type:Float64Array})}static fromCopyArray3(n){return super._fromCopyArray3(n,Float64Array)}static fromCopy3(n,t,o){return super._fromCopy3(n,t,o,Float64Array)}static fromCopy1(n){return super._fromCopy3(n,n,n,Float64Array)}static fromCopyArray(n){return super._fromCopyArray(n,Float64Array)}static fromArrayBuffer(n){return new Il(new Float64Array(n))}static fromFloat64Array(n){return new Il(n)}static zero(){return super._zero(Float64Array)}static one(){return super._one(Float64Array)}static dummy(){return super._dummy(Float64Array)}static normalize(n){return super._normalize(n,Float64Array)}static add(n,t){return super._add(n,t,Float64Array)}static subtract(n,t){return super._subtract(n,t,Float64Array)}static multiply(n,t){return super._multiply(n,t,Float64Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float64Array)}static multiplyMatrix4(n,t){return super._multiplyMatrix4(n,t,Float64Array)}static divide(n,t){return super._divide(n,t,Float64Array)}static divideVector(n,t){return super._divideVector(n,t,Float64Array)}static cross(n,t){return super._cross(n,t,Float64Array)}static multiplyQuaternion(n,t){return super._multiplyQuaternion(n,t,Float64Array)}static lerp(n,t,o){return super._lerp(n,t,o,Float64Array)}};h(Il,"Vector3d");m_=Il,kC=S.fromCopy3(1,1,1),WC=S.fromCopy3(0,0,0)});var h_,Tl,Qi,L,Sl,d_,Ot=C(()=>{"use strict";ye();me();h_=class h_ extends Wi{constructor(n,{type:t}){super(n,{type:t})}set x(n){this._v[0]=n}get x(){return this._v[0]}set y(n){this._v[1]=n}get y(){return this._v[1]}set z(n){this._v[2]=n}get z(){return this._v[2]}get w(){return 1}raw(){return this._v}setAt(n,t){return this._v[n]=t,this}setComponents(n,t,o){return this._v[0]=n,this._v[1]=t,this._v[2]=o,this}copyComponents(n){return this.setComponents(n._v[0],n._v[1],n._v[2])}zero(){return this.setComponents(0,0,0)}one(){return this.setComponents(1,1,1)}normalize(){let n=this.length();return this.divide(n),this}add(n){return this._v[0]+=n._v[0],this._v[1]+=n._v[1],this._v[2]+=n._v[2],this}subtract(n){return this._v[0]-=n._v[0],this._v[1]-=n._v[1],this._v[2]-=n._v[2],this}multiply(n){return this._v[0]*=n,this._v[1]*=n,this._v[2]*=n,this}multiplyVector(n){return this._v[0]*=n._v[0],this._v[1]*=n._v[1],this._v[2]*=n._v[2],this}divide(n){return n!==0?(this._v[0]/=n,this._v[1]/=n,this._v[2]/=n):(N.error("0 division occurred!"),this._v[0]=1/0,this._v[1]=1/0,this._v[2]=1/0),this}divideVector(n){return n._v[0]!==0&&n._v[1]!==0&&n._v[2]!==0?(this._v[0]/=n._v[0],this._v[1]/=n._v[1],this._v[2]/=n._v[2]):(N.error("0 division occurred!"),this._v[0]=n._v[0]===0?1/0:this._v[0]/n._v[0],this._v[1]=n._v[1]===0?1/0:this._v[1]/n._v[1],this._v[2]=n._v[2]===0?1/0:this._v[2]/n._v[2]),this}cross(n){let t=this._v[1]*n._v[2]-this._v[2]*n._v[1],o=this._v[2]*n._v[0]-this._v[0]*n._v[2],r=this._v[0]*n._v[1]-this._v[1]*n._v[0];return this.setComponents(t,o,r)}multiplyQuaternion(n){let t=n._v[0]*2,o=n._v[1]*2,r=n._v[2]*2,i=n._v[0]*t,a=n._v[1]*o,s=n._v[2]*r,l=n._v[0]*o,c=n._v[0]*r,u=n._v[1]*r,_=n._v[3]*t,d=n._v[3]*o,p=n._v[3]*r,x=(1-(a+s))*this._v[0]+(l-p)*this._v[1]+(c+d)*this._v[2],v=(l+p)*this._v[0]+(1-(i+s))*this._v[1]+(u-_)*this._v[2],y=(c-d)*this._v[0]+(u+_)*this._v[1]+(1-(i+a))*this._v[2];return this.setComponents(x,v,y)}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}static _fromCopy3(n,t,o,r){return new this(new r([n,t,o]),{type:r})}};h(h_,"MutableVector3_");Tl=h_,Qi=class Qi extends Tl{constructor(n){super(n,{type:Float32Array})}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(n){return super._normalize(n,Float32Array)}static add(n,t){return super._add(n,t,Float32Array)}static subtract(n,t){return super._subtract(n,t,Float32Array)}static multiply(n,t){return super._multiply(n,t,Float32Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float32Array)}static divide(n,t){return super._divide(n,t,Float32Array)}static divideVector(n,t){return super._divideVector(n,t,Float32Array)}static cross(n,t){return super._cross(n,t,Float32Array)}static multiplyQuaternion(n,t){return super._multiplyQuaternion(n,t,Float32Array)}get className(){return"MutableVector3"}static fromCopy3(n,t,o){return super._fromCopy3(n,t,o,Float32Array)}static fromCopy1(n){return super._fromCopy3(n,n,n,Float32Array)}static fromCopyArray3(n){return new Qi(new Float32Array(n))}static fromCopyArray(n){return new Qi(new Float32Array(n.slice(0,3)))}static fromFloat32Array(n){return new Qi(n)}static fromCopyFloat32Array(n){return new Qi(new Float32Array(n.buffer.slice(0)))}static fromCopyVector3(n){return super._fromCopyVector3(n,Float32Array)}static fromCopyVector4(n){return super._fromCopyVector4(n,Float32Array)}clone(){return super.clone()}static rotateX(n,t,o){let r=Math.cos(t),i=Math.sin(t);o.y=n.y*r-n.z*i,o.z=n.y*i+n.z*r}static rotateY(n,t,o){let r=Math.cos(t),i=Math.sin(t);o.x=n.x*r+n.z*i,o.z=-n.x*i+n.z*r}static rotateZ(n,t,o){let r=Math.cos(t),i=Math.sin(t);o.x=n.x*r-n.y*i,o.y=n.x*i+n.y*r}};h(Qi,"MutableVector3");L=Qi,Sl=class Sl extends Tl{constructor(n){super(n,{type:Float64Array})}static zero(){return super._zero(Float64Array)}static one(){return super._one(Float64Array)}static dummy(){return super._dummy(Float64Array)}static normalize(n){return super._normalize(n,Float64Array)}static add(n,t){return super._add(n,t,Float64Array)}static subtract(n,t){return super._subtract(n,t,Float64Array)}static multiply(n,t){return super._multiply(n,t,Float64Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float64Array)}static divide(n,t){return super._divide(n,t,Float64Array)}static divideVector(n,t){return super._divideVector(n,t,Float64Array)}static cross(n,t){return super._cross(n,t,Float64Array)}static multiplyQuaternion(n,t){return super._multiplyQuaternion(n,t,Float64Array)}static fromCopy3(n,t,o){return super._fromCopy3(n,t,o,Float64Array)}static fromCopy1(n){return super._fromCopy3(n,n,n,Float64Array)}static fromCopyArray3(n){return new Sl(new Float64Array(n))}static fromCopyArray(n){return new Sl(new Float64Array(n.slice(0,3)))}static rotateX(n,t,o){let r=Math.cos(t),i=Math.sin(t);o.y=n.y*r-n.z*i,o.z=n.y*i+n.z*r}static rotateY(n,t,o){let r=Math.cos(t),i=Math.sin(t);o.x=n.x*r+n.z*i,o.z=-n.x*i+n.z*r}static rotateZ(n,t,o){let r=Math.cos(t),i=Math.sin(t);o.x=n.x*r-n.y*i,o.y=n.x*i+n.y*r}clone(){return super.clone()}};h(Sl,"MutableVector3d");d_=Sl});var Ie,jt,pi=C(()=>{"use strict";ye();Ot();nn();Ie=class Ie{constructor(){f(this,"__min",L.fromCopyArray([Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE]));f(this,"__max",L.fromCopyArray([-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE]));f(this,"__centerPoint",L.zero());f(this,"__lengthCenterToCorner",0);f(this,"__isCenterPointDirty",!1);f(this,"__isLengthCenterToCornerDirty",!1);f(this,"__isVanilla",!0)}clone(){let n=new Ie;return n.__max=this.__max.clone(),n.__min=this.__min.clone(),n.__centerPoint=this.__centerPoint.clone(),n.__lengthCenterToCorner=this.__lengthCenterToCorner,n.__isCenterPointDirty=this.__isCenterPointDirty,n.__isLengthCenterToCornerDirty=this.__isLengthCenterToCornerDirty,n.__isVanilla=this.__isVanilla,n}copyComponents(n){return this.__max.copyComponents(n.__max),this.__min.copyComponents(n.__min),this.__centerPoint.copyComponents(n.__centerPoint),this.__lengthCenterToCorner=n.__lengthCenterToCorner,this.__isCenterPointDirty=n.__isCenterPointDirty,this.__isLengthCenterToCornerDirty=n.__isLengthCenterToCornerDirty,this.__isVanilla=!1,this}initialize(){this.__min.setComponents(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.__max.setComponents(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this.__centerPoint.zero(),this.__lengthCenterToCorner=0,this.__isCenterPointDirty=!1,this.__isLengthCenterToCornerDirty=!1,this.__isVanilla=!0}set minPoint(n){this.__min.copyComponents(n),this.__isCenterPointDirty=!0,this.__isLengthCenterToCornerDirty=!0,this.__isVanilla=!1}get minPoint(){return this.__min}set maxPoint(n){this.__max.copyComponents(n),this.__isCenterPointDirty=!0,this.__isLengthCenterToCornerDirty=!0,this.__isVanilla=!1}get maxPoint(){return this.__max}isVanilla(){return this.__isVanilla}addPosition(n){return this.__min.x=n.x<this.__min.x?n.x:this.__min.x,this.__min.y=n.y<this.__min.y?n.y:this.__min.y,this.__min.z=n.z<this.__min.z?n.z:this.__min.z,this.__max.x=this.__max.x<n.x?n.x:this.__max.x,this.__max.y=this.__max.y<n.y?n.y:this.__max.y,this.__max.z=this.__max.z<n.z?n.z:this.__max.z,this.__isCenterPointDirty=!0,this.__isLengthCenterToCornerDirty=!0,this.__isVanilla=!1,n}addPositionWithArray(n,t){return this.__min.x=n[t+0]<this.__min.x?n[t+0]:this.__min.x,this.__min.y=n[t+1]<this.__min.y?n[t+1]:this.__min.y,this.__min.z=n[t+2]<this.__min.z?n[t+2]:this.__min.z,this.__max.x=this.__max.x<n[t+0]?n[t+0]:this.__max.x,this.__max.y=this.__max.y<n[t+1]?n[t+1]:this.__max.y,this.__max.z=this.__max.z<n[t+2]?n[t+2]:this.__max.z,this.__isCenterPointDirty=!0,this.__isLengthCenterToCornerDirty=!0,this.__isVanilla=!1,n}mergeAABB(n){return n.isVanilla()?!1:(this.__isCenterPointDirty=!0,this.__isLengthCenterToCornerDirty=!0,this.isVanilla()?(this.__min.copyComponents(n.minPoint),this.__max.copyComponents(n.maxPoint),this.__isVanilla=!1,!0):(n.minPoint.x<this.__min.x&&(this.__min.x=n.minPoint.x),n.minPoint.y<this.__min.y&&(this.__min.y=n.minPoint.y),n.minPoint.z<this.__min.z&&(this.__min.z=n.minPoint.z),this.__max.x<n.maxPoint.x&&(this.__max.x=n.maxPoint.x),this.__max.y<n.maxPoint.y&&(this.__max.y=n.maxPoint.y),this.__max.z<n.maxPoint.z&&(this.__max.z=n.maxPoint.z),!0))}get centerPoint(){return this.__isCenterPointDirty&&(L.addTo(this.__min,this.__max,this.__centerPoint).divide(2),this.__isCenterPointDirty=!1),this.__centerPoint}get lengthCenterToCorner(){return this.__isLengthCenterToCornerDirty&&(this.__lengthCenterToCorner=S.lengthBtw(this.centerPoint,this.maxPoint),this.__isLengthCenterToCornerDirty=!1),this.__lengthCenterToCorner}get sizeX(){return this.__max.x-this.__min.x}get sizeY(){return this.__max.y-this.__min.y}get sizeZ(){return this.__max.z-this.__min.z}static multiplyMatrixTo(n,t,o){return t.isVanilla()?o.copyComponents(t):(o.initialize(),Ie.__tmpVector3.x=t.__min.x,Ie.__tmpVector3.y=t.__min.y,Ie.__tmpVector3.z=t.__min.z,n.multiplyVector3To(Ie.__tmpVector3,Ie.__tmpVector3),o.addPosition(Ie.__tmpVector3),Ie.__tmpVector3.x=t.__max.x,Ie.__tmpVector3.y=t.__min.y,Ie.__tmpVector3.z=t.__min.z,n.multiplyVector3To(Ie.__tmpVector3,Ie.__tmpVector3),o.addPosition(Ie.__tmpVector3),Ie.__tmpVector3.x=t.__min.x,Ie.__tmpVector3.y=t.__max.y,Ie.__tmpVector3.z=t.__min.z,n.multiplyVector3To(Ie.__tmpVector3,Ie.__tmpVector3),o.addPosition(Ie.__tmpVector3),Ie.__tmpVector3.x=t.__min.x,Ie.__tmpVector3.y=t.__min.y,Ie.__tmpVector3.z=t.__max.z,n.multiplyVector3To(Ie.__tmpVector3,Ie.__tmpVector3),o.addPosition(Ie.__tmpVector3),Ie.__tmpVector3.x=t.__min.x,Ie.__tmpVector3.y=t.__max.y,Ie.__tmpVector3.z=t.__max.z,n.multiplyVector3To(Ie.__tmpVector3,Ie.__tmpVector3),o.addPosition(Ie.__tmpVector3),Ie.__tmpVector3.x=t.__max.x,Ie.__tmpVector3.y=t.__min.y,Ie.__tmpVector3.z=t.__max.z,n.multiplyVector3To(Ie.__tmpVector3,Ie.__tmpVector3),o.addPosition(Ie.__tmpVector3),Ie.__tmpVector3.x=t.__max.x,Ie.__tmpVector3.y=t.__max.y,Ie.__tmpVector3.z=t.__min.z,n.multiplyVector3To(Ie.__tmpVector3,Ie.__tmpVector3),o.addPosition(Ie.__tmpVector3),Ie.__tmpVector3.x=t.__max.x,Ie.__tmpVector3.y=t.__max.y,Ie.__tmpVector3.z=t.__max.z,n.multiplyVector3To(Ie.__tmpVector3,Ie.__tmpVector3),o.addPosition(Ie.__tmpVector3),o)}toString(){return"AABB_min: "+this.__min+`
AABB_max: `+this.__max+`
centerPoint: `+this.__centerPoint+`
lengthCenterToCorner: `+this.__lengthCenterToCorner}toStringApproximately(){return"AABB_max: "+this.__max.toStringApproximately()+`
AABB_min: `+this.__min.toStringApproximately()+`
centerPoint: `+this.centerPoint.toStringApproximately()+`
lengthCenterToCorner: `+Y.financial(this.lengthCenterToCorner)}};h(Ie,"AABB"),f(Ie,"__tmpVector3",L.zero());jt=Ie});var p_,Xi,ou=C(()=>{"use strict";pi();ye();p_=class p_{constructor(){f(this,"zNearMax",.1);f(this,"zFarScalingFactor",1e5);f(this,"autoCalculateZNearAndZFar",!0)}_calcZNearInner(n,t,o){if(this.autoCalculateZNearAndZFar&&this.__targetEntities.length>0){let r=new jt;for(let _ of this.__targetEntities)r.mergeAABB(_.getSceneGraph().worldMergedAABBWithSkeletal);let i=r,a=S.lengthBtw(t,i.centerPoint),s=i.centerPoint.x-t.x,l=i.centerPoint.y-t.y,c=i.centerPoint.z-t.z,u=(s*o.x+l*o.y+c*o.z)/(Math.hypot(s,l,c)*o.length());n.zNearInner=Math.max(Math.min(a*u-i.lengthCenterToCorner,this.zNearMax),.01)}else n.zNearInner=n.zNear}_calcZFarInner(n){this.autoCalculateZNearAndZFar?n.zFarInner=n.zNearInner*this.zFarScalingFactor:n.zNearInner=n.zFar}};h(p_,"AbstractCameraController");Xi=p_});var x_,Wo,Hi=C(()=>{"use strict";x_=class x_{constructor(){f(this,"_v",new Float32Array)}at(n,t){throw new Error("Method not implemented.")}toString(){throw new Error("Method not implemented.")}toStringApproximately(){throw new Error("Method not implemented.")}flattenAsArray(){throw new Error("Method not implemented.")}isDummy(){return this._v.length===0}v(n){return this._v[n]}determinant(){throw new Error("Method not implemented.")}get className(){return this.constructor.name}get isIdentityMatrixClass(){return!1}isTheSourceSame(n){return this._v.buffer===n}};h(x_,"AbstractMatrix");Wo=x_});var qi,El,v_=C(()=>{"use strict";se();Hi();ye();qi=class qi extends Wo{constructor(){super(),this._v=qi.__v}toString(){return`1 0 0
0 1 0
0 0 1
`}toStringApproximately(){return this.toString()}flattenAsArray(){return[1,0,0,0,1,0,0,0,1]}isDummy(){return!1}isEqual(n,t=Number.EPSILON){return Math.abs(n.m00-1)<t&&Math.abs(n.m10)<t&&Math.abs(n.m20)<t&&Math.abs(n.m01)<t&&Math.abs(n.m11-1)<t&&Math.abs(n.m21)<t&&Math.abs(n.m02)<t&&Math.abs(n.m12)<t&&Math.abs(n.m22-1)<t}isStrictEqual(n){let t=n._v;return t[0]===1&&t[1]===0&&t[2]===0&&t[3]===0&&t[4]===0&&t[5]===0&&t[6]===0&&t[7]===0&&t[8]===0&&t[9]===0&&t[10]===0&&t[11]===0&&t[12]===0&&t[13]===0&&t[14]===0&&t[15]===0}at(n,t){return n===t?1:0}determinant(){return 1}multiplyVector(n){return n}multiplyVectorTo(n,t){let o=n._v;return t._v[0]=o[0],t._v[1]=o[1],t._v[2]=o[2],t._v[3]=o[3],t}getScale(){return S.fromCopyArray([1,1,1])}getScaleTo(n){let t=n._v;return t[0]=1,t[1]=1,t[2]=1,n}clone(){return new qi}getRotate(){return new qi}get m00(){return 1}get m10(){return 0}get m20(){return 0}get m30(){return 0}get m01(){return 0}get m11(){return 1}get m21(){return 0}get m31(){return 0}get m02(){return 0}get m12(){return 0}get m22(){return 1}get m32(){return 0}get m03(){return 0}get m13(){return 0}get m23(){return 0}get m33(){return 1}get className(){return"IdentityMatrix33"}static get compositionType(){return b.Mat3}get isIdentityMatrixClass(){return!0}};h(qi,"IdentityMatrix33"),f(qi,"__v",new Float32Array([1,0,0,0,1,0,0,0,1]));El=qi});var Qt,Ut,ji=C(()=>{"use strict";ye();se();nn();Hi();v_();me();Qt=class Qt extends Wo{constructor(n){super(),this._v=n}get m00(){return this._v[0]}get m10(){return this._v[1]}get m20(){return this._v[2]}get m01(){return this._v[3]}get m11(){return this._v[4]}get m21(){return this._v[5]}get m02(){return this._v[6]}get m12(){return this._v[7]}get m22(){return this._v[8]}get className(){return"Matrix33"}static get compositionType(){return b.Mat3}static zero(){return Qt.fromCopy9RowMajor(0,0,0,0,0,0,0,0,0)}static identity(){return new El}static dummy(){return new this(new Float32Array(0))}static transpose(n){return n.isIdentityMatrixClass?n:Qt.fromCopy9RowMajor(n._v[0],n._v[1],n._v[2],n._v[3],n._v[4],n._v[5],n._v[6],n._v[7],n._v[8])}static invert(n){if(n.isIdentityMatrixClass)return n;let t=n.determinant();t===0&&N.error("the determinant is 0!");let o=(n._v[4]*n._v[8]-n._v[7]*n._v[5])/t,r=(n._v[6]*n._v[5]-n._v[3]*n._v[8])/t,i=(n._v[3]*n._v[7]-n._v[6]*n._v[4])/t,a=(n._v[7]*n._v[2]-n._v[1]*n._v[8])/t,s=(n._v[0]*n._v[8]-n._v[6]*n._v[2])/t,l=(n._v[6]*n._v[1]-n._v[0]*n._v[7])/t,c=(n._v[1]*n._v[5]-n._v[4]*n._v[2])/t,u=(n._v[3]*n._v[2]-n._v[0]*n._v[5])/t,_=(n._v[0]*n._v[4]-n._v[3]*n._v[1])/t;return Qt.fromCopy9RowMajor(o,r,i,a,s,l,c,u,_)}static invertTo(n,t){if(n.isIdentityMatrixClass)return t.copyComponents(n);let o=n.determinant();o===0&&N.error("the determinant is 0!");let r=(n._v[4]*n._v[8]-n._v[7]*n._v[5])/o,i=(n._v[6]*n._v[5]-n._v[3]*n._v[8])/o,a=(n._v[3]*n._v[7]-n._v[6]*n._v[4])/o,s=(n._v[7]*n._v[2]-n._v[1]*n._v[8])/o,l=(n._v[0]*n._v[8]-n._v[6]*n._v[2])/o,c=(n._v[6]*n._v[1]-n._v[0]*n._v[7])/o,u=(n._v[1]*n._v[5]-n._v[4]*n._v[2])/o,_=(n._v[3]*n._v[2]-n._v[0]*n._v[5])/o,d=(n._v[0]*n._v[4]-n._v[3]*n._v[1])/o;return t.setComponents(r,i,a,s,l,c,u,_,d)}static rotateX(n){let t=Math.cos(n),o=Math.sin(n);return Qt.fromCopy9RowMajor(1,0,0,0,t,-o,0,o,t)}static rotateY(n){let t=Math.cos(n),o=Math.sin(n);return Qt.fromCopy9RowMajor(t,0,o,0,1,0,-o,0,t)}static rotateZ(n){let t=Math.cos(n),o=Math.sin(n);return Qt.fromCopy9RowMajor(t,-o,0,o,t,0,0,0,1)}static rotateXYZ(n,t,o){let r=Math.cos(n),i=Math.sin(n),a=Math.cos(t),s=Math.sin(t),l=Math.cos(o),c=Math.sin(o),u=r,_=-i,d=i,p=r,x=a,v=s,y=-s,g=a,E=l,w=-c,T=c,R=l,P=x,V=v*d,z=v*p,k=u,W=_,X=y,j=g*d,ae=g*p,le=E*P,ze=E*V+w*k,At=E*z+w*W,Be=T*P,Fn=T*V+R*k,Sn=T*z+R*W,cn=X,Dr=j,Br=ae;return Qt.fromCopy9RowMajor(le,ze,At,Be,Fn,Sn,cn,Dr,Br)}static rotate(n){return this.rotateXYZ(n._v[0],n._v[1],n._v[2])}static scale(n){return Qt.fromCopy9RowMajor(n._v[0],0,0,0,n._v[1],0,0,0,n._v[2])}static multiply(n,t){if(n.isIdentityMatrixClass)return t;if(t.isIdentityMatrixClass)return n;let o=n._v[0]*t._v[0]+n._v[3]*t._v[1]+n._v[6]*t._v[2],r=n._v[1]*t._v[0]+n._v[4]*t._v[1]+n._v[7]*t._v[2],i=n._v[2]*t._v[0]+n._v[5]*t._v[1]+n._v[8]*t._v[2],a=n._v[0]*t._v[3]+n._v[3]*t._v[4]+n._v[6]*t._v[5],s=n._v[1]*t._v[3]+n._v[4]*t._v[4]+n._v[7]*t._v[5],l=n._v[2]*t._v[3]+n._v[5]*t._v[4]+n._v[8]*t._v[5],c=n._v[0]*t._v[6]+n._v[3]*t._v[7]+n._v[6]*t._v[8],u=n._v[1]*t._v[6]+n._v[4]*t._v[7]+n._v[7]*t._v[8],_=n._v[2]*t._v[6]+n._v[5]*t._v[7]+n._v[8]*t._v[8];return Qt.fromCopy9RowMajor(o,a,c,r,s,u,i,l,_)}static multiplyTo(n,t,o){if(n.isIdentityMatrixClass)return o.copyComponents(t);if(t.isIdentityMatrixClass)return o.copyComponents(n);let r=n._v[0]*t._v[0]+n._v[3]*t._v[1]+n._v[6]*t._v[2],i=n._v[1]*t._v[0]+n._v[4]*t._v[1]+n._v[7]*t._v[2],a=n._v[2]*t._v[0]+n._v[5]*t._v[1]+n._v[8]*t._v[2],s=n._v[0]*t._v[3]+n._v[3]*t._v[4]+n._v[6]*t._v[5],l=n._v[1]*t._v[3]+n._v[4]*t._v[4]+n._v[7]*t._v[5],c=n._v[2]*t._v[3]+n._v[5]*t._v[4]+n._v[8]*t._v[5],u=n._v[0]*t._v[6]+n._v[3]*t._v[7]+n._v[6]*t._v[8],_=n._v[1]*t._v[6]+n._v[4]*t._v[7]+n._v[7]*t._v[8],d=n._v[2]*t._v[6]+n._v[5]*t._v[7]+n._v[8]*t._v[8];return o.setComponents(r,s,u,i,l,_,a,c,d)}toString(){return this._v[0]+" "+this._v[3]+" "+this._v[6]+`
`+this._v[1]+" "+this._v[4]+" "+this._v[7]+`
`+this._v[2]+" "+this._v[5]+" "+this._v[8]+`
`}toStringApproximately(){return Y.financial(this._v[0])+" "+Y.financial(this._v[3])+" "+Y.financial(this._v[6])+`
`+Y.financial(this._v[1])+" "+Y.financial(this._v[4])+" "+Y.financial(this._v[7])+` 
`+Y.financial(this._v[2])+" "+Y.financial(this._v[5])+" "+Y.financial(this._v[8])+`
`}flattenAsArray(){return[this._v[0],this._v[1],this._v[2],this._v[3],this._v[4],this._v[5],this._v[6],this._v[7],this._v[8]]}isDummy(){return this._v.length===0}isEqual(n,t=Number.EPSILON){return Math.abs(n._v[0]-this._v[0])<t&&Math.abs(n._v[1]-this._v[1])<t&&Math.abs(n._v[2]-this._v[2])<t&&Math.abs(n._v[3]-this._v[3])<t&&Math.abs(n._v[4]-this._v[4])<t&&Math.abs(n._v[5]-this._v[5])<t&&Math.abs(n._v[6]-this._v[6])<t&&Math.abs(n._v[7]-this._v[7])<t&&Math.abs(n._v[8]-this._v[8])<t}isStrictEqual(n){return n._v[0]===this._v[0]&&n._v[1]===this._v[1]&&n._v[2]===this._v[2]&&n._v[3]===this._v[3]&&n._v[4]===this._v[4]&&n._v[5]===this._v[5]&&n._v[6]===this._v[6]&&n._v[7]===this._v[7]&&n._v[8]===this._v[8]}at(n,t){return this._v[n+t*3]}v(n){return this._v[n]}determinant(){return this._v[0]*this._v[4]*this._v[8]+this._v[1]*this._v[5]*this._v[6]+this._v[2]*this._v[3]*this._v[7]-this._v[0]*this._v[5]*this._v[7]-this._v[2]*this._v[4]*this._v[6]-this._v[1]*this._v[3]*this._v[8]}multiplyVector(n){let t=this._v[0]*n._v[0]+this._v[3]*n._v[1]+this._v[6]*n._v[2],o=this._v[1]*n._v[0]+this._v[4]*n._v[1]+this._v[7]*n._v[2],r=this._v[2]*n._v[0]+this._v[5]*n._v[1]+this._v[8]*n._v[2];return new n.constructor(new Float32Array([t,o,r]))}multiplyVectorTo(n,t){let o=this._v[0]*n._v[0]+this._v[3]*n._v[1]+this._v[6]*n._v[2],r=this._v[1]*n._v[0]+this._v[4]*n._v[1]+this._v[7]*n._v[2],i=this._v[2]*n._v[0]+this._v[5]*n._v[1]+this._v[8]*n._v[2];return t._v[0]=o,t._v[1]=r,t._v[2]=i,t}getScale(){return S.fromCopyArray([Math.hypot(this._v[0],this._v[1],this._v[2]),Math.hypot(this._v[3],this._v[4],this._v[5]),Math.hypot(this._v[6],this._v[7],this._v[8])])}getScaleTo(n){return n._v[0]=Math.hypot(this._v[0],this._v[1],this._v[2]),n._v[1]=Math.hypot(this._v[3],this._v[4],this._v[5]),n._v[2]=Math.hypot(this._v[6],this._v[7],this._v[8]),n}clone(){return this.constructor.fromCopy9RowMajor(this._v[0],this._v[3],this._v[6],this._v[1],this._v[4],this._v[7],this._v[2],this._v[5],this._v[8])}static fromCopy9RowMajor(n,t,o,r,i,a,s,l,c){let u=new Float32Array(9);return u[0]=n,u[3]=t,u[6]=o,u[1]=r,u[4]=i,u[7]=a,u[2]=s,u[5]=l,u[8]=c,new Qt(u)}static fromCopy9ColumnMajor(n,t,o,r,i,a,s,l,c){let u=new Float32Array(9);return u[0]=n,u[3]=r,u[6]=s,u[1]=t,u[4]=i,u[7]=l,u[2]=o,u[5]=a,u[8]=c,new Qt(u)}static fromCopyMatrix44(n){let t=new Float32Array(9);return t[0]=n._v[0],t[1]=n._v[1],t[2]=n._v[2],t[3]=n._v[5],t[4]=n._v[6],t[5]=n._v[7],t[6]=n._v[9],t[7]=n._v[10],t[8]=n._v[11],new Qt(t)}static fromFloat32ArrayColumnMajor(n){return new Qt(n)}static fromCopyFloat32ArrayColumnMajor(n){let t=new Float32Array(9);return t.set(n),new Qt(t)}static fromCopyFloat32ArrayRowMajor(n){let t=new Float32Array(9);return t[0]=n[0],t[3]=n[1],t[6]=n[2],t[1]=n[3],t[4]=n[4],t[7]=n[5],t[2]=n[6],t[5]=n[7],t[8]=n[8],new Qt(t)}static fromCopyMatrix33(n){let t=new Float32Array(9);return t[0]=n._v[0],t[3]=n._v[3],t[6]=n._v[6],t[1]=n._v[1],t[4]=n._v[4],t[7]=n._v[7],t[2]=n._v[2],t[5]=n._v[5],t[8]=n._v[8],new Qt(t)}static fromCopyArray9ColumnMajor(n){let t=new Float32Array(9);return t.set(n),new Qt(t)}static fromCopyArrayColumnMajor(n){let t=new Float32Array(9);return t.set(n),new Qt(t)}static fromCopyArray9RowMajor(n){let t=new Float32Array(9);return t[0]=n[0],t[3]=n[1],t[6]=n[2],t[1]=n[3],t[4]=n[4],t[7]=n[5],t[2]=n[6],t[5]=n[7],t[8]=n[8],new Qt(t)}static fromCopyArrayRowMajor(n){let t=new Float32Array(9);return t[0]=n[0],t[3]=n[1],t[6]=n[2],t[1]=n[3],t[4]=n[4],t[7]=n[5],t[2]=n[6],t[5]=n[7],t[8]=n[8],new Qt(t)}static fromCopyQuaternion(n){let t=n._v[0]*n._v[0],o=n._v[1]*n._v[1],r=n._v[2]*n._v[2],i=n._v[1]*n._v[2],a=n._v[0]*n._v[2],s=n._v[0]*n._v[1],l=n._v[3]*n._v[0],c=n._v[3]*n._v[1],u=n._v[3]*n._v[2],_=new Float32Array(9);return _[0]=1-2*(o+r),_[3]=2*(s-u),_[6]=2*(a+c),_[1]=2*(s+u),_[4]=1-2*(t+r),_[7]=2*(i-l),_[2]=2*(a-c),_[5]=2*(i+l),_[8]=1-2*(t+o),new Qt(_)}};h(Qt,"Matrix33");Ut=Qt});var lo,We,or=C(()=>{"use strict";ji();me();lo=class lo extends Ut{constructor(n){super(n)}set m00(n){this._v[0]=n}get m00(){return this._v[0]}set m10(n){this._v[1]=n}get m10(){return this._v[1]}set m20(n){this._v[2]=n}get m20(){return this._v[2]}set m01(n){this._v[3]=n}get m01(){return this._v[3]}set m11(n){this._v[4]=n}get m11(){return this._v[4]}set m21(n){this._v[5]=n}get m21(){return this._v[5]}set m02(n){this._v[6]=n}get m02(){return this._v[6]}set m12(n){this._v[7]=n}get m12(){return this._v[7]}set m22(n){this._v[8]=n}get m22(){return this._v[8]}get className(){return"MutableMatrix33"}static zero(){return super.zero()}static identity(){return lo.fromCopy9RowMajor(1,0,0,0,1,0,0,0,1)}static dummy(){return super.dummy()}static transpose(n){return super.transpose(n)}static invert(n){return super.invert(n)}static rotateX(n){return super.rotateX(n)}static rotateY(n){return super.rotateY(n)}static rotateZ(n){return super.rotateZ(n)}static rotateXYZ(n,t,o){return super.rotateXYZ(n,t,o)}static rotate(n){return super.rotateXYZ(n._v[0],n._v[1],n._v[2])}static scale(n){return super.scale(n)}static multiply(n,t){return super.multiply(n,t)}clone(){return super.clone()}raw(){return this._v}setAt(n,t,o){return this._v[n+t*3]=o,this}setComponents(n,t,o,r,i,a,s,l,c){return this._v[0]=n,this._v[3]=t,this._v[6]=o,this._v[1]=r,this._v[4]=i,this._v[7]=a,this._v[2]=s,this._v[5]=l,this._v[8]=c,this}copyComponents(n){return this._v[0]=n.m00,this._v[3]=n.m01,this._v[6]=n.m02,this._v[1]=n.m10,this._v[4]=n.m11,this._v[7]=n.m12,this._v[2]=n.m20,this._v[5]=n.m21,this._v[8]=n.m22,this}zero(){return this.setComponents(0,0,0,0,0,0,0,0,0)}identity(){return this.setComponents(1,0,0,0,1,0,0,0,1)}_swap(n,t){this._v[t]=[this._v[n],this._v[n]=this._v[t]][0]}transpose(){return this._swap(1,3),this._swap(2,6),this._swap(5,8),this}invert(){let n=this.determinant();n===0&&N.error("the determinant is 0!");let t=(this._v[4]*this._v[8]-this._v[7]*this._v[5])/n,o=(this._v[6]*this._v[5]-this._v[3]*this._v[8])/n,r=(this._v[3]*this._v[7]-this._v[6]*this._v[4])/n,i=(this._v[7]*this._v[2]-this._v[1]*this._v[8])/n,a=(this._v[0]*this._v[8]-this._v[6]*this._v[2])/n,s=(this._v[6]*this._v[1]-this._v[0]*this._v[7])/n,l=(this._v[1]*this._v[5]-this._v[4]*this._v[2])/n,c=(this._v[3]*this._v[2]-this._v[0]*this._v[5])/n,u=(this._v[0]*this._v[4]-this._v[3]*this._v[1])/n;return this.setComponents(t,o,r,i,a,s,l,c,u)}rotateX(n){let t=Math.cos(n),o=Math.sin(n);return this.setComponents(1,0,0,0,t,-o,0,o,t)}rotateY(n){let t=Math.cos(n),o=Math.sin(n);return this.setComponents(t,0,o,0,1,0,-o,0,t)}rotateZ(n){let t=Math.cos(n),o=Math.sin(n);return this.setComponents(t,-o,0,o,t,0,0,0,1)}rotateXYZ(n,t,o){let r=Math.cos(n),i=Math.sin(n),a=Math.cos(t),s=Math.sin(t),l=Math.cos(o),c=Math.sin(o),u=r,_=-i,d=i,p=r,x=a,v=s,y=-s,g=a,E=l,w=-c,T=c,R=l,P=x,V=v*d,z=v*p,k=u,W=_,X=y,j=g*d,ae=g*p,le=E*P,ze=E*V+w*k,At=E*z+w*W,Be=T*P,Fn=T*V+R*k,Sn=T*z+R*W,cn=X,Dr=j,Br=ae;return this.setComponents(le,ze,At,Be,Fn,Sn,cn,Dr,Br)}rotate(n){return this.rotateXYZ(n._v[0],n._v[1],n._v[2])}scale(n){return this.setComponents(n._v[0],0,0,0,n._v[1],0,0,0,n._v[2])}multiplyScale(n){return this._v[0]*=n._v[0],this._v[3]*=n._v[0],this._v[6]*=n._v[0],this._v[1]*=n._v[1],this._v[4]*=n._v[1],this._v[7]*=n._v[1],this._v[2]*=n._v[2],this._v[5]*=n._v[2],this._v[8]*=n._v[2],this}multiply(n){if(n.isIdentityMatrixClass)return this;let t=this._v[0]*n._v[0]+this._v[3]*n._v[1]+this._v[6]*n._v[2],o=this._v[0]*n._v[3]+this._v[3]*n._v[4]+this._v[6]*n._v[5],r=this._v[0]*n._v[6]+this._v[3]*n._v[7]+this._v[6]*n._v[8],i=this._v[1]*n._v[0]+this._v[4]*n._v[1]+this._v[7]*n._v[2],a=this._v[1]*n._v[3]+this._v[4]*n._v[4]+this._v[7]*n._v[5],s=this._v[1]*n._v[6]+this._v[4]*n._v[7]+this._v[7]*n._v[8],l=this._v[2]*n._v[0]+this._v[5]*n._v[1]+this._v[8]*n._v[2],c=this._v[2]*n._v[3]+this._v[5]*n._v[4]+this._v[8]*n._v[5],u=this._v[2]*n._v[6]+this._v[5]*n._v[7]+this._v[8]*n._v[8];return this.setComponents(t,o,r,i,a,s,l,c,u)}multiplyByLeft(n){if(n.isIdentityMatrixClass)return this;let t=n._v[0]*this._v[0]+n._v[3]*this._v[1]+n._v[6]*this._v[2],o=n._v[0]*this._v[3]+n._v[3]*this._v[4]+n._v[6]*this._v[5],r=n._v[0]*this._v[6]+n._v[3]*this._v[7]+n._v[6]*this._v[8],i=n._v[1]*this._v[0]+n._v[4]*this._v[1]+n._v[7]*this._v[2],a=n._v[1]*this._v[3]+n._v[4]*this._v[4]+n._v[7]*this._v[5],s=n._v[1]*this._v[6]+n._v[4]*this._v[7]+n._v[7]*this._v[8],l=n._v[2]*this._v[0]+n._v[5]*this._v[1]+n._v[8]*this._v[2],c=n._v[2]*this._v[3]+n._v[5]*this._v[4]+n._v[8]*this._v[5],u=n._v[2]*this._v[6]+n._v[5]*this._v[7]+n._v[8]*this._v[8];return this.setComponents(t,o,r,i,a,s,l,c,u)}static fromCopy9RowMajor(n,t,o,r,i,a,s,l,c){let u=new Float32Array(9);return u[0]=n,u[3]=t,u[6]=o,u[1]=r,u[4]=i,u[7]=a,u[2]=s,u[5]=l,u[8]=c,new lo(u)}static fromCopy9ColumnMajor(n,t,o,r,i,a,s,l,c){let u=new Float32Array(9);return u[0]=n,u[3]=r,u[6]=s,u[1]=t,u[4]=i,u[7]=l,u[2]=o,u[5]=a,u[8]=c,new lo(u)}static fromCopyMatrix44(n){let t=new Float32Array(9);return t.set(n._v),new lo(t)}static fromFloat32ArrayColumnMajor(n){return new lo(n)}static fromCopyFloat32ArrayColumnMajor(n){let t=new Float32Array(9);return t.set(n),new lo(t)}static fromCopyFloat32ArrayRowMajor(n){let t=new Float32Array(9);return t[0]=n[0],t[3]=n[1],t[6]=n[2],t[1]=n[3],t[4]=n[4],t[7]=n[5],t[2]=n[6],t[5]=n[7],t[8]=n[8],new lo(t)}static fromCopyMatrix33(n){let t=new Float32Array(9);return t[0]=n._v[0],t[3]=n._v[3],t[6]=n._v[6],t[1]=n._v[1],t[4]=n._v[4],t[7]=n._v[7],t[2]=n._v[2],t[5]=n._v[5],t[8]=n._v[8],new lo(t)}static fromCopyArray9ColumnMajor(n){let t=new Float32Array(9);return t.set(n),new lo(t)}static fromCopyArrayColumnMajor(n){let t=new Float32Array(9);return t.set(n),new lo(t)}static fromCopyArray9RowMajor(n){let t=new Float32Array(9);return t[0]=n[0],t[3]=n[1],t[6]=n[2],t[1]=n[3],t[4]=n[4],t[7]=n[5],t[2]=n[6],t[5]=n[7],t[8]=n[8],new lo(t)}static fromCopyArrayRowMajor(n){let t=new Float32Array(9);return t[0]=n[0],t[3]=n[1],t[6]=n[2],t[1]=n[3],t[4]=n[4],t[7]=n[5],t[2]=n[6],t[5]=n[7],t[8]=n[8],new lo(t)}static fromCopyQuaternion(n){let t=n._v[0]*n._v[0],o=n._v[1]*n._v[1],r=n._v[2]*n._v[2],i=n._v[1]*n._v[2],a=n._v[0]*n._v[2],s=n._v[0]*n._v[1],l=n._v[3]*n._v[0],c=n._v[3]*n._v[1],u=n._v[3]*n._v[2],_=new Float32Array(9);return _[0]=1-2*(o+r),_[3]=2*(s-u),_[6]=2*(a+c),_[1]=2*(s+u),_[4]=1-2*(t+r),_[7]=2*(i-l),_[2]=2*(a-c),_[5]=2*(i+l),_[8]=1-2*(t+o),new lo(_)}};h(lo,"MutableMatrix33");We=lo});var y_,Yi,Ya,q,Cl,g_,QC,XC,HC,It=C(()=>{"use strict";nn();se();qa();me();y_=class y_ extends pr{constructor(n,{type:t}){super(),this._v=n}get x(){return this._v[0]}get y(){return this._v[1]}get z(){return this._v[2]}get w(){return this._v[3]}get glslStrAsFloat(){return`vec4(${Y.convertToStringAsGLSLFloat(this._v[0])}, ${Y.convertToStringAsGLSLFloat(this._v[1])}, ${Y.convertToStringAsGLSLFloat(this._v[2])}, ${Y.convertToStringAsGLSLFloat(this._v[3])})`}get glslStrAsInt(){return`ivec4(${Math.floor(this._v[0])}, ${Math.floor(this._v[1])}, ${Math.floor(this._v[2])}, ${Math.floor(this._v[3])})`}static _fromCopyArray4(n,t){return new this(new t(n),{type:t})}static _fromCopy4(n,t,o,r,i){return new this(new i([n,t,o,r]),{type:i})}static _fromCopyArray(n,t){return new this(new t(n.slice(0,4)),{type:t})}static _fromCopyVector4(n,t){return new this(new t([n._v[0],n._v[1],n._v[2],n._v[3]]),{type:t})}static _fromCopyVector3(n,t){return new this(new t([n._v[0],n._v[1],n._v[2],1]),{type:t})}static _fromVector2(n,t){return new this(new t([n._v[0],n._v[1],0,1]),{type:t})}static get compositionType(){return b.Vec4}static lengthSquared(n){return n.lengthSquared()}static lengthBtw(n,t){return n.lengthTo(t)}static _zero(n){return new this(new n([0,0,0,0]),{type:n})}static _one(n){return new this(new n([1,1,1,1]),{type:n})}static _dummy(n){return new this(new n([]),{type:n})}static _normalize(n,t){let o=n.length();return this._divide(n,o,t)}static _add(n,t,o){let r=n._v[0]+t._v[0],i=n._v[1]+t._v[1],a=n._v[2]+t._v[2],s=n._v[3]+t._v[3];return new this(new o([r,i,a,s]),{type:o})}static addTo(n,t,o){return o._v[0]=n._v[0]+t._v[0],o._v[1]=n._v[1]+t._v[1],o._v[2]=n._v[2]+t._v[2],o._v[3]=n._v[3]+t._v[3],o}static _subtract(n,t,o){let r=n._v[0]-t._v[0],i=n._v[1]-t._v[1],a=n._v[2]-t._v[2],s=n._v[3]-t._v[3];return new this(new o([r,i,a,s]),{type:o})}static subtractTo(n,t,o){return o._v[0]=n._v[0]-t._v[0],o._v[1]=n._v[1]-t._v[1],o._v[2]=n._v[2]-t._v[2],o._v[3]=n._v[3]-t._v[3],o}static _multiply(n,t,o){let r=n._v[0]*t,i=n._v[1]*t,a=n._v[2]*t,s=n._v[3]*t;return new this(new o([r,i,a,s]),{type:o})}static multiplyTo(n,t,o){return o._v[0]=n._v[0]*t,o._v[1]=n._v[1]*t,o._v[2]=n._v[2]*t,o._v[3]=n._v[3]*t,o}static _multiplyVector(n,t,o){let r=n._v[0]*t._v[0],i=n._v[1]*t._v[1],a=n._v[2]*t._v[2],s=n._v[3]*t._v[3];return new this(new o([r,i,a,s]),{type:o})}static multiplyVectorTo(n,t,o){return o._v[0]=n._v[0]*t._v[0],o._v[1]=n._v[1]*t._v[1],o._v[2]=n._v[2]*t._v[2],o._v[3]=n._v[3]*t._v[3],o}static _divide(n,t,o){let r,i,a,s;return t!==0?(r=n._v[0]/t,i=n._v[1]/t,a=n._v[2]/t,s=n._v[3]/t):(N.error("0 division occurred!"),r=1/0,i=1/0,a=1/0,s=1/0),new this(new o([r,i,a,s]),{type:o})}static divideTo(n,t,o){return t!==0?(o._v[0]=n._v[0]/t,o._v[1]=n._v[1]/t,o._v[2]=n._v[2]/t,o._v[3]=n._v[3]/t):(N.error("0 division occurred!"),o._v[0]=1/0,o._v[1]=1/0,o._v[2]=1/0,o._v[3]=1/0),o}static _divideVector(n,t,o){let r,i,a,s;return t._v[0]!==0&&t._v[1]!==0&&t._v[2]!==0&&t._v[3]!==0?(r=n._v[0]/t._v[0],i=n._v[1]/t._v[1],a=n._v[2]/t._v[2],s=n._v[3]/t._v[3]):(N.error("0 division occurred!"),r=t._v[0]===0?1/0:n._v[0]/t._v[0],i=t._v[1]===0?1/0:n._v[1]/t._v[1],a=t._v[2]===0?1/0:n._v[2]/t._v[2],s=t._v[3]===0?1/0:n._v[3]/t._v[3]),new this(new o([r,i,a,s]),{type:o})}static divideVectorTo(n,t,o){return t._v[0]!==0&&t._v[1]!==0&&t._v[2]!==0&&t._v[3]!==0?(o._v[0]=n._v[0]/t._v[0],o._v[1]=n._v[1]/t._v[1],o._v[2]=n._v[2]/t._v[2],o._v[3]=n._v[3]/t._v[3]):(N.error("0 division occurred!"),o._v[0]=t._v[0]===0?1/0:n._v[0]/t._v[0],o._v[1]=t._v[1]===0?1/0:n._v[1]/t._v[1],o._v[2]=t._v[2]===0?1/0:n._v[2]/t._v[2],o._v[3]=t._v[3]===0?1/0:n._v[3]/t._v[3]),o}static dot(n,t){return n.dot(t)}toString(){return"("+this._v[0]+", "+this._v[1]+", "+this._v[2]+", "+this._v[3]+")"}toStringApproximately(){return Y.financial(this._v[0])+" "+Y.financial(this._v[1])+" "+Y.financial(this._v[2])+" "+Y.financial(this._v[3])+`
`}flattenAsArray(){return[this._v[0],this._v[1],this._v[2],this._v[3]]}isDummy(){return this._v.length===0}isEqual(n,t=Number.EPSILON){return Math.abs(n._v[0]-this._v[0])<t&&Math.abs(n._v[1]-this._v[1])<t&&Math.abs(n._v[2]-this._v[2])<t&&Math.abs(n._v[3]-this._v[3])<t}isStrictEqual(n){return this._v[0]===n._v[0]&&this._v[1]===n._v[1]&&this._v[2]===n._v[2]&&this._v[3]===n._v[3]}at(n){return this._v[n]}length(){return Math.hypot(this._v[0],this._v[1],this._v[2],this._v[3])}lengthSquared(){return this._v[0]**2+this._v[1]**2+this._v[2]**2+this._v[3]**2}lengthTo(n){let t=this._v[0]-n._v[0],o=this._v[1]-n._v[1],r=this._v[2]-n._v[2],i=this._v[3]-n._v[3];return Math.hypot(t,o,r,i)}dot(n){return this._v[0]*n._v[0]+this._v[1]*n._v[1]+this._v[2]*n._v[2]+this._v[3]*n._v[3]}get className(){return"Vector4"}clone(){return new this.constructor(new this._v.constructor([this._v[0],this._v[1],this._v[2],this._v[3]]))}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}};h(y_,"Vector4_");Yi=y_,Ya=class Ya extends Yi{constructor(n){super(n,{type:Float32Array})}static fromCopyArray(n){return super._fromCopyArray(n,Float32Array)}static fromCopyArray4(n){return super._fromCopyArray4(n,Float32Array)}static fromCopy4(n,t,o,r){return super._fromCopy4(n,t,o,r,Float32Array)}static fromCopyVector3(n){return super._fromCopyVector3(n,Float32Array)}static fromCopyVector4(n){return super._fromCopyVector4(n,Float32Array)}static fromArrayBuffer(n){return new Ya(new Float32Array(n))}static fromFloat32Array(n){return new Ya(n)}static fromCopyFloat32Array(n){return new Ya(n.slice(0))}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(n){return super._normalize(n,Float32Array)}static add(n,t){return super._add(n,t,Float32Array)}static subtract(n,t){return super._subtract(n,t,Float32Array)}static multiply(n,t){return super._multiply(n,t,Float32Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float32Array)}static divide(n,t){return super._divide(n,t,Float32Array)}static divideVector(n,t){return super._divideVector(n,t,Float32Array)}clone(){return super.clone()}};h(Ya,"Vector4");q=Ya,Cl=class Cl extends Yi{constructor(n){super(n,{type:Float64Array})}static fromCopyArray4(n){return super._fromCopyArray4(n,Float64Array)}static fromCopy4(n,t,o,r){return super._fromCopy4(n,t,o,r,Float64Array)}static fromCopyArray(n){return super._fromCopyArray(n,Float64Array)}static fromArrayBuffer(n){return new Cl(new Float64Array(n))}static fromFloat64Array(n){return new Cl(n)}static zero(){return super._zero(Float64Array)}static one(){return super._one(Float64Array)}static dummy(){return super._dummy(Float64Array)}static normalize(n){return super._normalize(n,Float64Array)}static add(n,t){return super._add(n,t,Float64Array)}static subtract(n,t){return super._subtract(n,t,Float64Array)}static multiply(n,t){return super._multiply(n,t,Float64Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float64Array)}static divide(n,t){return super._divide(n,t,Float64Array)}static divideVector(n,t){return super._divideVector(n,t,Float64Array)}clone(){return super.clone()}};h(Cl,"Vector4d");g_=Cl,QC=q.fromCopy4(1,1,1,1),XC=q.fromCopy4(0,0,0,1),HC=q.fromCopy4(0,0,0,0)});var Ki,wl,b_=C(()=>{"use strict";se();Hi();ye();Ki=class Ki extends Wo{constructor(){super(),this._v=Ki.__v}toString(){return`1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
`}toStringApproximately(){return this.toString()}flattenAsArray(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}isDummy(){return!1}isEqual(n,t=Number.EPSILON){return Math.abs(n.m00-1)<t&&Math.abs(n.m10)<t&&Math.abs(n.m20)<t&&Math.abs(n.m30)<t&&Math.abs(n.m01)<t&&Math.abs(n.m11-1)<t&&Math.abs(n.m21)<t&&Math.abs(n.m31)<t&&Math.abs(n.m02)<t&&Math.abs(n.m12)<t&&Math.abs(n.m22-1)<t&&Math.abs(n.m32)<t&&Math.abs(n.m03)<t&&Math.abs(n.m13)<t&&Math.abs(n.m23)<t&&Math.abs(n.m33-1)<t}isStrictEqual(n){let t=n._v;return t[0]===1&&t[1]===0&&t[2]===0&&t[3]===0&&t[4]===0&&t[5]===1&&t[6]===0&&t[7]===0&&t[8]===0&&t[9]===0&&t[10]===1&&t[11]===0&&t[12]===0&&t[13]===0&&t[14]===0&&t[15]===1}at(n,t){return n===t?1:0}v(n){return n%5===0?1:0}determinant(){return 1}multiplyVector(n){return n}multiplyVector3(n){return n}multiplyVectorTo(n,t){let o=n._v;return t._v[0]=o[0],t._v[1]=o[1],t._v[2]=o[2],t._v[3]=o[3],t}getScale(){return S.one()}getScaleTo(n){let t=n._v;return t[0]=1,t[1]=1,t[2]=1,n}clone(){return new Ki}getRotate(){return new Ki}getTranslate(){return S.zero()}get m00(){return 1}get m10(){return 0}get m20(){return 0}get m30(){return 0}get m01(){return 0}get m11(){return 1}get m21(){return 0}get m31(){return 0}get m02(){return 0}get m12(){return 0}get m22(){return 1}get m32(){return 0}get m03(){return 0}get m13(){return 0}get m23(){return 0}get m33(){return 1}get translateX(){return 0}get translateY(){return 0}get translateZ(){return 0}get className(){return"IdentityMatrix44"}static get compositionType(){return b.Mat4}get isIdentityMatrixClass(){return!0}};h(Ki,"IdentityMatrix44"),f(Ki,"__v",new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]));wl=Ki});var Qv,ru,iu,Xv,au,su,Hv,Ka,lu,qv,Za,cu,Ja,fu,jv,Yv,Kv,Zv,Jv,Rl,Nl,Pl,uu,$v,mu,_u,du,hu,pu,xu,vu,qC,jC,YC,KC,ZC,JC,$C,ew,tw,nw,ow,rw,iw,aw,sw,lw,cw,fw,uw,mw,_w,dw,hw,pw,xw,vw,gw,yw,bw,Aw,Iw,kv,Wv,Sw,gu=C(()=>{"use strict";Qv=Symbol("get1"),ru=Symbol("get1_offset"),iu=Symbol("get1_offsetAsComposition"),Xv=Symbol("get2"),au=Symbol("get2_offset"),su=Symbol("get2_offsetAsComposition"),Hv=Symbol("get3"),Ka=Symbol("get3_offset"),lu=Symbol("get3_offsetAsComposition"),qv=Symbol("get4"),Za=Symbol("get4_offset"),cu=Symbol("get4_offsetAsComposition"),Ja=Symbol("getN_offset"),fu=Symbol("getN_offsetAsComposition"),jv=Symbol("add2"),Yv=Symbol("add2_offset"),Kv=Symbol("add3"),Zv=Symbol("add3_offset"),Jv=Symbol("add4"),Rl=Symbol("mulArray3WithScalar_offset"),Nl=Symbol("mulArray4WithScalar_offset"),Pl=Symbol("mulArrayNWithScalar_offset"),uu=Symbol("mulThatAndThisToOutAsMat44_offsetAsComposition"),$v=Symbol("add4_offset"),mu=Symbol("qlerp_offsetAsComposition"),_u=Symbol("scalar_lerp_offsetAsComposition"),du=Symbol("array2_lerp_offsetAsComposition"),hu=Symbol("array3_lerp_offsetAsComposition"),pu=Symbol("array4_lerp_offsetAsComposition"),xu=Symbol("arrayN_lerp_offsetAsComposition"),vu=Symbol("normalizeArray4"),qC=h(function(){return[this[0]]},"get1_fn"),jC=h(function(m){return[this[m]]},"get1_offset_fn"),YC=h(function(m){return[this[m]]},"get1_offsetAsComposition_fn"),KC=h(function(){return[this[0],this[1]]},"get2_fn"),ZC=h(function(m){return[this[m],this[m+1]]},"get2_offset_fn"),JC=h(function(m){return[this[m*2],this[m*2+1]]},"get2_offsetAsComposition_fn"),$C=h(function(){return[this[0],this[1],this[2]]},"get3_fn"),ew=h(function(m){return[this[m],this[m+1],this[m+2]]},"get3_offset_fn"),tw=h(function(m){return[this[m*3],this[m*3+1],this[m*3+2]]},"get3_offsetAsComposition_fn"),nw=h(function(){return[this[0],this[1],this[2],this[3]]},"get4_fn"),ow=h(function(m){return[this[m],this[m+1],this[m+2],this[m+3]]},"get4_offset_fn"),rw=h(function(m){return[this[m*4],this[m*4+1],this[m*4+2],this[m*4+3]]},"get4_offsetAsComposition_fn"),iw=h(function(m,n){let t=new Array(n);for(let o=0;o<n;o++)t[o]=this[m+o];return t},"getN_offset_fn"),aw=h(function(m,n){let t=new Array(n);for(let o=0;o<n;o++)t[o]=this[m*n+o];return t},"getN_offsetAsComposition_fn"),sw=h(function(m){return this[0]+=m[0],this[1]+=m[1],this},"add2_fn"),lw=h(function(m,n,t){return this[n]+=m[t],this[n+1]+=m[t+1],this},"add2_offset_fn"),cw=h(function(m){return this[0]+=m[0],this[1]+=m[1],this[2]+=m[2],this},"add3_fn"),fw=h(function(m,n,t){return this[n]+=m[t],this[n+1]+=m[t+1],this[n+2]+=m[t+2],this},"add3_offset_fn"),uw=h(function(m){return this[0]+=m[0],this[1]+=m[1],this[2]+=m[2],this[3]+=m[3],this},"add4_fn"),mw=h(function(m,n,t){return this[n]+=m[t],this[n+1]+=m[t+1],this[n+2]+=m[t+2],this[n+3]+=m[t+3],this},"add4_offset_fn"),_w=h(function(m,n){return this[m]*=n,this[m+1]*=n,this[m+2]*=n,this},"mulArray3WithScalar_offset_fn"),dw=h(function(m,n){return this[m]*=n,this[m+1]*=n,this[m+2]*=n,this[m+3]*=n,this},"mulArray4WithScalar_offset_fn"),hw=h(function(m,n,t){for(let o=0;o<n;o++)this[m+o]*=t;return this},"mulArrayNWithScalar_offset_fn"),pw=h(function(m,n,t,o){let r=n,i=this,a=t*16,s=m*16;o[0]=r[a]*i[s]+r[a+4]*i[s+1]+r[a+8]*i[s+2]+r[a+12]*i[s+3],o[1]=r[a+1]*i[s]+r[a+5]*i[s+1]+r[a+9]*i[s+2]+r[a+13]*i[s+3],o[2]=r[a+2]*i[s]+r[a+6]*i[s+1]+r[a+10]*i[s+2]+r[a+14]*i[s+3],o[3]=r[a+3]*i[s]+r[a+7]*i[s+1]+r[a+11]*i[s+2]+r[a+15]*i[s+3],o[4]=r[a]*i[s+4]+r[a+4]*i[s+5]+r[a+8]*i[s+6]+r[a+12]*i[s+7],o[5]=r[a+1]*i[s+4]+r[a+5]*i[s+5]+r[a+9]*i[s+6]+r[a+13]*i[s+7],o[6]=r[a+2]*i[s+4]+r[a+6]*i[s+5]+r[a+10]*i[s+6]+r[a+14]*i[s+7],o[7]=r[a+3]*i[s+4]+r[a+7]*i[s+5]+r[a+11]*i[s+6]+r[a+15]*i[s+7],o[8]=r[a]*i[s+8]+r[a+4]*i[s+9]+r[a+8]*i[s+10]+r[a+12]*i[s+11],o[9]=r[a+1]*i[s+8]+r[a+5]*i[s+9]+r[a+9]*i[s+10]+r[a+13]*i[s+11],o[10]=r[a+2]*i[s+8]+r[a+6]*i[s+9]+r[a+10]*i[s+10]+r[a+14]*i[s+11],o[11]=r[a+3]*i[s+8]+r[a+7]*i[s+9]+r[a+11]*i[s+10]+r[a+15]*i[s+11],o[12]=r[a]*i[s+12]+r[a+4]*i[s+13]+r[a+8]*i[s+14]+r[a+12]*i[s+15],o[13]=r[a+1]*i[s+12]+r[a+5]*i[s+13]+r[a+9]*i[s+14]+r[a+13]*i[s+15],o[14]=r[a+2]*i[s+12]+r[a+6]*i[s+13]+r[a+10]*i[s+14]+r[a+14]*i[s+15],o[15]=r[a+3]*i[s+12]+r[a+7]*i[s+13]+r[a+11]*i[s+14]+r[a+15]*i[s+15]},"mulThatAndThisToOutAsMat44_offsetAsComposition_fn"),xw=h(function(m,n,t,o){let r=new Array(4),i=this[0+t*4]*m[0+o*4]+this[1+t*4]*m[1+o*4]+this[2+t*4]*m[2+o*4]+this[3+t*4]*m[3+o*4];if(1-i*i===0)r[0]=this[0+t*4],r[1]=this[1+t*4],r[2]=this[2+t*4],r[3]=this[3+t*4];else{i>1?i=.999:i<-1&&(i=-.999);let s=Math.acos(i),l=Math.sin(s),c;i<0?(i*=-1,s=Math.acos(i),c=-1*Math.sin(s*n)/l):c=Math.sin(s*n)/l;let u=Math.sin(s*(1-n))/l;r[0]=this[0+t*4]*u+m[0+o*4]*c,r[1]=this[1+t*4]*u+m[1+o*4]*c,r[2]=this[2+t*4]*u+m[2+o*4]*c,r[3]=this[3+t*4]*u+m[3+o*4]*c}return r},"qlerp_offsetAsComposition_fn"),vw=h(function(m,n,t,o){return[this[t]*(1-n)+m[o]*n]},"scalar_lerp_offsetAsComposition_fn"),gw=h(function(m,n,t,o){let r=new Array(2);for(let i=0;i<2;i++)r[i]=this[t*2+i]*(1-n)+m[o*2+i]*n;return r},"array2_lerp_offsetAsComposition_fn"),yw=h(function(m,n,t,o){let r=new Array(3);for(let i=0;i<3;i++)r[i]=this[t*3+i]*(1-n)+m[o*3+i]*n;return r},"array3_lerp_offsetAsComposition_fn"),bw=h(function(m,n,t,o){let r=new Array(4);for(let i=0;i<4;i++)r[i]=this[t*4+i]*(1-n)+m[o*4+i]*n;return r},"array4_lerp_offsetAsComposition_fn"),Aw=h(function(m,n,t,o,r){let i=new Array(n);for(let a=0;a<n;a++)i[a]=this[o*n+a]*(1-t)+m[r*n+a]*t;return i},"arrayN_lerp_offsetAsComposition_fn"),Iw=h(function(){let m=Math.hypot(this[0],this[1],this[2],this[3]);return this[0]/=m,this[1]/=m,this[2]/=m,this[3]/=m,this},"normalizeArray4_fn"),kv=[Array,Float32Array,Float64Array,Int8Array,Int16Array,Int32Array,Uint8Array,Uint16Array,Uint32Array],Wv=[iu,su,Qv,ru,Xv,au,Hv,Ka,lu,qv,Za,cu,Ja,fu,jv,Yv,Kv,Zv,Jv,$v,Rl,Nl,Pl,uu,mu,_u,du,hu,pu,xu,vu],Sw=[YC,JC,qC,jC,KC,ZC,$C,ew,tw,nw,ow,rw,iw,aw,sw,lw,cw,fw,uw,mw,_w,dw,hw,pw,xw,vw,gw,yw,bw,Aw,Iw];for(let m=0;m<kv.length;m++)for(let n=0;n<Wv.length;n++)kv[m].prototype[Wv[n]]=Sw[n]});var Bt,Se,yo=C(()=>{"use strict";ye();It();se();nn();b_();Hi();gu();me();Bt=class Bt extends Wo{constructor(n){super(),this._v=n}get m00(){return this._v[0]}get m10(){return this._v[1]}get m20(){return this._v[2]}get m30(){return this._v[3]}get m01(){return this._v[4]}get m11(){return this._v[5]}get m21(){return this._v[6]}get m31(){return this._v[7]}get m02(){return this._v[8]}get m12(){return this._v[9]}get m22(){return this._v[10]}get m32(){return this._v[11]}get m03(){return this._v[12]}get m13(){return this._v[13]}get m23(){return this._v[14]}get m33(){return this._v[15]}get translateX(){return this._v[12]}get translateY(){return this._v[13]}get translateZ(){return this._v[14]}static get compositionType(){return b.Mat4}static zero(){return Bt.fromCopy16RowMajor(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}static identity(){return new wl}static dummy(){return new this(new Float32Array(0))}static transpose(n){return n.isIdentityMatrixClass?n:Bt.fromCopyFloat32ArrayRowMajor(n._v)}static invert(n){if(n.isIdentityMatrixClass)return n;let t=n._v[0]*n._v[5]-n._v[4]*n._v[1],o=n._v[0]*n._v[9]-n._v[8]*n._v[1],r=n._v[0]*n._v[13]-n._v[12]*n._v[1],i=n._v[4]*n._v[9]-n._v[8]*n._v[5],a=n._v[4]*n._v[13]-n._v[12]*n._v[5],s=n._v[8]*n._v[13]-n._v[12]*n._v[9],l=n._v[2]*n._v[7]-n._v[6]*n._v[3],c=n._v[2]*n._v[11]-n._v[10]*n._v[3],u=n._v[2]*n._v[15]-n._v[14]*n._v[3],_=n._v[6]*n._v[11]-n._v[10]*n._v[7],d=n._v[6]*n._v[15]-n._v[14]*n._v[7],p=n._v[10]*n._v[15]-n._v[14]*n._v[11],x=t*p-o*d+r*_+i*u-a*c+s*l;x===0&&N.error("the determinant is 0!");let v=1/x,y=(n._v[5]*p-n._v[9]*d+n._v[13]*_)*v,g=(n._v[8]*d-n._v[4]*p-n._v[12]*_)*v,E=(n._v[7]*s-n._v[11]*a+n._v[15]*i)*v,w=(n._v[10]*a-n._v[6]*s-n._v[14]*i)*v,T=(n._v[9]*u-n._v[1]*p-n._v[13]*c)*v,R=(n._v[0]*p-n._v[8]*u+n._v[12]*c)*v,P=(n._v[11]*r-n._v[3]*s-n._v[15]*o)*v,V=(n._v[2]*s-n._v[10]*r+n._v[14]*o)*v,z=(n._v[1]*d-n._v[5]*u+n._v[13]*l)*v,k=(n._v[4]*u-n._v[0]*d-n._v[12]*l)*v,W=(n._v[3]*a-n._v[7]*r+n._v[15]*t)*v,X=(n._v[6]*r-n._v[2]*a-n._v[14]*t)*v,j=(n._v[5]*c-n._v[1]*_-n._v[9]*l)*v,ae=(n._v[0]*_-n._v[4]*c+n._v[8]*l)*v,le=(n._v[7]*o-n._v[3]*i-n._v[11]*t)*v,ze=(n._v[2]*i-n._v[6]*o+n._v[10]*t)*v;return Bt.fromCopy16RowMajor(y,g,E,w,T,R,P,V,z,k,W,X,j,ae,le,ze)}static invertTo(n,t){if(n.isIdentityMatrixClass)return t.copyComponents(n);let o=n._v[0]*n._v[5]-n._v[4]*n._v[1],r=n._v[0]*n._v[9]-n._v[8]*n._v[1],i=n._v[0]*n._v[13]-n._v[12]*n._v[1],a=n._v[4]*n._v[9]-n._v[8]*n._v[5],s=n._v[4]*n._v[13]-n._v[12]*n._v[5],l=n._v[8]*n._v[13]-n._v[12]*n._v[9],c=n._v[2]*n._v[7]-n._v[6]*n._v[3],u=n._v[2]*n._v[11]-n._v[10]*n._v[3],_=n._v[2]*n._v[15]-n._v[14]*n._v[3],d=n._v[6]*n._v[11]-n._v[10]*n._v[7],p=n._v[6]*n._v[15]-n._v[14]*n._v[7],x=n._v[10]*n._v[15]-n._v[14]*n._v[11],v=o*x-r*p+i*d+a*_-s*u+l*c;v===0&&N.error("the determinant is 0!");let y=1/v,g=(n._v[5]*x-n._v[9]*p+n._v[13]*d)*y,E=(n._v[8]*p-n._v[4]*x-n._v[12]*d)*y,w=(n._v[7]*l-n._v[11]*s+n._v[15]*a)*y,T=(n._v[10]*s-n._v[6]*l-n._v[14]*a)*y,R=(n._v[9]*_-n._v[1]*x-n._v[13]*u)*y,P=(n._v[0]*x-n._v[8]*_+n._v[12]*u)*y,V=(n._v[11]*i-n._v[3]*l-n._v[15]*r)*y,z=(n._v[2]*l-n._v[10]*i+n._v[14]*r)*y,k=(n._v[1]*p-n._v[5]*_+n._v[13]*c)*y,W=(n._v[4]*_-n._v[0]*p-n._v[12]*c)*y,X=(n._v[3]*s-n._v[7]*i+n._v[15]*o)*y,j=(n._v[6]*i-n._v[2]*s-n._v[14]*o)*y,ae=(n._v[5]*u-n._v[1]*d-n._v[9]*c)*y,le=(n._v[0]*d-n._v[4]*u+n._v[8]*c)*y,ze=(n._v[7]*r-n._v[3]*a-n._v[11]*o)*y,At=(n._v[2]*a-n._v[6]*r+n._v[10]*o)*y;return t.setComponents(g,E,w,T,R,P,V,z,k,W,X,j,ae,le,ze,At)}static translate(n){return Bt.fromCopy16RowMajor(1,0,0,n._v[0],0,1,0,n._v[1],0,0,1,n._v[2],0,0,0,1)}static rotateX(n){let t=Math.cos(n),o=Math.sin(n);return Bt.fromCopy16RowMajor(1,0,0,0,0,t,-o,0,0,o,t,0,0,0,0,1)}static rotateY(n){let t=Math.cos(n),o=Math.sin(n);return Bt.fromCopy16RowMajor(t,0,o,0,0,1,0,0,-o,0,t,0,0,0,0,1)}static rotateZ(n){let t=Math.cos(n),o=Math.sin(n);return Bt.fromCopy16RowMajor(t,-o,0,0,o,t,0,0,0,0,1,0,0,0,0,1)}static rotateXYZ(n,t,o){let r=Math.cos(n),i=Math.sin(n),a=Math.cos(t),s=Math.sin(t),l=Math.cos(o),c=Math.sin(o),u=r,_=-i,d=i,p=r,x=a,v=s,y=-s,g=a,E=l,w=-c,T=c,R=l,P=x,V=v*d,z=v*p,k=u,W=_,X=y,j=g*d,ae=g*p,le=E*P,ze=E*V+w*k,At=E*z+w*W,Be=T*P,Fn=T*V+R*k,Sn=T*z+R*W,cn=X,Dr=j,Br=ae;return Bt.fromCopy16RowMajor(le,ze,At,0,Be,Fn,Sn,0,cn,Dr,Br,0,0,0,0,1)}static rotate(n){return this.rotateXYZ(n._v[0],n._v[1],n._v[2])}static scale(n){return Bt.fromCopy16RowMajor(n._v[0],0,0,0,0,n._v[1],0,0,0,0,n._v[2],0,0,0,0,1)}static multiply(n,t){if(n.isIdentityMatrixClass)return t;if(t.isIdentityMatrixClass)return n;let o=n._v,r=t._v,i=o[0]*r[0]+o[4]*r[1]+o[8]*r[2]+o[12]*r[3],a=o[1]*r[0]+o[5]*r[1]+o[9]*r[2]+o[13]*r[3],s=o[2]*r[0]+o[6]*r[1]+o[10]*r[2]+o[14]*r[3],l=o[3]*r[0]+o[7]*r[1]+o[11]*r[2]+o[15]*r[3],c=o[0]*r[4]+o[4]*r[5]+o[8]*r[6]+o[12]*r[7],u=o[1]*r[4]+o[5]*r[5]+o[9]*r[6]+o[13]*r[7],_=o[2]*r[4]+o[6]*r[5]+o[10]*r[6]+o[14]*r[7],d=o[3]*r[4]+o[7]*r[5]+o[11]*r[6]+o[15]*r[7],p=o[0]*r[8]+o[4]*r[9]+o[8]*r[10]+o[12]*r[11],x=o[1]*r[8]+o[5]*r[9]+o[9]*r[10]+o[13]*r[11],v=o[2]*r[8]+o[6]*r[9]+o[10]*r[10]+o[14]*r[11],y=o[3]*r[8]+o[7]*r[9]+o[11]*r[10]+o[15]*r[11],g=o[0]*r[12]+o[4]*r[13]+o[8]*r[14]+o[12]*r[15],E=o[1]*r[12]+o[5]*r[13]+o[9]*r[14]+o[13]*r[15],w=o[2]*r[12]+o[6]*r[13]+o[10]*r[14]+o[14]*r[15],T=o[3]*r[12]+o[7]*r[13]+o[11]*r[14]+o[15]*r[15];return Bt.fromCopy16RowMajor(i,c,p,g,a,u,x,E,s,_,v,w,l,d,y,T)}static multiplyTo(n,t,o){if(n.isIdentityMatrixClass)return o.copyComponents(t);if(t.isIdentityMatrixClass)return o.copyComponents(n);let r=n._v,i=t._v,a=r[0]*i[0]+r[4]*i[1]+r[8]*i[2]+r[12]*i[3],s=r[1]*i[0]+r[5]*i[1]+r[9]*i[2]+r[13]*i[3],l=r[2]*i[0]+r[6]*i[1]+r[10]*i[2]+r[14]*i[3],c=r[3]*i[0]+r[7]*i[1]+r[11]*i[2]+r[15]*i[3],u=r[0]*i[4]+r[4]*i[5]+r[8]*i[6]+r[12]*i[7],_=r[1]*i[4]+r[5]*i[5]+r[9]*i[6]+r[13]*i[7],d=r[2]*i[4]+r[6]*i[5]+r[10]*i[6]+r[14]*i[7],p=r[3]*i[4]+r[7]*i[5]+r[11]*i[6]+r[15]*i[7],x=r[0]*i[8]+r[4]*i[9]+r[8]*i[10]+r[12]*i[11],v=r[1]*i[8]+r[5]*i[9]+r[9]*i[10]+r[13]*i[11],y=r[2]*i[8]+r[6]*i[9]+r[10]*i[10]+r[14]*i[11],g=r[3]*i[8]+r[7]*i[9]+r[11]*i[10]+r[15]*i[11],E=r[0]*i[12]+r[4]*i[13]+r[8]*i[14]+r[12]*i[15],w=r[1]*i[12]+r[5]*i[13]+r[9]*i[14]+r[13]*i[15],T=r[2]*i[12]+r[6]*i[13]+r[10]*i[14]+r[14]*i[15],R=r[3]*i[12]+r[7]*i[13]+r[11]*i[14]+r[15]*i[15];return o.setComponents(a,u,x,E,s,_,v,w,l,d,y,T,c,p,g,R)}static multiplyTypedArrayTo(n,t,o,r){return t[uu](r,n._v,0,o._v),o}static fromQuaternionTo(n,t){let o=n._v[0]*n._v[0],r=n._v[1]*n._v[1],i=n._v[2]*n._v[2],a=n._v[1]*n._v[2],s=n._v[0]*n._v[2],l=n._v[0]*n._v[1],c=n._v[3]*n._v[0],u=n._v[3]*n._v[1],_=n._v[3]*n._v[2],d=1-2*(r+i),p=2*(l-_),x=2*(s+u),v=0,y=2*(l+_),g=1-2*(o+i),E=2*(a-c),w=0,T=2*(s-u),R=2*(a+c),P=1-2*(o+r);return t.setComponents(d,p,x,v,y,g,E,w,T,R,P,0,0,0,0,1)}toString(){return this._v[0]+" "+this._v[4]+" "+this._v[8]+" "+this._v[12]+` 
`+this._v[1]+" "+this._v[5]+" "+this._v[9]+" "+this._v[13]+` 
`+this._v[2]+" "+this._v[6]+" "+this._v[10]+" "+this._v[14]+` 
`+this._v[3]+" "+this._v[7]+" "+this._v[11]+" "+this._v[15]+` 
`}toStringApproximately(){return Y.financial(this._v[0])+" "+Y.financial(this._v[4])+" "+Y.financial(this._v[8])+" "+Y.financial(this._v[12])+` 
`+Y.financial(this._v[1])+" "+Y.financial(this._v[5])+" "+Y.financial(this._v[9])+" "+Y.financial(this._v[13])+` 
`+Y.financial(this._v[2])+" "+Y.financial(this._v[6])+" "+Y.financial(this._v[10])+" "+Y.financial(this._v[14])+` 
`+Y.financial(this._v[3])+" "+Y.financial(this._v[7])+" "+Y.financial(this._v[11])+" "+Y.financial(this._v[15])+` 
`}flattenAsArray(){return[this._v[0],this._v[1],this._v[2],this._v[3],this._v[4],this._v[5],this._v[6],this._v[7],this._v[8],this._v[9],this._v[10],this._v[11],this._v[12],this._v[13],this._v[14],this._v[15]]}isDummy(){return this._v.length===0}isEqual(n,t=Number.EPSILON){let o=n._v;return Math.abs(o[0]-this._v[0])<t&&Math.abs(o[1]-this._v[1])<t&&Math.abs(o[2]-this._v[2])<t&&Math.abs(o[3]-this._v[3])<t&&Math.abs(o[4]-this._v[4])<t&&Math.abs(o[5]-this._v[5])<t&&Math.abs(o[6]-this._v[6])<t&&Math.abs(o[7]-this._v[7])<t&&Math.abs(o[8]-this._v[8])<t&&Math.abs(o[9]-this._v[9])<t&&Math.abs(o[10]-this._v[10])<t&&Math.abs(o[11]-this._v[11])<t&&Math.abs(o[12]-this._v[12])<t&&Math.abs(o[13]-this._v[13])<t&&Math.abs(o[14]-this._v[14])<t&&Math.abs(o[15]-this._v[15])<t}isStrictEqual(n){return n._v[0]===this._v[0]&&n._v[1]===this._v[1]&&n._v[2]===this._v[2]&&n._v[3]===this._v[3]&&n._v[4]===this._v[4]&&n._v[5]===this._v[5]&&n._v[6]===this._v[6]&&n._v[7]===this._v[7]&&n._v[8]===this._v[8]&&n._v[9]===this._v[9]&&n._v[10]===this._v[10]&&n._v[11]===this._v[11]&&n._v[12]===this._v[12]&&n._v[13]===this._v[13]&&n._v[14]===this._v[14]&&n._v[15]===this._v[15]}at(n,t){return this._v[n+t*4]}determinant(){return this._v[0]*this._v[5]*this._v[10]*this._v[15]+this._v[0]*this._v[9]*this._v[14]*this._v[7]+this._v[0]*this._v[13]*this._v[6]*this._v[11]+this._v[4]*this._v[1]*this._v[14]*this._v[11]+this._v[4]*this._v[9]*this._v[2]*this._v[15]+this._v[4]*this._v[13]*this._v[10]*this._v[3]+this._v[8]*this._v[1]*this._v[6]*this._v[15]+this._v[8]*this._v[5]*this._v[14]*this._v[3]+this._v[8]*this._v[13]*this._v[2]*this._v[7]+this._v[12]*this._v[1]*this._v[10]*this._v[7]+this._v[12]*this._v[5]*this._v[2]*this._v[11]+this._v[12]*this._v[9]*this._v[6]*this._v[3]-this._v[0]*this._v[5]*this._v[14]*this._v[11]-this._v[0]*this._v[9]*this._v[6]*this._v[15]-this._v[0]*this._v[13]*this._v[10]*this._v[7]-this._v[4]*this._v[1]*this._v[10]*this._v[15]-this._v[4]*this._v[9]*this._v[14]*this._v[3]-this._v[4]*this._v[13]*this._v[2]*this._v[11]-this._v[8]*this._v[1]*this._v[14]*this._v[7]-this._v[8]*this._v[5]*this._v[2]*this._v[15]-this._v[8]*this._v[13]*this._v[6]*this._v[3]-this._v[12]*this._v[1]*this._v[6]*this._v[11]-this._v[12]*this._v[5]*this._v[10]*this._v[3]-this._v[12]*this._v[9]*this._v[2]*this._v[7]}multiplyVector(n){let t=this._v[0]*n._v[0]+this._v[4]*n._v[1]+this._v[8]*n._v[2]+this._v[12]*n._v[3],o=this._v[1]*n._v[0]+this._v[5]*n._v[1]+this._v[9]*n._v[2]+this._v[13]*n._v[3],r=this._v[2]*n._v[0]+this._v[6]*n._v[1]+this._v[10]*n._v[2]+this._v[14]*n._v[3],i=this._v[3]*n._v[0]+this._v[7]*n._v[1]+this._v[11]*n._v[2]+this._v[15]*n._v[3];return q.fromCopyArray([t,o,r,i])}multiplyVectorTo(n,t){let o=this._v[0]*n._v[0]+this._v[4]*n._v[1]+this._v[8]*n._v[2]+this._v[12]*n._v[3],r=this._v[1]*n._v[0]+this._v[5]*n._v[1]+this._v[9]*n._v[2]+this._v[13]*n._v[3],i=this._v[2]*n._v[0]+this._v[6]*n._v[1]+this._v[10]*n._v[2]+this._v[14]*n._v[3],a=this._v[3]*n._v[0]+this._v[7]*n._v[1]+this._v[11]*n._v[2]+this._v[15]*n._v[3];return t._v[0]=o,t._v[1]=r,t._v[2]=i,t._v[3]=a,t}multiplyVectorToVec3(n,t){let o=this._v[0]*n._v[0]+this._v[4]*n._v[1]+this._v[8]*n._v[2]+this._v[12]*n._v[3],r=this._v[1]*n._v[0]+this._v[5]*n._v[1]+this._v[9]*n._v[2]+this._v[13]*n._v[3],i=this._v[2]*n._v[0]+this._v[6]*n._v[1]+this._v[10]*n._v[2]+this._v[14]*n._v[3];return t._v[0]=o,t._v[1]=r,t._v[2]=i,t}multiplyVector3(n){let t=this._v[0]*n._v[0]+this._v[4]*n._v[1]+this._v[8]*n._v[2]+this._v[12],o=this._v[1]*n._v[0]+this._v[5]*n._v[1]+this._v[9]*n._v[2]+this._v[13],r=this._v[2]*n._v[0]+this._v[6]*n._v[1]+this._v[10]*n._v[2]+this._v[14];return S.fromCopyArray([t,o,r])}multiplyVector3To(n,t){let o=this._v[0]*n._v[0]+this._v[4]*n._v[1]+this._v[8]*n._v[2]+this._v[12],r=this._v[1]*n._v[0]+this._v[5]*n._v[1]+this._v[9]*n._v[2]+this._v[13],i=this._v[2]*n._v[0]+this._v[6]*n._v[1]+this._v[10]*n._v[2]+this._v[14];return t._v[0]=o,t._v[1]=r,t._v[2]=i,t}getTranslate(){return S.fromCopyArray([this._v[12],this._v[13],this._v[14]])}getTranslateTo(n){return n._v[0]=this._v[12],n._v[1]=this._v[13],n._v[2]=this._v[14],n}getScale(){return S.fromCopyArray([Math.hypot(this._v[0],this._v[1],this._v[2]),Math.hypot(this._v[4],this._v[5],this._v[6]),Math.hypot(this._v[8],this._v[9],this._v[10])])}getScaleTo(n){return n._v[0]=Math.hypot(this._v[0],this._v[1],this._v[2]),n._v[1]=Math.hypot(this._v[4],this._v[5],this._v[6]),n._v[2]=Math.hypot(this._v[8],this._v[9],this._v[10]),n}toEulerAngles(){let n;if(Math.abs(this._v[2])!==1){let t=-Math.asin(this._v[2]),o=Math.atan2(this._v[6]/Math.cos(t),this._v[10]/Math.cos(t)),r=Math.atan2(this._v[1]/Math.cos(t),this._v[0]/Math.cos(t));n=S.fromCopyArray([o,t,r])}else this._v[2]===-1?n=S.fromCopyArray([Math.atan2(this._v[4],this._v[8]),Math.PI/2,0]):n=S.fromCopyArray([Math.atan2(-this._v[4],-this._v[8]),-Math.PI/2,0]);return n}toEulerAnglesTo(n){if(Math.abs(this._v[2])!==1){let t=-Math.asin(this._v[2]),o=Math.atan2(this._v[6]/Math.cos(t),this._v[10]/Math.cos(t)),r=Math.atan2(this._v[1]/Math.cos(t),this._v[0]/Math.cos(t));n._v[0]=o,n._v[1]=t,n._v[2]=r}else this._v[2]===-1?(n._v[0]=Math.atan2(this._v[4],this._v[8]),n._v[1]=Math.PI/2,n._v[2]=0):(n._v[0]=Math.atan2(-this._v[4],-this._v[8]),n._v[1]=-Math.PI/2,n._v[2]=0);return n}clone(){return this.constructor.fromCopy16RowMajor(this._v[0],this._v[4],this._v[8],this._v[12],this._v[1],this._v[5],this._v[9],this._v[13],this._v[2],this._v[6],this._v[10],this._v[14],this._v[3],this._v[7],this._v[11],this._v[15])}getRotate(){let n=Math.hypot(this._v[0],this._v[1],this._v[2]),t=Math.hypot(this._v[4],this._v[5],this._v[6]),o=Math.hypot(this._v[8],this._v[9],this._v[10]);return Bt.fromCopy16RowMajor(this._v[0]/n,this._v[4],this._v[8],0,this._v[1],this._v[5]/t,this._v[9],0,this._v[2],this._v[6],this._v[10]/o,0,0,0,0,1)}static fromCopy16RowMajor(n,t,o,r,i,a,s,l,c,u,_,d,p,x,v,y){let g=new Float32Array(16);return g[0]=n,g[4]=t,g[8]=o,g[12]=r,g[1]=i,g[5]=a,g[9]=s,g[13]=l,g[2]=c,g[6]=u,g[10]=_,g[14]=d,g[3]=p,g[7]=x,g[11]=v,g[15]=y,new Bt(g)}static fromCopy16ColumnMajor(n,t,o,r,i,a,s,l,c,u,_,d,p,x,v,y){let g=new Float32Array(16);return g[0]=n,g[4]=i,g[8]=c,g[12]=p,g[1]=t,g[5]=a,g[9]=u,g[13]=x,g[2]=o,g[6]=s,g[10]=_,g[14]=v,g[3]=r,g[7]=l,g[11]=d,g[15]=y,new Bt(g)}static fromCopyMatrix44(n){let t=new Float32Array(16);return t.set(n._v),new Bt(t)}static fromFloat32ArrayColumnMajor(n){return new Bt(n)}static fromCopyFloat32ArrayColumnMajor(n){let t=new Float32Array(16);return t.set(n),new Bt(t)}static fromCopyFloat32ArrayRowMajor(n){let t=new Float32Array(16);return t[0]=n[0],t[4]=n[1],t[8]=n[2],t[12]=n[3],t[1]=n[4],t[5]=n[5],t[9]=n[6],t[13]=n[7],t[2]=n[8],t[6]=n[9],t[10]=n[10],t[14]=n[11],t[3]=n[12],t[7]=n[13],t[11]=n[14],t[15]=n[15],new Bt(t)}static fromCopyMatrix33(n){let t=new Float32Array(16);return t[0]=n._v[0],t[4]=n._v[3],t[8]=n._v[6],t[12]=0,t[1]=n._v[1],t[5]=n._v[4],t[9]=n._v[7],t[13]=0,t[2]=n._v[2],t[6]=n._v[5],t[10]=n._v[8],t[14]=0,t[3]=0,t[7]=0,t[11]=0,t[15]=1,new Bt(t)}static fromCopyArray16ColumnMajor(n){let t=new Float32Array(16);return t.set(n),new Bt(t)}static fromCopyArrayColumnMajor(n){let t=new Float32Array(16);return t.set(n),new Bt(t)}static fromCopyArray16RowMajor(n){let t=new Float32Array(16);return t[0]=n[0],t[4]=n[1],t[8]=n[2],t[12]=n[3],t[1]=n[4],t[5]=n[5],t[9]=n[6],t[13]=n[7],t[2]=n[8],t[6]=n[9],t[10]=n[10],t[14]=n[11],t[3]=n[12],t[7]=n[13],t[11]=n[14],t[15]=n[15],new Bt(t)}static fromCopyArrayRowMajor(n){let t=new Float32Array(16);return t[0]=n[0],t[4]=n[1],t[8]=n[2],t[12]=n[3],t[1]=n[4],t[5]=n[5],t[9]=n[6],t[13]=n[7],t[2]=n[8],t[6]=n[9],t[10]=n[10],t[14]=n[11],t[3]=n[12],t[7]=n[13],t[11]=n[14],t[15]=n[15],new Bt(t)}static fromCopyQuaternion(n){let t=n._v[0]*n._v[0],o=n._v[1]*n._v[1],r=n._v[2]*n._v[2],i=n._v[1]*n._v[2],a=n._v[0]*n._v[2],s=n._v[0]*n._v[1],l=n._v[3]*n._v[0],c=n._v[3]*n._v[1],u=n._v[3]*n._v[2],_=new Float32Array(16);return _[0]=1-2*(o+r),_[4]=2*(s-u),_[8]=2*(a+c),_[12]=0,_[1]=2*(s+u),_[5]=1-2*(t+r),_[9]=2*(i-l),_[13]=0,_[2]=2*(a-c),_[6]=2*(i+l),_[10]=1-2*(t+o),_[14]=0,_[3]=0,_[7]=0,_[11]=0,_[15]=1,new Bt(_)}};h(Bt,"Matrix44");Se=Bt});var Ln,$,Yt=C(()=>{"use strict";yo();me();Ln=class Ln extends Se{constructor(n){super(n)}set m00(n){this._v[0]=n}get m00(){return this._v[0]}set m10(n){this._v[1]=n}get m10(){return this._v[1]}set m20(n){this._v[2]=n}get m20(){return this._v[2]}set m30(n){this._v[3]=n}get m30(){return this._v[3]}set m01(n){this._v[4]=n}get m01(){return this._v[4]}set m11(n){this._v[5]=n}get m11(){return this._v[5]}set m21(n){this._v[6]=n}get m21(){return this._v[6]}set m31(n){this._v[7]=n}get m31(){return this._v[7]}set m02(n){this._v[8]=n}get m02(){return this._v[8]}set m12(n){this._v[9]=n}get m12(){return this._v[9]}set m22(n){this._v[10]=n}get m22(){return this._v[10]}set m32(n){this._v[11]=n}get m32(){return this._v[11]}set m03(n){this._v[12]=n}get m03(){return this._v[12]}set m13(n){this._v[13]=n}get m13(){return this._v[13]}set m23(n){this._v[14]=n}get m23(){return this._v[14]}set m33(n){this._v[15]=n}get m33(){return this._v[15]}get translateX(){return this._v[12]}set translateX(n){this._v[12]=n}get translateY(){return this._v[13]}set translateY(n){this._v[13]=n}get translateZ(){return this._v[14]}set translateZ(n){this._v[14]=n}get className(){return"MutableMatrix44"}static zero(){return Ln.fromCopy16RowMajor(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}static identity(){return Ln.fromCopy16RowMajor(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}static dummy(){return super.dummy()}static transpose(n){return n.isIdentityMatrixClass?n:Ln.fromCopyFloat32ArrayRowMajor(n._v)}static invert(n){return super.invert(n)}static translate(n){return super.translate(n)}static rotateX(n){return super.rotateX(n)}static rotateY(n){return super.rotateY(n)}static rotateZ(n){return super.rotateZ(n)}static rotateXYZ(n,t,o){return super.rotateXYZ(n,t,o)}static rotate(n){return super.rotateXYZ(n._v[0],n._v[1],n._v[2])}static scale(n){return super.scale(n)}static multiply(n,t){return super.multiply(n,t)}clone(){return super.clone()}getRotate(){return super.getRotate()}getTranslate(){return super.getTranslate()}getTranslateTo(n){return super.getTranslateTo(n)}getScale(){return super.getScale()}raw(){return this._v}setAt(n,t,o){return this._v[n+t*4]=o,this}setComponents(n,t,o,r,i,a,s,l,c,u,_,d,p,x,v,y){return this._v[0]=n,this._v[4]=t,this._v[8]=o,this._v[12]=r,this._v[1]=i,this._v[5]=a,this._v[9]=s,this._v[13]=l,this._v[2]=c,this._v[6]=u,this._v[10]=_,this._v[14]=d,this._v[3]=p,this._v[7]=x,this._v[11]=v,this._v[15]=y,this}copyComponents(n){return this._v[0]=n._v[0],this._v[4]=n._v[4],this._v[8]=n._v[8],this._v[12]=n._v[12],this._v[1]=n._v[1],this._v[5]=n._v[5],this._v[9]=n._v[9],this._v[13]=n._v[13],this._v[2]=n._v[2],this._v[6]=n._v[6],this._v[10]=n._v[10],this._v[14]=n._v[14],this._v[3]=n._v[3],this._v[7]=n._v[7],this._v[11]=n._v[11],this._v[15]=n._v[15],this}zero(){return this.setComponents(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}identity(){return this.setComponents(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}_swap(n,t){this._v[t]=[this._v[n],this._v[n]=this._v[t]][0]}transpose(){return this._swap(1,4),this._swap(2,8),this._swap(3,12),this._swap(6,9),this._swap(7,13),this._swap(11,14),this}invert(){let n=this._v[0]*this._v[5]-this._v[4]*this._v[1],t=this._v[0]*this._v[9]-this._v[8]*this._v[1],o=this._v[0]*this._v[13]-this._v[12]*this._v[1],r=this._v[4]*this._v[9]-this._v[8]*this._v[5],i=this._v[4]*this._v[13]-this._v[12]*this._v[5],a=this._v[8]*this._v[13]-this._v[12]*this._v[9],s=this._v[2]*this._v[7]-this._v[6]*this._v[3],l=this._v[2]*this._v[11]-this._v[10]*this._v[3],c=this._v[2]*this._v[15]-this._v[14]*this._v[3],u=this._v[6]*this._v[11]-this._v[10]*this._v[7],_=this._v[6]*this._v[15]-this._v[14]*this._v[7],d=this._v[10]*this._v[15]-this._v[14]*this._v[11],p=n*d-t*_+o*u+r*c-i*l+a*s;p===0&&N.error("the determinant is 0!");let x=(this._v[5]*d-this._v[9]*_+this._v[13]*u)/p,v=(this._v[8]*_-this._v[4]*d-this._v[12]*u)/p,y=(this._v[7]*a-this._v[11]*i+this._v[15]*r)/p,g=(this._v[10]*i-this._v[6]*a-this._v[14]*r)/p,E=(this._v[9]*c-this._v[1]*d-this._v[13]*l)/p,w=(this._v[0]*d-this._v[8]*c+this._v[12]*l)/p,T=(this._v[11]*o-this._v[3]*a-this._v[15]*t)/p,R=(this._v[2]*a-this._v[10]*o+this._v[14]*t)/p,P=(this._v[1]*_-this._v[5]*c+this._v[13]*s)/p,V=(this._v[4]*c-this._v[0]*_-this._v[12]*s)/p,z=(this._v[3]*i-this._v[7]*o+this._v[15]*n)/p,k=(this._v[6]*o-this._v[2]*i-this._v[14]*n)/p,W=(this._v[5]*l-this._v[1]*u-this._v[9]*s)/p,X=(this._v[0]*u-this._v[4]*l+this._v[8]*s)/p,j=(this._v[7]*t-this._v[3]*r-this._v[11]*n)/p,ae=(this._v[2]*r-this._v[6]*t+this._v[10]*n)/p;return this.setComponents(x,v,y,g,E,w,T,R,P,V,z,k,W,X,j,ae)}translate(n){return this.setComponents(1,0,0,n._v[0],0,1,0,n._v[1],0,0,1,n._v[2],0,0,0,1)}putTranslate(n){return this._v[12]=n._v[0],this._v[13]=n._v[1],this._v[14]=n._v[2],this}addTranslate(n){return this._v[12]+=n._v[0],this._v[13]+=n._v[1],this._v[14]+=n._v[2],this}rotateX(n){let t=Math.cos(n),o=Math.sin(n);return this.setComponents(1,0,0,0,0,t,-o,0,0,o,t,0,0,0,0,1)}rotateY(n){let t=Math.cos(n),o=Math.sin(n);return this.setComponents(t,0,o,0,0,1,0,0,-o,0,t,0,0,0,0,1)}rotateZ(n){let t=Math.cos(n),o=Math.sin(n);return this.setComponents(t,-o,0,0,o,t,0,0,0,0,1,0,0,0,0,1)}rotateXYZ(n,t,o){let r=Math.cos(n),i=Math.sin(n),a=Math.cos(t),s=Math.sin(t),l=Math.cos(o),c=Math.sin(o),u=r,_=-i,d=i,p=r,x=a,v=s,y=-s,g=a,E=l,w=-c,T=c,R=l,P=x,V=v*d,z=v*p,k=u,W=_,X=y,j=g*d,ae=g*p,le=E*P,ze=E*V+w*k,At=E*z+w*W,Be=T*P,Fn=T*V+R*k,Sn=T*z+R*W,cn=X,Dr=j,Br=ae;return this.setComponents(le,ze,At,0,Be,Fn,Sn,0,cn,Dr,Br,0,0,0,0,1)}rotate(n){return this.rotateXYZ(n._v[0],n._v[1],n._v[2])}scale(n){return this.setComponents(n._v[0],0,0,0,0,n._v[1],0,0,0,0,n._v[2],0,0,0,0,1)}multiplyScale(n){return this._v[0]*=n._v[0],this._v[4]*=n._v[0],this._v[8]*=n._v[0],this._v[12]*=n._v[0],this._v[1]*=n._v[1],this._v[5]*=n._v[1],this._v[9]*=n._v[1],this._v[13]*=n._v[1],this._v[2]*=n._v[2],this._v[6]*=n._v[2],this._v[10]*=n._v[2],this._v[14]*=n._v[2],this}multiply(n){if(n.isIdentityMatrixClass)return this;let t=this._v[0]*n._v[0]+this._v[4]*n._v[1]+this._v[8]*n._v[2]+this._v[12]*n._v[3],o=this._v[0]*n._v[4]+this._v[4]*n._v[5]+this._v[8]*n._v[6]+this._v[12]*n._v[7],r=this._v[0]*n._v[8]+this._v[4]*n._v[9]+this._v[8]*n._v[10]+this._v[12]*n._v[11],i=this._v[0]*n._v[12]+this._v[4]*n._v[13]+this._v[8]*n._v[14]+this._v[12]*n._v[15],a=this._v[1]*n._v[0]+this._v[5]*n._v[1]+this._v[9]*n._v[2]+this._v[13]*n._v[3],s=this._v[1]*n._v[4]+this._v[5]*n._v[5]+this._v[9]*n._v[6]+this._v[13]*n._v[7],l=this._v[1]*n._v[8]+this._v[5]*n._v[9]+this._v[9]*n._v[10]+this._v[13]*n._v[11],c=this._v[1]*n._v[12]+this._v[5]*n._v[13]+this._v[9]*n._v[14]+this._v[13]*n._v[15],u=this._v[2]*n._v[0]+this._v[6]*n._v[1]+this._v[10]*n._v[2]+this._v[14]*n._v[3],_=this._v[2]*n._v[4]+this._v[6]*n._v[5]+this._v[10]*n._v[6]+this._v[14]*n._v[7],d=this._v[2]*n._v[8]+this._v[6]*n._v[9]+this._v[10]*n._v[10]+this._v[14]*n._v[11],p=this._v[2]*n._v[12]+this._v[6]*n._v[13]+this._v[10]*n._v[14]+this._v[14]*n._v[15],x=this._v[3]*n._v[0]+this._v[7]*n._v[1]+this._v[11]*n._v[2]+this._v[15]*n._v[3],v=this._v[3]*n._v[4]+this._v[7]*n._v[5]+this._v[11]*n._v[6]+this._v[15]*n._v[7],y=this._v[3]*n._v[8]+this._v[7]*n._v[9]+this._v[11]*n._v[10]+this._v[15]*n._v[11],g=this._v[3]*n._v[12]+this._v[7]*n._v[13]+this._v[11]*n._v[14]+this._v[15]*n._v[15];return this.setComponents(t,o,r,i,a,s,l,c,u,_,d,p,x,v,y,g)}multiplyByLeft(n){if(n.isIdentityMatrixClass)return this;let t=n._v[0]*this._v[0]+n._v[4]*this._v[1]+n._v[8]*this._v[2]+n._v[12]*this._v[3],o=n._v[0]*this._v[4]+n._v[4]*this._v[5]+n._v[8]*this._v[6]+n._v[12]*this._v[7],r=n._v[0]*this._v[8]+n._v[4]*this._v[9]+n._v[8]*this._v[10]+n._v[12]*this._v[11],i=n._v[0]*this._v[12]+n._v[4]*this._v[13]+n._v[8]*this._v[14]+n._v[12]*this._v[15],a=n._v[1]*this._v[0]+n._v[5]*this._v[1]+n._v[9]*this._v[2]+n._v[13]*this._v[3],s=n._v[1]*this._v[4]+n._v[5]*this._v[5]+n._v[9]*this._v[6]+n._v[13]*this._v[7],l=n._v[1]*this._v[8]+n._v[5]*this._v[9]+n._v[9]*this._v[10]+n._v[13]*this._v[11],c=n._v[1]*this._v[12]+n._v[5]*this._v[13]+n._v[9]*this._v[14]+n._v[13]*this._v[15],u=n._v[2]*this._v[0]+n._v[6]*this._v[1]+n._v[10]*this._v[2]+n._v[14]*this._v[3],_=n._v[2]*this._v[4]+n._v[6]*this._v[5]+n._v[10]*this._v[6]+n._v[14]*this._v[7],d=n._v[2]*this._v[8]+n._v[6]*this._v[9]+n._v[10]*this._v[10]+n._v[14]*this._v[11],p=n._v[2]*this._v[12]+n._v[6]*this._v[13]+n._v[10]*this._v[14]+n._v[14]*this._v[15],x=n._v[3]*this._v[0]+n._v[7]*this._v[1]+n._v[11]*this._v[2]+n._v[15]*this._v[3],v=n._v[3]*this._v[4]+n._v[7]*this._v[5]+n._v[11]*this._v[6]+n._v[15]*this._v[7],y=n._v[3]*this._v[8]+n._v[7]*this._v[9]+n._v[11]*this._v[10]+n._v[15]*this._v[11],g=n._v[3]*this._v[12]+n._v[7]*this._v[13]+n._v[11]*this._v[14]+n._v[15]*this._v[15];return this.setComponents(t,o,r,i,a,s,l,c,u,_,d,p,x,v,y,g)}fromQuaternion(n){let t=n._v[0]*n._v[0],o=n._v[1]*n._v[1],r=n._v[2]*n._v[2],i=n._v[1]*n._v[2],a=n._v[0]*n._v[2],s=n._v[0]*n._v[1],l=n._v[3]*n._v[0],c=n._v[3]*n._v[1],u=n._v[3]*n._v[2],_=1-2*(o+r),d=2*(s-u),p=2*(a+c),x=0,v=2*(s+u),y=1-2*(t+r),g=2*(i-l),E=0,w=2*(a-c),T=2*(i+l),R=1-2*(t+o);return this.setComponents(_,d,p,x,v,y,g,E,w,T,R,0,0,0,0,1)}static fromCopy16RowMajor(n,t,o,r,i,a,s,l,c,u,_,d,p,x,v,y){let g=new Float32Array(16);return g[0]=n,g[4]=t,g[8]=o,g[12]=r,g[1]=i,g[5]=a,g[9]=s,g[13]=l,g[2]=c,g[6]=u,g[10]=_,g[14]=d,g[3]=p,g[7]=x,g[11]=v,g[15]=y,new Ln(g)}static fromCopy16ColumnMajor(n,t,o,r,i,a,s,l,c,u,_,d,p,x,v,y){let g=new Float32Array(16);return g[0]=n,g[4]=i,g[8]=c,g[12]=p,g[1]=t,g[5]=a,g[9]=u,g[13]=x,g[2]=o,g[6]=s,g[10]=_,g[14]=v,g[3]=r,g[7]=l,g[11]=d,g[15]=y,new Ln(g)}static fromCopyMatrix44(n){let t=new Float32Array(16);return t.set(n._v),new Ln(t)}static fromFloat32ArrayColumnMajor(n){return new Ln(n)}static fromCopyFloat32ArrayColumnMajor(n){let t=new Float32Array(16);return t.set(n),new Ln(t)}static fromCopyFloat32ArrayRowMajor(n){let t=new Float32Array(16);return t[0]=n[0],t[4]=n[1],t[8]=n[2],t[12]=n[3],t[1]=n[4],t[5]=n[5],t[9]=n[6],t[13]=n[7],t[2]=n[8],t[6]=n[9],t[10]=n[10],t[14]=n[11],t[3]=n[12],t[7]=n[13],t[11]=n[14],t[15]=n[15],new Ln(t)}static fromCopyMatrix33(n){let t=new Float32Array(16);return t[0]=n._v[0],t[4]=n._v[3],t[8]=n._v[6],t[12]=0,t[1]=n._v[1],t[5]=n._v[4],t[9]=n._v[7],t[13]=0,t[2]=n._v[2],t[6]=n._v[5],t[10]=n._v[8],t[14]=0,t[3]=0,t[7]=0,t[11]=0,t[15]=1,new Ln(t)}static fromCopyArray16ColumnMajor(n){let t=new Float32Array(16);return t.set(n),new Ln(t)}static fromCopyArrayColumnMajor(n){let t=new Float32Array(16);return t.set(n),new Ln(t)}static fromCopyArray16RowMajor(n){let t=new Float32Array(16);return t[0]=n[0],t[4]=n[1],t[8]=n[2],t[12]=n[3],t[1]=n[4],t[5]=n[5],t[9]=n[6],t[13]=n[7],t[2]=n[8],t[6]=n[9],t[10]=n[10],t[14]=n[11],t[3]=n[12],t[7]=n[13],t[11]=n[14],t[15]=n[15],new Ln(t)}static fromCopyArrayRowMajor(n){let t=new Float32Array(16);return t[0]=n[0],t[4]=n[1],t[8]=n[2],t[12]=n[3],t[1]=n[4],t[5]=n[5],t[9]=n[6],t[13]=n[7],t[2]=n[8],t[6]=n[9],t[10]=n[10],t[14]=n[11],t[3]=n[12],t[7]=n[13],t[11]=n[14],t[15]=n[15],new Ln(t)}static fromCopyQuaternion(n){let t=n._v[0]*n._v[0],o=n._v[1]*n._v[1],r=n._v[2]*n._v[2],i=n._v[1]*n._v[2],a=n._v[0]*n._v[2],s=n._v[0]*n._v[1],l=n._v[3]*n._v[0],c=n._v[3]*n._v[1],u=n._v[3]*n._v[2],_=new Float32Array(16);return _[0]=1-2*(o+r),_[4]=2*(s-u),_[8]=2*(a+c),_[12]=0,_[1]=2*(s+u),_[5]=1-2*(t+r),_[9]=2*(i-l),_[13]=0,_[2]=2*(a-c),_[6]=2*(i+l),_[10]=1-2*(t+o),_[14]=0,_[3]=0,_[7]=0,_[11]=0,_[15]=1,new Ln(_)}};h(Ln,"MutableMatrix44");$=Ln});var xi,yu,Tw,A,ge=C(()=>{"use strict";xi={defined(m,...n){return m!==void 0},undefined(m,...n){return m===void 0},null(m,...n){return m===null},exist(m,...n){return m!=null},function(m,...n){return typeof m=="function"},true(m,...n){return m===!0},truly(m,...n){return!!m},false(m,...n){return m===!1},falsy(m,...n){return!m},stringContaining(m,n){return m.indexOf(n)!==-1}},yu={not(m){return function(){return m.apply(null,[...arguments])}},all(m){return function(){return Array.isArray(arguments[0])?arguments[0].every(m):[...arguments].every(m)}},any(m){return function(){return Array.isArray(arguments[0])?arguments[0].some(m):[...arguments].some(m)}}},Tw={defined(m,...n){return m===void 0},undefined(m,...n){return m!==void 0},null(m,...n){return m!==null},exist(m,...n){return m==null},function(m,...n){return typeof m!="function"},true(m,...n){return m!==!0},truly(m,...n){return!m},false(m,...n){return m!==!1},falsy(m,...n){return!!m}};for(let m in yu)if(Object.prototype.hasOwnProperty.call(yu,m)){xi[m]={};for(let n in xi)Object.prototype.hasOwnProperty.call(xi,n)&&(m==="not"?xi[m][n]=yu[m](Tw[n]):xi[m][n]=yu[m](xi[n]))}A=xi});function Kr(m){if(typeof window=="undefined")throw new Error("THis function works in Browser environment");let n={Touch:typeof document.ontouchstart!="undefined",Pointer:window.navigator.pointerEnabled,MSPointer:window.navigator.msPointerEnabled};return{start:n.Pointer?r0:n.MSPointer?i0:n.Touch?f0:e0,move:n.Pointer?a0:n.MSPointer?s0:n.Touch?u0:t0,end:n.Pointer?l0:n.MSPointer?c0:n.Touch?m0:n0,click:o0}[m]}var e0,t0,n0,Ew,Cw,ww,Rw,o0,Nw,Pw,Mw,r0,i0,a0,s0,l0,c0,Dw,Bw,Fw,Lw,Vw,zw,Gw,Ow,Uw,kw,Ww,Qw,Xw,Hw,f0,u0,m0,qw,jw,Yw,Kw,Zw,_0,bo,vr,gr,xr,Ft,$a=C(()=>{"use strict";ge();e0="mousedown",t0="mousemove",n0="mouseup",Ew="wheel",Cw="mouseenter",ww="mouseleave",Rw="mouseover",o0="click",Nw="keydown",Pw="keyup",Mw="keypress",r0="pointerdown",i0="MSPointerDown",a0="pointermove",s0="MSPointerMove",l0="pointerup",c0="MSPointerUp",Dw="pointercancel",Bw="pointerenter",Fw="pointerleave",Lw="pointerover",Vw="pointerout",zw="resize",Gw="orientationchange",Ow="tap",Uw="doubletap",kw="longtap",Ww="hold",Qw="drag",Xw="swipe",Hw="pinch",f0="touchstart",u0="touchmove",m0="touchend",qw="touchcancel",jw="touchenter",Yw="touchleave",Kw="touchover",Zw="touchout";h(Kr,"getEvent");_0="None",bo="CameraController",vr="GizmoTranslation",gr="GizmoScale",xr=class xr{static register(n,t){this.__inputHandlingStateMap.set(n,t),this.__activeMap.set(n,!0),this.__processEventListeners()}static unregister(n){this.__activeMap.set(n,!1),this.__inputHandlingStateMap.delete(n),this.__processEventListeners()}static setActive(n,t){this.__activeMap.set(n,t),n===vr&&t?this.__activeMap.set(gr,!1):n===gr&&t&&this.__activeMap.set(vr,!1),this.__processEventListeners()}static __addEventListeners(n){let t=xr.__inputHandlingStateMap.get(n);if(A.exist(t))for(let o of t)o.eventTargetDom.addEventListener(o.eventName,o.handler,o.options)}static __removeEventListeners(n){let t=xr.__inputHandlingStateMap.get(n);if(A.exist(t))for(let o of t)o.eventTargetDom.removeEventListener(o.eventName,o.handler,o.options)}static __processEventListeners(){let n=xr.__inputHandlingStateMap.get(vr),t=xr.__inputHandlingStateMap.get(gr);xr.__inputHandlingStateMap.get(bo)&&(this.__addEventListeners(bo),this.__currentState=bo),n&&(this.__addEventListeners(vr),this.__removeEventListeners(gr),this.__currentState=vr),t&&(this.__addEventListeners(gr),this.__removeEventListeners(vr),this.__currentState=gr)}static enableCameraController(){this.__addEventListeners(bo),this.__activeMap.set(bo,!0),this.__processEventListeners()}static disableCameraController(){this.__removeEventListeners(bo),this.__activeMap.set(bo,!1),this.__processEventListeners()}static getCurrentState(){return this.__currentState}};h(xr,"InputManager"),f(xr,"__inputHandlingStateMap",new Map),f(xr,"__activeMap",new Map),f(xr,"__currentState",_0);Ft=xr});function $w(m){return de({typeList:x0,index:m})}function eR(m){return Te({typeList:x0,str:m})}var es,bu,d0,h0,Jw,p0,x0,ke,Zi=C(()=>{"use strict";st();bu=(es=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(es,"BoneDataTypeClass"),es),d0=new bu({index:0,str:"Mat43x1"}),h0=new bu({index:1,str:"Vec4x2"}),Jw=new bu({index:2,str:"Vec4x2Old"}),p0=new bu({index:3,str:"Vec4x1"}),x0=[d0,h0,p0];h($w,"from");h(eR,"fromString");ke=Object.freeze({Mat43x1:d0,Vec4x2:h0,Vec4x2Old:Jw,Vec4x1:p0,from:$w,fromString:eR})});var A_,Ml,I_=C(()=>{"use strict";ge();A_=class A_{constructor(){f(this,"__weakMap",new WeakMap)}set(n,t){return this.__weakMap.has(n)?!1:(this.__weakMap.set(n,t),!0)}has(n){return!!this.__weakMap.has(n)}get(n){let t=this.__weakMap.get(n);return A.not.exist(t)?void 0:this.__weakMap.get(n)}delete(n){return this.__weakMap.has(n)?(this.__weakMap.delete(n),!0):!1}};h(A_,"SymbolWeakMap");Ml=A_});var T_,S_,v0=C(()=>{"use strict";I_();T_=class T_{constructor(){f(this,"__symbolWeakMap",new Ml)}register(n){this.__symbolWeakMap.set(Symbol(),n)}};h(T_,"Cache");S_=T_});var tR,nR,g0=C(()=>{"use strict";tR=h(m=>{let n=new WeakMap;return t=>{if(n.has(t))return n.get(t);let o=m(t);return n.set(t,o),o}},"objectCachify"),nR=h(m=>{let n=new Map;return t=>{if(n.has(t))return n.get(t);let o=m(t);return n.set(t,o),o}},"primitiveCachify1")});var y0=C(()=>{"use strict";v0();g0();I_()});var Dl,rr,Bl=C(()=>{"use strict";Dl=class Dl extends Error{constructor(t){super(`
  message: ${t.message}
  error: ${typeof t.error._rnException!="undefined"?"see below Exception \u2193"+t.error.toString():t.error}
`);f(this,"err");this.err=t,this.name=Dl._prefix}getRnError(){return this.err}};h(Dl,"RnException"),f(Dl,"_prefix",`
Rhodonite Exception`);rr=Dl});function Zr(m){if(m.isErr())throw new Error("This is Err. No Ok.")}function E_(m){if(m.isOk())throw new Error("This is Ok. No Err.")}var ts,b0,C_,je,w_,Ue,ir=C(()=>{"use strict";Bl();b0=(ts=class{constructor(n){f(this,"val");this.val=n}match(n){if(this instanceof je)return new je(n.Ok(this.val));if(this instanceof Ue)return new Ue(n.Err(this.val));throw new Error("This is neither Ok nor Err.")}name(){return this.constructor.name}},h(ts,"CResult"),ts),C_=class C_ extends b0{constructor(n){super(n)}andThen(n){return n(this.val)}orElse(n){return this}unwrapWithCompensation(n){return this.val}unwrapForce(){return this.val}true(){return!0}isOk(){return!0}isErr(){return!1}get(){return this.val}};h(C_,"Ok");je=C_,w_=class w_ extends b0{constructor(t){super(t);f(this,"_rnException");this._rnException=new rr(this.val)}andThen(t){return this}orElse(t){return t()}unwrapWithCompensation(t){return t(this.val)}unwrapForce(){throw this._rnException}false(){return!1}isOk(){return!1}isErr(){return!0}getRnError(){return this.val}toString(){return this._rnException.stack}};h(w_,"Err");Ue=w_;h(Zr,"assertIsOk");h(E_,"assertIsErr")});var Qo,Kt,Fl=C(()=>{"use strict";Qo=class Qo extends Promise{constructor(t){super((o,r)=>{});f(this,"__promise");f(this,"__callback");f(this,"name","");f(this,"__callbackObj",{promiseAllNum:0,resolvedNum:0,rejectedNum:0,pendingNum:0,processedPromises:[]});t instanceof Promise?this.__promise=t:this.__promise=new Promise(t)}static resolve(t){if(t instanceof Promise)return new Qo(t);if(t instanceof Qo)return t;if(t.then!=null){let o=new Qo((r,i)=>{r(t)});return o.then=t.then,o}else return new Qo((o,r)=>{o(t)})}static all(t,o){if(o){let r=[],i={promiseAllNum:t.length,resolvedNum:0,rejectedNum:0,pendingNum:t.length,processedPromises:[]};for(let a of t){let s=Qo.resolve(a);s.__callback=o,s.__callbackObj=i,r.push(s)}return new Qo(Promise.all(r))}else return new Qo(Promise.all(t))}static race(t){return new Qo(Promise.race(t))}then(t,o){let r;return t&&(r=h(i=>(this.__callbackObj.promiseAllNum!==0&&this.__callbackObj.processedPromises.indexOf(this)===-1&&(this.__callbackObj.pendingNum--,this.__callbackObj.resolvedNum++,this.__callbackObj.processedPromises.push(this)),this.__callback&&this.__callback(this.__callbackObj),t(i)),"onFulfilledWrapper")),this.__promise.then(r,o)}catch(t){return new Qo(this.__promise.catch(t))}finally(t){return this.__promise.finally(t)}static reject(t){return new Qo(Promise.reject(t))}};h(Qo,"RnPromise");Kt=Qo});var ar,ie,co=C(()=>{"use strict";ir();Fl();ar=class ar{static isNode(){return window===void 0&&typeof process!="undefined"&&typeof tu!="undefined"}static btoa(n){if(ar.isNode()){let o;return Buffer.isBuffer(n)?o=n:o=Buffer.from(n.toString(),"binary"),o.toString("base64")}else return btoa(n)}static atob(n){return ar.isNode()?Buffer.from(n,"base64").toString("binary"):atob(n)}static dataUriToArrayBuffer(n){let t=n.split(","),o=ar.atob(t[1]),r=o.length,i=new ArrayBuffer(r),a=new Uint8Array(i);for(let s=0;s<r;s++)a[s]=o.charCodeAt(s);return i}static arrayBufferToString(n){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(n);{let t=new Uint8Array(n);return this.uint8ArrayToStringInner(t)}}static uint8ArrayToString(n){return typeof TextDecoder!="undefined"?new TextDecoder().decode(n):this.uint8ArrayToStringInner(n)}static stringToBase64(n){let t=null;return t=ar.btoa(n),t}static base64ToArrayBuffer(n){if(typeof window!="undefined"){let t=window.atob(n),o=t.length,r=new Uint8Array(o);for(let i=0;i<o;i++)r[i]=t.charCodeAt(i);return r.buffer}else throw new Error("This function works in browser environment.")}static UInt8ArrayToDataURL(n,t,o){let r=document.createElement("canvas");r.width=t,r.height=o;let i=r.getContext("2d"),a=i.createImageData(t,o);for(let s=0;s<a.data.length;s+=4)a.data[s+0]=n[(o-Math.floor(s/(4*t)))*(4*t)+s%(4*t)+0],a.data[s+1]=n[(o-Math.floor(s/(4*t)))*(4*t)+s%(4*t)+1],a.data[s+2]=n[(o-Math.floor(s/(4*t)))*(4*t)+s%(4*t)+2],a.data[s+3]=n[(o-Math.floor(s/(4*t)))*(4*t)+s%(4*t)+3];return i.putImageData(a,0,0),r.remove(),r.toDataURL("image/png")}static loadResourceAsync(n,t,o,r){return new Promise((i,a)=>{if(!ar.isNode()){let l=new XMLHttpRequest;t?(l.onload=c=>{let u=null;t?u=l.response:u=l.responseText,o(i,u)},l.open("GET",n,!0),l.responseType="arraybuffer"):(l.onreadystatechange=()=>{if(l.readyState===4&&(Math.floor(l.status/100)===2||l.status===0)){let c=null;t?c=l.response:c=l.responseText,o(i,c)}else r&&r(a,l.status)},l.open("GET",n,!0)),l.send(null)}})}static toCRC32(n){let t=0,o=0,r=0,i=ar.crc32table;t=t^-1;for(let a=0,s=n.length;a<s;++a)r=(t^n.charCodeAt(a))&255,o="0x"+i[r],t=t>>>8^o;return(t^-1)>>>0}static accessBinaryAsImage(n,t,o,r){let i=this.takeBufferViewAsUint8Array(t,n,o);return this.accessArrayBufferAsImage(i,r)}static createBlobImageUriFromUint8Array(n,t){let o=new Blob([n],{type:t});return URL.createObjectURL(o)}static takeBufferViewAsUint8Array(n,t,o){var c;let r=n.bufferViews[t],i=(c=r.byteOffset)!=null?c:0,a=r.byteLength,s=o;return o instanceof Uint8Array&&(s=o.buffer,i+=o.byteOffset),new Uint8Array(s,i,a)}static accessArrayBufferAsImage(n,t){let o=this.uint8ArrayToStringInner(new Uint8Array(n));return this.getImageType(t)+ar.btoa(o)}static uint8ArrayToStringInner(n){let t=new Array(n.byteLength);for(let a=0;a<n.byteLength;a++)t[a]=n[a];let o=1024,r=Math.ceil(t.length/o),i="";for(let a=0;a<r;a++)i+=String.fromCharCode.apply(this,t.slice(a*o,(a+1)*o));return i}static getImageType(n){let t=null;return n==="image/jpeg"||n.toLowerCase()==="jpg"||n.toLowerCase()==="jpeg"?t="data:image/jpeg;base64,":n==="image/png"||n.toLowerCase()==="png"?t="data:image/png;base64,":n==="image/gif"||n.toLowerCase()==="gif"?t="data:image/gif;base64,":n==="image/bmp"||n.toLowerCase()==="bmp"?t="data:image/bmp;base64,":t="data:image/unknown;base64,",t}static getMimeTypeFromExtension(n){let t=null;return n.toLowerCase()==="jpg"||n.toLowerCase()==="jpeg"?t="image/jpeg":n.toLowerCase()==="png"?t="image/png":n.toLowerCase()==="gif"?t="image/gif":n.toLowerCase()==="bmp"?t="image/bmp":t="image/unknown",t}static getExtension(n){let t=n.split(".");return t[t.length-1]}static createUint8ArrayFromBufferViewInfo(n,t,o){var c;let r=n.bufferViews[t],i=(c=r.byteOffset)!=null?c:0,a=r.byteLength,s=o;return o instanceof Uint8Array&&(s=o.buffer,i+=o.byteOffset),new Uint8Array(s,i,a)}static createImageFromUri(n,t){return new Kt(o=>{let r=new Image;if(r.crossOrigin="Anonymous",n.match(/^blob:/)||n.match(/^data:/))r.onload=()=>{o(r)},r.src=n;else{let i=h((s,l)=>{let c=new Uint8Array(l),u=ar.createBlobImageUriFromUint8Array(c,t);s.onload=()=>{o(s),URL.revokeObjectURL(u)},s.src=u},"load");h(()=>{let s=new XMLHttpRequest;s.onreadystatechange=function(l){return function(){s.readyState===4&&s.status===200&&i(l,s.response)}}(r),s.open("GET",n),s.responseType="arraybuffer",s.send()},"loadBinaryImage")()}})}static createDefaultGltfOptions(){return{files:{},loaderExtension:void 0,defaultMaterialHelperName:void 0,defaultMaterialHelperArgumentArray:[],statesOfElements:[{targets:[],states:{enable:[],functions:{}},isTransparent:!0,opacity:1,isTextureImageToLoadPreMultipliedAlpha:!1}],tangentCalculationMode:1,extendedJson:void 0,__importedType:"undefined"}}static async fetchArrayBuffer(n){let t=await fetch(n,{mode:"cors"});if(!t.ok)return new Ue({message:`fetchArrayBuffer failed. uri: ${n}`,error:t.statusText});let o=await t.arrayBuffer();return new je(o)}static getResizedCanvas(n,t){let o=document.createElement("canvas"),r=this.getNearestPowerOfTwo(n.width),i=this.getNearestPowerOfTwo(n.height),a=i/r,s=0,l=0;return r>i?(s=Math.min(r,t),l=s*a):(l=Math.min(i,t),s=l/a),o.width=s,o.height=l,o.getContext("2d").drawImage(n,0,0,n.width,n.height,0,0,s,l),[o,s,l]}static detectTransparentPixelExistence(n,t=1){let o=n.width,r=n.height,i,a;n instanceof ImageData?a=n:n instanceof HTMLImageElement?(i=document.createElement("canvas").getContext("2d"),i.drawImage(n,0,0),a=i.getImageData(0,0,o,r)):(i=n.getContext("2d"),i.drawImage(n,0,0),a=i.getImageData(0,0,o,r));for(let s=0;s<r;s++)for(let l=0;l<o;l++)if(a.data[(l+s*o)*4+3]<t)return!0;return!1}static getNearestPowerOfTwo(n){return Math.pow(2,Math.round(Math.log(n)/Math.LN2))}static calcPaddingBytes(n,t){return n%t!==0?t-n%t:0}static addPaddingBytes(n,t){return n+this.calcPaddingBytes(n,t)}static normalizedInt8ArrayToFloat32Array(n){let t=new Float32Array(n.length);for(let o=0;o<n.length;o++)t[o]=Math.max(n[o]/127,-1);return t}static normalizedUint8ArrayToFloat32Array(n){let t=new Float32Array(n.length);for(let o=0;o<n.length;o++)t[o]=n[o]/255;return t}static normalizedInt16ArrayToFloat32Array(n){let t=new Float32Array(n.length);for(let o=0;o<n.length;o++)t[o]=Math.max(n[o]/32767,-1);return t}static normalizedUint16ArrayToFloat32Array(n){let t=new Float32Array(n.length);for(let o=0;o<n.length;o++)t[o]=n[o]/65535;return t}static getCopy({src:n,srcByteOffset:t,copyByteLength:o,distByteOffset:r}){let i=new ArrayBuffer(n.byteLength),a=new Uint8Array(i,r,o);return a.set(new Uint8Array(n,t,o)),a.buffer}static getCopyAs4Bytes({src:n,srcByteOffset:t,copyByteLength:o,distByteOffset:r}){if(t%4!==0||o%4!==0||r%4!==0)throw new Error("Invalid byte align for 4bytes unit copy operation.");let i=new ArrayBuffer(n.byteLength),a=new Int32Array(i,r,o/4);return a.set(new Int32Array(n,t,o/4)),a.buffer}static copyArrayBuffer({src:n,dist:t,srcByteOffset:o,copyByteLength:r,distByteOffset:i=0}){let a=new Uint8Array(t,i,r);return a.set(new Uint8Array(n,o,r)),a.buffer}static copyArrayBufferWithPadding({src:n,dist:t,srcByteOffset:o,copyByteLength:r,distByteOffset:i}){let a=new Uint8Array(t,i,r),s=n.byteLength-o-r;if(s<0){a.set(new Uint8Array(n,o,n.byteLength-o));let l=-s,c=new Uint8Array(l);a.set(c)}else a.set(new Uint8Array(n,o,r));return a.buffer}static copyArrayBufferAs4Bytes({src:n,dist:t,srcByteOffset:o,copyByteLength:r,distByteOffset:i}){if(o%4!==0||r%4!==0||i%4!==0)throw new Error("Invalid byte align for 4bytes unit copy operation.");let a=new Int32Array(t,i,r/4);return a.set(new Int32Array(n,o,r/4)),a.buffer}static copyArrayBufferAs4BytesWithPadding({src:n,dist:t,srcByteOffset:o,copyByteLength:r,distByteOffset:i}){let a=new Int32Array(t,i,r/4),s=n.byteLength-o-r;if(s<0){a.set(new Int32Array(n,o,(n.byteLength-o)/4));let l=-s,c=new Uint8Array(l);a.set(c)}else a.set(new Int32Array(n,o,r/4));return a.buffer}static stringToBuffer(n){return new TextEncoder().encode(n).buffer}};h(ar,"DataUtil"),f(ar,"crc32table","00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D".split(" "));ie=ar});var R_,ns,N_=C(()=>{"use strict";ye();R_=class R_ extends S{constructor(n){super(n)}get x(){return this._v[0]}get y(){return this._v[1]}get z(){return this._v[2]}get w(){return 1}get r(){return this._v[0]}get g(){return this._v[1]}get b(){return this._v[2]}get a(){return 1}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(n){return super._normalize(n,Float32Array)}static add(n,t){return super._add(n,t,Float32Array)}static subtract(n,t){return super._subtract(n,t,Float32Array)}static multiply(n,t){return super._multiply(n,t,Float32Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float32Array)}static divide(n,t){return super._divide(n,t,Float32Array)}static divideVector(n,t){return super._divideVector(n,t,Float32Array)}static cross(n,t){return super._cross(n,t,Float32Array)}clone(){return super.clone()}};h(R_,"ColorRgb");ns=R_});var M_,Ji,D_,Ee,Ll,P_,oR,rR,Xo=C(()=>{"use strict";nn();se();qa();me();M_=class M_ extends pr{constructor(n,{type:t}){super(),this._v=n}get x(){return this._v[0]}get y(){return this._v[1]}get glslStrAsFloat(){return`vec2(${Y.convertToStringAsGLSLFloat(this._v[0])}, ${Y.convertToStringAsGLSLFloat(this._v[1])})`}get glslStrAsInt(){return`ivec2(${Math.floor(this._v[0])}, ${Math.floor(this._v[1])})`}static get compositionType(){return b.Vec2}static lengthSquared(n){return n.lengthSquared()}static lengthBtw(n,t){return n.lengthTo(t)}static angleOfVectors(n,t){let o=n.length()*t.length();o===0&&N.error("length of a vector is 0!");let r=n.dot(t)/o;return Math.acos(r)}static _zero(n){return this._fromCopyArray2([0,0],n)}static _one(n){return this._fromCopyArray2([1,1],n)}static _dummy(n){return new this(new n,{type:n})}static _normalize(n,t){let o=n.length();return this._divide(n,o,t)}static _add(n,t,o){let r=n._v[0]+t._v[0],i=n._v[1]+t._v[1];return this._fromCopyArray2([r,i],o)}static addTo(n,t,o){return o._v[0]=n._v[0]+t._v[0],o._v[1]=n._v[1]+t._v[1],o}static _subtract(n,t,o){let r=n._v[0]-t._v[0],i=n._v[1]-t._v[1];return this._fromCopyArray2([r,i],o)}static subtractTo(n,t,o){return o._v[0]=n._v[0]-t._v[0],o._v[1]=n._v[1]-t._v[1],o}static _multiply(n,t,o){let r=n._v[0]*t,i=n._v[1]*t;return this._fromCopyArray2([r,i],o)}static multiplyTo(n,t,o){return o._v[0]=n._v[0]*t,o._v[1]=n._v[1]*t,o}static _multiplyVector(n,t,o){let r=n._v[0]*t._v[0],i=n._v[1]*t._v[1];return this._fromCopyArray2([r,i],o)}static multiplyVectorTo(n,t,o){return o._v[0]=n._v[0]*t._v[0],o._v[1]=n._v[1]*t._v[1],o}static _divide(n,t,o){let r,i;return t!==0?(r=n._v[0]/t,i=n._v[1]/t):(N.error("0 division occurred!"),r=1/0,i=1/0),this._fromCopyArray2([r,i],o)}static divideTo(n,t,o){return t!==0?(o._v[0]=n._v[0]/t,o._v[1]=n._v[1]/t):(N.error("0 division occurred!"),o._v[0]=1/0,o._v[1]=1/0),o}static _divideVector(n,t,o){let r,i;return t._v[0]!==0&&t._v[1]!==0?(r=n._v[0]/t._v[0],i=n._v[1]/t._v[1]):(N.error("0 division occurred!"),r=t._v[0]===0?1/0:n._v[0]/t._v[0],i=t._v[1]===0?1/0:n._v[1]/t._v[1]),this._fromCopyArray2([r,i],o)}static divideVectorTo(n,t,o){return t._v[0]!==0&&t._v[1]!==0?(o._v[0]=n._v[0]/t._v[0],o._v[1]=n._v[1]/t._v[1]):(N.error("0 division occurred!"),o._v[0]=t._v[0]===0?1/0:n._v[0]/t._v[0],o._v[1]=t._v[1]===0?1/0:n._v[1]/t._v[1]),o}static dot(n,t){return n.dot(t)}toString(){return"("+this._v[0]+", "+this._v[1]+")"}toStringApproximately(){return Y.financial(this._v[0])+" "+Y.financial(this._v[1])+`
`}flattenAsArray(){return[this._v[0],this._v[1]]}isDummy(){return this._v.length===0}isEqual(n,t=Number.EPSILON){return Math.abs(n._v[0]-this._v[0])<t&&Math.abs(n._v[1]-this._v[1])<t}isStrictEqual(n){return this._v[0]===n._v[0]&&this._v[1]===n._v[1]}at(n){return this._v[n]}length(){return Math.hypot(this._v[0],this._v[1])}lengthSquared(){return this._v[0]**2+this._v[1]**2}lengthTo(n){let t=this._v[0]-n._v[0],o=this._v[1]-n._v[1];return Math.hypot(t,o)}dot(n){return this._v[0]*n._v[0]+this._v[1]*n._v[1]}clone(){return new this.constructor(new this._v.constructor([this._v[0],this._v[1]]))}static _fromCopyArray2(n,t){return new this(new t(n),{type:t})}static _fromCopy2(n,t,o){return new this(new o([n,t]),{type:o})}static _fromCopyArray(n,t){return new this(new t(n.slice(0,2)),{type:t})}static _fromVector2(n,t){return new this(new t(n._v),{type:t})}static _fromCopyVector2(n,t){return new this(new t([n._v[0],n._v[1]]),{type:t})}static _fromCopyVector3(n,t){return new this(new t([n._v[0],n._v[1],n._v[2]]),{type:t})}static _fromCopyVector4(n,t){return new this(new t([n._v[0],n._v[1],n._v[2]]),{type:t})}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}};h(M_,"Vector2_");Ji=M_,D_=class D_ extends Ji{constructor(n){super(n,{type:Float32Array})}static fromCopyArray2(n){return super._fromCopyArray2(n,Float32Array)}static fromCopy2(n,t){return super._fromCopy2(n,t,Float32Array)}static fromCopyArray(n){return super._fromCopyArray(n,Float32Array)}static fromCopyVector2(n){return super._fromCopyVector2(n,Float32Array)}static fromCopyVector4(n){return super._fromCopyVector4(n,Float32Array)}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(n){return super._normalize(n,Float32Array)}static add(n,t){return super._add(n,t,Float32Array)}static subtract(n,t){return super._subtract(n,t,Float32Array)}static multiply(n,t){return super._multiply(n,t,Float32Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float32Array)}static divide(n,t){return super._divide(n,t,Float32Array)}static divideVector(n,t){return super._divideVector(n,t,Float32Array)}get className(){return"Vector2"}clone(){return super.clone()}};h(D_,"Vector2");Ee=D_,Ll=class Ll extends Ji{constructor(n){super(n,{type:Float64Array})}static fromCopyArray2(n){return super._fromCopyArray2(n,Float64Array)}static fromCopy2(n,t){return super._fromCopy2(n,t,Float64Array)}static fromCopyArray(n){return super._fromCopyArray(n,Float64Array)}static fromArrayBuffer(n){return new Ll(new Float64Array(n))}static fromFloat64Array(n){return new Ll(n)}static zero(){return super._zero(Float64Array)}static one(){return super._one(Float64Array)}static dummy(){return super._dummy(Float64Array)}static normalize(n){return super._normalize(n,Float64Array)}static add(n,t){return super._add(n,t,Float64Array)}static subtract(n,t){return super._subtract(n,t,Float64Array)}static multiply(n,t){return super._multiply(n,t,Float64Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float64Array)}static divide(n,t){return super._divide(n,t,Float64Array)}static divideVector(n,t){return super._divideVector(n,t,Float64Array)}clone(){return super.clone()}};h(Ll,"Vector2d");P_=Ll,oR=Ee.fromCopy2(1,1),rR=Ee.fromCopy2(0,0)});var F_,Vl,$i,pt,Au,B_,sr=C(()=>{"use strict";Xo();me();F_=class F_ extends Ji{constructor(n,{type:t}){super(n,{type:t})}set x(n){this._v[0]=n}get x(){return this._v[0]}set y(n){this._v[1]=n}get y(){return this._v[1]}get z(){return 0}get w(){return 1}raw(){return this._v}setAt(n,t){return this._v[n]=t,this}setComponents(n,t){return this._v[0]=n,this._v[1]=t,this}copyComponents(n){return this.setComponents(n._v[0],n._v[1])}zero(){return this.setComponents(0,0)}one(){return this.setComponents(1,1)}normalize(){let n=this.length();return this.divide(n),this}add(n){return this._v[0]+=n._v[0],this._v[1]+=n._v[1],this}subtract(n){return this._v[0]-=n._v[0],this._v[1]-=n._v[1],this}multiply(n){return this._v[0]*=n,this._v[1]*=n,this}multiplyVector(n){return this._v[0]*=n._v[0],this._v[1]*=n._v[1],this}divide(n){return n!==0?(this._v[0]/=n,this._v[1]/=n):(N.error("0 division occurred!"),this._v[0]=1/0,this._v[1]=1/0),this}divideVector(n){return n._v[0]!==0&&n._v[1]!==0?(this._v[0]/=n._v[0],this._v[1]/=n._v[1]):(N.error("0 division occurred!"),this._v[0]=n._v[0]===0?1/0:this._v[0]/n._v[0],this._v[1]=n._v[1]===0?1/0:this._v[1]/n._v[1]),this}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}};h(F_,"MutableVector2_");Vl=F_,$i=class $i extends Vl{constructor(n){super(n,{type:Float32Array})}static fromCopyArray2(n){return new $i(new Float32Array(n))}static fromCopyArray(n){return new $i(new Float32Array(n.slice(0,2)))}static fromFloat32Array(n){return new $i(n)}static fromCopyFloat32Array(n){return new $i(new Float32Array(n.buffer.slice(0)))}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(n){return super._normalize(n,Float32Array)}static add(n,t){return super._add(n,t,Float32Array)}static subtract(n,t){return super._subtract(n,t,Float32Array)}static multiply(n,t){return super._multiply(n,t,Float32Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float32Array)}static divide(n,t){return super._divide(n,t,Float32Array)}static divideVector(n,t){return super._divideVector(n,t,Float32Array)}get className(){return"MutableVector2"}clone(){return super.clone()}};h($i,"MutableVector2");pt=$i,Au=class Au extends Vl{constructor(n){super(n,{type:Float64Array})}static fromCopyArray(n){return new Au(new Float64Array(n))}static zero(){return super._zero(Float64Array)}static one(){return super._one(Float64Array)}static dummy(){return super._dummy(Float64Array)}static normalize(n){return super._normalize(n,Float64Array)}static add(n,t){return super._add(n,t,Float64Array)}static subtract(n,t){return super._subtract(n,t,Float64Array)}static multiply(n,t){return super._multiply(n,t,Float64Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float64Array)}static divide(n,t){return super._divide(n,t,Float64Array)}static divideVector(n,t){return super._divideVector(n,t,Float64Array)}clone(){return super.clone()}};h(Au,"MutableVector2d");B_=Au});var Iu,Jr,Su=C(()=>{"use strict";Iu=class Iu{constructor(n,t,o){f(this,"__data");f(this,"__channels");f(this,"__width");f(this,"__height");this.__channels=o,this.__width=n,this.__height=t,this.__data=new Float32Array(n*t*o)}resize(n,t,o){this.__width=n,this.__height=t,this.__channels=o,this.__data=new Float32Array(Iu.transfer(this.__data.buffer,n*t*o*4))}setPixelAtChannel(n,t,o,r){this.__data[t*this.__width*this.__channels+n*this.__channels+o]=r}get width(){return this.__width}get height(){return this.__height}get data(){return this.__data}getPixel(n,t,o){return this.__data[t*this.__width*this.__channels+n*this.__channels+o]}getPixelAs(n,t,o,r){if(o===3)return new r(new Float32Array([this.__data[t*this.__width*this.__channels+n*this.__channels+0],this.__data[t*this.__width*this.__channels+n*this.__channels+1],this.__data[t*this.__width*this.__channels+n*this.__channels+2]]));if(o===4)return new r(new Float32Array([this.__data[t*this.__width*this.__channels+n*this.__channels+0],this.__data[t*this.__width*this.__channels+n*this.__channels+1],this.__data[t*this.__width*this.__channels+n*this.__channels+2],this.__data[t*this.__width*this.__channels+n*this.__channels+3]]))}getPixelAsArray(n,t){let o=[];for(let r=0;r<this.__channels;r++)o.push(this.__data[t*this.__width*this.__channels+n*this.__channels+r]);return o}initialize(n,t,o){this.__width=n,this.__height=t,this.__channels=o,this.__data=new Float32Array(n*t*o)}static transfer(n,t){n=Object(n);let o=new ArrayBuffer(t);if(!(n instanceof ArrayBuffer)||!(o instanceof ArrayBuffer))throw new TypeError("Source and destination must be ArrayBuffer instances");if(o.byteLength>=n.byteLength){let i=0,a=n.byteLength;[8,4,2,1].forEach(l=>{if(a>=l){let c=r(l,n,o,i,a);i=c.nextOffset,a=c.leftBytes}})}return o;function r(i,a,s,l,c){let u=Uint8Array;switch(i){case 8:u=Float64Array;break;case 4:u=Float32Array;break;case 2:u=Uint16Array;break;case 1:u=Uint8Array;break;default:u=Uint8Array;break}let _=new u(a,l,Math.trunc(c/i)),d=new u(s,l,Math.trunc(c/i));for(let p=0;p<d.length;p++)d[p]=_[p];return{nextOffset:_.byteOffset+_.byteLength,leftBytes:a.byteLength-(_.byteOffset+_.byteLength)}}}};h(Iu,"TextureDataFloat");Jr=Iu});function iR(m,n){let t=0,o=0,r=0,i=0,a=0,s=0,l=0,c=0,u=0;for(let v=0;v<m.height;v++)for(let y=0;y<m.width;y++){let g=m.getPixelAs(y,v,3,ns);t+=g.x,o+=g.y,r+=g.z,i+=g.x*g.x,a+=g.y*g.y,s+=g.z*g.z,l+=g.x*g.y,c+=g.x*g.z,u+=g.y*g.z}let _=m.width*m.height;t/=_,o/=_,r/=_,i/=_,a/=_,s/=_,l/=_,c/=_,u/=_;let d=We.zero();d.m00=i-t*t,d.m01=l-t*o,d.m02=c-t*r,d.m10=l-t*o,d.m11=a-o*o,d.m12=u-o*r,d.m20=c-t*r,d.m21=u-o*r,d.m22=s-r*r;let p=We.zero(),x=L.zero();Y.computeEigenValuesAndVectors(d,p,x),n[0]=S.fromCopyArray([p.m00,p.m10,p.m20]),n[1]=S.fromCopyArray([p.m01,p.m11,p.m21]),n[2]=S.fromCopyArray([p.m02,p.m12,p.m22])}function aR(m,n,t,o,r,i){let a=[L.zero(),L.zero(),L.zero()];iR(m,a);for(let l=0;l<m.height;l++)for(let c=0;c<m.width;c++)for(let u=0;u<3;++u){let _=m.getPixelAs(c,l,3,ns),d=S.dot(_,a[u]);n.setPixelAtChannel(c,l,u,d)}let s=[pt.fromCopyArray2([Number.MAX_VALUE,-Number.MAX_VALUE]),pt.fromCopyArray2([Number.MAX_VALUE,-Number.MAX_VALUE]),pt.fromCopyArray2([Number.MAX_VALUE,-Number.MAX_VALUE])];for(let l=0;l<m.height;l++)for(let c=0;c<m.width;c++)for(let u=0;u<3;++u)s[u].x=Math.min(s[u].x,n.getPixelAsArray(c,l)[u]),s[u].y=Math.max(s[u].y,n.getPixelAsArray(c,l)[u]);for(let l=0;l<m.height;l++)for(let c=0;c<m.width;c++)for(let u=0;u<3;++u){let d=(n.getPixelAsArray(c,l)[u]-s[u].x)/(s[u].y-s[u].x);n.setPixelAtChannel(c,l,u,d)}i.x=s[0].x*a[0].x+s[1].x*a[1].x+s[2].x*a[2].x,i.y=s[0].x*a[0].y+s[1].x*a[1].y+s[2].x*a[2].y,i.z=s[0].x*a[0].z+s[1].x*a[1].z+s[2].x*a[2].z,t.x=a[0].x*(s[0].y-s[0].x),t.y=a[0].y*(s[0].y-s[0].x),t.z=a[0].z*(s[0].y-s[0].x),o.x=a[1].x*(s[1].y-s[1].x),o.y=a[1].y*(s[1].y-s[1].x),o.z=a[1].z*(s[1].y-s[1].x),r.x=a[2].x*(s[2].y-s[2].x),r.y=a[2].y*(s[2].y-s[2].x),r.z=a[2].z*(s[2].y-s[2].x)}function sR(m,n,t){let o=1<<n,r=0;for(let i=0;i<m.height;i+=o)for(let a=0;a<m.width;a+=o){let s=0,l=0;for(let u=0;u<o;u++)for(let _=0;_<o;_++){let d=m.getPixel(a+_,i+u,t);s+=d,l+=d*d}s/=o*o,l/=o*o;let c=Math.max(0,l-s*s);r+=c/(m.width*m.height/o/o)}return r}function lR(m,n,t,o,r=128){let i=2*r,a=0;for(let s=0;s<i;s++){let l=(s+.5)/i,c=Y.invGaussianCdf(l,n,t),u=Math.max(0,Math.min(r-1,Math.floor(c*r))),_=m.getPixelAsArray(u,0)[o];a+=_}return a/=i,a}function cR(m,n,t){for(let o=1;o<n.height;o++){let r=sR(m,o,t),i=Math.sqrt(r);for(let a=0;a<n.width;a++){let s=(a+.5)/n.width,l=lR(n,s,i,t);n.setPixelAtChannel(a,o,t,l)}}}function fR(m){let n=[];for(let t=0;t<m;t++)n.push({});return n}function uR(m,n,t,o=.5,r=.16666){let i=fR(m.height*m.width);for(let a=0;a<m.height;a++)for(let s=0;s<m.width;s++)i[a*m.width+s].x=s,i[a*m.width+s].y=a,i[a*m.width+s].value=m.getPixel(s,a,t);i.sort((a,s)=>a.value<s.value?-1:a.value>s.value?1:0);for(let a=0;a<i.length;a++){let s=i[a].x,l=i[a].y,c=(a+.5)/i.length,u=Y.invGaussianCdf(c,o,r);n.setPixelAtChannel(s,l,t,u)}}function mR(m,n,t,o=.5,r=.16666){let i=[];for(let a=0;a<m.height;a++)for(let s=0;s<m.width;s++)i[a*m.width+s]=m.getPixel(s,a,t);i.sort((a,s)=>a<s?-1:a>s?1:0);for(let a=0;a<n.width;a++){let s=(a+.5)/n.width,l=Y.gaussianCdf(s,o,r),c=Math.floor(l*i.length),u=i[c];n.setPixelAtChannel(a,0,t,u)}}function _R(m,n=128){let t={};t.lutWidth=n,t.colorSpaceVector1=L.zero(),t.colorSpaceVector2=L.zero(),t.colorSpaceVector3=L.zero(),t.colorSpaceOrigin=L.zero();let o=new Jr(m.width,m.height,3);aR(m,o,t.colorSpaceVector1,t.colorSpaceVector2,t.colorSpaceVector3,t.colorSpaceOrigin);let r=new Jr(m.width,m.height,3);t.Tinput=r;for(let a=0;a<3;a++)uR(o,r,a);let i=new Jr(n,1,3);t.Tinv=i;for(let a=0;a<3;a++)mR(o,i,a);i.resize(i.width,Math.floor(Math.log(r.width)/Math.log(2)),3);for(let a=0;a<3;a++)cR(r,i,a);return t}function dR(m,n,t){let o=document.createElement("canvas");return o.width=n,o.height=t,o.getContext("2d").drawImage(m,0,0,m.width,m.height,0,0,n,t),o}function hR(m){let n=m.width,t=m.height,o=document.createElement("canvas");o.width=n,o.height=t;let r=o.getContext("2d"),i=r.getImageData(0,0,n,t);if(A.exist(m.r_image)){let s=m.r_image.getContext("2d").getImageData(0,0,m.r_image.width,m.r_image.height);for(let l=0;l<n*t;l++)i.data[l*4+0]=s.data[l*4+0]}else for(let a=0;a<n*t;a++)i.data[a*4+0]=0;if(A.exist(m.g_image)){let s=m.g_image.getContext("2d").getImageData(0,0,m.g_image.width,m.g_image.height);for(let l=0;l<n*t;l++)i.data[l*4+1]=s.data[l*4+1]}else for(let a=0;a<n*t;a++)i.data[a*4+1]=0;if(A.exist(m.b_image)){let s=m.b_image.getContext("2d").getImageData(0,0,m.b_image.width,m.b_image.height);for(let l=0;l<n*t;l++)i.data[l*4+2]=s.data[l*4+2]}else for(let a=0;a<n*t;a++)i.data[a*4+2]=0;if(A.exist(m.a_image)){let s=m.a_image.getContext("2d").getImageData(0,0,m.a_image.width,m.a_image.height);for(let l=0;l<n*t;l++)i.data[l*4+3]=s.data[l*4+3]}else for(let a=0;a<n*t;a++)i.data[a*4+3]=0;return r.putImageData(i,0,0),o}var pR,A0=C(()=>{"use strict";ye();or();nn();Ot();N_();sr();Su();ge();h(iR,"computeEigenVectors");h(aR,"decorrelateColorSpace");h(sR,"computeLODAverageSubpixelVariance");h(lR,"filterLUTValueAtx");h(cR,"prefilterLUT");h(fR,"generatePixelSortTypeArray");h(uR,"computeTinput");h(mR,"computeInvT");h(_R,"precomputations");h(dR,"convertHTMLImageElementToCanvas");h(hR,"combineImages");pR=Object.freeze({precomputations:_R})});function jn(m){if(m==null)throw new Error(`Expected 'val' to be existed, but received ${m}`)}function z_(m){return JSON.parse(JSON.stringify(m))}function E0(m,n){let t=document.createElement("a");t.download=m;let o=new Blob([n],{type:"octet/stream"}),r=URL.createObjectURL(o);t.href=r;let i=new MouseEvent("click");t.dispatchEvent(i),URL.revokeObjectURL(r)}function C0(m,n){let t=document.createElement("a");t.download=m;let o=new Blob([n],{type:"octet/stream"}),r=URL.createObjectURL(o);t.href=r;let i=new MouseEvent("click");t.dispatchEvent(i),URL.revokeObjectURL(r)}var xR,I0,vR,gR,S0,yR,bR,AR,IR,SR,TR,vi,ER,CR,os,wR,L_,RR,NR,PR,MR,V_,Tu,DR,BR,FR,T0,on,Vn=C(()=>{"use strict";ge();xR=h(function(){return typeof window!="undefined"?/(Pacific Build.+OculusBrowser.+SamsungBrowser.+)|(SamsungBrowser)|(Mobile VR)/i.test(window.navigator.userAgent):!1},"isMobileVr"),I0=h(function(){let m=["iPod","iPad","iPhone","Android"];for(let n=0;n<m.length;n++)if(navigator.userAgent.indexOf(m[n])>0)return!0;return S0()},"isMobile"),vR=h(function(){return navigator.userAgent.indexOf("Safari")>0&&navigator.userAgent.indexOf("Chrome")===-1},"isSafari"),gR=h(function(){let m=["iPod","iPad","iPhone"];for(let n=0;n<m.length;n++)if(navigator.userAgent.indexOf(m[n])>0)return!0;return S0()},"isIOS"),S0=h(function(){return navigator.userAgent.indexOf("Macintosh")>-1&&"ontouchend"in document},"isIPad"),yR=h(function(m){I0()||m.preventDefault()},"preventDefaultForDesktopOnly"),bR=h(function(m){return m instanceof Object&&!(m instanceof Array)},"isObject"),AR=h(function(m,n){return new Function("return `"+m+"`;").call(n)},"fillTemplate"),IR=h(function(){return typeof process!="undefined"&&typeof tu!="undefined"},"isNode"),SR=h(function(m,n,t,o){let r=0;for(let u=0;u<n.length;++u)r+=n[u];let i;o!=null?i=new Uint8Array(o):i=new Uint8Array(r);let a=h(u=>o!=null&&s+u>o?s+u-o:0,"getExceededSize"),s=0,l=h((u,_)=>{let d=a(u);return d?(i.set(new Uint8Array(m[_],t[_],d),s),s+=d,!0):(i.set(new Uint8Array(m[_],t[_],u),s),s+=u,!1)},"addData"),c=h(u=>{let _=a(u);return _?(i.set(new Uint8Array(_),s),s+=_,!0):(i.set(new Uint8Array(u),s),s+=u,!1)},"addOverSizeData");for(let u=0;u<m.length;++u){let _=n[u]+t[u]-m[u].byteLength,d=_>0?_:0,p=n[u]-d;if(l(p,u)||d>0&&c(d))return i.buffer}return o!=null&&s<o&&i.set(new Uint8Array(o-s),s),i.buffer},"concatArrayBuffers"),TR=h(({finalSize:m,srcs:n,srcsOffset:t,srcsCopySize:o})=>{let r=new Uint8Array(new ArrayBuffer(m)),i=0;for(let a in n){let s=n[a],l=new Uint8Array(s,t[a],o[a]);r.set(l,i),i+=o[a]}return r.buffer},"concatArrayBuffers2"),vi=h(({value:m,defaultValue:n})=>m==null?n:m,"valueWithDefault"),ER=h((m,n)=>A.exist(n)?(m(n),!0):!1,"ifExistsThen"),CR=h((m,n)=>A.exist(n)?m(n):n,"ifExistsThenWithReturn"),os=h((m,n)=>A.exist(n)?(m(n),!0):!1,"ifDefinedThen"),wR=h((m,n)=>A.exist(n)?m(n):n,"ifDefinedThenWithReturn"),L_=h((m,n)=>A.undefined(n)?(m(),!1):!0,"ifUndefinedThen"),RR=h((m,n)=>A.undefined(n)?m():n,"ifUndefinedThenWithReturn"),NR=h((m,n)=>{A.undefined(n)&&m()},"ifNotExistsThen"),PR=h((m,n)=>A.undefined(n)?m():n,"ifNotExistsThenWithReturn"),MR=h((m,n)=>n==null?m:n,"defaultValue"),V_=h(({value:m,compensation:n})=>m==null?n():m,"valueWithCompensation"),Tu=h(m=>m==null?[]:m,"nullishToEmptyArray"),DR=h(m=>m==null?new Map:m,"nullishToEmptyMap"),BR=h((m,n)=>m>n?{result:!0,greater:m,less:n}:{result:!1,greater:n,less:m},"greaterThan"),FR=h((m,n)=>m<n?{result:!0,greater:n,less:m}:{result:!1,greater:m,less:n},"lessThan"),T0=h(m=>{let n=m.split(/\r\n|\r|\n/),t="";for(let o=0;o<n.length;o++){let r=o+1,i=" : ";r<10?i="  : ":r>=100&&(i=": "),t+=r+i+n[o]+`
`}return t},"addLineNumberToCode");h(jn,"assertExist");h(z_,"deepCopyUsingJsonStringify");h(E0,"downloadArrayBuffer");h(C0,"downloadTypedArray");on=Object.freeze({isMobileVr:xR,isMobile:I0,isIOS:gR,isSafari:vR,preventDefaultForDesktopOnly:yR,isObject:bR,fillTemplate:AR,isNode:IR,concatArrayBuffers:SR,concatArrayBuffers2:TR,addLineNumberToCode:T0,downloadArrayBuffer:E0,downloadTypedArray:C0})});function LR(m){if(!m.has())throw new ReferenceError(G_)}function VR(m){if(m.has())throw new ReferenceError(G_)}var G_,O_,lt,U_,be,zl=C(()=>{"use strict";G_="The value does not exist!",O_=class O_{constructor(n){f(this,"value");this.value=n}andThen(n){return n(this.value)}orElse(n){return this}match(n){return n.Some(this.value)}unwrapOrDefault(n){return this.value}unwrapOrElse(n){return this.value}unwrapForce(){return this.value}unwrapOrUndefined(){return this.value}get(){return this.value}has(){return!0}doesNotHave(){return!1}};h(O_,"Some");lt=O_,U_=class U_{andThen(n){return this}orElse(n){return n()}match(n){return n.None()}unwrapOrDefault(n){return n}unwrapOrElse(n){return n()}unwrapForce(){throw new ReferenceError(G_)}unwrapOrUndefined(){}has(){return!1}doesNotHave(){return!0}};h(U_,"None");be=U_;h(LR,"assertHas");h(VR,"assertDoesNotHave")});var Rt,Ho,Eu=C(()=>{"use strict";Rt=class Rt{static _processBegin(){Rt.__currentProcessBeginTime=performance.now(),Rt.__intervalProcessBegin=Rt.__currentProcessBeginTime-Rt.__lastProcessBeginTime,Rt.__systemStartTime===0&&(Rt.__systemStartTime=Rt.__currentProcessBeginTime),Rt.__lastProcessBeginTime=Rt.__currentProcessBeginTime}static _processEnd(){Rt.__lastProcessEndTime=performance.now(),Rt.__lastTickTimeInterval=Rt.__lastProcessEndTime-Rt.__currentProcessBeginTime}static get timeAtProcessBeginMilliseconds(){return Rt.__currentProcessBeginTime}static get timeAtProcessEndMilliseconds(){return Rt.__lastProcessEndTime}static get timeFromSystemStart(){return(performance.now()-Rt.__systemStartTime)/1e3}static get lastTickTimeInterval(){return Rt.__lastTickTimeInterval/1e3}static get intervalProcessBegin(){return Rt.__intervalProcessBegin/1e3}static get lastTimeTimeIntervalInMilliseconds(){return Rt.__lastTickTimeInterval}};h(Rt,"Time"),f(Rt,"__currentProcessBeginTime",0),f(Rt,"__lastProcessBeginTime",0),f(Rt,"__lastProcessEndTime",0),f(Rt,"__lastTickTimeInterval",0),f(Rt,"__systemStartTime",0),f(Rt,"__intervalProcessBegin",0);Ho=Rt});var w0,X_,k_,H_,W_,q_,Q_,R0=C(()=>{"use strict";ge();w0="The value does not exist!",X_=class X_{constructor(){f(this,"__weakMap",new WeakMap)}set(n,t){this.__weakMap.set(n,t)}unwrapOrDefault(n,t){let o=this.__weakMap.get(n);return A.exist(o)?o:t}unwrapOrElse(n,t){let o=this.__weakMap.get(n);return A.exist(o)?o:t()}unwrapForce(n){let t=this.__weakMap.get(n);if(A.exist(t))return t;throw new ReferenceError(w0)}unwrapOrUndefined(n){return this.__weakMap.get(n)}has(n){return this.__weakMap.has(n)}};h(X_,"WeakOption");k_=X_,H_=class H_{constructor(n,t){f(this,"__weakMap",new WeakMap);this.__weakMap.set(n,t)}unwrapOrDefault(n,t){return this.__weakMap.get(n)}unwrapOrElse(n,t){return this.__weakMap.get(n)}unwrapForce(n){return this.__weakMap.get(n)}get(n){return this.__weakMap.get(n)}unwrapOrUndefined(n){return this.__weakMap.get(n)}has(n){return!0}};h(H_,"WeakSome");W_=H_,q_=class q_{then(){return this}unwrapOrDefault(n,t){return t}unwrapOrElse(n,t){return t(void 0)}unwrapForce(n){throw new ReferenceError(w0)}unwrapOrUndefined(n){}has(){return!1}};h(q_,"WeakNone");Q_=q_});var yr=C(()=>{"use strict";y0();co();st();A0();ge();Vn();zl();ir();Fl();Bl();Eu();R0();me()});var zR,GR,N0,OR,UR,P0,kR,WR,QR,XR,M0,D0,HR,qR,jR,YR,KR,ZR,JR,$R,eN,tN,nN,oN,rN,F,tt=C(()=>{"use strict";Zi();yr();zR=5e3,GR=4,N0=41,OR=10,UR=10,P0=33,kR=30,WR=512,QR=300,XR=50,M0=Math.pow(2,12),D0=Math.pow(2,12),HR=ke.Mat43x1,qR=4,jR=0,YR=!1,ZR=!0,JR=!1,$R=!1,eN=1,tN=.5,nN=.4,oN=!1,rN=4;typeof navigator!="undefined"&&(on.isMobile()||on.isMobileVr())&&(N0=4,P0=32,M0=2**9,D0=2**9);F={maxEntityNumber:zR,maxLightNumberInShader:GR,maxVertexMorphNumberInShader:N0,maxVertexPrimitiveNumberInShader:OR,maxMaterialInstanceForEachType:UR,boneDataType:HR,maxSkeletonNumber:P0,maxCameraNumber:kR,maxSizeLimitOfNonCompressedTexture:WR,maxSkeletalBoneNumber:QR,maxSkeletalBoneNumberForUniformMode:XR,dataTextureWidth:M0,dataTextureHeight:D0,maxMorphTargetNumber:qR,totalSizeOfGPUShaderDataStorageExceptMorphData:jR,isUboEnabled:YR,eventTargetDom:KR,cacheWebGpuRenderBundles:ZR,cgApiDebugConsoleOutput:JR,multiViewForWebVR:$R,physicsTimeIntervalScale:eN,vrmSpringBoneBonAxisCoeff:tN,vrmSpringBoneToCoeff:nN,isMobile:oN,shadowMapTextureArrayLength:rN}});var xt,ea,j_=C(()=>{"use strict";ye();Ot();nn();or();yo();Yt();pi();ou();ge();$a();tt();xt=class xt extends Xi{constructor(t){super();f(this,"dollyScale",2);f(this,"scaleOfLengthCenterToCamera",1);f(this,"moveSpeed",1);f(this,"followTargetAABB",!1);f(this,"autoUpdate",!0);f(this,"__updated",!1);f(this,"__updateCount",0);f(this,"__fixedLengthOfCenterToEye",1);f(this,"__isMouseDown",!1);f(this,"__lastMouseDownTimeStamp",0);f(this,"__lastMouseUpTimeStamp",0);f(this,"__originalY",-1);f(this,"__originalX",-1);f(this,"__buttonNumber",0);f(this,"__mouse_translate_y",0);f(this,"__mouse_translate_x",0);f(this,"__efficiency",1);f(this,"__lengthOfCenterToEye",1);f(this,"__fovyBias",1);f(this,"__scaleOfTranslation",2.8);f(this,"__mouseTranslateVec",L.zero());f(this,"__newEyeVec",L.zero());f(this,"__newCenterVec",L.zero());f(this,"__newUpVec",L.zero());f(this,"__newTangentVec",L.zero());f(this,"__isSymmetryMode",!0);f(this,"__rot_bgn_x",0);f(this,"__rot_bgn_y",0);f(this,"__rot_x",0);f(this,"__rot_y",0);f(this,"__dolly",.5);f(this,"__eyeVec",L.zero());f(this,"__centerVec",L.zero());f(this,"__upVec",L.zero());f(this,"__targetEntities",[]);f(this,"__scaleOfZNearAndZFar",5e3);f(this,"__doPreventDefault",!1);f(this,"__isPressingShift",!1);f(this,"__isPressingCtrl",!1);f(this,"__pinchInOutControl",!1);f(this,"__pinchInOutOriginalDistance",null);f(this,"__maximum_y");f(this,"__minimum_y");f(this,"__resetDollyTouchTime",0);f(this,"__initialTargetAABB");f(this,"aabbWithSkeletal",!0);f(this,"useInitialTargetAABBForLength",!1);f(this,"__mouseDownFunc",this.__mouseDown.bind(this));f(this,"__mouseUpFunc",this.__mouseUp.bind(this));f(this,"__mouseMoveFunc",this.__mouseMove.bind(this));f(this,"__touchDownFunc",this.__touchDown.bind(this));f(this,"__touchUpFunc",this.__touchUp.bind(this));f(this,"__touchMoveFunc",this.__touchMove.bind(this));f(this,"__pinchInOutFunc",this.__pinchInOut.bind(this));f(this,"__pinchInOutEndFunc",this.__pinchInOutEnd.bind(this));f(this,"__mouseWheelFunc",this.__mouseWheel.bind(this));f(this,"__mouseDblClickFunc",this.__mouseDblClick.bind(this));f(this,"__contextMenuFunc",this.__contextMenu.bind(this));f(this,"__pressShiftFunc",this.__pressShift.bind(this));f(this,"__releaseShiftFunc",this.__releaseShift.bind(this));f(this,"__pressCtrlFunc",this.__pressCtrl.bind(this));f(this,"__releaseCtrlFunc",this.__releaseCtrl.bind(this));f(this,"__resetDollyAndPositionFunc",this.__resetDollyAndPosition.bind(this));f(this,"__cameraControllerComponent");this.registerEventListeners(),this.__cameraControllerComponent=t}get updateCount(){return this.__updateCount}_updateCount(){this.__updateCount++,this.__cameraControllerComponent._updateCount(this.__updateCount)}resetDollyAndTranslation(){this.__dolly=.5,this.__mouse_translate_x=0,this.__mouse_translate_y=0,this.__mouseTranslateVec=L.zero()}setTarget(t){this.setTargets([t])}setTargets(t){this.__targetEntities=t,this.__initialTargetAABB=void 0,this.__updated=!1,this._updateCount()}getTargets(){return this.__targetEntities}set doPreventDefault(t){this.__doPreventDefault=t}get doPreventDefault(){return this.__doPreventDefault}__mouseDown(t){this.__tryToPreventDefault(t),!this.__isPressingCtrl&&(this.__originalX=t.clientX,this.__originalY=t.clientY,this.__rot_bgn_x=this.__rot_x,this.__rot_bgn_y=this.__rot_y,this.__isMouseDown=!0,this.__lastMouseDownTimeStamp=t.timeStamp,this.__updated=!1,this._updateCount())}__mouseMove(t){if(this.__tryToPreventDefault(t),A.false(this.isMouseDown)||this.__isPressingCtrl)return;this.__buttonNumber===0&&(this.__buttonNumber=t.buttons);let o=t.clientX,r=t.clientY;switch(this.__buttonNumber){case 1:this.__isPressingShift?this.__parallelTranslateControl(this.__originalX,this.__originalY,o,r):(this.__rotateControl(this.__originalX,this.__originalY,o,r),this.__rot_bgn_x=this.__rot_x,this.__rot_bgn_y=this.__rot_y);break;case 2:this.__zoomControl(this.__originalX,o);break;case 4:this.__parallelTranslateControl(this.__originalX,this.__originalY,o,r);break;default:return}this.__originalX=o,this.__originalY=r,this.__updated=!1,this._updateCount()}__mouseUp(t){this.__buttonNumber=0,this.__originalX=-1,this.__originalY=-1,this.__isMouseDown=!1,this.__lastMouseUpTimeStamp=t.timeStamp,this.__updated=!1,this._updateCount()}__touchDown(t){this.__tryToPreventDefault(t),t.touches.length===1?(this.__originalX=t.touches[0].clientX,this.__originalY=t.touches[0].clientY,this.__rot_bgn_x=this.__rot_x,this.__rot_bgn_y=this.__rot_y):(this.__originalX=(t.touches[0].clientX+t.touches[1].clientX)*.5,this.__originalY=(t.touches[0].clientY+t.touches[1].clientY)*.5),this.__isMouseDown=!0,this.__lastMouseDownTimeStamp=t.timeStamp,this.__updated=!1,this._updateCount()}__touchMove(t){if(this.__tryToPreventDefault(t),A.false(this.isMouseDown))return;let o=t.touches[0].clientX,r=t.touches[0].clientY;t.touches.length===1?(o=t.touches[0].clientX,r=t.touches[0].clientY,this.__rotateControl(this.__originalX,this.__originalY,o,r),this.__rot_bgn_x=this.__rot_x,this.__rot_bgn_y=this.__rot_y):(o=(t.touches[0].clientX+t.touches[1].clientX)*.5,r=(t.touches[0].clientY+t.touches[1].clientY)*.5,this.__parallelTranslateControl(this.__originalX,this.__originalY,o,r)),this.__originalX=o,this.__originalY=r,this.__updated=!1,this._updateCount()}__touchUp(t){let o=t.touches.length;o===0?(this.__originalX=-1,this.__originalY=-1):o===1?(this.__originalX=t.touches[0].clientX,this.__originalY=t.touches[0].clientY,this.__rot_bgn_x=this.__rot_x,this.__rot_bgn_y=this.__rot_y):(this.__originalX=(t.touches[0].clientX+t.touches[1].clientX)*.5,this.__originalY=(t.touches[0].clientY+t.touches[1].clientY)*.5),this.__isMouseDown=!1,this.__lastMouseUpTimeStamp=t.timeStamp,this.__updated=!1,this._updateCount()}set rotX(t){this.__rot_x=t,this.__updated=!1,this._updateCount()}get rotX(){return this.__rot_x}set rotY(t){this.__rot_y=t,this.__updated=!1,this._updateCount()}get rotY(){return this.__rot_y}set maximumY(t){this.__maximum_y=t}set minimumY(t){this.__minimum_y=t}__rotateControl(t,o,r,i){let a=(r-t)*this.__efficiency*.3,s=(i-o)*this.__efficiency*.3;this.__rot_x=this.__rot_bgn_x-a,this.__rot_y=this.__rot_bgn_y-s,this.__maximum_y!=null&&this.__rot_y>this.__maximum_y&&(this.__rot_y=this.__maximum_y),this.__minimum_y!=null&&this.__rot_y<this.__minimum_y&&(this.__rot_y=this.__minimum_y)}__zoomControl(t,o){this.dolly-=(o-t)/1e3*this.__efficiency}__parallelTranslateControl(t,o,r,i){this.__mouse_translate_y=(i-o)/1e3*this.__efficiency,this.__mouse_translate_x=(r-t)/1e3*this.__efficiency;let a=this.__lengthOfCenterToEye*this.__fovyBias*this.__scaleOfTranslation,s=xt.__tmpVec3_0;s.copyComponents(this.__newUpVec).normalize().multiply(this.__mouse_translate_y).multiply(a);let l=xt.__tmpVec3_1;l.copyComponents(this.__newTangentVec).normalize().multiply(this.__mouse_translate_x).multiply(a),this.__mouseTranslateVec.add(s).add(l)}__getTouchesDistance(t){let o=t.touches,r=o[1].clientX-o[0].clientX,i=o[1].clientY-o[0].clientY;return Math.hypot(r,i)}__pinchInOut(t){if(t.touches.length<2)return;if(this.__pinchInOutOriginalDistance==null){this.__pinchInOutOriginalDistance=this.__getTouchesDistance(t);return}let o=this.__getTouchesDistance(t),r=this.__pinchInOutOriginalDistance;if(!this.__pinchInOutControl){Math.abs(o-r)>35&&(this.__pinchInOutOriginalDistance=o,this.__pinchInOutControl=!0);return}let i=r/o;this.dolly*=Math.pow(i*this.__efficiency,2.2/15),this.__pinchInOutOriginalDistance=o,this.__updated=!1,this._updateCount()}__pinchInOutEnd(t){t.touches.length<2&&(this.__pinchInOutControl=!1,this.__pinchInOutOriginalDistance=null),this.__updated=!1,this._updateCount()}__tryToPreventDefault(t){this.__doPreventDefault&&t.preventDefault()}__mouseWheel(t){this.__tryToPreventDefault(t),this.dolly+=Math.sign(t.deltaY)/200,this.__updated=!1,this._updateCount()}__contextMenu(t){this.__tryToPreventDefault(t)}set dolly(t){t=Math.min(t,1),t=Math.max(t,1e-4);let o=Math.pow(t,5);o=Math.max(o,1e-4),this.__dolly=o}get dolly(){return Math.pow(this.__dolly,1/5)}__mouseDblClick(t){t.shiftKey?this.__mouseTranslateVec.zero():t.ctrlKey&&(this.__rot_y=0,this.__rot_x=0,this.__rot_bgn_y=0,this.__rot_bgn_x=0)}__resetDollyAndPosition(t){if(t.touches.length>1)return;let o=new Date().getTime();o-this.__resetDollyTouchTime<300?(this.dolly=Math.pow(.5,1/2.2),this.__mouseTranslateVec.zero(),this.__rot_x=0,this.__rot_y=0):this.__resetDollyTouchTime=o}__pressShift(t){t.shiftKey===!0&&(this.__isPressingShift=!0)}__releaseShift(t){t.shiftKey===!1&&(this.__isPressingShift=!1)}__pressCtrl(t){t.ctrlKey===!0&&(this.__isPressingCtrl=!0)}__releaseCtrl(t){t.ctrlKey===!1&&(this.__isPressingCtrl=!1)}registerEventListeners(){let t=window;A.exist(F.eventTargetDom)&&(t=F.eventTargetDom),"ontouchend"in document?Ft.register(bo,[{eventName:"touchstart",handler:this.__touchDownFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"touchmove",handler:this.__touchMoveFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"touchend",handler:this.__touchUpFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"touchmove",handler:this.__pinchInOutFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"touchend",handler:this.__pinchInOutEndFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"touchstart",handler:this.__resetDollyAndPositionFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"contextmenu",handler:this.__contextMenuFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"dblclick",handler:this.__mouseDblClickFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t}]):Ft.register(bo,[{eventName:"mousedown",handler:this.__mouseDownFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"mouseup",handler:this.__mouseUpFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"mouseleave",handler:this.__mouseUpFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"mousemove",handler:this.__mouseMoveFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"keydown",handler:this.__pressShiftFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"keyup",handler:this.__releaseShiftFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"keydown",handler:this.__pressCtrlFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"keyup",handler:this.__releaseCtrlFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"contextmenu",handler:this.__contextMenuFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"wheel",handler:this.__mouseWheelFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"dblclick",handler:this.__mouseDblClickFunc,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t}])}unregisterEventListeners(){Ft.unregister(bo)}__getFovyFromCamera(t){return t.fovy?t.fovy:Y.radianToDegree(2*Math.atan(Math.abs(t.top-t.bottom)/(2*t.zNear)))}logic(t){(!this.__updated||this.autoUpdate)&&(this.__updateTargeting(t),this.__calculateInfluenceOfController(),this.__updateCameraComponent(t),this.__updated=!0)}__getTargetAABB(t){return this.aabbWithSkeletal?t.tryToGetSceneGraph().worldMergedAABBWithSkeletal:t.tryToGetSceneGraph().worldMergedAABB}__updateTargeting(t){let o=t.eye,r=t._direction,i=t._up,a=this.__eyeVec,s=this.__centerVec,l=this.__upVec.copyComponents(i);if(this.__targetEntities.length===0)a.copyComponents(o),s.copyComponents(r);else{if(this.__initialTargetAABB==null){let v=new jt;for(let y of this.__targetEntities)v.mergeAABB(this.__getTargetAABB(y));this.__initialTargetAABB=v.clone()}let c=this.__initialTargetAABB;if(this.followTargetAABB){let v=new jt;for(let y of this.__targetEntities)v.mergeAABB(this.__getTargetAABB(y));c=v}s.copyComponents(c.centerPoint);let _=L.subtractTo(o,r,a).normalize(),p=(this.useInitialTargetAABBForLength?this.__initialTargetAABB.lengthCenterToCorner:c.lengthCenterToCorner)*(1+1/Math.tan(Y.degreeToRadian(t.fovy/2)))*this.scaleOfLengthCenterToCamera;Math.abs(p)<1e-5&&(p=1),_.multiply(p).add(s);let x=t.entity.tryToGetSceneGraph();if(x!=null){let v=Se.invertTo(x.matrixInner,xt.__tmpMat44_0);v.multiplyVector3To(s,s),v.multiplyVector3To(a,a),v.multiplyVector3To(l,l)}}}__calculateInfluenceOfController(){let t=L.subtractTo(this.__eyeVec,this.__centerVec,xt.__tmpVec3_0);t.multiply(this.__dolly*this.dollyScale),this.__lengthOfCenterToEye=t.length();let o=this.__newUpVec,r=this.__newEyeVec,i=this.__newCenterVec,a=this.__newTangentVec;if(this.__isSymmetryMode){let s=xt.__tmpVec3_1;s.setComponents(t.x,0,t.z);let l=S.angleOfVectors(s,xt.__tmp_up),c=Math.sign(s.cross(xt.__tmp_up).y);l*=c;let u=xt.__tmp_rotateM_X,_=xt.__tmp_rotateM_Y,d=xt.__tmp_rotateM_Reset,p=xt.__tmp_rotateM_Revert;u.rotateX(Y.degreeToRadian(this.__rot_y)),_.rotateY(Y.degreeToRadian(this.__rot_x)),d.rotateY(Y.degreeToRadian(l)),p.rotateY(Y.degreeToRadian(-l));let x=xt.__tmp_rotateM;We.multiplyTo(u,d,x),x.multiplyByLeft(_),x.multiplyByLeft(p),x.multiplyVectorTo(this.__upVec,o),x.multiplyVectorTo(t,r).add(this.__centerVec),i.copyComponents(this.__centerVec);let v=xt.__tmpVec3_2;L.subtractTo(i,r,v),L.crossTo(o,v,a),r.add(this.__mouseTranslateVec),i.add(this.__mouseTranslateVec)}else{let s=xt.__tmp_rotateM_X,l=xt.__tmp_rotateM_Y;s.rotateX(Y.degreeToRadian(this.__rot_y)),l.rotateY(Y.degreeToRadian(this.__rot_x));let c=We.multiplyTo(l,s,xt.__tmp_rotateM);c.multiplyVectorTo(this.__upVec,o),c.multiplyVectorTo(t,r).add(this.__centerVec),i.copyComponents(this.__centerVec);let u=xt.__tmpVec3_1;L.subtractTo(i,r,u),L.crossTo(o,u,a),r.add(this.__mouseTranslateVec),i.add(this.__mouseTranslateVec)}}__updateCameraComponent(t){let o=xt.__tmpVec3_0.copyComponents(this.__newCenterVec);o.subtract(this.__newEyeVec).normalize(),this._calcZNearInner(t,this.__newEyeVec,o),this._calcZFarInner(t);let r=t.zFar/t.zNear,i=this.__scaleOfZNearAndZFar,a=r/i,s=t.left+a,l=t.right+a,c=t.top+a,u=t.bottom+a,_=this.__getFovyFromCamera(t);this.__fovyBias=Math.tan(Y.degreeToRadian(_/2)),t.eyeInner=this.__newEyeVec,t.directionInner=this.__newCenterVec,t.upInner=this.__newUpVec,t.leftInner=s,t.rightInner=l,t.topInner=c,t.bottomInner=u,t.fovyInner=_}set scaleOfZNearAndZFar(t){this.__scaleOfZNearAndZFar=t,this.__updated=!1,this._updateCount()}get scaleOfZNearAndZFar(){return this.__scaleOfZNearAndZFar}get isMouseDown(){return this.__isMouseDown}get lastMouseDownTimeStamp(){return this.__lastMouseDownTimeStamp}get lastMouseUpTimeStamp(){return this.__lastMouseUpTimeStamp}};h(xt,"OrbitCameraController"),f(xt,"__tmp_up",S.fromCopyArray([0,0,1])),f(xt,"__tmpVec3_0",L.zero()),f(xt,"__tmpVec3_1",L.zero()),f(xt,"__tmpVec3_2",L.zero()),f(xt,"__tmp_rotateM_X",We.identity()),f(xt,"__tmp_rotateM_Y",We.identity()),f(xt,"__tmp_rotateM",We.identity()),f(xt,"__tmp_rotateM_Reset",We.identity()),f(xt,"__tmp_rotateM_Revert",We.identity()),f(xt,"__tmpMat44_0",$.identity());ea=xt});var Y_,Gl,K_=C(()=>{"use strict";Y_=class Y_{constructor(){f(this,"_v",new Float32Array)}get className(){return this.constructor.name}get x(){return this._v[0]}get y(){return this._v[1]}get z(){return this._v[2]}get w(){return this._v[3]}at(n){return this._v[n]}length(){return Math.hypot(this._v[0],this._v[1],this._v[2],this._v[3])}lengthSquared(){return this._v[0]**2+this._v[1]**2+this._v[2]**2+this._v[3]**2}toString(){throw new Error("Method not implemented.")}toStringApproximately(){throw new Error("Method not implemented.")}flattenAsArray(){throw new Error("Method not implemented.")}isDummy(){throw new Error("Method not implemented.")}isEqual(n,t){throw new Error("Method not implemented.")}isStrictEqual(n){throw new Error("Method not implemented.")}toEulerAnglesTo(n){throw new Error("Method not implemented.")}toEulerAngles(){throw new Error("Method not implemented.")}transformVector3(n){throw new Error("Method not implemented.")}transformVector3To(n,t){throw new Error("Method not implemented.")}transformVector3Inverse(n){throw new Error("Method not implemented.")}dot(n){return this._v[0]*n._v[0]+this._v[1]*n._v[1]+this._v[2]*n._v[2]+this._v[3]*n._v[3]}clone(){throw new Error("Method not implemented.")}};h(Y_,"AbstractQuaternion");Gl=Y_});var he,H,Bo=C(()=>{"use strict";nn();se();K_();ye();Ot();Yt();me();he=class he extends Gl{constructor(n){super(),this._v=n}get className(){return"Quaternion"}static get compositionType(){return b.Vec4}static identity(){return he.fromCopy4(0,0,0,1)}static dummy(){return new this(new Float32Array(0))}static invert(n){let t=n.length();if(t===0)return he.fromCopy4(0,0,0,0);let o=-n._v[0]/t,r=-n._v[1]/t,i=-n._v[2]/t,a=n._v[3]/t;return he.fromCopy4(o,r,i,a)}static invertTo(n,t){let o=n.length();return o===0?t.setComponents(0,0,0,0):(t._v[0]=-n._v[0]/o,t._v[1]=-n._v[1]/o,t._v[2]=-n._v[2]/o,t._v[3]=n._v[3]/o,t)}static qlerp(n,t,o){let r=n._v[0]*t._v[0]+n._v[1]*t._v[1]+n._v[2]*t._v[2]+n._v[3]*t._v[3];if(1-r*r===0)return n.clone();{r>1?r=.999:r<-1&&(r=-.999);let a=Math.acos(r),s=Math.sin(a),l;r<0?(r*=-1,a=Math.acos(r),l=-1*Math.sin(a*o)/s):l=Math.sin(a*o)/s;let c=Math.sin(a*(1-o))/s,u=n._v[0]*c+t._v[0]*l,_=n._v[1]*c+t._v[1]*l,d=n._v[2]*c+t._v[2]*l,p=n._v[3]*c+t._v[3]*l,x=Math.hypot(u,_,d,p);return u=u/x,_=_/x,d=d/x,p=p/x,he.fromCopy4(u,_,d,p)}}static qlerpTo(n,t,o,r){let i=n._v[0]*t._v[0]+n._v[1]*t._v[1]+n._v[2]*t._v[2]+n._v[3]*t._v[3];if(1-i*i===0)return r.copyComponents(n);{i>1?i=.999:i<-1&&(i=-.999);let s=Math.acos(i),l=Math.sin(s),c;i<0?(i*=-1,s=Math.acos(i),c=-1*Math.sin(s*o)/l):c=Math.sin(s*o)/l;let u=Math.sin(s*(1-o))/l;r._v[0]=n._v[0]*u+t._v[0]*c,r._v[1]=n._v[1]*u+t._v[1]*c,r._v[2]=n._v[2]*u+t._v[2]*c,r._v[3]=n._v[3]*u+t._v[3]*c}return r.normalize()}static lerp(n,t,o){let r=n._v[0]*(1-o)+t._v[0]*o,i=n._v[1]*(1-o)+t._v[1]*o,a=n._v[2]*(1-o)+t._v[2]*o,s=n._v[3]*(1-o)+t._v[3]*o;return he.fromCopy4(r,i,a,s)}static lerpTo(n,t,o,r){return r._v[0]=n._v[0]*(1-o)+t._v[0]*o,r._v[1]=n._v[1]*(1-o)+t._v[1]*o,r._v[2]=n._v[2]*(1-o)+t._v[2]*o,r._v[3]=n._v[3]*(1-o)+t._v[3]*o,r}static axisAngle(n,t){let o=.5*t,r=Math.sin(o),i=n.length();return i===0&&N.error("0 division occurred!"),he.fromCopy4(r*n._v[0]/i,r*n._v[1]/i,r*n._v[2]/i,Math.cos(o))}static fromMatrix(n){let t=Math.hypot(n.m00,n.m10,n.m20),o=Math.hypot(n.m01,n.m11,n.m21),r=Math.hypot(n.m02,n.m12,n.m22);n.determinant()<0&&(t=-t);let a=$.fromCopyMatrix44(n),s=1/t,l=1/o,c=1/r;a.m00*=s,a.m10*=s,a.m20*=s,a.m01*=l,a.m11*=l,a.m21*=l,a.m02*=c,a.m12*=c,a.m22*=c;let u=a.m00+a.m11+a.m22;if(u>0){let _=.5/Math.sqrt(u+1),d=(a.m21-a.m12)*_,p=(a.m02-a.m20)*_,x=(a.m10-a.m01)*_,v=.25/_;return he.fromCopy4(d,p,x,v)}else if(a.m00>a.m11&&a.m00>a.m22){let _=Math.sqrt(1+a.m00-a.m11-a.m22)*2,d=.25*_,p=(a.m01+a.m10)/_,x=(a.m02+a.m20)/_,v=(a.m21-a.m12)/_;return he.fromCopy4(d,p,x,v)}else if(a.m11>a.m22){let _=Math.sqrt(1+a.m11-a.m00-a.m22)*2,d=(a.m01+a.m10)/_,p=.25*_,x=(a.m12+a.m21)/_,v=(a.m02-a.m20)/_;return he.fromCopy4(d,p,x,v)}else{let _=Math.sqrt(1+a.m22-a.m00-a.m11)*2,d=(a.m02+a.m20)/_,p=(a.m12+a.m21)/_,x=.25*_,v=(a.m10-a.m01)/_;return he.fromCopy4(d,p,x,v)}}static fromMatrixTo(n,t){let o=Math.hypot(n.m00,n.m10,n.m20),r=Math.hypot(n.m01,n.m11,n.m21),i=Math.hypot(n.m02,n.m12,n.m22);n.determinant()<0&&(o=-o);let s=$.fromCopyMatrix44(n),l=1/o,c=1/r,u=1/i;s.m00*=l,s.m10*=l,s.m20*=l,s.m01*=c,s.m11*=c,s.m21*=c,s.m02*=u,s.m12*=u,s.m22*=u;let _=s.m00+s.m11+s.m22;if(_>0){let d=.5/Math.sqrt(_+1);t._v[0]=(s.m21-s.m12)*d,t._v[1]=(s.m02-s.m20)*d,t._v[2]=(s.m10-s.m01)*d,t._v[3]=.25/d}else if(s.m00>s.m11&&s.m00>s.m22){let d=Math.sqrt(1+s.m00-s.m11-s.m22)*2;t._v[0]=.25*d,t._v[1]=(s.m01+s.m10)/d,t._v[2]=(s.m02+s.m20)/d,t._v[3]=(s.m21-s.m12)/d}else if(s.m11>s.m22){let d=Math.sqrt(1+s.m11-s.m00-s.m22)*2;t._v[0]=(s.m01+s.m10)/d,t._v[1]=.25*d,t._v[2]=(s.m12+s.m21)/d,t._v[3]=(s.m02-s.m20)/d}else{let d=Math.sqrt(1+s.m22-s.m00-s.m11)*2;t._v[0]=(s.m02+s.m20)/d,t._v[1]=(s.m12+s.m21)/d,t._v[2]=.25*d,t._v[3]=(s.m10-s.m01)/d}return t}static lookFromTo(n,t){return n.isEqual(t)?he.fromCopy4(0,0,0,1):this.qlerp(this.lookForward(n),this.lookForward(t),1)}static lookForward(n){return he.__tmp_upVec==null&&(he.__tmp_upVec=new n.constructor(0,1,0)),this.lookForwardAccordingToThisUp(n,he.__tmp_upVec)}static lookForwardAccordingToThisUp(n,t){let o=n.length();o===0&&N.error("0 division occurred!");let r=n._v[0]/o,i=n._v[1]/o,a=n._v[2]/o,s=t.length();s===0&&N.error("0 division occurred!");let l=t._v[0]/s,c=t._v[1]/s,u=t._v[2]/s,_=t._v[1]*n._v[2]-t._v[2]*n._v[1],d=t._v[2]*n._v[0]-t._v[0]*n._v[2],p=t._v[0]*n._v[1]-t._v[1]*n._v[0],x=Math.hypot(_,d,p);x===0&&N.error("0 division occurred!"),_/=x,d/=x,p/=x;let v=_,y=d,g=p,E=l,w=c,T=u,R=r,P=i,V=a,z=v+w+V;if(z>0){let k=Math.sqrt(z+1),W=.5/k;return he.fromCopy4((T-P)*W,(R-g)*W,(y-E)*W,k*.5)}else if(v>=w&&v>=V){let k=Math.sqrt(1+v-w-V),W=.5/k;return he.fromCopy4(.5*k,(y+E)*W,(g+R)*W,(T-P)*W)}else if(w>V){let k=Math.sqrt(1+w-v-V),W=.5/k;return he.fromCopy4((E+y)*W,.5*k,(P+T)*W,(R-g)*W)}else{let k=Math.sqrt(1+V-v-w),W=.5/k;return he.fromCopy4((R+g)*W,(P+T)*W,.5*k,(y-E)*W)}}static fromPosition(n){return he.fromCopy4(n._v[0],n._v[1],n._v[2],0)}static add(n,t){let o=n._v[0]+t._v[0],r=n._v[1]+t._v[1],i=n._v[2]+t._v[2],a=n._v[3]+t._v[3];return he.fromCopy4(o,r,i,a)}static addTo(n,t,o){return o._v[0]=n._v[0]+t._v[0],o._v[1]=n._v[1]+t._v[1],o._v[2]=n._v[2]+t._v[2],o._v[3]=n._v[3]+t._v[3],o}static subtract(n,t){let o=n._v[0]-t._v[0],r=n._v[1]-t._v[1],i=n._v[2]-t._v[2],a=n._v[3]-t._v[3];return he.fromCopy4(o,r,i,a)}static subtractTo(n,t,o){return o._v[0]=n._v[0]-t._v[0],o._v[1]=n._v[1]-t._v[1],o._v[2]=n._v[2]-t._v[2],o._v[3]=n._v[3]-t._v[3],o}static multiply(n,t){let o=t._v[3]*n._v[0]+t._v[2]*n._v[1]-t._v[1]*n._v[2]+t._v[0]*n._v[3],r=-t._v[2]*n._v[0]+t._v[3]*n._v[1]+t._v[0]*n._v[2]+t._v[1]*n._v[3],i=t._v[1]*n._v[0]-t._v[0]*n._v[1]+t._v[3]*n._v[2]+t._v[2]*n._v[3],a=-t._v[0]*n._v[0]-t._v[1]*n._v[1]-t._v[2]*n._v[2]+t._v[3]*n._v[3];return he.fromCopy4(o,r,i,a)}static multiplyTo(n,t,o){let r=t._v[3]*n._v[0]+t._v[2]*n._v[1]-t._v[1]*n._v[2]+t._v[0]*n._v[3],i=-t._v[2]*n._v[0]+t._v[3]*n._v[1]+t._v[0]*n._v[2]+t._v[1]*n._v[3],a=t._v[1]*n._v[0]-t._v[0]*n._v[1]+t._v[3]*n._v[2]+t._v[2]*n._v[3],s=-t._v[0]*n._v[0]-t._v[1]*n._v[1]-t._v[2]*n._v[2]+t._v[3]*n._v[3];return o.setComponents(r,i,a,s)}static multiplyNumber(n,t){let o=n._v[0]*t,r=n._v[1]*t,i=n._v[2]*t,a=n._v[3]*t;return he.fromCopy4(o,r,i,a)}static multiplyNumberTo(n,t,o){return o._v[0]=n._v[0]*t,o._v[1]=n._v[1]*t,o._v[2]=n._v[2]*t,o._v[3]=n._v[3]*t,o}static divideNumber(n,t){t===0&&N.error("0 division occurred!");let o=n._v[0]/t,r=n._v[1]/t,i=n._v[2]/t,a=n._v[3]/t;return he.fromCopy4(o,r,i,a)}static divideNumberTo(n,t,o){return t===0&&N.error("0 division occurred!"),o._v[0]=n._v[0]/t,o._v[1]=n._v[1]/t,o._v[2]=n._v[2]/t,o._v[3]=n._v[3]/t,o}toString(){return"("+this._v[0]+", "+this._v[1]+", "+this._v[2]+", "+this._v[3]+")"}toStringApproximately(){return Y.financial(this._v[0])+" "+Y.financial(this._v[1])+" "+Y.financial(this._v[2])+" "+Y.financial(this._v[3])+`
`}flattenAsArray(){return[this._v[0],this._v[1],this._v[2],this._v[3]]}isDummy(){return this._v.length===0}isEqual(n,t=Number.EPSILON){return Math.abs(n._v[0]-this._v[0])<t&&Math.abs(n._v[1]-this._v[1])<t&&Math.abs(n._v[2]-this._v[2])<t&&Math.abs(n._v[3]-this._v[3])<t}isStrictEqual(n){return this._v[0]===n._v[0]&&this._v[1]===n._v[1]&&this._v[2]===n._v[2]&&this._v[3]===n._v[3]}toEulerAnglesTo(n){let t=2*(this._v[3]*this._v[0]+this._v[1]*this._v[2]),o=1-2*(this._v[0]*this._v[0]+this._v[1]*this._v[1]);n._v[0]=Math.atan2(t,o);let r=2*(this._v[3]*this._v[1]-this._v[2]*this._v[0]);r=r>1?1:r,r=r<-1?-1:r,n._v[1]=Math.asin(r);let i=2*(this._v[3]*this._v[2]+this._v[0]*this._v[1]),a=1-2*(this._v[1]*this._v[1]+this._v[2]*this._v[2]);return n._v[2]=Math.atan2(i,a),n}toEulerAngles(){let n=new S(new Float32Array(3)),t=2*(this._v[3]*this._v[0]+this._v[1]*this._v[2]),o=1-2*(this._v[0]*this._v[0]+this._v[1]*this._v[1]);n._v[0]=Math.atan2(t,o);let r=2*(this._v[3]*this._v[1]-this._v[2]*this._v[0]);r=r>1?1:r,r=r<-1?-1:r,n._v[1]=Math.asin(r);let i=2*(this._v[3]*this._v[2]+this._v[0]*this._v[1]),a=1-2*(this._v[1]*this._v[1]+this._v[2]*this._v[2]);return n._v[2]=Math.atan2(i,a),n}static _divide(n,t){let o,r,i,a;return t!==0?(o=n._v[0]/t,r=n._v[1]/t,i=n._v[2]/t,a=n._v[3]/t):(N.error("0 division occurred!"),o=1/0,r=1/0,i=1/0,a=1/0),he.fromCopy4(o,r,i,a)}static _divideTo(n,t,o){let r,i,a,s;return t!==0?(r=n._v[0]/t,i=n._v[1]/t,a=n._v[2]/t,s=n._v[3]/t):(N.error("0 division occurred!"),r=1/0,i=1/0,a=1/0,s=1/0),o._v[0]=r,o._v[1]=i,o._v[2]=a,o._v[3]=s,o}static normalize(n){let t=n.length();return this._divide(n,t)}static normalizeTo(n,t){let o=n.length();return this._divideTo(n,o,t)}fromToRotation(n,t){let o=L.fromCopyVector3(n),r=L.fromCopyVector3(t);o.normalize(),r.normalize();let i=o.dot(r);if(i>-1+Number.EPSILON){let a=Math.sqrt((1+i)*2),s=1/a,l=S.multiply(o.cross(r),s);return this._v[0]=l.x,this._v[1]=l.y,this._v[2]=l.z,this._v[3]=a*.5,he.normalize(this)}else{let a=S.fromCopy3(0,1,0),s=o.cross(a);return s.length()<Number.EPSILON&&(a=S.fromCopy3(1,0,0),s=o.cross(a)),s.normalize(),he.fromAxisAngle(s,Math.PI)}}static fromToRotation(n,t){let o=S.dot(n,t)+1;if(o<Number.EPSILON)if(o=0,Math.abs(n.x)>Math.abs(n.z)){let r=he.fromCopy4(-n.y,n.x,0,o);return he.normalize(r)}else{let r=he.fromCopy4(0,-n.z,n.y,o);return he.normalize(r)}else{let r=he.fromCopy4(n.y*t.z-n.z*t.y,n.z*t.x-n.x*t.z,n.x*t.y-n.y*t.x,o);return he.normalize(r)}}static fromToRotationTo(n,t,o){let r=S.dot(n,t)+1;return r<Number.EPSILON?(r=0,Math.abs(n.x)>Math.abs(n.z)?(o._v[0]=-n.y,o._v[1]=n.x,o._v[2]=0,o._v[3]=r,o.normalize(),o):(o._v[0]=0,o._v[1]=-n.z,o._v[2]=n.y,o._v[3]=r,o.normalize(),o)):(o._v[0]=n.y*t.z-n.z*t.y,o._v[1]=n.z*t.x-n.x*t.z,o._v[2]=n.x*t.y-n.y*t.x,o._v[3]=r,o.normalize(),o)}transformVector3(n){let t=he.__tmp_vec3_5;t.setComponents(this._v[0],this._v[1],this._v[2]);let o=S.cross(t,n),r=S.cross(t,o),i=S.multiply(o,this._v[3]),a=S.add(r,i),s=S.multiply(a,2);return S.add(n,s)}transformVector3To(n,t){let o=he.__tmp_vec3_5;o.setComponents(this._v[0],this._v[1],this._v[2]);let r=S.crossTo(o,n,he.__tmp_vec3_0),i=S.crossTo(o,r,he.__tmp_vec3_1),a=S.multiplyTo(r,this._v[3],he.__tmp_vec3_2),s=S.addTo(i,a,he.__tmp_vec3_3),l=S.multiplyTo(s,2,he.__tmp_vec3_4);return S.addTo(n,l,t)}transformVector3Inverse(n){return he.invert(this).transformVector3(n)}clone(){return he.fromCopy4(this._v[0],this._v[1],this._v[2],this._v[3])}static fromFloat32Array(n){return new he(n)}static fromCopyArray4(n){return new he(new Float32Array(n))}static fromCopyArray(n){return new he(new Float32Array(n.slice(0,4)))}static fromCopy4(n,t,o,r){return new he(new Float32Array([n,t,o,r]))}static fromCopyQuaternion(n){let t=new Float32Array(4);return t[0]=n._v[0],t[1]=n._v[1],t[2]=n._v[2],t[3]=n._v[3],new he(t)}static fromCopyVector4(n){let t=new Float32Array(4);return t[0]=n._v[0],t[1]=n._v[1],t[2]=n._v[2],t[3]=n._v[3],new he(t)}static fromCopyLogQuaternion(n){let t=n._v[0]*n._v[0]+n._v[1]*n._v[1]+n._v[2]*n._v[2],o=Math.sin(t),r=new Float32Array(4);return r[0]=n._v[0]*(o/t),r[1]=n._v[1]*(o/t),r[2]=n._v[2]*(o/t),r[3]=Math.cos(t),new he(r)}static fromAxisAngle(n,t){t=t*.5;let o=Math.sin(t);return he.fromCopy4(o*n.x,o*n.y,o*n.z,Math.cos(t))}static fromAxisAngleTo(n,t,o){t=t*.5;let r=Math.sin(t);return o._v[0]=r*n.x,o._v[1]=r*n.y,o._v[2]=r*n.z,o._v[3]=Math.cos(t),o}static getQuaternionAngle(n){let t=Math.max(-1,Math.min(1,n.w));return 2*Math.acos(t)}static clampRotation(n,t){let o=he.getQuaternionAngle(n);if(o<=t)return n;{let r=t/o,i=he.fromCopy4(0,0,0,1);return he.qlerp(i,n,r)}}};h(he,"Quaternion"),f(he,"__tmp_upVec"),f(he,"__tmp_vec3_0",L.zero()),f(he,"__tmp_vec3_1",L.zero()),f(he,"__tmp_vec3_2",L.zero()),f(he,"__tmp_vec3_3",L.zero()),f(he,"__tmp_vec3_4",L.zero()),f(he,"__tmp_vec3_5",L.zero());H=he});var J_,Ol,rs,pe,is,Z_,fo=C(()=>{"use strict";It();me();J_=class J_ extends Yi{constructor(t,{type:o}){super(t,{type:o});f(this,"__updateCount",0)}set x(t){this._v[0]=t,this.__updateCount++}get x(){return this._v[0]}set y(t){this._v[1]=t,this.__updateCount++}get y(){return this._v[1]}set z(t){this._v[2]=t,this.__updateCount++}get z(){return this._v[2]}set w(t){this._v[3]=t,this.__updateCount++}get w(){return this._v[3]}raw(){return this._v}setAt(t,o){return this._v[t]=o,this.__updateCount++,this}setComponents(t,o,r,i){return this._v[0]=t,this._v[1]=o,this._v[2]=r,this._v[3]=i,this.__updateCount++,this}copyComponents(t){return this.setComponents(t._v[0],t._v[1],t._v[2],t._v[3])}zero(){return this.setComponents(0,0,0,0)}one(){return this.setComponents(1,1,1,1)}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}normalize(){let t=this.length();return this.divide(t),this}normalize3(){let t=Math.hypot(this._v[0],this._v[1],this._v[2]);return this.divide(t),this}add(t){return this._v[0]+=t._v[0],this._v[1]+=t._v[1],this._v[2]+=t._v[2],this._v[3]+=t._v[3],this}subtract(t){return this._v[0]-=t._v[0],this._v[1]-=t._v[1],this._v[2]-=t._v[2],this._v[3]-=t._v[3],this}multiply(t){return this._v[0]*=t,this._v[1]*=t,this._v[2]*=t,this._v[3]*=t,this}multiplyVector(t){return this._v[0]*=t._v[0],this._v[1]*=t._v[1],this._v[2]*=t._v[2],this._v[3]*=t._v[3],this}divide(t){return t!==0?(this._v[0]/=t,this._v[1]/=t,this._v[2]/=t,this._v[3]/=t):(N.error("0 division occurred!"),this._v[0]=1/0,this._v[1]=1/0,this._v[2]=1/0,this._v[3]=1/0),this}divideVector(t){return t._v[0]!==0&&t._v[1]!==0&&t._v[2]!==0&&t._v[3]!==0?(this._v[0]/=t._v[0],this._v[1]/=t._v[1],this._v[2]/=t._v[2],this._v[3]/=t._v[3]):(N.error("0 division occurred!"),this._v[0]=t._v[0]===0?1/0:this._v[0]/t._v[0],this._v[1]=t._v[1]===0?1/0:this._v[1]/t._v[1],this._v[2]=t._v[2]===0?1/0:this._v[2]/t._v[2],this._v[3]=t._v[3]===0?1/0:this._v[3]/t._v[3]),this}get _updateCount(){return this.__updateCount}};h(J_,"MutableVector4_");Ol=J_,rs=class rs extends Ol{constructor(n){super(n,{type:Float32Array})}static fromCopyArray(n){return new rs(new Float32Array(n).slice(0,4))}static fromCopyArray4(n){return new rs(new Float32Array(n))}static fromCopy4(n,t,o,r){return new rs(new Float32Array([n,t,o,r]))}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(n){return super._normalize(n,Float32Array)}static add(n,t){return super._add(n,t,Float32Array)}static subtract(n,t){return super._subtract(n,t,Float32Array)}static multiply(n,t){return super._multiply(n,t,Float32Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float32Array)}static divide(n,t){return super._divide(n,t,Float32Array)}static divideVector(n,t){return super._divideVector(n,t,Float32Array)}get className(){return"MutableVector4"}clone(){return new this.constructor(new this._v.constructor([this._v[0],this._v[1],this._v[2],this._v[3]]))}};h(rs,"MutableVector4");pe=rs,is=class is extends Ol{constructor(n){super(n,{type:Float64Array})}static zero(){return super._zero(Float64Array)}static one(){return super._one(Float64Array)}static dummy(){return super._dummy(Float64Array)}static normalize(n){return super._normalize(n,Float64Array)}static add(n,t){return super._add(n,t,Float64Array)}static subtract(n,t){return super._subtract(n,t,Float64Array)}static multiply(n,t){return super._multiply(n,t,Float64Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float64Array)}static divide(n,t){return super._divide(n,t,Float64Array)}static divideVector(n,t){return super._divideVector(n,t,Float64Array)}static fromCopyArray4(n){return new is(new Float64Array(n))}static fromCopyArray(n){return new is(new Float64Array(n.slice(0,4)))}static fromCopy4(n,t,o,r){return new is(new Float64Array([n,t,o,r]))}clone(){return super.clone()}};h(is,"MutableVector4d");Z_=is});var ed,ta,as,te,ss,$_,Tn=C(()=>{"use strict";nn();qa();se();ed=class ed extends pr{constructor(n,{type:t}){super(),this._v=n}getValue(){return this._v[0]}getValueInArray(){return[this._v[0]]}get x(){return this._v[0]}get raw(){return this._v}isStrictEqual(n){return this.x===n.x}isEqual(n,t=Number.EPSILON){return Math.abs(n.x-this.x)<t}get glslStrAsFloat(){return`${Y.convertToStringAsGLSLFloat(this.x)}`}get glslStrAsInt(){return`${Math.floor(this.x)}`}static _fromCopyNumber(n,t){return new this(new t([n]),{type:t})}static _dummy(n){return new this(new n,{type:n})}static get compositionType(){return b.Scalar}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}};h(ed,"Scalar_");ta=ed,as=class as extends ta{constructor(n){super(n,{type:Float32Array})}static fromCopyNumber(n){return super._fromCopyNumber(n,Float32Array)}static zero(){return as.fromCopyNumber(0)}static one(){return as.fromCopyNumber(1)}static dummy(){return super._dummy(Float32Array)}get className(){return"Scalar"}toString(){return"("+this._v[0]+")"}clone(){return new as(this._v)}};h(as,"Scalar");te=as,ss=class ss extends ta{constructor(n){super(n,{type:Float64Array})}static fromCopyNumber(n){return super._fromCopyNumber(n,Float64Array)}static zero(){return ss.fromCopyNumber(0)}static one(){return ss.fromCopyNumber(1)}static dummy(){return super._dummy(Float64Array)}clone(){return new ss(this._v)}};h(ss,"Scalard");$_=ss});var lr,Ye,br=C(()=>{"use strict";Bo();Yt();me();lr=class lr extends H{constructor(n){super(n)}set x(n){this._v[0]=n}get x(){return this._v[0]}set y(n){this._v[1]=n}get y(){return this._v[1]}set z(n){this._v[2]=n}get z(){return this._v[2]}set w(n){this._v[3]=n}get w(){return this._v[3]}get className(){return"MutableQuaternion"}static identity(){return lr.fromCopy4(0,0,0,1)}static dummy(){return new this(new Float32Array(0))}static invert(n){return super.invert(n)}static qlerp(n,t,o){return super.qlerp(n,t,o)}static lerp(n,t,o){return super.lerp(n,t,o)}static axisAngle(n,t){return super.axisAngle(n,t)}static fromMatrix(n){return super.fromMatrix(n)}static fromPosition(n){return super.fromPosition(n)}static add(n,t){return super.add(n,t)}static subtract(n,t){return super.subtract(n,t)}static multiply(n,t){return super.multiply(n,t)}static multiplyNumber(n,t){return super.multiplyNumber(n,t)}static divideNumber(n,t){return super.divideNumber(n,t)}raw(){return this._v}setAt(n,t){return this._v[n]=t,this}setComponents(n,t,o,r){return this._v[0]=n,this._v[1]=t,this._v[2]=o,this._v[3]=r,this}copyComponents(n){return this.setComponents(n._v[0],n._v[1],n._v[2],n._v[3])}identity(){return this.setComponents(0,0,0,1)}normalize(){let n=this.length();return this.divideNumber(n)}invert(){let n=this.length();return n===0?this:(this._v[0]=-this._v[0]/n,this._v[1]=-this._v[1]/n,this._v[2]=-this._v[2]/n,this._v[3]=this._v[3]/n,this)}qlerp(n,t,o){let r=n._v[3]*t._v[3]+n._v[0]*t._v[0]+n._v[1]*t._v[1]+n._v[2]*t._v[2];if(1-r*r===0)return this.copyComponents(n);{r>1?r=.999:r<-1&&(r=-.999);let a=Math.acos(r),s;r<0&&a>Math.PI/2?(r=-n._v[3]*t._v[3]-n._v[0]*t._v[0]-n._v[1]*t._v[1]-n._v[2]*t._v[2],a=Math.acos(r),s=-1*Math.sin(a*o)/Math.sin(a)):s=Math.sin(a*o)/Math.sin(a);let l=Math.sin(a*(1-o))/Math.sin(a);this._v[0]=n._v[0]*l+t._v[0]*s,this._v[1]=n._v[1]*l+t._v[1]*s,this._v[2]=n._v[2]*l+t._v[2]*s,this._v[3]=n._v[3]*l+t._v[3]*s}return this}lerp(n,t,o){return this._v[0]=n._v[0]*(1-o)+t._v[0]*o,this._v[1]=n._v[1]*(1-o)+t._v[1]*o,this._v[2]=n._v[2]*(1-o)+t._v[2]*o,this._v[3]=n._v[3]*(1-o)+t._v[3]*o,this}axisAngle(n,t){let o=.5*t,r=Math.sin(o),i=n.length();return i===0&&N.error("0 division occurred!"),this._v[3]=Math.cos(o),this._v[0]=r*n._v[0]/i,this._v[1]=r*n._v[1]/i,this._v[2]=r*n._v[2]/i,this}fromMatrix(n){let t=Math.hypot(n.m00,n.m10,n.m20),o=Math.hypot(n.m01,n.m11,n.m21),r=Math.hypot(n.m02,n.m12,n.m22);n.determinant()<0&&(t=-t);let a=$.fromCopyMatrix44(n),s=1/t,l=1/o,c=1/r;a.m00*=s,a.m10*=s,a.m20*=s,a.m01*=l,a.m11*=l,a.m21*=l,a.m02*=c,a.m12*=c,a.m22*=c;let u=a.m00+a.m11+a.m22;if(u>0){let _=.5/Math.sqrt(u+1);this._v[0]=(a.m21-a.m12)*_,this._v[1]=(a.m02-a.m20)*_,this._v[2]=(a.m10-a.m01)*_,this._v[3]=.25/_}else if(a.m00>a.m11&&a.m00>a.m22){let _=Math.sqrt(1+a.m00-a.m11-a.m22)*2;this._v[0]=.25*_,this._v[1]=(a.m01+a.m10)/_,this._v[2]=(a.m02+a.m20)/_,this._v[3]=(a.m21-a.m12)/_}else if(a.m11>a.m22){let _=Math.sqrt(1+a.m11-a.m00-a.m22)*2;this._v[0]=(a.m01+a.m10)/_,this._v[1]=.25*_,this._v[2]=(a.m12+a.m21)/_,this._v[3]=(a.m02-a.m20)/_}else{let _=Math.sqrt(1+a.m22-a.m00-a.m11)*2;this._v[0]=(a.m02+a.m20)/_,this._v[1]=(a.m12+a.m21)/_,this._v[2]=.25*_,this._v[3]=(a.m10-a.m01)/_}return this}fromPosition(n){return this.setComponents(n._v[0],n._v[1],n._v[2],0)}add(n){return this._v[0]+=n._v[0],this._v[1]+=n._v[1],this._v[2]+=n._v[2],this._v[3]+=n._v[3],this}subtract(n){return this._v[0]-=n._v[0],this._v[1]-=n._v[1],this._v[2]-=n._v[2],this._v[3]-=n._v[3],this}multiply(n){let t=n._v[3]*this._v[0]+n._v[2]*this._v[1]+n._v[1]*this._v[2]-n._v[0]*this._v[3],o=-n._v[2]*this._v[0]+n._v[3]*this._v[1]+n._v[0]*this._v[2]-n._v[1]*this._v[3],r=n._v[1]*this._v[0]+n._v[0]*this._v[1]+n._v[3]*this._v[2]-n._v[2]*this._v[3],i=-n._v[0]*this._v[0]-n._v[1]*this._v[1]-n._v[2]*this._v[2]-n._v[3]*this._v[3];return this.setComponents(t,o,r,i)}multiplyNumber(n){return this._v[0]*=n,this._v[1]*=n,this._v[2]*=n,this._v[3]*=n,this}divideNumber(n){return n!==0?(this._v[0]/=n,this._v[1]/=n,this._v[2]/=n,this._v[3]/=n):(N.error("0 division occurred!"),this._v[0]=1/0,this._v[1]=1/0,this._v[2]=1/0,this._v[3]=1/0),this}clone(){return lr.fromCopy4(this._v[0],this._v[1],this._v[2],this._v[3])}static fromFloat32Array(n){return new lr(n)}static fromCopyArray4(n){return new lr(new Float32Array(n))}static fromCopyArray(n){return new lr(new Float32Array(n.slice(0,4)))}static fromCopy4(n,t,o,r){return new lr(new Float32Array([n,t,o,r]))}static fromCopyQuaternion(n){let t=new Float32Array(4);return t[0]=n._v[0],t[1]=n._v[1],t[2]=n._v[2],t[3]=n._v[3],new lr(t)}static fromCopyVector4(n){let t=new Float32Array(4);return t[0]=n._v[0],t[1]=n._v[1],t[2]=n._v[2],t[3]=n._v[3],new lr(t)}static fromCopyLogQuaternion(n){let t=n._v[0]*n._v[0]+n._v[1]*n._v[1]+n._v[2]*n._v[2],o=Math.sin(t),r=new Float32Array(4);return r[0]=n._v[0]*(o/t),r[1]=n._v[1]*(o/t),r[2]=n._v[2]*(o/t),r[3]=Math.cos(t),new lr(r)}};h(lr,"MutableQuaternion");Ye=lr});var nd,Ul,na,ut,oa,td,gi=C(()=>{"use strict";Tn();se();nd=class nd extends ta{constructor(n,{type:t}){super(n,{type:t})}copyComponents(n){this._v[0]=n._v[0]}get x(){return this._v[0]}set x(n){this._v[0]=n}get y(){return 0}get z(){return 0}get w(){return 1}toString(){return"("+this._v[0]+")"}setValue(n){return this.x=n,this}static get compositionType(){return b.Scalar}get bytesPerComponent(){return this._v.BYTES_PER_ELEMENT}};h(nd,"MutableScalar_");Ul=nd,na=class na extends Ul{constructor(n){super(n,{type:Float32Array})}clone(){return new na(new Float32Array([this.x]))}static one(){return new na(new Float32Array([1]))}static dummy(){return new na(new Float32Array([]))}static zero(){return new na(new Float32Array([0]))}get className(){return"MutableScalar"}};h(na,"MutableScalar");ut=na,oa=class oa extends Ul{constructor(n){super(n,{type:Float64Array})}clone(){return new oa(new Float64Array([this.x]))}static one(){return new oa(new Float64Array([1]))}static dummy(){return new oa(new Float64Array([]))}static zero(){return new oa(new Float64Array([0]))}};h(oa,"MutableScalard");td=oa});var od,ve,Ao=C(()=>{"use strict";od=class od{constructor(n){f(this,"_v");this._v=n}};h(od,"VectorN");ve=od});var kl,En,ra=C(()=>{"use strict";Xo();ye();It();Bo();ji();yo();se();Yt();or();fo();Ot();sr();Tn();br();gi();Ao();me();kl=class kl{constructor(){}static arrayToVector(n){return Array.isArray(n)?typeof n[3]!="undefined"?q.fromCopyArray([n[0],n[1],n[2],n[3]]):typeof n[2]!="undefined"?S.fromCopyArray([n[0],n[1],n[2]]):Ee.fromCopyArray2([n[0],n[1]]):n}static arrayToVectorOrMatrix(n){return Array.isArray(n)?typeof n[15]!="undefined"?Se.fromCopyArrayRowMajor(n):typeof n[8]!="undefined"?Ut.fromCopyArrayRowMajor(n):typeof n[3]!="undefined"?q.fromCopyArray([n[0],n[1],n[2],n[3]]):typeof n[2]!="undefined"?S.fromCopyArray([n[0],n[1],n[2]]):Ee.fromCopyArray2([n[0],n[1]]):n}static getImmutableValueClass(n){if(n===b.Vec2)return Ee;if(n===b.Vec3)return S;if(n===b.Vec4)return q;if(n===b.Mat3)return Ut;if(n===b.Mat4)return Se}static getMutableValueClass(n){return n===b.Vec2?pt:n===b.Vec3?L:n===b.Vec4?pe:n===b.Mat3?We:n===b.Mat4?$:void 0}static cloneOfMathObjects(n){return n instanceof Se||n instanceof Ut||n instanceof q||n instanceof S||n instanceof Ee?n.clone():n}static isAcceptableArrayForQuaternion(n){return!!(Array.isArray(n)&&typeof n[3]!="undefined")}static arrayToQuaternion(n){return H.fromCopy4(n[0],n[1],n[2],n[3])}static makeSubArray(n,t){return t===4?[n[0],n[1],n[2],n[3]]:t===3?[n[0],n[1],n[2]]:t===2?[n[0],n[1]]:n[0]}static vectorToArray(n){return n instanceof Ee?[n.x,n.y]:n instanceof S?[n.x,n.y,n.z]:n instanceof q||n instanceof H?[n.x,n.y,n.z,n.w]:n}static componentNumberOfVector(n){return n instanceof Ee?2:n instanceof S?3:n instanceof q||n instanceof H?4:Array.isArray(n)?n.length:0}static packNormalizedVec4ToVec2(n,t,o,r,i){let a=0,s=0;n=(n+1)/2,t=(t+1)/2,o=(o+1)/2,r=(r+1)/2;let l=Math.floor(n*(i-1)),c=Math.floor(t*(i-1));a=(l*i+c)/i;let _=Math.floor(o*(i-1)),d=Math.floor(r*(i-1));return s=(_*i+d)/i,[a,s]}static unProjectTo(n,t,o,r,i,a){let s=this.__tmpVector4_0.setComponents((n-i.x)/i.z*2-1,(t-i.y)/i.w*2-1,2*o-1,1),l=r.multiplyVectorTo(s,this.__tmpVector4_1);return l.w===0&&N.error("0 division occurred!"),L.multiplyTo(l,1/l.w,a)}static add(n,t){if(isFinite(n))return n+t;if(n instanceof Ee)return Ee.add(n,t);if(n instanceof S)return S.add(n,t);if(n instanceof q)return q.add(n,t);if(n instanceof H)return H.add(n,t);if(Array.isArray(n)){let o=[];for(let r=0;r<n.length;r++)o[r]=n[r]+t[r];return o}else{N.error("Non supported type!");return}}static subtract(n,t){if(isFinite(n))return n-t;if(n instanceof Ee)return Ee.subtract(n,t);if(n instanceof S)return S.subtract(n,t);if(n instanceof q)return q.subtract(n,t);if(n instanceof H)return H.subtract(n,t);if(Array.isArray(n)){let o=[];for(let r=0;r<n.length;r++)o[r]=n[r]-t[r];return o}else{N.error("Non supported type!");return}}static multiplyNumber(n,t){if(isFinite(n))return n*t;if(n instanceof Ee)return Ee.multiply(n,t);if(n instanceof S)return S.multiply(n,t);if(n instanceof q)return q.multiply(n,t);if(n instanceof H)return H.multiplyNumber(n,t);if(Array.isArray(n)){let o=[];for(let r=0;r<n.length;r++)o[r]=n[r]*t;return o}else{N.error("Non supported type!");return}}static divideNumber(n,t){if(isFinite(n))return n/t;if(n instanceof Ee)return Ee.multiply(n,1/t);if(n instanceof S)return S.multiply(n,1/t);if(n instanceof q)return q.multiply(n,1/t);if(n instanceof H)return H.multiplyNumber(n,1/t);if(Array.isArray(n)){let o=[];for(let r=0;r<n.length;r++)o[r]=n[r]/t;return o}else{N.error("Non supported type!");return}}static initWithScalar(n,t){if(isFinite(n))return t;if(n instanceof Ee)return Ee.fromCopyArray2([t,t]);if(n instanceof S)return S.fromCopyArray([t,t,t]);if(n instanceof q)return q.fromCopyArray([t,t,t,t]);if(n instanceof H)return H.fromCopy4(0,0,0,1);if(Array.isArray(n)){let o=[];for(let r=0;r<n.length;r++)o[r]=t;return o}else{N.error("Non supported type!");return}}static initWithFloat32Array(n,t,o,r){let i;if(isFinite(n)){let a=new Float32Array(o);return o._v=void 0,a[0]=t,new te(a)}else if(n instanceof te||n instanceof ut)o[0]=t.x,i=new ut(o);else if(n instanceof Ee||n instanceof pt)o[0]=t.x,o[1]=t.y,i=new pt(o);else if(n instanceof S||n instanceof L)o[0]=t.x,o[1]=t.y,o[2]=t.z,i=L.fromFloat32Array(o);else if(n instanceof q||n instanceof pe)o[0]=t.x,o[1]=t.y,o[2]=t.z,o[3]=t.w,i=new pe(o);else if(n instanceof H||n instanceof Ye)o[0]=t.x,o[1]=t.y,o[2]=t.z,o[3]=t.w,i=new Ye(o);else if(n instanceof Ut||n instanceof We)i=i==null?new We(o):i,i.m00=t.m00,i.m01=t.m01,i.m02=t.m02,i.m10=t.m10,i.m11=t.m11,i.m12=t.m12,i.m20=t.m20,i.m21=t.m21,i.m22=t.m22;else if(n instanceof Se||n instanceof $)i=new $(o),i.m00=t.m00,i.m01=t.m01,i.m02=t.m02,i.m03=t.m03,i.m10=t.m10,i.m11=t.m11,i.m12=t.m12,i.m13=t.m13,i.m20=t.m20,i.m21=t.m21,i.m22=t.m22,i.m23=t.m23,i.m30=t.m30,i.m31=t.m31,i.m32=t.m32,i.m33=t.m33;else if(n instanceof ve){for(let a=0;a<t._v.length;a++)o[a]=t._v[a];i=new ve(o)}else if(n==null){let a;switch(o.length){case 4:a=q.fromCopyFloat32Array(o);break;case 3:a=S.fromCopyFloat32Array(o);break;case 2:a=new Ee(o);break;case 1:a=new te(o);break}return o._v=void 0,a}else{if(Array.isArray(n)||ArrayBuffer.isView(n)||ArrayBuffer.isView(n._v))return n;N.error("Non supported type!");return}return o._v=void 0,i}static _setForce(n,t){if(n instanceof pe||n instanceof q){if(n.isEqual(t))return!1;n._v[0]=t._v[0],n._v[1]=t._v[1],n._v[2]=t._v[2],n._v[3]=t._v[3]}else if(n instanceof pt||n instanceof Ee){if(n.isEqual(t))return!1;n._v[0]=t._v[0],n._v[1]=t._v[1]}else if(n instanceof L||n instanceof S){if(n.isEqual(t))return!1;n._v[0]=t._v[0],n._v[1]=t._v[1],n._v[2]=t._v[2]}else if(n instanceof ut||n instanceof te)if(typeof t._v=="undefined"){if(n._v[0]==t)return!1;n._v[0]=t}else{if(n._v[0]==t._v[0])return!1;n._v[0]=t._v[0]}else if(n instanceof We||n instanceof Ut){if(n.isEqual(t))return!1;n._v[0]=t._v[0],n._v[1]=t._v[1],n._v[2]=t._v[2],n._v[3]=t._v[3],n._v[4]=t._v[4],n._v[5]=t._v[5],n._v[6]=t._v[6],n._v[7]=t._v[7],n._v[8]=t._v[8]}else if(n instanceof $||n instanceof Se){if(n.isEqual(t))return!1;n._v[0]=t._v[0],n._v[1]=t._v[1],n._v[2]=t._v[2],n._v[3]=t._v[3],n._v[4]=t._v[4],n._v[5]=t._v[5],n._v[6]=t._v[6],n._v[7]=t._v[7],n._v[8]=t._v[8],n._v[9]=t._v[9],n._v[10]=t._v[10],n._v[11]=t._v[11],n._v[12]=t._v[12],n._v[13]=t._v[13],n._v[14]=t._v[14],n._v[15]=t._v[15]}else if(n instanceof Ye||n instanceof H){if(n.isEqual(t))return!1;n._v[0]=t._v[0],n._v[1]=t._v[1],n._v[2]=t._v[2],n._v[3]=t._v[3]}else if(n instanceof ve){let o;t instanceof ve?o=t._v:o=t;let r=!0;for(let i=0;i<n._v.length;i++)if(n._v[i]!==o[i]){r=!1;break}if(r)return!1;for(let i=0;i<n._v.length;i++)n._v[i]=o[i]}else if(Array.isArray(n)){let o=!0;for(let r=0;r<n.length;r++)if(n[r]!==t._v[r]){o=!1;break}if(o)return!1;for(let r=0;r<n.length;r++)n[r]=t._v[r]}else if(isNaN(n._v.length))N.warn("Unknown type _setForce");else{let o=!0;for(let r=0;r<n._v.length;r++)if(Array.isArray(t)){if(n._v[r]!==t[r]){o=!1;break}}else if(n._v[r]!==t._v[r]){o=!1;break}if(o)return!1;for(let r=0;r<n._v.length;r++)Array.isArray(t)?n._v[r]=t[r]:n._v[r]=t._v[r]}return!0}};h(kl,"MathClassUtil"),f(kl,"__tmpVector4_0",pe.zero()),f(kl,"__tmpVector4_1",pe.zero());En=kl});var qo,Wl,rd=C(()=>{"use strict";yo();ra();Ot();or();Yt();ou();nn();ge();$a();pi();qo=class qo extends Xi{constructor(t,o={eventTargetDom:document,verticalSpeed:1,horizontalSpeed:1,turnSpeed:.25,mouseWheelSpeedScale:1,inverseVerticalRotating:!1,inverseHorizontalRotating:!1}){super();f(this,"__updateCount",0);f(this,"_horizontalSpeed");f(this,"_verticalSpeed");f(this,"_turnSpeed");f(this,"_mouseWheelSpeedScale");f(this,"_inverseVerticalRotating");f(this,"_inverseHorizontalRotating");f(this,"_onKeydown");f(this,"_isKeyDown",!1);f(this,"_isMouseDrag",!1);f(this,"_lastKeyCode",-1);f(this,"_onKeyup");f(this,"_currentDir",L.fromCopyArray([0,0,-1]));f(this,"_currentPos",L.fromCopyArray([0,0,0]));f(this,"_currentCenter",L.fromCopyArray([0,0,-1]));f(this,"_currentHorizontalDir",L.fromCopyArray([0,0,-1]));f(this,"_newDir",L.fromCopyArray([0,0,-1]));f(this,"_isMouseDown",!1);f(this,"_clickedMouseXOnCanvas",-1);f(this,"_clickedMouseYOnCanvas",-1);f(this,"_draggedMouseXOnCanvas",-1);f(this,"_draggedMouseYOnCanvas",-1);f(this,"_deltaMouseXOnCanvas",-1);f(this,"_deltaMouseYOnCanvas",-1);f(this,"_mouseXAdjustScale",1);f(this,"_mouseYAdjustScale",1);f(this,"_deltaY",-1);f(this,"_deltaX",-1);f(this,"_mouseUpBind",this._mouseUp.bind(this));f(this,"_mouseDownBind",this._mouseDown.bind(this));f(this,"_mouseMoveBind",this._mouseMove.bind(this));f(this,"_mouseWheelBind",this._mouseWheel.bind(this));f(this,"_eventTargetDom");f(this,"__doPreventDefault",!1);f(this,"_needInitialize",!0);f(this,"__targetEntities",[]);f(this,"aabbWithSkeletal",!0);f(this,"__cameraControllerComponent");this.__cameraControllerComponent=t,this._horizontalSpeed=o.horizontalSpeed,this._verticalSpeed=o.verticalSpeed,this._turnSpeed=o.turnSpeed,this._mouseXAdjustScale=this._turnSpeed,this._mouseYAdjustScale=this._turnSpeed,this._mouseWheelSpeedScale=o.mouseWheelSpeedScale,this._inverseVerticalRotating=o.inverseVerticalRotating,this._inverseHorizontalRotating=o.inverseHorizontalRotating,this.reset(),this._onKeydown=i=>{this._isKeyDown=!0,this._lastKeyCode=i.keyCode},this._onKeyup=i=>{this._isKeyDown=!1,this._lastKeyCode=-1};let r=o.eventTargetDom;this.registerEventListeners(r)}_updateCount(){this.__updateCount++,this.__cameraControllerComponent._updateCount(this.__updateCount)}get updateCount(){return this.__updateCount}registerEventListeners(t=document){this._eventTargetDom=t;let o=[{eventName:"keydown",handler:this._onKeydown,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"keyup",handler:this._onKeyup,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t}];"ontouchend"in document&&o.push({eventName:"touchstart",handler:this._mouseDownBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"touchend",handler:this._mouseUpBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"touchmove",handler:this._mouseMoveBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t}),"onmouseup"in document&&o.push({eventName:"mousedown",handler:this._mouseDownBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"mouseup",handler:this._mouseUpBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"mouseleave",handler:this._mouseUpBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t},{eventName:"mousemove",handler:this._mouseMoveBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t}),"onwheel"in document&&o.push({eventName:"wheel",handler:this._mouseWheelBind,options:{passive:!this.__doPreventDefault},classInstance:this,eventTargetDom:t}),Ft.register(bo,o)}unregisterEventListeners(){Ft.unregister(bo)}__tryToPreventDefault(t){this.__doPreventDefault&&t.preventDefault()}_mouseWheel(t){if(this._currentDir===null)return;let o=-1*Math.sign(t.deltaY)*this._mouseWheelSpeedScale*this._horizontalSpeed,r=qo.__tmp_Vec3_0;r.setComponents(this._currentDir.x,0,this._currentDir.z).normalize();let i=L.multiplyTo(r,o,qo.__tmp_Vec3_1);this._currentPos.add(i),this._currentCenter.add(i),this._updateCount()}_mouseDown(t){this.__tryToPreventDefault(t),this._isMouseDown=!0;let o=t.target.getBoundingClientRect();return this._clickedMouseXOnCanvas=t.clientX-o.left,this._clickedMouseYOnCanvas=t.clientY-o.top,this._updateCount(),!1}_mouseMove(t){if(this.__tryToPreventDefault(t),!this._isMouseDown)return;let o=t.target.getBoundingClientRect();this._draggedMouseXOnCanvas=t.clientX-o.left,this._draggedMouseYOnCanvas=t.clientY-o.top,this._deltaMouseXOnCanvas=this._draggedMouseXOnCanvas-this._clickedMouseXOnCanvas,this._deltaMouseYOnCanvas=this._draggedMouseYOnCanvas-this._clickedMouseYOnCanvas,this._isMouseDrag=!0,this._updateCount()}_mouseUp(t){this._isMouseDown=!1,this._isMouseDrag=!1;let o=t.target;if((o==null?void 0:o.getBoundingClientRect)==null)return;let r=o.getBoundingClientRect();this._clickedMouseXOnCanvas=t.clientX-r.left,this._clickedMouseYOnCanvas=t.clientY-r.top,this._updateCount()}tryReset(){}reset(){this._isKeyDown=!1,this._lastKeyCode=-1,this._currentPos.zero(),this._currentCenter.setComponents(0,0,-1),this._currentDir.setComponents(0,0,-1),this._currentHorizontalDir.setComponents(0,0,-1),this._isMouseDown=!1,this._isMouseDrag=!1,this._draggedMouseXOnCanvas=-1,this._draggedMouseYOnCanvas=-1,this._deltaMouseXOnCanvas=-1,this._deltaMouseYOnCanvas=-1,this._mouseXAdjustScale=this._turnSpeed,this._mouseYAdjustScale=this._turnSpeed,this._deltaY=0,this._deltaX=0,this._newDir.setComponents(0,0,-1)}logic(t){this.__updateCameraComponent(t)}__updateCameraComponent(t){let o=new jt;for(let s of this.__targetEntities)o.mergeAABB(this.__getTargetAABB(s));let r=o;if(this._needInitialize&&r!=null){let s=r.lengthCenterToCorner*(1+1/Math.tan(Y.degreeToRadian(t.fovy/2)));this._currentPos.copyComponents(r.centerPoint),this._currentPos.z+=s,this._currentCenter.copyComponents(r.centerPoint),this._currentDir.setComponents(0,0,-1);let l=t.entity.tryToGetSceneGraph();if(A.exist(l)){let c=Se.invertTo(l.matrixInner,qo.__tmpInvMat);c.multiplyVector3To(this._currentPos,this._currentPos),c.multiplyVector3To(this._currentCenter,this._currentCenter)}this._needInitialize=!1}let i=this._deltaY/90;this._newDir.x=this._currentDir.x*(1-i),this._newDir.y=i,this._newDir.z=this._currentDir.z*(1-i),this._newDir.normalize(),this._currentHorizontalDir.x=this._currentDir.x,this._currentHorizontalDir.y=0,this._currentHorizontalDir.z=this._currentDir.z,this._currentHorizontalDir.normalize();let a=qo.__tmp_Vec3_0.zero();switch(this._lastKeyCode){case 87:case 38:a.x=this._currentHorizontalDir.x*this._horizontalSpeed,a.z=this._currentHorizontalDir.z*this._horizontalSpeed;break;case 65:case 37:a.x=this._currentHorizontalDir.z*this._horizontalSpeed,a.z=-this._currentHorizontalDir.x*this._horizontalSpeed;break;case 83:case 40:a.x=-this._currentHorizontalDir.x*this._horizontalSpeed,a.z=-this._currentHorizontalDir.z*this._horizontalSpeed;break;case 68:case 39:a.x=-this._currentHorizontalDir.z*this._horizontalSpeed,a.z=this._currentHorizontalDir.x*this._horizontalSpeed;break;case 81:a.x=-this._newDir.x*this._horizontalSpeed,a.y=-this._newDir.y*this._horizontalSpeed,a.z=-this._newDir.z*this._horizontalSpeed;break;case 69:a.x=this._newDir.x*this._horizontalSpeed,a.y=this._newDir.y*this._horizontalSpeed,a.z=this._newDir.z*this._horizontalSpeed;break;case 82:a.y=this._verticalSpeed;break;case 70:a.y=-this._verticalSpeed;break}if(this._currentPos.add(a),this._currentCenter.add(a),this._isMouseDrag){this._inverseHorizontalRotating?this._deltaX=this._deltaMouseXOnCanvas*this._mouseXAdjustScale:this._deltaX=-this._deltaMouseXOnCanvas*this._mouseXAdjustScale,this._inverseVerticalRotating?this._deltaY+=this._deltaMouseYOnCanvas*this._mouseYAdjustScale:this._deltaY+=-this._deltaMouseYOnCanvas*this._mouseYAdjustScale,this._deltaY=Math.max(-120,Math.min(50,this._deltaY));let s=qo.__tmpRotateMat.rotateY(Y.degreeToRadian(this._deltaX));s.multiplyVectorTo(this._currentDir,this._currentDir);let l=L.subtractTo(this._currentCenter,this._currentPos,qo.__tmp_Vec3_1);s.multiplyVectorTo(l,l),l.x=l.x*(1-i),l.y=i,l.z=l.z*(1-i),l.normalize(),this._currentCenter.copyComponents(this._currentPos),this._currentCenter.add(l),this._clickedMouseXOnCanvas=this._draggedMouseXOnCanvas,this._clickedMouseYOnCanvas=this._draggedMouseYOnCanvas,this._deltaMouseXOnCanvas=0,this._deltaMouseYOnCanvas=0}t.eyeInner=this._currentPos,t.directionInner=this._currentCenter,t.upInner=t._up,t.leftInner=t.left,t.rightInner=t.right,t.topInner=t.top,t.bottomInner=t.bottom,t.fovyInner=t.fovy,this._calcZNearInner(t,this._currentPos,this._newDir),this._calcZFarInner(t)}getDirection(){return this._currentCenter!==null?this._newDir.clone():null}set horizontalSpeed(t){this._horizontalSpeed=t}get horizontalSpeed(){return this._horizontalSpeed}set verticalSpeed(t){this._verticalSpeed=t}get verticalSpeed(){return this._verticalSpeed}set mouseWheelSpeed(t){this._mouseWheelSpeedScale=t}get mouseWheelSpeed(){return this._mouseWheelSpeedScale}setTarget(t){this.setTargets([t])}__getTargetAABB(t){return this.aabbWithSkeletal?t.tryToGetSceneGraph().worldMergedAABBWithSkeletal:t.tryToGetSceneGraph().worldMergedAABB}setTargets(t){let o=new jt;for(let i of t)o.mergeAABB(this.__getTargetAABB(i));let r=o.lengthCenterToCorner/10;this.verticalSpeed=r,this.horizontalSpeed=r,this.__targetEntities=t,this._needInitialize=!0,this._updateCount()}getTargets(){return this.__targetEntities}get allInfo(){let t={};return t.verticalSpeed=this.verticalSpeed,t.horizontalSpeed=this.horizontalSpeed,t._turnSpeed=this._turnSpeed,this._currentPos&&(t._currentPos=this._currentPos.clone()),this._currentCenter&&(t._currentCenter=this._currentCenter.clone()),this._currentDir&&(t._currentDir=this._currentDir.clone()),t._deltaY=this._deltaY,t._newDir=this._newDir.clone(),t}set allInfo(t){let o=t;typeof t=="string"&&(o=JSON.parse(t));for(let r in o)o.hasOwnProperty(r)&&r in this&&(r==="quaternion"?this[r]=En.cloneOfMathObjects(En.arrayToQuaternion(o[r])):this[r]=En.cloneOfMathObjects(En.arrayToVectorOrMatrix(o[r])))}};h(qo,"WalkThroughCameraController"),f(qo,"__tmpInvMat",$.identity()),f(qo,"__tmpRotateMat",We.identity()),f(qo,"__tmp_Vec3_0",L.zero()),f(qo,"__tmp_Vec3_1",L.zero());Wl=qo});function iN(m){return de({typeList:Fu,index:m})}function aN(m){return Te({typeList:Fu,str:m})}function sN(m){return m instanceof Int8Array?Cu:m instanceof Uint8Array||m instanceof Uint8ClampedArray?wu:m instanceof Int16Array?Ru:m instanceof Uint16Array?Nu:m instanceof Int32Array?Pu:m instanceof Uint32Array?Mu:m instanceof Float32Array?Du:m instanceof Float64Array?Bu:id}function lN(m){return m===Cu?Int8Array:m===wu?Uint8Array:m===Ru?Int16Array:m===Nu?Uint16Array:m===Pu?Int32Array:m===Mu?Uint32Array:m===Du?Float32Array:m===Bu?Float64Array:void 0}function cN(m){let n=m;switch(m){case"bool":n="BOOL";break;case"i32":n="INT";break;case"u32":n="UNSIGNED_INT";break;case"f32":n="FLOAT";break;case"vec2<f32>":n="FLOAT";break;case"vec3<f32>":n="FLOAT";break;case"vec4<f32>":n="FLOAT";break;case"mat2x2<f32>":n="FLOAT";break;case"mat3x3<f32>":n="FLOAT";break;case"mat4x4<f32>":n="FLOAT";break;case"vec2<i32>":n="INT";break;case"vec3<i32>":n="INT";break;case"vec4<i32>":n="INT";break;case"sampler_2d":n="INT";break;case"sampler_2d_shadow":n="INT";break;case"sampler_3d":n="INT";break;case"sampler_cube":n="INT";break}return Te({typeList:Fu,str:n})}function fN(m){let n=m;switch(m){case"bool":n="BOOL";break;case"int":n="INT";break;case"float":n="FLOAT";break;case"vec2":n="FLOAT";break;case"vec3":n="FLOAT";break;case"vec4":n="FLOAT";break;case"mat2":n="FLOAT";break;case"mat3":n="FLOAT";break;case"mat4":n="FLOAT";break;case"ivec2":n="INT";break;case"ivec3":n="INT";break;case"ivec4":n="INT";break;case"sampler2D":n="INT";break;case"sampler2DShadow":n="INT";break;case"sampler2DRect":n="INT";break;case"sampler3D":n="INT";break;case"samplerCube":n="INT";break}return Te({typeList:Fu,str:n})}function uN(m){return m.index}var ls,Ar,id,Cu,wu,Ru,Nu,Pu,Mu,Du,Bu,B0,F0,Fu,I,xe=C(()=>{"use strict";st();Ar=(ls=class extends fe{constructor({index:t,str:o,sizeInBytes:r,wgsl:i,webgpu:a}){super({index:t,str:o});f(this,"__webgpu");f(this,"__wgsl");f(this,"__sizeInBytes");f(this,"__dummyStr");this.__sizeInBytes=r,this.__webgpu=a,this.__wgsl=i,this.__dummyStr=o}get wgsl(){return this.__wgsl}get webgpu(){return this.__webgpu}getSizeInBytes(){return this.__sizeInBytes}isFloatingPoint(){return this.index===5126||this.index===5127||this.index===36193}isInteger(){return this.index===5120||this.index===5122||this.index===5124}isUnsignedInteger(){return this.index===5121||this.index===5123||this.index===5125}},h(ls,"ComponentTypeClass"),ls),id=new Ar({index:5119,str:"UNKNOWN",sizeInBytes:0,wgsl:"unknown",webgpu:"unknown"}),Cu=new Ar({index:5120,str:"BYTE",sizeInBytes:1,wgsl:"i32",webgpu:"sint8"}),wu=new Ar({index:5121,str:"UNSIGNED_BYTE",sizeInBytes:1,wgsl:"u32",webgpu:"uint8"}),Ru=new Ar({index:5122,str:"SHORT",sizeInBytes:2,wgsl:"i32",webgpu:"sint16"}),Nu=new Ar({index:5123,str:"UNSIGNED_SHORT",sizeInBytes:2,wgsl:"u32",webgpu:"uint16"}),Pu=new Ar({index:5124,str:"INT",sizeInBytes:4,wgsl:"i32",webgpu:"sint32"}),Mu=new Ar({index:5125,str:"UNSIGNED_INT",sizeInBytes:4,wgsl:"u32",webgpu:"uint32"}),Du=new Ar({index:5126,str:"FLOAT",sizeInBytes:4,wgsl:"f32",webgpu:"float32"}),Bu=new Ar({index:5127,str:"DOUBLE",sizeInBytes:8,wgsl:"f32",webgpu:"float64"}),B0=new Ar({index:35670,str:"BOOL",sizeInBytes:1,wgsl:"bool",webgpu:"bool"}),F0=new Ar({index:5131,str:"HALF_FLOAT",sizeInBytes:2,wgsl:"f16",webgpu:"float16"}),Fu=[id,Cu,wu,Ru,Nu,Pu,Mu,Du,Bu,F0,B0];h(iN,"from");h(aN,"fromString");h(sN,"fromTypedArray");h(lN,"toTypedArray");h(cN,"fromWgslString");h(fN,"fromGlslString");h(uN,"toGltf2AccessorComponentType");I=Object.freeze({Unknown:id,Byte:Cu,UnsignedByte:wu,Short:Ru,UnsignedShort:Nu,Int:Pu,UnsignedInt:Mu,Float:Du,Double:Bu,Bool:B0,HalfFloat:F0,from:iN,fromTypedArray:sN,toTypedArray:lN,toGltf2AccessorComponentType:uN,fromString:aN,fromGlslString:fN,fromWgslString:cN})});var $r,cs,ad=C(()=>{"use strict";xe();se();Xo();ye();It();sr();Ot();fo();ji();Yt();ge();me();$r=class $r{constructor({bufferView:n,byteOffsetInBufferView:t,compositionType:o,componentType:r,byteStride:i,count:a,raw:s,max:l,min:c,arrayLength:u,normalized:_}){f(this,"__bufferView");f(this,"__byteOffsetInRawArrayBufferOfBuffer");f(this,"__compositionType",b.Unknown);f(this,"__componentType",I.Unknown);f(this,"__count",0);f(this,"__raw");f(this,"__dataView");f(this,"__typedArray");f(this,"__takenCount",0);f(this,"__byteStride",0);f(this,"__typedArrayClass");f(this,"__dataViewGetter");f(this,"__dataViewSetter");f(this,"__max",pe.fromCopyArray([-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE]));f(this,"__min",pe.fromCopyArray([Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE]));f(this,"__arrayLength",1);f(this,"__normalized",!1);f(this,"__isMinMixDirty",!0);f(this,"__version",0);f(this,"_primitive");var y,g,E,w,T,R,P,V;this.__bufferView=n,this.__byteOffsetInRawArrayBufferOfBuffer=n.byteOffsetInRawArrayBufferOfBuffer+t,this.__compositionType=o,this.__componentType=r,this.__count=a,this.__arrayLength=u,A.exist(l)&&this.__max.setComponents((y=l[0])!=null?y:-Number.MAX_VALUE,(g=l[1])!=null?g:-Number.MAX_VALUE,(E=l[2])!=null?E:-Number.MAX_VALUE,(w=l[3])!=null?w:-Number.MAX_VALUE),A.exist(c)&&this.__min.setComponents((T=c[0])!=null?T:Number.MAX_VALUE,(R=c[1])!=null?R:Number.MAX_VALUE,(P=c[2])!=null?P:Number.MAX_VALUE,(V=c[3])!=null?V:Number.MAX_VALUE),A.exist(l)&&A.exist(c)&&(this.__isMinMixDirty=!1),this.__raw=s,this.__normalized=_,this.__byteStride=i,this.__byteStride===0&&(this.__byteStride=this.__compositionType.getNumberOfComponents()*this.__componentType.getSizeInBytes()*this.__arrayLength);let d=this.getTypedArrayClass(this.__componentType);this.__typedArrayClass=d;let p=this.__byteStride-this.__compositionType.getNumberOfComponents()*this.__componentType.getSizeInBytes(),x=this.__raw.byteLength-this.__byteOffsetInRawArrayBufferOfBuffer,v=this.byteStride*this.__count-p;if(x<v&&N.error(`Requesting a data size that exceeds the remaining capacity of the buffer: ${this.bufferView.buffer.name}.
        Exceeded Size: ${v-x}
        this.__raw.byteLength: ${this.__raw.byteLength}
        this.__byteOffsetInRawArrayBufferOfBuffer: ${this.byteOffsetInRawArrayBufferOfBuffer}
        this.byteStride: ${this.byteStride}
        this.__count: ${this.__count}
        this.__raw.byteLength - this.__byteOffsetInRawArrayBufferOfBuffer: ${this.__raw.byteLength-this.__byteOffsetInRawArrayBufferOfBuffer}
        this.byteStride * this.__count: ${this.byteStride*this.__count}
        maxExceededSizeOnAoS: ${p}
        `),this.__dataView=new DataView(this.__raw,this.__byteOffsetInRawArrayBufferOfBuffer,Math.min(this.__byteStride*this.__count,this.__raw.byteLength-this.__byteOffsetInRawArrayBufferOfBuffer)),this.__byteOffsetInRawArrayBufferOfBuffer%d.BYTES_PER_ELEMENT===0)this.__typedArray=new d(this.__raw,this.__byteOffsetInRawArrayBufferOfBuffer,this.__compositionType.getNumberOfComponents()*this.__count);else{N.warn(`This Accessor's byteOffsetInRawArrayBufferOfBuffer is not aligned with the typedArrayClass's BYTES_PER_ELEMENT. So we need to copy the buffer.
So the typedArray data got by getTypedArray() is copied data, not reference to the original buffer.
`);let z=this.__raw.slice(this.__byteOffsetInRawArrayBufferOfBuffer,this.__byteOffsetInRawArrayBufferOfBuffer+this.__compositionType.getNumberOfComponents()*this.__count*d.BYTES_PER_ELEMENT);this.__typedArray=new d(z)}this.__dataViewGetter=this.__dataView[this.getDataViewGetter(this.__componentType)].bind(this.__dataView),this.__dataViewSetter=this.__dataView[this.getDataViewSetter(this.__componentType)].bind(this.__dataView)}__onUpdated(){var n;this.__version++,this._primitive!=null&&((n=this._primitive.deref())==null||n.onAccessorUpdated(this.__version))}getTypedArrayClass(n){switch(n){case I.Byte:return Int8Array;case I.UnsignedByte:return Uint8Array;case I.Short:return Int16Array;case I.UnsignedShort:return Uint16Array;case I.Int:return Int32Array;case I.UnsignedInt:return Uint32Array;case I.Float:return Float32Array;case I.Double:return Float64Array;default:N.error("Unexpected ComponentType!");return}}getDataViewGetter(n){switch(n){case I.Byte:return"getInt8";case I.UnsignedByte:return"getUint8";case I.Short:return"getInt16";case I.UnsignedShort:return"getUint16";case I.Int:return"getInt32";case I.UnsignedInt:return"getUint32";case I.Float:return"getFloat32";case I.Double:return"getFloat64";default:return N.error("Unexpected ComponentType!"),"unknown"}}getDataViewSetter(n){switch(n){case I.Byte:return"setInt8";case I.UnsignedByte:return"setUint8";case I.Short:return"setInt16";case I.UnsignedShort:return"setUint16";case I.Int:return"setInt32";case I.UnsignedInt:return"setUint32";case I.Float:return"setFloat32";case I.Double:return"setFloat64";default:N.error("Unexpected ComponentType!")}}takeOne(){let n=this.__raw;this.__takenCount>=this.__count&&N.error("You are trying to allocate more than you have secured.");let t=new this.__typedArrayClass(n,this.__byteOffsetInRawArrayBufferOfBuffer+this.__byteStride*this.__takenCount,this.__compositionType.getNumberOfComponents()*this.__arrayLength);return t._accessor=this,t._idx_of_accessor=this.__takenCount,this.__takenCount+=1,t}_takeExistedOne(n){let t=this.__raw;n>=this.__count&&N.error("You are trying to allocate more than you have secured.");let o=new this.__typedArrayClass(t,this.__byteOffsetInRawArrayBufferOfBuffer+this.__byteStride*n,this.__compositionType.getNumberOfComponents()*this.__arrayLength);return o._accessor=this,o._idx_of_accessor=n,o}get takenCount(){return this.takenCount}get numberOfComponents(){return this.__compositionType.getNumberOfComponents()}get componentSizeInBytes(){return this.__componentType.getSizeInBytes()}get elementSizeInBytes(){return this.numberOfComponents*this.componentSizeInBytes}get elementCount(){return this.__count}get byteLength(){return this.__byteStride*this.__count}get componentType(){return this.__componentType}get compositionType(){return this.__compositionType}getTypedArray(){return this.__typedArray}getUint8Array(){return new Uint8Array(this.bufferView.buffer.getArrayBuffer(),this.byteOffsetInRawArrayBufferOfBuffer,this.byteLength)}get isAoS(){return!this.isSoA}get isSoA(){return this.byteStride===this.__compositionType.getNumberOfComponents()*this.__componentType.getSizeInBytes()}get byteStride(){return this.__byteStride}getScalar(n,{indicesAccessor:t,endian:o=!0}){let r=n;return t&&(r=t.getScalar(n,{})),this.__dataViewGetter(this.__byteStride*r,o)}getScalarAt(n,t,{indicesAccessor:o,endian:r=!0}){let i=n;return o&&(i=o.getScalar(n,{})),this.__dataViewGetter(this.__byteStride*i+t,r)}getVec2AsArray(n,{indicesAccessor:t,endian:o=!0}){let r=n;t&&(r=t.getScalar(n,{}));let i=this.componentSizeInBytes;return[this.__dataViewGetter(this.__byteStride*r,o),this.__dataViewGetter(this.__byteStride*r+1*i,o)]}getVec3AsArray(n,{indicesAccessor:t,endian:o=!0}){let r=n;t&&(r=t.getScalar(n,{}));let i=this.componentSizeInBytes;return[this.__dataViewGetter(this.__byteStride*r,o),this.__dataViewGetter(this.__byteStride*r+1*i,o),this.__dataViewGetter(this.__byteStride*r+2*i,o)]}getVec4AsArray(n,{indicesAccessor:t,endian:o=!0}){let r=n;t&&(r=t.getScalar(n,{}));let i=this.componentSizeInBytes;return[this.__dataViewGetter(this.__byteStride*r,o),this.__dataViewGetter(this.__byteStride*r+1*i,o),this.__dataViewGetter(this.__byteStride*r+2*i,o),this.__dataViewGetter(this.__byteStride*r+3*i,o)]}getMat3AsArray(n,{indicesAccessor:t,endian:o=!0}){let r=n;t&&(r=t.getScalar(n,{}));let i=this.componentSizeInBytes;return[this.__dataViewGetter(this.__byteStride*r,o),this.__dataViewGetter(this.__byteStride*r+1*i,o),this.__dataViewGetter(this.__byteStride*r+2*i,o),this.__dataViewGetter(this.__byteStride*r+3*i,o),this.__dataViewGetter(this.__byteStride*r+4*i,o),this.__dataViewGetter(this.__byteStride*r+5*i,o),this.__dataViewGetter(this.__byteStride*r+6*i,o),this.__dataViewGetter(this.__byteStride*r+7*i,o),this.__dataViewGetter(this.__byteStride*r+8*i,o)]}getMat4AsArray(n,{indicesAccessor:t,endian:o=!0}){let r=n;t&&(r=t.getScalar(n,{}));let i=this.componentSizeInBytes;return[this.__dataViewGetter(this.__byteStride*r,o),this.__dataViewGetter(this.__byteStride*r+1*i,o),this.__dataViewGetter(this.__byteStride*r+2*i,o),this.__dataViewGetter(this.__byteStride*r+3*i,o),this.__dataViewGetter(this.__byteStride*r+4*i,o),this.__dataViewGetter(this.__byteStride*r+5*i,o),this.__dataViewGetter(this.__byteStride*r+6*i,o),this.__dataViewGetter(this.__byteStride*r+7*i,o),this.__dataViewGetter(this.__byteStride*r+8*i,o),this.__dataViewGetter(this.__byteStride*r+9*i,o),this.__dataViewGetter(this.__byteStride*r+10*i,o),this.__dataViewGetter(this.__byteStride*r+11*i,o),this.__dataViewGetter(this.__byteStride*r+12*i,o),this.__dataViewGetter(this.__byteStride*r+13*i,o),this.__dataViewGetter(this.__byteStride*r+14*i,o),this.__dataViewGetter(this.__byteStride*r+15*i,o)]}getVec2(n,{indicesAccessor:t,endian:o=!0}){let r=n;t&&(r=t.getScalar(n,{}));let i=this.componentSizeInBytes;return Ee.fromCopyArray2([this.__dataViewGetter(this.__byteStride*r,o),this.__dataViewGetter(this.__byteStride*r+1*i,o)])}getVec3(n,{indicesAccessor:t,endian:o=!0}){let r=n;t&&(r=t.getScalar(n,{}));let i=this.componentSizeInBytes;return S.fromCopyArray([this.__dataViewGetter(this.__byteStride*r,o),this.__dataViewGetter(this.__byteStride*r+1*i,o),this.__dataViewGetter(this.__byteStride*r+2*i,o)])}getVec4(n,{indicesAccessor:t,endian:o=!0}){let r=n;t&&(r=t.getScalar(n,{}));let i=this.componentSizeInBytes;return q.fromCopyArray([this.__dataViewGetter(this.__byteStride*r,o),this.__dataViewGetter(this.__byteStride*r+1*i,o),this.__dataViewGetter(this.__byteStride*r+2*i,o),this.__dataViewGetter(this.__byteStride*r+3*i,o)])}getMat3(n,{indicesAccessor:t,endian:o=!0}){let r=n;t&&(r=t.getScalar(n,{}));let i=this.componentSizeInBytes;return Ut.fromCopy9RowMajor(this.__dataViewGetter(this.__byteStride*r,o),this.__dataViewGetter(this.__byteStride*r+1*i,o),this.__dataViewGetter(this.__byteStride*r+2*i,o),this.__dataViewGetter(this.__byteStride*r+3*i,o),this.__dataViewGetter(this.__byteStride*r+4*i,o),this.__dataViewGetter(this.__byteStride*r+5*i,o),this.__dataViewGetter(this.__byteStride*r+6*i,o),this.__dataViewGetter(this.__byteStride*r+7*i,o),this.__dataViewGetter(this.__byteStride*r+8*i,o))}getMat4(n,{indicesAccessor:t,endian:o=!0}){let r=n;t&&(r=t.getScalar(n,{}));let i=this.componentSizeInBytes;return $.fromCopy16RowMajor(this.__dataViewGetter(this.__byteStride*r,o),this.__dataViewGetter(this.__byteStride*r+1*i,o),this.__dataViewGetter(this.__byteStride*r+2*i,o),this.__dataViewGetter(this.__byteStride*r+3*i,o),this.__dataViewGetter(this.__byteStride*r+4*i,o),this.__dataViewGetter(this.__byteStride*r+5*i,o),this.__dataViewGetter(this.__byteStride*r+6*i,o),this.__dataViewGetter(this.__byteStride*r+7*i,o),this.__dataViewGetter(this.__byteStride*r+8*i,o),this.__dataViewGetter(this.__byteStride*r+9*i,o),this.__dataViewGetter(this.__byteStride*r+10*i,o),this.__dataViewGetter(this.__byteStride*r+11*i,o),this.__dataViewGetter(this.__byteStride*r+12*i,o),this.__dataViewGetter(this.__byteStride*r+13*i,o),this.__dataViewGetter(this.__byteStride*r+14*i,o),this.__dataViewGetter(this.__byteStride*r+15*i,o))}getVec2To(n,t,{indicesAccessor:o,endian:r=!0}){let i=n;o&&(i=o.getScalar(n,{}));let a=this.componentSizeInBytes;return t.setComponents(this.__dataViewGetter(this.__byteStride*i,r),this.__dataViewGetter(this.__byteStride*i+1*a,r))}getVec3To(n,t,{indicesAccessor:o,endian:r=!0}){let i=n;o&&(i=o.getScalar(n,{}));let a=this.componentSizeInBytes;return t.setComponents(this.__dataViewGetter(this.__byteStride*i,r),this.__dataViewGetter(this.__byteStride*i+1*a,r),this.__dataViewGetter(this.__byteStride*i+2*a,r))}getVec4To(n,t,{indicesAccessor:o,endian:r=!0}){let i=n;o&&(i=o.getScalar(n,{}));let a=this.componentSizeInBytes;return t.setComponents(this.__dataViewGetter(this.__byteStride*i,r),this.__dataViewGetter(this.__byteStride*i+1*a,r),this.__dataViewGetter(this.__byteStride*i+2*a,r),this.__dataViewGetter(this.__byteStride*i+3*a,r))}getMat3To(n,t,{indicesAccessor:o,endian:r=!0}){let i=n;o&&(i=o.getScalar(n,{}));let a=this.componentSizeInBytes;return t.setComponents(this.__dataViewGetter(this.__byteStride*i,r),this.__dataViewGetter(this.__byteStride*i+1*a,r),this.__dataViewGetter(this.__byteStride*i+2*a,r),this.__dataViewGetter(this.__byteStride*i+3*a,r),this.__dataViewGetter(this.__byteStride*i+4*a,r),this.__dataViewGetter(this.__byteStride*i+5*a,r),this.__dataViewGetter(this.__byteStride*i+6*a,r),this.__dataViewGetter(this.__byteStride*i+7*a,r),this.__dataViewGetter(this.__byteStride*i+8*a,r))}getMat4To(n,t,{indicesAccessor:o,endian:r=!0}){let i=n;o&&(i=o.getScalar(n,{}));let a=this.componentSizeInBytes;return t.setComponents(this.__dataViewGetter(this.__byteStride*i,r),this.__dataViewGetter(this.__byteStride*i+1*a,r),this.__dataViewGetter(this.__byteStride*i+2*a,r),this.__dataViewGetter(this.__byteStride*i+3*a,r),this.__dataViewGetter(this.__byteStride*i+4*a,r),this.__dataViewGetter(this.__byteStride*i+5*a,r),this.__dataViewGetter(this.__byteStride*i+6*a,r),this.__dataViewGetter(this.__byteStride*i+7*a,r),this.__dataViewGetter(this.__byteStride*i+8*a,r),this.__dataViewGetter(this.__byteStride*i+9*a,r),this.__dataViewGetter(this.__byteStride*i+10*a,r),this.__dataViewGetter(this.__byteStride*i+11*a,r),this.__dataViewGetter(this.__byteStride*i+12*a,r),this.__dataViewGetter(this.__byteStride*i+13*a,r),this.__dataViewGetter(this.__byteStride*i+14*a,r),this.__dataViewGetter(this.__byteStride*i+15*a,r))}setScalar(n,t,{indicesAccessor:o,endian:r=!0}){let i=n;o&&(i=o.getScalar(n,{})),this.__dataViewSetter(this.__byteStride*i,t,r),this.__isMinMixDirty=!0,this.__onUpdated()}setVec2(n,t,o,{indicesAccessor:r,endian:i=!0}){let a=n;r&&(a=r.getScalar(n,{}));let s=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*a,t,i),this.__dataViewSetter(this.__byteStride*a+1*s,o,i),this.__isMinMixDirty=!0,this.__onUpdated()}setVec3(n,t,o,r,{indicesAccessor:i,endian:a=!0}){let s=n;i&&(s=i.getScalar(n,{}));let l=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*s,t,a),this.__dataViewSetter(this.__byteStride*s+1*l,o,a),this.__dataViewSetter(this.__byteStride*s+2*l,r,a),this.__isMinMixDirty=!0,this.__onUpdated()}setVec4(n,t,o,r,i,{indicesAccessor:a,endian:s=!0}){let l=n;a&&(l=a.getScalar(n,{}));let c=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*l,t,s),this.__dataViewSetter(this.__byteStride*l+1*c,o,s),this.__dataViewSetter(this.__byteStride*l+2*c,r,s),this.__dataViewSetter(this.__byteStride*l+3*c,i,s),this.__isMinMixDirty=!0,this.__onUpdated()}setMat4(n,t,o,r,i,a,s,l,c,u,_,d,p,x,v,y,g,{indicesAccessor:E,endian:w=!0}){let T=n;E&&(T=E.getScalar(n,{}));let R=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*T,t,w),this.__dataViewSetter(this.__byteStride*T+1*R,o,w),this.__dataViewSetter(this.__byteStride*T+2*R,r,w),this.__dataViewSetter(this.__byteStride*T+3*R,i,w),this.__dataViewSetter(this.__byteStride*T+4*R,a,w),this.__dataViewSetter(this.__byteStride*T+5*R,s,w),this.__dataViewSetter(this.__byteStride*T+6*R,l,w),this.__dataViewSetter(this.__byteStride*T+7*R,c,w),this.__dataViewSetter(this.__byteStride*T+8*R,u,w),this.__dataViewSetter(this.__byteStride*T+9*R,_,w),this.__dataViewSetter(this.__byteStride*T+10*R,d,w),this.__dataViewSetter(this.__byteStride*T+11*R,p,w),this.__dataViewSetter(this.__byteStride*T+12*R,x,w),this.__dataViewSetter(this.__byteStride*T+13*R,v,w),this.__dataViewSetter(this.__byteStride*T+14*R,y,w),this.__dataViewSetter(this.__byteStride*T+15*R,g,w),this.__isMinMixDirty=!0,this.__onUpdated()}setVec2AsVector(n,t,{indicesAccessor:o,endian:r=!0}){let i=n;o&&(i=o.getScalar(n,{}));let a=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*i,t.x,r),this.__dataViewSetter(this.__byteStride*i+1*a,t.y,r),this.__isMinMixDirty=!0,this.__onUpdated()}setVec3AsVector(n,t,{indicesAccessor:o,endian:r=!0}){let i=n;o&&(i=o.getScalar(n,{}));let a=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*i,t.x,r),this.__dataViewSetter(this.__byteStride*i+1*a,t.y,r),this.__dataViewSetter(this.__byteStride*i+2*a,t.z,r),this.__isMinMixDirty=!0,this.__onUpdated()}setVec4AsVector(n,t,{indicesAccessor:o,endian:r=!0}){let i=n;o&&(i=o.getScalar(n,{}));let a=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*i,t.x,r),this.__dataViewSetter(this.__byteStride*i+1*a,t.y,r),this.__dataViewSetter(this.__byteStride*i+2*a,t.z,r),this.__dataViewSetter(this.__byteStride*i+3*a,t.w,r),this.__isMinMixDirty=!0,this.__onUpdated()}setMat4AsMatrix44(n,t,{indicesAccessor:o,endian:r=!0}){let i=n;o&&(i=o.getScalar(n,{}));let a=this.componentSizeInBytes;this.__dataViewSetter(this.__byteStride*i,t._v[0],r),this.__dataViewSetter(this.__byteStride*i+1*a,t._v[1],r),this.__dataViewSetter(this.__byteStride*i+2*a,t._v[2],r),this.__dataViewSetter(this.__byteStride*i+3*a,t._v[3],r),this.__dataViewSetter(this.__byteStride*i+4*a,t._v[4],r),this.__dataViewSetter(this.__byteStride*i+5*a,t._v[5],r),this.__dataViewSetter(this.__byteStride*i+6*a,t._v[6],r),this.__dataViewSetter(this.__byteStride*i+7*a,t._v[7],r),this.__dataViewSetter(this.__byteStride*i+8*a,t._v[8],r),this.__dataViewSetter(this.__byteStride*i+9*a,t._v[9],r),this.__dataViewSetter(this.__byteStride*i+10*a,t._v[10],r),this.__dataViewSetter(this.__byteStride*i+11*a,t._v[11],r),this.__dataViewSetter(this.__byteStride*i+12*a,t._v[12],r),this.__dataViewSetter(this.__byteStride*i+13*a,t._v[13],r),this.__dataViewSetter(this.__byteStride*i+14*a,t._v[14],r),this.__dataViewSetter(this.__byteStride*i+15*a,t._v[15],r),this.__isMinMixDirty=!0,this.__onUpdated()}copyFromTypedArray(n){let t=this.numberOfComponents;for(let o=0;o<n.byteLength/this.componentSizeInBytes;o++){let r=Math.floor(o/t),i=r*t;switch(t){case 1:this.setScalar(r,n[i+0],{});break;case 2:this.setVec2(r,n[i+0],n[i+1],{});break;case 3:this.setVec3(r,n[i+0],n[i+1],n[i+2],{});break;case 4:this.setVec4(r,n[i+0],n[i+1],n[i+2],n[i+3],{});break;default:throw new Error("Other than vectors are currently not supported.")}}this.__isMinMixDirty=!0,this.__onUpdated()}setScalarAt(n,t,o,{indicesAccessor:r,endian:i=!0}){let a=n;r&&(a=r.getScalar(n,{})),this.__dataViewSetter(this.__byteStride*a+t,o,i),this.__isMinMixDirty=!0,this.__onUpdated()}setElementFromSameCompositionAccessor(n,t,o){let r=o!=null?o:n;this.compositionType.getNumberOfComponents()===1?this.setScalar(n,t.getScalar(r,{}),{}):this.compositionType.getNumberOfComponents()===2?this.setVec2AsVector(n,t.getVec2(r,{}),{}):this.compositionType.getNumberOfComponents()===3?this.setVec3AsVector(n,t.getVec3(r,{}),{}):this.compositionType.getNumberOfComponents()===4&&this.setVec4AsVector(n,t.getVec4(r,{}),{}),this.__isMinMixDirty=!0,this.__onUpdated()}copyBuffer(n){new Uint8Array(this.__raw).set(new Uint8Array(n.__raw,n.__byteOffsetInRawArrayBufferOfBuffer,n.byteLength),this.__byteOffsetInRawArrayBufferOfBuffer),this.__isMinMixDirty=!0,this.__onUpdated()}setElementFromAccessor(n,t,o){let r=o!=null?o:n;if(this.compositionType.getNumberOfComponents()===1)t.compositionType.getNumberOfComponents()===1?this.setScalar(n,t.getScalar(r,{}),{}):t.compositionType.getNumberOfComponents()===2?this.setScalar(n,t.getVec2(r,{}).x,{}):t.compositionType.getNumberOfComponents()===3?this.setScalar(n,t.getVec3(r,{}).x,{}):t.compositionType.getNumberOfComponents()===4&&this.setScalar(n,t.getVec4(r,{}).x,{});else if(this.compositionType.getNumberOfComponents()===2){if(t.compositionType.getNumberOfComponents()===1){let i=t.getScalar(r,{});this.setVec2(n,i,0,{})}else if(t.compositionType.getNumberOfComponents()===2)this.setVec2AsVector(n,t.getVec2(r,{}),{});else if(t.compositionType.getNumberOfComponents()===3){let i=t.getVec3(r,{});this.setVec2(n,i.x,i.y,{})}else if(t.compositionType.getNumberOfComponents()===4){let i=t.getVec4(r,{});this.setVec2(n,i.x,i.y,{})}}else if(this.compositionType.getNumberOfComponents()===3){if(t.compositionType.getNumberOfComponents()===1){let i=t.getScalar(r,{});this.setVec3(n,i,0,0,{})}else if(t.compositionType.getNumberOfComponents()===2){let i=t.getVec2(r,{});this.setVec3(n,i.x,i.y,0,{})}else if(t.compositionType.getNumberOfComponents()===3){let i=t.getVec3(r,{});this.setVec3AsVector(n,i,{})}else if(t.compositionType.getNumberOfComponents()===4){let i=t.getVec4(r,{});this.setVec3(n,i.x,i.y,i.z,{})}}else if(this.compositionType.getNumberOfComponents()===4){if(t.compositionType.getNumberOfComponents()===1){let i=t.getScalar(r,{});this.setVec4(n,i,0,0,0,{})}else if(t.compositionType.getNumberOfComponents()===2){let i=t.getVec2(r,{});this.setVec4(n,i.x,i.y,0,0,{})}else if(t.compositionType.getNumberOfComponents()===3){let i=t.getVec3(r,{});this.setVec4(n,i.x,i.y,i.z,0,{})}else if(t.compositionType.getNumberOfComponents()===4){let i=t.getVec4(r,{});this.setVec4AsVector(n,i,{})}}this.__isMinMixDirty=!0,this.__onUpdated()}addElementFromSameCompositionAccessor(n,t,o,r){let i=r!=null?r:n;this.compositionType.getNumberOfComponents()===1?this.setScalar(n,this.getScalar(n,{})+o*t.getScalar(i,{}),{}):this.compositionType.getNumberOfComponents()===2?this.setVec2AsVector(n,Ee.add(this.getVec2(n,{}),Ee.multiply(t.getVec2(i,{}),o)),{}):this.compositionType.getNumberOfComponents()===3?this.setVec3AsVector(n,S.add(this.getVec3(n,{}),S.multiply(t.getVec3(i,{}),o)),{}):this.compositionType.getNumberOfComponents()===4&&this.setVec4AsVector(n,q.add(this.getVec4(n,{}),q.multiply(t.getVec4(i,{}),o)),{}),this.__isMinMixDirty=!0,this.__onUpdated()}get arrayBufferOfBufferView(){return this.__raw}get dataViewOfBufferView(){return this.__dataView}get byteOffsetInBufferView(){return this.__byteOffsetInRawArrayBufferOfBuffer-this.__bufferView.byteOffsetInRawArrayBufferOfBuffer}get byteOffsetInBuffer(){return this.__byteOffsetInRawArrayBufferOfBuffer-this.__bufferView.buffer.byteOffsetInRawArrayBuffer}get byteOffsetInRawArrayBufferOfBuffer(){return this.__byteOffsetInRawArrayBufferOfBuffer}get bufferView(){return this.__bufferView}setMinMax(n,t){let o=this.compositionType.getNumberOfComponents();o===1?(this.__min._v[0]=n[0],this.__max._v[0]=t[0]):o===2?(this.__min._v[0]=n[0],this.__min._v[1]=n[1],this.__max._v[0]=t[0],this.__max._v[1]=t[1]):o===3?(this.__min._v[0]=n[0],this.__min._v[1]=n[1],this.__min._v[2]=n[2],this.__max._v[0]=t[0],this.__max._v[1]=t[1],this.__max._v[2]=t[2]):o===4&&(this.__min._v[0]=n[0],this.__min._v[1]=n[1],this.__min._v[2]=n[2],this.__min._v[3]=n[3],this.__max._v[0]=t[0],this.__max._v[1]=t[1],this.__max._v[2]=t[2],this.__max._v[3]=t[3]),this.__isMinMixDirty=!1}get min(){this.__isMinMixDirty&&this.__calcMinMax();let n=this.compositionType.getNumberOfComponents();return n===4?[this.__min._v[0],this.__min._v[1],this.__min._v[2],this.__min._v[3]]:n===3?[this.__min._v[0],this.__min._v[1],this.__min._v[2]]:n===2?[this.__min._v[0],this.__min._v[1]]:[this.__min._v[0]]}get max(){this.__isMinMixDirty&&this.__calcMinMax();let n=this.compositionType.getNumberOfComponents();return n===4?[this.__max._v[0],this.__max._v[1],this.__max._v[2],this.__max._v[3]]:n===3?[this.__max._v[0],this.__max._v[1],this.__max._v[2]]:n===2?[this.__max._v[0],this.__max._v[1]]:[this.__max._v[0]]}get normalized(){return this.__normalized}__calcMinMax(){let n=this.compositionType.getNumberOfComponents();if(n===4){this.__max.setComponents(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this.__min.setComponents(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);let t=$r.__tmpVector4_0;for(let o=0;o<this.elementCount;o++){this.getVec4To(o,t,{});for(let r=0;r<4;r++)this.__max._v[r]<t._v[r]&&(this.__max._v[r]=t._v[r]),t._v[r]<this.__min._v[r]&&(this.__min._v[r]=t._v[r])}}else if(n===3){this.__max.setComponents(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this.__min.setComponents(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);let t=$r.__tmpVector3_0;for(let o=0;o<this.elementCount;o++){this.getVec3To(o,t,{});for(let r=0;r<3;r++)this.__max._v[r]<t._v[r]&&(this.__max._v[r]=t._v[r]),t._v[r]<this.__min._v[r]&&(this.__min._v[r]=t._v[r])}}else if(n===2){this.__max.setComponents(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this.__min.setComponents(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);let t=$r.__tmpVector2_0;for(let o=0;o<this.elementCount;o++){this.getVec2To(o,t,{});for(let r=0;r<2;r++)this.__max._v[r]<t._v[r]&&(this.__max._v[r]=t._v[r]),t._v[r]<this.__min._v[r]&&(this.__min._v[r]=t._v[r])}}else if(n===1){this.__max.setComponents(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this.__min.setComponents(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);for(let t=0;t<this.elementCount;t++){let o=this.getScalar(t,{});this.__max._v[0]<o&&(this.__max._v[0]=o),o<this.__min._v[0]&&(this.__min._v[0]=o)}}this.__isMinMixDirty=!1}get isMinMaxDirty(){return this.__isMinMixDirty}get version(){return this.__version}get actualByteStride(){return this.__byteStride===0?this.__compositionType.getNumberOfComponents()*this.__componentType.getSizeInBytes()*this.__arrayLength:this.__byteStride}isSame(n){return this.byteLength===n.byteLength&&this.byteOffsetInRawArrayBufferOfBuffer===n.byteOffsetInRawArrayBufferOfBuffer&&this.bufferView.buffer.getArrayBuffer()===n.bufferView.buffer.getArrayBuffer()}};h($r,"Accessor"),f($r,"__tmpVector4_0",pe.zero()),f($r,"__tmpVector3_0",L.zero()),f($r,"__tmpVector2_0",pt.zero());cs=$r});var sd,fs,ld=C(()=>{"use strict";ad();yr();sd=class sd{constructor({buffer:n,byteOffsetInBuffer:t,defaultByteStride:o,byteLength:r,raw:i}){f(this,"__buffer");f(this,"__byteOffsetInRawArrayBufferOfBuffer");f(this,"__byteOffsetInBuffer");f(this,"__byteLength");f(this,"__defaultByteStride",0);f(this,"__takenByte",0);f(this,"__takenAccessorCount",0);f(this,"__raw");f(this,"__accessors",[]);this.__buffer=n,this.__byteOffsetInBuffer=t,this.__byteOffsetInRawArrayBufferOfBuffer=n.byteOffsetInRawArrayBuffer+t,this.__byteLength=r,this.__defaultByteStride=o,this.__raw=i}get defaultByteStride(){return this.__defaultByteStride}get byteLength(){return this.__byteLength}get byteOffsetInBuffer(){return this.__byteOffsetInRawArrayBufferOfBuffer-this.__buffer.byteOffsetInRawArrayBuffer}get byteOffsetInRawArrayBufferOfBuffer(){return this.__byteOffsetInRawArrayBufferOfBuffer}get buffer(){return this.__buffer}get isSoA(){return!this.isAoS}get isAoS(){for(let n of this.__accessors)if(n.isAoS)return!0;return!1}getUint8Array(){return new Uint8Array(this.__raw,this.__byteOffsetInRawArrayBufferOfBuffer,this.__byteLength)}takeAccessor({compositionType:n,componentType:t,count:o,byteStride:r=this.defaultByteStride,max:i,min:a,arrayLength:s=1,normalized:l=!1}){return this.__takeAccessorInner({compositionType:n,componentType:t,count:o,byteStride:r,max:i,min:a,normalized:l,arrayLength:s})}takeAccessorWithByteOffset({compositionType:n,componentType:t,count:o,byteOffsetInBufferView:r,byteStride:i=this.defaultByteStride,max:a,min:s,normalized:l=!1}){return this.__takeAccessorInnerWithByteOffset({compositionType:n,componentType:t,count:o,byteStride:i,byteOffsetInBufferView:r,max:a,min:s,normalized:l})}__takeAccessorInner({compositionType:n,componentType:t,count:o,byteStride:r,max:i,min:a,arrayLength:s,normalized:l}){let c=this.__takenByte,u=r;if(u===0&&(u=n.getNumberOfComponents()*t.getSizeInBytes()*s),this.__takenByte+u*(o-1)+t.getSizeInBytes()*n.getNumberOfComponents()>this.byteLength){let d=`The size of the Accessor you are trying to take exceeds the byte length left in the BufferView.
BufferView.byteLength: ${this.byteLength}, BufferView.takenSizeInByte: ${this.__takenByte}, Accessor.byteStride: ${r}, Accessor.count: ${o};
byteSizeToTake: ${u*o}, the byte length left in the Buffer: ${this.byteLength-this.__takenByte}`;return new Ue({message:d,error:void 0})}let _=new cs({bufferView:this,byteOffsetInBufferView:c,compositionType:n,componentType:t,byteStride:r,count:o,raw:this.__raw,max:i,min:a,arrayLength:s,normalized:l});return this.__accessors.push(_),this.__takenByte+=u*o,new je(_)}__takeAccessorInnerWithByteOffset({compositionType:n,componentType:t,count:o,byteStride:r,byteOffsetInBufferView:i,max:a,min:s,normalized:l}){if(this.__takenByte+r*(o-1)+t.getSizeInBytes()*n.getNumberOfComponents()>this.byteLength){let u=`The size of the Accessor you are trying to take exceeds the byte length left in the BufferView.
BufferView.byteLength: ${this.byteLength}, BufferView.takenSizeInByte: ${this.__takenByte}, Accessor.byteStride: ${r}, Accessor.count: ${o};
byteSizeToTake: ${r*o}, the byte length left in the Buffer: ${this.byteLength-this.__takenByte}`;return new Ue({message:u,error:void 0})}let c=new cs({bufferView:this,byteOffsetInBufferView:i,compositionType:n,componentType:t,byteStride:r,count:o,raw:this.__raw,max:a,min:s,arrayLength:1,normalized:l});return this.__accessors.push(c),new je(c)}isSame(n){return this.byteLength===n.byteLength&&this.byteOffsetInRawArrayBufferOfBuffer===n.byteOffsetInRawArrayBufferOfBuffer&&this.defaultByteStride===n.defaultByteStride&&this.buffer.getArrayBuffer()===n.buffer.getArrayBuffer()}};h(sd,"BufferView");fs=sd});var cd,ei,Lu=C(()=>{"use strict";ld();se();xe();co();ir();me();cd=class cd{constructor({byteLength:n,buffer:t,name:o,byteAlign:r}){f(this,"__byteLength",0);f(this,"__byteOffset",0);f(this,"__takenBytesIndex",0);f(this,"__byteAlign");f(this,"__raw");f(this,"__name","");f(this,"__bufferViews",[]);this.__name=o,this.__byteLength=n,this.__byteAlign=r,t instanceof Uint8Array?(this.__raw=t.buffer,this.__byteOffset=t.byteOffset):this.__raw=t}set name(n){this.__name=n}get name(){return this.__name}getArrayBuffer(){return this.__raw}__padding(n,t){let o=ie.calcPaddingBytes(n,t);return o>0&&N.info("Padding bytes added to takenBytesIndex."),o}takeBufferView({byteLengthToNeed:n,byteStride:t}){let o=n;if(o+this.__takenBytesIndex>this.byteLength){let i=`The size of the BufferView you are trying to take exceeds the byte length left in the Buffer.
Buffer.byteLength: ${this.byteLength}, Buffer.takenSizeInByte: ${this.takenSizeInByte},
byteSizeToTake: ${o}, the byte length left in the Buffer: ${this.__byteLength-this.__takenBytesIndex}`;return new Ue({message:i,error:{"Buffer.byteLength":this.takenSizeInByte,"Buffer.takenSizeInByte":this.takenSizeInByte}})}let r=new fs({buffer:this,byteOffsetInBuffer:this.__takenBytesIndex,defaultByteStride:t,byteLength:o,raw:this.__raw});return this.__takenBytesIndex+=o,this.__takenBytesIndex=ie.addPaddingBytes(this.__takenBytesIndex,this.__byteAlign),this.__bufferViews.push(r),new je(r)}takeBufferViewWithByteOffset({byteLengthToNeed:n,byteStride:t,byteOffset:o}){if(n+o>this.byteLength){let s=`The size of the BufferView you are trying to take exceeds the byte length left in the Buffer.
Buffer.byteLength: ${this.byteLength}, Buffer.takenSizeInByte: ${this.takenSizeInByte},
byteSizeToTake: ${n}, the byte length left in the Buffer: ${this.__byteLength-this.__takenBytesIndex}`;return new Ue({message:s,error:void 0})}let i=new fs({buffer:this,byteOffsetInBuffer:o,defaultByteStride:t,byteLength:n,raw:this.__raw}),a=Uint8Array.BYTES_PER_ELEMENT*n+o;return this.__takenBytesIndex<a&&(this.__takenBytesIndex=a),this.__bufferViews.push(i),new je(i)}_addTakenByteIndex(n){this.__takenBytesIndex+=n}get byteLength(){return this.__byteLength}get takenSizeInByte(){return this.__takenBytesIndex}get byteOffsetInRawArrayBuffer(){return this.__byteOffset}getTypedArray(n,t,o,r=100){let i,a=I.toTypedArray(o);return a===void 0&&N.warn("componentType is Invalid"),b.isArray(t)?i=new a(this.__raw,this.__byteOffset+n*4,r):i=new a(this.__raw,this.__byteOffset+n*4,1),i}isSame(n){return this.__raw===n.__raw}};h(cd,"Buffer");ei=cd});function mN(m){return de({typeList:O0,index:m})}function _N(m){return Te({typeList:O0,str:m})}var us,Vu,L0,V0,z0,G0,O0,Ce,cr=C(()=>{"use strict";st();Vu=(us=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(us,"BufferUseClass"),us),L0=new Vu({index:0,str:"GPUInstanceData"}),V0=new Vu({index:1,str:"GPUVertexData"}),z0=new Vu({index:2,str:"UBOGeneric"}),G0=new Vu({index:3,str:"CPUGeneric"}),O0=[L0,V0,z0,G0];h(mN,"from");h(_N,"fromString");Ce=Object.freeze({GPUInstanceData:L0,GPUVertexData:V0,UBOGeneric:z0,CPUGeneric:G0,from:mN,fromString:_N})});var ia,we,jo=C(()=>{"use strict";Lu();cr();tt();Vn();ia=class ia{constructor(n,t,o){f(this,"__buffers",{});f(this,"__buffersOnDemand",new Map);f(this,"__memorySizeRatios",{});this.__memorySizeRatios[Ce.CPUGeneric.str]=n,this.__memorySizeRatios[Ce.GPUInstanceData.str]=t,this.__memorySizeRatios[Ce.GPUVertexData.str]=o}static createInstanceIfNotCreated({cpuGeneric:n,gpuInstanceData:t,gpuVertexData:o}){return this.__instance?this.__instance:(this.__instance=new ia(n,t,o),this.__instance)}__makeMultipleOf4byteSize(n){return n+(n%4===0?0:4-n%4)}static getInstance(){return this.__instance}getMemorySize(){return ia.bufferWidthLength*ia.bufferHeightLength*4*4}__createBuffer(n){let t=this.getMemorySize()*this.__memorySizeRatios[n.str],o=new ArrayBuffer(this.__makeMultipleOf4byteSize(t)),r=4;(n===Ce.GPUInstanceData||n===Ce.GPUVertexData)&&(r=16);let i=new ei({byteLength:o.byteLength,buffer:o,name:n.str,byteAlign:r});return this.__buffers[i.name]=i,i}getBuffer(n){return this.__buffers[n.toString()]}createOrGetBuffer(n){let t=this.__buffers[n.toString()];return t==null&&(t=this.__createBuffer(n)),t}createBufferOnDemand(n,t,o){let r=new ArrayBuffer(n),i=new ei({byteLength:r.byteLength,buffer:r,name:Ce.UBOGeneric.toString(),byteAlign:o});return this.__buffersOnDemand.set(t.objectUID,i),i}getBufferOnDemand(n){return this.__buffersOnDemand.get(n.objectUID)}static get bufferWidthLength(){return F.dataTextureWidth}static get bufferHeightLength(){return F.dataTextureHeight}printMemoryUsage(){let n=this.__buffers[Ce.CPUGeneric.toString()],t=this.__buffers[Ce.GPUInstanceData.toString()],o=this.__buffers[Ce.GPUVertexData.toString()];console.log("Memory Usage in Memory Manager:"),console.log(`CPUGeneric: ${n.takenSizeInByte} byte of ${n.byteLength} bytes. (${n.takenSizeInByte/n.byteLength*100} %) `),console.log(`GPUInstanceData: ${t.takenSizeInByte} byte of ${t.byteLength} bytes. (${t.takenSizeInByte/t.byteLength*100} %) `),o!=null&&console.log(`GPUVertexData: ${o.takenSizeInByte} byte of ${o.byteLength} bytes. (${o.takenSizeInByte/o.byteLength*100} %) `)}dumpBuffer(n){let t=this.__buffers[n.toString()];return on.downloadArrayBuffer(n.toString(),t.getArrayBuffer()),t}};h(ia,"MemoryManager"),f(ia,"__instance");we=ia});function hN(m){return de({typeList:dN,index:m})}var ms,ti,U0,k0,W0,Q0,X0,H0,q0,j0,Y0,dN,Ne,Cn=C(()=>{"use strict";st();ti=(ms=class extends fe{constructor({index:t,str:o,methodName:r}){super({index:t,str:o});f(this,"methodName");this.methodName=r}},h(ms,"ProcessStageClass"),ms),U0=new ti({index:-1,str:"UNKNOWN",methodName:"$unknown"}),k0=new ti({index:0,str:"CREATE",methodName:"$create"}),W0=new ti({index:1,str:"LOAD",methodName:"$load"}),Q0=new ti({index:2,str:"MOUNT",methodName:"$mount"}),X0=new ti({index:3,str:"LOGIC",methodName:"$logic"}),H0=new ti({index:4,str:"PRE_RENDER",methodName:"$prerender"}),q0=new ti({index:5,str:"RENDER",methodName:"$render"}),j0=new ti({index:6,str:"UNMOUNT",methodName:"$unmount"}),Y0=new ti({index:7,str:"DISCARD",methodName:"$discard"}),dN=[U0,k0,W0,Q0,X0,H0,q0,j0,Y0];h(hN,"from");Ne=Object.freeze({Unknown:U0,Create:k0,Load:W0,Mount:Q0,Logic:X0,PreRender:H0,Render:q0,Unmount:j0,Discard:Y0,from:hN})});var Q,it=C(()=>{"use strict";Q=Object.freeze({AnimationStateComponentTID:1,AnimationComponentTID:2,TransformComponentTID:3,SceneGraphComponentTID:4,MeshComponentTID:5,MeshRendererComponentTID:6,LightComponentTID:7,CameraControllerComponentTID:8,CameraComponentTID:9,SkeletalComponentTID:10,BlendShapeComponentTID:11,PhysicsComponentTID:12,EffekseerComponentTID:13,VrmComponentTID:14,ConstraintComponentTID:15,maxWellKnownTidNumber:15})});var Io,J,St=C(()=>{"use strict";ge();tt();it();Io=class Io{constructor(){}static registerComponentClass(n){Io.__componentClasses.set(n.componentTID,n)}static deregisterComponentClass(n){Io.__componentClasses.delete(n)}static getComponentClass(n){return this.__componentClasses.get(n)}static createComponent(n,t,o){let i=Io.__componentClasses.get(n);if(A.exist(i)){let a=this.__component_sid_count_map.get(n);A.not.exist(a)&&(this.__component_sid_count_map.set(n,0),a=Io.invalidComponentSID);let s=this.__components.get(n),l=-1;if(A.exist(s)){for(let p=0;p<s.length;p++)if(A.not.exist(s[p])){l=p;break}}let c=-1,u=!1;l===-1?(this.__component_sid_count_map.set(n,++a),c=a):(c=l,u=!0);let _=new i(t,c,o,u);this.__components.has(n)||(this.__components.set(n,[]),this.__updateComponentTIDs());let d=this.__components.get(n);return d[_.componentSID]=_,_}else throw new Error("The Component Class object is invalid.")}static deleteComponent(n){let t=Io,o=n.componentTID,r=n.componentSID,i=t.__components.get(o);i!=null&&delete i[r]}static getComponent(n,t){return this.getComponentFromComponentTID(n.componentTID,t)}static getComponentFromComponentTID(n,t){let o=this.__components.get(n);if(o!=null)return o[t]!=null?o[t]:void 0}static _getComponents(n){return this.__components.get(n.componentTID)}static _getComponentsIncludingDead(n){return this.__components.get(n.componentTID)}static getMemoryBeginIndex(n){let t=0;for(let o=0;o<n;o++){let r=Io.__componentClasses.get(o);if(r!=null){let i=r.sizeOfThisComponent,a=F.maxEntityNumber;t+=i*a}}return t}static getComponentsWithType(n){let t=this.__components.get(n.componentTID);return t==null?[]:t.filter(o=>o!=null)}static __updateComponentTIDs(){let n=Array.from(this.__components.keys());n.sort((o,r)=>o-r),this.__componentTIDs=n;let t=[];t.push(Q.MeshRendererComponentTID),this.__components.has(Q.EffekseerComponentTID)&&t.push(Q.EffekseerComponentTID),this.__renderingComponentTIDs=t}static getComponentTIDs(){return this.__componentTIDs}static getRenderingComponentTIDs(){return this.__renderingComponentTIDs}};h(Io,"ComponentRepository"),f(Io,"__component_sid_count_map",new Map),f(Io,"__components",new Map),f(Io,"__componentClasses",new Map),f(Io,"__componentTIDs",[]),f(Io,"__renderingComponentTIDs",[]),f(Io,"invalidComponentSID",-1);J=Io});var kt,nt,zn=C(()=>{"use strict";Vn();kt=class kt{constructor(){f(this,"__objectUid",kt.currentMaxObjectCount++);f(this,"__uniqueName");f(this,"_tags",{});f(this,"__combinedTagString","");this.__uniqueName=`${this.constructor.name}__uid_${this.__objectUid}`,this.__updateInfo(this.__uniqueName)}__updateInfo(n){kt.__uniqueNames[this.__objectUid]=n,kt.__objects[this.__objectUid]=new WeakRef(this),kt.__objectsByNameMap.set(this.__uniqueName,new WeakRef(this))}unregister(){delete kt.__objects[this.__objectUid],delete kt.__uniqueNames[this.__objectUid],kt.__objectsByNameMap.delete(this.__uniqueName)}static searchByTag(n,t){var o;for(let r of kt.__objects)if(((o=r.deref())==null?void 0:o.getTagValue(n))===t)return r}get objectUID(){return this.__objectUid}static getRnObject(n){var t;return(t=kt.__objects[n])==null?void 0:t.deref()}static getRnObjectByName(n){var t;return(t=kt.__objectsByNameMap.get(n))==null?void 0:t.deref()}tryToSetUniqueName(n,t){if(kt.__uniqueNames.indexOf(n)!==-1){if(t){let o=n+"_("+this.__objectUid+")";if(kt.__uniqueNames.indexOf(o)===-1)return kt.__objectsByNameMap.delete(this.__uniqueName),this.__uniqueName=o,kt.__uniqueNames[this.__objectUid]=this.__uniqueName,kt.__objectsByNameMap.set(this.__uniqueName,new WeakRef(this)),!0}return!1}else return this.__uniqueName=n,kt.__uniqueNames[this.__objectUid]=this.__uniqueName,kt.__objectsByNameMap.set(this.__uniqueName,new WeakRef(this)),!0}validateTagString(n){return!new RegExp(/[!"#$%&'()\*\+\-\s\.,\/:;<=>?@\[\\\]^`{|}~]/g).test(n)}tryToSetTag(n){return this.validateTagString(n.tag)?(this.hasTag(n.tag)&&this.removeTag(n.tag),this._tags[n.tag]=n.value,this.__combinedTagString+=`${n.tag}:${n.value} `,!0):!1}getTagValue(n){return this._tags[n]}getTag(n){return{tag:n,value:this._tags[n]}}hasTag(n){return this._tags[n]!=null}removeTag(n){let t=`${n}:${this._tags[n]} `;this.__combinedTagString.replace(this.__combinedTagString,""),delete this._tags[n]}matchTag(n,t){return this._tags[n]===t}matchTagsAsFreeStrings(n){let t="^";for(let r=0;r<n.length;r++)t+=`(?=.*${n[r]})`;return!!new RegExp(t).test(this.__combinedTagString)}matchTags(n){let t="^";for(let r in n)t+=`(?=.*${[r]}:${n[r]})`;return!!new RegExp(t).test(this.__combinedTagString)}get uniqueName(){return this.__uniqueName}static _reset(){this.currentMaxObjectCount=0,this.__uniqueNames=[],this.__objectsByNameMap=new Map,this.__objects=[]}_copyFrom(n){this._tags=z_(n._tags),this.__combinedTagString=n.__combinedTagString}};h(kt,"RnObject"),f(kt,"InvalidObjectUID",-1),f(kt,"currentMaxObjectCount",0),f(kt,"__uniqueNames",[]),f(kt,"__objectsByNameMap",new Map),f(kt,"__objects",[]);nt=kt});var Mt,De,dn=C(()=>{"use strict";jo();Cn();St();tt();zn();ir();yr();Mt=class Mt extends nt{constructor(t,o,r,i){super();f(this,"_component_sid");f(this,"_isAlive",!0);f(this,"__currentProcessStage",Ne.Load);f(this,"__byteOffsetOfThisComponent",-1);f(this,"__entityUid");f(this,"__memoryManager");f(this,"__entityRepository");f(this,"__maxComponentNumber",F.maxEntityNumber);this.__entityUid=t,this._component_sid=o;let a=Mt._processStages;this.__memoryManager=we.getInstance(),this.__entityRepository=r}moveStageTo(t){this.__currentProcessStage=t}_setMaxNumberOfComponent(t){this.__maxComponentNumber=t}get maxNumberOfComponent(){return this.__maxComponentNumber}static get componentTID(){return 0}get componentTID(){return 0}get componentSID(){return this._component_sid}get entityUID(){return this.__entityUid}get currentProcessStage(){return this.__currentProcessStage}static doesTheProcessStageMethodExist(t,o){return t.prototype[o.methodName]!=null}isExistProcessStageMethod(t){return this[t.methodName]!=null}static process(t,o){if(!Mt.doesTheProcessStageMethodExist(t,o))return;let r=o.methodName,i=J.getComponentsWithType(t);for(let a of i)o===a.__currentProcessStage&&a[r]()}static updateComponentsForRenderStage(t,o,r){let i=t.sort_$render;return i(r)}static getByteLengthSumOfMembers(t,o){return this.__byteLengthSumOfMembers.get(o).get(t)}registerDependency(t,o){}takeOne(t,o,r,i,a){if(!this["_"+t].isDummy())return;let s;i?s=Mt.__accessors.get(this.constructor).get(t)._takeExistedOne(a):s=Mt.__accessors.get(this.constructor).get(t).takeOne(),this["_"+t]=new o(s,!1,!0);for(let l=0;l<this["_"+t]._v.length;++l)this["_"+t]._v[l]=r[l];return null}static getAccessor(t,o){return this.__accessors.get(o).get(t)}static takeAccessor(t,o,r,i,a,s){this.__accessors.has(r)||this.__accessors.set(r,new Map);let l=this.__accessors.get(r);if(l.has(o))return new Ue({message:"Already taken",error:void 0});{let c=i.getNumberOfComponents()*a.getSizeInBytes(),_=we.getInstance().createOrGetBuffer(t).takeBufferView({byteLengthToNeed:c*s,byteStride:0});if(_.isErr())return new Ue({message:"Failed to take buffer view: "+_.getRnError().message,error:void 0});let d=_.get().takeAccessor({compositionType:i,componentType:a,count:s,byteStride:c});return d.isErr()?new Ue({message:"Failed to take accessor: "+d.getRnError().message,error:void 0}):(l.set(o,d.get()),d)}}static getByteOffsetOfThisComponentTypeInBuffer(t,o){return this.__bufferViews.get(o).get(t).byteOffsetInBuffer}static getByteOffsetOfFirstOfThisMemberInBuffer(t,o){return this.__accessors.get(o).get(t).byteOffsetInBuffer}static getByteOffsetOfFirstOfThisMemberInBufferView(t,o){return this.__accessors.get(o).get(t).byteOffsetInBufferView}registerMember(t,o,r,i,a){Mt.__memberInfo.has(this.constructor)||Mt.__memberInfo.set(this.constructor,[]),Mt.__memberInfo.get(this.constructor).push({bufferUse:t,memberName:o,dataClassType:r,compositionType:r.compositionType,componentType:i,initValues:a})}submitToAllocation(t,o){if(this._component_sid>=t){let l=this.constructor;console.error(`%c${l.name}: The number of components is over the limit. This may lead to incorrect processing results. Please consider to increase the limit. You can set the limit on Rn.Config.xxxxxx.`,"color: red; background: yellow; font-size: 2em;")}let r=this.constructor,i=Mt.__memberInfo.get(r);this._component_sid===0&&s(this);let a=Mt.__members.get(r);for(let l of a.keys())a.get(l).forEach(u=>{this.takeOne(u.memberName,u.dataClassType,u.initValues,o,this._component_sid)});return;function s(l){Mt.__members.has(r)||Mt.__members.set(r,new Map);let c=Mt.__members.get(r);i.forEach(u=>{c.set(u.bufferUse,[])}),i.forEach(u=>{c.get(u.bufferUse).push(u)});for(let u of c.keys()){let _=c.get(u);Mt.__byteLengthSumOfMembers.has(r)||Mt.__byteLengthSumOfMembers.set(r,new Map);let d=Mt.__byteLengthSumOfMembers.get(r);d.has(u)||d.set(u,0),_.forEach(p=>{d.set(u,d.get(u)+p.compositionType.getNumberOfComponents()*p.componentType.getSizeInBytes())}),_.length>0}for(let u of c.keys())c.get(u).forEach(d=>{let p=Mt.takeAccessor(d.bufferUse,d.memberName,r,d.compositionType,d.componentType,t);if(p.isErr())throw new rr(p.getRnError());l["_byteOffsetOfAccessorInBuffer_"+d.memberName]=p.get().byteOffsetInBuffer,l["_byteOffsetOfAccessorInComponent_"+d.memberName]=p.get().byteOffsetInBufferView})}}get entity(){return this.__entityRepository.getEntity(this.__entityUid)}static getDataByteInfoInner(t,o){let i=t["_"+o]._v,a=i.byteOffset,s=i.byteLength,l=i.length,c=a/4/4,u=this["_byteOffsetOfAccessorInComponent_"+o]+t.componentSID*l*4,_=this["_byteOffsetOfAccessorInComponent_"+o]+t.componentSID*l,d=t.__byteOffsetOfThisComponent,p=t.__byteOffsetOfThisComponent/4/4;return{byteLength:s,byteOffsetInBuffer:a,byteOffsetInThisComponent:u,locationOffsetInBuffer:c,locationOffsetInThisComponent:_,thisComponentByteOffsetInBuffer:d,thisComponentLocationOffsetInBuffer:p,componentNumber:l}}getDataByteInfo(t){return Mt.getDataByteInfoInner(this,t)}static getDataByteInfoByComponentSID(t,o,r){let i=J.getComponent(t,o);if(i)return Mt.getDataByteInfoInner(i,r)}static getLocationOffsetOfMemberOfComponent(t,o){return J.getComponent(t,0)["_byteOffsetOfAccessorInBuffer_"+o]/4/4}addThisComponentToEntity(t,o){throw"Invalid Calling"}static getCompositionTypeOfMember(t,o){let i=this.__memberInfo.get(o).find(a=>a.memberName===t);if(i!=null)return i.compositionType}static getComponentTypeOfMember(t,o){let i=this.__memberInfo.get(o).find(a=>a.memberName===t);if(i!=null)return i.componentType}_destroy(){this._isAlive=!1}_shallowCopyFrom(t){}};h(Mt,"Component"),f(Mt,"__bufferViews",new Map),f(Mt,"__accessors",new Map),f(Mt,"__byteLengthSumOfMembers",new Map),f(Mt,"__memberInfo",new Map),f(Mt,"__members",new Map),f(Mt,"_processStages",[Ne.Load,Ne.Logic,Ne.Render]);De=Mt});var Ql,_s,fd=C(()=>{"use strict";zn();ge();it();Ql=class Ql extends nt{constructor(t,o,r){super();f(this,"___entity_uid");f(this,"__components");f(this,"_myLatestCopyEntityUID",Ql.invalidEntityUID);f(this,"_isAlive");this.___entity_uid=t,this._isAlive=o,this.__components=A.exist(r)?r:new Map}get entityUID(){return this.___entity_uid}_setComponent(t,o){this.__components.set(t.componentTID,o)}hasComponent(t){return this.__components.has(t.componentTID)}getComponent(t){return this.__components.get(t.componentTID)}getComponentByComponentTID(t){return this.__components.get(t)}_removeComponent(t){this.__components.delete(t)}tryToGetAnimation(){return this.getComponentByComponentTID(Q.AnimationComponentTID)}tryToGetAnimationState(){return this.getComponentByComponentTID(Q.AnimationStateComponentTID)}tryToGetBlendShape(){return this.getComponentByComponentTID(Q.BlendShapeComponentTID)}tryToGetCamera(){return this.getComponentByComponentTID(Q.CameraComponentTID)}tryToGetCameraController(){return this.getComponentByComponentTID(Q.CameraControllerComponentTID)}tryToGetLight(){return this.getComponentByComponentTID(Q.LightComponentTID)}tryToGetMesh(){return this.getComponentByComponentTID(Q.MeshComponentTID)}tryToGetMeshRenderer(){return this.getComponentByComponentTID(Q.MeshRendererComponentTID)}tryToGetPhysics(){return this.getComponentByComponentTID(Q.PhysicsComponentTID)}tryToGetSceneGraph(){return this.getComponentByComponentTID(Q.SceneGraphComponentTID)}tryToGetSkeletal(){return this.getComponentByComponentTID(Q.SkeletalComponentTID)}tryToGetTransform(){return this.getComponentByComponentTID(Q.TransformComponentTID)}tryToGetVrm(){return this.getComponentByComponentTID(Q.VrmComponentTID)}tryToGetConstraint(){return this.getComponentByComponentTID(Q.ConstraintComponentTID)}tryToGetEffekseer(){return this.getComponentByComponentTID(Q.EffekseerComponentTID)}_destroy(){this.__components.forEach(t=>{t._destroy()}),this._isAlive=!1}};h(Ql,"Entity"),f(Ql,"invalidEntityUID",-1);_s=Ql});function vt(m,n){Object.getOwnPropertyNames(n.prototype).forEach(t=>{Object.defineProperty(m,t,Object.getOwnPropertyDescriptor(n.prototype,t)||Object.create(null))})}function pN(){return ne.createEntity()}var Yn,ne,at=C(()=>{"use strict";fd();St();Vn();ge();it();yr();Yn=class Yn{constructor(){}static createEntity(){let n=-1;for(let r=0;r<this.__entities.length;r++)this.__entities[r]==null&&(n=r);let t=-1;n===-1?t=++this.__entity_uid_count:t=n;let o=new _s(t,!0);return this.__entities[t]=o,this.__updateCount++,o}static deleteEntity(n){var t;if(!A.not.exist(this._components[n])){for(let[o,r]of this._components[n]){if(o===Q.SceneGraphComponentTID){let a=r.children.concat();for(let s of a)Yn.deleteEntity(s.entity.entityUID)}J.deleteComponent(r)}(t=this.__entities[n])==null||t._destroy(),delete this.__entities[n],delete this._components[n],this.__updateCount++}}static deleteEntityRecursively(n){let t=this.getEntity(n),o=[],r=t.tryToGetSceneGraph();r!=null&&(o.push(r.entity),i(r));function i(a){let s=a.children;for(let l=0;l<s.length;l++){let c=s[l];o.push(c.entity),i(c)}}h(i,"addChild");for(let a of o)Yn.deleteEntity(a.entityUID)}static shallowCopyEntity(n){let t=Yn._shallowCopyEntityInner(n);return this.__setJoints(n),this.__handleTagData(t),t}static __setJoints(n){let o=Yn.getEntity(n._myLatestCopyEntityUID).getComponentByComponentTID(Q.SkeletalComponentTID),r=n.getComponentByComponentTID(Q.SkeletalComponentTID);if(A.exist(o)&&A.exist(r)){let s=r.getJoints().map(l=>Yn.getEntity(l.entity._myLatestCopyEntityUID).tryToGetSceneGraph());o.setJoints(s)}let i=n.tryToGetSceneGraph();A.exist(i)&&i.children.forEach(a=>{Yn.__setJoints(a.entity)})}static _shallowCopyEntityInner(n){let t=this.createEntity();t._tags=Object.assign({},n._tags),n._myLatestCopyEntityUID=t.entityUID;for(let o=1;o<=Q.maxWellKnownTidNumber;o++){let r=n.getComponentByComponentTID(o);if(A.exist(r)){this.tryToAddComponentToEntityByTID(o,t);let i=t.getComponentByComponentTID(o);A.exist(i)&&i._shallowCopyFrom(r)}}return t}static __handleTagData(n){let t=n._tags;if(A.exist(t)){let r=Object.keys(t);for(let i of r){if(i==="rnEntities"){let s=n.getTagValue("rnEntities").map(l=>Yn.getEntity(l._myLatestCopyEntityUID));n.tryToSetTag({tag:"rnEntities",value:s})}if(i==="rnEntitiesByNames"){let a=n.getTagValue("rnEntitiesByNames");for(let s of Object.keys(a)){let l=a.get(s);a.set(s,Yn.getEntity(l._myLatestCopyEntityUID))}n.tryToSetTag({tag:"rnEntitiesByNames",value:a})}}}let o=n.tryToGetSceneGraph();A.exist(o)&&o.children.forEach(r=>{Yn.__handleTagData(r.entity)})}static tryToAddComponentToEntityByTID(n,t){let o=J.getComponentClass(n);return A.not.exist(o)?t:this.addComponentToEntity(o,t)}static addComponentToEntity(n,t){if(t.hasComponent(n))return N.info("This entity already has the Component."),t;let o=J.createComponent(n.componentTID,t.entityUID,this);V_({value:this._components[t.entityUID],compensation:h(()=>this._components[t.entityUID]=new Map,"compensation")}).set(n.componentTID,o);let i=o.addThisComponentToEntity(t,n);return t._setComponent(n,o),this.__updateCount++,t}static removeComponentFromEntity(n,t){let o=this._components[t.entityUID];o==null&&(o=new Map,this._components[t.entityUID]=o);let r=o.get(n.componentTID);return A.exist(r)&&(r._destroy(),o.delete(n.componentTID),t._removeComponent(n.componentTID)),this.__updateCount++,t}static getEntity(n){return this.__entities[n]}getEntity(n){return Yn.__entities[n]}static getComponentOfEntity(n,t){let o=this._components[n],r=null;return o!=null?(r=o.get(t.componentTID),r!=null?r:null):r}static searchByTags(n){let t=[];for(let o of this.__entities)o!=null&&o.matchTags(n)&&t.push(o);return t}static getEntityByUniqueName(n){for(let t of this.__entities)if(t!=null&&t.uniqueName===n)return t}static _getEntities(){return this.__entities.filter(n=>n!=null&&n._isAlive)}static getEntitiesNumber(){return this.__entities.filter(t=>t!=null&&t._isAlive).length}static get updateCount(){return this.__updateCount}};h(Yn,"EntityRepository"),f(Yn,"__entity_uid_count",_s.invalidEntityUID),f(Yn,"__entities",[]),f(Yn,"_components",[]),f(Yn,"__updateCount",0);ne=Yn;h(vt,"applyMixins");h(pN,"createEntity")});function xN(m){return de({typeList:ag,index:m})}function vN(m){return Te({typeList:ag,str:m})}var ds,Lr,K0,Z0,J0,$0,eg,tg,ng,og,rg,ig,ag,mt,Vr=C(()=>{"use strict";st();Lr=(ds=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(ds,"AnimationAttributeClass"),ds),K0=new Lr({index:0,str:"Quaternion"}),Z0=new Lr({index:1,str:"Translate"}),J0=new Lr({index:2,str:"Scale"}),$0=new Lr({index:3,str:"Weights"}),eg=new Lr({index:4,str:"Effekseer"}),tg=new Lr({index:5,str:"Vector4"}),ng=new Lr({index:6,str:"Vector3"}),og=new Lr({index:7,str:"Vector2"}),rg=new Lr({index:8,str:"Scalar"}),ig=new Lr({index:9,str:"VectorN"}),ag=[K0,Z0,J0,$0,eg,tg,ng,og,rg,ig];h(xN,"from");h(vN,"fromString");mt=Object.freeze({Quaternion:K0,Translate:Z0,Scale:J0,Weights:$0,Effekseer:eg,Vector4:tg,Vector3:ng,Vector2:og,Scalar:rg,VectorN:ig,from:xN,fromString:vN})});var ud,Xl,md=C(()=>{"use strict";ge();Vn();ud=class ud{constructor(){f(this,"__subscriberMap",new Map)}subscribe(n,t){let o=this.__subscriberMap.get(n);return A.not.exist(o)&&(this.__subscriberMap.set(n,[]),o=this.__subscriberMap.get(n)),o.push(t)-1}unsubscribe(n,t){let o=this.__subscriberMap.get(n);o!=null&&o.splice(t,1)}unsubscribeAll(n){this.__subscriberMap.delete(n)}publishAsync(n,t){let o=0,r=Tu(this.__subscriberMap.get(n));for(let i of r)setTimeout(i.bind(this,t),0),o++;return o}publishSync(n,t){let o=0,r=Tu(this.__subscriberMap.get(n));for(let i of r)i(t),o++;return o}};h(ud,"EventPubSub");Xl=ud});function gN(m){return de({typeList:fg,index:m})}function yN(m){return Te({typeList:fg,str:m})}var hs,_d,sg,lg,cg,fg,Gn,Hl=C(()=>{"use strict";st();_d=(hs=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}get GltfString(){return this.str.toUpperCase()}},h(hs,"AnimationInterpolationClass"),hs),sg=new _d({index:0,str:"Linear"}),lg=new _d({index:1,str:"Step"}),cg=new _d({index:2,str:"CubicSpline"}),fg=[sg,lg,cg];h(gN,"from");h(yN,"fromString");Gn=Object.freeze({Linear:sg,Step:lg,CubicSpline:cg,from:gN,fromString:yN})});function bN(m,n,t,o,r){let i=new Array(m.length);for(let a=0;a<m.length;a++)i[a]=(2*r**3-3*r**2+1)*m[a]+(r**3-2*r**2+r)*t[a]+(-2*r**3+3*r**2)*n[a]+(r**3-r**2)*o[a];return i}function AN(m,n,t,o){let r=m;if(t===4){let i=r[Za](t*3*n+t),a=r[Za](t*3*(n+1)+t),s=r[Nl](t*3*n+t*2,o),l=r[Nl](t*3*(n+1),o);return{p_0:i,p_1:a,m_0:s,m_1:l}}else if(t===3){let i=r[Ka](t*3*n+t),a=r[Ka](t*3*(n+1)+t),s=r[Rl](t*3*n+t*2,o),l=r[Rl](t*3*(n+1),o);return{p_0:i,p_1:a,m_0:s,m_1:l}}else{let i=r[Ja](t*3*n+t,t),a=r[Ja](t*3*(n+1)+t,t),s=r[Pl](t*3*n+t*2,t,o),l=r[Pl](t*3*(n+1),t,o);return{p_0:i,p_1:a,m_0:s,m_1:l}}}function zu(m,n,t){let o=t;return n.interpolationMethod===Gn.CubicSpline?n.outputComponentN===4?o[Za](n.outputComponentN*3*m+n.outputComponentN):n.outputComponentN===3?o[Ka](n.outputComponentN*3*m+n.outputComponentN):n.outputComponentN===2?o[au](n.outputComponentN*3*m+n.outputComponentN):n.outputComponentN===1?o[ru](n.outputComponentN*3*m+n.outputComponentN):o[Ja](n.outputComponentN*3*m+n.outputComponentN,n.outputComponentN):n.outputComponentN===4?o[cu](m):n.outputComponentN===3?o[lu](m):n.outputComponentN===2?o[su](m):n.outputComponentN===1?o[iu](m):o[fu](m,n.outputComponentN)}function ug(m,n){let t=0,o=0,r=m.length-1,i=0;for(;o<=r&&n>=m[o]&&n<=m[r];)if(t=Math.floor(o+(n-m[o])*(r-o)/(m[r]-m[o])),m[t]<n)o=t+1,i=t;else if(n<m[t])r=t-1,i=r;else return t;return i}function IN(m,n,t,o,r){let i=m;if(t===mt.Quaternion.index)return i[mu](i,n,o,o+1);if(t===mt.Weights.index||t===mt.VectorN.index)return i[xu](i,r,n,o,o+1);if(t===mt.Translate.index||t===mt.Scale.index||t===mt.Vector3.index)return i[hu](i,n,o,o+1);if(t===mt.Vector2.index)return i[du](i,n,o,o+1);if(t===mt.Vector4.index)return i[pu](i,n,o,o+1);if(t===mt.Scalar.index)return i[_u](i,n,o,o+1);throw new Error("non supported type")}function hn(m,n,t){var a;let o=m.input,r=m.output,i=(a=m.interpolationMethod)!=null?a:Gn.Linear;if(n<=o[0])return zu(0,m,r);if(o[o.length-1]<=n)return zu(o.length-1,m,r);if(i===Gn.CubicSpline){let s=ug(o,n),l=o[s+1]-o[s],c=(n-o[s])/l,{p_0:u,p_1:_,m_0:d,m_1:p}=AN(r,s,m.outputComponentN,l),x=bN(u,_,d,p,c);return t===mt.Quaternion.index&&x[vu](),x}else if(i===Gn.Linear){let s=ug(o,n),l=(n-o[s])/(o[s+1]-o[s]);return IN(r,l,t,s,m.outputComponentN)}else if(i===Gn.Step){for(let l=0;l<o.length-1;l++)if(o[l]<=n&&n<o[l+1])return zu(l,m,r);return zu(o.length-1,m,r)}return[]}var yi=C(()=>{"use strict";Vr();Hl();gu();h(bN,"cubicSpline");h(AN,"__prepareVariablesForCubicSpline");h(zu,"__getOutputValue");h(ug,"interpolationSearch");h(IN,"__lerp");h(hn,"__interpolate")});function SN(m){return de({typeList:hd,index:m})}function TN(m){return Te({typeList:hd,str:m})}function EN(m){return Te({typeList:hd,str:m})}var ps,dd,mg,_g,dg,hd,Tt,ni=C(()=>{"use strict";st();dd=(ps=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}toGltfString(){return this.str}},h(ps,"AlphaModeClass"),ps),mg=new dd({index:0,str:"OPAQUE"}),_g=new dd({index:1,str:"MASK"}),dg=new dd({index:2,str:"BLEND"}),hd=[mg,_g,dg];h(SN,"from");h(TN,"fromString");h(EN,"fromGlTFString");Tt=Object.freeze({Opaque:mg,Mask:_g,Blend:dg,from:SN,fromString:TN,fromGlTFString:EN})});function CN(m){return de({typeList:Mg,index:m})}function wN(m){return Te({typeList:Mg,str:m})}var xs,Kn,hg,pg,xg,vg,gg,yg,bg,Ag,Ig,Sg,Tg,Eg,Cg,wg,Rg,Ng,Pg,Mg,On,Gu=C(()=>{"use strict";st();Kn=(xs=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(xs,"BasisCompressionTypeClass"),xs),hg=new Kn({index:0,str:"ETC1"}),pg=new Kn({index:1,str:"ETC2"}),xg=new Kn({index:2,str:"BC1"}),vg=new Kn({index:3,str:"BC3"}),gg=new Kn({index:4,str:"BC4"}),yg=new Kn({index:5,str:"BC5"}),bg=new Kn({index:6,str:"BC7_M6_OPAQUE"}),Ag=new Kn({index:7,str:"BC7_M5"}),Ig=new Kn({index:8,str:"PVRTC1_RGB"}),Sg=new Kn({index:9,str:"PVRTC1_RGBA"}),Tg=new Kn({index:10,str:"ASTC"}),Eg=new Kn({index:11,str:"ATC_RGB"}),Cg=new Kn({index:12,str:"ATC_RGBA"}),wg=new Kn({index:13,str:"RGBA32"}),Rg=new Kn({index:14,str:"RGB565"}),Ng=new Kn({index:15,str:"BGR565"}),Pg=new Kn({index:16,str:"RGBA4444"}),Mg=[hg,pg,xg,vg,gg,yg,Ag,bg,Ig,Sg,Tg,Eg,Cg,wg,Rg,Ng,Pg];h(CN,"from");h(wN,"fromString");On=Object.freeze({ETC1:hg,ETC2:pg,BC1:xg,BC3:vg,BC4:gg,BC5:yg,BC7_M5:Ag,BC7_M6_OPAQUE:bg,PVRTC1_RGB:Ig,PVRTC1_RGBA:Sg,ASTC:Tg,ATC_RGB:Eg,ATC_RGBA:Cg,RGBA32:wg,RGB565:Rg,BGR565:Ng,RGBA4444:Pg,from:CN,fromString:wN})});function RN(m){return de({typeList:Lg,index:m})}function NN(m){return Te({typeList:Lg,str:m})}var vs,Dg,Bg,Fg,Lg,gs,pd=C(()=>{"use strict";st();Dg=(vs=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(vs,"CameraControllerTypeClass"),vs),Bg=new Dg({index:0,str:"Orbit"}),Fg=new Dg({index:1,str:"WalkThrough"}),Lg=[Bg,Fg];h(RN,"from");h(NN,"fromString");gs=Object.freeze({Orbit:Bg,WalkThrough:Fg,from:RN,fromString:NN})});function PN(m){return de({typeList:Og,index:m})}function MN(m){return Te({typeList:Og,str:m})}var ys,xd,Vg,zg,Gg,Og,wn,ql=C(()=>{"use strict";st();xd=(ys=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(ys,"CameraTypeClass"),ys),Vg=new xd({index:0,str:"Perspective"}),zg=new xd({index:1,str:"Orthographic"}),Gg=new xd({index:2,str:"Frustum"}),Og=[Vg,zg,Gg];h(PN,"from");h(MN,"fromString");wn=Object.freeze({Perspective:Vg,Orthographic:zg,Frustum:Gg,from:PN,fromString:MN})});function DN(m){return de({typeList:Ey,index:m})}function BN(m){return Te({typeList:Ey,str:m})}var bs,Qe,Ug,kg,Wg,Qg,Xg,Hg,qg,jg,Yg,Kg,Zg,Jg,$g,ey,ty,ny,oy,ry,iy,ay,sy,ly,cy,fy,uy,my,_y,dy,hy,py,xy,vy,gy,yy,by,Ay,Iy,Sy,Ty,Ey,Un,vd=C(()=>{"use strict";st();Qe=(bs=class extends fe{constructor({index:t,str:o,webgpu:r,blockInfo:i}){super({index:t,str:o});f(this,"__webgpu");f(this,"__blockInfo");this.__webgpu=r,this.__blockInfo=i}get webgpu(){if(this.__webgpu===void 0)throw new Error(`does not support ${this.str}`);return this.__webgpu}get blockInfo(){if(this.__blockInfo===void 0)throw new Error(`does not support ${this.str}`);return this.__blockInfo}},h(bs,"CompressionTextureTypeClass"),bs),Ug=new Qe({index:37808,str:"COMPRESSED_RGBA_ASTC_4x4_KHR",webgpu:"astc-4x4-unorm",blockInfo:{byteSize:16,width:4,height:4}}),kg=new Qe({index:37809,str:"COMPRESSED_RGBA_ASTC_5x4_KHR",webgpu:"astc-5x4-unorm"}),Wg=new Qe({index:37810,str:"COMPRESSED_RGBA_ASTC_5x5_KHR",webgpu:"astc-5x5-unorm"}),Qg=new Qe({index:37811,str:"COMPRESSED_RGBA_ASTC_6x5_KHR",webgpu:"astc-6x5-unorm"}),Xg=new Qe({index:37812,str:"COMPRESSED_RGBA_ASTC_6x6_KHR",webgpu:"astc-6x6-unorm"}),Hg=new Qe({index:37813,str:"COMPRESSED_RGBA_ASTC_8x5_KHR",webgpu:"astc-8x5-unorm"}),qg=new Qe({index:37814,str:"COMPRESSED_RGBA_ASTC_8x6_KHR",webgpu:"astc-8x6-unorm"}),jg=new Qe({index:37815,str:"COMPRESSED_RGBA_ASTC_8x8_KHR",webgpu:"astc-8x8-unorm"}),Yg=new Qe({index:37816,str:"COMPRESSED_RGBA_ASTC_10x5_KHR",webgpu:"astc-10x5-unorm"}),Kg=new Qe({index:37817,str:"COMPRESSED_RGBA_ASTC_10x6_KHR",webgpu:"astc-10x6-unorm"}),Zg=new Qe({index:37818,str:"COMPRESSED_RGBA_ASTC_10x8_KHR",webgpu:"astc-10x8-unorm"}),Jg=new Qe({index:37819,str:"COMPRESSED_RGBA_ASTC_10x10_KHR",webgpu:"astc-10x10-unorm"}),$g=new Qe({index:37820,str:"COMPRESSED_RGBA_ASTC_12x10_KHR",webgpu:"astc-12x10-unorm"}),ey=new Qe({index:37821,str:"COMPRESSED_RGBA_ASTC_12x12_KHR",webgpu:"astc-12x12-unorm"}),ty=new Qe({index:37840,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR",webgpu:"astc-4x4-unorm-srgb",blockInfo:{byteSize:16,width:4,height:4}}),ny=new Qe({index:37841,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR",webgpu:"astc-5x4-unorm-srgb"}),oy=new Qe({index:37842,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR",webgpu:"astc-5x5-unorm-srgb"}),ry=new Qe({index:37843,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR",webgpu:"astc-6x5-unorm-srgb"}),iy=new Qe({index:37844,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR",webgpu:"astc-6x6-unorm-srgb"}),ay=new Qe({index:37845,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR",webgpu:"astc-8x5-unorm-srgb"}),sy=new Qe({index:37846,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR",webgpu:"astc-8x6-unorm-srgb"}),ly=new Qe({index:37847,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR",webgpu:"astc-8x8-unorm-srgb"}),cy=new Qe({index:37848,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR",webgpu:"astc-10x5-unorm-srgb"}),fy=new Qe({index:37849,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR",webgpu:"astc-10x6-unorm-srgb"}),uy=new Qe({index:37850,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR",webgpu:"astc-10x8-unorm-srgb"}),my=new Qe({index:37851,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR",webgpu:"astc-10x10-unorm-srgb"}),_y=new Qe({index:37852,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR",webgpu:"astc-12x10-unorm-srgb"}),dy=new Qe({index:37853,str:"COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR",webgpu:"astc-12x12-unorm-srgb"}),hy=new Qe({index:33776,str:"COMPRESSED_RGB_S3TC_DXT1_EXT",webgpu:"bc1-rgba-unorm",blockInfo:{byteSize:8,width:4,height:4}}),py=new Qe({index:33777,str:"COMPRESSED_RGBA_S3TC_DXT1_EXT",webgpu:"bc1-rgba-unorm",blockInfo:{byteSize:8,width:4,height:4}}),xy=new Qe({index:33778,str:"COMPRESSED_RGBA_S3TC_DXT3_EXT",webgpu:"bc2-rgba-unorm",blockInfo:{byteSize:16,width:4,height:4}}),vy=new Qe({index:33779,str:"COMPRESSED_RGBA_S3TC_DXT5_EXT",webgpu:"bc3-rgba-unorm",blockInfo:{byteSize:16,width:4,height:4}}),gy=new Qe({index:36492,str:"COMPRESSED_RGBA_BPTC_UNORM_EXT",webgpu:"bc7-rgba-unorm",blockInfo:{byteSize:16,width:4,height:4}}),yy=new Qe({index:35842,str:"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",blockInfo:{byteSize:8,width:4,height:4}}),by=new Qe({index:35840,str:"COMPRESSED_RGB_PVRTC_4BPPV1_IMG",blockInfo:{byteSize:8,width:4,height:4}}),Ay=new Qe({index:37496,str:"COMPRESSED_RGBA8_ETC2_EAC",webgpu:"etc2-rgba8unorm",blockInfo:{byteSize:16,width:4,height:4}}),Iy=new Qe({index:37492,str:"COMPRESSED_RGB8_ETC2",webgpu:"etc2-rgb8unorm",blockInfo:{byteSize:16,width:4,height:4}}),Sy=new Qe({index:36196,str:"COMPRESSED_RGB_ETC1_WEBGL"}),Ty=new Qe({index:32856,str:"RGBA8_EXT",blockInfo:{byteSize:4,width:1,height:1}}),Ey=[Ug,kg,Wg,Qg,Xg,Hg,qg,jg,Yg,Kg,Zg,Jg,$g,ey,ty,ny,oy,ry,iy,ay,sy,ly,cy,fy,uy,my,_y,dy,hy,py,xy,vy,gy,yy,by,Ay,Iy,Sy,Ty];h(DN,"from");h(BN,"fromString");Un=Object.freeze({ASTC_RGBA_4x4:Ug,ASTC_RGBA_5x4:kg,ASTC_RGBA_5x5:Wg,ASTC_RGBA_6x5:Qg,ASTC_RGBA_6x6:Xg,ASTC_RGBA_8x5:Hg,ASTC_RGBA_8x6:qg,ASTC_RGBA_8x8:jg,ASTC_RGBA_10x5:Yg,ASTC_RGBA_10x6:Kg,ASTC_RGBA_10x8:Zg,ASTC_RGBA_10x10:Jg,ASTC_RGBA_12x10:$g,ASTC_RGBA_12x12:ey,ASTC_SRGB_4x4:ty,ASTC_SRGB_5x4:ny,ASTC_SRGB_5x5:oy,ASTC_SRGB_6x5:ry,ASTC_SRGB_6x6:iy,ASTC_SRGB_8x5:ay,ASTC_SRGB_8x6:sy,ASTC_SRGB_8x8:ly,ASTC_SRGB_10x5:cy,ASTC_SRGB_10x6:fy,ASTC_SRGB_10x8:uy,ASTC_SRGB_10x10:my,ASTC_SRGB_12x10:_y,ASTC_SRGB_12x12:dy,S3TC_RGB_DXT1:hy,S3TC_RGBA_DXT1:py,S3TC_RGBA_DXT3:xy,S3TC_RGBA_DXT5:vy,BPTC_RGBA:gy,PVRTC_RGBA_4BPPV1:yy,PVRTC_RGB_4BPPV1:by,ETC2_RGBA8_EAC:Ay,ETC2_RGB8:Iy,ETC1_RGB:Sy,RGBA8_EXT:Ty,from:DN,fromString:BN})});function FN(m){return de({typeList:Ny,index:m})}function LN(m){let n=Te({typeList:Ny,str:m});return n!=null?n:gd}function VN(m){return m===yd||m===bd}var As,Is,gd,yd,bd,Cy,wy,Ry,Ny,Yo,Ou=C(()=>{"use strict";st();Is=(As=class extends fe{constructor({index:t,str:o,ext:r,brand:i}){super({index:t,str:o});f(this,"extension");f(this,"brand");this.extension=r,this.brand=i}},h(As,"FileTypeClass"),As),gd=new Is({index:-1,str:"unknown",ext:"unknown",brand:"UnKnown"}),yd=new Is({index:0,str:"gltf",ext:"gltf",brand:"glTF"}),bd=new Is({index:1,str:"glb",ext:"glb",brand:"glTF"}),Cy=new Is({index:2,str:"vrm",ext:"vrm",brand:"VRM"}),wy=new Is({index:3,str:"drc",ext:"drc",brand:"Draco"}),Ry=new Is({index:4,str:"efk",ext:"efk",brand:"EffekseerEffect"}),Ny=[gd,yd,bd,Cy,wy,Ry];h(FN,"from");h(LN,"fromString");h(VN,"isGltfOrGlb");Yo=Object.freeze({Unknown:gd,Gltf:yd,GltfBinary:bd,VRM:Cy,Draco:wy,EffekseerEffect:Ry,from:FN,fromString:LN,isGltfOrGlb:VN})});function zN(m){return de({typeList:Vy,index:m})}function GN(m){return Te({typeList:Vy,str:m})}var Ss,Ts,Py,My,Dy,By,Fy,Ly,Vy,wt,bi=C(()=>{"use strict";st();Ts=(Ss=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(Ss,"HdriFormatClass"),Ss),Py=new Ts({index:0,str:".ldr_srgb"}),My=new Ts({index:1,str:".ldr_linear"}),Dy=new Ts({index:2,str:".hdr"}),By=new Ts({index:3,str:".rgbe.png"}),Fy=new Ts({index:4,str:".rgb9_e5.png"}),Ly=new Ts({index:5,str:".exr"}),Vy=[Py,My,Dy,By,Fy,Ly];h(zN,"from");h(GN,"fromString");wt=Object.freeze({LDR_SRGB:Py,LDR_LINEAR:My,HDR_LINEAR:Dy,RGBE_PNG:By,RGB9_E5_PNG:Fy,OpenEXR:Ly,from:zN,fromString:GN})});function ON(m){return de({typeList:ky,index:m})}function UN(m){return Te({typeList:ky,str:m})}var Es,Uu,zy,Gy,Oy,Uy,ky,Fo,Cs=C(()=>{"use strict";st();Uu=(Es=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(Es,"LightTypeClass"),Es),zy=new Uu({index:0,str:"Directional"}),Gy=new Uu({index:1,str:"Point"}),Oy=new Uu({index:2,str:"Spot"}),Uy=new Uu({index:3,str:"Ambient"}),ky=[Gy,zy,Oy,Uy];h(ON,"from");h(UN,"fromString");Fo=Object.freeze({Point:Gy,Directional:zy,Spot:Oy,Ambient:Uy,from:ON,fromString:UN})});var Wy=C(()=>{"use strict"});var Qy=C(()=>{"use strict"});var Xy=C(()=>{"use strict"});var Hy=C(()=>{"use strict"});function kN(m){switch(m.className){case"Scalar":return b.Scalar;case"Vector2":return b.Vec2;case"Vector3":return b.Vec3;case"Vector4":return b.Vec4;case"Matrix22":return b.Mat2;case"Matrix33":return b.Mat3;case"Matrix44":return b.Mat4;default:return N.error("CompositionType.Unknown"),b.Unknown}}var qy=C(()=>{"use strict";se();me();h(kN,"fromTensorToCompositionType")});var jy=C(()=>{"use strict"});var Yy=C(()=>{"use strict"});var WN,QN,XN,HN,qN,jN,YN,KN,ZN,JN,ku,Ad,Id,Sd,Td,Ed,Cd,wd,Rd,Nd,Pd,$N,eP,tP,nP,oP,rP,iP,aP,sP,lP,cP,fP,uP,mP,_P,dP,hP,pP,xP,vP,gP,yP,bP,AP,IP,SP,TP,EP,CP,wP,RP,NP,PP,MP,DP,BP,FP,LP,VP,zP,GP,OP,UP,kP,WP,QP,XP,HP,qP,jP,YP,KP,ZP,JP,$P,eM,tM,nM,oM,rM,iM,aM,sM,lM,cM,fM,uM,mM,_M,dM,hM,pM,xM,Wu,Md,vM,gM,yM,bM,AM,IM,SM,TM,EM,CM,wM,RM,NM,PM,MM,DM,BM,FM,LM,VM,zM,GM,OM,UM,kM,WM,QM,XM,HM,qM,jM,YM,KM,ZM,JM,$M,eD,tD,nD,oD,rD,iD,aD,sD,lD,cD,fD,uD,mD,_D,dD,hD,pD,xD,vD,gD,yD,bD,AD,ID,SD,TD,ED,CD,wD,RD,ND,PD,MD,DD,BD,FD,LD,VD,zD,GD,OD,UD,kD,WD,QD,XD,HD,qD,jD,YD,KD,ZD,JD,$D,eB,tB,nB,oB,rB,aa,iB,aB,sB,lB,cB,fB,uB,mB,_B,dB,hB,pB,xB,vB,gB,yB,bB,AB,IB,SB,TB,EB,CB,wB,RB,NB,PB,MB,DB,BB,FB,LB,VB,zB,GB,OB,UB,kB,WB,QB,XB,HB,qB,jB,YB,KB,ZB,JB,$B,eF,tF,nF,oF,rF,iF,aF,sF,lF,cF,fF,uF,mF,_F,dF,hF,pF,xF,vF,gF,yF,bF,AF,IF,SF,TF,EF,CF,wF,RF,NF,PF,MF,DF,BF,FF,LF,VF,zF,GF,OF,UF,kF,WF,QF,XF,HF,qF,jF,YF,KF,ZF,JF,$F,eL,tL,nL,oL,rL,iL,aL,sL,lL,cL,fL,uL,mL,_L,dL,hL,pL,xL,vL,gL,yL,bL,AL,IL,SL,TL,EL,CL,wL,RL,NL,PL,ML,DL,BL,FL,LL,VL,zL,GL,OL,UL,kL,WL,QL,XL,HL,qL,jL,YL,KL,ZL,JL,$L,eV,tV,nV,oV,rV,iV,aV,sV,lV,cV,fV,uV,mV,_V,dV,hV,pV,xV,vV,Dd,Bd,gV,yV,bV,AV,IV,SV,TV,EV,CV,wV,RV,NV,PV,MV,DV,BV,FV,LV,VV,zV,GV,OV,UV,kV,WV,Fd,QV,XV,HV,qV,jV,YV,KV,ZV,JV,$V,ez,tz,nz,oz,rz,iz,az,sz,lz,cz,fz,uz,mz,_z,dz,hz,pz,xz,vz,gz,yz,bz,Az,Iz,Sz,Tz,Ez,Cz,wz,Rz,Nz,Pz,Mz,Dz,Bz,Fz,Lz,Vz,zz,Gz,Oz,Uz,kz,Wz,Qz,Xz,Hz,qz,jz,Yz,Kz,Zz,Jz,$z,eG,tG,nG,oG,rG,iG,aG,sG,lG,cG,fG,uG,mG,_G,dG,hG,pG,xG,vG,gG,yG,bG,AG,IG,SG,TG,EG,CG,wG,RG,NG,PG,MG,DG,BG,FG,LG,VG,zG,GG,OG,UG,kG,WG,QG,XG,HG,qG,jG,YG,KG,ZG,JG,$G,eO,tO,nO,oO,rO,iO,aO,sO,lO,cO,fO,uO,mO,_O,dO,hO,pO,xO,vO,gO,yO,bO,AO,IO,SO,TO,EO,CO,wO,RO,NO,PO,MO,DO,BO,FO,LO,VO,zO,GO,OO,UO,kO,WO,QO,XO,HO,qO,jO,YO,KO,ZO,JO,$O,eU,tU,nU,oU,rU,iU,aU,sU,lU,cU,fU,uU,mU,_U,dU,hU,pU,xU,vU,gU,yU,bU,AU,IU,SU,TU,EU,CU,wU,RU,NU,PU,MU,DU,BU,FU,LU,VU,zU,GU,OU,UU,kU,WU,QU,XU,HU,qU,jU,YU,KU,ZU,JU,$U,e6,t6,n6,o6,r6,i6,a6,s6,l6,c6,f6,u6,m6,_6,d6,h6,p6,x6,v6,g6,y6,b6,A6,I6,S6,T6,E6,C6,w6,R6,N6,P6,M6,D6,B6,F6,L6,V6,z6,G6,O6,U6,k6,W6,Q6,X6,H6,q6,j6,Y6,K6,Z6,J6,Qu=C(()=>{"use strict";WN=256,QN=1024,XN=16384,HN=0,qN=1,jN=2,YN=3,KN=4,ZN=5,JN=6,ku=0,Ad=1,Id=768,Sd=769,Td=770,Ed=771,Cd=772,wd=773,Rd=774,Nd=775,Pd=776,$N=32769,eP=32770,tP=32771,nP=32772,oP=32774,rP=32778,iP=32779,aP=32777,sP=32777,lP=34877,cP=32968,fP=32969,uP=32970,mP=32971,_P=32773,dP=34964,hP=34965,pP=2849,xP=33901,vP=33902,gP=2885,yP=2886,bP=2928,AP=2930,IP=2931,SP=2932,TP=2961,EP=2962,CP=2964,wP=2965,RP=2966,NP=2967,PP=2963,MP=2968,DP=34816,BP=34817,FP=34818,LP=34819,VP=36003,zP=36004,GP=36005,OP=2978,UP=3088,kP=3106,WP=3107,QP=3317,XP=3333,HP=3379,qP=3386,jP=3408,YP=3410,KP=3411,ZP=3412,JP=3413,$P=3414,eM=3415,tM=10752,nM=32824,oM=32873,rM=32936,iM=32937,aM=32938,sM=32939,lM=34467,cM=7936,fM=7937,uM=7938,mM=35738,_M=35739,dM=37444,hM=35044,pM=35040,xM=35048,Wu=34962,Md=34963,vM=34660,gM=34661,yM=34342,bM=34338,AM=34339,IM=34340,SM=34341,TM=34922,EM=34373,CM=34975,wM=2884,RM=1028,NM=1029,PM=1032,MM=3042,DM=2929,BM=3024,FM=32823,LM=32926,VM=32928,zM=3089,GM=2960,OM=0,UM=1280,kM=1281,WM=1282,QM=1285,XM=37442,HM=2304,qM=2305,jM=4352,YM=4353,KM=4354,ZM=33170,JM=5120,$M=5121,eD=5122,tD=5123,nD=5124,oD=5125,rD=5126,iD=6402,aD=6406,sD=6407,lD=6408,cD=6409,fD=6410,uD=5121,mD=32819,_D=32820,dD=33635,hD=35632,pD=35633,xD=35713,vD=35712,gD=35714,yD=35715,bD=35717,AD=35721,ID=35718,SD=34921,TD=36347,ED=36348,CD=35661,wD=35660,RD=34930,ND=36349,PD=35663,MD=35724,DD=35725,BD=512,FD=519,LD=513,VD=514,zD=515,GD=516,OD=518,UD=517,kD=7680,WD=7681,QD=7682,XD=7683,HD=5386,qD=34055,jD=34056,YD=9728,KD=9729,ZD=9984,JD=9985,$D=9986,eB=9987,tB=10240,nB=10241,oB=10242,rB=10243,aa=3553,iB=5890,aB=34067,sB=34068,lB=34069,cB=34070,fB=34071,uB=34072,mB=34073,_B=34074,dB=34076,hB=33984,pB=33985,xB=33986,vB=33987,gB=33988,yB=33989,bB=33990,AB=33991,IB=33992,SB=33993,TB=33994,EB=33995,CB=33996,wB=33997,RB=33998,NB=33999,PB=34e3,MB=34001,DB=34002,BB=34003,FB=34004,LB=34005,VB=34006,zB=34007,GB=34008,OB=34009,UB=34010,kB=34011,WB=34012,QB=34013,XB=34014,HB=34015,qB=34016,jB=10497,YB=33071,KB=33648,ZB=35664,JB=35665,$B=35666,eF=35667,tF=35668,nF=35669,oF=35670,rF=35671,iF=35672,aF=35673,sF=35674,lF=35675,cF=35676,fF=35678,uF=35680,mF=36336,_F=36337,dF=36338,hF=36339,pF=36340,xF=36341,vF=36160,gF=36161,yF=32854,bF=32855,AF=36194,IF=33189,SF=6401,TF=36168,EF=34041,CF=36162,wF=36163,RF=36164,NF=36176,PF=36177,MF=36178,DF=36179,BF=36180,FF=36181,LF=36048,VF=36049,zF=36050,GF=36051,OF=36064,UF=36096,kF=36128,WF=33306,QF=0,XF=36053,HF=36054,qF=36055,jF=36057,YF=36061,KF=36006,ZF=36007,JF=34024,$F=1286,eL=37440,tL=37441,nL=37443,oL=3074,rL=3314,iL=3315,aL=3316,sL=3330,lL=3331,cL=3332,fL=32874,uL=32877,mL=32878,_L=32883,dL=33e3,hL=33001,pL=34045,xL=35657,vL=35658,gL=35071,yL=35076,bL=35077,AL=35659,IL=35723,SL=35977,TL=34229,EL=37154,CL=37157,wL=37137,RL=36203,NL=6403,PL=32849,ML=32856,DL=32857,BL=32879,FL=32882,LL=33082,VL=33083,zL=33084,GL=33085,OL=34892,UL=34893,kL=35904,WL=35905,QL=35907,XL=34894,HL=34836,qL=34837,jL=34842,YL=34843,KL=35866,ZL=35869,JL=35898,$L=35901,eV=36208,tV=36209,nV=36214,oV=36215,rV=36220,iV=36221,aV=36226,sV=36227,lV=36232,cV=36233,fV=36238,uV=36239,mV=36244,_V=36248,dV=36249,hV=33321,pV=33323,xV=33325,vV=33326,Dd=33327,Bd=33328,gV=33329,yV=33330,bV=33331,AV=33332,IV=33333,SV=33334,TV=33335,EV=33336,CV=33337,wV=33338,RV=33339,NV=33340,PV=36756,MV=36757,DV=36758,BV=36759,FV=36975,LV=37167,VV=33503,zV=33640,GV=35899,OV=35902,UV=36269,kV=34042,WV=5131,Fd=33319,QV=33320,XV=36255,HV=34917,qV=34918,jV=34919,YV=35887,KV=36202,ZV=34852,JV=34853,$V=34854,ez=34855,tz=34856,nz=34857,oz=34858,rz=34859,iz=34860,az=34861,sz=34862,lz=34863,cz=34864,fz=34865,uz=34866,mz=34867,_z=34868,dz=36063,hz=36065,pz=36066,xz=36067,vz=36068,gz=36069,yz=36070,bz=36071,Az=36072,Iz=36073,Sz=36074,Tz=36075,Ez=36076,Cz=36077,wz=36078,Rz=36079,Nz=35679,Pz=35682,Mz=36289,Dz=36292,Bz=36293,Fz=36298,Lz=36299,Vz=36300,zz=36303,Gz=36306,Oz=36307,Uz=36308,kz=36311,Wz=36183,Qz=35097,Xz=35051,Hz=35052,qz=35053,jz=35055,Yz=36662,Kz=36663,Zz=36662,Jz=36663,$z=35685,eG=35686,tG=35687,nG=35688,oG=35689,rG=35690,iG=36294,aG=36295,sG=36296,lG=35863,cG=36764,fG=35069,uG=35070,mG=35967,_G=35968,dG=35971,hG=35972,pG=35973,xG=35976,vG=35978,gG=35979,yG=35980,bG=35981,AG=35982,IG=35983,SG=36386,TG=36387,EG=36388,CG=36389,wG=33296,RG=33297,NG=33298,PG=33299,MG=33300,DG=33301,BG=33302,FG=33303,LG=33304,VG=35056,zG=36006,GG=36008,OG=36009,UG=36010,kG=36011,WG=36052,QG=36182,XG=35345,HG=35368,qG=35369,jG=35370,YG=35371,KG=35373,ZG=35374,JG=35375,$G=35376,eO=35377,tO=35379,nO=35380,oO=35382,rO=35383,iO=35384,aO=35386,sO=35387,lO=35388,cO=35389,fO=35390,uO=35391,mO=35392,_O=35394,dO=35395,hO=35396,pO=35398,xO=37138,vO=37139,gO=37140,yO=37141,bO=37142,AO=37143,IO=37144,SO=37145,TO=37146,EO=37147,CO=37148,wO=37149,RO=1,NO=6144,PO=6145,MO=6146,DO=32775,BO=32776,FO=33190,LO=35041,VO=35042,zO=35045,GO=35046,OO=35049,UO=35050,kO=36012,WO=36013,QO=4294967295,XO=-1,HO=37447,qO=35070,jO=37445,YO=37446,KO=34047,ZO=34046,JO=33776,$O=33777,eU=33778,tU=33779,nU=35916,oU=35917,rU=35918,iU=35919,aU=37488,sU=37489,lU=37490,cU=37491,fU=37492,uU=37493,mU=37494,_U=37495,dU=37496,hU=37497,pU=35840,xU=35842,vU=35841,gU=35843,yU=36196,bU=35986,AU=35986,IU=34798,SU=37808,TU=37809,EU=37810,CU=37811,wU=37812,RU=37813,NU=37814,PU=37815,MU=37816,DU=37817,BU=37818,FU=37819,LU=37820,VU=37821,zU=37840,GU=37841,OU=37842,UU=37843,kU=37844,WU=37845,QU=37846,XU=37847,HU=37848,qU=37849,jU=37850,YU=37851,KU=37852,ZU=37853,JU=34042,$U=36193,e6=34836,t6=34837,n6=33297,o6=35863,r6=32775,i6=32776,a6=35904,s6=35906,l6=35907,c6=33296,f6=35723,u6=36064,m6=36065,_6=36066,d6=36067,h6=36068,p6=36069,x6=36070,v6=36071,g6=36072,y6=36073,b6=36074,A6=36075,I6=36076,S6=36077,T6=36078,E6=36079,C6=34853,w6=34854,R6=34855,N6=34856,P6=34857,M6=34858,D6=34859,B6=34860,F6=34861,L6=34862,V6=34863,z6=34864,G6=34865,O6=34866,U6=34867,k6=34868,W6=36063,Q6=34852,X6=34229,H6=34916,q6=34917,j6=34918,Y6=34919,K6=35007,Z6=36392,J6=36795});var Ky=C(()=>{"use strict"});function Vd(m,n){return m.magFilter===n.magFilter&&m.minFilter===n.minFilter&&m.wrapS===n.wrapS&&m.wrapT===n.wrapT}var Ld,Xu=C(()=>{"use strict";Ld="gltf_node_index";h(Vd,"isSameGlTF2TextureSampler")});var Zy=C(()=>{"use strict"});var Jy=C(()=>{"use strict"});var $y=C(()=>{"use strict"});var eb=C(()=>{"use strict"});var jl=C(()=>{"use strict";Wy();Qy();Xy();Hy();qy();jy();Yy();Qu();Ky();Xu();Zy();Jy();$y();eb()});function $6(m){switch(m){case zd:return 1;case Gd:return 2;case Od:return 1;case Ud:return 2;case kd:return 3;case Wd:return 4;case Qd:return 1;case Xd:return 2;default:throw new Error(`Not supported ${m}`)}}function tk(m){return de({typeList:ek,index:m})}var ws,Ai,zd,Gd,Od,Ud,kd,Wd,Qd,Xd,ek,ue,Lo=C(()=>{"use strict";jl();st();Ai=(ws=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(ws,"PixelFormatClass"),ws),zd=new Ai({index:6402,str:"DEPTH_COMPONENT"}),Gd=new Ai({index:34041,str:"DEPTH_STENCIL"}),Od=new Ai({index:6406,str:"ALPHA"}),Ud=new Ai({index:33319,str:"RG"}),kd=new Ai({index:6407,str:"RGB"}),Wd=new Ai({index:6408,str:"RGBA"}),Qd=new Ai({index:6409,str:"LUMINANCE"}),Xd=new Ai({index:6410,str:"LUMINANCE_ALPHA"});h($6,"getCompositionNumFromPixelFormat");ek=[zd,Gd,Od,Ud,kd,Wd,Qd,Xd];h(tk,"from");ue=Object.freeze({DepthComponent:zd,DepthStencil:Gd,Alpha:Od,RG:Ud,RGB:kd,RGBA:Wd,Luminance:Qd,LuminanceAlpha:Xd,from:tk,getCompositionNumFromPixelFormat:$6})});function ok(m){return de({typeList:nk,index:m})}var Rs,Ii,tb,nb,ob,rb,ib,ab,sb,lb,nk,Re,Nn=C(()=>{"use strict";st();Ii=(Rs=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}getWebGPUTypeStr(){switch(this.index){case 0:return"point-list";case 1:return"line-list";case 2:throw new Error("Not Supported in WebGPU");case 3:return"line-strip";case 4:return"triangle-list";case 5:return"triangle-strip";case 6:throw new Error("Not Supported in WebGPU");default:throw new Error("Not Supported in WebGPU")}}},h(Rs,"PrimitiveModeClass"),Rs),tb=new Ii({index:-1,str:"UNKNOWN"}),nb=new Ii({index:0,str:"POINTS"}),ob=new Ii({index:1,str:"LINES"}),rb=new Ii({index:2,str:"LINE_LOOP"}),ib=new Ii({index:3,str:"LINE_STRIP"}),ab=new Ii({index:4,str:"TRIANGLES"}),sb=new Ii({index:5,str:"TRIANGLE_STRIP"}),lb=new Ii({index:6,str:"TRIANGLE_FAN"}),nk=[tb,nb,ob,rb,ib,ab,sb,lb];h(ok,"from");Re=Object.freeze({Unknown:tb,Points:nb,Lines:ob,LineLoop:rb,LineStrip:ib,Triangles:ab,TriangleStrip:sb,TriangleFan:lb,from:ok})});var Hd,sa,rk,Hu,qu,cb,ik,ak,sk,lk,Z,Ke=C(()=>{"use strict";st();Hd=class Hd extends fe{constructor({index:n,str:t}){super({index:n,str:t})}get webGLVersion(){switch(this){case Hu:case qu:return 2;default:return 0}}};h(Hd,"ProcessApproachClass");sa=Hd,rk=new sa({index:0,str:"NONE"}),Hu=new sa({index:1,str:"UNIFORM"}),qu=new sa({index:2,str:"DataTexture"}),cb=new sa({index:3,str:"WebGPU"}),ik=h(m=>{switch(m){case qu:return!0;default:return!1}},"isDataTextureApproach"),ak=h(m=>{switch(m){case Hu:return!0;default:return!1}},"isUniformApproach"),sk=h(m=>{switch(m){case cb:return!0;default:return!1}},"isWebGpuApproach"),lk=h(m=>{switch(m){case Hu:case qu:return!0;default:return!1}},"isWebGL2Approach"),Z=Object.freeze({isDataTextureApproach:ik,isUniformApproach:ak,isWebGpuApproach:sk,None:rk,Uniform:Hu,DataTexture:qu,WebGPU:cb,isWebGL2Approach:lk})});function fk(m){return de({typeList:ck,index:m})}var Ns,kn,ub,mb,_b,db,hb,pb,xb,vb,gb,yb,bb,Ab,Ib,Sb,Tb,Eb,Cb,wb,ck,la,ju=C(()=>{"use strict";st();kn=(Ns=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}webGLConstantValue(){return this.index===-2?0:this.index===-1?1029:36064+this.index}},h(Ns,"RenderBufferTargetClass"),Ns),ub=new kn({index:-2,str:"NONE"}),mb=new kn({index:-1,str:"BACK"}),_b=new kn({index:0,str:"COLOR_ATTACHMENT0"}),db=new kn({index:1,str:"COLOR_ATTACHMENT1"}),hb=new kn({index:2,str:"COLOR_ATTACHMENT2"}),pb=new kn({index:3,str:"COLOR_ATTACHMENT3"}),xb=new kn({index:4,str:"COLOR_ATTACHMENT4"}),vb=new kn({index:5,str:"COLOR_ATTACHMENT5"}),gb=new kn({index:6,str:"COLOR_ATTACHMENT6"}),yb=new kn({index:7,str:"COLOR_ATTACHMENT7"}),bb=new kn({index:8,str:"COLOR_ATTACHMENT8"}),Ab=new kn({index:9,str:"COLOR_ATTACHMENT9"}),Ib=new kn({index:10,str:"COLOR_ATTACHMENT10"}),Sb=new kn({index:11,str:"COLOR_ATTACHMENT11"}),Tb=new kn({index:12,str:"COLOR_ATTACHMENT12"}),Eb=new kn({index:13,str:"COLOR_ATTACHMENT13"}),Cb=new kn({index:14,str:"COLOR_ATTACHMENT14"}),wb=new kn({index:15,str:"COLOR_ATTACHMENT15"}),ck=[ub,mb,_b,db,hb,pb,xb,vb,gb,yb,bb,Ab,Ib,Sb,Tb,Eb,Cb,wb];h(fk,"from");la=Object.freeze({None:ub,Back:mb,ColorAttachment0:_b,ColorAttachment1:db,ColorAttachment2:hb,ColorAttachment3:pb,ColorAttachment4:xb,ColorAttachment5:vb,ColorAttachment6:gb,ColorAttachment7:yb,ColorAttachment8:bb,ColorAttachment9:Ab,ColorAttachment10:Ib,ColorAttachment11:Sb,ColorAttachment12:Tb,ColorAttachment13:Eb,ColorAttachment14:Cb,ColorAttachment15:wb,from:fk})});function uk(m){return de({typeList:Pb,index:m})}function mk(m){return Te({typeList:Pb,str:m})}var Ps,Yu,Rb,Nb,MZ,DZ,Pb,Yl,Ku=C(()=>{"use strict";st();Yu=(Ps=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(Ps,"ShaderNodeClass"),Ps),Rb=new Yu({index:0,str:"ClassicShading"}),Nb=new Yu({index:1,str:"PBRShading"}),MZ=new Yu({index:2,str:"Lerp"}),DZ=new Yu({index:3,str:"Add"}),Pb=[Rb,Nb];h(uk,"from");h(mk,"fromString");Yl=Object.freeze({ClassicShading:Rb,PBRShading:Nb,from:uk,fromString:mk})});function dk(m){return de({typeList:qd,index:m})}function hk(m){return Te({typeList:qd,str:m})}function pk(m){return jm({typeList:qd,str:m})}function vk(m){return m.index}var fr,B,Mb,Db,Bb,Fb,Lb,Vb,zb,Gb,Ob,Ub,kb,Wb,Qb,Xb,Hb,qb,jb,Yb,Kb,Zb,Jb,$b,e1,t1,n1,o1,r1,i1,a1,s1,l1,c1,f1,u1,m1,_1,d1,h1,p1,x1,v1,g1,y1,b1,A1,I1,S1,T1,E1,C1,w1,R1,N1,P1,M1,D1,B1,F1,L1,V1,z1,G1,O1,U1,k1,_k,W1,Q1,X1,H1,q1,j1,Y1,K1,Z1,J1,$1,eA,tA,nA,oA,rA,iA,aA,sA,lA,cA,fA,uA,mA,_A,dA,hA,pA,xA,vA,gA,yA,bA,AA,IA,SA,TA,EA,CA,wA,RA,NA,PA,MA,DA,BA,FA,LA,VA,zA,GA,OA,UA,kA,WA,QA,XA,HA,qA,jA,YA,KA,ZA,JA,$A,eI,tI,qd,xk,Xe,So=C(()=>{"use strict";st();se();fr=class fr extends fe{constructor({str:n}){super({index:++fr.__indexCount*fr._scale,str:n,noCheckStrUnique:!0}),fr.__classes[this.index]=this}static getShaderSemanticByIndex(n){return this.__classes[Math.abs(n)-Math.abs(n)%this._scale]}static isNonArrayShaderSemanticIndex(n){return n>=this._scale}static isArrayAndZeroIndexShaderSemanticIndex(n){return n<0&&Math.abs(n)%fr._scale===0}static isArrayAndNonZeroIndexShaderSemanticIndex(n){return n<0&&Math.abs(n)%fr._scale!==0}static getIndexCount(){return fr.__indexCount}};h(fr,"ShaderSemanticsClass"),f(fr,"__indexCount",-1),f(fr,"_scale",1e4),f(fr,"__classes",[]);B=fr,Mb=new B({str:"worldMatrix"}),Db=new B({str:"viewMatrix"}),Bb=new B({str:"isBillboard"}),Fb=new B({str:"enableViewMatrix"}),Lb=new B({str:"projectionMatrix"}),Vb=new B({str:"normalMatrix"}),zb=new B({str:"boneMatrix"}),Gb=new B({str:"baseColorFactor"}),Ob=new B({str:"baseColorTexture"}),Ub=new B({str:"normalTexture"}),kb=new B({str:"metallicRoughnessTexture"}),Wb=new B({str:"occlusionTexture"}),Qb=new B({str:"emissiveFactor"}),Xb=new B({str:"emissiveTexture"}),Hb=new B({str:"lightNumber"}),qb=new B({str:"lightPosition"}),jb=new B({str:"lightDirection"}),Yb=new B({str:"lightIntensity"}),Kb=new B({str:"lightProperty"}),Zb=new B({str:"metallicRoughnessFactor"}),Jb=new B({str:"brdfLutTexture"}),$b=new B({str:"diffuseEnvTexture"}),e1=new B({str:"specularEnvTexture"}),t1=new B({str:"sheenEnvTexture"}),n1=new B({str:"inverseEnvironment"}),o1=new B({str:"iblParameter"}),r1=new B({str:"viewPosition"}),i1=new B({str:"wireframe"}),a1=new B({str:"diffuseColorFactor"}),s1=new B({str:"diffuseColorTexture"}),l1=new B({str:"shininess"}),c1=new B({str:"shadingModel"}),f1=new B({str:"skinningMode"}),u1=new B({str:"generalTexture"}),m1=new B({str:"vertexAttributesExistenceArray"}),_1=new B({str:"boneQuaternion"}),d1=new B({str:"boneTranslateScale"}),h1=new B({str:"boneTranslatePackedQuat"}),p1=new B({str:"boneScalePackedQuat"}),x1=new B({str:"boneCompressedChunk"}),v1=new B({str:"boneCompressedInfo"}),g1=new B({str:"pointSize"}),y1=new B({str:"colorEnvTexture"}),b1=new B({str:"pointDistanceAttenuation"}),A1=new B({str:"hdriFormat"}),I1=new B({str:"screenInfo"}),S1=new B({str:"depthTexture"}),T1=new B({str:"lightViewProjectionMatrix"}),E1=new B({str:"anisotropy"}),C1=new B({str:"clearcoatParameter"}),w1=new B({str:"sheenColorFactor"}),R1=new B({str:"sheenColorTexture"}),N1=new B({str:"sheenRoughnessFactor"}),P1=new B({str:"sheenRoughnessTexture"}),M1=new B({str:"sheenLutTexture"}),D1=new B({str:"specularGlossinessFactor"}),B1=new B({str:"specularGlossinessTexture"}),F1=new B({str:"entityUID"}),L1=new B({str:"morphTargetNumber"}),V1=new B({str:"dataTextureMorphOffsetPosition"}),z1=new B({str:"morphWeights"}),G1=new B({str:"currentComponentSIDs"}),O1=new B({str:"alphaCutoff"}),U1=new B({str:"alphaTexture"}),k1=new B({str:"makeOutputSrgb"}),_k=new B({str:"framebufferSize"}),W1=new B({str:"clearCoatFactor"}),Q1=new B({str:"clearCoatTexture"}),X1=new B({str:"clearCoatRoughnessFactor"}),H1=new B({str:"clearCoatRoughnessTexture"}),q1=new B({str:"clearCoatNormalTexture"}),j1=new B({str:"transmissionFactor"}),Y1=new B({str:"transmissionTexture"}),K1=new B({str:"backBufferTexture"}),Z1=new B({str:"backBufferTextureSize"}),J1=new B({str:"thicknessFactor"}),$1=new B({str:"thicknessTexture"}),eA=new B({str:"attenuationDistance"}),tA=new B({str:"attenuationColor"}),nA=new B({str:"isOutputHDR"}),oA=new B({str:"baseColorTextureTransform"}),rA=new B({str:"baseColorTextureRotation"}),iA=new B({str:"normalTextureTransform"}),aA=new B({str:"normalTextureRotation"}),sA=new B({str:"metallicRoughnessTextureTransform"}),lA=new B({str:"metallicRoughnessTextureRotation"}),cA=new B({str:"normalTexcoordIndex"}),fA=new B({str:"baseColorTexcoordIndex"}),uA=new B({str:"metallicRoughnessTexcoordIndex"}),mA=new B({str:"occlusionTexcoordIndex"}),_A=new B({str:"occlusionTextureTransform"}),dA=new B({str:"occlusionTextureRotation"}),hA=new B({str:"emissiveTexcoordIndex"}),pA=new B({str:"emissiveTextureTransform"}),xA=new B({str:"emissiveTextureRotation"}),vA=new B({str:"normalScale"}),gA=new B({str:"occlusionStrength"}),yA=new B({str:"envRotation"}),bA=new B({str:"envHdriFormat"}),AA=new B({str:"vrState"}),IA=new B({str:"enableLinearToSrgb"}),SA=new B({str:"specularFactor"}),TA=new B({str:"specularTexture"}),EA=new B({str:"specularColorFactor"}),CA=new B({str:"specularColorTexture"}),wA=new B({str:"ior"}),RA=new B({str:"depthBiasPV"}),NA=new B({str:"clearCoatTextureTransform"}),PA=new B({str:"clearCoatTextureRotation"}),MA=new B({str:"clearCoatRoughnessTextureTransform"}),DA=new B({str:"clearCoatRoughnessTextureRotation"}),BA=new B({str:"clearCoatNormalTextureTransform"}),FA=new B({str:"clearCoatNormalTextureRotation"}),LA=new B({str:"clearCoatTexcoordIndex"}),VA=new B({str:"clearCoatRoughnessTexcoordIndex"}),zA=new B({str:"clearCoatNormalTexcoordIndex"}),GA=new B({str:"iridescenceFactor"}),OA=new B({str:"iridescenceTexture"}),UA=new B({str:"iridescenceIor"}),kA=new B({str:"iridescenceThicknessMinimum"}),WA=new B({str:"iridescenceThicknessMaximum"}),QA=new B({str:"iridescenceThicknessTexture"}),XA=new B({str:"gaussianKernelSize"}),HA=new B({str:"gaussianRatio"}),qA=new B({str:"isHorizontal"}),jA=new B({str:"anisotropyStrength"}),YA=new B({str:"anisotropyRotation"}),KA=new B({str:"anisotropyTexture"}),ZA=new B({str:"emissiveStrength"}),JA=new B({str:"time"}),$A=new B({str:"cubeMapFaceId"}),eI=new B({str:"roughness"}),tI=new B({str:"distributionType"}),qd=[Mb,Db,Bb,Fb,Lb,Vb,zb,Gb,Ob,Ub,kb,Wb,Qb,Xb,Hb,qb,jb,Yb,Kb,Zb,Jb,$b,e1,t1,n1,o1,r1,i1,a1,s1,l1,c1,f1,u1,m1,_1,d1,h1,p1,x1,v1,g1,y1,b1,A1,I1,S1,T1,E1,C1,w1,R1,N1,P1,M1,D1,B1,F1,L1,V1,z1,G1,O1,U1,k1,W1,Q1,X1,H1,q1,j1,Y1,K1,Z1,J1,$1,eA,tA,nA,oA,rA,iA,aA,sA,lA,cA,fA,uA,mA,_A,dA,hA,pA,xA,vA,gA,yA,bA,AA,IA,SA,TA,EA,CA,wA,RA,NA,PA,MA,DA,BA,FA,LA,VA,zA,GA,OA,UA,kA,WA,QA,XA,HA,qA,jA,YA,KA,ZA,JA,$A,eI,tI];h(dk,"from");h(hk,"fromString");h(pk,"fromStringCaseSensitively");xk=h((m,n,t,o)=>{let r=n.compositionType.getGlslStr(n.componentType),i=n.semantic,a=n.compositionType.getGlslStr(n.componentType),s="";n.arrayLength&&(s=`[${n.arrayLength}]`);let l=`  uniform ${a} u_${i}${s};
`,c="";b.isArray(n.compositionType)?(i.match(/\[.+?\]/)?i=i.replace(/\[.+?\]/g,"[i]"):i+="[i]",c+=`
        ${r} val;
          int i = index;
          return u_${i};
        `):c+=`return u_${i};`;let u="";return b.isTexture(n.compositionType)||(u=`
  ${r} get_${n.semantic}(float instanceId, int index) {
    ${c}
  }
`),`${l}${u}`},"getShaderProperty");h(vk,"_getPropertyIndex2");Xe=Object.freeze({from:dk,fromString:hk,fromStringCaseSensitively:pk,WorldMatrix:Mb,ViewMatrix:Db,IsBillboard:Bb,EnableViewMatrix:Fb,ProjectionMatrix:Lb,NormalMatrix:Vb,BoneMatrix:zb,BaseColorFactor:Gb,BaseColorTexture:Ob,NormalTexture:Ub,MetallicRoughnessTexture:kb,OcclusionTexture:Wb,EmissiveFactor:Qb,EmissiveTexture:Xb,LightNumber:Hb,LightPosition:qb,LightDirection:jb,LightIntensity:Yb,LightProperty:Kb,MetallicRoughnessFactor:Zb,BrdfLutTexture:Jb,DiffuseEnvTexture:$b,SpecularEnvTexture:e1,SheenEnvTexture:t1,InverseEnvironment:n1,IBLParameter:o1,ViewPosition:r1,Wireframe:i1,DiffuseColorFactor:a1,DiffuseColorTexture:s1,Shininess:l1,ShadingModel:c1,SkinningMode:f1,GeneralTexture:u1,VertexAttributesExistenceArray:m1,BoneQuaternion:_1,BoneTranslateScale:d1,BoneTranslatePackedQuat:h1,BoneScalePackedQuat:p1,BoneCompressedChunk:x1,BoneCompressedInfo:v1,PointSize:g1,ColorEnvTexture:y1,PointDistanceAttenuation:b1,HDRIFormat:A1,ScreenInfo:I1,DepthTexture:S1,LightViewProjectionMatrix:T1,Anisotropy:E1,ClearCoatParameter:C1,SheenColorFactor:w1,SheenColorTexture:R1,SheenRoughnessFactor:N1,SheenRoughnessTexture:P1,SheenLutTexture:M1,SpecularGlossinessFactor:D1,SpecularGlossinessTexture:B1,ClearCoatFactor:W1,ClearCoatTexture:Q1,ClearCoatRoughnessFactor:X1,ClearCoatRoughnessTexture:H1,ClearCoatNormalTexture:q1,TransmissionFactor:j1,TransmissionTexture:Y1,BackBufferTexture:K1,BackBufferTextureSize:Z1,ThicknessFactor:J1,ThicknessTexture:$1,AttenuationDistance:eA,AttenuationColor:tA,getShaderProperty:xk,EntityUID:F1,MorphTargetNumber:L1,DataTextureMorphOffsetPosition:V1,MorphWeights:z1,CurrentComponentSIDs:G1,AlphaCutoff:O1,AlphaTexture:U1,MakeOutputSrgb:k1,FramebufferSize:_k,IsOutputHDR:nA,BaseColorTextureTransform:oA,BaseColorTextureRotation:rA,NormalTextureTransform:iA,NormalTextureRotation:aA,MetallicRoughnessTextureTransform:sA,MetallicRoughnessTextureRotation:lA,NormalTexcoordIndex:cA,BaseColorTexcoordIndex:fA,MetallicRoughnessTexcoordIndex:uA,OcclusionTexcoordIndex:mA,OcclusionTextureTransform:_A,OcclusionTextureRotation:dA,EmissiveTexcoordIndex:hA,EmissiveTextureTransform:pA,EmissiveTextureRotation:xA,NormalScale:vA,OcclusionStrength:gA,envRotation:yA,EnvHdriFormat:bA,VrState:AA,EnableLinearToSrgb:IA,SpecularFactor:SA,SpecularTexture:TA,SpecularColorFactor:EA,SpecularColorTexture:CA,Ior:wA,DepthBiasPV:RA,ClearCoatTextureTransform:NA,ClearCoatTextureRotation:PA,ClearCoatRoughnessTextureTransform:MA,ClearCoatRoughnessTextureRotation:DA,ClearCoatNormalTextureTransform:BA,ClearCoatNormalTextureRotation:FA,ClearCoatTexcoordIndex:LA,ClearCoatRoughnessTexcoordIndex:VA,ClearCoatNormalTexcoordIndex:zA,IridescenceFactor:GA,IridescenceTexture:OA,IridescenceIor:UA,IridescenceThicknessMinimum:kA,IridescenceThicknessMaximum:WA,IridescenceThicknessTexture:QA,GaussianKernelSize:XA,GaussianRatio:HA,IsHorizontal:qA,AnisotropyStrength:jA,AnisotropyRotation:YA,AnisotropyTexture:KA,EmissiveStrength:ZA,Time:JA,CubeMapFaceId:$A,Roughness:eI,DistributionType:tI})});function Kl(m){let n=m.compositionType.getNumberOfComponents(),t=m.componentType.getSizeInBytes(),o=n*t,r=o;if(r%16!==0&&(r=o+16-o%16),b.isArray(m.compositionType)){let i=m.arrayLength;i!=null?r*=i:(N.error("semanticInfo has invalid maxIndex!"),r*=100)}return r}var Zu=C(()=>{"use strict";me();se();h(Kl,"calcAlignedByteLength")});function gk(m){return de({typeList:aI,index:m})}function yk(m){return Te({typeList:aI,str:m})}var Ms,Ju,nI,oI,rI,iI,aI,D,Zt=C(()=>{"use strict";st();Ju=(Ms=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(Ms,"ShaderTypeClass"),Ms),nI=new Ju({index:1,str:"VertexShader"}),oI=new Ju({index:2,str:"PixelShader"}),rI=new Ju({index:3,str:"VertexAndPixelShader"}),iI=new Ju({index:4,str:"ComputeShader"}),aI=[nI,oI,rI,iI];h(gk,"from");h(yk,"fromString");D=Object.freeze({VertexShader:nI,PixelShader:oI,VertexAndPixelShader:rI,ComputeShader:iI,from:gk,fromString:yk})});function bk(m){return de({typeList:fI,index:m})}function Ak(m){return Te({typeList:fI,str:m})}var Ds,sI,lI,cI,fI,Ik,uI=C(()=>{"use strict";st();sI=(Ds=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(Ds,"ShaderVariableTypeClass"),Ds),lI=new sI({index:1,str:"Varying"}),cI=new sI({index:2,str:"ReadOnlyData"}),fI=[lI,cI];h(bk,"from");h(Ak,"fromString");Ik=Object.freeze({Varying:lI,ReadOnlyData:cI,from:bk,fromString:Ak})});function Tk(m){return de({typeList:Sk,index:m})}var Bs,Zl,mI,_I,dI,hI,pI,Sk,To,Jl=C(()=>{"use strict";st();Zl=(Bs=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(Bs,"ShadingModelClass"),Bs),mI=new Zl({index:-1,str:"UNKNOWN"}),_I=new Zl({index:0,str:"CONSTANT"}),dI=new Zl({index:1,str:"LAMBERT"}),hI=new Zl({index:2,str:"BLINN"}),pI=new Zl({index:3,str:"PHONG"}),Sk=[mI,_I,dI,hI,pI];h(Tk,"from");To=Object.freeze({Unknown:mI,Constant:_I,Lambert:dI,BlinnPhong:hI,Phong:pI,from:Tk})});function Ek(m){return de({typeList:yI,index:m})}function Ck(m){return Te({typeList:yI,str:m})}var Fs,xI,vI,gI,yI,wk,bI=C(()=>{"use strict";st();xI=(Fs=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(Fs,"ShadowMapClass"),Fs),vI=new xI({index:0,str:"Standard"}),gI=new xI({index:1,str:"Variance"}),yI=[vI,gI];h(Ek,"from");h(Ck,"fromString");wk=Object.freeze({Standard:vI,Variance:gI,from:Ek,fromString:Ck})});function Rk(m){switch(m){case jd:return ue.RGB;case Yd:return ue.RGBA;case Kd:return ue.RGBA;case Zd:return ue.RG;case Jd:return ue.RG;case $d:return ue.RGB;case eh:return ue.RGB;case th:return ue.RGBA;case nh:return ue.RGBA;case oh:return ue.RGB;case rh:return ue.DepthComponent;case ih:return ue.DepthComponent;case ah:return ue.DepthComponent;case sh:return ue.DepthStencil;case lh:return ue.DepthStencil;default:throw new Error(`Not implemented yet: ${m}`)}}function Nk(m){let n=ue.RGBA,t=I.UnsignedByte;return m===oe.RGB8?(n=ue.RGB,t=I.UnsignedByte):m===oe.RGBA8?(n=ue.RGBA,t=I.UnsignedByte):m===oe.RGB10_A2?(n=ue.RGBA,t=I.UnsignedByte):m===oe.RG16F?(n=ue.RG,t=I.HalfFloat):m===oe.RG32F?(n=ue.RG,t=I.Float):m===oe.RGB16F?(n=ue.RGB,t=I.HalfFloat):m===oe.RGB32F?(n=ue.RGB,t=I.Float):m===oe.RGBA16F?(n=ue.RGBA,t=I.HalfFloat):m===oe.RGBA32F?(n=ue.RGBA,t=I.Float):m===oe.R11F_G11F_B10F?(n=ue.RGB,t=I.Float):m===oe.Depth16?(n=ue.DepthComponent,t=I.UnsignedShort):m===oe.Depth24||m===oe.Depth24Stencil8?(n=ue.DepthComponent,t=I.UnsignedInt):(m===oe.Depth32F||m===oe.Depth32FStencil8)&&(n=ue.DepthComponent,t=I.Float),{format:n,type:t}}function Mk(m){return de({typeList:Pk,index:m})}var Ls,Eo,jd,Yd,Kd,Zd,Jd,$d,eh,th,nh,oh,rh,ih,ah,sh,lh,Pk,oe,pn=C(()=>{"use strict";jl();st();xe();Lo();Eo=(Ls=class extends fe{constructor({index:t,str:o,webgpu:r}){super({index:t,str:o});f(this,"__webgpu");this.__webgpu=r}get webgpu(){if(this.__webgpu===void 0)throw new Error(`does not support ${this.str}`);return this.__webgpu}},h(Ls,"TextureFormatClass"),Ls),jd=new Eo({index:32849,str:"RGB8",webgpu:"rgb8unorm"}),Yd=new Eo({index:32856,str:"RGBA8",webgpu:"rgba8unorm"}),Kd=new Eo({index:32857,str:"RGB10_A2",webgpu:"rgb10a2unorm"}),Zd=new Eo({index:33327,str:"RG16F",webgpu:"rg16float"}),Jd=new Eo({index:33328,str:"RG32F",webgpu:"rg32float"}),$d=new Eo({index:34843,str:"RGB16F",webgpu:"rgba16float"}),eh=new Eo({index:34837,str:"RGB32F",webgpu:"rgba32float"}),th=new Eo({index:34842,str:"RGBA16F",webgpu:"rgba16float"}),nh=new Eo({index:34836,str:"RGBA32F",webgpu:"rgba32float"}),oh=new Eo({index:35898,str:"R11F_G11F_B10F",webgpu:"rg11b10ufloat"}),rh=new Eo({index:33189,str:"DEPTH_COMPONENT16",webgpu:"depth16unorm"}),ih=new Eo({index:33190,str:"DEPTH_COMPONENT24",webgpu:"depth24plus"}),ah=new Eo({index:36012,str:"DEPTH_COMPONENT32F",webgpu:"depth32float"}),sh=new Eo({index:35056,str:"DEPTH24_STENCIL8",webgpu:"depth24plus-stencil8"}),lh=new Eo({index:36013,str:"DEPTH32F_STENCIL8",webgpu:"depth32float-stencil8"});h(Rk,"getPixelFormatFromTextureFormat");h(Nk,"getPixelFormatAndComponentTypeFromTextureFormat");Pk=[jd,Yd,Kd,Zd,Jd,$d,eh,th,nh,oh,rh,ih,ah,sh,lh];h(Mk,"from");oe=Object.freeze({RGB8:jd,RGBA8:Yd,RGB10_A2:Kd,RG16F:Zd,RG32F:Jd,RGB16F:$d,RGB32F:eh,RGBA16F:th,RGBA32F:nh,R11F_G11F_B10F:oh,Depth16:rh,Depth24:ih,Depth32F:ah,Depth24Stencil8:sh,Depth32FStencil8:lh,getPixelFormatFromTextureFormat:Rk,getPixelFormatAndComponentTypeFromTextureFormat:Nk,from:Mk})});function Bk(m){return de({typeList:Dk,index:m})}var Vs,Wn,AI,II,SI,TI,EI,CI,wI,RI,NI,PI,MI,DI,BI,FI,LI,VI,zI,GI,Dk,U,Vo=C(()=>{"use strict";st();Wn=(Vs=class extends fe{constructor({index:t,str:o,webgpu:r}){super({index:t,str:o});f(this,"__webgpu");this.__webgpu=r}get webgpu(){if(this.__webgpu===void 0)throw new Error(`does not support ${this.str}`);return this.__webgpu}},h(Vs,"TextureParameterClass"),Vs),AI=new Wn({index:9728,str:"NEAREST",webgpu:"nearest"}),II=new Wn({index:9729,str:"LINEAR",webgpu:"linear"}),SI=new Wn({index:9984,str:"NEAREST_MIPMAP_NEAREST",webgpu:"nearest"}),TI=new Wn({index:9985,str:"LINEAR_MIPMAP_NEAREST",webgpu:"linear"}),EI=new Wn({index:9986,str:"NEAREST_MIPMAP_LINEAR",webgpu:"nearest"}),CI=new Wn({index:9987,str:"LINEAR_MIPMAP_LINEAR",webgpu:"linear"}),wI=new Wn({index:10240,str:"TEXTURE_MAG_FILTER"}),RI=new Wn({index:10241,str:"TEXTURE_MIN_FILTER"}),NI=new Wn({index:10242,str:"TEXTURE_WRAP_S"}),PI=new Wn({index:10243,str:"TEXTURE_WRAP_T"}),MI=new Wn({index:3553,str:"TEXTURE_2D"}),DI=new Wn({index:5890,str:"TEXTURE"}),BI=new Wn({index:33984,str:"TEXTURE0"}),FI=new Wn({index:33985,str:"TEXTURE1"}),LI=new Wn({index:34016,str:"ACTIVE_TEXTURE"}),VI=new Wn({index:10497,str:"REPEAT",webgpu:"repeat"}),zI=new Wn({index:33071,str:"CLAMP_TO_EDGE",webgpu:"clamp-to-edge"}),GI=new Wn({index:33648,str:"MIRRORED_REPEAT",webgpu:"mirror-repeat"}),Dk=[AI,II,SI,TI,EI,CI,wI,RI,NI,PI,MI,DI,BI,FI,LI,VI,zI,GI];h(Bk,"from");U=Object.freeze({Nearest:AI,Linear:II,NearestMipmapNearest:SI,LinearMipmapNearest:TI,NearestMipmapLinear:EI,LinearMipmapLinear:CI,TextureMagFilter:wI,TextureMinFilter:RI,TextureWrapS:NI,TextureWrapT:PI,Texture2D:MI,Texture:DI,Texture0:BI,Texture1:FI,ActiveTexture:LI,Repeat:VI,ClampToEdge:zI,MirroredRepeat:GI,from:Bk})});function Lk(m){return m instanceof Zn}function Vk(m){return de({typeList:ch,index:m})}function zk(m){let n=m;return m==="COLOR"?n="COLOR_0":m==="TEXCOORD"?n="TEXCOORD_0":m==="JOINTS"?n="JOINTS_0":m==="WEIGHTS"&&(n="WEIGHTS_0"),Te({typeList:ch,str:n})}function Gk(m){switch(m){case $l:return m.XYZ;case rc:return m.XYZ;case ec:return m.XYZ;case tc:return m.XYZ;case nc:return m.XY;case oc:return m.XY;case $u:return m.XY;case ic:return m.XYZW;case ac:return m.XYZW;case sc:return m.XYZW;case lc:return m.XYZW;case cc:return m.XYZW;default:throw new Error("Invalied glTF VertexAttributeEnum")}}function Ok(m){switch(m){case $l.XYZ:return $l.getAttributeSlot();case rc.XYZ:return rc.getAttributeSlot();case ec.XYZ:return ec.getAttributeSlot();case tc.XYZ:return tc.getAttributeSlot();case nc.XY:return nc.getAttributeSlot();case oc.XY:return oc.getAttributeSlot();case $u.XY:return $u.getAttributeSlot();case ic.XYZW:return ic.getAttributeSlot();case ac.XYZW:return ac.getAttributeSlot();case sc.XYZW:return sc.getAttributeSlot();case lc.XYZ:return lc.getAttributeSlot();case cc.XYZ:return cc.getAttributeSlot();default:throw new Error("Invalied glTF VertexAttributeEnum")}}function Uk(m){return m.split(",").length}var zs,Zn,OI,$l,ec,tc,nc,oc,rc,ic,ac,sc,lc,cc,$u,ch,Fk,ee,Xt=C(()=>{"use strict";st();Bl();zs=class zs extends fe{constructor({str:t,shaderStr:o,attributeSlot:r,gltfComponentN:i}){super({index:zs.__indexCount++,str:t});f(this,"__attributeSlot");f(this,"__shaderStr");f(this,"__gltfComponentN");this.__attributeSlot=r,this.__shaderStr=o,this.__gltfComponentN=i}getAttributeSlot(){return this.__attributeSlot}get shaderStr(){return this.__shaderStr}get attributeTypeName(){return this.str}_setShaderStr(t){this.__shaderStr=this.__shaderStr+t}get X(){return`${this.attributeTypeName}.X`}get Y(){return`${this.attributeTypeName}.Y`}get Z(){return`${this.attributeTypeName}.Z`}get W(){return`${this.attributeTypeName}.W`}get XY(){return`${this.attributeTypeName}.X,${this.attributeTypeName}.Y`}get XYZ(){return`${this.attributeTypeName}.X,${this.attributeTypeName}.Y,${this.attributeTypeName}.Z`}get XYZW(){return`${this.attributeTypeName}.X,${this.attributeTypeName}.Y,${this.attributeTypeName}.Z,${this.attributeTypeName}.W`}getVertexAttributeComponentsAsGltf(){if(this.__gltfComponentN===1)return this.X;if(this.__gltfComponentN===2)return this.XY;if(this.__gltfComponentN===3)return this.XYZ;if(this.__gltfComponentN===4)return this.XYZW;throw new rr({message:"Invalid gltf component number",error:this.__gltfComponentN})}static __createVertexAttributeClass(t){return new zs(t)}};h(zs,"VertexAttributeClass"),f(zs,"__indexCount",-1);Zn=zs,OI=Zn.__createVertexAttributeClass({str:"UNKNOWN",shaderStr:"a_unknown",attributeSlot:-1,gltfComponentN:0}),$l=Zn.__createVertexAttributeClass({str:"POSITION",shaderStr:"a_position",attributeSlot:0,gltfComponentN:3}),ec=Zn.__createVertexAttributeClass({str:"NORMAL",shaderStr:"a_normal",attributeSlot:1,gltfComponentN:3}),tc=Zn.__createVertexAttributeClass({str:"TANGENT",shaderStr:"a_tangent",attributeSlot:2,gltfComponentN:4}),nc=Zn.__createVertexAttributeClass({str:"TEXCOORD_0",shaderStr:"a_texcoord_0",attributeSlot:3,gltfComponentN:2}),oc=Zn.__createVertexAttributeClass({str:"TEXCOORD_1",shaderStr:"a_texcoord_1",attributeSlot:4,gltfComponentN:2}),rc=Zn.__createVertexAttributeClass({str:"COLOR_0",shaderStr:"a_color_0",attributeSlot:5,gltfComponentN:4}),ic=Zn.__createVertexAttributeClass({str:"JOINTS_0",shaderStr:"a_joints_0",attributeSlot:6,gltfComponentN:4}),ac=Zn.__createVertexAttributeClass({str:"WEIGHTS_0",shaderStr:"a_weights_0",attributeSlot:7,gltfComponentN:4}),sc=Zn.__createVertexAttributeClass({str:"INSTANCE",shaderStr:"a_instanceInfo",attributeSlot:8,gltfComponentN:4}),lc=Zn.__createVertexAttributeClass({str:"FACE_NORMAL",shaderStr:"a_faceNormal",attributeSlot:9,gltfComponentN:3}),cc=Zn.__createVertexAttributeClass({str:"BARY_CENTRIC_COORD",shaderStr:"a_baryCentricCoord",attributeSlot:10,gltfComponentN:4}),$u=Zn.__createVertexAttributeClass({str:"TEXCOORD_2",shaderStr:"a_texcoord_2",attributeSlot:11,gltfComponentN:2}),ch=[OI,$l,ec,tc,nc,oc,rc,ic,ac,sc,lc,cc,$u],Fk=ch.length-1;h(Lk,"isInstanceOfVertexAttributeClass");h(Vk,"from");h(zk,"fromString");h(Gk,"toVertexAttributeSemanticJoinedStringAsGltfStyle");h(Ok,"toAttributeSlotFromJoinedString");h(Uk,"toVectorComponentN");ee=Object.freeze({Unknown:OI,Position:$l,Normal:ec,Tangent:tc,Texcoord0:nc,Texcoord1:oc,Color0:rc,Joints0:ic,Weights0:ac,Instance:sc,FaceNormal:lc,BaryCentricCoord:cc,AttributeTypeNumber:Fk,isInstanceOfVertexAttributeClass:Lk,toVertexAttributeSemanticJoinedStringAsGltfStyle:Gk,toAttributeSlotFromJoinedString:Ok,toVectorComponentN:Uk,from:Vk,fromString:zk})});function kk(m){return de({typeList:QI,index:m})}function Wk(m){return Te({typeList:QI,str:m})}var Gs,fh,UI,kI,WI,QI,Qk,XI=C(()=>{"use strict";st();fh=(Gs=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(Gs,"VisibilityClass"),Gs),UI=new fh({index:0,str:"Neutral"}),kI=new fh({index:1,str:"Visible"}),WI=new fh({index:-1,str:"Invisible"}),QI=[kI,WI,UI];h(kk,"from");h(Wk,"fromString");Qk=Object.freeze({Visible:kI,Invisible:WI,Neutral:UI,from:kk,fromString:Wk})});function Hk(m){return de({typeList:Xk,index:m})}var Os,ca,HI,qI,jI,YI,KI,ZI,JI,Xk,oi,$I=C(()=>{"use strict";st();ca=(Os=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(Os,"ToneMappingTypeClass"),Os),HI=new ca({index:-1,str:"None"}),qI=new ca({index:0,str:"Khronos_PBR_Neutral"}),jI=new ca({index:1,str:"Reinhard"}),YI=new ca({index:2,str:"GT_ToneMap"}),KI=new ca({index:3,str:"ACES_Filmic_ToneMap_Narkowicz"}),ZI=new ca({index:4,str:"ACES_Filmic_ToneMap_Hill"}),JI=new ca({index:5,str:"ACES_Filmic_ToneMap_Hill_Exposure_Boost"}),Xk=[HI,qI,jI,YI,KI,ZI,JI];h(Hk,"from");oi=Object.freeze({None:HI,KhronosPbrNeutral:qI,Reinhard:jI,GT_ToneMap:YI,ACES_Narkowicz:KI,ACES_Hill:ZI,ACES_Hill_Exposure_Boost:JI,from:Hk})});var un=C(()=>{"use strict";ni();Vr();Hl();Gu();Zi();cr();pd();ql();xe();se();vd();Ou();bi();Cs();Lo();Nn();Ke();Cn();ju();Ku();So();Zu();Zt();uI();Jl();bI();pn();Vo();Xt();XI();$I()});var e2=C(()=>{"use strict";gu()});var mh,uh,t2=C(()=>{"use strict";mh=class mh{constructor(){f(this,"_v",new Float32Array)}isTheSourceSame(n){return this._v.buffer===n}};h(mh,"AbstractArrayBufferBaseMathNumber");uh=mh});var _h,fc,qk,jk,n2=C(()=>{"use strict";It();_h=class _h extends q{constructor(n){super(n)}get x(){return this._v[0]}get y(){return this._v[1]}get z(){return this._v[2]}get w(){return this._v[3]}get r(){return this._v[0]}get g(){return this._v[1]}get b(){return this._v[2]}get a(){return this._v[3]}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(n){return super._normalize(n,Float32Array)}static add(n,t){return super._add(n,t,Float32Array)}static subtract(n,t){return super._subtract(n,t,Float32Array)}static multiply(n,t){return super._multiply(n,t,Float32Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float32Array)}static divide(n,t){return super._divide(n,t,Float32Array)}static divideVector(n,t){return super._divideVector(n,t,Float32Array)}clone(){return super.clone()}static fromCopyArray(n){return this._fromCopyArray(n,Float32Array)}static fromCopyArray4(n){return this._fromCopyArray4(n,Float32Array)}static fromCopy4(n,t,o,r){return this._fromCopy4(n,t,o,r,Float32Array)}static fromCopyVector4(n){return this._fromCopyVector4(n,Float32Array)}};h(_h,"ColorRgba");fc=_h,qk=new fc(new Float32Array([1,1,1,1])),jk=new fc(new Float32Array([0,0,0,1]))});var o2=C(()=>{"use strict"});var r2=C(()=>{"use strict"});var i2=C(()=>{"use strict"});var a2=C(()=>{"use strict"});var s2=C(()=>{"use strict"});var uc,dh,l2=C(()=>{"use strict";Bo();uc=class uc{constructor(n){f(this,"_v");this._v=n}get x(){return this._v[0]}get y(){return this._v[1]}get z(){return this._v[2]}get w(){return 1}static fromFloat32Array(n){return new uc(n)}static fromCopyArray3(n){return new H(new Float32Array(n))}static fromCopyArray(n){return new H(new Float32Array(n.slice(0,3)))}static fromCopy3(n,t,o){return new H(new Float32Array([n,t,o]))}static fromCopyLogQuaternion(n){let t=new Float32Array(3);return t[0]=n._v[0],t[1]=n._v[1],t[2]=n._v[2],new H(t)}static fromCopyVector4(n){let t=new Float32Array(3);return t[0]=n._v[0],t[1]=n._v[1],t[2]=n._v[2],new H(t)}static fromCopyQuaternion(n){let t=Math.acos(n.w),o=Math.sin(t),r=new Float32Array(3);return r[0]=n.x*(t/o),r[1]=n.y*(t/o),r[2]=n.z*(t/o),new uc(r)}get className(){return"LogQuaternion"}};h(uc,"LogQuaternion");dh=uc});var xn,mc,hh=C(()=>{"use strict";se();Xo();nn();Hi();me();xn=class xn extends Wo{constructor(n){super(),this._v=n}get m00(){return this._v[0]}get m10(){return this._v[1]}get m01(){return this._v[2]}get m11(){return this._v[3]}get className(){return"Matrix22"}static get compositionType(){return b.Mat2}static zero(){return xn.fromCopy4RowMajor(0,0,0,0)}static identity(){return xn.fromCopy4RowMajor(1,0,0,1)}static dummy(){return new this(new Float32Array(0))}static transpose(n){return xn.fromCopy4RowMajor(n._v[0],n._v[1],n._v[2],n._v[3])}static invert(n){let t=n.determinant();t===0&&N.error("the determinant is 0!");let o=n._v[3]/t,r=n._v[2]/t*-1,i=n._v[1]/t*-1,a=n._v[0]/t;return xn.fromCopy4RowMajor(o,r,i,a)}static invertTo(n,t){let o=n.determinant();o===0&&N.error("the determinant is 0!");let r=n._v[3]/o,i=n._v[2]/o*-1,a=n._v[1]/o*-1,s=n._v[0]/o;return t.setComponents(r,i,a,s)}static rotate(n){let t=Math.cos(n),o=Math.sin(n);return xn.fromCopy4RowMajor(t,-o,o,t)}static scale(n){return xn.fromCopy4RowMajor(n._v[0],0,0,n._v[1])}static multiply(n,t){let o=n._v[0]*t._v[0]+n._v[2]*t._v[1],r=n._v[1]*t._v[0]+n._v[3]*t._v[1],i=n._v[0]*t._v[2]+n._v[2]*t._v[3],a=n._v[1]*t._v[2]+n._v[3]*t._v[3];return xn.fromCopy4RowMajor(o,i,r,a)}static multiplyTo(n,t,o){let r=n._v[0]*t._v[0]+n._v[2]*t._v[1],i=n._v[1]*t._v[0]+n._v[3]*t._v[1],a=n._v[0]*t._v[2]+n._v[2]*t._v[3],s=n._v[1]*t._v[2]+n._v[3]*t._v[3];return o.setComponents(r,a,i,s)}toString(){return this._v[0]+" "+this._v[2]+`
`+this._v[1]+" "+this._v[3]+` 
`}toStringApproximately(){return Y.financial(this._v[0])+" "+Y.financial(this._v[2])+`
`+Y.financial(this._v[1])+" "+Y.financial(this._v[3])+` 
`}flattenAsArray(){return[this._v[0],this._v[1],this._v[2],this._v[3]]}isDummy(){return this._v.length===0}isEqual(n,t=Number.EPSILON){return Math.abs(n._v[0]-this._v[0])<t&&Math.abs(n._v[1]-this._v[1])<t&&Math.abs(n._v[2]-this._v[2])<t&&Math.abs(n._v[3]-this._v[3])<t}isStrictEqual(n){return n._v[0]===this._v[0]&&n._v[1]===this._v[1]&&n._v[2]===this._v[2]&&n._v[3]===this._v[3]}at(n,t){return this._v[n+t*2]}determinant(){return this._v[0]*this._v[3]-this._v[1]*this._v[2]}multiplyVector(n){let t=this._v[0]*n._v[0]+this._v[2]*n._v[1],o=this._v[1]*n._v[0]+this._v[3]*n._v[1];return Ee.fromCopyArray2([t,o])}multiplyVectorTo(n,t){let o=this._v[0]*n._v[0]+this._v[2]*n._v[1],r=this._v[1]*n._v[0]+this._v[3]*n._v[1];return t._v[0]=o,t._v[1]=r,t}getScale(){return Ee.fromCopyArray2([Math.hypot(this.m00,this.m01),Math.hypot(this.m10,this.m11)])}getScaleTo(n){return n._v[0]=Math.hypot(this._v[0],this._v[2]),n._v[1]=Math.hypot(this._v[1],this._v[3]),n}clone(){return this.constructor.fromCopy4RowMajor(this._v[0],this._v[2],this._v[1],this._v[3])}static fromCopy4RowMajor(n,t,o,r){let i=new Float32Array(4);return i[0]=n,i[2]=t,i[1]=o,i[3]=r,new xn(i)}static fromCopy4ColumnMajor(n,t,o,r){let i=new Float32Array(4);return i[0]=n,i[2]=o,i[1]=t,i[3]=r,new xn(i)}static fromFloat32ArrayColumnMajor(n){return new xn(n)}static fromCopyFloat32ArrayColumnMajor(n){let t=new Float32Array(4);return t.set(n),new xn(t)}static fromCopyFloat32ArrayRowMajor(n){let t=new Float32Array(4);return t[0]=n[0],t[3]=n[1],t[1]=n[2],t[4]=n[3],new xn(t)}static fromCopyMatrix22(n){let t=new Float32Array(4);return t[0]=n._v[0],t[3]=n._v[1],t[1]=n._v[2],t[4]=n._v[3],new xn(t)}static fromCopyArray9ColumnMajor(n){let t=new Float32Array(4);return t.set(n),new xn(t)}static fromCopyArrayColumnMajor(n){let t=new Float32Array(4);return t.set(n),new xn(t)}static fromCopyArray9RowMajor(n){let t=new Float32Array(4);return t[0]=n[0],t[3]=n[1],t[1]=n[2],t[4]=n[3],new xn(t)}static fromCopyArrayRowMajor(n){let t=new Float32Array(4);return t[0]=n[0],t[3]=n[1],t[1]=n[2],t[4]=n[3],new xn(t)}};h(xn,"Matrix22");mc=xn});var xh,ph,c2=C(()=>{"use strict";Ot();xh=class xh extends L{constructor(n){super(n)}get x(){return this._v[0]}set x(n){this._v[0]=n}get y(){return this._v[1]}set y(n){this._v[1]=n}get z(){return this._v[2]}set z(n){this._v[2]=n}get w(){return 1}get r(){return this._v[0]}set r(n){this._v[0]=n}get g(){return this._v[1]}set g(n){this._v[1]=n}get b(){return this._v[2]}set b(n){this._v[2]=n}get a(){return 1}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(n){return super._normalize(n,Float32Array)}static add(n,t){return super._add(n,t,Float32Array)}static subtract(n,t){return super._subtract(n,t,Float32Array)}static multiply(n,t){return super._multiply(n,t,Float32Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float32Array)}static divide(n,t){return super._divide(n,t,Float32Array)}static divideVector(n,t){return super._divideVector(n,t,Float32Array)}static cross(n,t){return super._cross(n,t,Float32Array)}clone(){return super.clone()}};h(xh,"MutableColorRgb");ph=xh});var gh,vh,f2=C(()=>{"use strict";fo();gh=class gh extends pe{constructor(n){super(n)}get x(){return this._v[0]}set x(n){this._v[0]=n}get y(){return this._v[1]}set y(n){this._v[1]=n}get z(){return this._v[2]}set z(n){this._v[2]=n}get w(){return this._v[3]}set w(n){this._v[3]=n}get r(){return this._v[0]}set r(n){this._v[0]=n}get g(){return this._v[1]}set g(n){this._v[1]=n}get b(){return this._v[2]}set b(n){this._v[2]=n}get a(){return this._v[3]}set a(n){this._v[3]=n}static zero(){return super._zero(Float32Array)}static one(){return super._one(Float32Array)}static dummy(){return super._dummy(Float32Array)}static normalize(n){return super._normalize(n,Float32Array)}static add(n,t){return super._add(n,t,Float32Array)}static subtract(n,t){return super._subtract(n,t,Float32Array)}static multiply(n,t){return super._multiply(n,t,Float32Array)}static multiplyVector(n,t){return super._multiplyVector(n,t,Float32Array)}static divide(n,t){return super._divide(n,t,Float32Array)}static divideVector(n,t){return super._divideVector(n,t,Float32Array)}clone(){return super.clone()}};h(gh,"MutableColorRgba");vh=gh});var Ko,fa,em=C(()=>{"use strict";hh();me();Ko=class Ko extends mc{constructor(n){super(n)}set m00(n){this._v[0]=n}get m00(){return this._v[0]}set m10(n){this._v[1]=n}get m10(){return this._v[1]}set m01(n){this._v[2]=n}get m01(){return this._v[2]}set m11(n){this._v[3]=n}get m11(){return this._v[3]}get className(){return"MutableMatrix22"}static zero(){return super.zero()}static identity(){return super.identity()}static dummy(){return super.dummy()}static transpose(n){return super.transpose(n)}static invert(n){return super.invert(n)}static rotate(n){return super.rotate(n)}static scale(n){return super.scale(n)}static multiply(n,t){return super.multiply(n,t)}clone(){return super.clone()}raw(){return this._v}setAt(n,t,o){return this._v[n+t*2]=o,this}setComponents(n,t,o,r){return this._v[0]=n,this._v[2]=t,this._v[1]=o,this._v[3]=r,this}copyComponents(n){return this._v[0]=n.m00,this._v[2]=n.m01,this._v[1]=n.m10,this._v[3]=n.m11,this}zero(){return this.setComponents(0,0,0,0)}identity(){return this.setComponents(1,0,0,1)}_swap(n,t){this._v[t]=[this._v[n],this._v[n]=this._v[t]][0]}transpose(){return this._swap(1,2),this}invert(){let n=this.determinant();n===0&&N.error("the determinant is 0!");let t=this._v[3]/n,o=this._v[2]/n*-1,r=this._v[1]/n*-1,i=this._v[0]/n;return this.setComponents(t,o,r,i)}rotate(n){let t=Math.cos(n),o=Math.sin(n);return this.setComponents(t,-o,o,t)}scale(n){return this.setComponents(n._v[0],0,0,n._v[1])}multiplyScale(n){return this._v[0]*=n._v[0],this._v[2]*=n._v[0],this._v[1]*=n._v[1],this._v[3]*=n._v[1],this}multiply(n){let t=this._v[0]*n._v[0]+this._v[2]*n._v[1],o=this._v[0]*n._v[2]+this._v[2]*n._v[3],r=this._v[1]*n._v[0]+this._v[3]*n._v[1],i=this._v[1]*n._v[2]+this._v[3]*n._v[3];return this.setComponents(t,o,r,i)}multiplyByLeft(n){let t=n._v[0]*this._v[0]+n._v[2]*this._v[1],o=n._v[0]*this._v[2]+n._v[2]*this._v[3],r=n._v[1]*this._v[0]+n._v[3]*this._v[1],i=n._v[1]*this._v[2]+n._v[3]*this._v[3];return this.setComponents(t,o,r,i)}static fromCopy4RowMajor(n,t,o,r){let i=new Float32Array(4);return i[0]=n,i[2]=t,i[1]=o,i[3]=r,new Ko(i)}static fromCopy4ColumnMajor(n,t,o,r){let i=new Float32Array(4);return i[0]=n,i[2]=o,i[1]=t,i[3]=r,new Ko(i)}static fromFloat32ArrayColumnMajor(n){return new Ko(n)}static fromCopyFloat32ArrayColumnMajor(n){let t=new Float32Array(4);return t.set(n),new Ko(t)}static fromCopyFloat32ArrayRowMajor(n){let t=new Float32Array(4);return t[0]=n[0],t[3]=n[1],t[1]=n[2],t[4]=n[3],new Ko(t)}static fromCopyMatrix22(n){let t=new Float32Array(4);return t[0]=n._v[0],t[3]=n._v[1],t[1]=n._v[2],t[4]=n._v[3],new Ko(t)}static fromCopyArray9ColumnMajor(n){let t=new Float32Array(4);return t.set(n),new Ko(t)}static fromCopyArrayColumnMajor(n){let t=new Float32Array(4);return t.set(n),new Ko(t)}static fromCopyArray9RowMajor(n){let t=new Float32Array(4);return t[0]=n[0],t[3]=n[1],t[1]=n[2],t[4]=n[3],new Ko(t)}static fromCopyArrayRowMajor(n){let t=new Float32Array(4);return t[0]=n[0],t[3]=n[1],t[1]=n[2],t[4]=n[3],new Ko(t)}};h(Ko,"MutableMatrix22");fa=Ko});var Jn,Us,yh=C(()=>{"use strict";yo();Yt();br();Ot();Bo();ye();Jn=class Jn{constructor(n){f(this,"__position");f(this,"__scale");f(this,"__rotation");f(this,"__updateCount",0);this.__position=L.dummy(),this.__scale=L.dummy(),this.__rotation=Ye.dummy(),n!==void 0?this.setTransform(n.positionInner,n.scaleInner,Ye.fromCopyQuaternion(n.rotationInner)):(this.__position=L.zero(),this.__scale=L.one(),this.__rotation=Ye.identity())}isEqual(n,t=Number.EPSILON){return this.positionInner.isEqual(n.positionInner,t)&&this.rotationInner.isEqual(n.rotationInner,t)&&this.scaleInner.isEqual(n.scaleInner,t)}clone(){return new Jn(this)}set position(n){this.__position.copyComponents(n),this.__updateTransform()}setPositionAsArray3(n){this.__position._v[0]=n[0],this.__position._v[1]=n[1],this.__position._v[2]=n[2],this.__updateTransform()}get position(){return this.positionInner.clone()}get positionInner(){return this.__position}set eulerAngles(n){let t=Math.sin(n._v[0]*.5),o=Math.cos(n._v[0]*.5),r=Math.sin(n._v[1]*.5),i=Math.cos(n._v[1]*.5),a=Math.sin(n._v[2]*.5),s=Math.cos(n._v[2]*.5);this.rotation=Ye.fromCopy4(t*i*s-o*r*a,o*r*s+t*i*a,o*i*a-t*r*s,o*i*s+t*r*a)}get eulerAngles(){return this.eulerAnglesInner.clone()}get eulerAnglesInner(){return this.__rotation.toEulerAngles()}set scale(n){this.__scale.copyComponents(n),this.__updateTransform()}setScaleAsArray3(n){this.__scale._v[0]=n[0],this.__scale._v[1]=n[1],this.__scale._v[2]=n[2],this.__updateTransform()}get scale(){return this.scaleInner.clone()}get scaleInner(){return this.__scale}set rotation(n){this.__rotation.copyComponents(n),this.__updateTransform()}setRotationAsArray4(n){this.__rotation._v[0]=n[0],this.__rotation._v[1]=n[1],this.__rotation._v[2]=n[2],this.__rotation._v[3]=n[3],this.__updateTransform()}get rotation(){return this.rotationInner.clone()}get rotationInner(){return this.__rotation}__updateTransform(){this.__updateCount++}set matrix(n){this.__rotation.fromMatrix(n),n.getTranslateTo(this.__position),n.getScaleTo(this.__scale),this.__updateTransform()}get matrix(){return this.matrixInner}get matrixInner(){let n=this.scaleInner,t=n._v[0],o=n._v[1],r=n._v[2],i=this.rotationInner,a=i._v[0]*i._v[0],s=i._v[1]*i._v[1],l=i._v[2]*i._v[2],c=i._v[1]*i._v[2],u=i._v[0]*i._v[2],_=i._v[0]*i._v[1],d=i._v[3]*i._v[0],p=i._v[3]*i._v[1],x=i._v[3]*i._v[2],v=1-2*(s+l),y=2*(_-x),g=2*(u+p),E=2*(_+x),w=1-2*(a+l),T=2*(c-d),R=2*(u-p),P=2*(c+d),V=1-2*(a+s),z=this.positionInner;return $.fromCopy16RowMajor(v*t,y*o,g*r,z.x,E*t,w*o,T*r,z.y,R*t,P*o,V*r,z.z,0,0,0,1)}getMatrixInnerTo(n){let t=this.scaleInner,o=t._v[0],r=t._v[1],i=t._v[2],a=this.rotationInner,s=a._v[0]*a._v[0],l=a._v[1]*a._v[1],c=a._v[2]*a._v[2],u=a._v[1]*a._v[2],_=a._v[0]*a._v[2],d=a._v[0]*a._v[1],p=a._v[3]*a._v[0],x=a._v[3]*a._v[1],v=a._v[3]*a._v[2],y=1-2*(l+c),g=2*(d-v),E=2*(_+x),w=2*(d+v),T=1-2*(s+c),R=2*(u-p),P=2*(_-x),V=2*(u+p),z=1-2*(s+l),k=this.positionInner;n.setComponents(y*o,g*r,E*i,k.x,w*o,T*r,R*i,k.y,P*o,V*r,z*i,k.z,0,0,0,1)}get updateCount(){return this.__updateCount}set rotateMatrix44(n){this.rotation=Jn.__tmpQuaternion_0.fromMatrix(n)}get rotateMatrix44(){return Se.fromCopyQuaternion(this.rotation)}setPropertiesFromJson(n){let t=n;typeof n=="string"&&(t=JSON.parse(n));for(let o in t)t.hasOwnProperty(o)&&o in this&&(o==="quaternion"?this.rotation=H.fromCopyArray4(t[o]):o==="matrix"?this[o]=Se.fromCopyArray16RowMajor(t[o]):this[o]=S.fromCopyArray(t[o]))}setRotationFromNewUpAndFront(n,t){let o=n,r=L.crossTo(o,t,Jn.__tmpVector3_0),i=L.crossTo(r,o,Jn.__tmpVector3_1),a=Jn.__tmpMatrix44_0.setComponents(r.x,o.x,i.x,0,r.y,o.y,i.y,0,r.z,o.z,i.z,0,0,0,0,1);this.rotateMatrix44=a}headToDirection(n,t){let o=Jn.__tmpVector3_0.copyComponents(n).normalize(),r=Jn.__tmpVector3_1.copyComponents(t).normalize(),i=L.crossTo(o,r,Jn.__tmpVector3_2),a=S.dot(o,r),s=Math.acos(a);this.rotation=Jn.__tmpQuaternion_0.axisAngle(i,s)}setTransform(n,t,o){this.__position=n.clone(),this.__rotation=o.clone(),this.__scale=t.clone(),this.__updateTransform()}};h(Jn,"Transform3D"),f(Jn,"__tmpMatrix44_0",$.zero()),f(Jn,"__tmpVector3_0",L.zero()),f(Jn,"__tmpVector3_1",L.zero()),f(Jn,"__tmpVector3_2",L.zero()),f(Jn,"__tmpQuaternion_0",Ye.identity());Us=Jn});var bh,ur,_c=C(()=>{"use strict";yi();Vr();Co();Tn();me();bh=class bh extends te{constructor(t,o){super(new Float32Array(1));f(this,"__animationSamplers");f(this,"__firstActiveAnimationTrackName");f(this,"__firstActiveAnimationSampler");f(this,"__secondActiveAnimationTrackName");f(this,"__secondActiveAnimationSampler");f(this,"__blendingRatio",0);f(this,"__time");f(this,"__lastTime",-1);f(this,"isLoop",!0);this.__animationSamplers=t,this.__firstActiveAnimationTrackName=o;let r=this.__animationSamplers.get(this.__firstActiveAnimationTrackName);if(r===void 0)throw new Error("Animation channel not found");this.__firstActiveAnimationSampler=r}getNumberArray(){return Array.from(this._v)}setFloat32Array(t){this._v=t,this.update()}setTime(t){this.__time=t,this.update()}useGlobalTime(){this.__time=void 0,this.update()}set blendingRatio(t){this.__blendingRatio=t,this.__lastTime=-1,this.update()}get blendingRatio(){return this.__blendingRatio}get x(){return this.update(),this._v[0]}update(){var r;let t=(r=this.__time)!=null?r:ot.globalTime;if(this.isLoop){let i=this.__firstActiveAnimationSampler.input[this.__firstActiveAnimationSampler.input.length-1];this.__secondActiveAnimationSampler!==void 0&&(i=Math.min(i,this.__secondActiveAnimationSampler.input[this.__secondActiveAnimationSampler.input.length-1])),t=t%i}if(this.__lastTime==t)return;let o=hn(this.__firstActiveAnimationSampler,t,mt.Scalar.index);if(this.__secondActiveAnimationSampler===void 0)this._v[0]=o[0];else{let i=hn(this.__secondActiveAnimationSampler,t,mt.Scalar.index);this._v[0]=o[0]*(1-this.blendingRatio)+i[0]*this.blendingRatio}this.__lastTime=t}setFirstActiveAnimationTrackName(t){this.__firstActiveAnimationTrackName=t;let o=this.__animationSamplers.get(this.__firstActiveAnimationTrackName);o===void 0?N.info("Animation channel not found"):this.__firstActiveAnimationSampler=o}setSecondActiveAnimationTrackName(t){this.__secondActiveAnimationTrackName=t;let o=this.__animationSamplers.get(this.__secondActiveAnimationTrackName);o===void 0?N.info("Animation channel not found"):this.__secondActiveAnimationSampler=o}getFirstActiveAnimationTrackName(){return this.__firstActiveAnimationTrackName}getSecondActiveAnimationTrackName(){return this.__secondActiveAnimationTrackName}getMinStartInputTime(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o.input[0]}getMaxEndInputTime(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o.input[o.input.length-1]}getAllTrackNames(){return Array.from(this.__animationSamplers.keys())}getAnimationSampler(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o}deleteAnimationSampler(t){this.__animationSamplers.delete(t)}setAnimationSampler(t,o){this.__animationSamplers.set(t,o)}};h(bh,"AnimatedScalar");ur=bh});var Ah,zr,tm=C(()=>{"use strict";yi();Vr();Co();Xo();me();Ah=class Ah extends Ee{constructor(t,o){super(new Float32Array(2));f(this,"__animationSamplers");f(this,"__firstActiveAnimationTrackName");f(this,"__firstActiveAnimationSampler");f(this,"__secondActiveAnimationTrackName");f(this,"__secondActiveAnimationSampler");f(this,"__blendingRatio",0);f(this,"__time");f(this,"__lastTime",-1);f(this,"isLoop",!0);this.__animationSamplers=t,this.__firstActiveAnimationTrackName=o;let r=this.__animationSamplers.get(this.__firstActiveAnimationTrackName);if(r===void 0)throw new Error("Animation channel not found");this.__firstActiveAnimationSampler=r}getNumberArray(){return Array.from(this._v)}setFloat32Array(t){this._v=t,this.update()}setTime(t){this.__time=t,this.update()}useGlobalTime(){this.__time=void 0,this.update()}set blendingRatio(t){this.__blendingRatio=t,this.__lastTime=-1,this.update()}get blendingRatio(){return this.__blendingRatio}get x(){return this.update(),this._v[0]}get y(){return this.update(),this._v[1]}get z(){return this.update(),this._v[2]}update(){var r;let t=(r=this.__time)!=null?r:ot.globalTime;if(this.isLoop){let i=this.__firstActiveAnimationSampler.input[this.__firstActiveAnimationSampler.input.length-1];this.__secondActiveAnimationSampler!==void 0&&(i=Math.min(i,this.__secondActiveAnimationSampler.input[this.__secondActiveAnimationSampler.input.length-1])),t=t%i}if(this.__lastTime==t)return;let o=hn(this.__firstActiveAnimationSampler,t,mt.Vector2.index);if(this.__secondActiveAnimationSampler===void 0)this._v[0]=o[0],this._v[1]=o[1];else{let i=hn(this.__secondActiveAnimationSampler,t,mt.Vector2.index);this._v[0]=o[0]*(1-this.blendingRatio)+i[0]*this.blendingRatio,this._v[1]=o[1]*(1-this.blendingRatio)+i[1]*this.blendingRatio}this.__lastTime=t}setFirstActiveAnimationTrackName(t){this.__firstActiveAnimationTrackName=t;let o=this.__animationSamplers.get(this.__firstActiveAnimationTrackName);o===void 0?N.info("Animation channel not found"):this.__firstActiveAnimationSampler=o}setSecondActiveAnimationTrackName(t){this.__secondActiveAnimationTrackName=t;let o=this.__animationSamplers.get(this.__secondActiveAnimationTrackName);o===void 0?N.info("Animation channel not found"):this.__secondActiveAnimationSampler=o}getFirstActiveAnimationTrackName(){return this.__firstActiveAnimationTrackName}getSecondActiveAnimationTrackName(){return this.__secondActiveAnimationTrackName}getMinStartInputTime(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o.input[0]}getMaxEndInputTime(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o.input[o.input.length-1]}getAllTrackNames(){return Array.from(this.__animationSamplers.keys())}getAnimationSampler(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o}deleteAnimationSampler(t){this.__animationSamplers.delete(t)}setAnimationSampler(t,o){this.__animationSamplers.set(t,o)}};h(Ah,"AnimatedVector2");zr=Ah});var Ih,$n,ks=C(()=>{"use strict";yi();Vr();Co();ye();me();Ih=class Ih extends S{constructor(t,o){super(new Float32Array(3));f(this,"__animationSamplers");f(this,"__firstActiveAnimationTrackName");f(this,"__firstActiveAnimationSampler");f(this,"__secondActiveAnimationTrackName");f(this,"__secondActiveAnimationSampler");f(this,"__blendingRatio",0);f(this,"__time");f(this,"__lastTime",-1);f(this,"isLoop",!0);this.__animationSamplers=t,this.__firstActiveAnimationTrackName=o;let r=this.__animationSamplers.get(this.__firstActiveAnimationTrackName);if(r===void 0)throw new Error("Animation channel not found");this.__firstActiveAnimationSampler=r}getNumberArray(){return Array.from(this._v)}setFloat32Array(t){this._v=t,this.update()}setTime(t){this.__time=t,this.update()}useGlobalTime(){this.__time=void 0,this.update()}set blendingRatio(t){this.__blendingRatio=t,this.__lastTime=-1,this.update()}get blendingRatio(){return this.__blendingRatio}get x(){return this.update(),this._v[0]}get y(){return this.update(),this._v[1]}get z(){return this.update(),this._v[2]}update(){var r;let t=(r=this.__time)!=null?r:ot.globalTime;if(this.isLoop){let i=this.__firstActiveAnimationSampler.input[this.__firstActiveAnimationSampler.input.length-1];this.__secondActiveAnimationSampler!==void 0&&(i=Math.min(i,this.__secondActiveAnimationSampler.input[this.__secondActiveAnimationSampler.input.length-1])),t=t%i}if(this.__lastTime==t)return;let o=hn(this.__firstActiveAnimationSampler,t,mt.Vector3.index);if(this.__secondActiveAnimationSampler===void 0)this._v[0]=o[0],this._v[1]=o[1],this._v[2]=o[2];else{let i=hn(this.__secondActiveAnimationSampler,t,mt.Vector3.index);this._v[0]=o[0]*(1-this.blendingRatio)+i[0]*this.blendingRatio,this._v[1]=o[1]*(1-this.blendingRatio)+i[1]*this.blendingRatio,this._v[2]=o[2]*(1-this.blendingRatio)+i[2]*this.blendingRatio}this.__lastTime=t}setFirstActiveAnimationTrackName(t){this.__firstActiveAnimationTrackName=t;let o=this.__animationSamplers.get(this.__firstActiveAnimationTrackName);o===void 0?N.info("Animation channel not found"):this.__firstActiveAnimationSampler=o}setSecondActiveAnimationTrackName(t){this.__secondActiveAnimationTrackName=t;let o=this.__animationSamplers.get(this.__secondActiveAnimationTrackName);o===void 0?N.info("Animation channel not found"):this.__secondActiveAnimationSampler=o}getFirstActiveAnimationTrackName(){return this.__firstActiveAnimationTrackName}getSecondActiveAnimationTrackName(){return this.__secondActiveAnimationTrackName}getMinStartInputTime(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o.input[0]}getMaxEndInputTime(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o.input[o.input.length-1]}getAllTrackNames(){return Array.from(this.__animationSamplers.keys())}getAnimationSampler(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o}deleteAnimationSampler(t){this.__animationSamplers.delete(t)}setAnimationSampler(t,o){this.__animationSamplers.set(t,o)}};h(Ih,"AnimatedVector3");$n=Ih});var Sh,Gr,nm=C(()=>{"use strict";It();yi();Vr();Co();me();Sh=class Sh extends q{constructor(t,o){super(new Float32Array(4));f(this,"__animationSamplers");f(this,"__firstActiveAnimationTrackName");f(this,"__firstActiveAnimationSampler");f(this,"__secondActiveAnimationTrackName");f(this,"__secondActiveAnimationSampler");f(this,"__blendingRatio",0);f(this,"__time");f(this,"__lastTime",-1);f(this,"isLoop",!0);this.__animationSamplers=t,this.__firstActiveAnimationTrackName=o;let r=this.__animationSamplers.get(this.__firstActiveAnimationTrackName);if(r===void 0)throw new Error("Animation channel not found");this.__firstActiveAnimationSampler=r}getNumberArray(){return Array.from(this._v)}setFloat32Array(t){this._v=t,this.update()}setTime(t){this.__time=t,this.update()}useGlobalTime(){this.__time=void 0,this.update()}set blendingRatio(t){this.__blendingRatio=t,this.__lastTime=-1,this.update()}get blendingRatio(){return this.__blendingRatio}get x(){return this.update(),this._v[0]}get y(){return this.update(),this._v[1]}get z(){return this.update(),this._v[2]}get w(){return this.update(),this._v[3]}update(){var r;let t=(r=this.__time)!=null?r:ot.globalTime;if(this.isLoop){let i=this.__firstActiveAnimationSampler.input[this.__firstActiveAnimationSampler.input.length-1];this.__secondActiveAnimationSampler!==void 0&&(i=Math.min(i,this.__secondActiveAnimationSampler.input[this.__secondActiveAnimationSampler.input.length-1])),t=t%i}if(this.__lastTime==t)return;let o=hn(this.__firstActiveAnimationSampler,t,mt.Vector4.index);if(this.__secondActiveAnimationSampler===void 0)this._v[0]=o[0],this._v[1]=o[1],this._v[2]=o[2],this._v[3]=o[3];else{let i=hn(this.__secondActiveAnimationSampler,t,mt.Vector4.index);this._v[0]=o[0]*(1-this.blendingRatio)+i[0]*this.blendingRatio,this._v[1]=o[1]*(1-this.blendingRatio)+i[1]*this.blendingRatio,this._v[2]=o[2]*(1-this.blendingRatio)+i[2]*this.blendingRatio,this._v[3]=o[3]*(1-this.blendingRatio)+i[3]*this.blendingRatio}this.__lastTime=t}setFirstActiveAnimationTrackName(t){this.__firstActiveAnimationTrackName=t;let o=this.__animationSamplers.get(this.__firstActiveAnimationTrackName);o===void 0?N.info("Animation channel not found"):this.__firstActiveAnimationSampler=o}setSecondActiveAnimationTrackName(t){this.__secondActiveAnimationTrackName=t;let o=this.__animationSamplers.get(this.__secondActiveAnimationTrackName);o===void 0?N.info("Animation channel not found"):this.__secondActiveAnimationSampler=o}getFirstActiveAnimationTrackName(){return this.__firstActiveAnimationTrackName}getSecondActiveAnimationTrackName(){return this.__secondActiveAnimationTrackName}getMinStartInputTime(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o.input[0]}getMaxEndInputTime(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o.input[o.input.length-1]}getAllTrackNames(){return Array.from(this.__animationSamplers.keys())}getAnimationSampler(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o}deleteAnimationSampler(t){this.__animationSamplers.delete(t)}setAnimationSampler(t,o){this.__animationSamplers.set(t,o)}};h(Sh,"AnimatedVector4");Gr=Sh});var Th,Si,om=C(()=>{"use strict";Ao();Co();Vr();yi();me();Th=class Th extends ve{constructor(t,o){super(new Float32Array);f(this,"__animationSamplers");f(this,"__firstActiveAnimationTrackName");f(this,"__firstActiveAnimationSampler");f(this,"__secondActiveAnimationTrackName");f(this,"__secondActiveAnimationSampler");f(this,"__blendingRatio",0);f(this,"__time");f(this,"__lastTime",-1);f(this,"isLoop",!0);this.__animationSamplers=t,this.__firstActiveAnimationTrackName=o;let r=this.__animationSamplers.get(this.__firstActiveAnimationTrackName);if(r===void 0)throw new Error("Animation channel not found");this.__firstActiveAnimationSampler=r,this.setFloat32Array(new Float32Array(r.outputComponentN))}getNumberArray(){return Array.from(this._v)}setFloat32Array(t){this._v=t,this.update()}setTime(t){this.__time=t,this.update()}useGlobalTime(){this.__time=void 0,this.update()}set blendingRatio(t){this.__blendingRatio=t,this.__lastTime=-1,this.update()}get blendingRatio(){return this.__blendingRatio}update(){var r;let t=(r=this.__time)!=null?r:ot.globalTime;if(this.isLoop){let i=this.__firstActiveAnimationSampler.input[this.__firstActiveAnimationSampler.input.length-1];this.__secondActiveAnimationSampler!==void 0&&(i=Math.min(i,this.__secondActiveAnimationSampler.input[this.__secondActiveAnimationSampler.input.length-1])),t=t%i}if(this.__lastTime==t)return;let o=hn(this.__firstActiveAnimationSampler,t,mt.VectorN.index);if(this.__secondActiveAnimationSampler===void 0)for(let i=0;i<this._v.length;i++)this._v[i]=o[i];else{let i=hn(this.__secondActiveAnimationSampler,t,mt.VectorN.index);for(let a=0;a<this._v.length;a++)this._v[a]=o[a]*(1-this.blendingRatio)+i[a]*this.blendingRatio}this.__lastTime=t}setFirstActiveAnimationTrackName(t){this.__firstActiveAnimationTrackName=t;let o=this.__animationSamplers.get(this.__firstActiveAnimationTrackName);o===void 0?N.info("Animation channel not found"):this.__firstActiveAnimationSampler=o}setSecondActiveAnimationTrackName(t){this.__secondActiveAnimationTrackName=t;let o=this.__animationSamplers.get(this.__secondActiveAnimationTrackName);o===void 0?N.info("Animation channel not found"):this.__secondActiveAnimationSampler=o}getFirstActiveAnimationTrackName(){return this.__firstActiveAnimationTrackName}getSecondActiveAnimationTrackName(){return this.__secondActiveAnimationTrackName}getMinStartInputTime(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o.input[0]}getMaxEndInputTime(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o.input[o.input.length-1]}getAllTrackNames(){return Array.from(this.__animationSamplers.keys())}getAnimationSampler(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o}deleteAnimationSampler(t){this.__animationSamplers.delete(t)}setAnimationSampler(t,o){this.__animationSamplers.set(t,o)}};h(Th,"AnimatedVectorN");Si=Th});var Eh,Ir,Ws=C(()=>{"use strict";yi();Vr();Co();Bo();me();Eh=class Eh extends H{constructor(t,o){super(new Float32Array(4));f(this,"__animationSamplers");f(this,"__firstActiveAnimationTrackName");f(this,"__firstActiveAnimationSampler");f(this,"__secondActiveAnimationTrackName");f(this,"__secondActiveAnimationSampler");f(this,"__blendingRatio",0);f(this,"__time");f(this,"__lastTime",-1);f(this,"isLoop",!0);this.__animationSamplers=t,this.__firstActiveAnimationTrackName=o;let r=this.__animationSamplers.get(this.__firstActiveAnimationTrackName);if(r===void 0)throw new Error("Animation channel not found");this.__firstActiveAnimationSampler=r}getNumberArray(){return Array.from(this._v)}setFloat32Array(t){this._v=t,this.update()}setTime(t){this.__time=t,this.update()}useGlobalTime(){this.__time=void 0,this.update()}set blendingRatio(t){this.__blendingRatio=t,this.__lastTime=-1,this.update()}get blendingRatio(){return this.__blendingRatio}get x(){return this.update(),this._v[0]}get y(){return this.update(),this._v[1]}get z(){return this.update(),this._v[2]}get w(){return this.update(),this._v[3]}update(){var r;let t=(r=this.__time)!=null?r:ot.globalTime;if(this.isLoop){let i=this.__firstActiveAnimationSampler.input[this.__firstActiveAnimationSampler.input.length-1];this.__secondActiveAnimationSampler!==void 0&&(i=Math.min(i,this.__secondActiveAnimationSampler.input[this.__secondActiveAnimationSampler.input.length-1])),t=t%i}if(this.__lastTime==t)return;let o=hn(this.__firstActiveAnimationSampler,t,mt.Quaternion.index);if(this.__secondActiveAnimationSampler===void 0)this._v[0]=o[0],this._v[1]=o[1],this._v[2]=o[2],this._v[3]=o[3];else{let i=hn(this.__secondActiveAnimationSampler,t,mt.Quaternion.index),a=H.fromCopy4(o[0],o[1],o[2],o[3]),s=H.fromCopy4(i[0],i[1],i[2],i[3]),l=H.qlerp(a,s,this.blendingRatio)._v;this._v[0]=l[0],this._v[1]=l[1],this._v[2]=l[2],this._v[3]=l[3]}this.__lastTime=t}setFirstActiveAnimationTrackName(t){this.__firstActiveAnimationTrackName=t;let o=this.__animationSamplers.get(this.__firstActiveAnimationTrackName);o===void 0?N.info("Animation channel not found"):this.__firstActiveAnimationSampler=o}setSecondActiveAnimationTrackName(t){this.__secondActiveAnimationTrackName=t;let o=this.__animationSamplers.get(this.__secondActiveAnimationTrackName);o===void 0?N.info("Animation channel not found"):this.__secondActiveAnimationSampler=o}getFirstActiveAnimationTrackName(){return this.__firstActiveAnimationTrackName}getSecondActiveAnimationTrackName(){return this.__secondActiveAnimationTrackName}getMinStartInputTime(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o.input[0]}getMaxEndInputTime(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o.input[o.input.length-1]}getAllTrackNames(){return Array.from(this.__animationSamplers.keys())}getAnimationSampler(t){let o=this.__animationSamplers.get(t);if(o===void 0)throw new Error("Animation channel not found");return o}deleteAnimationSampler(t){this.__animationSamplers.delete(t)}setAnimationSampler(t,o){this.__animationSamplers.set(t,o)}};h(Eh,"AnimatedQuaternion");Ir=Eh});var Or=C(()=>{"use strict";e2();pi();t2();Hi();K_();qa();N_();n2();o2();v_();b_();r2();i2();a2();s2();l2();ra();nn();hh();ji();yo();c2();f2();em();or();Yt();br();gi();sr();Ot();fo();Bo();Tn();yh();Xo();ye();It();Ao();_c();tm();ks();nm();om();Ws()});var Yk,Kk,Ht,ot,Co=C(()=>{"use strict";dn();St();at();it();Vr();md();ge();yi();un();br();Ot();Or();ks();Ws();Yk=Symbol("AnimationComponentEventChangeAnimationInfo"),Kk=Symbol("AnimationComponentEventPlayEnd"),Ht=class Ht extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"__animationBlendingRatio",0);f(this,"__animationTrack",new Map);f(this,"__isEffekseerState",-1);f(this,"__isAnimating",!0);f(this,"isLoop",!0);f(this,"useGlobalTime",!0);f(this,"time",0)}$load(){this.moveStageTo(Ne.Logic)}$logic(){!Ht.isAnimating||!this.isAnimating||this.__applyAnimation()}set animationBlendingRatio(t){this.__animationBlendingRatio=t,this.__applyAnimation()}get animationBlendingRatio(){return this.__animationBlendingRatio}__applyAnimation(){let t=this.time;this.useGlobalTime&&(t=Ht.globalTime);let o=this.entity.getTransform(),r=this.entity.tryToGetBlendShape(),i=this.entity.tryToGetEffekseer();for(let[a,s]of this.__animationTrack)if(s.animatedValue.setTime(t),s.animatedValue.blendingRatio=this.__animationBlendingRatio,a==="translate")o.localPosition=s.animatedValue;else if(a==="quaternion")o.localRotation=s.animatedValue;else if(a==="scale")o.localScale=s.animatedValue;else if(a==="weights")r.weights=s.animatedValue.getNumberArray();else if(a.startsWith("material/")){let l=this.entity.tryToGetMesh();if(A.exist(l)&&A.exist(l.mesh)){let c=l.mesh;for(let u=0;u<c.getPrimitiveNumber();u++){let d=c.getPrimitiveAt(u).material;A.exist(d)&&d.setParameter(a.split("/").pop(),s.animatedValue)}}}else if(a==="light_color"){let l=this.entity.tryToGetLight();if(A.exist(l)){let c=s.animatedValue;l.color=c}}else if(a==="light_intensity"){let l=this.entity.tryToGetLight();if(A.exist(l)){let c=s.animatedValue;l.intensity=c._v[0]}}else if(a==="light_range"){let l=this.entity.tryToGetLight();if(A.exist(l)){let c=s.animatedValue;l.range=c._v[0]}}else if(a==="light_spot_innerConeAngle"){let l=this.entity.tryToGetLight();if(A.exist(l)){let c=s.animatedValue;l.innerConeAngle=c._v[0]}}else if(a==="light_spot_outerConeAngle"){let l=this.entity.tryToGetLight();if(A.exist(l)){let c=s.animatedValue;l.outerConeAngle=c._v[0]}}else if(a==="camera_znear"){let l=this.entity.tryToGetCamera();if(A.exist(l)){let c=s.animatedValue;l.zNear=c._v[0]}}else if(a==="camera_zfar"){let l=this.entity.tryToGetCamera();if(A.exist(l)){let c=s.animatedValue;l.zFar=c._v[0]}}else if(a==="camera_fovy"){let l=this.entity.tryToGetCamera();if(A.exist(l)){let c=s.animatedValue;l.setFovyAndChangeFocalLength(Y.radianToDegree(c._v[0]))}}else if(a==="camera_xmag"){let l=this.entity.tryToGetCamera();if(A.exist(l)){let c=s.animatedValue;l.xMag=c._v[0]}}else if(a==="camera_ymag"){let l=this.entity.tryToGetCamera();if(A.exist(l)){let c=s.animatedValue;l.yMag=c._v[0]}}else a==="effekseer"&&(s.animatedValue.x>.5?this.__isEffekseerState===0&&(i==null||i.play()):this.__isEffekseerState===1&&(i==null||i.pause()),this.__isEffekseerState=s.animatedValue.x)}static subscribe(t,o){Ht.__pubsub.subscribe(t,o)}setIsAnimating(t){this.__isAnimating=t}static setActiveAnimationForAll(t){let o=J.getComponentsWithType(Ht);for(let r of o)r.setActiveAnimationTrack(t)}setActiveAnimationTrack(t){for(let[o,r]of this.__animationTrack)r.animatedValue.setFirstActiveAnimationTrackName(t)}setSecondActiveAnimationTrack(t){for(let[o,r]of this.__animationTrack)r.animatedValue.setSecondActiveAnimationTrackName(t)}getActiveAnimationTrack(){for(let[t,o]of this.__animationTrack)return o.animatedValue.getFirstActiveAnimationTrackName();throw new Error("No active animation track found")}hasAnimation(t,o){for(let[r,i]of this.__animationTrack)return o==r&&i.animatedValue.getFirstActiveAnimationTrackName()===t;return!1}setAnimation(t,o){let r;if(this.__animationTrack.has(t)){let a=this.__animationTrack.get(t).animatedValue;for(let s of o.getAllTrackNames())a.setAnimationSampler(s,o.getAnimationSampler(s));r=a}else this.__animationTrack.set(t,{animatedValue:o,target:{pathName:t,entity:this.entity}}),r=o;let i=r.getAllTrackNames();for(let a of i){let s=r.getMinStartInputTime(a),l=r.getMaxEndInputTime(a),c={name:a,minStartInputTime:s,maxEndInputTime:l};Ht.__animationGlobalInfo.set(a,c),Ht.__pubsub.publishAsync(Ht.Event.ChangeAnimationInfo,{infoMap:new Map(Ht.__animationGlobalInfo)})}this.entity.getTransform()._backupTransformAsRest()}getAnimation(t){var o;return(o=this.__animationTrack.get(t))==null?void 0:o.animatedValue}getStartInputValueOfAnimation(t){return Ht.__animationGlobalInfo.get(t).minStartInputTime}getEndInputValueOfAnimation(t){return Ht.__animationGlobalInfo.get(t).maxEndInputTime}static getAnimationList(){return Array.from(this.__animationGlobalInfo.keys())}static getAnimationInfo(){return new Map(this.__animationGlobalInfo)}getAnimationTrackNames(){let t=[];for(let[o,r]of this.__animationTrack)t.push(...r.animatedValue.getAllTrackNames());return t}getAnimationChannelsOfTrack(){return this.__animationTrack}get isAnimating(){return this.__isAnimating}static get startInputValue(){if(J.getComponentsWithType(Ht).length===0)return 0;{let o=Array.from(this.__animationGlobalInfo.values());return o[o.length-1].minStartInputTime}}static get endInputValue(){if(J.getComponentsWithType(Ht).length===0)return 0;{let o=Array.from(this.__animationGlobalInfo.values());return o[o.length-1].maxEndInputTime}}static get componentTID(){return Q.AnimationComponentTID}get componentTID(){return Q.AnimationComponentTID}get entity(){return ne.getEntity(this.__entityUid)}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(s,l,c){super(s,l,c)}getAnimation(){return this.getComponentByComponentTID(Q.AnimationComponentTID)}},h(i,"AnimationEntity"),i);return vt(t,r),t}addKeyFrame(t,o,r,i){let a=r/i,s=a,l=(r+1)/i,c=this.__animationTrack.get(o);if(A.not.exist(c))return!1;let u=c.animatedValue,_=mt.fromString(o).index,d=hn(u.getAnimationSampler(t),Ht.globalTime,_);if(u.getAnimationSampler(t).input.length===0){let p=Array.from(u.getAnimationSampler(t).input);p.push(s),u.getAnimationSampler(t).input=new Float32Array(p);let x=Array.from(u.getAnimationSampler(t).output);x.push(...d),u.getAnimationSampler(t).output=new Float32Array(x)}else if(u.getAnimationSampler(t).input.length===1){let p=u.getAnimationSampler(t).input[0];if(l<p){let x=Array.from(u.getAnimationSampler(t).input);x.unshift(s),u.getAnimationSampler(t).input=new Float32Array(x);let v=Array.from(u.getAnimationSampler(t).output);v.unshift(...d),u.getAnimationSampler(t).output=new Float32Array(v)}else if(p<a){let x=Array.from(u.getAnimationSampler(t).input);x.push(s),u.getAnimationSampler(t).input=new Float32Array(x);let v=Array.from(u.getAnimationSampler(t).output);v.push(...d),u.getAnimationSampler(t).output=new Float32Array(v)}else{let x=Array.from(u.getAnimationSampler(t).input);x.splice(0,0,s),u.getAnimationSampler(t).input=new Float32Array(x);let v=Array.from(u.getAnimationSampler(t).output);v.splice(0,0,...d),u.getAnimationSampler(t).output=new Float32Array(v)}}else for(let p=0;p<u.getAnimationSampler(t).input.length;p++){let x=u.getAnimationSampler(t).input[p];if(a<=x){if(a<=x&&x<=l){u.getAnimationSampler(t).input[p]=s;for(let v=0;v<u.getAnimationSampler(t).outputComponentN;v++)u.getAnimationSampler(t).output[p*u.getAnimationSampler(t).outputComponentN+v]=d[v]}else{let v=Array.from(u.getAnimationSampler(t).input);v.splice(p,0,s),u.getAnimationSampler(t).input=new Float32Array(v);let y=Array.from(u.getAnimationSampler(t).output);y.splice(p*u.getAnimationSampler(t).outputComponentN,0,...d),u.getAnimationSampler(t).output=new Float32Array(y)}break}}return!0}addKeyFrameWithValue(t,o,r,i,a){let s=r/a,l=s,c=(r+1)/a,u=this.__animationTrack.get(o);if(A.not.exist(u))return!1;let _=u.animatedValue;if(_.getAnimationSampler(t).input.length===0){let d=Array.from(_.getAnimationSampler(t).input);d.push(l),_.getAnimationSampler(t).input=new Float32Array(d);let p=Array.from(_.getAnimationSampler(t).output);p.push(...i),_.getAnimationSampler(t).output=new Float32Array(p)}else if(_.getAnimationSampler(t).input.length===1){let d=_.getAnimationSampler(t).input[0];if(c<d){let p=Array.from(_.getAnimationSampler(t).input);p.unshift(l),_.getAnimationSampler(t).input=new Float32Array(p);let x=Array.from(_.getAnimationSampler(t).output);x.unshift(...i),_.getAnimationSampler(t).output=new Float32Array(x)}else if(d<s){let p=Array.from(_.getAnimationSampler(t).input);p.push(l),_.getAnimationSampler(t).input=new Float32Array(p);let x=Array.from(_.getAnimationSampler(t).output);x.push(...i),_.getAnimationSampler(t).output=new Float32Array(x)}else{let p=Array.from(_.getAnimationSampler(t).input);p.splice(0,0,l),_.getAnimationSampler(t).input=new Float32Array(p);let x=Array.from(_.getAnimationSampler(t).output);x.splice(0,0,...i),_.getAnimationSampler(t).output=new Float32Array(x)}}else for(let d=0;d<_.getAnimationSampler(t).input.length;d++){let p=_.getAnimationSampler(t).input[d];if(s<=p){if(s<=p&&p<=c){_.getAnimationSampler(t).input[d]=l;for(let x=0;x<_.getAnimationSampler(t).outputComponentN;x++)_.getAnimationSampler(t).output[d*_.getAnimationSampler(t).outputComponentN+x]=i[x]}else{let x=Array.from(_.getAnimationSampler(t).input);x.splice(d,0,l),_.getAnimationSampler(t).input=new Float32Array(x);let v=Array.from(_.getAnimationSampler(t).output);v.splice(d*_.getAnimationSampler(t).outputComponentN,0,...i),_.getAnimationSampler(t).output=new Float32Array(v)}break}}return!0}deleteKeysAtFrame(t,o,r,i){let a=r/i,s=(r+1)/i,l=this.__animationTrack.get(o);if(A.not.exist(l))return!1;let c=l.animatedValue;for(let u=0;u<c.getAnimationSampler(t).input.length;u++){let _=c.getAnimationSampler(t).input[u];if(a<=_&&_<s){let d=Array.from(c.getAnimationSampler(t).input);d.splice(u,1),c.getAnimationSampler(t).input=new Float32Array(d);let p=Array.from(c.getAnimationSampler(t).output);p.splice(u*c.getAnimationSampler(t).outputComponentN,c.getAnimationSampler(t).outputComponentN),c.getAnimationSampler(t).output=new Float32Array(p)}}return!0}hasKeyFramesAtFrame(t,o,r,i){let a=r/i,s=(r+1)/i,l=this.__animationTrack.get(o);if(A.not.exist(l))return!1;let c=l.animatedValue;for(let u=0;u<c.getAnimationSampler(t).input.length;u++){let _=c.getAnimationSampler(t).input[u];if(a<=_&&_<s)return!0}return!1}static setIsAnimating(t){this.isAnimating=t}_shallowCopyFrom(t){let o=t;this.__animationTrack=new Map(o.__animationTrack),this.__isEffekseerState=o.__isEffekseerState,this.__isAnimating=o.__isAnimating}_setRetarget(t,o){let i=t.getEntity().tryToGetAnimation(),a=this.entity;if(this.entity.getTransform()._backupTransformAsRest(),A.not.exist(i))return[];i.useGlobalTime=!1;let s=[];for(let[_,d]of i.__animationTrack){let p=d.animatedValue;for(let x of p.getAllTrackNames()){let v=x+(o!=null?o:"");s.push(v);let y=p.getAnimationSampler(x).input;if(d.target.pathName==="translate"){let g=l(y,i),E=new Map;E.set(v,{input:y,output:g,outputComponentN:3,interpolationMethod:p.getAnimationSampler(x).interpolationMethod});let w=new $n(E,v);this.setAnimation(_,w)}if(d.target.pathName==="quaternion"){let g=c(y,i),E=new Map;E.set(v,{input:y,output:g,outputComponentN:4,interpolationMethod:p.getAnimationSampler(x).interpolationMethod});let w=new Ir(E,v);this.setAnimation(_,w)}if(d.target.pathName==="scale"){let g=u(y,i),E=new Map;E.set(v,{input:y,output:g,outputComponentN:3,interpolationMethod:p.getAnimationSampler(x).interpolationMethod});let w=new $n(E,v);this.setAnimation(_,w)}}}function l(_,d){let p=new Float32Array(_.length*3);for(let x=0;x<_.length;x++){d.time=_[x],d.__applyAnimation();let v=t.retargetTranslate(a);p[x*3+0]=v.x,p[x*3+1]=v.y,p[x*3+2]=v.z}return p}h(l,"retargetTranslate");function c(_,d){let p=new Float32Array(_.length*4);for(let x=0;x<_.length;x++){d.time=_[x],d.__applyAnimation();let v=t.retargetQuaternion(a);p[x*4+0]=v.x,p[x*4+1]=v.y,p[x*4+2]=v.z,p[x*4+3]=v.w}return p}h(c,"retargetQuaternion");function u(_,d){let p=new Float32Array(_.length*3);for(let x=0;x<_.length;x++){d.time=_[x],d.__applyAnimation();let v=t.retargetScale(a);p[x*3+0]=v.x,p[x*3+1]=v.y,p[x*3+2]=v.z}return p}return h(u,"retargetScale"),s}resetAnimationTracks(){this.__animationTrack.clear()}resetAnimationTrack(t){for(let[o,r]of this.__animationTrack)r.animatedValue.deleteAnimationSampler(t)}resetAnimationTrackByPostfix(t){let o=this.getAnimationTrackNames();for(let r of o)r.endsWith(t)&&this.resetAnimationTrack(r)}_destroy(){super._destroy(),this.__animationTrack.clear(),this.__isAnimating=!1}};h(Ht,"AnimationComponent"),f(Ht,"__animationGlobalInfo",new Map),f(Ht,"isAnimating",!0),f(Ht,"globalTime",0),f(Ht,"Event",{ChangeAnimationInfo:Yk,PlayEnd:Kk}),f(Ht,"__tmpQuat",Ye.identity()),f(Ht,"__tmpPos",L.zero()),f(Ht,"__tmpScale",L.one()),f(Ht,"__pubsub",new Xl);ot=Ht});var u2=C(()=>{"use strict"});var Zk,m2=C(()=>{"use strict";Zk="Default"});var _2=C(()=>{"use strict";Co();u2();m2()});var ua,Zo,dc=C(()=>{"use strict";dn();at();it();Cn();ua=class ua extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"__weights",[]);f(this,"__targetNames",[]);this.moveStageTo(Ne.Logic)}static get updateCount(){return this.__updateCount}static get componentTID(){return Q.BlendShapeComponentTID}get componentTID(){return Q.BlendShapeComponentTID}set weights(t){this.__weights=t,ua.__updateCount++}get weights(){return this.__weights}set targetNames(t){this.__targetNames=t,ua.__updateCount++}get targetNames(){return this.__targetNames}setWeightByIndex(t,o){this.__weights[t]=o,ua.__updateCount++}$logic(){}_destroy(){super._destroy()}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(s,l,c){super(s,l,c)}getBlendShape(){return this.getComponentByComponentTID(Q.BlendShapeComponentTID)}},h(i,"BlendShapeEntity"),i);return vt(t,r),t}};h(ua,"BlendShapeComponent"),f(ua,"__updateCount",0);Zo=ua});var d2=C(()=>{"use strict"});var h2=C(()=>{"use strict";dc();d2()});var Ch,hc,wh=C(()=>{"use strict";It();yo();Yt();fo();Ch=class Ch{constructor(){f(this,"top",pe.zero());f(this,"bottom",pe.zero());f(this,"right",pe.zero());f(this,"left",pe.zero());f(this,"zNear",pe.zero());f(this,"zFar",pe.zero());f(this,"__updated",!1);f(this,"__vp",$.zero());f(this,"__invProjMat",$.zero());f(this,"__invViewMat",$.zero());f(this,"__tmp_vec4_0",pe.zero());f(this,"__tmp_vec4_1",pe.zero());f(this,"__tmp_vec4_array",[pe.zero(),pe.zero(),pe.zero(),pe.zero(),pe.zero(),pe.zero(),pe.zero(),pe.zero()]);f(this,"__hCorners",[q.fromCopy4(-1,1,1,1),q.fromCopy4(1,1,1,1),q.fromCopy4(1,-1,1,1),q.fromCopy4(-1,-1,1,1),q.fromCopy4(-1,1,-1,1),q.fromCopy4(1,1,-1,1),q.fromCopy4(1,-1,-1,1),q.fromCopy4(-1,-1,-1,1)]);f(this,"corners",[])}update(n,t){Se.multiplyTo(t,n,this.__vp),this.zNear.x=this.__vp.m20+this.__vp.m30,this.zNear.y=this.__vp.m21+this.__vp.m31,this.zNear.z=this.__vp.m22+this.__vp.m32,this.zNear.w=this.__vp.m23+this.__vp.m33,this.zFar.x=-this.__vp.m20+this.__vp.m30,this.zFar.y=-this.__vp.m21+this.__vp.m31,this.zFar.z=-this.__vp.m22+this.__vp.m32,this.zFar.w=-this.__vp.m23+this.__vp.m33,this.bottom.x=this.__vp.m10+this.__vp.m30,this.bottom.y=this.__vp.m11+this.__vp.m31,this.bottom.z=this.__vp.m12+this.__vp.m32,this.bottom.w=this.__vp.m13+this.__vp.m33,this.top.x=-this.__vp.m10+this.__vp.m30,this.top.y=-this.__vp.m11+this.__vp.m31,this.top.z=-this.__vp.m12+this.__vp.m32,this.top.w=-this.__vp.m13+this.__vp.m33,this.left.x=this.__vp.m00+this.__vp.m30,this.left.y=this.__vp.m01+this.__vp.m31,this.left.z=this.__vp.m02+this.__vp.m32,this.left.w=this.__vp.m03+this.__vp.m33,this.right.x=-this.__vp.m00+this.__vp.m30,this.right.y=-this.__vp.m01+this.__vp.m31,this.right.z=-this.__vp.m02+this.__vp.m32,this.right.w=-this.__vp.m03+this.__vp.m33,Se.invertTo(t,this.__invProjMat),Se.invertTo(n,this.__invViewMat);for(let o=0;o<8;o++)this.__invProjMat.multiplyVectorTo(this.__hCorners[o],this.__tmp_vec4_0),this.__tmp_vec4_1.x=this.__tmp_vec4_0.x/this.__tmp_vec4_0.w,this.__tmp_vec4_1.y=this.__tmp_vec4_0.y/this.__tmp_vec4_0.w,this.__tmp_vec4_1.z=this.__tmp_vec4_0.z/this.__tmp_vec4_0.w,this.__tmp_vec4_1.w=1,this.__invViewMat.multiplyVectorTo(this.__tmp_vec4_1,this.__tmp_vec4_array[o]),this.corners[o]=this.__tmp_vec4_array[o]}culling(n){let t=n.entity.getSceneGraph().worldMergedAABBWithSkeletal;for(let r=0;r<6;r++){let i=0,a=this.getPlane(r);if(i+=a.x*t.minPoint.x+a.y*t.minPoint.y+a.z*t.minPoint.z+a.w<0?1:0,i+=a.x*t.maxPoint.x+a.y*t.minPoint.y+a.z*t.minPoint.z+a.w<0?1:0,i+=a.x*t.minPoint.x+a.y*t.maxPoint.y+a.z*t.minPoint.z+a.w<0?1:0,i+=a.x*t.maxPoint.x+a.y*t.maxPoint.y+a.z*t.minPoint.z+a.w<0?1:0,i+=a.x*t.minPoint.x+a.y*t.minPoint.y+a.z*t.maxPoint.z+a.w<0?1:0,i+=a.x*t.maxPoint.x+a.y*t.minPoint.y+a.z*t.maxPoint.z+a.w<0?1:0,i+=a.x*t.minPoint.x+a.y*t.maxPoint.y+a.z*t.maxPoint.z+a.w<0?1:0,i+=a.x*t.maxPoint.x+a.y*t.maxPoint.y+a.z*t.maxPoint.z+a.w<0?1:0,i===8)return!1}let o=0;o=0;for(let r=0;r<8;r++){let i=this.corners[r];o+=i.x>t.maxPoint.x?1:0}if(o===8)return!1;o=0;for(let r=0;r<8;r++){let i=this.corners[r];o+=i.x<t.minPoint.x?1:0}if(o===8)return!1;o=0;for(let r=0;r<8;r++){let i=this.corners[r];o+=i.y>t.maxPoint.y?1:0}if(o===8)return!1;o=0;for(let r=0;r<8;r++){let i=this.corners[r];o+=i.y<t.minPoint.y?1:0}if(o===8)return!1;o=0;for(let r=0;r<8;r++){let i=this.corners[r];o+=i.z>t.maxPoint.z?1:0}if(o===8)return!1;o=0;for(let r=0;r<8;r++){let i=this.corners[r];o+=i.z<t.minPoint.z?1:0}return o!==8}getPlane(n){switch(n){case 0:return this.top;case 1:return this.bottom;case 2:return this.right;case 3:return this.left;case 4:return this.zNear;case 5:return this.zFar;default:throw new Error("Invalid plane index.")}}};h(Ch,"Frustum");hc=Ch});var Jk,rm,im=C(()=>{"use strict";Ke();Qn();Jk=h(function(m){let o=Pe.getInstance().getModule("webgl");return Z.isDataTextureApproach(m)?o.WebGLStrategyDataTexture.getInstance():(Z.isUniformApproach(m),o.WebGLStrategyUniform.getInstance())},"getRenderingStrategy"),rm=Jk});var Qs,Lt,$k,eW,tW,nW,oW,rW,iW,aW,sW,lW,cW,fW,uW,mW,_W,dW,hW,pW,xW,vW,gW,yW,bW,AW,IW,SW,vn,am=C(()=>{"use strict";st();Lt=(Qs=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(Qs,"WebGLExtensionClass"),Qs),$k=new Lt({index:1,str:"OES_vertex_array_object"}),eW=new Lt({index:2,str:"OES_texture_float"}),tW=new Lt({index:3,str:"OES_texture_half_float"}),nW=new Lt({index:4,str:"OES_texture_float_linear"}),oW=new Lt({index:5,str:"OES_texture_half_float_linear"}),rW=new Lt({index:6,str:"ANGLE_instanced_arrays"}),iW=new Lt({index:7,str:"EXT_texture_filter_anisotropic"}),aW=new Lt({index:8,str:"OES_element_index_uint"}),sW=new Lt({index:9,str:"EXT_shader_texture_lod"}),lW=new Lt({index:10,str:"OES_standard_derivatives"}),cW=new Lt({index:11,str:"WEBGL_draw_buffers"}),fW=new Lt({index:12,str:"EXT_blend_minmax"}),uW=new Lt({index:13,str:"WEBGL_color_buffer_float"}),mW=new Lt({index:14,str:"WEBGL_compressed_texture_astc"}),_W=new Lt({index:15,str:"WEBGL_compressed_texture_s3tc"}),dW=new Lt({index:16,str:"WEBGL_compressed_texture_pvrtc"}),hW=new Lt({index:17,str:"WEBGL_compressed_texture_atc"}),pW=new Lt({index:18,str:"WEBGL_compressed_texture_etc"}),xW=new Lt({index:19,str:"WEBGL_compressed_texture_etc1"}),vW=new Lt({index:20,str:"EXT_texture_compression_bptc"}),gW=new Lt({index:21,str:"GMAN_webgl_memory"}),yW=new Lt({index:22,str:"EXT_color_buffer_float"}),bW=new Lt({index:23,str:"EXT_color_buffer_half_float"}),AW=new Lt({index:24,str:"OCULUS_multiview"}),IW=new Lt({index:25,str:"OVR_multiview2"}),SW=new Lt({index:26,str:"EXT_clip_control"}),vn=Object.freeze({VertexArrayObject:$k,TextureFloat:eW,TextureHalfFloat:tW,TextureFloatLinear:nW,TextureHalfFloatLinear:oW,InstancedArrays:rW,TextureFilterAnisotropic:iW,ElementIndexUint:aW,ShaderTextureLod:sW,ShaderDerivatives:lW,DrawBuffers:cW,BlendMinmax:fW,ColorBufferFloatWebGL1:uW,CompressedTextureAstc:mW,CompressedTextureS3tc:_W,CompressedTexturePvrtc:dW,CompressedTextureAtc:hW,CompressedTextureEtc:pW,CompressedTextureEtc1:xW,CompressedTextureBptc:vW,ColorBufferFloatWebGL2:yW,ColorBufferHalfFloatWebGL2:bW,OculusMultiview:AW,OvrMultiview2:IW,GMAN_WEBGL_MEMORY:gW,ClipControl:SW})});var Ti,pc,sm,lm,xc,vc,gc,Rh,ma,cm=C(()=>{"use strict";am();It();tt();me();Ti=-1,Rh=class Rh{constructor(n,t){f(this,"__gl");f(this,"__webglVersion",1);f(this,"width",0);f(this,"height",0);f(this,"canvas");f(this,"webgl1ExtVAO");f(this,"webgl1ExtIA");f(this,"webgl1ExtTF");f(this,"webgl1ExtTHF");f(this,"webgl1ExtTFL");f(this,"webgl1ExtTHFL");f(this,"webgl1ExtTFA");f(this,"webgl1ExtEIUI");f(this,"webgl1ExtSTL");f(this,"webgl1ExtDRV");f(this,"webgl1ExtDB");f(this,"webgl1ExtBM");f(this,"webgl1ExtCBF");f(this,"webgl1ExtCTAstc");f(this,"webgl1ExtCTS3tc");f(this,"webgl1ExtCTPvrtc");f(this,"webgl1ExtCTAtc");f(this,"webgl1ExtCTEtc");f(this,"webgl1ExtCTEtc1");f(this,"webgl1ExtCTBptc");f(this,"webgl2ExtTFL");f(this,"webgl2ExtTHFL");f(this,"webgl2ExtTFA");f(this,"webgl2ExtCBF");f(this,"webgl2ExtCBHF");f(this,"webgl2ExtCTAstc");f(this,"webgl2ExtCTS3tc");f(this,"webgl2ExtCTPvrtc");f(this,"webgl2ExtCTAtc");f(this,"webgl2ExtCTEtc");f(this,"webgl2ExtCTEtc1");f(this,"webgl2ExtCTBptc");f(this,"webgl2ExtMLTVIEW");f(this,"webgl2ExtClipCtrl");f(this,"webgl2ExtGmanWM");f(this,"__activeTextureBackup",-1);f(this,"__activeTextures2D",[]);f(this,"__activeTextures2DArray",[]);f(this,"__activeTexturesCube",[]);f(this,"__boundTextures",new Map);f(this,"__boundSamplers",new Map);f(this,"__viewport_left",0);f(this,"__viewport_top",0);f(this,"__viewport_width",0);f(this,"__viewport_height",0);f(this,"__default_viewport_left",0);f(this,"__default_viewport_top",0);f(this,"__default_viewport_width",0);f(this,"__default_viewport_height",0);Yr(this,pc,Ti);Yr(this,sm,Ti);Yr(this,lm,Ti);Yr(this,xc,Ti);Yr(this,vc,Ti);Yr(this,gc,Ti);f(this,"__maxVertexUniformVectors",Ti);f(this,"__maxFragmentUniformVectors",Ti);f(this,"__is_multiview");f(this,"_isWebXRMode",!1);f(this,"__extensions",new Map);this.__gl=n,this.width=t.width,this.height=t.height,this.canvas=t,this.__viewport_width=this.__default_viewport_width=this.width,this.__viewport_height=this.__default_viewport_height=this.height,this.__is_multiview=!0,this.__gl.constructor.name==="WebGL2RenderingContext"&&(this.__webglVersion=2,this.webgl2ExtTFL=this.__getExtension(vn.TextureFloatLinear),this.webgl2ExtTHFL=this.__getExtension(vn.TextureHalfFloatLinear),this.webgl2ExtTFA=this.__getExtension(vn.TextureFilterAnisotropic),this.webgl2ExtCBF=this.__getExtension(vn.ColorBufferFloatWebGL2),this.webgl2ExtCBHF=this.__getExtension(vn.ColorBufferHalfFloatWebGL2),this.webgl2ExtCTAstc=this.__getCompressedTextureExtension(vn.CompressedTextureAstc),this.webgl2ExtCTS3tc=this.__getCompressedTextureExtension(vn.CompressedTextureS3tc),this.webgl2ExtCTPvrtc=this.__getCompressedTextureExtension(vn.CompressedTexturePvrtc),this.webgl2ExtCTAtc=this.__getCompressedTextureExtension(vn.CompressedTextureAtc),this.webgl2ExtCTEtc=this.__getCompressedTextureExtension(vn.CompressedTextureEtc),this.webgl2ExtCTEtc1=this.__getCompressedTextureExtension(vn.CompressedTextureEtc1),this.webgl2ExtCTBptc=this.__getCompressedTextureExtension(vn.CompressedTextureBptc),this.webgl2ExtMLTVIEW=this.__getExtension(vn.OculusMultiview),this.webgl2ExtMLTVIEW?this.webgl2ExtMLTVIEW.is_multisample=!0:(this.webgl2ExtMLTVIEW=this.__getExtension(vn.OvrMultiview2),this.webgl2ExtMLTVIEW?this.webgl2ExtMLTVIEW.is_multisample=!1:(F.cgApiDebugConsoleOutput&&N.info("OCULUS_multiview and OVR_multiview2 extensions are not supported"),this.__is_multiview=!1)),this.webgl2ExtClipCtrl=this.__getExtension(vn.ClipControl),this.webgl2ExtGmanWM=this.__getExtension(vn.GMAN_WEBGL_MEMORY)),this.__getUniformBufferInfo(),this.__getMaxUniformVectors()}getRawContext(){return this.__gl}getRawContextAsWebGL1(){return this.__gl}getRawContextAsWebGL2(){return this.__gl}get viewport(){return q.fromCopyArray([this.__viewport_left,this.__viewport_top,this.__viewport_width,this.__viewport_height])}get defaultViewport(){return q.fromCopyArray([this.__default_viewport_left,this.__default_viewport_top,this.__default_viewport_width,this.__default_viewport_height])}isSupportWebGL1Extension(n){return!!this.__getExtension(n)}isNotSupportWebGL1Extension(n){return!this.isSupportWebGL1Extension(n)}getIsWebGL2(n){return this.isWebGL2}get isWebGL2(){return this.__webglVersion===2}createVertexArray(){return this.getIsWebGL2(this.__gl)?this.__gl.createVertexArray():this.webgl1ExtVAO!=null?this.webgl1ExtVAO.createVertexArrayOES():void 0}deleteVertexArray(n){this.getIsWebGL2(this.__gl)?this.__gl.deleteVertexArray(n):this.webgl1ExtVAO!=null&&this.webgl1ExtVAO.deleteVertexArrayOES(n)}bindVertexArray(n){this.getIsWebGL2(this.__gl)?this.__gl.bindVertexArray(n):this.webgl1ExtVAO!=null&&this.webgl1ExtVAO.bindVertexArrayOES(n)}vertexAttribDivisor(n,t){this.getIsWebGL2(this.__gl)?this.__gl.vertexAttribDivisor(n,t):this.webgl1ExtIA.vertexAttribDivisorANGLE(n,t)}drawElementsInstanced(n,t,o,r,i){this.__gl.drawElementsInstanced(n,t,o,r,i)}drawArraysInstanced(n,t,o,r){this.__gl.drawArraysInstanced(n,t,o,r)}colorAttachment(n){return 36064+n}drawBuffers(n){let t=this.__gl;if(n.length===0){t.drawBuffers([t.NONE]);return}let o=n[0].webGLConstantValue();t.drawBuffers(n.map(r=>r.webGLConstantValue())),o===t.NONE||n.length===0?t.colorMask(!1,!1,!1,!1):t.colorMask(!0,!0,!0,!0)}__activeTexture(n){this.__activeTextureBackup!==n&&(this.__gl.activeTexture(this.__gl.TEXTURE0+n),this.__activeTextureBackup=n)}bindTexture2D(n,t){this.__boundTextures.get(n)!==t&&(this.__activeTexture(n),this.__gl.bindTexture(this.__gl.TEXTURE_2D,t),this.__boundTextures.set(n,t)),this.__activeTextures2D[n]=t}bindTexture2DArray(n,t){this.__boundTextures.get(n)!==t&&(this.__activeTexture(n),this.__gl.bindTexture(this.__gl.TEXTURE_2D_ARRAY,t),this.__boundTextures.set(n,t)),this.__activeTextures2DArray[n]=t}bindTextureSampler(n,t){this.__gl.bindSampler(n,t),this.__boundSamplers.set(n,t)}bindTextureCube(n,t){this.__boundTextures.get(n)!==t&&(this.__activeTexture(n),this.__gl.bindTexture(this.__gl.TEXTURE_CUBE_MAP,t),this.__boundTextures.set(n,t)),this.__activeTexturesCube[n]=t}unbindTexture2D(n){this.__activeTexture(n),this.__gl.bindTexture(this.__gl.TEXTURE_2D,null),this.__boundTextures.delete(n),delete this.__activeTextures2D[n]}unbindTexture2DArray(n){this.__activeTexture(n),this.__gl.bindTexture(this.__gl.TEXTURE_2D_ARRAY,null),this.__boundTextures.delete(n),delete this.__activeTextures2DArray[n]}unbindTextureCube(n){this.__activeTexture(n),this.__gl.bindTexture(this.__gl.TEXTURE_CUBE_MAP,null),this.__boundTextures.delete(n),delete this.__activeTexturesCube[n]}unbindTextures(){for(let n=0;n<this.__activeTextures2D.length;n++)this.__activeTextures2D[n]!=null&&(this.__activeTexture(15),this.__gl.bindTexture(this.__gl.TEXTURE_2D,null),delete this.__activeTextures2D[n]);for(let n=0;n<this.__activeTextures2DArray.length;n++)this.__activeTextures2DArray[n]!=null&&(this.__activeTexture(15),this.__gl.bindTexture(this.__gl.TEXTURE_2D_ARRAY,null),delete this.__activeTextures2DArray[n]);for(let n=0;n<this.__activeTexturesCube.length;n++)this.__activeTexturesCube[n]!=null&&(this.__activeTexture(15),this.__gl.bindTexture(this.__gl.TEXTURE_CUBE_MAP,null),delete this.__activeTexturesCube[n])}__getExtension(n){let t=this.__gl;if(!this.__extensions.has(n)){let o=t.getExtension(n.toString());if(o==null&&F.cgApiDebugConsoleOutput){let r=`${n.toString()} Not Available in this environment`;N.info(r)}return this.__extensions.set(n,o),o}return this.__extensions.get(n)}__getCompressedTextureExtension(n){var o,r;let t=this.__gl;if(!this.__extensions.has(n)){let i=n.toString(),a=(r=(o=t.getExtension(i))!=null?o:t.getExtension("MOZ_"+i))!=null?r:t.getExtension("WEBKIT_"+i);if(a==null&&F.cgApiDebugConsoleOutput){let s=`${n.toString()} Not Available in this environment`;N.info(s)}else this.__extensions.set(n,a);return a}return this.__extensions.get(n)}setViewport(n,t,o,r){let i=this.__gl;(this.__viewport_width!==o||this.__viewport_height!==r||this.__viewport_left!==n||this.__viewport_top!==t)&&(i.viewport(n,t,o,r),this.__viewport_left=n,this.__viewport_top=t,this.__viewport_width=o,this.__viewport_height=r)}setViewportAsVector4(n){let t=this.__gl;(this.__viewport_width!==n.z||this.__viewport_height!==n.w||this.__viewport_left!==n.x||this.__viewport_top!==n.y)&&(t.viewport(n.x,n.y,n.z,n.w),this.__viewport_left=n.x,this.__viewport_top=n.y,this.__viewport_width=n.z,this.__viewport_height=n.w)}__getUniformBufferInfo(){if(!this.isWebGL2)return;let n=this.__gl,t=n.getParameter(n.UNIFORM_BUFFER_OFFSET_ALIGNMENT),o=n.getParameter(n.MAX_UNIFORM_BLOCK_SIZE);Fr(this,xc,n.getParameter(n.MAX_VERTEX_UNIFORM_BLOCKS)),Fr(this,vc,n.getParameter(n.MAX_FRAGMENT_UNIFORM_BLOCKS)),Fr(this,gc,Math.min(Do(this,xc),Do(this,vc))),Fr(this,pc,o-o%t),Fr(this,lm,t),Fr(this,sm,o)}__getMaxUniformVectors(){let n=this.getRawContext();this.__maxVertexUniformVectors=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),this.__maxVertexUniformVectors=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)}getMaxConventionUniformBlocks(){return Do(this,gc)}getAlignedMaxUniformBlockSize(){return Do(this,pc)}getMaxVertexUniformVectors(){return this.__maxVertexUniformVectors}getMaxFragmentUniformVectors(){return this.__maxFragmentUniformVectors}getWebGLMemoryInfo(){if(this.webgl2ExtGmanWM)return this.webgl2ExtGmanWM.getMemoryInfo()}isMultiview(){return this.__is_multiview&&F.multiViewForWebVR}};pc=new WeakMap,sm=new WeakMap,lm=new WeakMap,xc=new WeakMap,vc=new WeakMap,gc=new WeakMap,h(Rh,"WebGLContextWrapper");ma=Rh});var _a,mn,Sr=C(()=>{"use strict";zn();Lo();xe();Su();se();ge();pn();_a=class _a extends nt{constructor(){super();f(this,"__width",0);f(this,"__height",0);f(this,"__level",0);f(this,"__mipLevelCount",1);f(this,"__internalFormat",oe.RGBA8);f(this,"__format",ue.RGBA);f(this,"__type",I.UnsignedByte);f(this,"__hasTransparentPixels",!1);f(this,"__textureUid");f(this,"__img");f(this,"__isTextureReady",!1);f(this,"__startedToLoad",!1);f(this,"__htmlImageElement");f(this,"__htmlCanvasElement");f(this,"__canvasContext");f(this,"__uri");f(this,"__name","untitled");f(this,"_textureResourceUid",-1);f(this,"_samplerResourceUid",-1);f(this,"_textureViewResourceUid",-1);f(this,"_textureViewAsRenderTargetResourceUid",-1);f(this,"_recommendedTextureSampler");this.__textureUid=++_a.__textureUidCount}get textureUID(){return this.__textureUid}get width(){return this.__width}getWidthAtMipLevel(t){return Math.max(1,Math.floor(this.__width/Math.pow(2,t)))}getHeightAtMipLevel(t){return Math.max(1,Math.floor(this.__height/Math.pow(2,t)))}set width(t){this.__width=t}get height(){return this.__height}set height(t){this.__height=t}get isTextureReady(){return this.__isTextureReady}get startedToLoad(){return this.__startedToLoad}get htmlImageElement(){return this.__htmlImageElement}get htmlCanvasElement(){let t=document.createElement("canvas"),o=t==null?void 0:t.getContext("2d");return this.__htmlCanvasElement=t,A.exist(o)&&A.exist(this.__htmlImageElement)&&(t.width=this.__htmlImageElement.width,t.height=this.__htmlImageElement.height,o.drawImage(this.__htmlImageElement,0,0,this.__htmlImageElement.width,this.__htmlImageElement.height)),this.__htmlCanvasElement}get uri(){return this.__uri}set name(t){this.__name=t}get name(){return this.__name}getImageData(t,o,r,i){return this.__canvasContext===void 0&&this.createInternalCanvasContext(),this.__canvasContext.getImageData(t,o,r,i)}getPixelAs(t,o,r){let a=this.getImageData(t,o,1,1).data;return r.compositionType===b.Vec4?new r(new Float32Array([a[0],a[1],a[2],a[3]])):new r(new Float32Array([a[0],a[1],a[2]]))}getPixelAsArray(t,o){return this.getImageData(t,o,1,1).data}setPixel(t,o,r){let i=this.getImageData(t,o,1,1),a=i.data,l=r.constructor.compositionType.getNumberOfComponents();for(let c=0;c<l;c++)a[c]=r.at(c);this.__canvasContext.putImageData(i,t,o)}setPixelAtChannel(t,o,r,i){let a=this.getImageData(t,o,1,1),s=a.data;s[r]=i,this.__canvasContext.putImageData(a,t,o)}get isTransparent(){return this.__hasTransparentPixels}createInternalCanvasContext(){let t;this.__htmlCanvasElement!=null?t=this.__htmlCanvasElement:(t=document.createElement("canvas"),t.width=this.width,t.height=this.height),this.__htmlCanvasElement=t,this.__canvasContext=t.getContext("2d")}getTextureDataFloat(t){let o=this.getImageData(0,0,this.width,this.height),r=new Jr(this.width,this.height,t),i=o.data;for(let a=0;a<this.height;a++)for(let s=0;s<this.width;s++)for(let l=0;l<t;l++)r.setPixelAtChannel(s,a,l,i[a*this.width*4+s*4+l]/255);return r}};h(_a,"AbstractTexture"),f(_a,"InvalidTextureUid",-1),f(_a,"__textureUidCount",_a.InvalidTextureUid);mn=_a});var TW,K,Ze=C(()=>{"use strict";Ke();TW=Z.None,K={currentProcessApproach:TW,viewportAspectRatio:0,webgpuRenderBundleMode:!1}});var Nh,Jo,yc=C(()=>{"use strict";Sr();ft();It();Ze();Ke();pn();Nh=class Nh extends mn{constructor(){super();f(this,"__fbo")}create({width:t,height:o,mipLevelCount:r,format:i}){this.__width=t,this.__height=o,this.__mipLevelCount=r!=null?r:Math.floor(Math.log2(Math.max(t,o)))+1;let{format:a,type:s}=oe.getPixelFormatAndComponentTypeFromTextureFormat(i);this.__internalFormat=i,this.__format=a,this.__type=s,this.__createRenderTargetTexture()}set _fbo(t){this.__fbo=t}get fbo(){return this.__fbo}__createRenderTargetTexture(){let t=G.getCgApiResourceRepository(),o=t.createRenderTargetTexture({width:this.__width,height:this.__height,mipLevelCount:this.__mipLevelCount,format:this.__internalFormat});this._textureResourceUid=o,K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=t.createTextureView2d(this._textureResourceUid),this._textureViewAsRenderTargetResourceUid=t.createTextureViewAsRenderTarget(this._textureResourceUid))}resize(t,o){this.destroy3DAPIResources(),this.__width=t,this.__height=o,this.__createRenderTargetTexture()}destroy3DAPIResources(){return G.getCgApiResourceRepository().deleteTexture(this._textureResourceUid),this._textureResourceUid=G.InvalidCGAPIResourceUid,!0}async getTexturePixelData(){return G.getCgApiResourceRepository().getTexturePixelData(this._textureResourceUid,this.__width,this.__height,this.__fbo.framebufferUID,this.__fbo.whichColorAttachment(this))}async downloadTexturePixelData(){let t=await this.getTexturePixelData(),o=document.createElement("canvas");o.width=this.__width,o.height=this.__height;let r=o.getContext("2d"),i=new ImageData(new Uint8ClampedArray(t.buffer),this.__width,this.__height);r.putImageData(i,this.__width,this.__height);let a=o.toDataURL("image/png"),s=document.createElement("a"),l=document.createEvent("MouseEvent");s.href=a,s.download="texture.png",l.initEvent("click",!0,!0),s.dispatchEvent(l)}async getPixelValueAt(t,o,r){let i=r;return i||(i=await this.getTexturePixelData()),q.fromCopyArray([i[(o*this.width+t)*4+0],i[(o*this.width+t)*4+1],i[(o*this.width+t)*4+2],i[(o*this.width+t)*4+3]])}generateMipmaps(){G.getCgApiResourceRepository().generateMipmaps2d(this._textureResourceUid,this.width,this.height)}createCubeTextureViewAsRenderTarget(t,o){}};h(Nh,"RenderTargetTexture");Jo=Nh});var Ph,Ge,Pn=C(()=>{"use strict";un();ft();Ph=class Ph{constructor(n){f(this,"__minFilter");f(this,"__magFilter");f(this,"__wrapS");f(this,"__wrapT");f(this,"__wrapR");f(this,"__anisotropy");f(this,"__shadowCompareMode");f(this,"__samplerResourceUid",-1);var t,o,r;this.__minFilter=n.minFilter,this.__magFilter=n.magFilter,this.__wrapS=n.wrapS,this.__wrapT=n.wrapT,this.__wrapR=(t=n.wrapR)!=null?t:U.Repeat,this.__anisotropy=(o=n.anisotropy)!=null?o:!0,this.__shadowCompareMode=(r=n.shadowCompareMode)!=null?r:!1}create(){let n=G.getCgApiResourceRepository();this.__samplerResourceUid=n==null?void 0:n.createTextureSampler({minFilter:this.__minFilter,magFilter:this.__magFilter,wrapS:this.__wrapS,wrapT:this.__wrapT,wrapR:this.__wrapR,anisotropy:this.__anisotropy,shadowCompareMode:this.__shadowCompareMode})}get created(){return this.__samplerResourceUid!==-1}get minFilter(){return this.__minFilter}get magFilter(){return this.__magFilter}get wrapS(){return this.__wrapS}get wrapT(){return this.__wrapT}get wrapR(){return this.__wrapR}get _samplerResourceUid(){return this.__samplerResourceUid}};h(Ph,"Sampler");Ge=Ph});var EW,CW,bc,Xs,p2=C(()=>{"use strict";me();EW=["#version 300 es","uniform vec2 u_offset;","uniform vec2 u_scale;","out mediump vec3 v_texcoord;","void main() {","    const float eye_offset_x[12] = float[12] (","        0.0, 0.0, 0.0, 0.0, 0.0, 0.0,","        1.0, 1.0, 1.0, 1.0, 1.0, 1.0","    );","    const vec3 quad_positions[12] = vec3[12]","    (","        vec3(0.0, 0.0, 0.0),","        vec3(1.0, 0.0, 0.0),","        vec3(0.0, 1.0, 0.0),","        vec3(0.0, 1.0, 0.0),","        vec3(1.0, 0.0, 0.0),","        vec3(1.0, 1.0, 0.0),","        vec3(0.0, 0.0, 1.0),","        vec3(1.0, 0.0, 1.0),","        vec3(0.0, 1.0, 1.0),","        vec3(0.0, 1.0, 1.0),","        vec3(1.0, 0.0, 1.0),","        vec3(1.0, 1.0, 1.0)","    );","    const vec2 pos_scale = vec2(0.5, 1.0);","    vec2 eye_offset = vec2(eye_offset_x[gl_VertexID], 0.0);","    gl_Position = vec4(((quad_positions[gl_VertexID].xy * u_scale + u_offset) * pos_scale * 2.0) - 1.0 + eye_offset, 0.0, 1.0);","    v_texcoord = vec3(quad_positions[gl_VertexID].xy * u_scale + u_offset, quad_positions[gl_VertexID].z);","}"].join(`
`),CW=["#version 300 es","uniform mediump sampler2DArray u_source_texture;","in mediump vec3 v_texcoord;","out mediump vec4 output_color;","void main()","{","    output_color = texture(u_source_texture, v_texcoord);","}"].join(`
`),bc=class bc{constructor(n){f(this,"__gl");f(this,"__vertexShader");f(this,"__fragmentShader");f(this,"__program");f(this,"__attrib");f(this,"__uniform");this.__gl=n,this.__program=n.createProgram(),this.__attachShaderSource(EW,n.VERTEX_SHADER),this.__attachShaderSource(CW,n.FRAGMENT_SHADER),this.__gl.linkProgram(this.__program),this.__bindAttribLocation({v_texcoord:0}),this.__getUniformLocations()}static getInstance(n){return this.__instance||(this.__instance=new bc(n)),this.__instance}__attachShaderSource(n,t){let o=this.__gl,r;switch(t){case o.VERTEX_SHADER:this.__vertexShader=o.createShader(t),r=this.__vertexShader;break;case o.FRAGMENT_SHADER:this.__fragmentShader=o.createShader(t),r=this.__fragmentShader;break;default:N.error("Invalid Shader Type: "+t);return}o.attachShader(this.__program,r),o.shaderSource(r,n),o.compileShader(r)}__bindAttribLocation(n){let t=this.__gl;if(n){this.__attrib={};for(let o in n)t.bindAttribLocation(this.__program,n[o],o),this.__attrib[o]=n[o]}}__getUniformLocations(){let n=this.__gl;if(this.__uniform==null){this.__uniform={};let t=n.getProgramParameter(this.__program,n.ACTIVE_UNIFORMS),o="";for(let r=0;r<t;r++)o=n.getActiveUniform(this.__program,r).name.replace("[0]",""),this.__uniform[o]=n.getUniformLocation(this.__program,o)}}blit(n,t,o,r,i,a,s){let l=this.__gl,c=this.__program;l.activeTexture(l.TEXTURE15),l.bindTexture(l.TEXTURE_2D_ARRAY,n),l.useProgram(c);let u=l.getParameter(l.DEPTH_TEST),_=l.getParameter(l.DEPTH_WRITEMASK);l.disable(l.SCISSOR_TEST),u&&l.disable(l.DEPTH_TEST),l.disable(l.STENCIL_TEST),l.colorMask(!0,!0,!0,!0),_&&l.depthMask(!1);let d=l.getParameter(l.VIEWPORT);l.viewport(0,0,a,s),l.uniform2f(this.__uniform.u_scale,r,i),l.uniform2f(this.__uniform.u_offset,t,o),l.uniform1i(this.__uniform.u_source_texture,15),l.drawArrays(l.TRIANGLES,0,12),l.__changedProgram=!0,l.viewport(d[0],d[1],d[2],d[3]),u&&l.enable(l.DEPTH_TEST),l.depthMask(_),l.flush()}blitFake(n,t,o,r,i,a,s){let l=this.__gl,c=this.__program;l.activeTexture(l.TEXTURE15),l.bindTexture(l.TEXTURE_2D_ARRAY,n),l.useProgram(c);let u=l.getParameter(l.VIEWPORT);l.viewport(0,0,a,s),l.uniform2f(this.__uniform.u_scale,r,i),l.uniform2f(this.__uniform.u_offset,t,o),l.uniform1i(this.__uniform.u_source_texture,15),l.drawArrays(l.TRIANGLES,0,12),l.__changedProgram=!0,l.viewport(u[0],u[1],u[2],u[3])}blit2(n,t,o,r){let i=this.__gl,a=i.createFramebuffer(),s=i.createFramebuffer();function l(c,u){let _=i.createTexture();i.bindTexture(i.TEXTURE_2D,_),i.texImage2D(i.TEXTURE_2D,0,i.RGBA,o,r,0,i.RGBA,i.UNSIGNED_BYTE,null),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST),i.bindFramebuffer(i.READ_FRAMEBUFFER,a),i.framebufferTextureLayer(i.READ_FRAMEBUFFER,i.COLOR_ATTACHMENT0,n,0,c),i.bindFramebuffer(i.DRAW_FRAMEBUFFER,s),i.framebufferTexture2D(i.DRAW_FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,_,0),i.blitFramebuffer(0,0,o,r,0,0,o,r,i.COLOR_BUFFER_BIT,i.NEAREST),i.framebufferTexture2D(i.READ_FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,_,0),i.framebufferTexture2D(i.DRAW_FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,t,0),i.blitFramebuffer(0,0,o,r,u,0,u+o,r,i.COLOR_BUFFER_BIT,i.NEAREST)}h(l,"blitTextureArrayLayer"),l(0,0),l(1,o),i.bindFramebuffer(i.FRAMEBUFFER,null)}};h(bc,"WebGLStereoUtil"),f(bc,"__instance");Xs=bc});var fm,Mh=C(()=>{"use strict";fm=function(m,n,t){return t()}("HDRImage",void 0,function(){function m(){var c=document.createElement("canvas"),u="t",_=1,d=2.2,p=null,x,v;return c.__defineGetter__("exposure",function(){return _}),c.__defineSetter__("exposure",function(y){_=y,p&&(s(p,_,d,v.data),x.putImageData(v,0,0))}),c.__defineGetter__("gamma",function(){return d}),c.__defineSetter__("gamma",function(y){d=y,p&&(s(p,_,d,v.data),x.putImageData(v,0,0))}),c.__defineGetter__("dataFloat",function(){return a(p)}),c.__defineGetter__("dataRGBE",function(){return p}),c.toHDRBlob=function(y,g,E){function w(Be,Fn,Sn){var cn=Be.createShader(Sn);return Be.shaderSource(cn,Fn),Be.compileShader(cn),cn}h(w,"createShader");function T(Be,Fn,Sn){var cn=Be.createProgram(),Dr,Br;return Be.attachShader(cn,Dr=w(Be,Fn,Be.VERTEX_SHADER)),Be.attachShader(cn,Br=w(Be,Sn,Be.FRAGMENT_SHADER)),Be.linkProgram(cn),Be.deleteShader(Dr),Be.deleteShader(Br),cn}h(T,"createProgram");var R=g&&g.match(/rgb9_e5/i)?new Uint8Array(o(a(p)).buffer):new Uint8Array(p.buffer),P=`precision highp float;
attribute vec3 position;
varying vec2 tex;
void main() { tex = position.xy/2.0+0.5; gl_Position = vec4(position, 1.0); }`,V=`precision highp float;
precision highp sampler2D;
uniform sampler2D tx;
varying vec2 tex;
void main() { gl_FragColor = texture2D(tx,tex); }`,z=this.width,k=this.height;if(z*k*4<R.byteLength)return console.error("not big enough.");var W=document.createElement("canvas");W.width=z,W.height=k;var X=W.getContext("webgl",{antialias:!1,alpha:!0,premultipliedAlpha:!1,preserveDrawingBuffer:!0}),j=X.createTexture();X.activeTexture(X.TEXTURE0),X.bindTexture(X.TEXTURE_2D,j),X.pixelStorei(X.UNPACK_FLIP_Y_WEBGL,!0),X.texParameteri(X.TEXTURE_2D,X.TEXTURE_MAG_FILTER,X.NEAREST),X.texParameteri(X.TEXTURE_2D,X.TEXTURE_MIN_FILTER,X.NEAREST),X.texParameteri(X.TEXTURE_2D,X.TEXTURE_WRAP_S,X.CLAMP_TO_EDGE),X.texParameteri(X.TEXTURE_2D,X.TEXTURE_WRAP_T,X.CLAMP_TO_EDGE),X.texImage2D(X.TEXTURE_2D,0,X.RGBA,z,k,0,X.RGBA,X.UNSIGNED_BYTE,new Uint8Array(R.buffer));var ae=T(X,P,V),le=X.getUniformLocation(ae,"tx"),ze=new Float32Array([-1,-1,0,1,-1,0,1,1,0,1,1,0,-1,1,0,-1,-1,0]),At=X.createBuffer();if(X.enableVertexAttribArray(0),X.bindBuffer(X.ARRAY_BUFFER,At),X.bufferData(X.ARRAY_BUFFER,ze,X.STATIC_DRAW),X.vertexAttribPointer(0,3,X.FLOAT,!1,0,0),X.useProgram(ae),X.uniform1i(le,0),X.drawArrays(X.TRIANGLES,0,6),X.deleteTexture(j),X.deleteProgram(ae),y)return W.toBlob(y)},c.__defineGetter__("src",function(){return u}),c.__defineSetter__("src",function(y){if(u=y,x&&x.clearRect(0,0,this.width,this.height),y.match(/\.hdr$/i))t(y,function(E,w,T){p=E,this.width=this.style.width=w,this.height=this.style.height=T,x=this.getContext("2d"),v=x.getImageData(0,0,w,T),s(E,_,d,v.data),x.putImageData(v,0,0),this.onload&&this.onload()}.bind(c));else if(y.match(/\.rgb9_e5\.png$/i)){var g=new Image;g.src=y,g.onload=function(){var E=document.createElement("canvas"),w=this.width=this.style.width=E.width=g.width,T=this.height=this.style.height=E.height=g.height,R=E.getContext("webgl"),P=R.createTexture();R.bindTexture(R.TEXTURE_2D,P),R.texImage2D(R.TEXTURE_2D,0,R.RGBA,R.RGBA,R.UNSIGNED_BYTE,g),fb=R.createFramebuffer(),R.bindFramebuffer(R.FRAMEBUFFER,fb),R.framebufferTexture2D(R.FRAMEBUFFER,R.COLOR_ATTACHMENT0,R.TEXTURE_2D,P,0);var V=new Uint8Array(w*T*4);R.readPixels(0,0,w,T,R.RGBA,R.UNSIGNED_BYTE,V),R.deleteTexture(P),R.deleteFramebuffer(fb),this.dataRAW=new Uint32Array(V.buffer),p=i(r(this.dataRAW)),x=this.getContext("2d"),v=x.getImageData(0,0,w,T),s(p,_,d,v.data),x.putImageData(v,0,0),this.onload&&this.onload()}.bind(c)}else if(y.match(/\.hdr\.png$|\.rgbe\.png/i)){var g=new Image;g.src=y,g.onload=function(){var w=document.createElement("canvas"),T=this.width=this.style.width=w.width=g.width,R=this.height=this.style.height=w.height=g.height,P=w.getContext("webgl"),V=P.createTexture();P.bindTexture(P.TEXTURE_2D,V),P.texImage2D(P.TEXTURE_2D,0,P.RGBA,P.RGBA,P.UNSIGNED_BYTE,g),fb=P.createFramebuffer(),P.bindFramebuffer(P.FRAMEBUFFER,fb),P.framebufferTexture2D(P.FRAMEBUFFER,P.COLOR_ATTACHMENT0,P.TEXTURE_2D,V,0);var z=new Uint8Array(T*R*4);P.readPixels(0,0,T,R,P.RGBA,P.UNSIGNED_BYTE,z),P.deleteTexture(V),P.deleteFramebuffer(fb),p=z,x=this.getContext("2d"),v=x.getImageData(0,0,T,R),s(p,_,d,v.data),x.putImageData(v,0,0),this.onload&&this.onload()}.bind(c)}}),c}h(m,"HDRImage");function n(c,u){for(var _ in u)c[_]=u[_];return c}h(n,"m");function t(c,u){var _=n(new XMLHttpRequest,{responseType:"arraybuffer"});return _.onerror=u.bind(_,!1),_.onload=function(){if(this.status>=400)return this.onerror();for(var d="",p=0,x=new Uint8Array(this.response),v;!d.match(/\n\n[^\n]+\n/g);)d+=String.fromCharCode(x[p++]);if(v=d.match(/FORMAT=(.*)$/m)[1],v!="32-bit_rle_rgbe")return console.warn("unknown format : "+v),this.onerror();for(var y=d.split(/\n/).reverse()[1].split(" "),g=y[3]*1,E=y[1]*1,w=new Uint8Array(g*E*4),T=0,R=0;R<E;R++){var P=x.slice(p,p+=4),V=[];if(P[0]!=2||P[1]!=2||P[2]&128){var z=g,k=0;for(p-=4;z>0;)if(w.set(x.slice(p,p+=4),T),w[T]==1&&w[T+1]==1&&w[T+2]==1){for(w[T+3]<<k;W>0;W--)w.set(w.slice(T-4,T),T),T+=4,z--;k+=8}else z--,T+=4,k=0}else{if((P[2]<<8)+P[3]!=g)return console.warn("HDR line mismatch .."),this.onerror();for(var W=0;W<4;W++)for(var X=W*g,j=(W+1)*g,ae,le;X<j;)if(ae=x.slice(p,p+=2),ae[0]>128)for(le=ae[0]-128;le-- >0;)V[X++]=ae[1];else for(le=ae[0]-1,V[X++]=ae[1];le-- >0;)V[X++]=x[p++];for(var W=0;W<g;W++)w[T++]=V[W],w[T++]=V[W+g],w[T++]=V[W+2*g],w[T++]=V[W+3*g]}}u&&u(w,g,E)},_.open("GET",c,!0),_.send(null),_}h(t,"loadHDR");function o(c,T){for(var _,d,p,x,v,y,g,E,w=c.byteLength/12|0,T=T||new Uint32Array(w),R=0;R<w;R++)_=Math.min(32768,c[R*3]),d=Math.min(32768,c[R*3+1]),p=Math.min(32768,c[R*3+2]),v=Math.max(Math.max(_,d),p),y=Math.max(-16,Math.floor(Math.log2(v)))+16,g=Math.pow(2,y-24),Math.floor(v/g+.5)==511&&(g*=2,y+=1),T[R]=(Math.floor(_/g+.5)<<23)+(Math.floor(d/g+.5)<<14)+(Math.floor(p/g+.5)<<5)+(y|0);return T}h(o,"floatToRgb9_e5");function r(c,x){for(var _,d,p=c.byteLength>>2,x=x||new Float32Array(p*3),v=0;v<p;v++)_=c[v],d=Math.pow(2,(_&31)-24),x[v*3]=(_>>>23)*d,x[v*3+1]=(_>>>14&511)*d,x[v*3+2]=(_>>>5&511)*d;return x}h(r,"rgb9_e5ToFloat");function i(c,g){for(var _,d,p,x,v,y=c.byteLength/12|0,g=g||new Uint8Array(y*4),E=0;E<y;E++)_=c[E*3],d=c[E*3+1],p=c[E*3+2],x=Math.max(Math.max(_,d),p),e=Math.ceil(Math.log2(x)),v=Math.pow(2,e-8),g[E*4]=_/v|0,g[E*4+1]=d/v|0,g[E*4+2]=p/v|0,g[E*4+3]=e+128;return g}h(i,"floatToRgbe");function a(c,p){for(var _,d=c.byteLength>>2,p=p||new Float32Array(d*3),x=0;x<d;x++)_=Math.pow(2,c[x*4+3]-136),p[x*3]=c[x*4]*_,p[x*3+1]=c[x*4+1]*_,p[x*3+2]=c[x*4+2]*_;return p}h(a,"rgbeToFloat");function s(c,u,_,y){u=Math.pow(2,u===void 0?1:u)/2,_===void 0&&(_=2.2);for(var p=1/_,x,v=c.byteLength>>2,y=y||new Uint8ClampedArray(v*4),g=0;g<v;g++)x=u*Math.pow(2,c[g*4+3]-136),y[g*4]=255*Math.pow(c[g*4]*x,p),y[g*4+1]=255*Math.pow(c[g*4+1]*x,p),y[g*4+2]=255*Math.pow(c[g*4+2]*x,p),y[g*4+3]=255;return y}h(s,"rgbeToLDR");function l(c,u,_,y){u=Math.pow(2,u===void 0?1:u)/2,_===void 0&&(_=2.2);for(var p=1/_,x,v=c.byteLength/12|0,y=y||new Uint8ClampedArray(v*4),g=0;g<v;g++)y[g*4]=255*Math.pow(c[g*3]*u,p),y[g*4+1]=255*Math.pow(c[g*3+1]*u,p),y[g*4+2]=255*Math.pow(c[g*3+2]*u,p),y[g*4+3]=255;return y}return h(l,"floatToLDR"),m.floatToRgbe=i,m.rgbeToFloat=a,m.floatToRgb9_e5=o,m.rgb9_e5ToFloat=r,m.rgbeToLDR=s,m.floatToLDR=l,m})});var Dh,eo,Ac=C(()=>{"use strict";Sr();Lo();xe();ft();It();Ze();Ke();pn();Dh=class Dh extends mn{constructor(){super();f(this,"__fbo");f(this,"__arrayLength",0)}create({width:t,height:o,level:r=0,internalFormat:i=oe.RGB8,format:a=ue.RGBA,type:s=I.UnsignedByte,arrayLength:l}){this.__width=t,this.__height=o,this.__level=r,this.__internalFormat=i,this.__format=a,this.__type=s,this.__arrayLength=l,this.__createRenderTargetTextureArray()}set _fbo(t){this.__fbo=t}get fbo(){return this.__fbo}get arrayLength(){return this.__arrayLength}__createRenderTargetTextureArray(){let t=G.getCgApiResourceRepository(),o=t.createRenderTargetTextureArray({width:this.__width,height:this.__height,level:this.__level,internalFormat:this.__internalFormat,format:this.__format,type:this.__type,arrayLength:this.__arrayLength});this._textureResourceUid=o,K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=t.createTextureView2dArray(this._textureResourceUid,this.__arrayLength),this._textureViewAsRenderTargetResourceUid=t.createTextureView2dArrayAsRenderTarget(this._textureResourceUid,0,0))}changeRenderTargetLayerWebGPU(t){if(K.currentProcessApproach===Z.WebGPU){let o=G.getCgApiResourceRepository();this._textureViewAsRenderTargetResourceUid=o.createTextureView2dArrayAsRenderTarget(this._textureResourceUid,t,0)}}resize(t,o){this.destroy3DAPIResources(),this.__width=t,this.__height=o,this.__createRenderTargetTextureArray()}destroy3DAPIResources(){return G.getCgApiResourceRepository().deleteTexture(this._textureResourceUid),this._textureResourceUid=G.InvalidCGAPIResourceUid,!0}async getTexturePixelData(){return G.getCgApiResourceRepository().getTexturePixelData(this._textureResourceUid,this.__width,this.__height,this.__fbo.framebufferUID,this.__fbo.whichColorAttachment(this))}async downloadTexturePixelData(){let t=await this.getTexturePixelData(),o=document.createElement("canvas");o.width=this.__width,o.height=this.__height;let r=o.getContext("2d"),i=new ImageData(new Uint8ClampedArray(t.buffer),this.__width,this.__height);r.putImageData(i,this.__width,this.__height);let a=o.toDataURL("image/png"),s=document.createElement("a"),l=document.createEvent("MouseEvent");s.href=a,s.download="texture.png",l.initEvent("click",!0,!0),s.dispatchEvent(l)}async getPixelValueAt(t,o,r){let i=r;return i||(i=await this.getTexturePixelData()),q.fromCopyArray([i[(o*this.width+t)*4+0],i[(o*this.width+t)*4+1],i[(o*this.width+t)*4+2],i[(o*this.width+t)*4+3]])}generateMipmaps(){G.getCgApiResourceRepository().generateMipmaps2d(this._textureResourceUid,this.width,this.height)}blitToTexture2dFromTexture2dArray(t){if(this.__arrayLength===0)return;G.getWebGLResourceRepository().blitToTexture2dFromTexture2dArray(this._textureResourceUid,t.__fbo.cgApiResourceUid,t.width,t.height)}blitToTexture2dFromTexture2dArrayFake(t){if(this.__arrayLength===0)return;G.getWebGLResourceRepository().blitToTexture2dFromTexture2dArrayFake(this._textureResourceUid,t.__fbo.cgApiResourceUid,t.width,t.height)}blitToTexture2dFromTexture2dArray2(t){if(this.__arrayLength===0)return;G.getWebGLResourceRepository().blitToTexture2dFromTexture2dArray2(this._textureResourceUid,t._textureResourceUid,t.width/2,t.height)}createCubeTextureViewAsRenderTarget(t,o){}};h(Dh,"RenderTargetTexture2DArray");eo=Dh});var Hs,to,Ei=C(()=>{"use strict";ft();Xt();Vo();Lo();se();xe();cm();yc();bi();It();ju();Vn();co();Gu();am();ge();im();tt();Qu();Pn();Ze();p2();Ke();pn();me();Mh();Ac();Hs=class Hs extends G{constructor(){super();f(this,"__webglContexts",new Map);f(this,"__glw");f(this,"__resourceCounter",G.InvalidCGAPIResourceUid);f(this,"__webglResources",new Map);f(this,"__samplerClampToEdgeLinearUid",G.InvalidCGAPIResourceUid);f(this,"__samplerClampToEdgeNearestUid",G.InvalidCGAPIResourceUid);f(this,"__samplerRepeatNearestUid",G.InvalidCGAPIResourceUid);f(this,"__samplerRepeatLinearUid",G.InvalidCGAPIResourceUid);f(this,"__samplerShadowUid",G.InvalidCGAPIResourceUid);f(this,"__samplerRepeatTriLinearUid",G.InvalidCGAPIResourceUid);f(this,"__samplerRepeatAnisotropyLinearUid",G.InvalidCGAPIResourceUid)}static getInstance(){return this.__instance||(this.__instance=new Hs),this.__instance}addWebGLContext(t,o,r){let i=new ma(t,o);this.__webglContexts.set("default",i),r&&(this.__glw=i)}generateWebGLContext(t,o,r){let i=t.getContext("webgl2",r);return this.addWebGLContext(i,t,o),on.isSafari()&&(F.isUboEnabled=!1),i}get currentWebGLContextWrapper(){return this.__glw}getResourceNumber(){return++this.__resourceCounter}__registerResource(t){let o=this.getResourceNumber();return t._resourceUid=o,this.__webglResources.set(o,t),o}getWebGLResource(t){let o=this.__webglResources.get(t);return o!=null?o:null}createIndexBuffer(t){let o=this.__glw.getRawContext();if(o==null)throw new Error("No WebGLRenderingContext set as Default.");this.__glw.bindVertexArray(null);let r=o.createBuffer(),i=this.__registerResource(r);return o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,r),o.bufferData(o.ELEMENT_ARRAY_BUFFER,t.getTypedArray(),o.STATIC_DRAW),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,null),i}updateIndexBuffer(t,o){let r=this.__glw,i=r==null?void 0:r.getRawContext();if(A.not.exist(i))throw new Error("No WebGLRenderingContext set as Default.");let a=this.__webglResources.get(o);if(A.not.exist(a))throw new Error("Not found IBO.");r.bindVertexArray(null),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,a),i.bufferSubData(i.ELEMENT_ARRAY_BUFFER,0,t.getTypedArray()),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,null)}createVertexBuffer(t){let o=this.__glw.getRawContext();if(o==null)throw new Error("No WebGLRenderingContext set as Default.");this.__glw.bindVertexArray(null);let r=o.createBuffer(),i=this.__registerResource(r);return o.bindBuffer(o.ARRAY_BUFFER,r),o.bufferData(o.ARRAY_BUFFER,t.getUint8Array(),o.STATIC_DRAW),o.bindBuffer(o.ARRAY_BUFFER,null),i}createVertexBufferFromTypedArray(t){let o=this.__glw.getRawContext();if(o==null)throw new Error("No WebGLRenderingContext set as Default.");this.__glw.bindVertexArray(null);let r=o.createBuffer(),i=this.__registerResource(r);return o.bindBuffer(o.ARRAY_BUFFER,r),o.bufferData(o.ARRAY_BUFFER,t,o.STATIC_DRAW),o.bindBuffer(o.ARRAY_BUFFER,null),i}updateVertexBuffer(t,o){let r=this.__glw,i=r==null?void 0:r.getRawContext();if(!A.exist(i))throw new Error("No WebGLRenderingContext set as Default.");let a=this.__webglResources.get(o);if(!A.exist(a))throw new Error("Not found VBO.");r.bindVertexArray(null),i.bindBuffer(i.ARRAY_BUFFER,a),i.bufferSubData(i.ARRAY_BUFFER,0,t.bufferView.getUint8Array()),i.bindBuffer(i.ARRAY_BUFFER,null)}createVertexArray(){if(this.__glw==null)throw new Error("No WebGLRenderingContext set as Default.");let o=this.__glw.createVertexArray();return A.not.exist(o)?void 0:this.__registerResource(o)}bindTexture2D(t,o){let r=this.getWebGLResource(o);this.__glw.bindTexture2D(t,r)}bindTextureSampler(t,o){if(o===-1)this.__glw.bindTextureSampler(t,null);else{let r=this.getWebGLResource(o);this.__glw.bindTextureSampler(t,r)}}bindTextureCube(t,o){let r=this.getWebGLResource(o);this.__glw.bindTextureCube(t,r)}bindTexture2DArray(t,o){let r=this.getWebGLResource(o);this.__glw.bindTexture2DArray(t,r)}createVertexBufferAndIndexBuffer(t){let o;t.hasIndices()&&(o=this.createIndexBuffer(t.indicesAccessor));let r=[];for(let a=0;a<ee.AttributeTypeNumber;a++)r[a]=!1;let i=[];return t.attributeAccessors.forEach((a,s)=>{let l=this.createVertexBuffer(a),c=ee.toAttributeSlotFromJoinedString(t.attributeSemantics[s]);r[c]=!0,i.push(l)}),{vaoHandle:-1,iboHandle:o,vboHandles:i,attributesFlags:r,setComplete:!1}}updateVertexBufferAndIndexBuffer(t,o){o.iboHandle&&this.updateIndexBuffer(t.indicesAccessor,o.iboHandle);let r=t.attributeAccessors;for(let i=0;i<r.length;i++)this.updateVertexBuffer(r[i],o.vboHandles[i])}createShaderProgram({material:t,primitive:o,vertexShaderStr:r,fragmentShaderStr:i,attributeNames:a,attributeSemantics:s,onError:l}){let c=this.__glw.getRawContext();if(c==null)throw new Error("No WebGLRenderingContext set as Default.");let u=F.cgApiDebugConsoleOutput,_=c.createShader(c.VERTEX_SHADER);if(c.shaderSource(_,r),c.compileShader(_),u&&!this.__checkShaderCompileStatus(t.materialTypeName,_,r,l))return G.InvalidCGAPIResourceUid;let d=c.createShader(c.FRAGMENT_SHADER);c.shaderSource(d,i),c.compileShader(d),u&&this.__checkShaderCompileStatus(t.materialTypeName,d,i,l);let p=c.createProgram();if(p._gl=c,p._materialTypeName=t.materialTypeName,u&&(p._vertexShaderStr=r,p._fragmentShaderStr=i),p._shaderSemanticsInfoMap=new Map,p._material=new WeakRef(t),p._primitive=new WeakRef(o),c.attachShader(p,_),c.attachShader(p,d),a.forEach((v,y)=>{c.bindAttribLocation(p,s[y].getAttributeSlot(),v)}),c.linkProgram(p),u&&!this.__checkShaderProgramLinkStatus(t.materialTypeName,p,r,i))return G.InvalidCGAPIResourceUid;p.__SPECTOR_rebuildProgram=this.rebuildProgramBySpector.bind(p);let x=this.__registerResource(p);return c.deleteShader(_),c.deleteShader(d),x}__checkShaderCompileStatus(t,o,r,i){let s=this.__glw.getRawContext();if(A.false(s.getShaderParameter(o,s.COMPILE_STATUS))&&A.false(s.isContextLost())){N.info("MaterialTypeName: "+t);let l=on.addLineNumberToCode(r);N.info(l);let c=s.getShaderInfoLog(o);return i===void 0?(N.error("An error occurred compiling the shaders:"+c),!1):(i(c),!1)}return!0}__checkShaderProgramLinkStatus(t,o,r,i){let s=this.__glw.getRawContext();if(A.false(s.getProgramParameter(o,s.LINK_STATUS))&&A.false(s.isContextLost())){N.info("MaterialTypeName: "+t),N.info(on.addLineNumberToCode("Vertex Shader:")),N.info(on.addLineNumberToCode(r)),N.info(on.addLineNumberToCode("Fragment Shader:")),N.info(on.addLineNumberToCode(i));let l=s.getProgramInfoLog(o);return N.error("Unable to initialize the shader program: "+l),!1}return!0}setupUniformLocations(t,o,r){let a=this.__glw.getRawContext(),s=this.getWebGLResource(t),l=o.length;for(let c=0;c<l;c++){let u=o[c];s._shaderSemanticsInfoMap.set(u.semantic,u)}for(let c=0;c<l;c++){let u=o[c];if(r||u.needUniformInDataTextureMode||b.isTexture(u.compositionType)){let p=u.semantic,x="u_"+u.semantic,v=a.getUniformLocation(s,x),y=s;y[p]=v,v==null&&F.cgApiDebugConsoleOutput&&N.info(`Can not get the uniform location: ${x}. The uniform may be unused by other code so implicitly removed.`)}}return s}setupBasicUniformLocations(t){let o=this.getWebGLResource(t),r=this.currentWebGLContextWrapper.getRawContext();o.dataTexture=r.getUniformLocation(o,"u_dataTexture"),o.isMainVr=r.getUniformLocation(o,"u_isMainVr"),o.currentComponentSIDs=r.getUniformLocation(o,"u_currentComponentSIDs")}setUniform1iForTexture(t,o,r){let i=t,a=i._shaderSemanticsInfoMap.get(o);if(a==null)return;let s=this.__glw.getRawContext(),l=i[o];s.uniform1i(l,r[0]),this.bindTexture(a,r)}setUniformValue(t,o,r,i){let s=t._shaderSemanticsInfoMap.get(o);if(s==null)return!1;let l=!1,c=0;s.compositionType===b.Mat3?(l=!0,c=3):s.compositionType===b.Mat4?(l=!0,c=4):s.compositionType===b.Mat3Array?(l=!0,c=3):s.compositionType===b.Mat4Array?(l=!0,c=4):c=s.compositionType.getNumberOfComponents();let u=s.compositionType===b.ScalarArray||s.compositionType===b.Vec4Array||s.compositionType===b.Vec3Array||s.compositionType===b.Vec2Array,_=b.isTexture(s.compositionType),d=o,p=!1;return _?(p=this.setUniformValueInner(t,d,s,l,c,!1,{x:i[0]}),this.bindTexture(s,i)):u?i._v==null?p=this.setUniformValueInner(t,d,s,l,c,!0,{x:i}):p=this.setUniformValueInner(t,d,s,l,c,!0,{x:i._v}):s.compositionType===b.Scalar?i._v==null?p=this.setUniformValueInner(t,d,s,l,c,!1,{x:i}):p=this.setUniformValueInner(t,d,s,l,c,!0,{x:i._v}):i._v==null?p=this.setUniformValueInner(t,d,s,l,c,!1,i):p=this.setUniformValueInner(t,d,s,l,c,!0,{x:i._v}),p}bindTexture(t,o){var r,i;if(t.compositionType===b.Texture2D||t.compositionType===b.Texture2DShadow){if(this.bindTexture2D(o[0],o[1]._textureResourceUid),o[2]!=null)this.bindTextureSampler(o[0],o[2]._samplerResourceUid);else if(t.compositionType===b.Texture2D){let a=this.createOrGetTextureSamplerClampToEdgeLinear();this.bindTextureSampler(o[0],a)}else if(t.compositionType===b.Texture2DShadow){let a=this.createOrGetTextureSamplerShadow();this.bindTextureSampler(o[0],a)}}else if(t.compositionType===b.TextureCube)if(this.bindTextureCube(o[0],o[1]._textureResourceUid),o[2]!=null)this.bindTextureSampler(o[0],o[2]._samplerResourceUid);else{let a=o[1];this.bindTextureSampler(o[0],(i=(r=a._recommendedTextureSampler)==null?void 0:r._samplerResourceUid)!=null?i:-1)}else if(t.compositionType===b.Texture2DArray)if(this.bindTexture2DArray(o[0],o[1]._textureResourceUid),o[2]!=null)this.bindTextureSampler(o[0],o[2]._samplerResourceUid);else{let a=this.createOrGetTextureSamplerClampToEdgeLinear();this.bindTextureSampler(o[0],a)}}setUniformValueInner(t,o,r,i,a,s,{x:l,y:c,z:u,w:_}){let p=t[o];if(p==null)return!1;let x=p,v=this.__glw.getRawContext();if(i)a===4?v.uniformMatrix4fv(x,!1,l):v.uniformMatrix3fv(x,!1,l);else if(s){let y=r.componentType===I.Int||r.componentType===I.Short||r.componentType===I.Byte;a===1?y?v.uniform1iv(x,l):v.uniform1fv(x,l):a===2?y?v.uniform2iv(x,l):v.uniform2fv(x,l):a===3?y?v.uniform3iv(x,l):v.uniform3fv(x,l):a===4&&(y?v.uniform4iv(x,l):v.uniform4fv(x,l))}else{let y=r.componentType===I.Int||r.componentType===I.Short||r.componentType===I.Byte;a===1?y?v.uniform1i(x,l):v.uniform1f(x,l):a===2?y?v.uniform2i(x,l,c):v.uniform2f(x,l,c):a===3?y?v.uniform3i(x,l,c,u):v.uniform3f(x,l,c,u):a===4&&(y?v.uniform4i(x,l,c,u,_):v.uniform4f(x,l,c,u,_))}return!0}setVertexDataToPipeline({vaoHandle:t,iboHandle:o,vboHandles:r},i,a=G.InvalidCGAPIResourceUid){let s=this.__glw.getRawContext(),l=this.getWebGLResource(t);if(this.__glw.bindVertexArray(l),o!=null){let c=this.getWebGLResource(o);if(c!=null)s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,c);else throw new Error("Nothing Element Array Buffer!")}if(r.forEach((c,u)=>{let _=this.getWebGLResource(c);if(_!=null)s.bindBuffer(s.ARRAY_BUFFER,_);else throw new Error("Nothing Element Array Buffer at index "+u);s.enableVertexAttribArray(ee.toAttributeSlotFromJoinedString(i.attributeSemantics[u])),s.vertexAttribPointer(ee.toAttributeSlotFromJoinedString(i.attributeSemantics[u]),i.attributeCompositionTypes[u].getNumberOfComponents(),i.attributeComponentTypes[u].index,i.attributeAccessors[u].normalized,i.attributeAccessors[u].byteStride,0)}),a!==G.InvalidCGAPIResourceUid){let c=this.getWebGLResource(a);if(c!=null)s.bindBuffer(s.ARRAY_BUFFER,c);else throw new Error("Nothing Element Array Buffer at index");s.enableVertexAttribArray(ee.Instance.getAttributeSlot()),s.vertexAttribPointer(ee.Instance.getAttributeSlot(),b.Vec4.getNumberOfComponents(),I.Float.index,!1,0,0),this.__glw.vertexAttribDivisor(ee.Instance.getAttributeSlot(),1)}s.bindBuffer(s.ARRAY_BUFFER,null),this.__glw.bindVertexArray(null),s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,null)}createTexStorage2D({levels:t,internalFormat:o,width:r,height:i}){let a=this.__glw.getRawContextAsWebGL2(),s=a.createTexture();this.__glw.bindTexture2D(15,s),a.texStorage2D(3553,t,o.index,r,i);let l=this.__registerResource(s);return this.__glw.unbindTexture2D(15),l}createTextureSampler({magFilter:t,minFilter:o,wrapS:r,wrapT:i,wrapR:a,anisotropy:s,isPremultipliedAlpha:l,shadowCompareMode:c}){let u=this.__glw.getRawContextAsWebGL2(),_=u.createSampler(),d=this.__registerResource(_);return u.samplerParameteri(_,u.TEXTURE_MIN_FILTER,o.index),u.samplerParameteri(_,u.TEXTURE_MAG_FILTER,t.index),u.samplerParameteri(_,u.TEXTURE_WRAP_S,r.index),u.samplerParameteri(_,u.TEXTURE_WRAP_T,i.index),u.samplerParameteri(_,u.TEXTURE_WRAP_R,a.index),c&&(u.samplerParameteri(_,u.TEXTURE_COMPARE_MODE,u.COMPARE_REF_TO_TEXTURE),u.samplerParameteri(_,u.TEXTURE_COMPARE_FUNC,u.LESS)),s&&this.__glw.webgl2ExtTFA&&u.samplerParameteri(_,this.__glw.webgl2ExtTFA.TEXTURE_MAX_ANISOTROPY_EXT,4),d}createOrGetTextureSamplerClampToEdgeLinear(){if(this.__samplerClampToEdgeLinearUid===G.InvalidCGAPIResourceUid){let t=this.__glw.getRawContextAsWebGL2(),o=t.createSampler(),r=this.__registerResource(o);this.__samplerClampToEdgeLinearUid=r,t.samplerParameteri(o,t.TEXTURE_MIN_FILTER,t.LINEAR),t.samplerParameteri(o,t.TEXTURE_MAG_FILTER,t.LINEAR),t.samplerParameteri(o,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.samplerParameteri(o,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.samplerParameteri(o,t.TEXTURE_WRAP_R,t.CLAMP_TO_EDGE)}return this.__samplerClampToEdgeLinearUid}createOrGetTextureSamplerClampToEdgeNearest(){if(this.__samplerClampToEdgeNearestUid===G.InvalidCGAPIResourceUid){let t=this.__glw.getRawContextAsWebGL2(),o=t.createSampler(),r=this.__registerResource(o);this.__samplerClampToEdgeNearestUid=r,t.samplerParameteri(o,t.TEXTURE_MIN_FILTER,t.NEAREST),t.samplerParameteri(o,t.TEXTURE_MAG_FILTER,t.NEAREST),t.samplerParameteri(o,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.samplerParameteri(o,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.samplerParameteri(o,t.TEXTURE_WRAP_R,t.CLAMP_TO_EDGE)}return this.__samplerClampToEdgeNearestUid}createOrGetTextureSamplerRepeatNearest(){if(this.__samplerRepeatNearestUid===G.InvalidCGAPIResourceUid){let t=this.__glw.getRawContextAsWebGL2(),o=t.createSampler(),r=this.__registerResource(o);this.__samplerRepeatNearestUid=r,t.samplerParameteri(o,t.TEXTURE_MIN_FILTER,t.NEAREST),t.samplerParameteri(o,t.TEXTURE_MAG_FILTER,t.NEAREST),t.samplerParameteri(o,t.TEXTURE_WRAP_S,t.REPEAT),t.samplerParameteri(o,t.TEXTURE_WRAP_T,t.REPEAT),t.samplerParameteri(o,t.TEXTURE_WRAP_R,t.REPEAT)}return this.__samplerRepeatNearestUid}createOrGetTextureSamplerRepeatLinear(){if(this.__samplerRepeatLinearUid===G.InvalidCGAPIResourceUid){let t=this.__glw.getRawContextAsWebGL2(),o=t.createSampler(),r=this.__registerResource(o);this.__samplerRepeatLinearUid=r,t.samplerParameteri(o,t.TEXTURE_MIN_FILTER,t.LINEAR),t.samplerParameteri(o,t.TEXTURE_MAG_FILTER,t.LINEAR),t.samplerParameteri(o,t.TEXTURE_WRAP_S,t.REPEAT),t.samplerParameteri(o,t.TEXTURE_WRAP_T,t.REPEAT),t.samplerParameteri(o,t.TEXTURE_WRAP_R,t.REPEAT)}return this.__samplerRepeatLinearUid}createOrGetTextureSamplerRepeatTriLinear(){if(this.__samplerRepeatTriLinearUid===G.InvalidCGAPIResourceUid){let t=this.__glw.getRawContextAsWebGL2(),o=t.createSampler(),r=this.__registerResource(o);this.__samplerRepeatTriLinearUid=r,t.samplerParameteri(o,t.TEXTURE_MIN_FILTER,t.LINEAR_MIPMAP_LINEAR),t.samplerParameteri(o,t.TEXTURE_MAG_FILTER,t.LINEAR),t.samplerParameteri(o,t.TEXTURE_WRAP_S,t.REPEAT),t.samplerParameteri(o,t.TEXTURE_WRAP_T,t.REPEAT),t.samplerParameteri(o,t.TEXTURE_WRAP_R,t.REPEAT)}return this.__samplerRepeatTriLinearUid}createOrGetTextureSamplerShadow(){if(this.__samplerShadowUid===G.InvalidCGAPIResourceUid){let t=this.__glw.getRawContextAsWebGL2(),o=t.createSampler(),r=this.__registerResource(o);this.__samplerShadowUid=r,t.samplerParameteri(o,t.TEXTURE_MIN_FILTER,t.NEAREST),t.samplerParameteri(o,t.TEXTURE_MAG_FILTER,t.NEAREST),t.samplerParameteri(o,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.samplerParameteri(o,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.samplerParameteri(o,t.TEXTURE_COMPARE_MODE,t.COMPARE_REF_TO_TEXTURE),t.samplerParameteri(o,t.TEXTURE_COMPARE_FUNC,t.LESS)}return this.__samplerShadowUid}createOrGetTextureSamplerRepeatAnisotropyLinear(){if(this.__samplerRepeatAnisotropyLinearUid===G.InvalidCGAPIResourceUid){let t=this.__glw.getRawContextAsWebGL2(),o=t.createSampler(),r=this.__registerResource(o);this.__samplerRepeatAnisotropyLinearUid=r,t.samplerParameteri(o,t.TEXTURE_MIN_FILTER,t.LINEAR_MIPMAP_LINEAR),t.samplerParameteri(o,t.TEXTURE_MAG_FILTER,t.LINEAR),t.samplerParameteri(o,t.TEXTURE_WRAP_S,t.REPEAT),t.samplerParameteri(o,t.TEXTURE_WRAP_T,t.REPEAT),t.samplerParameteri(o,t.TEXTURE_WRAP_R,t.REPEAT),t.samplerParameteri(o,this.__glw.webgl2ExtTFA.TEXTURE_MAX_ANISOTROPY_EXT,4)}return this.__samplerRepeatAnisotropyLinearUid}createTextureFromImageBitmapData(t,{level:o,internalFormat:r,width:i,height:a,border:s,format:l,type:c,generateMipmap:u}){let _=this.__glw.getRawContextAsWebGL2(),d=_.createTexture(),p=this.__registerResource(d);this.__glw.bindTexture2D(15,d);let x=Math.floor(Math.log2(Math.max(i,a)))+1;return _.texStorage2D(3553,x,r.index,i,a),_.texSubImage2D(_.TEXTURE_2D,0,0,0,l.index,c.index,t),this.__createTextureInner(_,i,a,u),p}__createTextureInner(t,o,r,i){t.generateMipmap(t.TEXTURE_2D),this.__glw.unbindTexture2D(15)}async createTextureFromHTMLImageElement(t,{level:o,internalFormat:r,width:i,height:a,border:s,format:l,type:c,generateMipmap:u}){let _=this.__glw.getRawContextAsWebGL2(),d=_.createTexture(),p=this.__registerResource(d);this.__glw.bindTexture2D(15,d);let x=u?Math.max(Math.log2(i),Math.log2(a)):1;return _.texStorage2D(3553,x,r.index,i,a),_.texSubImage2D(_.TEXTURE_2D,0,0,0,l.index,c.index,t),this.__createTextureInner(_,i,a,u),p}createTextureArray(t,o,r,i,a,s,l,c){let u=this.__glw.getRawContextAsWebGL2(),_=u.createTexture(),d=this.__registerResource(_);this.__glw.bindTexture2DArray(15,_),u.texStorage3D(u.TEXTURE_2D_ARRAY,i,a.index,t,o,r);for(let p=0;p<r;p++)u.texSubImage3D(u.TEXTURE_2D_ARRAY,0,0,0,p,t,o,1,s.index,l.index,c);return this.__glw.unbindTexture2DArray(15),d}allocateTexture({format:t,width:o,height:r,mipLevelCount:i}){let a=this.__glw.getRawContextAsWebGL2(),s=a.createTexture(),l=this.__registerResource(s);return this.__glw.bindTexture2D(15,s),a.texStorage2D(3553,i,t.index,o,r),this.__glw.unbindTexture2D(15),l}loadImageToMipLevelOfTexture2D({mipLevel:t,textureUid:o,format:r,type:i,xOffset:a,yOffset:s,width:l,height:c,rowSizeByPixel:u,data:_}){let d=this.__glw.getRawContextAsWebGL2(),p=this.getWebGLResource(o),x=oe.getPixelFormatFromTextureFormat(r),v=ue.getCompositionNumFromPixelFormat(x),y=new _.constructor(l*c*v);for(let g=0;g<c;g++){let E=g*u*v,w=g*l*v;for(let T=0;T<l;T++)y.set(_.subarray(E+T*v,E+(T+1)*v),w+T*v)}this.__glw.bindTexture2D(15,p),d.texSubImage2D(d.TEXTURE_2D,t,a,s,l,c,x.index,i.index,y),this.__glw.unbindTexture2D(15)}createTextureFromTypedArray(t,{level:o,internalFormat:r,width:i,height:a,border:s,format:l,type:c,generateMipmap:u}){let _=this.__glw.getRawContextAsWebGL2(),d=_.createTexture(),p=this.__registerResource(d);this.__glw.bindTexture2D(15,d);let x=u?Math.max(Math.log2(i),Math.log2(a)):1;return _.texStorage2D(3553,x,r.index,i,a),_.texSubImage2D(_.TEXTURE_2D,0,0,0,i,a,l.index,c.index,t),this.__createTextureInner(_,i,a,u),p}createCompressedTexture(t,o){let r=this.__glw.getRawContext(),i=r.createTexture(),a=this.__registerResource(i);this.__glw.bindTexture2D(15,i);let s=o.index;for(let l of t)r.compressedTexImage2D(r.TEXTURE_2D,l.level,s,l.width,l.height,0,l.buffer);return this.__glw.unbindTexture2D(15),a}createCompressedTextureFromBasis(t,{border:o,format:r,type:i}){let a,s,l=this.__glw.getRawContext(),c=l.createTexture(),u=this.__registerResource(c);this.__glw.bindTexture2D(15,c);let _=l.getExtension("WEBGL_compressed_texture_s3tc");_&&(a=On.BC3,s=_.COMPRESSED_RGBA_S3TC_DXT5_EXT);let d=l.getExtension("WEBGL_compressed_texture_etc1");d&&(a=On.ETC1,s=d.COMPRESSED_RGB_ETC1_WEBGL);let p=l.getExtension("WEBGL_compressed_texture_atc");p&&(a=On.ATC_RGBA,s=p.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL);let x=l.getExtension("WEBGL_compressed_texture_etc");x&&(a=On.ETC2,s=x.COMPRESSED_RGBA8_ETC2_EAC);let v=l.getExtension("WEBGL_compressed_texture_pvrtc")||l.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");v&&(a=On.PVRTC1_RGBA,s=v.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG);let y=l.getExtension("WEBGL_compressed_texture_astc");y&&(a=On.ASTC,s=y.COMPRESSED_RGBA_ASTC_4x4_KHR);let g=t.getNumLevels(0);for(let E=0;E<g;E++){let w=t.getImageWidth(0,E),T=t.getImageHeight(0,E),R=this.decodeBasisImage(t,a,0,E);l.compressedTexImage2D(l.TEXTURE_2D,E,s,w,T,o,R)}return this.__glw.unbindTexture2D(15),u}decodeBasisImage(t,o,r,i){let a=t.getImageTranscodedSizeInBytes(r,i,o.index),s=new Uint8Array(a);return t.transcodeImage(s,r,i,o.index,0,0)||N.error("failed to transcode the image."),s}createFrameBufferObject(){let o=this.__glw.getRawContext().createFramebuffer();return this.__registerResource(o)}attachColorBufferToFrameBufferObject(t,o,r){let i=this.__glw.getRawContextAsWebGL2(),a=this.getWebGLResource(t.framebufferUID);i.bindFramebuffer(i.FRAMEBUFFER,a);let s=this.getWebGLResource(r._textureResourceUid),l=this.__glw.colorAttachment(o);r instanceof eo?(r._fbo=t,this.__glw.webgl2ExtMLTVIEW.is_multisample?this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultisampleMultiviewOVR(i.DRAW_FRAMEBUFFER,l,s,0,4,0,r.arrayLength):this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultiviewOVR(i.DRAW_FRAMEBUFFER,l,s,0,0,r.arrayLength)):r instanceof Jo?(r._fbo=t,i.framebufferTexture2D(i.FRAMEBUFFER,l,i.TEXTURE_2D,s,0)):(r._fbo=t,i.framebufferRenderbuffer(i.FRAMEBUFFER,l,i.RENDERBUFFER,s)),i.bindFramebuffer(i.FRAMEBUFFER,null)}attachColorBufferLayerToFrameBufferObject(t,o,r,i,a){let s=this.__glw.getRawContextAsWebGL2(),l=this.getWebGLResource(t.framebufferUID);s.bindFramebuffer(s.FRAMEBUFFER,l);let c=this.getWebGLResource(r._textureResourceUid),u=this.__glw.colorAttachment(o);r._fbo=t,s.framebufferTextureLayer(s.FRAMEBUFFER,u,c,a,i),s.bindFramebuffer(s.FRAMEBUFFER,null)}attachColorBufferCubeToFrameBufferObject(t,o,r,i,a){let s=this.__glw.getRawContextAsWebGL2(),l=this.getWebGLResource(t.framebufferUID);s.bindFramebuffer(s.FRAMEBUFFER,l);let c=this.getWebGLResource(a._textureResourceUid),u=this.__glw.colorAttachment(o);a._fbo=t,s.framebufferTexture2D(s.FRAMEBUFFER,u,s.TEXTURE_CUBE_MAP_POSITIVE_X+r,c,i),s.bindFramebuffer(s.FRAMEBUFFER,null)}attachDepthBufferToFrameBufferObject(t,o){this.__attachDepthOrStencilBufferToFrameBufferObject(t,o,36096)}attachStencilBufferToFrameBufferObject(t,o){this.__attachDepthOrStencilBufferToFrameBufferObject(t,o,36128)}attachDepthStencilBufferToFrameBufferObject(t,o){this.__attachDepthOrStencilBufferToFrameBufferObject(t,o,33306)}__attachDepthOrStencilBufferToFrameBufferObject(t,o,r){let i=this.__glw.getRawContextAsWebGL2(),a=this.getWebGLResource(t.framebufferUID);i.bindFramebuffer(i.FRAMEBUFFER,a);let s=this.getWebGLResource(o._textureResourceUid);o instanceof eo?(o._fbo=t,this.__glw.webgl2ExtMLTVIEW.is_multisample?this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultisampleMultiviewOVR(i.DRAW_FRAMEBUFFER,r,s,0,4,0,o.arrayLength):this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultiviewOVR(i.DRAW_FRAMEBUFFER,r,s,0,0,o.arrayLength)):o instanceof Jo?(o._fbo=t,i.framebufferTexture2D(i.FRAMEBUFFER,r,i.TEXTURE_2D,s,0)):(o._fbo=t,i.framebufferRenderbuffer(i.FRAMEBUFFER,r,i.RENDERBUFFER,s)),i.bindFramebuffer(i.FRAMEBUFFER,null)}createRenderBuffer(t,o,r,i,a){let s=this.__glw.getRawContext(),l=s.createRenderbuffer(),c=this.__registerResource(l);return s.bindRenderbuffer(s.RENDERBUFFER,l),i?s.renderbufferStorageMultisample(s.RENDERBUFFER,a,s[r.str],t,o):s.renderbufferStorage(s.RENDERBUFFER,s[r.str],t,o),s.bindRenderbuffer(s.RENDERBUFFER,null),c}setDrawTargets(t){let o=t.getFramebuffer();if(o){let r=t.getRenderTargetColorAttachments();A.exist(r)?this.__glw.drawBuffers(r):this.__glw.drawBuffers(o.colorAttachmentsRenderBufferTargets)}else this.__glw.drawBuffers([la.Back])}bindFramebuffer(t){let o=this.__glw.getRawContext();if(t){let r=t.cgApiResourceUid,i=this.getWebGLResource(r);o.bindFramebuffer(o.FRAMEBUFFER,i)}else o.bindFramebuffer(o.FRAMEBUFFER,null)}unbindFramebuffer(){let t=this.__glw.getRawContext();t.bindFramebuffer(t.FRAMEBUFFER,null)}createRenderTargetTexture({width:t,height:o,mipLevelCount:r,format:i}){let a=this.__glw.getRawContextAsWebGL2(),s=a.createTexture(),l=this.__registerResource(s);return this.__glw.bindTexture2D(15,s),a.texStorage2D(a.TEXTURE_2D,r,i.index,t,o),this.__glw.unbindTexture2D(15),l}createRenderTargetTextureArray({width:t,height:o,level:r,internalFormat:i,format:a,type:s,arrayLength:l}){let c=this.__glw.getRawContextAsWebGL2(),u=c.createTexture(),_=this.__registerResource(u);return this.__glw.bindTexture2DArray(15,u),c.texStorage3D(c.TEXTURE_2D_ARRAY,1,i.index,t,o,l),this.__glw.unbindTexture2DArray(15),_}createRenderTargetTextureCube({width:t,height:o,mipLevelCount:r,format:i}){let a=this.__glw.getRawContextAsWebGL2(),s=a.createTexture(),l=this.__registerResource(s);return this.__glw.bindTextureCube(15,s),a.texStorage2D(a.TEXTURE_CUBE_MAP,r,i.index,t,o),this.__glw.unbindTextureCube(15),l}createCubeTexture(t,o,r,i){let a=this.__glw.getRawContext(),s=a.createTexture(),l=this.__registerResource(s);this.__glw.bindTextureCube(15,s);let c=U.ClampToEdge,u=U.ClampToEdge,_=U.Linear,d=U.Linear;o[0].posX.hdriFormat===wt.HDR_LINEAR&&this.__glw.isNotSupportWebGL1Extension(vn.TextureFloatLinear)?(t>=2?_=U.NearestMipmapNearest:_=U.Nearest,d=U.Nearest):(t>=2?_=U.LinearMipmapLinear:_=U.Linear,d=U.Linear);let p=new Ge({wrapS:c,wrapT:u,minFilter:_,magFilter:d});p.create();let x=h((v,y,g)=>{if(v.hdriFormat===wt.HDR_LINEAR){let E=this.__glw.getRawContextAsWebGL2();E.texImage2D(y,g,F.isMobile?E.RGB16F:E.RGB32F,v.width,v.height,0,E.RGB,E.FLOAT,v.dataFloat)}else v instanceof HTMLImageElement||v instanceof HTMLCanvasElement?a.texImage2D(y,g,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,v):a.texImage2D(y,g,a.RGBA,r/2**g,i/2**g,0,a.RGBA,a.UNSIGNED_BYTE,v)},"loadImageToGPU");for(let v=0;v<o.length;v++){let y=o[v];x(y.posX,a.TEXTURE_CUBE_MAP_POSITIVE_X,v),x(y.negX,a.TEXTURE_CUBE_MAP_NEGATIVE_X,v),x(y.posY,a.TEXTURE_CUBE_MAP_POSITIVE_Y,v),x(y.negY,a.TEXTURE_CUBE_MAP_NEGATIVE_Y,v),x(y.posZ,a.TEXTURE_CUBE_MAP_POSITIVE_Z,v),x(y.negZ,a.TEXTURE_CUBE_MAP_NEGATIVE_Z,v)}return this.__glw.unbindTextureCube(15),[l,p]}async createCubeTextureFromFiles(t,o,r,i){let a=this.__glw.getRawContext(),s=[],l=0,c=0;for(let u=0;u<o;u++){let _=h(()=>new Promise((x,v)=>{let y=0,g=[],E=".jpg";i===wt.HDR_LINEAR?E=".hdr":i===wt.RGBE_PNG&&(E=".RGBE.PNG");let w="_right_",T="_left_",R="_top_",P="_bottom_",V="_front_",z="_back_";r&&(w="_posx_",T="_negx_",R="_posy_",P="_negy_",V="_posz_",z="_negz_");let k=[[t+w+u+E,a.TEXTURE_CUBE_MAP_POSITIVE_X],[t+T+u+E,a.TEXTURE_CUBE_MAP_NEGATIVE_X],[t+R+u+E,a.TEXTURE_CUBE_MAP_POSITIVE_Y],[t+P+u+E,a.TEXTURE_CUBE_MAP_NEGATIVE_Y],[t+V+u+E,a.TEXTURE_CUBE_MAP_POSITIVE_Z],[t+z+u+E,a.TEXTURE_CUBE_MAP_NEGATIVE_Z]];for(let W=0;W<k.length;W++){let X=k[W][1],j;i===wt.HDR_LINEAR||i===wt.RGB9_E5_PNG?j=new fm:j=new Image,j.hdriFormat=i,j.side=X,j.uri=k[W][0],j.crossOrigin="Anonymous",j.onload=()=>{y++,g.push(j),y===6&&x(g)},j.onerror=()=>{v(j.uri)},j.src=k[W][0]}}),"loadOneLevel"),d;try{d=await _()}catch{try{d=await _()}catch(v){N.error(`failed to load ${v}`)}}let p={};for(let x of d){switch(x.side){case a.TEXTURE_CUBE_MAP_POSITIVE_X:p.posX=x;break;case a.TEXTURE_CUBE_MAP_POSITIVE_Y:p.posY=x;break;case a.TEXTURE_CUBE_MAP_POSITIVE_Z:p.posZ=x;break;case a.TEXTURE_CUBE_MAP_NEGATIVE_X:p.negX=x;break;case a.TEXTURE_CUBE_MAP_NEGATIVE_Y:p.negY=x;break;case a.TEXTURE_CUBE_MAP_NEGATIVE_Z:p.negZ=x;break}u===0&&(l=x.width,c=x.height)}s.push(p)}return this.createCubeTexture(o,s,l,c)}createCubeTextureFromBasis(t,{magFilter:o=U.Linear,minFilter:r=U.LinearMipmapLinear,wrapS:i=U.Repeat,wrapT:a=U.Repeat,border:s=0}){let l=this.__glw.getRawContext(),c,u,_=l.createTexture(),d=this.__registerResource(_);this.__glw.bindTextureCube(15,_);let p=l.getExtension("WEBGL_compressed_texture_s3tc");p&&(c=On.BC3,u=p.COMPRESSED_RGBA_S3TC_DXT5_EXT);let x=l.getExtension("WEBGL_compressed_texture_etc1");x&&(c=On.ETC1,u=x.COMPRESSED_RGB_ETC1_WEBGL);let v=l.getExtension("WEBGL_compressed_texture_atc");v&&(c=On.ATC_RGBA,u=v.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL);let y=l.getExtension("WEBGL_compressed_texture_etc");y&&(c=On.ETC2,u=y.COMPRESSED_RGBA8_ETC2_EAC);let g=l.getExtension("WEBGL_compressed_texture_pvrtc")||l.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");g&&(c=On.PVRTC1_RGBA,u=g.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG);let E=l.getExtension("WEBGL_compressed_texture_astc");E&&(c=On.ASTC,u=E.COMPRESSED_RGBA_ASTC_4x4_KHR);let w=t.getNumImages(),T=t.getNumLevels(0);if(l.texParameteri(l.TEXTURE_CUBE_MAP,l.TEXTURE_WRAP_S,i.index),l.texParameteri(l.TEXTURE_CUBE_MAP,l.TEXTURE_WRAP_T,a.index),T>=2)l.texParameteri(l.TEXTURE_CUBE_MAP,l.TEXTURE_MIN_FILTER,r.index),l.texParameteri(l.TEXTURE_CUBE_MAP,l.TEXTURE_MAG_FILTER,o.index);else{let R=r;r===U.LinearMipmapLinear&&(R=U.Linear),l.texParameteri(l.TEXTURE_CUBE_MAP,l.TEXTURE_MIN_FILTER,R.index),l.texParameteri(l.TEXTURE_CUBE_MAP,l.TEXTURE_MAG_FILTER,o.index)}for(let R=0;R<T;R++)for(let P=0;P<w;P++){let V=t.getImageWidth(P,R),z=t.getImageHeight(P,R),k=this.decodeBasisImage(t,c,P,R);l.compressedTexImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X+P,R,u,V,z,s,k)}return this.__glw.unbindTextureCube(15),d}createDummyBlackCubeTexture(){let o=this.__createDummyTextureInner("iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPj/HwADBwIAMCbHYQAAAABJRU5ErkJggg=="),r=new Uint8Array(o);return this.createCubeTexture(1,[{posX:r,negX:r,posY:r,negY:r,posZ:r,negZ:r}],1,1)}createDummyCubeTexture(t="rgba(0,0,0,1)"){let o=document.createElement("canvas");o.width=1,o.height=1;let r=o.getContext("2d");return r.fillStyle=t,r.fillRect(0,0,1,1),this.createCubeTexture(1,[{posX:o,negX:o,posY:o,negY:o,posZ:o,negZ:o}],1,1)}setWebGLTextureDirectly(t){let o=t;return this.__registerResource(o)}async createTextureFromDataUri(t,{level:o,internalFormat:r,border:i,format:a,type:s,generateMipmap:l}){return new Promise(c=>{let u=new Image;t.match(/^data:/)||(u.crossOrigin="Anonymous"),u.onload=()=>{let _=u.width,d=u.height,p=this.createTextureFromHTMLImageElement(u,{level:o,internalFormat:r,width:_,height:d,border:i,format:a,type:s,generateMipmap:l});c(p)},u.src=t})}updateLevel0TextureAndGenerateMipmap(t,o,{width:r,height:i,format:a,type:s}){let l=this.getWebGLResource(t);this.__glw.bindTexture2D(15,l);let c=this.__glw.getRawContextAsWebGL2();c.texSubImage2D(c.TEXTURE_2D,0,0,0,r,i,a.index,s.index,o),c.generateMipmap(c.TEXTURE_2D),this.__glw.unbindTexture2D(15)}updateTexture(t,o,{level:r,xoffset:i,yoffset:a,width:s,height:l,format:c,type:u}){let _=this.getWebGLResource(t);this.__glw.bindTexture2D(15,_);let d=this.__glw.getRawContextAsWebGL2();d.texSubImage2D(d.TEXTURE_2D,r,0,0,s,l,c.index,u.index,o),this.__glw.unbindTexture2D(15)}deleteFrameBufferObject(t){let o=this.getWebGLResource(t),r=this.__glw.getRawContext();o!=null&&(r.deleteFramebuffer(o),this.__webglResources.delete(t))}deleteRenderBuffer(t){let o=this.__glw.getRawContext(),r=this.getWebGLResource(t);o.deleteRenderbuffer(r),this.__webglResources.delete(t)}deleteTexture(t){let o=this.getWebGLResource(t),r=this.__glw.getRawContext();o!=null&&(r.deleteTexture(o),this.__webglResources.delete(t),N.debug("gl.deleteTexture called: "+t))}createDummyTexture(t="rgba(255,255,255,1)"){let o=document.createElement("canvas");o.width=1,o.height=1;let r=o.getContext("2d");return r.fillStyle=t,r.fillRect(0,0,1,1),this.createTextureFromImageBitmapData(o,{level:0,internalFormat:oe.RGBA8,width:1,height:1,border:0,format:ue.RGBA,type:I.UnsignedByte,generateMipmap:!1})}createDummyBlackTexture(){return this.__createDummyTextureInner("iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPj/HwADBwIAMCbHYQAAAABJRU5ErkJggg==")}createDummyWhiteTexture(){return this.__createDummyTextureInner("iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5/hPwAIAgL/4d1j8wAAAABJRU5ErkJggg==")}createDummyNormalTexture(){return this.__createDummyTextureInner("iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mOsr///HwAGgAL+v1RumAAAAABJRU5ErkJggg==")}__createDummyTextureInner(t){let o=ie.base64ToArrayBuffer(t);return this.createTextureFromTypedArray(new Uint8Array(o),{level:0,internalFormat:oe.RGBA8,width:1,height:1,border:0,format:ue.RGBA,type:I.UnsignedByte,generateMipmap:!1})}generateMipmaps2d(t,o,r){let i=this.__glw.getRawContext(),a=this.getWebGLResource(t);this.__glw.bindTexture2D(15,a),i.generateMipmap(i.TEXTURE_2D),this.__glw.unbindTexture2D(15)}generateMipmapsCube(t,o,r){let i=this.__glw.getRawContext(),a=this.getWebGLResource(t);this.__glw.bindTextureCube(15,a),i.generateMipmap(i.TEXTURE_CUBE_MAP),this.__glw.unbindTextureCube(15)}async getTexturePixelData(t,o,r,i,a){let s=this.__glw.getRawContext(),l=this.getWebGLResource(i);s.bindFramebuffer(s.FRAMEBUFFER,l);let c=new Uint8Array(o*r*4);return s.readBuffer!=null&&s.readBuffer(36064+a),s.readPixels(0,0,o,r,s.RGBA,s.UNSIGNED_BYTE,c),s.bindFramebuffer(s.FRAMEBUFFER,null),c}createUniformBuffer(t){let o=this.__glw.getRawContextAsWebGL2();if(o==null)throw new Error("No WebGLRenderingContext set as Default.");let r=o.createBuffer(),i=this.__registerResource(r);return o.bindBuffer(o.UNIFORM_BUFFER,r),o.bufferData(o.UNIFORM_BUFFER,t,o.DYNAMIC_DRAW),o.bindBuffer(o.UNIFORM_BUFFER,null),i}updateUniformBuffer(t,o,r,i){let a=this.__glw.getRawContextAsWebGL2(),s=this.getWebGLResource(t);a.bindBuffer(a.UNIFORM_BUFFER,s),a.bufferSubData(a.UNIFORM_BUFFER,0,o,r,i),a.bindBuffer(a.UNIFORM_BUFFER,null)}bindUniformBlock(t,o,r){let i=this.__glw.getRawContextAsWebGL2();if(i==null)throw new Error("No WebGLRenderingContext set as Default.");let a=this.getWebGLResource(t),s=i.getUniformBlockIndex(a,o);i.uniformBlockBinding(a,s,r)}bindUniformBufferBase(t,o){let r=this.__glw.getRawContextAsWebGL2();if(r==null)throw new Error("No WebGLRenderingContext set as Default.");let i=this.getWebGLResource(o);r.bindBufferBase(r.UNIFORM_BUFFER,t,i)}deleteUniformBuffer(t){let o=this.__glw.getRawContext();o==null&&new Error("No WebGLRenderingContext set as Default.");let r=this.getWebGLResource(t);this.__webglResources.delete(t),o.deleteBuffer(r)}setupUniformBufferDataArea(t){let o=this.__glw.getRawContextAsWebGL2();o==null&&new Error("No WebGLRenderingContext set as Default.");let r=o.createBuffer(),i=this.__registerResource(r),a=this.__glw.getMaxConventionUniformBlocks(),s=this.__glw.getAlignedMaxUniformBlockSize(),l=s*a,c=new Float32Array(l/4);A.exist(t)&&c.set(t.subarray(0,c.length)),o.bindBuffer(o.UNIFORM_BUFFER,r),o.bufferData(o.UNIFORM_BUFFER,c,o.DYNAMIC_DRAW,0,0);for(let u=0;u<a;u++)o.bindBufferRange(o.UNIFORM_BUFFER,u,r,s*u,s);return o.bindBuffer(o.UNIFORM_BUFFER,null),i}getGlslRenderTargetBeginString(t){let o="";for(let r=0;r<t;r++)o+=`layout(location = ${r}) out vec4 rt${r};`;return o}getGlslRenderTargetEndString(t){return""}getGlslDataUBODefinitionString(){let t="",o=this.__glw.getMaxConventionUniformBlocks(),r=this.__glw.getAlignedMaxUniformBlockSize();for(let i=0;i<o;i++)t+=`
layout (std140) uniform Vec4Block${i} {
  vec4 vec4Block${i}[${r/4/4}];
};
`;t+=`
vec4 fetchVec4FromVec4Block(int vec4Idx) {
  int vec4IdxForEachBlock = vec4Idx % dataUBOVec4Size;
  if (vec4Idx < dataUBOVec4Size) {
    return vec4Block0[vec4IdxForEachBlock];
  }`;for(let i=1;i<o;i++)t+=`
 else if (vec4Idx < dataUBOVec4Size * ${i+1}) {
    return vec4Block${i}[vec4IdxForEachBlock];
}`;return t+=`}
`,t}getGlslDataUBOVec4SizeString(){return`const int dataUBOVec4Size = ${this.__glw.getAlignedMaxUniformBlockSize()/4/4};`}createMultiviewFramebuffer(t,o,r){if(A.not.exist(this.__glw.webgl2ExtMLTVIEW))return[-1,-1];let i=this.__glw.getRawContextAsWebGL2(),a=i.createFramebuffer(),s=this.__registerResource(a);i.bindFramebuffer(i.DRAW_FRAMEBUFFER,a);let l=i.createTexture(),c=this.__registerResource(l);i.bindTexture(i.TEXTURE_2D_ARRAY,l),i.texStorage3D(i.TEXTURE_2D_ARRAY,1,i.RGBA8,t,o,2),this.__glw.webgl2ExtMLTVIEW.is_multisample?this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultisampleMultiviewOVR(i.DRAW_FRAMEBUFFER,i.COLOR_ATTACHMENT0,l,0,r,0,2):this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultiviewOVR(i.DRAW_FRAMEBUFFER,i.COLOR_ATTACHMENT0,l,0,0,2);let u=i.createTexture();return i.bindTexture(i.TEXTURE_2D_ARRAY,u),i.texStorage3D(i.TEXTURE_2D_ARRAY,1,i.DEPTH32F_STENCIL8,t,o,2),this.__glw.webgl2ExtMLTVIEW.is_multisample?this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultisampleMultiviewOVR(i.DRAW_FRAMEBUFFER,i.DEPTH_STENCIL_ATTACHMENT,u,0,r,0,2):this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultiviewOVR(i.DRAW_FRAMEBUFFER,i.DEPTH_STENCIL_ATTACHMENT,u,0,0,2),[s,c]}createTransformFeedback(){let t=this.__glw.getRawContextAsWebGL2(),o=t.createTransformFeedback(),r=this.__registerResource(o);return t.bindTransformFeedback(t.TRANSFORM_FEEDBACK,o),r}deleteTransformFeedback(t){let o=this.__glw.getRawContextAsWebGL2(),r=this.getWebGLResource(t);o.deleteTransformFeedback(r),this.__webglResources.delete(t)}setViewport(t){var o,r;t?((o=this.__glw)==null||o.setViewportAsVector4(t),K.viewportAspectRatio=(t.z-t.x)/(t.w-t.y)):((r=this.__glw)==null||r.setViewport(0,0,this.__glw.width,this.__glw.height),K.viewportAspectRatio=this.__glw.width/this.__glw.height)}clearFrameBuffer(t){let o=this.__glw.getRawContext(),r=0;t.toClearColorBuffer&&(o.clearColor(t.clearColor.x,t.clearColor.y,t.clearColor.z,t.clearColor.w),r|=o.COLOR_BUFFER_BIT),t.toClearDepthBuffer&&(o.clearDepth(t.clearDepth),r|=o.DEPTH_BUFFER_BIT),t.toClearStencilBuffer&&(o.clearStencil(t.clearStencil),r|=o.STENCIL_BUFFER_BIT),r!==0&&o.clear(r)}deleteVertexDataResources(t){let o=this.__glw.getRawContext(),r=t.iboHandle;if(r){let l=this.getWebGLResource(r);o.deleteBuffer(l),this.__webglResources.delete(r)}let i=t.vboHandles;for(let l of i){let c=this.getWebGLResource(l);o.deleteBuffer(c),this.__webglResources.delete(l)}let a=t.vaoHandle,s=this.getWebGLResource(a);this.__glw.deleteVertexArray(s),this.__webglResources.delete(a)}deleteVertexArray(t){let o=this.getWebGLResource(t);this.__glw.deleteVertexArray(o),this.__webglResources.delete(t)}deleteVertexBuffer(t){let o=this.__glw.getRawContext(),r=this.getWebGLResource(t);o.deleteBuffer(r),this.__webglResources.delete(t)}resizeCanvas(t,o){this.__glw.width=t,this.__glw.height=o,this.__glw.canvas.width=t,this.__glw.canvas.height=o,this.__glw.setViewportAsVector4(q.fromCopyArray([0,0,t,o]))}getCanvasSize(){return[this.__glw.canvas.width,this.__glw.canvas.height]}switchDepthTest(t){let o=this.__glw.getRawContext();t?o.enable(o.DEPTH_TEST):o.disable(o.DEPTH_TEST)}rebuildProgramBySpector(t,o,r,i){let a=this._material.deref();if(A.not.exist(a)){let x="Material Not found";return N.warn(x),i(x),!1}let s=K.currentProcessApproach,l=rm(s),c=t.replace(/! =/g,"!="),u=o.replace(/! =/g,"!="),_=l._reSetupShaderForMaterialBySpector(a,this._primitive.deref(),{vertex:c,pixel:u},i);if(_<0)return!1;let p=Hs.getInstance().getWebGLResource(_);return _>0&&r(p),!0}getPixelDataFromTexture(t,o,r,i,a){let s=this.__glw.getRawContext(),l=new Uint8Array((i-o)*(a-r)*4),c=this.getWebGLResource(t),u=s.createFramebuffer();return s.bindFramebuffer(s.FRAMEBUFFER,u),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,c,0),s.readPixels(o,r,i,a,s.RGBA,s.UNSIGNED_BYTE,l),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteFramebuffer(u),l}setWebGLStateToDefault(){let t=this.__glw.getRawContextAsWebGL2();t.bindBuffer(t.ARRAY_BUFFER,null),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.bindRenderbuffer(t.RENDERBUFFER,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.bindVertexArray(null),t.clearColor(0,0,0,0),t.clearDepth(1),t.clearStencil(0),t.depthFunc(t.LESS),t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.SCISSOR_TEST),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),t.disable(t.CULL_FACE),t.frontFace(t.CCW),t.cullFace(t.BACK),t.blendColor(0,0,0,0),t.blendEquationSeparate(t.FUNC_ADD,t.FUNC_ADD),t.blendFuncSeparate(t.ONE,t.ZERO,t.ONE,t.ZERO),t.stencilOpSeparate(t.FRONT,t.KEEP,t.KEEP,t.KEEP),t.stencilOpSeparate(t.BACK,t.KEEP,t.KEEP,t.KEEP),t.stencilFuncSeparate(t.FRONT,t.ALWAYS,0,4294967295),t.stencilFuncSeparate(t.BACK,t.ALWAYS,0,4294967295),t.stencilMaskSeparate(t.FRONT,4294967295),t.stencilMaskSeparate(t.BACK,4294967295),t.colorMask(!0,!0,!0,!0),t.depthMask(!0),t.sampleCoverage(1,!1);for(let o=0;o<16;o++)t.activeTexture(t.TEXTURE0+o),t.bindTexture(t.TEXTURE_2D,null),t.bindTexture(t.TEXTURE_CUBE_MAP,null),t.bindSampler(o,null)}unbindTextureSamplers(){let t=this.__glw.getRawContextAsWebGL2();for(let o=0;o<16;o++)t.bindSampler(o,null)}isSupportMultiViewVRRendering(){return K.currentProcessApproach===Z.DataTexture?this.__glw.isMultiview():!1}blitToTexture2dFromTexture2dArray(t,o,r,i){let a=this.__glw.getRawContextAsWebGL2(),s=this.getWebGLResource(t),l=this.getWebGLResource(o);a.bindFramebuffer(a.DRAW_FRAMEBUFFER,l),Xs.getInstance(a).blit(s,0,0,1,1,r,i),a.bindFramebuffer(a.DRAW_FRAMEBUFFER,null)}blitToTexture2dFromTexture2dArrayFake(t,o,r,i){let a=this.__glw.getRawContextAsWebGL2(),s=this.getWebGLResource(t),l=this.getWebGLResource(o);a.bindFramebuffer(a.DRAW_FRAMEBUFFER,l),Xs.getInstance(a).blitFake(s,0,0,1,1,r,i),a.bindFramebuffer(a.DRAW_FRAMEBUFFER,null)}blitToTexture2dFromTexture2dArray2(t,o,r,i){let a=this.__glw.getRawContextAsWebGL2(),s=this.getWebGLResource(t),l=this.getWebGLResource(o);Xs.getInstance(a).blit2(s,l,r,i)}};h(Hs,"WebGLResourceRepository"),f(Hs,"__instance");to=Hs});var Bh,x2=C(()=>{Bh={code:`precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}
`,shaderStage:"fragment",isFragmentShader:!0}});var g2,v2=C(()=>{g2={code:`#ifdef RN_USE_INSTANCE
  @location(8) instance_ids: vec4<f32>,
#endif


#ifdef RN_USE_POSITION_FLOAT
  @location(0) position: vec3<f32>,
#endif
#ifdef RN_USE_POSITION_INT
  @location(0) position: vec3<i32>,
#endif
#ifdef RN_USE_POSITION_UINT
  @location(0) position: vec3<u32>,
#endif

#ifdef RN_USE_NORMAL
  @location(1) normal: vec3<f32>,
#endif
#ifdef RN_USE_TANGENT
  @location(2) tangent: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_0
  @location(3) texcoord_0: vec2<f32>,
#endif
#ifdef RN_USE_TEXCOORD_1
  @location(4) texcoord_1: vec2<f32>,
#endif

#ifdef RN_USE_COLOR_0_FLOAT
  @location(5) color_0: vec4<f32>,
#endif
#ifdef RN_USE_COLOR_0_INT
  @location(5) color_0: vec4<i32>,
#endif
#ifdef RN_USE_COLOR_0_UINT
  @location(5) color_0: vec4<u32>,
#endif

#ifdef RN_USE_JOINTS_0
  @location(6) joints_0: vec4<u32>,
#endif
#ifdef RN_USE_WEIGHTS_0
  @location(7) weights_0: vec4<f32>,
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
  @location(10) baryCentricCoord: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_2
  @location(11) texcoord_2: vec2<f32>,
#endif
  @builtin(vertex_index) vertexIdx : u32,

`,shaderStage:"vertex",isFragmentShader:!1}});var Fh,y2=C(()=>{Fh={code:`struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}
`,shaderStage:"fragment",isFragmentShader:!0}});var A2,b2=C(()=>{A2={code:`#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif
`,shaderStage:"fragment",isFragmentShader:!0}});var S2,I2=C(()=>{S2={code:`let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;
`,shaderStage:"fragment",isFragmentShader:!0}});var um,gn,Ci=C(()=>{"use strict";zn();um=class um extends nt{constructor(){super();f(this,"__renderPasses",[])}clone(){let t=new um;t.tryToSetUniqueName(this.uniqueName+"_cloned",!0);let o=[];for(let r of this.__renderPasses)o.push(r.clone());return t.addRenderPasses(o),t}addRenderPasses(t){for(let o of t)this.__renderPasses.push(o)}clearRenderPasses(){this.__renderPasses.length=0}get renderPasses(){return this.__renderPasses}setViewport(t){for(let o of this.__renderPasses)o.setViewport(t)}};h(um,"Expression");gn=um});var da,ha,mm=C(()=>{"use strict";zn();ge();da=class da extends nt{constructor(){super();f(this,"__expressions",[]);f(this,"__expressionsCache",[]);f(this,"__expressionQueries",[])}addExpression(t,{inputRenderPasses:o,outputs:r}={inputRenderPasses:[],outputs:[]}){if(A.exist(r))for(let i of r){let a=i.renderPass.instance;A.exist(i.renderPass.instance)?a=i.renderPass.instance:A.exist(i.renderPass.index)?a=t.renderPasses[i.renderPass.index]:A.exist(i.renderPass.uniqueName)&&(a=nt.getRnObjectByName(i.renderPass.uniqueName)),A.exist(a)&&a.setFramebuffer(i.frameBuffer)}this.__expressions.push({expression:t,inputRenderPasses:A.exist(o)?o:[]}),this.__expressionsCache.push(t)}getColorAttachmentFromInputOf(t,o={renderPass:{index:0},colorAttachmentIndex:0,framebufferType:da.FrameBuffer}){return new Promise(i=>{function*a(){let l=yield;return i(l),l}h(a,"generatorFunc");let s=a();this.__expressionQueries.push([t,o.renderPass,o.colorAttachmentIndex,s,o.framebufferType])})}resolve(){for(let[t,o,r,i,a]of this.__expressionQueries)for(let s of this.__expressions)if(t===s.expression){let l=o.instance;A.exist(o.instance)?l=o.instance:A.exist(o.index)?l=s.inputRenderPasses[o.index]:A.exist(o.uniqueName)&&(l=nt.getRnObjectByName(o.uniqueName));let c;if(a==="ResolveFrameBuffer2"?c=l.getResolveFramebuffer2():a==="ResolveFrameBuffer"?c=l.getResolveFramebuffer():a==="FrameBuffer"&&(c=l.getFramebuffer()),A.exist(c)){let u=c.getColorAttachedRenderTargetTexture(r);A.exist(u)&&(i.next(u),i.next(u))}}}clearExpressions(){this.__expressions.length=0,this.__expressionsCache.length=0}get expressions(){return this.__expressionsCache}setViewport(t){for(let o of this.__expressions)o.expression.setViewport(t)}};h(da,"Frame"),f(da,"FrameBuffer","FrameBuffer"),f(da,"ResolveFrameBuffer","ResolveFrameBuffer"),f(da,"ResolveFrameBuffer2","ResolveFrameBuffer2");ha=da});var _m=mC((Doe,T2)=>{"use strict";T2.exports=function(m){var n={};function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return m[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return h(t,"__webpack_require__"),t.m=m,t.c=n,t.d=function(o,r,i){t.o(o,r)||Object.defineProperty(o,r,{enumerable:!0,get:i})},t.r=function(o){typeof Symbol!="undefined"&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(o,"__esModule",{value:!0})},t.t=function(o,r){if(r&1&&(o=t(o)),r&8||r&4&&typeof o=="object"&&o&&o.__esModule)return o;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:o}),r&2&&typeof o!="string")for(var a in o)t.d(i,a,function(s){return o[s]}.bind(null,a));return i},t.n=function(o){var r=o&&o.__esModule?h(function(){return o.default},"getDefault"):h(function(){return o},"getModuleExports");return t.d(r,"a",r),r},t.o=function(o,r){return Object.prototype.hasOwnProperty.call(o,r)},t.p="./../../dist/",t(t.s="./src/index.ts")}({"./src/index.ts":h(function(m,n,t){"use strict";var o=this&&this.__importDefault||function(i){return i&&i.__esModule?i:{default:i}};Object.defineProperty(n,"__esModule",{value:!0});let r=o(t("./src/main/Shaderity.ts"));n.default=r.default},"./src/index.ts"),"./src/main/PreProcessor.ts":h(function(m,n,t){"use strict";var r;Object.defineProperty(n,"__esModule",{value:!0});let o=(r=class{static evaluateCondition(a){let s=/(\w+)\s*(==|!=|>|<|>=|<=)\s*(\d+)/g,l=/defined\s*\(\s*(\w+)\s*\)/g,c=/!\s*defined\s*\(\s*(\w+)\s*\)/g,u=a;u=u.replace(l,(_,d)=>this.definitions.has(d)?"true":"false"),u=u.replace(c,(_,d)=>this.definitions.has(d)?"false":"true"),u=u.replace(s,(_,d,p,x)=>{let v=this.definitions.get(d);if(v===void 0)return"false";let y=parseInt(v),g=parseInt(x);switch(p){case"==":return y===g?"true":"false";case"!=":return y!==g?"true":"false";case">":return y>g?"true":"false";case"<":return y<g?"true":"false";case">=":return y>=g?"true":"false";case"<=":return y<=g?"true":"false";default:return"false"}});try{if(!/^[a-zA-Z0-9\s\(\)!&|]+$/.test(u))throw new Error("Invalid condition");return u=u.replace(/&&/g," && ").replace(/\|\|/g," || ").replace(/!/g," ! ").replace(/\s+/g," ").trim(),Function(`return ${u}`)()}catch(_){return console.error("Error evaluating condition:",_),!1}}static process(a,s=[],l,c){let u=/#define[\t ]+(\w+)(?:[\t ]+(\S+))?/,_=/#ifdef[\t ]+(\w+)/,d=/#ifndef[\t ]+(\w+)/,p=/#if[\t ]+(.+)/,x=/#elif[\t ]+(.+)/,v=/#else/,y=/#endif/,g=[],E=!0,w=[],T=[],R=[];this.definitions.clear();for(let z of s)this.definitions.set(z,"1");let P=0,V=a.length;if(l&&(P=a.findIndex(z=>z.includes(l)),P===-1)||c&&(V=a.findIndex(z=>z.includes(c)),V===-1))return a;for(let z=0;z<P;z++){let k=a[z];R.push(k)}for(let z=P;z<V;z++){let k=a[z],W=!1;{let X=k.match(u);if(X!=null){let[j,ae,le="1"]=X;this.definitions.set(ae,le),W=!0}}{let X=k.match(_),j=k.match(d),ae=k.match(p);if(X||j||ae){g.push(E);let le="";X?le=`defined(${X[1]})`:j?le=`!defined(${j[1]})`:ae&&(le=ae[1]),w.push([le]),E?(E=this.evaluateCondition(le),T.push(E)):T.push(!1),W=!0}}{let X=k.match(x);if(X!=null){let j=X[1],ae=w[w.length-1];g[g.length-1]&&!T[T.length-1]?(E=this.evaluateCondition(j),E&&(T[T.length-1]=!0)):E=!1,ae.push(j),W=!0}}k.match(v)!=null&&(g[g.length-1]?E=!T[T.length-1]:E=!1,W=!0),k.match(y)!=null&&(E=g[g.length-1],W=!0,w.pop(),T.pop(),g.pop()),E&&!W&&R.push(k)}for(let z=V;z<a.length;z++){let k=a[z];R.push(k)}return R}},h(r,"PreProcessor"),r);n.default=o,o.definitions=new Map},"./src/main/PreProcessor.ts"),"./src/main/Reflection.ts":h(function(m,n,t){"use strict";var r;Object.defineProperty(n,"__esModule",{value:!0});let o=(r=class{constructor(a,s){this.__attributeSemanticsMap=new Map,this.__uniformSemanticsMap=new Map,this.__attributes=[],this.__varyings=[],this.__uniforms=[],this.__splittedShaderCode=a,this.__shaderStage=s,this.__setDefaultAttributeAndUniformSemanticsMap()}get attributes(){return this.__attributes}get varyings(){return this.__varyings}get uniforms(){return this.__uniforms}get attributesNames(){return this.__attributes.map(a=>a.name)}get attributesSemantics(){return this.__attributes.map(a=>a.semantic)}get attributesTypes(){return this.__attributes.map(a=>a.type)}addAttributeSemanticsMap(a){this.__attributeSemanticsMap=new Map([...this.__attributeSemanticsMap,...a])}addUniformSemanticsMap(a){this.__uniformSemanticsMap=new Map([...this.__uniformSemanticsMap,...a])}addAttributeSemantics(a,s){this.__attributeSemanticsMap.set(a,s)}addUniformSemantics(a,s){this.__uniformSemanticsMap.set(a,s)}resetAttributeSemantics(){this.__attributeSemanticsMap=new Map}resetUniformSemantics(){this.__uniformSemanticsMap=new Map}reflect(){let a=this.__splittedShaderCode,s=this.__shaderStage;for(let l of a){if(this.__matchAttribute(l,s)){this.__addAttribute(l);continue}if(this.__matchVarying(l,s)){this.__addVarying(l,s);continue}if(l.match(/^(?![\/])[\t ]*uniform[\t ]+/)){this.__addUniform(l);continue}}}__setDefaultAttributeAndUniformSemanticsMap(){this.__attributeSemanticsMap.set("position","POSITION"),this.__attributeSemanticsMap.set("color$","COLOR_0"),this.__attributeSemanticsMap.set("color_?0","COLOR_0"),this.__attributeSemanticsMap.set("texcoord$","TEXCOORD_0"),this.__attributeSemanticsMap.set("texcoord_?0","TEXCOORD_0"),this.__attributeSemanticsMap.set("texcoord_?1","TEXCOORD_1"),this.__attributeSemanticsMap.set("texcoord_?2","TEXCOORD_2"),this.__attributeSemanticsMap.set("normal","NORMAL"),this.__attributeSemanticsMap.set("tangent","TANGENT"),this.__attributeSemanticsMap.set("joint$","JOINTS_0"),this.__attributeSemanticsMap.set("bone$","JOINTS_0"),this.__attributeSemanticsMap.set("joint_?0","JOINTS_0"),this.__attributeSemanticsMap.set("bone_?0","JOINTS_0"),this.__attributeSemanticsMap.set("weight$","WEIGHTS_0"),this.__attributeSemanticsMap.set("weight_?0","WEIGHTS_0"),this.__uniformSemanticsMap.set("worldmatrix","WorldMatrix"),this.__uniformSemanticsMap.set("normalmatrix","NormalMatrix"),this.__uniformSemanticsMap.set("viewmatrix","ViewMatrix"),this.__uniformSemanticsMap.set("projectionmatrix","ProjectionMatrix"),this.__uniformSemanticsMap.set("modelviewmatrix","ModelViewMatrix")}__matchAttribute(a,s){return s!=="vertex"?!1:a.match(/^(?![\/])[\t ]*(attribute|in)[\t ]+.+;/)}__addAttribute(a){let s={name:"",type:"float",semantic:"UNKNOWN"},l=a.match(r.attributeAndVaryingTypeRegExp);if(l){let c=l[1];s.type=c;let u=l[2];s.name=u;let _=a.match(r.semanticRegExp);if(_)s.semantic=_[1];else for(let[d,p]of this.__attributeSemanticsMap)u.match(new RegExp(d,"i"))&&(s.semantic=p)}this.__attributes.push(s)}__matchVarying(a,s){return s==="vertex"?a.match(/^(?![\/])[\t ]*(varying|out)[\t ]+.+;/):a.match(/^(?![\/])[\t ]*(varying|in)[\t ]+.+;/)}__addVarying(a,s){let l={name:"",type:"float",inout:"in"},c=a.match(r.attributeAndVaryingTypeRegExp);if(c){let u=c[1];l.type=u;let _=c[2];l.name=_,l.inout=s==="vertex"?"out":"in"}this.__varyings.push(l)}__addUniform(a){let s={name:"",type:"float",semantic:"UNKNOWN"},l=a.match(r.uniformTypeRegExp);if(l){let c=l[1];s.type=c;let u=l[2];s.name=u;let _=a.match(r.semanticRegExp);if(_)s.semantic=_[1];else for(let[d,p]of this.__uniformSemanticsMap)u.match(new RegExp(d,"i"))&&(s.semantic=p)}this.__uniforms.push(s)}},h(r,"Reflection"),r);n.default=o,o.attributeAndVaryingTypeRegExp=/[\t ]+(float|int|vec2|vec3|vec4|mat2|mat3|mat4|ivec2|ivec3|ivec4)[\t ]+(\w+);/,o.uniformTypeRegExp=/[\t ]+(float|int|vec2|vec3|vec4|mat2|mat3|mat4|ivec2|ivec3|ivec4|sampler2D|samplerCube|sampler3D)[\t ]+(\w+);/,o.semanticRegExp=/<.*semantic[\t ]*=[\t ]*(\w+).*>/},"./src/main/Reflection.ts"),"./src/main/ShaderEditor.ts":h(function(m,n,t){"use strict";var r;Object.defineProperty(n,"__esModule",{value:!0});let o=(r=class{static _insertDefinition(a,s){let l=s.replace(/#define[\t ]+/,"");a.unshift(`#define ${l}`)}static _fillTemplate(a,s){let l=a.replace(/\/\*[\t ]*shaderity:[\t ]*(@{[\t ]*)(\S+)([\t ]*})[\t ]*\*\//g,"${this.$2}");return new Function("return `"+l+"`;").call(s)}},h(r,"ShaderEditor"),r);n.default=o},"./src/main/ShaderEditor.ts"),"./src/main/ShaderTransformer.ts":h(function(m,n,t){"use strict";var r;Object.defineProperty(n,"__esModule",{value:!0});let o=(r=class{static _transformToGLSLES1(a,s,l){return this.__convertOrInsertVersionGLSLES1(a),this.__removeES3Qualifier(a,l),this.__convertIn(a,s),this.__convertOut(a,s,l),this.__removePrecisionForES3(a),this.__convertTextureFunctionToES1(a,s,l),a}static _transformToGLSLES3(a,s){return this.__convertOrInsertVersionGLSLES3(a),this.__convertAttribute(a,s),this.__convertVarying(a,s),this.__convertTextureCube(a),this.__convertTexture2D(a),this.__convertTexture2DProd(a),this.__convertTexture3D(a),this.__convertTexture3DProd(a),a}static _transformTo(a,s,l,c){return a.match(/webgl2|es3/i)?this._transformToGLSLES3(s,l):a.match(/webgl1|es1/i)?this._transformToGLSLES1(s,l,c):(console.error("Invalid Version"),s)}static __convertOrInsertVersionGLSLES1(a){let s=/^(?![\/])[\t ]*#[\t ]*version[\t ]+.*/;this.__removeFirstMatchingLine(a,s),a.unshift("#version 100")}static __convertOrInsertVersionGLSLES3(a){let s=/^(?![\/])[\t ]*#[\t ]*version[\t ]+.*/;this.__removeFirstMatchingLine(a,s),a.unshift("#define GLSL_ES3"),a.unshift("#version 300 es")}static __convertIn(a,s){let l=/^(?![\/])[\t ]*in[\t ]+((highp|mediump|lowp|)[\t ]*\w+[\t ]*\w+[\t ]*;)/,c;s?c=h(function(u,_){return"varying "+_},"replaceFunc"):c=h(function(u,_){return"attribute "+_},"replaceFunc"),this.__replaceLine(a,l,c)}static __convertOut(a,s,l){if(s){let c=this.__removeOutQualifier(a,l);if(c==null)return;this.__addGLFragColor(c,a,l)}else{let c=/^(?![\/])[\t ]*out[\t ]+((highp|mediump|lowp|)[\t ]*\w+[\t ]*\w+[\t ]*;)/,u=h(function(_,d){return"varying "+d},"replaceFunc");this.__replaceLine(a,c,u)}}static __removeOutQualifier(a,s){let l=/^(?![\/])[\t ]*out[\t ]+((highp|mediump|lowp|)[\t ]*\w+[\t ]*(\w+)[\t ]*;)/,c;for(let u=0;u<a.length;u++){let _=a[u].match(l);if(_){a[u]=_[1],c=_[3];break}}return c}static __addGLFragColor(a,s,l){let c=/(.*)\}[\n\t ]*$/,u=/[\n\t ]*return[\n\t ]*;/,_=/(^|^(?![\/])[\t\n ]+)void[\t\n ]+main([\t\n ]|\(|$)/,d=`  gl_FragColor = ${a};`,p=!1;for(let x=s.length-1;x>=0;x--){let v=s[x];if(!p&&v.match(c)&&(s[x]=v.replace(c,`$1
${d}
}
`),p=!0),v.match(u)&&s.splice(x,0,d),v.match(_))break}p||this.__outError(s,s.length,"__removeOutQualifier: Not found the closing brackets for the main function",l)}static __removeES3Qualifier(a,s){this.__removeVaryingQualifier(a,s),this.__removeLayout(a)}static __removeVaryingQualifier(a,s){let l=/^(?![\/])[\t ]*(flat|smooth)[\t ]*((in|out)[\t ]+.*)/,c="__removeVaryingQualifier: glsl es1 does not support flat qualifier";for(let u=0;u<a.length;u++)a[u]=a[u].replace(l,(_,d,p)=>d==="flat"?(this.__outError(a,u+1,c,s),_):p)}static __removeLayout(a){let s=/^(?![\/])[\t ]*layout[\t ]*\([\t ]*location[\t ]*\=[\t ]*\d[\t ]*\)[\t ]+/g;this.__replaceLine(a,s,"")}static __removePrecisionForES3(a){let s=/^(?![\/])[\t ]*precision[\t ]+(highp|mediump|lowp)[\t ]+(\w+)[\t ]*;/;for(let l=0;l<a.length;l++){let c=a[l].match(s);if(c!=null){if(c[2]==="int"||c[2]==="float"||c[2]==="sampler2D"||c[2]==="samplerCube")continue;a.splice(l--,1)}}}static __convertTextureFunctionToES1(a,s,l){var c,u;let _=this.__regSymbols(),d=new RegExp(`(${_}+)textureProj(Lod|)(${_}+)`,"g"),p=new RegExp(`(${_}+)texture(Lod|)(${_}+)`,"g"),x,v=this.__createUniformSamplerMap(a,l);for(let y=0;y<a.length;y++){let g=a[y],E=g.match(/textureProj(Lod|)[\t ]*\([\t ]*(\w+),/);if(E){x=x!=null?x:this.__createArgumentSamplerMap(a,y,l);let R=E[1]==="Lod",P=s&&R?"EXT":"",V=E[2],z=(c=x==null?void 0:x.get(V))!==null&&c!==void 0?c:v.get(V);if(z!=null)if(z==="sampler2D")a[y]=a[y].replace(d,`$1texture2DProj$2${P}$3`);else{let k="__convertTextureFunctionToES1: do not support "+z+" type";this.__outError(a,y,k,l)}continue}let w=g.match(/texture(Lod|)[\t ]*\([\t ]*(\w+),/);if(w){x=x!=null?x:this.__createArgumentSamplerMap(a,y,l);let R=w[1]==="Lod",P=s&&R?"EXT":"",V=w[2],z=(u=x==null?void 0:x.get(V))!==null&&u!==void 0?u:v.get(V);if(z!=null){let k;if(z==="sampler2D")k="texture2D";else if(z==="samplerCube")k="textureCube";else{k="";let W="__convertTextureFunctionToES1: do not support "+z+" type";this.__outError(a,y,W,l)}k!==""&&(a[y]=a[y].replace(p,`$1${k}$2${P}$3`))}continue}!!g.match(/\}/)&&(x=void 0)}}static __createUniformSamplerMap(a,s){let l=new Map;for(let c=0;c<a.length;c++){let _=a[c].match(/^(?![\/])[\t ]*uniform*[\t ]*(highp|mediump|lowp|)[\t ]*(sampler\w+)[\t ]+(\w+)/);if(_){let d=_[2],p=_[3];l.get(p)&&this.__outError(a,c,"__createUniformSamplerMap: duplicate variable name",s),l.set(p,d)}}return l}static __createArgumentSamplerMap(a,s,l){var c,u;let _=new Map;for(let d=s;d>=0;d--){if(!!!a[d].match(/\{/))continue;let y=(c=this.__getBracketSection(a,d).match(/.*\((.*)\)/))===null||c===void 0?void 0:c[1];if(y==null)return;let g=y.split(","),E=/[\n\t ]*(highp|mediump|lowp|)[\n\t ]*(sampler\w+)[\n\t ]*(\w+)[\n\t ]*/;if((u=g[0].match(E))!==null&&u!==void 0?u:g[0].match(/^[\n\t ]*$/)){for(let T of g){let R=T.match(E);if(R==null)continue;let P=R[2],V=R[3];_.get(V)&&this.__outError(a,d,"__createArgumentSamplerMap: duplicate variable name",l),_.set(V,P)}break}}return _}static __getBracketSection(a,s){let l=0;for(let u=s;u>=0;u--)if(!!a[u].match(/\(/)){l=u;break}let c="";for(let u=l;u<=s;u++)c+=a[u];return c}static __convertAttribute(a,s){if(s)return;let l=/^(?![\/])[\t ]*attribute[\t ]+/g;this.__replaceLine(a,l,"in ")}static __convertVarying(a,s){let l=/^(?![\/])[\t ]*varying[\t ]+/g,c=s?"in ":"out ";this.__replaceLine(a,l,c)}static __convertTextureCube(a){let s=this.__regSymbols(),l=new RegExp(`(${s}+)(textureCube)(${s}+)`,"g");this.__replaceLine(a,l,"$1"+"texture"+"$3")}static __convertTexture2D(a){let s=this.__regSymbols(),l=new RegExp(`(${s}+)(texture2D)(${s}+)`,"g");this.__replaceLine(a,l,"$1"+"texture"+"$3")}static __convertTexture2DProd(a){let s=this.__regSymbols(),l=new RegExp(`(${s}+)(texture2DProj)(${s}+)`,"g");this.__replaceLine(a,l,"$1"+"textureProj"+"$3")}static __convertTexture3D(a){let s=this.__regSymbols(),l=new RegExp(`(${s}+)(texture3D)(${s}+)`,"g");this.__replaceLine(a,l,"$1"+"texture"+"$3")}static __convertTexture3DProd(a){let s=this.__regSymbols(),l=new RegExp(`(${s}+)(texture3DProj)(${s}+)`,"g");this.__replaceLine(a,l,"$1"+"textureProj"+"$3")}static __regSymbols(){return`[!"#$%&'()*+-.,/:;<=>?@[\\]^\`{|}~	
 ]`}static __replaceLine(a,s,l){for(let c=0;c<a.length;c++)a[c]=a[c].replace(s,l)}static __removeFirstMatchingLine(a,s){for(let l=0;l<a.length;l++)if(a[l].match(s)){a.splice(l,1);break}}static __outError(a,s,l,c){if(c){let u=`// line ${s}: ${l}
`,_=/(.*)\}[\n\t ]*$/;for(let d=a.length-1;d>=0&&!a[d].match(_);d--)if(a[d]===u)return;console.error(l),a.push(u)}else throw new Error(l)}},h(r,"ShaderTransformer"),r);n.default=o},"./src/main/ShaderTransformer.ts"),"./src/main/Shaderity.ts":h(function(m,n,t){"use strict";var _;var o=this&&this.__importDefault||function(d){return d&&d.__esModule?d:{default:d}};Object.defineProperty(n,"__esModule",{value:!0});let r=o(t("./src/main/Reflection.ts")),i=o(t("./src/main/ShaderTransformer.ts")),a=o(t("./src/main/ShaderEditor.ts")),s=o(t("./src/main/Utility.ts")),l=o(t("./src/main/ShaderityObjectCreator.ts")),c=o(t("./src/main/PreProcessor.ts")),u=(_=class{static transformToGLSLES1(p,x=!1){let v=s.default._splitByLineFeedCode(p.code),y=i.default._transformToGLSLES1(v,p.isFragmentShader,x);return{code:s.default._joinSplittedLine(y),shaderStage:p.shaderStage,isFragmentShader:p.isFragmentShader}}static transformToGLSLES3(p){let x=s.default._splitByLineFeedCode(p.code),v=i.default._transformToGLSLES3(x,p.isFragmentShader);return{code:s.default._joinSplittedLine(v),shaderStage:p.shaderStage,isFragmentShader:p.isFragmentShader}}static transformTo(p,x,v=!1){let y=s.default._splitByLineFeedCode(x.code),g=i.default._transformTo(p,y,x.isFragmentShader,v);return{code:s.default._joinSplittedLine(g),shaderStage:x.shaderStage,isFragmentShader:x.isFragmentShader}}static processPragma(p,x=[],v,y){let g=s.default._splitByLineFeedCode(p.code),E=c.default.process(g,x,v,y);return{code:s.default._joinSplittedLine(E),shaderStage:p.shaderStage,isFragmentShader:p.isFragmentShader}}static createShaderityObjectCreator(p){return new l.default(p)}static fillTemplate(p,x){let v=this.__copyShaderityObject(p);return v.code=a.default._fillTemplate(v.code,x),v}static insertDefinition(p,x){let v=this.__copyShaderityObject(p),y=s.default._splitByLineFeedCode(p.code);return a.default._insertDefinition(y,x),v.code=s.default._joinSplittedLine(y),v}static createReflectionObject(p){let x=s.default._splitByLineFeedCode(p.code);return new r.default(x,p.shaderStage)}static __copyShaderityObject(p){return{code:p.code,shaderStage:p.shaderStage,isFragmentShader:p.isFragmentShader}}},h(_,"Shaderity"),_);n.default=u},"./src/main/Shaderity.ts"),"./src/main/ShaderityObjectCreator.ts":h(function(m,n,t){"use strict";var a;var o=this&&this.__importDefault||function(s){return s&&s.__esModule?s:{default:s}};Object.defineProperty(n,"__esModule",{value:!0});let r=o(t("./src/main/Utility.ts")),i=(a=class{constructor(l){this.__functionIdCount=0,this.__defineDirectiveNames=[],this.__extensions=[],this.__globalPrecision={int:"highp",float:"highp",sampler2D:"highp",samplerCube:"highp",sampler3D:"highp",sampler2DArray:"highp",isampler2D:"highp",isamplerCube:"highp",isampler3D:"highp",isampler2DArray:"highp",usampler2D:"highp",usamplerCube:"highp",usampler3D:"highp",usampler2DArray:"highp",sampler2DShadow:"highp",samplerCubeShadow:"highp",sampler2DArrayShadow:"highp"},this.__structDefinitions=[],this.__globalConstantValues=[],this.__globalConstantStructValues=[],this.__attributes=[],this.__varyings=[],this.__uniforms=[],this.__uniformStructs=[],this.__uniformBufferObjects=[],this.__functions=[],this.__mainFunctionCode="void main() {}",this.__outputColorVariableName="renderTarget0",this.__shaderStage=l}addDefineDirective(l){if(this.__defineDirectiveNames.some(u=>u===l)){console.warn("addDefineDirective: this define directive is already set");return}this.__defineDirectiveNames.push(l)}addExtension(l,c="enable"){if(this.__extensions.some(_=>_.extensionName===l)){console.warn("addExtension: this extension is already set");return}this.__extensions.push({extensionName:l,behavior:c})}addStructDefinition(l,c){if(this.__structDefinitions.some(_=>_.structName===l)){console.error(`addStructDefinition: duplicate struct type name ${l}`);return}this.__structDefinitions.push({structName:l,memberObjects:c})}addGlobalConstantValue(l,c,u){if(this.__globalConstantValues.some(x=>x.variableName===l)){console.error(`addGlobalConstantValue: duplicate variable name ${l}`);return}if(!r.default._isValidComponentCount(c,u)){console.error(`addGlobalConstantValue: the component count of ${l} is invalid`);return}r.default._isIntType(c)&&a.__existNonIntegerValue(u)&&console.warn(`addGlobalConstantValue: non-integer value is set to ${l}`),this.__globalConstantValues.push({variableName:l,type:c,values:u})}addGlobalConstantStructValue(l,c,u){if(this.__globalConstantStructValues.some(d=>d.variableName===c)){console.error(`addGlobalConstantStructValue: duplicate variable name ${c}`);return}this.__globalConstantStructValues.push({variableName:c,structName:l,values:u})}addAttributeDeclaration(l,c,u){if(this.__shaderStage!=="vertex"){console.error("addAttribute: this method is for vertex shader only");return}if(this.__attributes.some(d=>d.variableName===l)){console.error(`addAttribute: duplicate variable name ${l}`);return}this.__attributes.push({variableName:l,type:c,precision:u==null?void 0:u.precision,location:u==null?void 0:u.location})}addVaryingDeclaration(l,c,u){if(this.__varyings.some(x=>x.variableName===l)){console.error(`addVarying: duplicate variable name ${l}`);return}let d=r.default._isIntType(c),p=u==null?void 0:u.interpolationType;if(d&&p!=="flat")if(p!=null){console.error("addVarying: the interpolationType must be flat for integer types");return}else console.warn("addVarying: set the interpolationType of integer types to flat to avoid compilation error"),p="flat";this.__varyings.push({variableName:l,type:c,precision:u==null?void 0:u.precision,interpolationType:p})}addUniformDeclaration(l,c,u){if(this.__uniforms.some(d=>d.variableName===l)){console.error(`addUniform: duplicate variable name ${l}`);return}c==="bool"&&(u==null?void 0:u.precision)!=null&&(console.warn("addUniform: remove the specification of precision for bool type to avoid compilation error"),u.precision=void 0),this.__uniforms.push({variableName:l,type:c,precision:u==null?void 0:u.precision})}addUniformStructDeclaration(l,c){if(this.__uniformStructs.some(_=>_.variableName===c)){console.error(`addUniformStructDeclaration: duplicate variable name ${c}`);return}this.__uniformStructs.push({variableName:c,structName:l})}addUniformBufferObjectDeclaration(l,c,u){if(this.__uniformBufferObjects.some(d=>d.blockName===l)){console.error(`addUniformBufferObjectDeclaration: duplicate block name ${l}`);return}for(let d of this.__uniformBufferObjects)for(let p of d.variableObjects)for(let x of c)if(p.variableName===x.variableName){console.error(`addUniformBufferObjectDeclaration: duplicate variable name ${x.variableName}`);return}this.__uniformBufferObjects.push({blockName:l,variableObjects:c,instanceName:u==null?void 0:u.instanceName})}addFunctionDefinition(l,c){var u,_;let d=this.__functionIdCount++,p=(u=c==null?void 0:c.dependencyLevel)!==null&&u!==void 0?u:0;return this.__functions[p]=(_=this.__functions[p])!==null&&_!==void 0?_:[],this.__functions[p].push({functionCode:l,functionId:d}),d}updateGlobalPrecision(l){Object.assign(this.__globalPrecision,l)}updateStructDefinition(l,c){let u=this.__structDefinitions.findIndex(_=>_.structName===l);if(u===-1){console.error(`updateStructDefinition: the struct type name ${l} is not exist`);return}this.__structDefinitions[u].memberObjects=c}updateGlobalConstantValue(l,c){let u=this.__globalConstantValues.findIndex(x=>x.variableName===l);if(u===-1){console.warn(`updateGlobalConstantValue: the variable name ${l} is not exist`);return}let _=this.__globalConstantValues[u].type;if(!r.default._isValidComponentCount(_,c)){console.error("updateGlobalConstantValue: the component count is invalid");return}r.default._isIntType(_)&&a.__existNonIntegerValue(c)&&console.warn(`updateGlobalConstantValue: the ${l} has a non-integer value.`),this.__globalConstantValues[u].values=c}updateGlobalConstantStructValue(l,c){let u=this.__globalConstantStructValues.findIndex(_=>_.variableName===l);if(u===-1){console.error(`updateGlobalConstantStructValue:  the variable name ${l} is not exist`);return}this.__globalConstantStructValues[u].values=c}updateMainFunction(l){this.__mainFunctionCode=l}updateOutputColorVariableName(l){if(this.__shaderStage!=="fragment"){console.error("updateOutputColorVariableName: this method is for fragment shader only");return}if(l.length===0){console.error("updateOutputColorVariableName: invalid outColorVariableName");return}this.__outputColorVariableName=l}removeDefineDirective(l){let c=this.__defineDirectiveNames.indexOf(l);if(c===-1){console.warn("removedDefineDirective: this define directive is not exist");return}this.__defineDirectiveNames.splice(c,1)}removeExtension(l){let c=this.__extensions.findIndex(u=>u.extensionName===l);if(c===-1){console.warn("removeExtension: this extension is not exist");return}this.__extensions.splice(c,1)}removeStructDefinition(l){let c=this.__structDefinitions.findIndex(u=>u.structName===l);if(c===-1){console.error(`removeStructDefinition: the struct type name ${l} is not exist`);return}this.__structDefinitions.splice(c,1)}removeGlobalConstantValue(l){let c=this.__globalConstantValues.findIndex(u=>u.variableName===l);if(c===-1){console.warn(`removeGlobalConstantValue: the variable name ${l} is not exist`);return}this.__globalConstantValues.splice(c,1)}removeGlobalConstantStructValue(l){let c=this.__globalConstantStructValues.findIndex(u=>u.variableName===l);if(c===-1){console.error(`updateGlobalConstantStructValue:  the variable name ${l} is not exist`);return}this.__globalConstantStructValues.splice(c,1)}removeAttributeDeclaration(l){let c=this.__attributes.findIndex(u=>u.variableName===l);if(c===-1){console.warn(`removeAttribute: the variable name ${l} is not exist`);return}this.__attributes.splice(c,1)}removeVaryingDeclaration(l){let c=this.__varyings.findIndex(u=>u.variableName===l);if(c===-1){console.warn(`removeVarying: the variable name ${l} is not exist`);return}this.__varyings.splice(c,1)}removeUniformDeclaration(l){let c=this.__uniforms.findIndex(u=>u.variableName===l);if(c===-1){console.warn(`removeUniform: the variable name ${l} is not exist`);return}this.__uniforms.splice(c,1)}removeUniformStructDeclaration(l){let c=this.__uniformStructs.findIndex(u=>u.variableName===l);if(c===-1){console.warn(`removeUniformStructDeclaration: the variable name ${l} is not exist`);return}this.__uniformStructs.splice(c,1)}removeUniformBufferObjectDeclaration(l){let c=this.__uniformBufferObjects.findIndex(u=>u.blockName===l);if(c===-1){console.warn(`removeUniformStructDeclaration: the variable name ${l} is not exist`);return}this.__uniformBufferObjects.splice(c,1)}removeFunctionDefinition(l){this.__fillEmptyFunctions(),(l<0||l>=this.__functionIdCount)&&console.warn("removeFunctionDefinition: invalid function id");for(let c of this.__functions){let u=c.findIndex(_=>_.functionId===l);if(u!==-1){c.splice(u,1);return}}console.warn(`removeFunctionDefinition: not found the function of functionId ${l}`)}createShaderityObject(){return{code:this.__createShaderCode(),shaderStage:this.__shaderStage,isFragmentShader:this.__shaderStage==="fragment"}}static __existNonIntegerValue(l){for(let c of l)if(!Number.isInteger(c))return!0;return!1}__createShaderCode(){return this.__fillEmptyFunctions(),`#version 300 es

`+this.__createDefineDirectiveShaderCode()+this.__createExtensionShaderCode()+this.__createGlobalPrecisionShaderCode()+this.__createStructDefinitionShaderCode()+this.__createGlobalConstantValueShaderCode()+this.__createGlobalConstantStructValueShaderCode()+this.__createAttributeDeclarationShaderCode()+this.__createVaryingDeclarationShaderCode()+this.__createOutputColorDeclarationShaderCode()+this.__createUniformDeclarationShaderCode()+this.__createUniformStructDeclarationShaderCode()+this.__createUniformBufferObjectShaderCode()+this.__createFunctionDefinitionShaderCode()+this.__createMainFunctionDefinitionShaderCode()}__fillEmptyFunctions(){var l;for(let c=0;c<this.__functions.length;c++)this.__functions[c]=(l=this.__functions[c])!==null&&l!==void 0?l:[]}__createDefineDirectiveShaderCode(){let l="";for(let c of this.__defineDirectiveNames)l+=`#define ${c}
`;return r.default._addLineFeedCodeIfNotNullString(l)}__createExtensionShaderCode(){let l="";for(let c of this.__extensions)l+=`#extension ${c.extensionName}: ${c.behavior}
`;return r.default._addLineFeedCodeIfNotNullString(l)}__createGlobalPrecisionShaderCode(){let l="";for(let c in this.__globalPrecision){let u=c,_=this.__globalPrecision[u];l+=`precision ${_} ${u};
`}return r.default._addLineFeedCodeIfNotNullString(l)}__createStructDefinitionShaderCode(){let l="";for(let c of this.__structDefinitions){l+=`struct ${c.structName} {
`;for(let u=0;u<c.memberObjects.length;u++){let _=c.memberObjects[u];l+="  ",_.precision!=null&&(l+=`${_.precision} `),l+=`${_.type} ${_.memberName};
`}l+=`};
`}return r.default._addLineFeedCodeIfNotNullString(l)}__createGlobalConstantValueShaderCode(){let l="";for(let c of this.__globalConstantValues){let u=c.type,_=c.variableName,d=c.values;l+=`const ${u} ${_} = ${u}(`;for(let p=0;p<d.length;p++)l+=d[p]+", ";l=l.replace(/,\s$/,`);
`)}return r.default._addLineFeedCodeIfNotNullString(l)}__createGlobalConstantStructValueShaderCode(){let l="";for(let c of this.__globalConstantStructValues){let u=this.__structDefinitions.findIndex(p=>p.structName===c.structName);if(u===-1){console.error(`__createGlobalConstantStructValueShaderCode: the struct type ${c.structName} is not defined`);continue}l+=`const ${c.structName} ${c.variableName} = ${c.structName} (
`;let _=this.__structDefinitions[u];if(_.memberObjects.length!==Object.keys(c.values).length){console.error(`__createGlobalConstantStructValueShaderCode: Invalid number of variables that ${c.variableName} has`);continue}if(_.memberObjects.some(p=>r.default._isSamplerType(p.type))){console.error(`__createGlobalConstantStructValueShaderCode: ConstantStructValue (${c.variableName}) cannot have sampler type parameter`);continue}for(let p=0;p<_.memberObjects.length;p++){let x=_.memberObjects[p].memberName,v=c.values[x];if(v==null){console.error(`__createGlobalConstantStructValueShaderCode: ${c.variableName} does not have the value of ${x}`);continue}let y=_.memberObjects[p].type;if(!r.default._isValidComponentCount(y,v)){console.error(`__createGlobalConstantStructValueShaderCode: the component count of ${x} in ${c.variableName} is invalid`);continue}l+=`  ${y}(`;for(let E=0;E<v.length;E++)l+=v[E]+", ";l=l.replace(/,\s$/,`),
`)}l=l.replace(/,\n$/,`
);
`)}return r.default._addLineFeedCodeIfNotNullString(l)}__createAttributeDeclarationShaderCode(){let l="";for(let c of this.__attributes)c.location!=null&&(l+=`layout (location = ${c.location}) `),l+="in ",c.precision!=null&&(l+=`${c.precision} `),l+=`${c.type} ${c.variableName};
`;return r.default._addLineFeedCodeIfNotNullString(l)}__createVaryingDeclarationShaderCode(){let l="";for(let c of this.__varyings)c.interpolationType!=null&&(l+=`${c.interpolationType} `),l+=this.__shaderStage=="vertex"?"out ":"in ",c.precision!=null&&(l+=`${c.precision} `),l+=`${c.type} ${c.variableName};
`;return r.default._addLineFeedCodeIfNotNullString(l)}__createOutputColorDeclarationShaderCode(){return this.__shaderStage!=="fragment"?"":`layout(location = 0) out vec4 ${this.__outputColorVariableName};

`}__createUniformDeclarationShaderCode(){let l="";for(let c of this.__uniforms)l+="uniform ",c.precision!=null&&(l+=`${c.precision} `),l+=`${c.type} ${c.variableName};
`;return r.default._addLineFeedCodeIfNotNullString(l)}__createUniformStructDeclarationShaderCode(){let l="";for(let c of this.__uniformStructs){let u=c.structName;if(!this.__structDefinitions.some(d=>d.structName===u)){console.error(`__createUniformStructDeclarationShaderCode: the struct type ${u} is not defined`);continue}l+=`uniform ${u} ${c.variableName};
`}return r.default._addLineFeedCodeIfNotNullString(l)}__createUniformBufferObjectShaderCode(){let l="";for(let c of this.__uniformBufferObjects){l+=`layout (std140) uniform ${c.blockName} {
`;for(let u=0;u<c.variableObjects.length;u++){let _=c.variableObjects[u];l+=`  ${_.type} ${_.variableName};
`}c.instanceName!=null?l+=`} ${c.instanceName};
`:l+=`};
`}return r.default._addLineFeedCodeIfNotNullString(l)}__createFunctionDefinitionShaderCode(){let l="";for(let c=0;c<this.__functions.length;c++){let u=this.__functions[c];for(let _=0;_<u.length;_++)l+=u[_].functionCode+`
`}return r.default._addLineFeedCodeIfNotNullString(l)}__createMainFunctionDefinitionShaderCode(){return this.__mainFunctionCode+`
`}},h(a,"ShaderityObjectCreator"),a);n.default=i},"./src/main/ShaderityObjectCreator.ts"),"./src/main/Utility.ts":h(function(m,n,t){"use strict";var r;Object.defineProperty(n,"__esModule",{value:!0});let o=(r=class{static _splitByLineFeedCode(a){return a.split(/\r\n|\n/)}static _joinSplittedLine(a){return a.join(`
`)}static _addLineFeedCodeIfNotNullString(a){return a===""?a:a+`
`}static _componentNumber(a){let s;return a==="float"||a==="int"||a==="bool"||a==="uint"||a==="sampler2D"||a==="samplerCube"||a==="sampler3D"||a==="sampler2DArray"||a==="isampler2D"||a==="isamplerCube"||a==="isampler3D"||a==="isampler2DArray"||a==="usampler2D"||a==="usamplerCube"||a==="usampler3D"||a==="usampler2DArray"||a==="sampler2DShadow"||a==="samplerCubeShadow"||a==="sampler2DArrayShadow"?s=1:a==="vec2"||a==="ivec2"||a==="bvec2"||a==="uvec2"?s=2:a==="vec3"||a==="ivec3"||a==="bvec3"||a==="uvec3"?s=3:a==="vec4"||a==="ivec4"||a==="bvec4"||a==="uvec4"||a==="mat2"||a==="mat2x2"?s=4:a==="mat2x3"||a==="mat3x2"?s=6:a==="mat2x4"||a==="mat4x2"?s=8:a==="mat3"||a==="mat3x3"?s=9:a==="mat3x4"||a==="mat4x3"?s=12:a==="mat4"||a==="mat4x4"?s=16:(s=0,console.error("Utility._componentNumber: detect unknown type")),s}static _isIntType(a){return a==="int"||a==="ivec2"||a==="ivec3"||a==="ivec4"||a==="uint"||a==="uvec2"||a==="uvec3"||a==="uvec4"}static _isValidComponentCount(a,s){return r._componentNumber(a)===s.length}static _isSamplerType(a){return a==="sampler2D"||a==="samplerCube"||a==="sampler3D"||a==="sampler2DArray"||a==="isampler2D"||a==="isamplerCube"||a==="isampler3D"||a==="isampler2DArray"||a==="usampler2D"||a==="usamplerCube"||a==="usampler3D"||a==="usampler2DArray"||a==="sampler2DShadow"||a==="samplerCubeShadow"||a==="sampler2DArrayShadow"}},h(r,"Utility"),r);n.default=o},"./src/main/Utility.ts")})});var wi,Ri,dm=C(()=>{"use strict";Sr();bi();ft();Vo();Ze();Ke();me();wi=class wi extends mn{constructor(){super();f(this,"baseUriToLoad");f(this,"mipmapLevelNumber",1);f(this,"hdriFormat",wt.LDR_SRGB);f(this,"isNamePosNeg",!1);f(this,"__onTextureLoadedArray",[])}__setTextureResourceUid(t,o){this._textureResourceUid=t,wi.managedRegistry.register(this,{textureResourceUid:t,uniqueName:o},this)}registerOnTextureLoaded(t){this.__onTextureLoadedArray.push(t)}async loadTextureImages(){this.__startedToLoad=!0;let t=G.getCgApiResourceRepository(),[o,r]=await t.createCubeTextureFromFiles(this.baseUriToLoad,this.mipmapLevelNumber,this.isNamePosNeg,this.hdriFormat);this._recommendedTextureSampler=r,this.__setTextureResourceUid(o,this.uniqueName),this._samplerResourceUid=r._samplerResourceUid,K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=t.createTextureViewCube(this._textureResourceUid)),this.__isTextureReady=!0}loadTextureImagesAsync(){return new Promise(t=>{this.__startedToLoad=!0;let o=G.getCgApiResourceRepository();o.createCubeTextureFromFiles(this.baseUriToLoad,this.mipmapLevelNumber,this.isNamePosNeg,this.hdriFormat).then(([r,i])=>{this.__setTextureResourceUid(r,this.uniqueName),this._recommendedTextureSampler=i,this._samplerResourceUid=i._samplerResourceUid,K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=o.createTextureViewCube(this._textureResourceUid))}).then(()=>{this.__isTextureReady=!0,this.__onTextureLoadedArray.forEach(r=>{r()}),this.__onTextureLoadedArray=[],t()})})}loadTextureImagesFromBasis(t,{magFilter:o=U.Linear,minFilter:r=U.LinearMipmapLinear,wrapS:i=U.Repeat,wrapT:a=U.Repeat}={}){this.__startedToLoad=!0,typeof BASIS=="undefined"&&N.error("Failed to call BASIS() function. Please check to import basis_transcoder.js."),BASIS().then(s=>{let{initializeBasis:l}=s;l();let c=s.BasisFile,u=new c(t);if(!u.startTranscoding()){N.error("failed to start transcoding."),u.close(),u.delete();return}let d=G.getWebGLResourceRepository().createCubeTextureFromBasis(u,{magFilter:o,minFilter:r,wrapS:i,wrapT:a});this.__setTextureResourceUid(d,this.uniqueName),this.__isTextureReady=!0,u.close(),u.delete()})}load1x1Texture(t="rgba(0,0,0,1)"){let o=document.createElement("canvas");o.width=1,o.height=1;let r=o.getContext("2d");r.fillStyle=t,r.fillRect(0,0,1,1);let i=G.getCgApiResourceRepository(),[a,s]=i.createCubeTexture(1,[{posX:o,negX:o,posY:o,negY:o,posZ:o,negZ:o}],1,1);this.__setTextureResourceUid(a,this.uniqueName),this._recommendedTextureSampler=s,this._samplerResourceUid=s._samplerResourceUid,K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=i.createTextureViewCube(this._textureResourceUid)),this.__isTextureReady=!0}generateTextureFromTypedArrays(t,o,r){let i=G.getWebGLResourceRepository(),[a,s]=i.createCubeTexture(t.length,t,o,r);this._recommendedTextureSampler=s,this.__setTextureResourceUid(a,this.uniqueName),this.__isTextureReady=!0,this.__startedToLoad=!0}importWebGLTextureDirectly(t,o=0,r=0){this.__width=o,this.__height=r;let a=G.getWebGLResourceRepository().setWebGLTextureDirectly(t);this.__setTextureResourceUid(a,this.uniqueName),this.__startedToLoad=!0,this.__isTextureReady=!0}static __deleteInternalTexture(t){G.getCgApiResourceRepository().deleteTexture(t)}destroy3DAPIResources(){wi.__deleteInternalTexture(this._textureResourceUid),this._textureResourceUid=G.InvalidCGAPIResourceUid,this.__isTextureReady=!1,this.__startedToLoad=!1}[Symbol.dispose](){N.debug("[Symbol.dispose] is called"),this.destroy()}destroy(){this.destroy3DAPIResources(),this.unregister(),wi.managedRegistry.unregister(this)}};h(wi,"CubeTexture"),f(wi,"managedRegistry",new FinalizationRegistry(t=>{N.info(`WebGL/WebGPU cube texture "${t.uniqueName}" was automatically released along with GC. But explicit release is recommended.`),wi.__deleteInternalTexture(t.textureResourceUid)}));Ri=wi});function E2(m){return typeof TextDecoder!="undefined"?new TextDecoder().decode(m):Buffer.from(m).toString("utf8")}function C2(m){let n=new Uint8Array(m.buffer,m.byteOffset,wo.length);if(n[0]!==wo[0]||n[1]!==wo[1]||n[2]!==wo[2]||n[3]!==wo[3]||n[4]!==wo[4]||n[5]!==wo[5]||n[6]!==wo[6]||n[7]!==wo[7]||n[8]!==wo[8]||n[9]!==wo[9]||n[10]!==wo[10]||n[11]!==wo[11])throw new Error("Missing KTX 2.0 identifier.");let t=new DW,o=17*Uint32Array.BYTES_PER_ELEMENT,r=new Ic(m,wo.length,o,!0);t.vkFormat=r._nextUint32(),t.typeSize=r._nextUint32(),t.pixelWidth=r._nextUint32(),t.pixelHeight=r._nextUint32(),t.pixelDepth=r._nextUint32(),t.layerCount=r._nextUint32(),t.faceCount=r._nextUint32();let i=r._nextUint32();t.supercompressionScheme=r._nextUint32();let a=r._nextUint32(),s=r._nextUint32(),l=r._nextUint32(),c=r._nextUint32(),u=r._nextUint64(),_=r._nextUint64(),d=new Ic(m,wo.length+o,3*i*8,!0);for(let Be=0;Be<i;Be++)t.levels.push({levelData:new Uint8Array(m.buffer,m.byteOffset+d._nextUint64(),d._nextUint64()),uncompressedByteLength:d._nextUint64()});let p=new Ic(m,a,s,!0),x={vendorId:p._skip(4)._nextUint16(),descriptorType:p._nextUint16(),versionNumber:p._nextUint16(),descriptorBlockSize:p._nextUint16(),colorModel:p._nextUint8(),colorPrimaries:p._nextUint8(),transferFunction:p._nextUint8(),flags:p._nextUint8(),texelBlockDimension:{x:p._nextUint8()+1,y:p._nextUint8()+1,z:p._nextUint8()+1,w:p._nextUint8()+1},bytesPlane:[p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8()],samples:[]},v=(x.descriptorBlockSize/4-6)/4;for(let Be=0;Be<v;Be++)x.samples[Be]={bitOffset:p._nextUint16(),bitLength:p._nextUint8(),channelID:p._nextUint8(),samplePosition:[p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8()],sampleLower:p._nextUint32(),sampleUpper:p._nextUint32()};t.dataFormatDescriptor.length=0,t.dataFormatDescriptor.push(x);let y=new Ic(m,l,c,!0);for(;y._offset<c;){let Be=y._nextUint32(),Fn=y._scan(Be),Sn=E2(Fn),cn=y._scan(Be-Fn.byteLength);t.keyValue[Sn]=Sn.match(/^ktx/i)?E2(cn):cn,y._offset%4&&y._skip(4-y._offset%4)}if(_<=0)return t;let g=new Ic(m,u,_,!0),E=g._nextUint16(),w=g._nextUint16(),T=g._nextUint32(),R=g._nextUint32(),P=g._nextUint32(),V=g._nextUint32(),z=[];for(let Be=0;Be<i;Be++)z.push({imageFlags:g._nextUint32(),rgbSliceByteOffset:g._nextUint32(),rgbSliceByteLength:g._nextUint32(),alphaSliceByteOffset:g._nextUint32(),alphaSliceByteLength:g._nextUint32()});let k=u+g._offset,W=k+T,X=W+R,j=X+P,ae=new Uint8Array(m.buffer,m.byteOffset+k,T),le=new Uint8Array(m.buffer,m.byteOffset+W,R),ze=new Uint8Array(m.buffer,m.byteOffset+X,P),At=new Uint8Array(m.buffer,m.byteOffset+j,V);return t.globalData={endpointCount:E,selectorCount:w,imageDescs:z,endpointsData:ae,selectorsData:le,tablesData:ze,extendedData:At},t}var Qoe,wo,pa,Lh,Sc,hm,pm,Vh,Tc,xm,qs,DW,js,Ic,w2=C(()=>{"use strict";Qoe=new Uint8Array([0]),wo=[171,75,84,88,32,50,48,187,13,10,26,10];(function(m){m[m.NONE=0]="NONE",m[m.BASISLZ=1]="BASISLZ",m[m.ZSTD=2]="ZSTD",m[m.ZLIB=3]="ZLIB"})(pa||(pa={})),function(m){m[m.BASICFORMAT=0]="BASICFORMAT"}(Lh||(Lh={})),function(m){m[m.UNSPECIFIED=0]="UNSPECIFIED",m[m.ETC1S=163]="ETC1S",m[m.UASTC=166]="UASTC"}(Sc||(Sc={})),function(m){m[m.UNSPECIFIED=0]="UNSPECIFIED",m[m.SRGB=1]="SRGB"}(hm||(hm={})),function(m){m[m.UNSPECIFIED=0]="UNSPECIFIED",m[m.LINEAR=1]="LINEAR",m[m.SRGB=2]="SRGB",m[m.ITU=3]="ITU",m[m.NTSC=4]="NTSC",m[m.SLOG=5]="SLOG",m[m.SLOG2=6]="SLOG2"}(pm||(pm={})),function(m){m[m.ALPHA_STRAIGHT=0]="ALPHA_STRAIGHT",m[m.ALPHA_PREMULTIPLIED=1]="ALPHA_PREMULTIPLIED"}(Vh||(Vh={})),function(m){m[m.RGB=0]="RGB",m[m.RRR=3]="RRR",m[m.GGG=4]="GGG",m[m.AAA=15]="AAA"}(Tc||(Tc={})),function(m){m[m.RGB=0]="RGB",m[m.RGBA=3]="RGBA",m[m.RRR=4]="RRR",m[m.RRRG=5]="RRRG"}(xm||(xm={}));DW=(qs=class{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=pa.NONE,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:Lh.BASICFORMAT,versionNumber:2,descriptorBlockSize:40,colorModel:Sc.UNSPECIFIED,colorPrimaries:hm.SRGB,transferFunction:hm.SRGB,flags:Vh.ALPHA_STRAIGHT,texelBlockDimension:{x:4,y:4,z:1,w:1},bytesPlane:[],samples:[]}],this.keyValue={},this.globalData=null}},h(qs,"U"),qs),Ic=(js=class{constructor(n,t,o,r){this._dataView=new DataView(n.buffer,n.byteOffset+t,o),this._littleEndian=r,this._offset=0}_nextUint8(){let n=this._dataView.getUint8(this._offset);return this._offset+=1,n}_nextUint16(){let n=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,n}_nextUint32(){let n=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,n}_nextUint64(){let n=this._dataView.getUint32(this._offset,this._littleEndian)+4294967296*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,n}_skip(n){return this._offset+=n,this}_scan(n,t=0){let o=this._offset,r=0;for(;this._dataView.getUint8(this._offset)!==t&&r<n;)r++,this._offset++;return r<n&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+o,r)}},h(js,"c"),js);h(E2,"_");h(C2,"p")});var zh,ri,Oh,Gh,Ys,N2,R2,P2=C(()=>{"use strict";Gh={env:{emscripten_notify_memory_growth:h(function(m){Oh=new Uint8Array(ri.exports.memory.buffer)},"emscripten_notify_memory_growth")}},N2=(Ys=class{init(){return zh||(zh=typeof fetch!="undefined"?fetch("data:application/wasm;base64,"+R2).then(n=>n.arrayBuffer()).then(n=>WebAssembly.instantiate(n,Gh)).then(this._init):WebAssembly.instantiate(Buffer.from(R2,"base64"),Gh).then(this._init),zh)}_init(n){ri=n.instance,Gh.env.emscripten_notify_memory_growth(0)}decode(n,t=0){if(!ri)throw new Error("ZSTDDecoder: Await .init() before decoding.");let o=n.byteLength,r=ri.exports.malloc(o);Oh.set(n,r),t=t||Number(ri.exports.ZSTD_findDecompressedSize(r,o));let i=ri.exports.malloc(t),a=ri.exports.ZSTD_decompress(i,t,r,o),s=Oh.slice(i,i+a);return ri.exports.free(r),ri.exports.free(i),s}},h(Ys,"Q"),Ys),R2="AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ"});var Ks,uo,zo,Ec,Uh=C(()=>{"use strict";w2();ft();vd();P2();Ke();Ze();me();Ks={ETC1S:0,UASTC4x4:1},uo={ETC1_RGB:"ETC1_RGB",BC1_RGB:"BC1_RGB",BC4_R:"BC4_R",BC5_RG:"BC5_RG",BC3_RGBA:"BC3_RGBA",PVRTC1_4_RGB:"PVRTC1_4_RGB",PVRTC1_4_RGBA:"PVRTC1_4_RGBA",BC7_RGBA:"BC7_RGBA",BC7_M6_RGB:"BC7_M6_RGB",BC7_M5_RGBA:"BC7_M5_RGBA",ETC2_RGBA:"ETC2_RGBA",ASTC_4x4_RGBA:"ASTC_4x4_RGBA",RGBA32:"RGBA32",RGB565:"RGB565",BGR565:"BGR565",RGBA4444:"RGBA4444",PVRTC2_4_RGB:"PVRTC2_4_RGB",PVRTC2_4_RGBA:"PVRTC2_4_RGBA",EAC_R11:"EAC_R11",EAC_RG11:"EAC_RG11"},zo=class zo{constructor(){f(this,"__mscTranscoderPromise");typeof MSC_TRANSCODER=="undefined"&&N.error("Failed to call MSC_TRANSCODER() function. Please check to import msc_basis_transcoder.js."),this.__mscTranscoderPromise=this.__loadMSCTranscoder()}static getInstance(){return this.__instance||(this.__instance=new zo),this.__instance}transcode(n){let t=this.__parse(n);if(t.pixelDepth>0)throw new Error("Only 2D textures are currently supported");if(t.layerCount>1)throw new Error("Array textures are not currently supported");if(t.faceCount>1)throw new Error("Cube textures are not currently supported");return t.supercompressionScheme===pa.ZSTD?(zo.__zstdDecoder==null&&(zo.__zstdDecoder=new N2),zo.__zstdDecoder.init().then(()=>this.__mscTranscoderPromise.then(()=>this.__transcodeData(t)))):this.__mscTranscoderPromise.then(()=>this.__transcodeData(t))}__loadMSCTranscoder(){return new Promise(n=>{zo.__mscTranscoderModule&&n(),MSC_TRANSCODER().then(t=>{t.initTranscoders(),zo.__mscTranscoderModule=t,n()})})}__getDeviceDependentParametersWebGL(n){let o=G.getWebGLResourceRepository().currentWebGLContextWrapper,r=o.webgl2ExtCTAstc||o.webgl1ExtCTAstc,i=o.webgl2ExtCTBptc||o.webgl1ExtCTBptc,a=o.webgl2ExtCTS3tc||o.webgl1ExtCTS3tc,s=o.webgl2ExtCTPvrtc||o.webgl1ExtCTPvrtc,l=o.webgl2ExtCTEtc||o.webgl1ExtCTEtc,c=o.webgl2ExtCTEtc1||o.webgl1ExtCTEtc1,u,_;return r?(u=uo.ASTC_4x4_RGBA,_=Un.ASTC_RGBA_4x4):i?(u=uo.BC7_RGBA,_=Un.BPTC_RGBA):a?n?(u=uo.BC3_RGBA,_=Un.S3TC_RGBA_DXT5):(u=uo.BC1_RGB,_=Un.S3TC_RGB_DXT1):s?n?(u=uo.PVRTC1_4_RGBA,_=Un.PVRTC_RGBA_4BPPV1):(u=uo.PVRTC1_4_RGB,_=Un.PVRTC_RGB_4BPPV1):l?n?(u=uo.ETC2_RGBA,_=Un.ETC2_RGBA8_EAC):(u=uo.ETC1_RGB,_=Un.ETC2_RGB8):c?(u=uo.ETC1_RGB,_=Un.ETC1_RGB):(u=uo.RGBA32,_=Un.RGBA8_EXT),{transcodeTargetStr:u,compressionTextureType:_}}__getDeviceDependentParametersWebGPU(n){let o=G.getWebGpuResourceRepository().getWebGpuDeviceWrapper().gpuAdapter,r=o.features.has("texture-compression-astc"),i=o.features.has("texture-compression-bc"),a=o.features.has("texture-compression-etc2"),s,l;return r?(s=uo.ASTC_4x4_RGBA,l=Un.ASTC_RGBA_4x4):i?n?(s=uo.BC3_RGBA,l=Un.S3TC_RGBA_DXT5):(s=uo.BC1_RGB,l=Un.S3TC_RGB_DXT1):a?n?(s=uo.ETC2_RGBA,l=Un.ETC2_RGBA8_EAC):(s=uo.ETC1_RGB,l=Un.ETC2_RGB8):(s=uo.RGBA32,l=Un.RGBA8_EXT),{transcodeTargetStr:s,compressionTextureType:l}}__parse(n){return C2(n)}__transcodeData(n){var E;let t=n.pixelWidth,o=n.pixelHeight,r=n.faceCount,i=(E=n.globalData)==null?void 0:E.imageDescs,a=n.dataFormatDescriptor[0],s=a.colorModel===Sc.UASTC?Ks.UASTC4x4:Ks.ETC1S,l=this.__hasAlpha(a,s),c=!1,u=zo.__mscTranscoderModule,_=s===Ks.UASTC4x4?new u.UastcImageTranscoder:new u.BasisLzEtc1sImageTranscoder,d=s===Ks.UASTC4x4?u.TextureFormat.UASTC4x4:u.TextureFormat.ETC1S,{transcodeTargetStr:p,compressionTextureType:x}=K.currentProcessApproach===Z.WebGPU?this.__getDeviceDependentParametersWebGPU(l):this.__getDeviceDependentParametersWebGL(l),v=u.TranscodeTarget[p],y=[],g={width:t,height:o,compressionTextureType:x,mipmapData:y,needGammaCorrection:a.transferFunction!==pm.SRGB};for(let w=0;w<n.levels.length;w++){let T=Math.max(1,t>>w),R=Math.max(1,o>>w),P=new u.ImageInfo(d,T,R,w),V=n.levels[w].levelData,z=n.levels[w].uncompressedByteLength,k=P.numBlocksX*P.numBlocksY*a.bytesPlane[0];n.supercompressionScheme===pa.ZSTD&&(V=zo.__zstdDecoder.decode(V,z));let W=0,X=w*Math.max(n.layerCount,1)*r*Math.max(n.pixelDepth,1);for(let j=0;j<r;j++){let ae=null,le;n.supercompressionScheme===pa.BASISLZ?(ae=i==null?void 0:i[X+j],le=new Uint8Array(V,ae.rgbSliceByteOffset,ae.rgbSliceByteLength+ae.alphaSliceByteLength)):(le=new Uint8Array(V,W,k),W+=k);let ze;if(s===Ks.UASTC4x4)P.flags=0,P.rgbByteOffset=0,P.rgbByteLength=z,P.alphaByteOffset=0,P.alphaByteLength=0,ze=_.transcodeImage(v,le,P,0,l,c);else{let At=n.globalData,Be=_;Be.decodePalettes(At.endpointCount,At.endpointsData,At.selectorCount,At.selectorsData),Be.decodeTables(At.tablesData),P.flags=ae.imageFlags,P.rgbByteOffset=0,P.rgbByteLength=ae.rgbSliceByteLength,P.alphaByteOffset=ae.alphaSliceByteOffset>0?ae.rgbSliceByteLength:0,P.alphaByteLength=ae.alphaSliceByteLength,ze=Be.transcodeImage(v,le,P,0,c)}if((ze==null?void 0:ze.transcodedImage)!=null){let At=ze.transcodedImage.get_typed_memory_view().slice();ze.transcodedImage.delete();let Be={level:w,width:T,height:R,buffer:At};y.push(Be)}}}return g}__hasAlpha(n,t){return t===Ks.UASTC4x4?n.samples[0].channelID===xm.RGBA:n.samples.length===2&&(n.samples[0].channelID===Tc.AAA||n.samples[1].channelID===Tc.AAA)}};h(zo,"KTX2TextureLoader"),f(zo,"__instance"),f(zo,"__mscTranscoderModule"),f(zo,"__zstdDecoder");Ec=zo});var Xn,Jt,Ni=C(()=>{"use strict";Lo();xe();Sr();ft();tt();co();Uh();Qn();Ke();Ze();pn();me();Xn=class Xn extends mn{constructor(){super();f(this,"autoResize",!0);f(this,"autoDetectTransparency",!1);f(this,"__uriToLoadLazy");f(this,"__imgToLoadLazy");f(this,"__optionsToLoadLazy")}__setTextureResourceUid(t,o){this._textureResourceUid=t,Xn.managedRegistry.register(this,{textureResourceUid:t,uniqueName:o},this)}get hasDataToLoadLazy(){return this.__uriToLoadLazy!=null||this.__imgToLoadLazy!=null}generateTextureFromBasis(t,o){var r;this.__startedToLoad=!0,typeof BASIS=="undefined"&&N.error("Failed to call BASIS() function. Please check to import basis_transcoder.js."),Xn.__loadedBasisFunc?Xn.__BasisFile?this.__setBasisTexture(t,o):(r=Xn.__basisLoadPromise)==null||r.then(()=>{this.__setBasisTexture(t,o)}):(Xn.__loadedBasisFunc=!0,Xn.__basisLoadPromise=new Promise(i=>{BASIS().then(a=>{let{initializeBasis:s}=a;s(),Xn.__BasisFile=a.BasisFile,this.__setBasisTexture(t,o),i()})}))}__setBasisTexture(t,{level:o=0,internalFormat:r=oe.RGBA8,format:i=ue.RGBA,type:a=I.UnsignedByte,generateMipmap:s=!0}={}){this.__startedToLoad=!0;let l=new Xn.__BasisFile(t);if(!l.startTranscoding()){N.error("failed to start transcoding."),l.close(),l.delete();return}let u=G.getCgApiResourceRepository().createCompressedTextureFromBasis(l,{border:0,format:i,type:a});this.__setTextureResourceUid(u,this.uniqueName),this.__isTextureReady=!0,l.close(),l.delete()}async generateTextureFromKTX2(t){this.__startedToLoad=!0;let o=await Ec.getInstance().transcode(t);this.__width=o.width,this.__height=o.height,this.generateCompressedTextureWithMipmapFromTypedArray(o.mipmapData,o.compressionTextureType)}generateTextureFromImage(t,{level:o=0,internalFormat:r=oe.RGBA8,format:i=ue.RGBA,type:a=I.UnsignedByte,generateMipmap:s=!0}={}){this.__imgToLoadLazy=t,this.__optionsToLoadLazy={level:o,internalFormat:r,format:i,type:a,generateMipmap:s}}async loadFromImgLazy(){var _,d,p,x,v,y,g,E,w,T;if(this.__imgToLoadLazy==null)return;let t=this.__imgToLoadLazy,o=(d=(_=this.__optionsToLoadLazy)==null?void 0:_.level)!=null?d:0,r=(x=(p=this.__optionsToLoadLazy)==null?void 0:p.internalFormat)!=null?x:oe.RGBA8,i=(y=(v=this.__optionsToLoadLazy)==null?void 0:v.format)!=null?y:ue.RGBA,a=(E=(g=this.__optionsToLoadLazy)==null?void 0:g.type)!=null?E:I.UnsignedByte,s=(T=(w=this.__optionsToLoadLazy)==null?void 0:w.generateMipmap)!=null?T:!0;this.__startedToLoad=!0,this.__htmlImageElement=t;let l=t;if(this.autoResize){let[R,P,V]=ie.getResizedCanvas(l,F.maxSizeLimitOfNonCompressedTexture);l=R,this.__width=P,this.__height=V,this.__htmlCanvasElement=R}this.autoDetectTransparency&&(this.__hasTransparentPixels=ie.detectTransparentPixelExistence(l)),this.__width=l.width,this.__height=l.height;let c=G.getCgApiResourceRepository(),u;if(l instanceof HTMLImageElement)u=await c.createTextureFromHTMLImageElement(l,{level:o,internalFormat:r,width:this.__width,height:this.__height,border:0,format:i,type:a,generateMipmap:s});else if(l instanceof HTMLCanvasElement)u=c.createTextureFromImageBitmapData(l,{level:o,internalFormat:r,width:this.__width,height:this.__height,border:0,format:i,type:a,generateMipmap:s});else throw new Error("Unsupported image type.");this.__setTextureResourceUid(u,this.uniqueName),K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=c.createTextureView2d(this._textureResourceUid)),this.__isTextureReady=!0,this.__uri=t.src,this.__imgToLoadLazy=void 0}generateTextureFromUri(t,{level:o=0,internalFormat:r=oe.RGBA8,format:i=ue.RGBA,type:a=I.UnsignedByte,generateMipmap:s=!0}={}){this.__uriToLoadLazy=t,this.__optionsToLoadLazy={level:o,internalFormat:r,format:i,type:a,generateMipmap:s}}async loadFromUrlLazy(){var l,c,u,_,d,p,x,v,y,g;if(this.__uriToLoadLazy==null)return;let t=this.__uriToLoadLazy,o=(c=(l=this.__optionsToLoadLazy)==null?void 0:l.level)!=null?c:0,r=(_=(u=this.__optionsToLoadLazy)==null?void 0:u.internalFormat)!=null?_:oe.RGBA8,i=(p=(d=this.__optionsToLoadLazy)==null?void 0:d.format)!=null?p:ue.RGBA,a=(v=(x=this.__optionsToLoadLazy)==null?void 0:x.type)!=null?v:I.UnsignedByte,s=(g=(y=this.__optionsToLoadLazy)==null?void 0:y.generateMipmap)!=null?g:!0;return this.__uri=t,this.__startedToLoad=!0,new Promise((E,w)=>{this.__img=new Image,t.match(/^data:/)||(this.__img.crossOrigin="Anonymous"),this.__img.onload=()=>{this.__htmlImageElement=this.__img;let T=this.__img;if(this.autoResize){let[V,z,k]=ie.getResizedCanvas(T,F.maxSizeLimitOfNonCompressedTexture);T=V,this.__width=z,this.__height=k,this.__htmlCanvasElement=V}this.autoDetectTransparency&&(this.__hasTransparentPixels=ie.detectTransparentPixelExistence(T)),this.__width=T.width,this.__height=T.height;let R=G.getCgApiResourceRepository(),P=G.InvalidCGAPIResourceUid;(async()=>{if(T instanceof HTMLImageElement)P=await R.createTextureFromHTMLImageElement(T,{level:o,internalFormat:r,width:this.__width,height:this.__height,border:0,format:i,type:a,generateMipmap:s});else if(T instanceof HTMLCanvasElement)P=R.createTextureFromImageBitmapData(T,{level:o,internalFormat:r,width:this.__width,height:this.__height,border:0,format:i,type:a,generateMipmap:s});else throw new Error("Unsupported image type");this.__setTextureResourceUid(P,this.uniqueName),K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=R.createTextureView2d(this._textureResourceUid)),this.__isTextureReady=!0,this.__uriToLoadLazy=void 0,E()})()},this.__img.src=t})}generate1x1TextureFrom(t="rgba(255,255,255,1)"){let o=document.createElement("canvas");o.width=1,o.height=1,this.__width=1,this.__height=1;let r=o.getContext("2d");r.fillStyle=t,r.fillRect(0,0,1,1);let i=G.getCgApiResourceRepository(),a=i.createTextureFromImageBitmapData(o,{level:0,internalFormat:oe.RGBA8,width:1,height:1,border:0,format:ue.RGBA,type:I.UnsignedByte,generateMipmap:!1});this.__setTextureResourceUid(a,this.uniqueName),K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=i.createTextureView2d(this._textureResourceUid)),this.__isTextureReady=!0}async generateSheenLutTextureFromDataUri(){let r=Pe.getInstance().getModule("pbr"),i=G.getCgApiResourceRepository(),a=await i.createTextureFromDataUri(r.sheen_E_and_DGTerm,{level:0,internalFormat:oe.RGBA8,border:0,format:ue.RGBA,type:I.UnsignedByte,generateMipmap:!1});this.__setTextureResourceUid(a,this.uniqueName),K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=i.createTextureView2d(this._textureResourceUid)),this.__isTextureReady=!0}allocate(t){var i;let o=G.getCgApiResourceRepository();t.mipLevelCount=(i=t.mipLevelCount)!=null?i:Math.floor(Math.log2(Math.max(t.width,t.height)))+1;let r=o.allocateTexture({mipLevelCount:t.mipLevelCount,width:t.width,height:t.height,format:t.format});this.__setTextureResourceUid(r,this.uniqueName),K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=o.createTextureView2d(this._textureResourceUid)),this.__width=t.width,this.__height=t.height,this.__mipLevelCount=t.mipLevelCount,this.__internalFormat=t.format}async loadImageToMipLevel(t){await G.getCgApiResourceRepository().loadImageToMipLevelOfTexture2D({mipLevel:t.mipLevel,textureUid:this._textureResourceUid,format:this.__internalFormat,type:t.type,xOffset:t.xOffset,yOffset:t.yOffset,width:t.width,height:t.height,rowSizeByPixel:t.rowSizeByPixel,data:t.data}),t.mipLevel===0&&(this.__isTextureReady=!0)}generateCompressedTextureFromTypedArray(t,o,r,i){this.__width=o,this.__height=r;let a={level:0,width:o,height:r,buffer:t},s=G.getCgApiResourceRepository(),l=s.createCompressedTexture([a],i);this.__setTextureResourceUid(l,this.uniqueName),K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=s.createTextureView2d(this._textureResourceUid)),this.__isTextureReady=!0}generateCompressedTextureWithMipmapFromTypedArray(t,o){let r=t.find(s=>s.level===0);if(r==null)throw new Error("texture data with level 0 is not found");this.__width=r.width,this.__height=r.height;let i=G.getCgApiResourceRepository(),a=i.createCompressedTexture(t,o);this.__setTextureResourceUid(a,this.uniqueName),K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=i.createTextureView2d(this._textureResourceUid)),this.__isTextureReady=!0}generateMipmaps(){G.getCgApiResourceRepository().generateMipmaps2d(this._textureResourceUid,this.__width,this.__height)}importWebGLTextureDirectly(t,o=0,r=0){this.__width=o,this.__height=r;let a=G.getWebGLResourceRepository().setWebGLTextureDirectly(t);this.__setTextureResourceUid(a,this.uniqueName),this.__startedToLoad=!0,this.__isTextureReady=!0}destroy3DAPIResources(){return Xn.__deleteInternalTexture(this._textureResourceUid),this._textureResourceUid=G.InvalidCGAPIResourceUid,this.__isTextureReady=!1,this.__startedToLoad=!1,!0}static __deleteInternalTexture(t){G.getCgApiResourceRepository().deleteTexture(t)}[Symbol.dispose](){N.debug("[Symbol.dispose] is called"),this.destroy()}destroy(){this.destroy3DAPIResources(),this.unregister(),Xn.managedRegistry.unregister(this)}};h(Xn,"Texture"),f(Xn,"__loadedBasisFunc",!1),f(Xn,"__basisLoadPromise"),f(Xn,"__BasisFile"),f(Xn,"managedRegistry",new FinalizationRegistry(t=>{N.info(`WebGL/WebGPU 2D texture "${t.uniqueName}" was automatically released along with GC. But explicit release is recommended.`),Xn.__deleteInternalTexture(t.textureResourceUid)}));Jt=Xn});var Pi,xa,kh=C(()=>{"use strict";tt();xe();Lo();Ke();pn();me();ft();Ze();Sr();Pi=class Pi extends mn{constructor(){super()}__setTextureResourceUid(n,t){this._textureResourceUid=n,Pi.managedRegistry.register(this,{textureResourceUid:n,uniqueName:t},this)}static __deleteInternalTexture(n){G.getCgApiResourceRepository().deleteTexture(n)}load1x1Texture(n="rgba(0,0,0,1)"){let t=document.createElement("canvas");t.width=1,t.height=1;let o=t.getContext("2d");o.fillStyle=n,o.fillRect(0,0,1,1);let r=o.getImageData(0,0,1,1),i=new Uint8Array(r.data.buffer),a=G.getCgApiResourceRepository(),s=a.createTextureArray(1,1,F.shadowMapTextureArrayLength,1,oe.RGBA8,ue.RGBA,I.UnsignedByte,i);this.__setTextureResourceUid(s,this.uniqueName),K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=a.createTextureView2dArray(this._textureResourceUid,F.shadowMapTextureArrayLength)),this.__isTextureReady=!0}destroy3DAPIResources(){Pi.__deleteInternalTexture(this._textureResourceUid),this._textureResourceUid=G.InvalidCGAPIResourceUid,this.__isTextureReady=!1,this.__startedToLoad=!1}[Symbol.dispose](){N.debug("[Symbol.dispose] is called"),this.destroy()}destroy(){this.destroy3DAPIResources(),this.unregister(),Pi.managedRegistry.unregister(this)}};h(Pi,"TextureArray"),f(Pi,"managedRegistry",new FinalizationRegistry(n=>{N.info(`WebGL/WebGPU texture array "${n.uniqueName}" was automatically released along with GC. But explicit release is recommended.`),Pi.__deleteInternalTexture(n.textureResourceUid)}));xa=Pi});async function Wh(){ct.isTextureReady||(ct.tryToSetUniqueName("dummyWhiteTexture",!0),Ur.tryToSetUniqueName("dummyBlueTexture",!0),rn.tryToSetUniqueName("dummyBlackTexture",!0),qt.tryToSetUniqueName("dummyBlackCubeTexture",!0),Tr.tryToSetUniqueName("dummyZeroTexture",!0),Zs.tryToSetUniqueName("sheenLutTexture",!0),vm.tryToSetUniqueName("dummySRGBGrayTexture",!0),Js.tryToSetUniqueName("dummyAnisotropyTexture",!0),va.tryToSetUniqueName("dummyDepthMomentTextureArray",!0),ct.generate1x1TextureFrom(),Ur.generate1x1TextureFrom("rgba(127.5, 127.5, 255, 1)"),rn.generate1x1TextureFrom("rgba(0, 0, 0, 1)"),qt.load1x1Texture("rgba(0, 0, 0, 1)"),Tr.generate1x1TextureFrom("rgba(0, 0, 0, 0)"),await Zs.generateSheenLutTextureFromDataUri(),vm.generate1x1TextureFrom("rgba(186, 186, 186, 1)"),Js.generate1x1TextureFrom("rgba(255, 127.5, 255, 1)"),va.load1x1Texture("rgba(255, 255, 255, 1)"))}var ct,Ur,rn,qt,Tr,Zs,vm,Js,va,ga,mo=C(()=>{"use strict";dm();Ni();kh();ct=new Jt,Ur=new Jt,rn=new Jt,qt=new Ri,Tr=new Jt,Zs=new Jt,vm=new Jt,Js=new Jt,va=new xa;h(Wh,"initDefaultTextures");ga={dummyWhiteTexture:ct,dummyBlueTexture:Ur,dummyBlackTexture:rn,dummyBlackCubeTexture:qt,dummyZeroTexture:Tr,sheenLutTexture:Zs,dummySRGBGrayTexture:vm,dummyAnisotropyTexture:Js,dummyDepthMomentTextureArray:va}});var Qh,BW,Xh,Cc,M2=C(()=>{"use strict";Qh=Hm(_m(),1);xe();se();it();tt();sr();Ot();fo();or();Yt();gi();em();Zt();mo();un();Pn();me();BW=Qh.default.default||Qh.default,Xh=class Xh{static fillTemplate(n,t){let o=Object.assign(t,{WellKnownComponentTIDs:Q,Config:F});return BW.fillTemplate(n,o)}static getShaderDataReflection(n){let t=this.__copyShaderityObject(n),o=new Map,r=n.code.split(/\r\n|\n/),i=[],a=[];for(let s of r){let l=/^[\t ]*\/\/[\t ]*#param[\t ]+(\w+)[ \t]*:[\t ]*([\w><]+);[\t ]*(\/\/)*[\t ]*(.*)/,c=s.match(l),u=/^[\t ]*@group\(1\) @binding\((\d+)\)[ \t]*var[ \t]*(\w+)[ \t]*:[ \t]*([\w><]+);[\t ]*\/\/*[\t ]*(.*)/,_=s.match(u),d=/^[\t ]*@group\(2\) @binding\((\d+)\)[ \t]*var[ \t]*(\w+)[ \t]*:[ \t]*sampler;/,p=s.match(d);if(c){let x=c[2],v=c[1],y=c[4],g=this.__createShaderSemanticsInfo(x,v,y,n.isFragmentShader);a.push(g)}else if(_){let x=parseInt(_[1]),v=_[2],y=_[3],g=_[4],E=this.__createShaderSemanticInfoForTexture(y,v,x,g,n.isFragmentShader);o.set(x,E),a.push(E)}else if(p){let x=parseInt(p[1]),v=p[2];if(o.has(x)){let y=o.get(x);if(y){let g=new Ge({magFilter:U.Linear,minFilter:U.Linear,wrapS:U.Repeat,wrapT:U.Repeat,wrapR:U.Repeat,anisotropy:!1});y.initialValue[2]=g}}}else i.push(s)}return t.code=i.join(`
`),{shaderSemanticsInfoArray:a,shaderityObject:t}}static __createShaderSemanticInfoForTexture(n,t,o,r,i){let a=I.Int,s=b.Texture2D;n.indexOf("texture_2d")!==-1?s=b.Texture2D:n.indexOf("texture_cube")!==-1&&(s=b.TextureCube);let l=i?D.PixelShader:D.VertexShader,c={semantic:t,compositionType:s,componentType:a,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!1,stage:l},u=r.match(/initialValue[\t ]*=[\t ]*(.+)[,\t ]*/);if(u){let _=u[1];c.initialValue=this.__getInitialValueFromTextForTexture(c,o,_)}else c.initialValue=this.__getDefaultInitialValue(c);return c}static __createShaderSemanticsInfo(n,t,o,r){let i=I.fromWgslString(n),a=b.fromWgslString(n),s=r?D.PixelShader:D.VertexShader,l={semantic:t,compositionType:a,componentType:i,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!1,stage:s};return this.__setRhodoniteOriginalParametersTo(l,o),l}static __setRhodoniteOriginalParametersTo(n,t){let o=t.match(/soloDatum[\t ]*=[\t ]*(\w+)[,\t ]*/),r=!1;(o==null?void 0:o[1])==="true"&&(r=!0),n.soloDatum=r;let i=t.match(/isInternalSetting[\t ]*=[\t ]*(\w+)[,\t ]*/),a=!1;(i==null?void 0:i[1])==="true"&&(a=!0),n.isInternalSetting=a;let s=t.match(/initialValue[\t ]*=[\t ]*(.+)[,\t ]*/);if(s){let c=s[1];n.initialValue=this.__getInitialValueFromText(n,c)}else n.initialValue=this.__getDefaultInitialValue(n);let l=t.match(/needUniformInDataTextureMode[\t ]*=[\t ]*(.+)[,\t ]*/);if(l){let c=!1;(l==null?void 0:l[1])==="true"&&(c=!0),n.needUniformInDataTextureMode=c}}static __getInitialValueFromTextForTexture(n,t,o){let r,i=new Ge({magFilter:U.Linear,minFilter:U.Linear,wrapS:U.ClampToEdge,wrapT:U.ClampToEdge,wrapR:U.ClampToEdge,anisotropy:!1});if(n.compositionType===b.Texture2D||n.compositionType===b.Texture2DShadow){let a=o.charAt(0).toUpperCase()+o.slice(1);r=[t,ga[`dummy${a}Texture`],i]}else if(n.compositionType===b.TextureCube){let a=o.charAt(0).toUpperCase()+o.slice(1);r=[t,ga[`dummy${a}CubeTexture`],i]}return r}static __getInitialValueFromText(n,t){let o=t.match(/\(([\d\w., ]+)\)/),r=h(a=>{n.compositionType!==a&&N.error("component number of initialValue is invalid:"+n.semantic)},"checkCompositionNumber"),i;if(o){let s=o[1].split(",");switch(s.length){case 1:r(b.Scalar),s[0]==="true"?i=new ut(new Float32Array([1])):s[0]==="false"?i=new ut(new Float32Array([0])):i=new ut(new Float32Array([parseFloat(s[0])]));break;case 2:r(b.Vec2),i=pt.fromCopyArray([parseFloat(s[0]),parseFloat(s[1])]);break;case 3:r(b.Vec3),i=L.fromCopyArray([parseFloat(s[0]),parseFloat(s[1]),parseFloat(s[2])]);break;case 4:r(b.Vec4),i=pe.fromCopyArray([parseFloat(s[0]),parseFloat(s[1]),parseFloat(s[2]),parseFloat(s[3])]);break;case 9:r(b.Mat3),i=We.fromCopy9RowMajor(parseFloat(s[0]),parseFloat(s[1]),parseFloat(s[2]),parseFloat(s[3]),parseFloat(s[4]),parseFloat(s[5]),parseFloat(s[6]),parseFloat(s[7]),parseFloat(s[8]));break;case 16:r(b.Mat4),i=$.fromCopy16RowMajor(parseFloat(s[0]),parseFloat(s[1]),parseFloat(s[2]),parseFloat(s[3]),parseFloat(s[4]),parseFloat(s[5]),parseFloat(s[6]),parseFloat(s[7]),parseFloat(s[8]),parseFloat(s[9]),parseFloat(s[10]),parseFloat(s[11]),parseFloat(s[12]),parseFloat(s[13]),parseFloat(s[14]),parseFloat(s[15]));break;default:N.error("Invalid format")}}else r(b.Scalar),t==="true"?i=new ut(new Float32Array([1])):t==="false"?i=new ut(new Float32Array([0])):i=new ut(new Float32Array([parseFloat(t)]));return i}static __getDefaultInitialValue(n){if(n.compositionType===b.Scalar)return new ut(new Float32Array([0]));if(n.compositionType===b.Vec2)return pt.zero();if(n.compositionType===b.Vec3)return L.zero();if(n.compositionType===b.Vec4)return pe.zero();if(n.compositionType===b.Mat2)return fa.identity();if(n.compositionType===b.Mat3)return We.identity();if(n.compositionType===b.Mat4)return $.identity();if(n.compositionType===b.Texture2D)return[0,ct];if(n.compositionType===b.Texture2DShadow)return[0,ct];if(n.compositionType===b.TextureCube)return[0,rn];N.warn("initial value is not found")}static __copyShaderityObject(n){return{code:n.code,shaderStage:n.shaderStage,isFragmentShader:n.shaderStage==="fragment"}}};h(Xh,"ShaderityUtilityWebGPU");Cc=Xh});var Hh,gm,qh,mr,ym=C(()=>{"use strict";Hh=Hm(_m(),1);xe();se();Xt();jo();it();tt();sr();Ot();fo();or();Yt();gi();em();Zt();mo();me();gm=Hh.default.default||Hh.default,qh=class qh{static fillTemplate(n,t){let o=Object.assign(t,{WellKnownComponentTIDs:Q,widthOfDataTexture:`const int widthOfDataTexture = ${we.bufferWidthLength};`,heightOfDataTexture:`const int heightOfDataTexture = ${we.bufferHeightLength};`,Config:F});return gm.fillTemplate(n,o)}static transformWebGLVersion(n,t){return t?gm.transformToGLSLES3(n):gm.transformToGLSLES1(n,!0)}static getAttributeReflection(n){let t=gm.createReflectionObject(n);this.__setDefaultAttributeSemanticMap(t),t.reflect();let o=t.attributesNames,r=t.attributesSemantics.map(s=>ee.fromString(s)),i=t.attributesTypes.map(s=>b.fromGlslString(s)),a=t.attributesTypes.map(s=>I.fromGlslString(s));return{names:o,semantics:r,compositions:i,components:a}}static __setDefaultAttributeSemanticMap(n){let t=new Map;t.set("instanceinfo","INSTANCE"),t.set("barycentriccoord","BARY_CENTRIC_COORD"),n.addAttributeSemanticsMap(t)}static getShaderDataReflection(n){let t=this.__copyShaderityObject(n),o=n.code.split(/\r\n|\n/),r=[],i=[];for(let a of o){let s=/^(?![/])[\t ]*uniform[\t ]+(\w+)[\t ]+(\w+);[\t ]*(\/\/)*[\t ]*(.*)/,l=a.match(s);if(l){let c=l[1],u=l[2],_=l[4];if(this.__ignoreThisUniformDeclaration(_)){r.push(a);continue}let d=this.__createShaderSemanticsInfo(c,u,_,n.isFragmentShader);i.push(d)}else r.push(a)}return t.code=r.join(`
`),{shaderSemanticsInfoArray:i,shaderityObject:t}}static __copyShaderityObject(n){return{code:n.code,shaderStage:n.shaderStage,isFragmentShader:n.shaderStage==="fragment"}}static __ignoreThisUniformDeclaration(n){let t=n.match(/skipProcess[\t ]*=[\t ]*(\w+)[,\t ]*/);return(t==null?void 0:t[1])==="true"}static __createShaderSemanticsInfo(n,t,o,r){let i=I.fromGlslString(n),a=b.fromGlslString(n),s=r?D.PixelShader:D.VertexShader;t=t.match(/u_(\w+)/)[1];let c={semantic:t,compositionType:a,componentType:i,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!1,stage:s};return this.__setRhodoniteOriginalParametersTo(c,o),c}static __setRhodoniteOriginalParametersTo(n,t){let o=t.match(/soloDatum[\t ]*=[\t ]*(\w+)[,\t ]*/),r=!1;(o==null?void 0:o[1])==="true"&&(r=!0),n.soloDatum=r;let i=t.match(/isInternalSetting[\t ]*=[\t ]*(\w+)[,\t ]*/),a=!1;(i==null?void 0:i[1])==="true"&&(a=!0),n.isInternalSetting=a;let s=t.match(/initialValue[\t ]*=[\t ]*(.+)[,\t ]*/);if(s){let c=s[1];n.initialValue=this.__getInitialValueFromText(n,c)}else n.initialValue=this.__getDefaultInitialValue(n);let l=t.match(/needUniformInDataTextureMode[\t ]*=[\t ]*(.+)[,\t ]*/);if(l){let c=!1;(l==null?void 0:l[1])==="true"&&(c=!0),n.needUniformInDataTextureMode=c}}static __getInitialValueFromText(n,t){let o=t.match(/\(([\d\w., ]+)\)/),r=h(a=>{n.compositionType!==a&&N.error("component number of initialValue is invalid:"+n.semantic)},"checkCompositionNumber"),i;if(o){let s=o[1].split(",");switch(s.length){case 1:r(b.Scalar),s[0]==="true"?i=new ut(new Float32Array([1])):s[0]==="false"?i=new ut(new Float32Array([0])):i=new ut(new Float32Array([parseFloat(s[0])]));break;case 2:if(n.compositionType===b.Texture2D||n.compositionType===b.Texture2DShadow){let l=s[1].charAt(0).toUpperCase()+s[1].slice(1);i=[parseInt(s[0]),ga[`dummy${l}Texture`]]}else if(n.compositionType===b.TextureCube){let l=s[1].charAt(0).toUpperCase()+s[1].slice(1);i=[parseInt(s[0]),ga[`dummy${l}CubeTexture`]]}else r(b.Vec2),i=pt.fromCopyArray([parseFloat(s[0]),parseFloat(s[1])]);break;case 3:r(b.Vec3),i=L.fromCopyArray([parseFloat(s[0]),parseFloat(s[1]),parseFloat(s[2])]);break;case 4:r(b.Vec4),i=pe.fromCopyArray([parseFloat(s[0]),parseFloat(s[1]),parseFloat(s[2]),parseFloat(s[3])]);break;case 9:r(b.Mat3),i=We.fromCopy9RowMajor(parseFloat(s[0]),parseFloat(s[1]),parseFloat(s[2]),parseFloat(s[3]),parseFloat(s[4]),parseFloat(s[5]),parseFloat(s[6]),parseFloat(s[7]),parseFloat(s[8]));break;case 16:r(b.Mat4),i=$.fromCopy16RowMajor(parseFloat(s[0]),parseFloat(s[1]),parseFloat(s[2]),parseFloat(s[3]),parseFloat(s[4]),parseFloat(s[5]),parseFloat(s[6]),parseFloat(s[7]),parseFloat(s[8]),parseFloat(s[9]),parseFloat(s[10]),parseFloat(s[11]),parseFloat(s[12]),parseFloat(s[13]),parseFloat(s[14]),parseFloat(s[15]));break;default:N.error("Invalid format")}}else r(b.Scalar),t==="true"?i=new ut(new Float32Array([1])):t==="false"?i=new ut(new Float32Array([0])):i=new ut(new Float32Array([parseFloat(t)]));return i}static __getDefaultInitialValue(n){if(n.compositionType===b.Scalar)return new ut(new Float32Array([0]));if(n.compositionType===b.Vec2)return pt.zero();if(n.compositionType===b.Vec3)return L.zero();if(n.compositionType===b.Vec4)return pe.zero();if(n.compositionType===b.Mat2)return fa.identity();if(n.compositionType===b.Mat3)return We.identity();if(n.compositionType===b.Mat4)return $.identity();if(n.compositionType===b.Texture2D)return[0,ct];if(n.compositionType===b.Texture2DShadow)return[0,ct];if(n.compositionType===b.TextureCube)return[0,rn];N.warn("initial value is not found")}};h(qh,"ShaderityUtilityWebGL");mr=qh});var Me,He,Go=C(()=>{"use strict";zn();tt();sr();fo();ye();Yt();Xt();Ke();Zi();Ze();Zt();Qn();St();M2();ym();yr();Me=class Me extends nt{constructor(t,{isMorphing:o=!1,isSkinning:r=!1,isLighting:i=!1}={},a,s){super();f(this,"__semantics",[]);f(this,"__materialName");f(this,"__definitions","");f(this,"__isMorphing");f(this,"__isSkinning");f(this,"__isLighting");f(this,"__materialContentUid");f(this,"shaderType",D.VertexAndPixelShader);this.__materialName=t,this.__isMorphing=o,this.__isSkinning=r,this.__isLighting=i,this.__materialContentUid=Me.__materialContentCount++,this.setVertexShaderityObject(a),this.setPixelShaderityObject(s)}setVertexShaderityObject(t){var o;if(t)if(Me.__vertexShaderityObjectMap.has(t.code)){let r=(o=Me.__vertexShaderityObjectMap.get(t.code))!=null?o:[];r.push(this.__materialContentUid),Me.__vertexShaderityObjectMap.set(t.code,r)}else Me.__vertexShaderityObjectMap.set(t.code,[this.__materialContentUid])}setPixelShaderityObject(t){var o;if(t)if(Me.__pixelShaderityObjectMap.has(t.code)){let r=(o=Me.__pixelShaderityObjectMap.get(t.code))!=null?o:[];r.push(this.__materialContentUid),Me.__pixelShaderityObjectMap.set(t.code,r)}else Me.__pixelShaderityObjectMap.set(t.code,[this.__materialContentUid])}getMaterialSemanticsVariantName(){let t="";for(let r of this.__semantics)t+=`${r.semantic} ${r.stage.index} ${r.componentType.index} ${r.compositionType.index} ${r.soloDatum} ${r.isInternalSetting} ${r.arrayLength} ${r.needUniformInDataTextureMode}
`;let o=ie.toCRC32(t);return this.__materialName+"_semanticsVariation"+o}get vertexShaderityObject(){for(let[t,o]of Me.__vertexShaderityObjectMap.entries())if(o.includes(this.__materialContentUid))return{code:t,shaderStage:"vertex",isFragmentShader:!1}}get pixelShaderityObject(){for(let[t,o]of Me.__pixelShaderityObjectMap.entries())if(o.includes(this.__materialContentUid))return{code:t,shaderStage:"fragment",isFragmentShader:!0}}getDefinitions(){return this.__definitions}static getMaterialNode(t){return Me.materialNodes[t]}get _semanticsInfoArray(){return this.__semantics}get isSkinning(){return this.__isSkinning}get isMorphing(){return this.__isMorphing}get isLighting(){return this.__isLighting}setShaderSemanticsInfoArray(t){let o=[];for(let r of t)o.push(r);this.__semantics=o}setupBasicInfo(t,o,r,i,a){if(t.setUniform){if(this.setWorldMatrix(o,t.worldMatrix),this.setNormalMatrix(o,t.normalMatrix),this.setIsBillboard(o,t.isBillboard),r||t.isVr){let l=t.renderPass.cameraComponent;l==null&&(l=J.getComponent(a,a.current)),this.setViewInfo(o,l,t.isVr,t.displayIdx),this.setProjection(o,l,t.isVr,t.displayIdx)}if(r){this.setLightsInfo(o,t.lightComponents,i,t.setUniform);let l=t.entity.tryToGetSkeletal();this.setSkinning(o,t.setUniform,l)}}let s=t.entity.tryToGetBlendShape();this.setMorphInfo(o,t.entity.getMesh(),t.primitive,s)}setWorldMatrix(t,o){t._gl.uniformMatrix4fv(t.worldMatrix,!1,o._v)}setNormalMatrix(t,o){t._gl.uniformMatrix3fv(t.normalMatrix,!1,o._v)}setIsBillboard(t,o){t._gl.uniform1i(t.isBillboard,o?1:0)}setViewInfo(t,o,r,i){let a,s;if(r){let c=Pe.getInstance().getModule("xr").WebXRSystem.getInstance();c.isWebXRMode&&(a=c._getViewMatrixAt(i),s=c._getCameraWorldPositionAt(i))}else o?(s=o.worldPosition,a=o.viewMatrix):(a=$.identity(),s=S.fromCopyArray([0,0,10]));t._gl.uniformMatrix4fv(t.viewMatrix,!1,a._v),t._gl.uniform3fv(t.viewPosition,s._v)}setProjection(t,o,r,i){let a;if(r){let l=Pe.getInstance().getModule("xr").WebXRSystem.getInstance();l.isWebXRMode&&(a=l._getProjectMatrixAt(i))}else o?a=o.projectionMatrix:a=$.identity();t._gl.uniformMatrix4fv(t.projectionMatrix,!1,a._v)}setSkinning(t,o,r){if(this.__isSkinning)if(r){if(o){if(F.boneDataType===ke.Mat43x1){let i=r.jointMatricesArray;t._gl.uniformMatrix4x3fv(t.boneMatrix,!1,i)}else if(F.boneDataType===ke.Vec4x2){let i=r.jointTranslatePackedQuat,a=r.jointScalePackedQuat;t._gl.uniform4fv(t.boneTranslatePackedQuat,i),t._gl.uniform4fv(t.boneScalePackedQuat,a)}else if(F.boneDataType===ke.Vec4x2Old){let i=r.jointQuaternionArray,a=r.jointTranslateScaleArray;t._gl.uniform4fv(t.boneQuaternion,i),t._gl.uniform4fv(t.boneTranslateScale,a)}else if(F.boneDataType===ke.Vec4x1){let i=r.jointCompressedChunk,a=r.jointCompressedInfo;t._gl.uniform4fv(t.boneCompressedChunk,i),t._gl.uniform4fv(t.boneCompressedInfo,a._v)}t._gl.uniform1i(t.skinningMode,r.componentSID)}}else o&&t._gl.uniform1i(t.skinningMode,-1)}setLightsInfo(t,o,r,i){if(this.__isLighting&&i){let a=o.filter(l=>l.enable);t._gl.uniform1i(t.lightNumber,a.length);let s=Math.min(a.length,F.maxLightNumberInShader);Me.__lightPositions.length!==3*s&&(Me.__lightPositions=new Float32Array(3*s),Me.__lightDirections=new Float32Array(3*s),Me.__lightIntensities=new Float32Array(3*s),Me.__lightProperties=new Float32Array(4*s));for(let l=0;l<a.length&&!(l>=F.maxLightNumberInShader||t.lightPosition==null);l++){let c=a[l],_=c.entity.getSceneGraph().worldPosition,d=c.direction,p=c.intensity,x=c.color;Me.__lightPositions[l*3+0]=_.x,Me.__lightPositions[l*3+1]=_.y,Me.__lightPositions[l*3+2]=_.z;let v=1/Math.max(.001,Math.cos(c.innerConeAngle)-Math.cos(c.outerConeAngle)),y=-Math.cos(c.outerConeAngle)*v;Me.__lightDirections[l*3+0]=d.x,Me.__lightDirections[l*3+1]=d.y,Me.__lightDirections[l*3+2]=d.z,Me.__lightIntensities[l*3+0]=x.x*p,Me.__lightIntensities[l*3+1]=x.y*p,Me.__lightIntensities[l*3+2]=x.z*p,Me.__lightProperties[l*4+0]=c.enable?c.type.index:-1,Me.__lightProperties[l*4+1]=c.range,Me.__lightProperties[l*4+2]=v,Me.__lightProperties[l*4+3]=y}s>0&&(t._gl.uniform3fv(t.lightPosition,Me.__lightPositions),t._gl.uniform3fv(t.lightDirection,Me.__lightDirections),t._gl.uniform3fv(t.lightIntensity,Me.__lightIntensities),t._gl.uniform4fv(t.lightProperty,Me.__lightProperties))}}setMorphInfo(t,o,r,i){if(!this.__isMorphing)return;if(r.targets.length===0){t._gl.uniform1i(t.morphTargetNumber,0);return}t._gl.uniform1i(t.morphTargetNumber,r.targets.length);let a=r.targets.map(l=>{let c=l.get(ee.Position.XYZ),u=0;return Z.isDataTextureApproach(K.currentProcessApproach)&&(u=F.totalSizeOfGPUShaderDataStorageExceptMorphData),(u+c.byteOffsetInBuffer)/4/4});t._gl.uniform1iv(t.dataTextureMorphOffsetPosition,a);let s;i.weights.length>0?s=i.weights:s=new Float32Array(r.targets.length),t._gl.uniform1fv(t.morphWeights,s)}_setInternalSettingParametersToGpuWebGL({material:t,shaderProgram:o,firstTime:r,args:i}){}_setInternalSettingParametersToGpuWebGLPerPrimitive({material:t,shaderProgram:o,firstTime:r,args:i}){}_setInternalSettingParametersToGpuWebGpu({material:t,args:o}){}getDefinition(){return""}doShaderReflection(t,o,r,i){let a,s;K.currentProcessApproach===Z.WebGPU?(a=Cc.getShaderDataReflection(r),s=Cc.getShaderDataReflection(i),this.setVertexShaderityObject(a.shaderityObject),this.setPixelShaderityObject(s.shaderityObject)):(a=mr.getShaderDataReflection(t),s=mr.getShaderDataReflection(o),this.setVertexShaderityObject(a.shaderityObject),this.setPixelShaderityObject(s.shaderityObject));let l=[];for(let c of a.shaderSemanticsInfoArray)c.stage=D.VertexShader,l.push(c);for(let c of s.shaderSemanticsInfoArray){let u=l.find(_=>_.semantic===c.semantic);u?u.stage=D.VertexAndPixelShader:(c.stage=D.PixelShader,l.push(c))}return l}};h(Me,"AbstractMaterialContent"),f(Me,"materialNodes",[]),f(Me,"__gl"),f(Me,"__tmp_vector4",pe.zero()),f(Me,"__tmp_vector2",pt.zero()),f(Me,"__lightPositions",new Float32Array(0)),f(Me,"__lightDirections",new Float32Array(0)),f(Me,"__lightIntensities",new Float32Array(0)),f(Me,"__lightProperties",new Float32Array(0)),f(Me,"__materialContentCount",0),f(Me,"__vertexShaderityObjectMap",new Map),f(Me,"__pixelShaderityObjectMap",new Map);He=Me});var B2,D2=C(()=>{B2={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec3 a_position;
in vec3 a_normal;
in vec4 a_instanceInfo;
in vec4 a_joint;
in vec4 a_weight;

out vec3 v_normal_inWorld;
out vec4 v_position_inLocal;
out vec4 v_position_inWorld;

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

mat3 toNormalMatrix(mat4 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];

  float b00 = a00 * a11 - a01 * a10,
  b01 = a00 * a12 - a02 * a10,
  b02 = a00 * a13 - a03 * a10,
  b03 = a01 * a12 - a02 * a11,
  b04 = a01 * a13 - a03 * a11,
  b05 = a02 * a13 - a03 * a12,
  b06 = a20 * a31 - a21 * a30,
  b07 = a20 * a32 - a22 * a30,
  b08 = a20 * a33 - a23 * a30,
  b09 = a21 * a32 - a22 * a31,
  b10 = a21 * a33 - a23 * a31,
  b11 = a22 * a33 - a23 * a32;

  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3(
    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,
    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,
    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;
}



#ifdef RN_IS_SKINNING

highp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {
  highp vec4 q = quaternion;
  highp vec3 t = translation;

  highp float sx = q.x * q.x;
  highp float sy = q.y * q.y;
  highp float sz = q.z * q.z;
  highp float cx = q.y * q.z;
  highp float cy = q.x * q.z;
  highp float cz = q.x * q.y;
  highp float wx = q.w * q.x;
  highp float wy = q.w * q.y;
  highp float wz = q.w * q.z;

  highp mat4 mat = mat4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  highp mat4 uniformScaleMat = mat4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return mat*uniformScaleMat;
}

highp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){

  highp float r;
  highp float g;
  highp float b;
  highp float a;

  highp float ix = floor(vec_xy.x * criteria);
  highp float v1x = ix / criteria;
  highp float v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  highp float iy = floor( vec_xy.y * criteria);
  highp float v2x = iy / criteria;
  highp float v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4(r, g, b, a);
}

mat4 getSkinMatrix(float skeletalComponentSID) {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));
  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));
  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));
  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  vec2 criteria = vec2(4096.0, 4096.0);

  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));
  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));
  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));
  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));
  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));
  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));
  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));

  vec2 criteria = vec2(4096.0, 4096.0);
  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif



#ifdef RN_IS_SKINNING
bool skinning(
  float skeletalComponentSID,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
  )
{
  mat4 skinMat = getSkinMatrix(skeletalComponentSID);
  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);
  outNormalMatrix = toNormalMatrix(skinMat);
  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);

  return true;
}
#endif

bool processGeometryWithMorphingAndSkinning(
  float skeletalComponentSID,
  in mat4 worldMatrix,
  in mat4 viewMatrix,
  in bool isBillboard,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
) {
  bool isSkinning = false;

  vec3 position_inLocal;
#ifdef RN_IS_MORPHING
  if (u_morphTargetNumber == 0) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    float vertexIdx = a_baryCentricCoord.w;
    position_inLocal = get_position(vertexIdx, inPosition_inLocal);
  }
#endif

  mat4 worldMatrixInner = worldMatrix;
  if (isBillboard) {
    mat4 inverseViewMatrix = inverse(viewMatrix);
    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];
    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];
    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];
    worldMatrixInner = inverseViewMatrix * worldMatrix;
  }

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0.0) {
    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);
  } else {
#endif
    outNormalMatrix = inNormalMatrix;
    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
#ifdef RN_IS_SKINNING
  }
#endif

  return isSkinning;
}


void main(){

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);

  // Skeletal
  processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    worldMatrix,
    viewMatrix,
    false,
    normalMatrix,
    normalMatrix,
    a_position,
    v_position_inWorld,
    a_normal,
    v_normal_inWorld
  );

  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;

  v_position_inLocal = gl_Position;

// #ifdef RN_IS_POINTSPRITE

vec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);
vec3 viewPosition = get_viewPosition(cameraSID, 0);
float distanceFromCamera = length(position_inWorld.xyz - viewPosition);
vec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);
float distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));
float maxPointSize = get_pointSize(materialSID, 0);
gl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);

// #endif


}
`,shaderStage:"vertex",isFragmentShader:!1}});var L2,F2=C(()=>{L2={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec4 v_position_inLocal;

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

vec4 encodeDepthToRGBA(float depth){
  float r = depth;
  float g = fract(r * 255.0);
  float b = fract(g * 255.0);
  float a = fract(b * 255.0);
  float coef = 1.0 / 255.0;
  r -= g * coef;
  g -= b * coef;
  b -= a * coef;
  return vec4(r, g, b, a);
}

void main (){

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif

  float depth;
  bool isPointLight = get_isPointLight(materialSID, 0);
  if(isPointLight){
    float zNear = get_zNearInner(materialSID, 0);
    float zFar = get_zFarInner(materialSID, 0);
    float normalizationCoefficient = 1.0 / (zFar - zNear);
    depth = normalizationCoefficient * length(v_position_inLocal);
  }else{
    depth = gl_FragCoord.z;
  }

  float depthPow = get_depthPow(materialSID, 0);
  float depthData = pow(depth, depthPow);
  vec4 encodedDepth = encodeDepthToRGBA(depthData);

  rt0 = encodedDepth;

/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var ya,wc,jh=C(()=>{"use strict";Go();$t();St();xe();se();Tn();So();Zt();ye();D2();F2();ya=class ya extends He{constructor(t,o,{isSkinning:r}){super(t,{isMorphing:!1,isSkinning:r,isLighting:!1},B2,L2);f(this,"__lastZNear",0);f(this,"__lastZFar",0);let i=[{semantic:"zNearInner",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,isInternalSetting:!0,initialValue:te.fromCopyNumber(.1),min:1e-4,max:Number.MAX_SAFE_INTEGER},{semantic:"zFarInner",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,isInternalSetting:!0,initialValue:te.fromCopyNumber(1e4),min:1e-4,max:Number.MAX_SAFE_INTEGER},{semantic:"isPointLight",componentType:I.Bool,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(1),min:0,max:1},{semantic:"depthPow",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(o),min:1,max:2},{semantic:"pointSize",componentType:I.Float,compositionType:b.Scalar,stage:D.VertexShader,soloDatum:!0,initialValue:te.fromCopyNumber(30),min:0,max:100},{semantic:"pointDistanceAttenuation",componentType:I.Float,compositionType:b.Vec3,stage:D.VertexShader,soloDatum:!0,initialValue:S.fromCopyArray([0,.1,.01]),min:0,max:1}];this.setShaderSemanticsInfoArray(i)}_setInternalSettingParametersToGpuWebGL({material:t,shaderProgram:o,firstTime:r,args:i}){let a=i.renderPass.cameraComponent;a==null&&(a=J.getComponent(re,re.current)),i.setUniform?(this.setWorldMatrix(o,i.worldMatrix),this.setNormalMatrix(o,i.normalMatrix),this.setViewInfo(o,a,i.isVr,i.displayIdx),this.setProjection(o,a,i.isVr,i.displayIdx),(r||this.__lastZNear!==a.zNearInner)&&(o._gl.uniform1f(o.zNearInner,a.zNearInner),this.__lastZNear=a.zNearInner),this.__lastZFar!==a.zFarInner&&(o._gl.uniform1f(o.zFarInner,a.zFarInner),this.__lastZFar=a.zFarInner)):(t.setParameter("zNearInner",a.zNearInner),t.setParameter("zFarInner",a.zFarInner));let s=i.entity.tryToGetSkeletal();this.setSkinning(o,i.setUniform,s)}};h(ya,"DepthEncodeMaterialContent"),f(ya,"zNearInner",new B({str:"zNearInner"})),f(ya,"zFarInner",new B({str:"zFarInner"})),f(ya,"isPointLight",new B({str:"isPointLight"})),f(ya,"depthPow",new B({str:"depthPow"}));wc=ya});var z2,V2=C(()=>{z2={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec3 a_position;
in vec3 a_color;
in vec3 a_normal;
in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec2 a_texcoord_1;
in vec4 a_joint;
in vec4 a_weight;
out vec3 v_color;
out vec3 v_normal_inWorld;
out vec4 v_position_inWorld;
out vec2 v_texcoord_0;
out vec4 v_texcoord_1;
out vec4 v_projPosition_from_light;


precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

mat3 toNormalMatrix(mat4 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];

  float b00 = a00 * a11 - a01 * a10,
  b01 = a00 * a12 - a02 * a10,
  b02 = a00 * a13 - a03 * a10,
  b03 = a01 * a12 - a02 * a11,
  b04 = a01 * a13 - a03 * a11,
  b05 = a02 * a13 - a03 * a12,
  b06 = a20 * a31 - a21 * a30,
  b07 = a20 * a32 - a22 * a30,
  b08 = a20 * a33 - a23 * a30,
  b09 = a21 * a32 - a22 * a31,
  b10 = a21 * a33 - a23 * a31,
  b11 = a22 * a33 - a23 * a32;

  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3(
    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,
    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,
    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;
}



#ifdef RN_IS_SKINNING

highp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {
  highp vec4 q = quaternion;
  highp vec3 t = translation;

  highp float sx = q.x * q.x;
  highp float sy = q.y * q.y;
  highp float sz = q.z * q.z;
  highp float cx = q.y * q.z;
  highp float cy = q.x * q.z;
  highp float cz = q.x * q.y;
  highp float wx = q.w * q.x;
  highp float wy = q.w * q.y;
  highp float wz = q.w * q.z;

  highp mat4 mat = mat4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  highp mat4 uniformScaleMat = mat4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return mat*uniformScaleMat;
}

highp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){

  highp float r;
  highp float g;
  highp float b;
  highp float a;

  highp float ix = floor(vec_xy.x * criteria);
  highp float v1x = ix / criteria;
  highp float v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  highp float iy = floor( vec_xy.y * criteria);
  highp float v2x = iy / criteria;
  highp float v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4(r, g, b, a);
}

mat4 getSkinMatrix(float skeletalComponentSID) {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));
  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));
  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));
  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  vec2 criteria = vec2(4096.0, 4096.0);

  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));
  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));
  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));
  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));
  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));
  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));
  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));

  vec2 criteria = vec2(4096.0, 4096.0);
  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif



#ifdef RN_IS_SKINNING
bool skinning(
  float skeletalComponentSID,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
  )
{
  mat4 skinMat = getSkinMatrix(skeletalComponentSID);
  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);
  outNormalMatrix = toNormalMatrix(skinMat);
  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);

  return true;
}
#endif

bool processGeometryWithMorphingAndSkinning(
  float skeletalComponentSID,
  in mat4 worldMatrix,
  in mat4 viewMatrix,
  in bool isBillboard,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
) {
  bool isSkinning = false;

  vec3 position_inLocal;
#ifdef RN_IS_MORPHING
  if (u_morphTargetNumber == 0) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    float vertexIdx = a_baryCentricCoord.w;
    position_inLocal = get_position(vertexIdx, inPosition_inLocal);
  }
#endif

  mat4 worldMatrixInner = worldMatrix;
  if (isBillboard) {
    mat4 inverseViewMatrix = inverse(viewMatrix);
    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];
    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];
    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];
    worldMatrixInner = inverseViewMatrix * worldMatrix;
  }

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0.0) {
    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);
  } else {
#endif
    outNormalMatrix = inNormalMatrix;
    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
#ifdef RN_IS_SKINNING
  }
#endif

  return isSkinning;
}


void main(){

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);

  // Skeletal
  processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    worldMatrix,
    viewMatrix,
    false,
    normalMatrix,
    normalMatrix,
    a_position,
    v_position_inWorld,
    a_normal,
    v_normal_inWorld
  );

  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;

// #ifdef RN_IS_POINTSPRITE

vec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);
vec3 viewPosition = get_viewPosition(cameraSID, 0);
float distanceFromCamera = length(position_inWorld.xyz - viewPosition);
vec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);
float distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));
float maxPointSize = get_pointSize(materialSID, 0);
gl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);

// #endif


  // Shadow mapping
  mat4 lightViewProjectionMatrix = get_lightViewProjectionMatrix(materialSID, 0);
  v_projPosition_from_light = lightViewProjectionMatrix * v_position_inWorld;

  // Following tMatrix is based on https://wgld.org/d/webgl/w051.html
  mat4 tMatrix = mat4(
    0.5, 0.0, 0.0, 0.0,
    0.0, 0.5, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    0.5, 0.5, 0.0, 1.0
  );
  v_texcoord_1 = tMatrix * v_projPosition_from_light;

  v_color = a_color;
  v_normal_inWorld = normalMatrix * a_normal;
  v_texcoord_0 = a_texcoord_0;

}
`,shaderStage:"vertex",isFragmentShader:!1}});var O2,G2=C(()=>{O2={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec3 v_color;
in vec3 v_normal_inWorld;
in vec4 v_position_inWorld;
in vec2 v_texcoord_0;
in vec4 v_texcoord_1;
in vec4 v_projPosition_from_light;

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

struct Light {
  int type; // 0 = directional, 1 = point, 2 = spot
  vec3 position;
  vec3 intensity;
  vec3 attenuatedIntensity;
  vec3 directionOfLightObject;
  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)
  vec3 pointToLight; // not normalized
  float innerConeCos;
  float outerConeCos;
  float effectiveRange;
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
float getRangeAttenuation(Light light)
{
  float distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
float getSpotAttenuation(Light light)
{
  float actualCos = dot(light.direction, -light.directionOfLightObject);
  if (actualCos > light.outerConeCos) {
    if (actualCos < light.innerConeCos) {
      float attenuation = (actualCos - light.outerConeCos) / (light.innerConeCos - light.outerConeCos);
      return attenuation * attenuation;
    }
    return 1.0;
  }
  return 0.0;
}

vec3 getLightAttenuated(Light light) {
  light.attenuatedIntensity = light.intensity;
  // if (light.type == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light && Spot Light
  if (light.type != 0)
  {
    light.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot Light
  if (light.type == 2)
  {
    light.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return light.attenuatedIntensity;
}

Light getLight(int lightIdx, vec3 v_position_inWorld) {
  vec3 lightPosition = get_lightPosition(0.0, lightIdx);
  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);
  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);
  vec4 lightProperty = get_lightProperty(0.0, lightIdx);
  Light light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  float lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.innerConeCos = lightProperty.z;
  light.outerConeCos = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3(0.0);
    light.type = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.type = 1;
  } else { // is Directional Light
    light.type = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.type = 2;
  }

  const float M_PI = 3.141592653589793;
  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  light.attenuatedIntensity = getLightAttenuated(light);

  return light;
}


float decodeRGBAToDepth(vec4 RGBA){
  const float rMask = 1.0;
  const float gMask = 1.0 / 255.0;
  const float bMask = 1.0 / (255.0 * 255.0);
  const float aMask = 1.0 / (255.0 * 255.0 * 255.0);
  float depth = dot(RGBA, vec4(rMask, gMask, bMask, aMask));
  return depth;
}

void main (){
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  // Normal
  vec3 normal_inWorld = normalize(v_normal_inWorld);

  // diffuseColor
  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);
  float alpha = 1.0;

  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);
  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {
    diffuseColor = v_color * diffuseColorFactor.rgb;
    alpha = diffuseColorFactor.a;
  } else if (v_color == diffuseColor) {
    diffuseColor = diffuseColorFactor.rgb;
    alpha = diffuseColorFactor.a;
  } else if (diffuseColorFactor.rgb == diffuseColor) {
    diffuseColor = v_color;
  } else {
    diffuseColor = vec3(1.0, 1.0, 1.0);
  }

  // diffuseColorTexture
  vec4 textureColor = texture(u_diffuseColorTexture, v_texcoord_0);
  if (textureColor.r > 0.05) {
    diffuseColor *= textureColor.rgb;
    alpha *= textureColor.a;
  }

  // shadow mapping
  if(v_projPosition_from_light.w > 0.0){
    float zNear = get_zNearInner(materialSID, 0);
    float zFar = get_zFarInner(materialSID, 0);
    float normalizationCoefficient = 1.0 / (zFar - zNear);

    vec2 shadowMapUV = v_texcoord_1.xy / v_texcoord_1.w;

    #ifdef RN_IS_DEBUGGING
      bool inShadowMap = (shadowMapUV.x >= 0.0 && shadowMapUV.x <= 1.0) && (shadowMapUV.y >= 0.0 && shadowMapUV.y <= 1.0);
      if(inShadowMap == false){
        rt0 = get_debugColorFactor(materialSID, 0);
/* shaderity: @{renderTargetEnd} */

        return;
      }
    #endif

    float measureDepth = normalizationCoefficient * length(v_projPosition_from_light);
    float textureDepth = decodeRGBAToDepth(texture(u_depthTexture, shadowMapUV));
    float allowableDepthError = get_allowableDepthError(materialSID, 0);

    if(measureDepth > textureDepth + allowableDepthError){
      // case of shadow
      vec4 shadowColorFactor = get_shadowColorFactor(materialSID, 0);
      diffuseColor = shadowColorFactor.rgb;
      alpha = shadowColorFactor.a;
    }
  }

  // Lighting
  vec3 shadingColor = vec3(0.0, 0.0, 0.0);
  int shadingModel = get_shadingModel(materialSID, 0);
  if (shadingModel > 0) {

    vec3 diffuse = vec3(0.0, 0.0, 0.0);
    vec3 specular = vec3(0.0, 0.0, 0.0);
    int lightNumber = get_lightNumber(materialSID, 0);
    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {
      if (i >= lightNumber) {
        break;
      }

      // Light
      Light light = getLight(i, v_position_inWorld.xyz);

      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, light.direction)) * light.attenuatedIntensity;

      vec3 viewPosition = get_viewPosition(cameraSID, 0);
      float shininess = get_shininess(materialSID, 0);
      if (shadingModel == 2) {// BLINN
        // ViewDirection
        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);
        vec3 halfVector = normalize(light.direction + viewDirection);
        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), shininess);
      } else if (shadingModel == 3) { // PHONG
        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);
        vec3 R = reflect(light.direction, normal_inWorld);
        specular += pow(max(0.0, dot(R, viewDirection)), shininess);
      }

    }

    shadingColor = diffuse + specular;
  } else {
    shadingColor = diffuseColor;
  }

  rt0 = vec4(shadingColor, alpha);
  //rt0 = vec4(u_lightNumber, 0.0, 0.0, 1.0);

/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var Hn,Rc,Yh=C(()=>{"use strict";So();Go();se();xe();It();ye();Jl();Zt();St();$t();Ao();Tn();tt();ft();Yt();V2();G2();mo();me();Hn=class Hn extends He{constructor(t,{isMorphing:o,isSkinning:r,isLighting:i,isDebugging:a,colorAttachmentsNumber:s},l){super(t,{isMorphing:o,isSkinning:r,isLighting:i},z2,O2);f(this,"__encodedDepthRenderPass");this.__encodedDepthRenderPass=l;let c=l.getFramebuffer();if(c==null){N.error("encodedDepthRenderPass does not have framebuffer");return}let u=c.colorAttachments[s],_=l.getViewport();_.setComponents(1,1,_.z-1,_.w-1),l.setViewport(_);let d=[{semantic:"lightViewProjectionMatrix",compositionType:b.Mat4,componentType:I.Float,stage:D.VertexShader,initialValue:$.zero(),min:-Number.MAX_VALUE,max:Number.MAX_VALUE},{semantic:"shadingModel",compositionType:b.Scalar,componentType:I.Int,stage:D.PixelShader,initialValue:te.fromCopyNumber(To.Constant.index),min:0,max:3},{semantic:"shininess",compositionType:b.Scalar,componentType:I.Float,stage:D.PixelShader,initialValue:te.fromCopyNumber(5),min:0,max:Number.MAX_VALUE},{semantic:"allowableDepthError",compositionType:b.Scalar,componentType:I.Float,stage:D.PixelShader,initialValue:te.fromCopyNumber(1e-4),min:0,max:1},{semantic:"shadowColorFactor",compositionType:b.Vec4,componentType:I.Float,stage:D.PixelShader,initialValue:q.fromCopyArray([.5,.5,.5,1]),min:0,max:1},{semantic:"diffuseColorFactor",compositionType:b.Vec4,componentType:I.Float,stage:D.PixelShader,initialValue:q.fromCopyArray([1,1,1,1]),min:0,max:2},{semantic:"isPointLight",componentType:I.Bool,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(1),min:0,max:1},{semantic:"wireframe",componentType:I.Float,compositionType:b.Vec3,stage:D.PixelShader,initialValue:S.fromCopyArray([0,0,1]),min:0,max:10},{semantic:"normalTexture",compositionType:b.Texture2D,componentType:I.Int,stage:D.PixelShader,initialValue:[0,Ur],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"depthTexture",compositionType:b.Texture2D,componentType:I.Int,stage:D.PixelShader,initialValue:[0,u],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"diffuseColorTexture",compositionType:b.Texture2D,componentType:I.Int,stage:D.PixelShader,initialValue:[1,ct],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"zNearInner",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,isInternalSetting:!0,initialValue:te.fromCopyNumber(.1),min:1e-4,max:Number.MAX_SAFE_INTEGER},{semantic:"zFarInner",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,isInternalSetting:!0,initialValue:te.fromCopyNumber(1e4),min:1e-4,max:Number.MAX_SAFE_INTEGER}];d.push({semantic:"pointSize",componentType:I.Float,compositionType:b.Scalar,stage:D.VertexShader,soloDatum:!0,initialValue:te.fromCopyNumber(30),min:0,max:100},{semantic:"pointDistanceAttenuation",componentType:I.Float,compositionType:b.Vec3,stage:D.VertexShader,soloDatum:!0,initialValue:S.fromCopyArray([0,.1,.01]),min:0,max:1}),o&&d.push({semantic:"morphTargetNumber",componentType:I.Int,compositionType:b.Scalar,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:te.fromCopyNumber(0),min:0,max:F.maxVertexMorphNumberInShader,needUniformInDataTextureMode:!0},{semantic:"dataTextureMorphOffsetPosition",componentType:I.Int,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Int32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:I.Float,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Float32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0}),a&&d.push({semantic:"debugColorFactor",compositionType:b.Vec4,componentType:I.Float,stage:D.PixelShader,initialValue:q.fromCopyArray([1,0,0,1]),min:0,max:2}),this.setShaderSemanticsInfoArray(d)}_setInternalSettingParametersToGpuWebGL({material:t,shaderProgram:o,firstTime:r,args:i}){let a=i.renderPass.cameraComponent;a==null&&(a=J.getComponent(re,re.current));let s=this.__encodedDepthRenderPass.cameraComponent;i.setUniform?(this.setWorldMatrix(o,i.worldMatrix),this.setNormalMatrix(o,i.normalMatrix),this.setViewInfo(o,a,i.isVr,i.displayIdx),this.setProjection(o,a,i.isVr,i.displayIdx),Hn.__lastZNear!==s.zNearInner&&(o._gl.uniform1f(o.zNearInner,s.zNearInner),Hn.__lastZNear=s.zNearInner),Hn.__lastZFar!==s.zFarInner&&(o._gl.uniform1f(o.zFarInner,s.zFarInner),Hn.__lastZFar=s.zFarInner),G.getWebGLResourceRepository().setUniformValue(o,Xe.LightViewProjectionMatrix.str,!0,this.__encodedDepthRenderPass.cameraComponent.viewProjectionMatrix)):(t.setParameter("zNearInner",s.zNearInner),t.setParameter("zFarInner",s.zFarInner),t.setParameter("lightViewProjectionMatrix",this.__encodedDepthRenderPass.cameraComponent.viewProjectionMatrix));let l=i.entity.tryToGetSkeletal();this.setSkinning(o,i.setUniform,l),this.setLightsInfo(o,i.lightComponents,t,i.setUniform);let c=i.entity.tryToGetBlendShape();this.setMorphInfo(o,i.entity.getMesh(),i.primitive,c)}};h(Hn,"ShadowMapDecodeClassicMaterialContent"),f(Hn,"ShadowColorFactor",new B({str:"shadowColorFactor"})),f(Hn,"ShadowAlpha",new B({str:"shadowAlpha"})),f(Hn,"NonShadowAlpha",new B({str:"nonShadowAlpha"})),f(Hn,"AllowableDepthError",new B({str:"allowableDepthError"})),f(Hn,"zNearInner",new B({str:"zNearInner"})),f(Hn,"zFarInner",new B({str:"zFarInner"})),f(Hn,"DebugColorFactor",new B({str:"debugColorFactor"})),f(Hn,"DepthTexture",new B({str:"depthTexture"})),f(Hn,"IsPointLight",new B({str:"isPointLight"})),f(Hn,"__lastZNear",0),f(Hn,"__lastZFar",0);Rc=Hn});var k2,U2=C(()=>{k2={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec3 a_position;
in vec3 a_color;
in vec3 a_normal;
in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec4 a_joint;
in vec4 a_weight;
out vec3 v_color;
out vec3 v_normal_inWorld;
out vec4 v_position_inWorld;
out vec2 v_texcoord_0;
out float v_instanceInfo;

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

mat3 toNormalMatrix(mat4 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];

  float b00 = a00 * a11 - a01 * a10,
  b01 = a00 * a12 - a02 * a10,
  b02 = a00 * a13 - a03 * a10,
  b03 = a01 * a12 - a02 * a11,
  b04 = a01 * a13 - a03 * a11,
  b05 = a02 * a13 - a03 * a12,
  b06 = a20 * a31 - a21 * a30,
  b07 = a20 * a32 - a22 * a30,
  b08 = a20 * a33 - a23 * a30,
  b09 = a21 * a32 - a22 * a31,
  b10 = a21 * a33 - a23 * a31,
  b11 = a22 * a33 - a23 * a32;

  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3(
    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,
    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,
    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;
}



#ifdef RN_IS_SKINNING

highp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {
  highp vec4 q = quaternion;
  highp vec3 t = translation;

  highp float sx = q.x * q.x;
  highp float sy = q.y * q.y;
  highp float sz = q.z * q.z;
  highp float cx = q.y * q.z;
  highp float cy = q.x * q.z;
  highp float cz = q.x * q.y;
  highp float wx = q.w * q.x;
  highp float wy = q.w * q.y;
  highp float wz = q.w * q.z;

  highp mat4 mat = mat4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  highp mat4 uniformScaleMat = mat4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return mat*uniformScaleMat;
}

highp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){

  highp float r;
  highp float g;
  highp float b;
  highp float a;

  highp float ix = floor(vec_xy.x * criteria);
  highp float v1x = ix / criteria;
  highp float v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  highp float iy = floor( vec_xy.y * criteria);
  highp float v2x = iy / criteria;
  highp float v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4(r, g, b, a);
}

mat4 getSkinMatrix(float skeletalComponentSID) {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));
  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));
  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));
  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  vec2 criteria = vec2(4096.0, 4096.0);

  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));
  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));
  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));
  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));
  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));
  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));
  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));

  vec2 criteria = vec2(4096.0, 4096.0);
  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif



#ifdef RN_IS_SKINNING
bool skinning(
  float skeletalComponentSID,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
  )
{
  mat4 skinMat = getSkinMatrix(skeletalComponentSID);
  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);
  outNormalMatrix = toNormalMatrix(skinMat);
  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);

  return true;
}
#endif

bool processGeometryWithMorphingAndSkinning(
  float skeletalComponentSID,
  in mat4 worldMatrix,
  in mat4 viewMatrix,
  in bool isBillboard,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
) {
  bool isSkinning = false;

  vec3 position_inLocal;
#ifdef RN_IS_MORPHING
  if (u_morphTargetNumber == 0) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    float vertexIdx = a_baryCentricCoord.w;
    position_inLocal = get_position(vertexIdx, inPosition_inLocal);
  }
#endif

  mat4 worldMatrixInner = worldMatrix;
  if (isBillboard) {
    mat4 inverseViewMatrix = inverse(viewMatrix);
    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];
    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];
    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];
    worldMatrixInner = inverseViewMatrix * worldMatrix;
  }

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0.0) {
    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);
  } else {
#endif
    outNormalMatrix = inNormalMatrix;
    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
#ifdef RN_IS_SKINNING
  }
#endif

  return isSkinning;
}



void main()
{
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);

  // Skeletal
  processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    worldMatrix,
    viewMatrix,
    false,
    normalMatrix,
    normalMatrix,
    a_position,
    v_position_inWorld,
    a_normal,
    v_normal_inWorld
  );

  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;

// #ifdef RN_IS_POINTSPRITE

vec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);
vec3 viewPosition = get_viewPosition(cameraSID, 0);
float distanceFromCamera = length(position_inWorld.xyz - viewPosition);
vec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);
float distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));
float maxPointSize = get_pointSize(materialSID, 0);
gl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);

// #endif


  v_instanceInfo = a_instanceInfo.x;
}
`,shaderStage:"vertex",isFragmentShader:!1}});var Q2,W2=C(()=>{Q2={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec3 v_normal_inWorld;
in vec4 v_position_inWorld;
in float v_instanceInfo;


/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

const vec4 bitEnc = vec4(1.,255.,65025.,16581375.);
const vec4 bitDec = 1./bitEnc;

vec4 encodeFloatRGBA(float v) {
  float val = v;
  float r = mod(val, 255.0);
  val -= r;
  float g = mod(val, 65025.0);
  val -= g;
  float b = mod(val, 16581375.0);
  return vec4(r/255.0, g/65025.0, b/16581375.0, 1.0);
}


void main ()
{
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  rt0 = encodeFloatRGBA(v_instanceInfo);

/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var Kh,Nc,Zh=C(()=>{"use strict";Go();se();xe();ye();Zt();Tn();St();$t();U2();W2();Kh=class Kh extends He{constructor(n){super(n,{isMorphing:!1,isSkinning:!0,isLighting:!1},k2,Q2);let t=[{semantic:"pointSize",componentType:I.Float,compositionType:b.Scalar,stage:D.VertexShader,soloDatum:!0,initialValue:te.fromCopyNumber(30),min:0,max:100},{semantic:"pointDistanceAttenuation",componentType:I.Float,compositionType:b.Vec3,stage:D.VertexShader,soloDatum:!0,initialValue:S.fromCopyArray([0,.1,.01]),min:0,max:1}];this.setShaderSemanticsInfoArray(t)}_setInternalSettingParametersToGpuWebGL({material:n,shaderProgram:t,firstTime:o,args:r}){if(r.setUniform){this.setWorldMatrix(t,r.worldMatrix),this.setNormalMatrix(t,r.normalMatrix);let i=r.renderPass.cameraComponent;i==null&&(i=J.getComponent(re,re.current)),this.setViewInfo(t,i,r.isVr,r.displayIdx),this.setProjection(t,i,r.isVr,r.displayIdx);let a=r.entity.tryToGetSkeletal();this.setSkinning(t,r.setUniform,a),this.setLightsInfo(t,r.lightComponents,n,r.setUniform)}}};h(Kh,"EntityUIDOutputMaterialContent");Nc=Kh});var H2,X2=C(()=>{H2={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

// This shader is based on https://github.com/Santarh/MToon

in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec3 a_position;
in vec3 a_normal;
in vec4 a_baryCentricCoord;
in vec4 a_joint;
in vec4 a_weight;

out vec2 v_texcoord_0;
out vec3 v_baryCentricCoord;
out vec3 v_normal_inView;
out vec3 v_normal_inWorld;
out vec4 v_position_inWorld;
out float v_instanceInfo;

#ifdef RN_USE_TANGENT
in vec4 a_tangent;
out vec3 v_tangent_inWorld;
out vec3 v_binormal_inWorld; // bitangent_inWorld
#endif


precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

mat3 toNormalMatrix(mat4 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];

  float b00 = a00 * a11 - a01 * a10,
  b01 = a00 * a12 - a02 * a10,
  b02 = a00 * a13 - a03 * a10,
  b03 = a01 * a12 - a02 * a11,
  b04 = a01 * a13 - a03 * a11,
  b05 = a02 * a13 - a03 * a12,
  b06 = a20 * a31 - a21 * a30,
  b07 = a20 * a32 - a22 * a30,
  b08 = a20 * a33 - a23 * a30,
  b09 = a21 * a32 - a22 * a31,
  b10 = a21 * a33 - a23 * a31,
  b11 = a22 * a33 - a23 * a32;

  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3(
    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,
    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,
    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;
}



#ifdef RN_IS_SKINNING

highp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {
  highp vec4 q = quaternion;
  highp vec3 t = translation;

  highp float sx = q.x * q.x;
  highp float sy = q.y * q.y;
  highp float sz = q.z * q.z;
  highp float cx = q.y * q.z;
  highp float cy = q.x * q.z;
  highp float cz = q.x * q.y;
  highp float wx = q.w * q.x;
  highp float wy = q.w * q.y;
  highp float wz = q.w * q.z;

  highp mat4 mat = mat4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  highp mat4 uniformScaleMat = mat4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return mat*uniformScaleMat;
}

highp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){

  highp float r;
  highp float g;
  highp float b;
  highp float a;

  highp float ix = floor(vec_xy.x * criteria);
  highp float v1x = ix / criteria;
  highp float v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  highp float iy = floor( vec_xy.y * criteria);
  highp float v2x = iy / criteria;
  highp float v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4(r, g, b, a);
}

mat4 getSkinMatrix(float skeletalComponentSID) {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));
  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));
  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));
  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  vec2 criteria = vec2(4096.0, 4096.0);

  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));
  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));
  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));
  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));
  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));
  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));
  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));

  vec2 criteria = vec2(4096.0, 4096.0);
  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif



#ifdef RN_IS_SKINNING
bool skinning(
  float skeletalComponentSID,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
  )
{
  mat4 skinMat = getSkinMatrix(skeletalComponentSID);
  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);
  outNormalMatrix = toNormalMatrix(skinMat);
  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);

  return true;
}
#endif

bool processGeometryWithMorphingAndSkinning(
  float skeletalComponentSID,
  in mat4 worldMatrix,
  in mat4 viewMatrix,
  in bool isBillboard,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
) {
  bool isSkinning = false;

  vec3 position_inLocal;
#ifdef RN_IS_MORPHING
  if (u_morphTargetNumber == 0) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    float vertexIdx = a_baryCentricCoord.w;
    position_inLocal = get_position(vertexIdx, inPosition_inLocal);
  }
#endif

  mat4 worldMatrixInner = worldMatrix;
  if (isBillboard) {
    mat4 inverseViewMatrix = inverse(viewMatrix);
    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];
    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];
    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];
    worldMatrixInner = inverseViewMatrix * worldMatrix;
  }

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0.0) {
    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);
  } else {
#endif
    outNormalMatrix = inNormalMatrix;
    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
#ifdef RN_IS_SKINNING
  }
#endif

  return isSkinning;
}


void main(){
  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_NONE
      return;
    #endif
  #endif

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);
  bool isSkinning = false;
  isSkinning = processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    worldMatrix,
    viewMatrix,
    false,
    normalMatrix,
    normalMatrix,
    a_position,
    v_position_inWorld,
    a_normal,
    v_normal_inWorld
  );

  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);

  v_normal_inView = vec3(viewMatrix * vec4(v_normal_inWorld, 0.0));

  #ifdef RN_MTOON_IS_OUTLINE
    #if defined(RN_MTOON_HAS_OUTLINE_WIDTH_TEXTURE)
      float outlineTex = texture(u_outlineWidthTexture, a_texcoord_0).r;
    #else
      float outlineTex = 1.0;
    #endif

    #if defined(RN_MTOON_OUTLINE_WIDTH_WORLD)
      float outlineWidth = get_outlineWidth(materialSID, 0);
      vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * a_normal;
      vec4 worldOutlineOffset = worldMatrix * vec4(outlineOffset, 0.0);
      gl_Position = projectionMatrix * viewMatrix * (v_position_inWorld + worldOutlineOffset);

    #elif defined(RN_MTOON_OUTLINE_WIDTH_SCREEN)
      vec4 vertex = projectionMatrix * viewMatrix * v_position_inWorld;

      vec3 clipNormal = (projectionMatrix * vec4(v_normal_inView, 1.0)).xyz;
      vec2 projectedNormal = normalize(clipNormal.xy);
      float outlineScaledMaxDistance = get_outlineScaledMaxDistance(materialSID, 0);
      projectedNormal *= min(vertex.w, outlineScaledMaxDistance);
      float aspect = abs(get_aspect(0.0, 0)); //solo datum
      projectedNormal.x *= aspect;

      float outlineWidth = get_outlineWidth(materialSID, 0);
      vertex.xy += 0.01 * outlineWidth * outlineTex * projectedNormal * clamp(1.0 - abs(v_normal_inView.z), 0.0, 1.0); // ignore offset when normal toward camera

      gl_Position = vertex;
    #else
      gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;
    #endif
  #else
    gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;
  #endif

  #ifdef RN_USE_TANGENT
    v_tangent_inWorld = normalMatrix * a_tangent.xyz;
    v_binormal_inWorld = cross(v_normal_inWorld, v_tangent_inWorld) * a_tangent.w;
  #endif

  v_texcoord_0 = a_texcoord_0;
  v_baryCentricCoord = a_baryCentricCoord.xyz;
  v_instanceInfo = a_instanceInfo.x;
}
`,shaderStage:"vertex",isFragmentShader:!1}});var j2,q2=C(()=>{j2={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


const float EPS_COL = 0.00001;

in vec2 v_texcoord_0;
in vec3 v_baryCentricCoord;
in vec3 v_normal_inView;
in vec3 v_normal_inWorld;
in vec4 v_position_inWorld;
in float v_instanceInfo;
#ifdef RN_USE_TANGENT
  in vec3 v_tangent_inWorld;
  in vec3 v_binormal_inWorld; // bitangent_inWorld
#endif

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

struct Light {
  int type; // 0 = directional, 1 = point, 2 = spot
  vec3 position;
  vec3 intensity;
  vec3 attenuatedIntensity;
  vec3 directionOfLightObject;
  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)
  vec3 pointToLight; // not normalized
  float innerConeCos;
  float outerConeCos;
  float effectiveRange;
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
float getRangeAttenuation(Light light)
{
  float distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
float getSpotAttenuation(Light light)
{
  float actualCos = dot(light.direction, -light.directionOfLightObject);
  if (actualCos > light.outerConeCos) {
    if (actualCos < light.innerConeCos) {
      float attenuation = (actualCos - light.outerConeCos) / (light.innerConeCos - light.outerConeCos);
      return attenuation * attenuation;
    }
    return 1.0;
  }
  return 0.0;
}

vec3 getLightAttenuated(Light light) {
  light.attenuatedIntensity = light.intensity;
  // if (light.type == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light && Spot Light
  if (light.type != 0)
  {
    light.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot Light
  if (light.type == 2)
  {
    light.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return light.attenuatedIntensity;
}

Light getLight(int lightIdx, vec3 v_position_inWorld) {
  vec3 lightPosition = get_lightPosition(0.0, lightIdx);
  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);
  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);
  vec4 lightProperty = get_lightProperty(0.0, lightIdx);
  Light light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  float lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.innerConeCos = lightProperty.z;
  light.outerConeCos = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3(0.0);
    light.type = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.type = 1;
  } else { // is Directional Light
    light.type = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.type = 2;
  }

  const float M_PI = 3.141592653589793;
  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  light.attenuatedIntensity = getLightAttenuated(light);

  return light;
}


// https://github.com/KhronosGroup/glTF-Sample-Renderer
// Modified by Yuki Shimada

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

float angular_n_h(float NH) {
  return acos(NH);
}

float d_phong(float NH, float c1) {
  return pow(
    cos(acos(NH))
    , c1
  );
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec2 envBRDFApprox( float Roughness, float NoV ) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022 );
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );
  vec4 r = Roughness * c0 + c1;
  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}

// GGX NDF
float d_GGX(float NH, float alphaRoughness) {
  float roughnessSqr = alphaRoughness * alphaRoughness;
  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

float d_torrance_reiz(float NH, float c3) {
  float CosSquared = NH*NH;
  float TanSquared = (1.0 - CosSquared)/CosSquared;
  //return (1.0/M_PI) * sq(c3/(CosSquared * (c3*c3 + TanSquared)));  // gamma = 2, aka GGX
  return (1.0/sqrt(M_PI)) * (sq(c3)/(CosSquared * (c3*c3 + TanSquared))); // gamma = 1, D_Berry
}

float d_beckmann(float NH, float m) {
  float co = 1.0 / (4.0 * m * m * NH * NH * NH * NH);
  float expx = exp((NH * NH - 1.0) / (m * m * NH * NH));
  return co * expx;
}

// the same as glTF WebGL sample
// https://github.com/KhronosGroup/glTF-WebGL-PBR/blob/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders/pbr-frag.glsl#L188
// That is, Unreal Engine based approach, but modified to use alphaRoughness (squared artist's roughness parameter),
// and based on 'Separable Masking and Shadowing' approximation (propesed by Christophe Schlick)
// https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf
float g_shielding(float NL, float NV, float alphaRoughness) {
  float r = alphaRoughness;

  // Local Shadowing using "Schlick-Smith" Masking Function
  float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));

  // Local Masking using "Schlick-Smith" Masking Function
  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));

  return localShadowing * localMasking;
}

// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
float v_GGXCorrelated(float NL, float NV, float alphaRoughness) {
  float a2 = alphaRoughness * alphaRoughness;
  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  float GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  float GGX = GGXV + GGXL;
  if (GGX > 0.0) {
    return clamp(0.5 / GGX, 0.0, 1.0);
  }
  return 1.0;
}

float v_GGXCorrelatedFast(float NL, float NV, float alphaRoughness) {
  float a = alphaRoughness;
  float GGXV = NL * (NV * (1.0 - a) + a);
  float GGXL = NV * (NL * (1.0 - a) + a);
  float GGX = GGXV + GGXL;
  if (GGX > 0.0) {
    return 0.5 / GGX;
  }
  return 0.0;
}

// The Schlick Approximation to Fresnel
float fresnelSchlick(float f0, float f90, float VdotH) {
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

vec3 fresnelSchlick(vec3 f0, vec3 f90, float VdotH) {
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

vec3 fresnelSchlick(vec3 f0, float f90, float VdotH)
{
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

float fresnelSchlick(float f0, float VdotH)
{
  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelSchlick(f0, f90, VdotH);
}
vec3 fresnelSchlick(vec3 f0, float VdotH)
{
  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelSchlick(f0, f90, VdotH);
}

vec3 BRDF_specularGGX(float NH, float NL, float NV, float alphaRoughness) {
  float D = d_GGX(NH, alphaRoughness);
  float V = v_GGXCorrelated(NL, NV, alphaRoughness);
  return vec3(D) * vec3(V);
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf
vec3 BRDF_lambertian(vec3 diffuseAlbedo)
{
  // (1/pi) * diffuseAlbedo
  return diffuseAlbedo * RECIPROCAL_PI;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#specular-brdf
float specular_brdf(float alphaRoughness, float NdotL, float NdotV, float NdotH) {
  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  float D = d_GGX(NdotH, alphaRoughness);
  return V * D;
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes
float specular_btdf(float alphaRoughness, float NdotL, float NdotV, float NdotHt) {
  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  float D = d_GGX(NdotHt, alphaRoughness);
  return V * D;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel
vec3 conductor_fresnel(vec3 f0, float brdf, float alphaRoughness, float VdotH) {
  return vec3(brdf) * (f0.rgb + (vec3(1.0) - f0.rgb) * vec3(pow(1.0 - abs(VdotH), 5.0)));
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel
vec3 fresnel_mix(float ior, vec3 base, vec3 layer, float VdotH) {
  float f0 = pow((1.0 - ior)/(1.0 + ior), 2.0);
  float fr = f0 + (1.0 - f0) * pow(1.0 - abs(VdotH), 5.0);
  return mix(base, layer, fr);
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf
vec3 metal_brdf(float perceptualRoughness, vec3 baseColor, float NdotL, float NdotV, float NdotH, float VdotH) {
  float alphaRoughness = perceptualRoughness * perceptualRoughness;
  return conductor_fresnel(
    baseColor,
    specular_brdf(alphaRoughness, NdotL, NdotV, NdotH),
    alphaRoughness,
    VdotH
  );
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf
// vec3 dielectric_brdf(float ior, vec3 baseColor, float perceptualRoughness, float NdotL, float NdotV, float NdotH, float VdotH) {
//   vec3 base = BRDF_lambertian(baseColor);
//   float alphaRoughness = perceptualRoughness * perceptualRoughness;
//   vec3 layer = vec3(specular_brdf(alphaRoughness, NdotL, NdotV, NdotH));
//   return fresnel_mix(ior, base, layer, VdotH);
// }

vec3 srgbToLinear(vec3 srgbColor) {
  return pow(srgbColor, vec3(2.2));
}

float srgbToLinear(float value) {
  return pow(value, 2.2);
}

vec3 linearToSrgb(vec3 linearColor) {
  return pow(linearColor, vec3(1.0/2.2));
}

float linearToSrgb(float value) {
  return pow(value, 1.0/2.2);
}

// Roughness Dependent Fresnel
// https://www.jcgt.org/published/0008/01/03/paper.pdf
vec3 fresnelSchlickRoughness(vec3 F0, float cosTheta, float roughness)
{
  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;
  vec3 k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);
  return k_S;
}

// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66
vec3 Schlick_to_F0(vec3 f, vec3 f90, float VdotH) {
    float x = clamp(1.0 - VdotH, 0.0, 1.0);
    float x2 = x * x;
    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

float Schlick_to_F0(float f, float f90, float VdotH) {
    float x = clamp(1.0 - VdotH, 0.0, 1.0);
    float x2 = x * x;
    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

vec3 Schlick_to_F0(vec3 f, float VdotH) {
    return Schlick_to_F0(f, vec3(1.0), VdotH);
}

float Schlick_to_F0(float f, float VdotH) {
    return Schlick_to_F0(f, 1.0, VdotH);
}

vec3 normalBlendingUDN(sampler2D baseMap, sampler2D detailMap, vec2 baseUv, vec2 detailUv) {
  vec3 t = texture(baseMap,   baseUv).xyz * 2.0 - 1.0;
  vec3 u = texture(detailMap, detailUv).xyz * 2.0 - 1.0;
  vec3 r = normalize(vec3(t.xy + u.xy, t.z));
  return r;
}

vec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {
  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  mat3 rotationMat = mat3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  mat3 matrix = translationMat * rotationMat * scaleMat;
  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;

  return uvTransformed;
}

float IsotropicNDFFiltering(vec3 normal, float roughness2) {
  float SIGMA2 = 0.15915494;
  float KAPPA = 0.18;
  vec3 dndu = dFdx(normal);
  vec3 dndv = dFdy(normal);
  float kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));
  float clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);
  float filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);
  return filteredRoughness2;
}

////////////////////////////////////////
// glTF KHR_materials_transmission
////////////////////////////////////////

#ifdef RN_USE_TRANSMISSION
// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
vec3 volumeAttenuation(vec3 attenuationColor, float attenuationDistance, vec3 intensity, float transmissionDistance)
{
  if (attenuationDistance == 0.0) { // means Infinite distance
    return intensity; // No attenuation
  } else {
    // vec3 attenuationCo = -log(attenuationColor) / attenuationDistance;
    // vec3 attenuatedTransmittance = exp(-attenuationCo * transmissionDistance);
    vec3 attenuatedTransmittance = pow(attenuationColor, vec3(transmissionDistance / attenuationDistance));
    return intensity * attenuatedTransmittance;
  }
}

// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer
vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior)
{
  vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);
  mat4 worldMatrix = get_worldMatrix(v_instanceInfo);

  vec3 modelScale;
  modelScale.x = length(vec3(worldMatrix[0].xyz));
  modelScale.y = length(vec3(worldMatrix[1].xyz));
  modelScale.z = length(vec3(worldMatrix[2].xyz));

  return normalize(refractionVector) * thickness * modelScale;
}

float applyIorToRoughness(float roughness, float ior)
{
  return clamp(roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0), c_MinRoughness, 1.0);
}

vec3 calculateRadianceTransmission(vec3 normal, vec3 view, vec3 pointToLight, float alphaRoughness, vec3 baseColor, float ior)
{
  float transmissionRoughness = applyIorToRoughness(alphaRoughness, ior);

  vec3 n = normalize(normal);
  vec3 v = normalize(view);
  vec3 l = normalize(pointToLight);
  vec3 mirrorL = normalize(l + 2.0 * n * dot(-l, n));
  vec3 h = normalize(mirrorL + v);

  float D = d_GGX(clamp(dot(n, h), 0.0, 1.0), transmissionRoughness);
  float V = v_GGXCorrelated(clamp(dot(n, mirrorL), 0.0, 1.0), clamp(dot(n, v), 0.0, 1.0), transmissionRoughness);

  return baseColor * D * V;
}

#endif


////////////////////////////////////////
// glTF KHR_materials_anisotropy
////////////////////////////////////////
#ifdef RN_USE_ANISOTROPY
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
float D_GGX_anisotropic(float NdotH, float TdotH, float BdotH, float at, float ab)
{
    float a2 = at * ab;
    vec3 f = vec3(ab * TdotH, at * BdotH, a2 * NdotH);
    float w2 = a2 / dot(f, f);
    return a2 * w2 * w2 / M_PI;
}

float V_GGX_anisotropic(float NdotL, float NdotV, float BdotV, float TdotV, float TdotL, float BdotL,
    float at, float ab)
{
    float GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));
    float GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));
    float GGX = GGXV + GGXL;
    if (GGX > 0.0) {
      return clamp(0.5 / GGX, 0.0, 1.0);
    }
    return 1.0;
}

vec3 BRDF_specularAnisotropicGGX(float alphaRoughness,
    float VdotH, float NdotL, float NdotV, float NdotH, float BdotV, float TdotV,
    float TdotL, float BdotL, float TdotH, float BdotH, float anisotropy)
{
    float at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
    float ab = clamp(alphaRoughness, 0.001, 1.0);

    float V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);
    float D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);

    return vec3(V * D);
}
#endif



////////////////////////////////////////
// glTF KHR_materials_sheen
////////////////////////////////////////

#ifdef RN_USE_SHEEN
float d_Charlie(float sheenPerceptualRoughness, float NoH) {
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  float sheenRoughness = max(sheenPerceptualRoughness, 0.000001);
  float alphaG = sheenRoughness * sheenRoughness;
  float invAlpha  = 1.0 / alphaG;
  float cos2h = NoH * NoH;
  float sin2h = 1.0 - cos2h;
  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
float sheenSimpleVisibility(float NdotL, float NdotV) {
  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
float charlieL(float x, float alphaG) {
  float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
  float a = mix(21.5473, 25.3245, oneMinusAlphaSq);
  float b = mix(3.82987, 3.32435, oneMinusAlphaSq);
  float c = mix(0.19823, 0.16801, oneMinusAlphaSq);
  float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
  float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
  return a / (1.0 + b * pow(x, c)) + d * x + e;
}

float lambdaSheen(float cosTheta, float alphaG)
{
  return abs(cosTheta) < 0.5 ? exp(charlieL(cosTheta, alphaG)) : exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG));
}

float sheenCharlieVisibility(float NdotL, float NdotV, float sheenPerceptualRoughness) {
  float sheenRoughness = max(sheenPerceptualRoughness, 0.000001);
  float alphaG = sheenRoughness * sheenRoughness;
  float sheenVisibility = clamp(1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL)), 0.0, 1.0);
  return sheenVisibility;
}

vec3 BRDF_specularSheen(vec3 sheenColor, float sheenPerceptualRoughness, float NdotL, float NdotV, float NdotH) {
  float sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);
  float sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);
  return sheenColor * sheenDistribution * sheenVisibility;
}
#endif









////////////////////////////////////////
// glTF KHR_materials_irirdescence
////////////////////////////////////////

#ifdef RN_USE_IRIDESCENCE
// XYZ to REC709(sRGB) conversion matrix
const mat3 XYZ_TO_REC709 = mat3(
     3.2404542, -0.9692660,  0.0556434,
    -1.5371385,  1.8760108, -0.2040259,
    -0.4985314,  0.0415560,  1.0572252
);

vec3 fresnelSchlickRoughnessWithIridescence(
  vec3 F0, float cosTheta, float roughness,
  vec3 iridescenceFresnel, float iridescence
  )
{
  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;
  vec3 k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);
  return k_S;
}

// Assume air interface for top
vec3 Fresnel0ToIor(vec3 F0) {
    vec3 sqrtF0 = sqrt(F0);
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// Conversion from IOR to F0
// ior is a value between 1.0 and 3.0. 1.0 is air interface
vec3 IorToFresnel0(vec3 transmittedIor, float incidentIor) {
    return sq((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
float IorToFresnel0(float transmittedIor, float incidentIor) {
    return sq((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration
 */
vec3 evalSensitivity(float OPD, vec3 shift) {
    float phase = 2.0 * M_PI * OPD * 1.0e-9;
    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);

    vec3 xyz = val * sqrt(2.0 * M_PI * var) * cos(pos * phase + shift) * exp(-(phase * phase) * var);
    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));
    xyz /= 1.0685e-7;

    vec3 rgb = XYZ_TO_REC709 * xyz;
    return rgb;
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel
 */
vec3 calcIridescence(float outsideIor, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {


  // iridescenceIor is the index of refraction of the thin-film layer
  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
  float iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));

  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)
  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.
  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.
  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):
  float sinTheta2Sq = sq(outsideIor / iridescenceIor) * (1.0 - sq(cosTheta1));
  float cosTheta2Sq = 1.0 - sinTheta2Sq;

  // Handle total internal reflection
  if (cosTheta2Sq < 0.0) {
      return vec3(1.0);
  }

  float cosTheta2 = sqrt(cosTheta2Sq);

  /// Material Interfaces
  // The iridescence model defined by Belcour/Barla models two material interfaces
  // - one from the outside to the thin-film layer
  // and another one from the thin-film to the base material. These two interfaces are defined as follows:

  // First interface (from the outside to the thin-film layer)
  float R0 = IorToFresnel0(iridescenceIor, outsideIor);
  float R12 = fresnelSchlick(R0, cosTheta1);
  float R21 = R12;
  float T121 = 1.0 - R12;

  // Second interface (from the thin-film to the base material)
  vec3 baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0
  vec3 R1 = IorToFresnel0(baseIor, iridescenceIor);
  vec3 R23 = fresnelSchlick(R1, cosTheta2);

  // phi12 and phi23 define the base phases per interface and are approximated with 0.0
  // if the IOR of the hit material (iridescenceIor or baseIor) is higher
  // than the IOR of the previous material (outsideIor or iridescenceIor) and \u03C0 otherwise.
  // Also here, polarization is ignored.  float phi12 = 0.0;

  // First interface (from the outside to the thin-film layer)
  float phi12 = 0.0;
  if (iridescenceIor < outsideIor) phi12 = M_PI;
  float phi21 = M_PI - phi12;

  // Second interface (from the thin-film to the base material)
  vec3 phi23 = vec3(0.0);
  if (baseIor[0] < iridescenceIor) phi23[0] = M_PI;
  if (baseIor[1] < iridescenceIor) phi23[1] = M_PI;
  if (baseIor[2] < iridescenceIor) phi23[2] = M_PI;

  // OPD (optical path difference)
  float OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
  // Phase shift
  vec3 phi = vec3(phi21) + phi23;

  // Compound terms
  vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);
  vec3 r123 = sqrt(R123);
  vec3 Rs = (T121 * T121) * R23 / (vec3(1.0) - R123);

  // Reflectance term for m = 0 (DC term amplitude)
  vec3 C0 = R12 + Rs;
  vec3 I = C0;

  // Reflectance term for m > 0 (pairs of diracs)
  vec3 Cm = Rs - T121;
  for (int m = 1; m <= 2; ++m)
  {
      Cm *= r123;
      vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);
      I += Cm * Sm;
  }

  vec3 F_iridescence = max(I, vec3(0.0));

  return F_iridescence;
}

//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB
vec3 BRDF_lambertianIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float iridescenceFactor, vec3 diffuseColor, float specularWeight, float VdotH)
{
    vec3 iridescenceFresnelMax = vec3(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));
    vec3 schlickFresnel = Schlick_to_F0(f0, f90, VdotH);
    vec3 F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);

    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);
}

vec3 BRDF_specularGGXIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float alphaRoughness, float iridescenceFactor, float specularWeight, float VdotH, float NdotL, float NdotV, float NdotH)
{
    vec3 F = mix(Schlick_to_F0(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);
    float Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
    float D = d_GGX(NdotH, alphaRoughness);

    return specularWeight * F * Vis * D;
}

vec3 rgb_mix(vec3 base, vec3 specular_brdf, vec3 rgb_alpha)
{
    float rgb_alpha_max = max(rgb_alpha.r, max(rgb_alpha.g, rgb_alpha.b));
    return (1.0 - rgb_alpha_max) * base + rgb_alpha * specular_brdf;
}

#endif // RN_USE_IRIDESCENCE





////////////////////////////////////////
// lighting with a punctual light
////////////////////////////////////////
vec3 lightingWithPunctualLight(
  Light light,
  vec3 normal_inWorld,
  vec3 viewDirection,
  float NdotV,
  vec3 baseColor,
  float perceptualRoughness,
  float metallic,
  vec3 dielectricF0,
  vec3 dielectricF90,
  float ior,
  float transmission,
  float thickness,
  float clearcoat,
  float clearcoatRoughness,
  vec3 clearcoatF0,
  vec3 clearcoatF90,
  vec3 clearcoatFresnel,
  vec3 clearcoatNormal_inWorld,
  float VdotNc,
  vec3 attenuationColor,
  float attenuationDistance,
  float anisotropy,
  vec3 anisotropicT,
  vec3 anisotropicB,
  float BdotV,
  float TdotV,
  vec3 sheenColor,
  float sheenRoughness,
  float albedoSheenScalingNdotV,
  float iridescence,
  vec3 iridescenceFresnel_dielectric,
  vec3 iridescenceFresnel_metal,
  float specularWeight,
  float diffuseTransmission,
  vec3 diffuseTransmissionColor,
  float diffuseTransmissionThickness
  )
{
  float alphaRoughness = perceptualRoughness * perceptualRoughness;

  // Fresnel
  vec3 halfVector = normalize(light.direction + viewDirection);
  float VdotH = saturate(dot(viewDirection, halfVector));
  vec3 dielectricFresnel = fresnelSchlick(dielectricF0, dielectricF90, VdotH);
  vec3 metalFresnel = fresnelSchlick(baseColor, vec3(1.0), VdotH);

  float NdotL = saturateEpsilonToOne(dot(normal_inWorld, light.direction));

  // Diffuse
  vec3 diffuseBrdf = BRDF_lambertian(baseColor);
  vec3 diffuseContrib = diffuseBrdf * vec3(NdotL) * light.attenuatedIntensity;

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  diffuseContrib = diffuseContrib * (vec3(1.0) - diffuseTransmission);
  if (dot(normal_inWorld, light.direction) < 0.0) {
    float diffuseNdotL = saturate(dot(normal_inWorld, -light.direction));
    vec3 diffuseBtdf = BRDF_lambertian(diffuseTransmissionColor) * vec3(diffuseNdotL) * light.attenuatedIntensity;
    vec3 mirrorL = normalize(light.direction + 2.0 * normal_inWorld * dot(normal_inWorld, -light.direction));
    float diffuseVdotH = saturate(dot(viewDirection, normalize(mirrorL + viewDirection)));
    dielectricFresnel = fresnelSchlick(dielectricF0 * specularWeight, dielectricF90, abs(diffuseVdotH));
#ifdef RN_USE_VOLUME
    diffuseBtdf = volumeAttenuation(attenuationColor, attenuationDistance, diffuseBtdf, diffuseTransmissionThickness);
#endif // RN_USE_VOLUME
    diffuseContrib += diffuseBtdf * diffuseTransmission;
  }
#endif // RN_USE_DIFFUSE_TRANSMISSION


#ifdef RN_USE_TRANSMISSION
  vec3 transmittionRay = getVolumeTransmissionRay(normal_inWorld, viewDirection, thickness, ior);
  light.pointToLight -= transmittionRay;
  light.direction = normalize(light.pointToLight);
  vec3 transmittedContrib = calculateRadianceTransmission(normal_inWorld, viewDirection, light.direction, alphaRoughness, baseColor, ior) * light.attenuatedIntensity;

#ifdef RN_USE_VOLUME
  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittionRay));
#endif // RN_USE_VOLUME

  diffuseContrib = mix(diffuseContrib, vec3(transmittedContrib), transmission);
#endif // RN_USE_TRANSMISSION

  light.attenuatedIntensity = getLightAttenuated(light);
  // Specular
  float NdotH = saturate(dot(normal_inWorld, halfVector));

#ifdef RN_USE_ANISOTROPY
  float TdotL = dot(anisotropicT, light.direction);
  float BdotL = dot(anisotropicB, light.direction);
  float TdotH = dot(anisotropicT, halfVector);
  float BdotH = dot(anisotropicB, halfVector);
  vec3 specularMetalContrib = BRDF_specularAnisotropicGGX(alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3(NdotL) * light.attenuatedIntensity;
  vec3 specularDielectricContrib = specularMetalContrib;
#else
  vec3 specularMetalContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, alphaRoughness) * vec3(NdotL) * light.attenuatedIntensity;
  vec3 specularDielectricContrib = specularMetalContrib;
#endif // RN_USE_ANISOTROPY

  // Base Layer
  vec3 metal = specularMetalContrib * metalFresnel;
  vec3 dielectric = mix(diffuseContrib, specularDielectricContrib, dielectricFresnel);

#ifdef RN_USE_IRIDESCENCE
  metal = mix(metal, specularMetalContrib * iridescenceFresnel_metal, iridescence);
  dielectric = mix(dielectric, rgb_mix(diffuseContrib, specularDielectricContrib, iridescenceFresnel_dielectric), iridescence);
#endif // RN_USE_IRIDESCENCE

#ifdef RN_USE_CLEARCOAT
  // Clear Coat Layer
  float NdotHc = saturate(dot(clearcoatNormal_inWorld, halfVector));
  float LdotNc = saturate(dot(light.direction, clearcoatNormal_inWorld));
  vec3 clearcoatContrib = BRDF_specularGGX(NdotHc, LdotNc, VdotNc, clearcoatRoughness * clearcoatRoughness) * vec3(LdotNc) * light.attenuatedIntensity;
#else
  vec3 clearcoatContrib = vec3(0.0);
#endif // RN_USE_CLEARCOAT

#ifdef RN_USE_SHEEN
  // Sheen
  vec3 sheenContrib = BRDF_specularSheen(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;
  float albedoSheenScaling = min(
    albedoSheenScalingNdotV,
    1.0 - max3(sheenColor) * texture(u_sheenLutTexture, vec2(NdotL, sheenRoughness)).r);
#else
  vec3 sheenContrib = vec3(0.0);
  float albedoSheenScaling = 1.0;
#endif // RN_USE_SHEEN

  vec3 color = mix(dielectric, metal, metallic);
  color = sheenContrib + color * albedoSheenScaling;
  color = mix(color, clearcoatContrib, clearcoat * clearcoatFresnel);

  return color;
}


/* shaderity: @{matricesGetters} */

// This file includes portions of code from the glTF-Sample-Renderer project by Khronos Group (Apache License 2.0).
// https://github.com/KhronosGroup/glTF-Sample-Renderer
// Modified by Yuki Shimada


vec3 getIBLIrradiance(vec3 normal_forEnv, vec4 iblParameter, ivec2 hdriFormat) {
  vec4 diffuseTexel = texture(u_diffuseEnvTexture, normal_forEnv);

  vec3 irradiance;
  if (hdriFormat.x == 0) {
    // LDR_SRGB
    irradiance = srgbToLinear(diffuseTexel.rgb);
  }
  else if (hdriFormat.x == 3) {
    // RGBE
    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  }
  else {
    irradiance = diffuseTexel.rgb;
  }

  // scale with user parameters
  float IBLDiffuseContribution = iblParameter.y;
  irradiance *= IBLDiffuseContribution;

  return irradiance;
}

float scaleForLod(float perceptualRoughness, float ior)
{
  // Scale roughness to the range [0, 1],
  // ior=1.0 will be scale 0,
  // ior=1.5 will be scale 1.0,
  // ior=2 will be scale 1.0 (clamped)
  //

  float scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);
  return perceptualRoughness * scale;
}

#ifdef RN_USE_TRANSMISSION
vec3 get_sample_from_backbuffer(vec2 sampleCoord, float perceptualRoughness, float ior) {
  ivec2 vrState = get_vrState(0.0, 0);
  vec2 backBufferTextureSize = vec2(textureSize(u_backBufferTexture, 0));
  float backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);

#ifdef WEBGL2_MULTI_VIEW
  // For VR
  backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
  sampleCoord.x = sampleCoord.x * 0.5;
  if (v_displayIdx == 1.0) { // For right eye
    sampleCoord.x += 0.5;
  }
#else
  if (vrState.x == 1) { // For VR
    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
    sampleCoord.x = sampleCoord.x * 0.5;
    if (vrState.y == 1) { // For right eye
      sampleCoord.x += 0.5;
    }
  }
#endif

  float framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);
  vec3 transmittedLight = textureLod(u_backBufferTexture, sampleCoord, framebufferLod).rgb;

  return transmittedLight;
}

vec3 getIBLVolumeRefraction(vec3 baseColor, vec3 normal, vec3 view, float cameraSID, float materialSID, float thickness, float perceptualRoughness, float ior, vec3 attenuationColor, float attenuationDistance) {
#ifdef RN_USE_DISPERSION
  float dispersion = get_dispersion(materialSID, 0);
  float halfSpread = (ior - 1.0) * 0.025 * dispersion;
  vec3 iors = vec3(ior - halfSpread, ior, ior + halfSpread);

  vec3 transmittedLight;
  float transmissionRayLength;
  for(int i=0;i<3;i++) {
    vec3 transmissionRay = getVolumeTransmissionRay(normal, view, thickness, iors[i]);
    transmissionRayLength = length(transmissionRay);
    vec3 refractedRayExit = v_position_inWorld.xyz + transmissionRay;

    vec4 ndcPos = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4(refractedRayExit, 1.0);
    vec2 refractionCoords = ndcPos.xy / ndcPos.w;
    refractionCoords += 1.0;
    refractionCoords /= 2.0;

    transmittedLight[i] = get_sample_from_backbuffer(refractionCoords, perceptualRoughness, iors[i])[i];
  }
#else
  vec3 transmissionRay = getVolumeTransmissionRay(normal, view, thickness, ior);
  float transmissionRayLength = length(transmissionRay);
  vec3 refractedRayExit = v_position_inWorld.xyz + transmissionRay;

  vec4 ndcPos = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4(refractedRayExit, 1.0);
  vec2 refractionCoords = ndcPos.xy / ndcPos.w;
  refractionCoords += 1.0;
  refractionCoords /= 2.0;

  vec3 transmittedLight = get_sample_from_backbuffer(refractionCoords, perceptualRoughness, ior);
#endif
  vec3 attenuatedColor = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, transmissionRayLength);
  return attenuatedColor * baseColor;
}

#endif // RN_USE_TRANSMISSION

vec3 get_radiance(vec3 reflection, float lod, ivec2 hdriFormat) {
  vec4 specularTexel = textureLod(u_specularEnvTexture, reflection, lod);

  vec3 radiance;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

struct IblResult
{
  vec3 specular;
  vec3 diffuse;
  vec3 FssEss;
};

vec3 getIBLRadianceGGX(float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, vec3 reflection)
{
  // get radiance
  float mipCount = iblParameter.x;
  float lod = (perceptualRoughness * (mipCount - 1.0));
  vec3 radiance = get_radiance(reflection, lod, hdriFormat);

  // scale with user parameters
  float IBLSpecularContribution = iblParameter.z;
  radiance *= IBLSpecularContribution;

  return radiance;
}

vec3 getIBLFresnelGGX(float perceptualRoughness, float NdotV, vec3 F0, float specularWeight) {
  // https://bruop.github.io/ibl/#single_scattering_results

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = vec3(specularWeight) * (kS * f_ab.x + f_ab.y);

  // Multiple scattering
  float Ems = (1.0 - (f_ab.x + f_ab.y));
  vec3 F_avg = vec3(specularWeight) * (F0 + (1.0 - F0) / 21.0);
  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);

  return FssEss + FmsEms;
}

#ifdef RN_USE_SHEEN

vec3 get_radiance_sheen(vec3 reflection, float lod, ivec2 hdriFormat) {
  vec4 specularTexel = textureLod(u_sheenEnvTexture, reflection, lod);

  vec3 radiance;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

vec3 sheenIBL(float NdotV, float sheenPerceptualRoughness, vec3 sheenColor, vec4 iblParameter, vec3 reflection, ivec2 hdriFormat)
{
  float mipCount = iblParameter.x;
  float lod = (sheenPerceptualRoughness * (mipCount - 1.0));

  vec2 sheenLutUV = vec2(NdotV, sheenPerceptualRoughness);
  float brdf = texture(u_sheenLutTexture, sheenLutUV).b;
  vec3 sheenLight = get_radiance_sheen(reflection, lod, hdriFormat);
  float IBLSpecularContribution = iblParameter.z;
  sheenLight *= IBLSpecularContribution;

  return sheenLight * sheenColor * brdf;
}
#endif

vec3 getNormalForEnv(mat3 rotEnvMatrix, vec3 normal_inWorld, float materialSID) {
  vec3 normal_forEnv = rotEnvMatrix * normal_inWorld;
  if (get_inverseEnvironment(materialSID, 0)) {
    normal_forEnv.x *= -1.0;
  }
  return normal_forEnv;
}

vec3 getReflection(mat3 rotEnvMatrix, vec3 viewDirection, vec3 normal_inWorld, float materialSID, float perceptualRoughness, float anisotropy, vec3 anisotropyDirection) {
#ifdef RN_USE_ANISOTROPY

  float tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);
  vec3  anisotropicTangent  = cross(anisotropyDirection, viewDirection);
  vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);
  float bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);
  float bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;
  vec3  bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));
  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);
#else
  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);
#endif
  if (get_inverseEnvironment(materialSID, 0)) {
    reflection.x *= -1.0;
  }
  return reflection;
}

vec3 IBLContribution(float materialSID, vec3 normal_inWorld, float NdotV, vec3 viewDirection,
  vec3 baseColor, float perceptualRoughness, float clearcoatRoughness, vec3 clearcoatNormal_inWorld,
  float clearcoat, vec3 clearcoatFresnel, float VdotNc, vec3 geomNormal_inWorld, float cameraSID, float transmission, vec3 v_position_inWorld,
  float thickness, vec3 sheenColor, float sheenRoughness, float albedoSheenScalingNdotV, float ior,
  vec3 iridescenceFresnel_dielectric, vec3 iridescenceFresnel_metal, float iridescence, float anisotropy, vec3 anisotropyDirection,
  float specularWeight, vec3 dielectricF0, float metallic, float diffuseTransmission, vec3 diffuseTransmissionColor, float diffuseTransmissionThickness)
{
  vec4 iblParameter = get_iblParameter(materialSID, 0);
  float rot = iblParameter.w;
  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);

  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  vec3 reflection = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);

  // get irradiance
  vec3 irradiance = getIBLIrradiance(normal_forEnv, iblParameter, hdriFormat);
  vec3 diffuse = irradiance * baseColor;

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  vec3 diffuseTransmissionIBL = getIBLIrradiance(-normal_forEnv, iblParameter, hdriFormat) * diffuseTransmissionColor;
#ifdef RN_USE_VOLUME
  diffuseTransmissionIBL = volumeAttenuation(attenuationColor, attenuationDistance, diffuseTransmissionIBL, diffuseTransmissionThickness);
#endif
  diffuse = mix(diffuse, diffuseTransmissionIBL, diffuseTransmission);
#endif

#ifdef RN_USE_TRANSMISSION
  vec3 attenuationColor = get_attenuationColor(materialSID, 0);
  float attenuationDistance = get_attenuationDistance(materialSID, 0);
  vec3 specularTransmission = getIBLVolumeRefraction(baseColor, normal_inWorld, viewDirection, cameraSID, materialSID, thickness, perceptualRoughness, ior, attenuationColor, attenuationDistance);
  diffuse = mix(diffuse, specularTransmission, transmission);
#endif

  // take account of anisotropy with reflection
  vec3 specularMetal = getIBLRadianceGGX(perceptualRoughness, iblParameter, hdriFormat, reflection);
  vec3 specularDielectric = specularMetal;

  // Calculate fresnel mix
  vec3 fresnelMetal = getIBLFresnelGGX(perceptualRoughness, NdotV, baseColor, 1.0);
  vec3 metalContrib = fresnelMetal * specularMetal;
  vec3 fresnelDielectric = getIBLFresnelGGX(perceptualRoughness, NdotV, dielectricF0, specularWeight);
  vec3 dielectricContrib = mix(diffuse, specularDielectric, fresnelDielectric);

#ifdef RN_USE_IRIDESCENCE
  metalContrib = mix(metalContrib, specularMetal * iridescenceFresnel_metal, iridescence);
  dielectricContrib = mix(dielectricContrib, rgb_mix(diffuse, specularDielectric, iridescenceFresnel_dielectric), iridescence);
#endif

#ifdef RN_USE_CLEARCOAT
  vec3 clearcoatReflection = getReflection(rotEnvMatrix, viewDirection, clearcoatNormal_inWorld, materialSID, clearcoatRoughness, 0.0, vec3(0.0));
  vec3 clearcoatContrib = getIBLRadianceGGX(clearcoatRoughness, iblParameter, hdriFormat, clearcoatReflection);
#else
  vec3 clearcoatContrib = vec3(0.0);
#endif

#ifdef RN_USE_SHEEN
  vec3 sheenContrib = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);
  float albedoSheenScaling = albedoSheenScalingNdotV;
#else
  vec3 sheenContrib = vec3(0.0);
  float albedoSheenScaling = 1.0;
#endif

  vec3 color = mix(dielectricContrib, metalContrib, metallic);
  color = sheenContrib + color * albedoSheenScaling;
  color = mix(color, clearcoatContrib, clearcoat * clearcoatFresnel);

  return color;
}


uniform bool u_inverseEnvironment; // initialValue=false
uniform vec4 u_iblParameter; // initialValue=(1,1,1,1), isInternalSetting=true
uniform ivec2 u_hdriFormat; // initialValue=(0,0), isInternalSetting=true

uniform samplerCube u_diffuseEnvTexture; // initialValue=(5,black), isInternalSetting=true
uniform samplerCube u_specularEnvTexture; // initialValue=(6,black), isInternalSetting=true


float edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {
  vec3 d = fwidth(bary3);
  vec3 x = bary3+vec3(1.0 - wireframeWidthInner)*d;
  vec3 a3 = smoothstep(vec3(0.0), d, x);
  float factor = min(min(a3.x, a3.y), a3.z);

  return clamp((1.0 - factor), 0.0, 1.0);
}

const float PI_2 = 6.28318530718;

vec2 uvAnimation(vec2 origUv, float time, float uvAnimationMask, float uvAnimationScrollXSpeedFactor, float uvAnimationScrollYSpeedFactor, float uvAnimationRotationSpeedFactor) {
  float uvAnim = uvAnimationMask * time;
  vec2 uv = origUv;
  uv += vec2(uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor) * uvAnim;
  float rotateRad = uvAnimationRotationSpeedFactor * PI_2 * uvAnim;
  const vec2 rotatePivot = vec2(0.5);
  uv = mat2(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (uv - rotatePivot) + rotatePivot;
  return uv;
}

#ifdef RN_USE_TANGENT
  mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {
    vec3 tangent_inWorld = normalize(v_tangent_inWorld);
    vec3 binormal_inWorld = normalize(v_binormal_inWorld);
    mat3 tbnMat_tangent_to_world = mat3(tangent_inWorld, binormal_inWorld, normal_inWorld);

    return tbnMat_tangent_to_world;
  }
#else
    // This is based on http://www.thetenthplanet.de/archives/1180
    mat3 cotangent_frame(vec3 normal_inWorld, vec3 position, vec2 uv) {
      uv = gl_FrontFacing ? uv : -uv;

      // get edge vectors of the pixel triangle
      vec3 dp1 = dFdx(position);
      vec3 dp2 = dFdy(position);
      vec2 duv1 = dFdx(uv);
      vec2 duv2 = dFdy(uv);

      // solve the linear system
      vec3 dp2perp = cross(dp2, normal_inWorld);
      vec3 dp1perp = cross(normal_inWorld, dp1);
      vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;
      vec3 bitangent = dp2perp * duv1.y + dp1perp * duv2.y;
      bitangent *= -1.0;

      // construct a scale-invariant frame
      float invMat = inversesqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));
      return mat3(tangent * invMat, bitangent * invMat, normal_inWorld);
    }

    mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {
      mat3 tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord);

      return tbnMat_tangent_to_world;
    }
#endif


void main (){
  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_NONE
      discard;
    #endif
  #endif

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  // uv animation
  float uvAnimationMaskTexture = texture(u_uvAnimationMaskTexture, v_texcoord_0).r;
  float uvAnimationScrollXSpeedFactor = get_uvAnimationScrollXSpeedFactor(materialSID, 0);
  float uvAnimationScrollYSpeedFactor = get_uvAnimationScrollYSpeedFactor(materialSID, 0);
  float uvAnimationRotationSpeedFactor = get_uvAnimationRotationSpeedFactor(materialSID, 0);
  float time = get_time(0.0, 0);
  vec2 mainUv = uvAnimation(v_texcoord_0, time, uvAnimationMaskTexture, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);

  // main color
  vec4 litTextureColor = texture(u_litColorTexture, mainUv);
  vec4 litColorFactor = get_litColor(materialSID, 0);

  // alpha
  float alpha = 1.0;

  #ifdef RN_ALPHATEST_ON
    alpha = litTextureColor.a * litColorFactor.a;
    float cutoff = get_cutoff(materialSID, 0);
    if(alpha < cutoff) discard;
  #elif defined(RN_ALPHABLEND_ON)
    alpha = litTextureColor.a * litColorFactor.a;
  #endif

  if (alpha < 0.01) {
    discard;
  }else{
    rt0.w = alpha;
  }


  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_COLOR_FIXED
      vec3 outlineColor = get_outlineColor(materialSID, 0);
      rt0.xyz = outlineColor;

      rt0.xyz = srgbToLinear(rt0.xyz);
/* shaderity: @{renderTargetEnd} */

      return;
    #endif
  #endif

  // view vector
  vec3 viewPosition = get_viewPosition(cameraSID, 0);
  vec3 viewVector = viewPosition - v_position_inWorld.xyz;
  vec3 viewDirection = normalize(viewVector);

  // Normal
  vec3 normal_inWorld = normalize(v_normal_inWorld);
  #ifdef RN_MTOON_HAS_BUMPMAP
    vec3 normal = texture(u_normalTexture, mainUv).xyz * 2.0 - 1.0;
    mat3 TBN = getTBN(normal_inWorld, viewDirection, mainUv);
    normal_inWorld = normalize(TBN * normal);
  #endif

  #ifdef RN_MTOON_IS_OUTLINE
    normal_inWorld *= -1.0;
  #endif


  // Lighting, Direct Light

  float shadowAttenuation = 1.0;
  // TODO: shadowmap computation

  float receiveShadowRate = get_receiveShadowRate(materialSID, 0);
  float lightAttenuation = shadowAttenuation * mix(1.0, shadowAttenuation, receiveShadowRate * texture(u_receiveShadowTexture, mainUv).r);

  float shadingGradeRate = get_shadingGradeRate(materialSID, 0);
  float shadingGrade = 1.0 - shadingGradeRate * (1.0 - texture(u_shadingGradeTexture, mainUv).r);
  float lightColorAttenuation = get_lightColorAttenuation(materialSID, 0);

  vec3 shadeColorFactor = get_shadeColor(materialSID, 0);
  vec3 shadeColor = shadeColorFactor * srgbToLinear(texture(u_shadeColorTexture, mainUv).xyz);

  vec3 litColor = litColorFactor.xyz * srgbToLinear(litTextureColor.xyz);

  float shadeShift = get_shadeShift(materialSID, 0);
  float shadeToony = get_shadeToony(materialSID, 0);

  vec3 lightings[/* shaderity: @{Config.maxLightNumberInShader} */];
  #ifdef RN_MTOON_DEBUG_LITSHADERATE
    float lightIntensities[/* shaderity: @{Config.maxLightNumberInShader} */];
  #endif
  for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {
    if (i >= lightNumber) {
      break;
    }

    // Light
    Light light = getLight(i, v_position_inWorld.xyz);

    // lightAttenuation *= distanceAttenuation * spotEffect;
    float dotNL = dot(light.direction, normal_inWorld);
    float lightIntensity = dotNL * 0.5 + 0.5; // from [-1, +1] to [0, 1]
    lightIntensity = lightIntensity * lightAttenuation; // TODO: receive shadow
    lightIntensity = lightIntensity * shadingGrade; // darker
    lightIntensity = lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]

    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]
    float maxIntensityThreshold = mix(1.0, shadeShift, shadeToony);
    float minIntensityThreshold = shadeShift;
    lightIntensity = clamp((lightIntensity - minIntensityThreshold) / max(EPS_COL, (maxIntensityThreshold - minIntensityThreshold)), 0.0, 1.0);
    #ifdef RN_MTOON_DEBUG_LITSHADERATE
      lightIntensities[i] = lightIntensity;
    #endif

    // Albedo color
    vec3 col = mix(shadeColor, litColor, lightIntensity);

    // Direct Light
    vec3 lighting = light.attenuatedIntensity;
    lighting = mix(lighting, vec3(max(EPS_COL, max(lighting.x, max(lighting.y, lighting.z)))), lightColorAttenuation); // color atten


    if(i > 0){
      lighting *= 0.5; // darken if additional light.
      lighting *= min(0.0, dotNL) + 1.0; // darken dotNL < 0 area by using half lambert
      // lighting *= shadowAttenuation; // darken if receiving shadow
      #ifdef RN_ALPHABLEND_ON
        lighting *= step(0.0, dotNL); // darken if transparent. Because Unity's transparent material can't receive shadowAttenuation.
      #endif
    }

    col *= lighting * RECIPROCAL_PI;
    lightings[i] = lighting;

    rt0.xyz += col;

    lightAttenuation = 1.0;
  }


  // Indirect Light
  float indirectLightIntensity = get_indirectLightIntensity(materialSID, 0);
  vec3 worldUpVector = vec3(0.0, 1.0, 0.0);
  vec3 worldDownVector = vec3(0.0, -1.0, 0.0);
  vec4 iblParameter = get_iblParameter(materialSID, 0);
  float rot = iblParameter.w;
  float IBLDiffuseContribution = iblParameter.y;
  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);
  vec3 rawGiUp = getIBLIrradiance(worldUpVector, iblParameter, hdriFormat) * IBLDiffuseContribution;
  vec3 rawGiDown = getIBLIrradiance(worldDownVector, iblParameter, hdriFormat) * IBLDiffuseContribution;
  vec3 rawGiNormal = getIBLIrradiance(normal_forEnv, iblParameter, hdriFormat) * IBLDiffuseContribution;
  vec3 uniformedGi = (rawGiUp + rawGiDown) / 2.0;
  vec3 passthroughGi = rawGiNormal;
  vec3 indirectLighting = mix(uniformedGi, passthroughGi, indirectLightIntensity);
  indirectLighting = mix(indirectLighting, vec3(max(EPS_COL, max(indirectLighting.x, max(indirectLighting.y, indirectLighting.z)))), lightColorAttenuation); // color atten

  rt0.xyz += indirectLighting * litColor * RECIPROCAL_PI;
  // rt0.xyz = min(rt0.xyz, litColor); // comment out if you want to PBR absolutely.


  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_COLOR_MIXED
      vec3 outlineColor = get_outlineColor(materialSID, 0);
      // outlineColor = srgbToLinear(outlineColor);
      float outlineLightingMix = get_outlineLightingMix(materialSID, 0);
      rt0.xyz = outlineColor * mix(vec3(1.0), rt0.xyz, outlineLightingMix);
    #endif
  #else
    float rimFresnelPower = get_rimFresnelPower(materialSID, 0);
    float rimLift = get_rimLift(materialSID, 0);
    vec3 rimColorFactor = get_rimColor(materialSID, 0);
    vec3 rimTextureColor = texture(u_rimTexture, mainUv).xyz;
    vec3 rimColor = rimColorFactor * srgbToLinear(rimTextureColor);
    vec3 rim = pow(clamp(1.0 - dot(normal_inWorld, viewDirection) + rimLift, 0.0, 1.0), rimFresnelPower) * rimColor;

    float staticRimLighting = 1.0;
    float rimLightingMix = get_rimLightingMix(materialSID, 0);
    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {
      if (i >= lightNumber) break;

      if(i > 0) staticRimLighting = 0.0;

      vec3 rimLighting = mix(vec3(staticRimLighting), lightings[i], vec3(rimLightingMix));
      rt0.xyz += rim * rimLighting;
    }

    // additive matcap
    vec3 cameraUp = get_cameraUp(0.0, 0); //solo datum
    vec3 worldViewUp = normalize(cameraUp - viewDirection * dot(viewDirection, cameraUp));
    vec3 worldViewRight = normalize(cross(viewDirection, worldViewUp));
    vec2 matcapUv = vec2(dot(worldViewRight, normal_inWorld), dot(worldViewUp, normal_inWorld)) * 0.5 + 0.5;
    vec3 matCapColor = srgbToLinear(texture(u_matCapTexture, matcapUv).xyz);
    rt0.xyz += matCapColor;


    // Emission
    vec3 emissionColor = get_emissionColor(materialSID, 0);
    vec3 emission = srgbToLinear(texture(u_emissionTexture, mainUv).xyz) * emissionColor;
    rt0.xyz += emission;
  #endif


  // debug
  #ifdef RN_MTOON_DEBUG_NORMAL
    rt0 = vec4(normal_inWorld * 0.5 + 0.5, alpha);

    rt0.xyz = srgbToLinear(rt0.xyz);
/* shaderity: @{renderTargetEnd} */

    return;
  #elif defined(RN_MTOON_DEBUG_LITSHADERATE)
    rt0 = vec4(0.0);
    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {
      if (i >= lightNumber) break;
      rt0 += vec4(lightIntensities[i] * lightings[i], alpha);
    }

    rt0.xyz = srgbToLinear(rt0.xyz);
/* shaderity: @{renderTargetEnd} */

    return;
  #endif


  // Wireframe
  float threshold = 0.001;
  vec3 wireframe = get_wireframe(materialSID, 0);
  float wireframeWidthInner = wireframe.z;
  float wireframeWidthRelativeScale = 1.0;
  if (wireframe.x > 0.5 && wireframe.y < 0.5) {
    rt0.a = 0.0;
  }
  vec4 wireframeResult = rt0;
  vec4 wireframeColor = vec4(0.2, 0.75, 0.0, 1.0);
  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);
  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);
  // if r0.a is 0.0, it is wireframe not on shaded
  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified);
  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));

  if (wireframe.x > 0.5) {
    rt0 = wireframeResult;
    if (wireframe.y < 0.5 && rt0.a == 0.0) {
      discard;
    }
  }

float makeOutputSrgb = float(get_makeOutputSrgb(materialSID, 0));
rt0.rgb = mix(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb);


/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var K2,Y2=C(()=>{K2={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

// This shader is based on https://github.com/Santarh/MToon


#ifdef RN_IS_SKINNING

fn createMatrixFromQuaternionTranslationScale( quaternion: vec4<f32>, translation: vec3<f32>, scale: vec3<f32> ) -> mat4x4<f32> {
  let q = quaternion;
  let t = translation;

  let sx = q.x * q.x;
  let sy = q.y * q.y;
  let sz = q.z * q.z;
  let cx = q.y * q.z;
  let cy = q.x * q.z;
  let cz = q.x * q.y;
  let wx = q.w * q.x;
  let wy = q.w * q.y;
  let wz = q.w * q.z;

  let mat = mat4x4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  let uniformScaleMat = mat4x4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  let mat44 = mat*uniformScaleMat;
  return mat44;

}

fn unpackedVec2ToNormalizedVec4(vec_xy: vec2<f32>, criteria: f32) -> vec4<f32> {

  var r: f32;
  var g: f32;
  var b: f32;
  var a: f32;

  let ix = floor(vec_xy.x * criteria);
  let v1x = ix / criteria;
  let v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  let iy = floor( vec_xy.y * criteria);
  let v2x = iy / criteria;
  let v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4<f32>(r, g, b, a);
}

fn get_boneMatrixAsMat4x4(skeletalComponentSID: u32, joint: u32) -> mat4x4<f32> {
  let mat43: mat4x3<f32> = get_boneMatrix(skeletalComponentSID, joint);
  return mat4x4<f32>(
    vec4<f32>(mat43[0], 0.0),
    vec4<f32>(mat43[1], 0.0),
    vec4<f32>(mat43[2], 0.0),
    vec4<f32>(mat43[3], 1.0)
  );
}

fn getSkinMatrix(skeletalComponentSID: u32, joint: vec4<u32>, weight: vec4<f32>) -> mat4x4<f32> {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  var skinMat: mat4x4<f32> = weight.x * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.x);
  skinMat += weight.y * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.y);
  skinMat += weight.z * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.z);
  skinMat += weight.w * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.w);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  let criteria = vec2<f32>(4096.0, 4096.0);

  let tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, joint.x);
  let sq_x = get_boneScalePackedQuat(skeletalComponentSID, joint.x);
  var quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  let tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, joint.y);
  let sq_y = get_boneScalePackedQuat(skeletalComponentSID, joint.y);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  let tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, joint.z);
  let sq_z = get_boneScalePackedQuat(skeletalComponentSID, joint.z);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  let tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, joint.w);
  let sq_w = get_boneScalePackedQuat(skeletalComponentSID, joint.w);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  let ts_x = get_boneTranslateScale(skeletalComponentSID, joint.x);
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.x), ts_x.xyz, vec3(ts_x.w));
  let ts_y = get_boneTranslateScale(skeletalComponentSID, joint.y);
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.y), ts_y.xyz, vec3(ts_y.w));
  let ts_z = get_boneTranslateScale(skeletalComponentSID, joint.z);
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.z), ts_z.xyz, vec3(ts_z.w));
  let ts_w = get_boneTranslateScale(skeletalComponentSID, joint.w);
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.w), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  let boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, joint.x);
  let boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, joint.y);
  let boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, joint.z);
  let boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, joint.w);

  let criteria = vec2<f32>(4096.0, 4096.0);
  let boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  let ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  let ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  let ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  let ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif

fn toNormalMatrix(m: mat4x4<f32>) -> mat3x3<f32> {
  let a00 = m[0][0];
  let a01 = m[0][1];
  let a02 = m[0][2];
  let a03 = m[0][3];
  let a10 = m[1][0];
  let a11 = m[1][1];
  let a12 = m[1][2];
  let a13 = m[1][3];
  let a20 = m[2][0];
  let a21 = m[2][1];
  let a22 = m[2][2];
  let a23 = m[2][3];
  let a30 = m[3][0];
  let a31 = m[3][1];
  let a32 = m[3][2];
  let a33 = m[3][3];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  let determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3x3<f32>(
    (a11 * b11 - a12 * b10 + a13 * b09) / determinantVal,
    (a12 * b08 - a10 * b11 - a13 * b07) / determinantVal,
    (a10 * b10 - a11 * b08 + a13 * b06) / determinantVal,
    (a02 * b10 - a01 * b11 - a03 * b09) / determinantVal,
    (a00 * b11 - a02 * b08 + a03 * b07) / determinantVal,
    (a01 * b08 - a00 * b10 - a03 * b06) / determinantVal,
    (a31 * b05 - a32 * b04 + a33 * b03) / determinantVal,
    (a32 * b02 - a30 * b05 - a33 * b01) / determinantVal,
    (a30 * b04 - a31 * b02 + a33 * b00) / determinantVal
  );
}

struct GeometoryOutput {
  normalMatrix: mat3x3<f32>,
  position_inWorld: vec4<f32>,
  normal_inWorld: vec3<f32>,
  isSkinning: bool,
}

#ifdef RN_IS_SKINNING
fn skinning(
  skeletalComponentSID: u32,
  inNormalMatrix: mat3x3<f32>,
  inPosition_inLocal: vec3<f32>,
  inNormal_inLocal: vec3<f32>,
  joint: vec4<u32>,
  weight: vec4<f32>,
  ) -> GeometoryOutput
{
  var output: GeometoryOutput;
  let skinMat = getSkinMatrix(skeletalComponentSID, joint, weight);
  output.position_inWorld = skinMat * vec4<f32>(inPosition_inLocal, 1.0);
  output.normalMatrix = toNormalMatrix(skinMat);
  output.normal_inWorld = normalize(output.normalMatrix * inNormal_inLocal);
  output.isSkinning = true;

  return output;
}
#endif


fn processGeometryWithMorphingAndSkinning(
  skeletalComponentSID: i32,
  blendShapeComponentSID: u32,
  worldMatrix: mat4x4<f32>,
  viewMatrix: mat4x4<f32>,
  isBillboard: bool,
  inNormalMatrix: mat3x3<f32>,
  inPosition_inLocal: vec3<f32>,
  inNormal_inLocal: vec3<f32>,
  baryCentricCoord: vec4<f32>,
  joint: vec4<u32>,
  weight: vec4<f32>,
) -> GeometoryOutput {
  var output: GeometoryOutput;

  var position_inLocal: vec3<f32>;
#ifdef RN_IS_MORPHING
  if (uniformDrawParameters.morphTargetNumber == 0u) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    let vertexIdx = u32(baryCentricCoord.w);
    position_inLocal = get_position(vertexIdx, inPosition_inLocal, blendShapeComponentSID);
  }
#endif

  var worldMatrixInner = worldMatrix;

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0) {
    output = skinning(u32(skeletalComponentSID), inNormalMatrix, position_inLocal, inNormal_inLocal, joint, weight);
  } else {
#endif
    output.normalMatrix = inNormalMatrix;
    output.position_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    output.normal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
    output.isSkinning = false;
#ifdef RN_IS_SKINNING
  }
#endif

  return output;
}


@vertex
fn main(
#ifdef RN_USE_INSTANCE
  @location(8) instance_ids: vec4<f32>,
#endif


#ifdef RN_USE_POSITION_FLOAT
  @location(0) position: vec3<f32>,
#endif
#ifdef RN_USE_POSITION_INT
  @location(0) position: vec3<i32>,
#endif
#ifdef RN_USE_POSITION_UINT
  @location(0) position: vec3<u32>,
#endif

#ifdef RN_USE_NORMAL
  @location(1) normal: vec3<f32>,
#endif
#ifdef RN_USE_TANGENT
  @location(2) tangent: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_0
  @location(3) texcoord_0: vec2<f32>,
#endif
#ifdef RN_USE_TEXCOORD_1
  @location(4) texcoord_1: vec2<f32>,
#endif

#ifdef RN_USE_COLOR_0_FLOAT
  @location(5) color_0: vec4<f32>,
#endif
#ifdef RN_USE_COLOR_0_INT
  @location(5) color_0: vec4<i32>,
#endif
#ifdef RN_USE_COLOR_0_UINT
  @location(5) color_0: vec4<u32>,
#endif

#ifdef RN_USE_JOINTS_0
  @location(6) joints_0: vec4<u32>,
#endif
#ifdef RN_USE_WEIGHTS_0
  @location(7) weights_0: vec4<f32>,
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
  @location(10) baryCentricCoord: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_2
  @location(11) texcoord_2: vec2<f32>,
#endif
  @builtin(vertex_index) vertexIdx : u32,


) -> VertexOutput {
  var output : VertexOutput;
  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_NONE
      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);
      return output;
    #endif
  #endif

#ifdef RN_USE_NORMAL
#else
  let normal = vec3<f32>(0.0, 0.0, 0.0);
#endif

#ifdef RN_USE_JOINTS_0
  let joint = joints_0;
#else
  let joint = vec4<u32>(0, 0, 0, 0);
#endif
#ifdef RN_USE_WEIGHTS_0
  let weight = weights_0;
#else
  let weight = vec4<f32>(0.0, 0.0, 0.0, 0.0);
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
#else
  let baryCentricCoord = vec4<f32>(0.0, 0.0, 0.0, 0.0);
#endif

let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  let instanceId = u32(instance_ids.x);
  let worldMatrix = get_worldMatrix(instanceId);
  let normalMatrix = get_normalMatrix(instanceId);
  let viewMatrix = get_viewMatrix(cameraSID, 0);
  let skeletalComponentSID = i32(instance_ids.y);
  let blendShapeComponentSID = u32(instance_ids.z);
  let geom = processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    blendShapeComponentSID,
    worldMatrix,
    viewMatrix,
    false,
    normalMatrix,
    position,
    normal,
    baryCentricCoord,
    joint,
    weight
  );

  let projectionMatrix = get_projectionMatrix(cameraSID, 0);

  output.position_inWorld = geom.position_inWorld.xyz;
  output.normal_inWorld = geom.normal_inWorld;
  output.normal_inView = (viewMatrix * vec4(geom.normal_inWorld, 0.0)).xyz;

  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_HAS_OUTLINE_WIDTH_TEXTURE
      let textureSize = textureDimensions(outlineWidthTexture, 0);
      let outlineTex = textureLoad(outlineWidthTexture, vec2u(vec2f(textureSize) * texcoord_0), 0).r;
    #else
      let outlineTex = 1.0;
    #endif

    #ifdef RN_MTOON_OUTLINE_WIDTH_WORLD
      let outlineWidth: f32 = get_outlineWidth(materialSID, 0);
      let outlineOffset: vec3f = 0.01 * outlineWidth * outlineTex * normal;
      let worldOutlineOffset: vec4f = worldMatrix * vec4f(outlineOffset, 0.0);
      output.position = projectionMatrix * viewMatrix * (geom.position_inWorld + worldOutlineOffset);

    #elif defined(RN_MTOON_OUTLINE_WIDTH_SCREEN)
      var vertex: vec4f = projectionMatrix * viewMatrix * geom.position_inWorld;

      let clipNormal: vec3f = (projectionMatrix * vec4f(output.normal_inView, 1.0)).xyz;
      var projectedNormal: vec2f = normalize(clipNormal.xy);
      let outlineScaledMaxDistance: f32 = get_outlineScaledMaxDistance(materialSID, 0);
      projectedNormal *= min(vertex.w, outlineScaledMaxDistance);
      let aspect: f32 = abs(get_aspect(0, 0)); //solo datum
      projectedNormal.x *= aspect;

      let outlineWidth: f32 = get_outlineWidth(materialSID, 0);
      vertex += vec4f(0.01 * outlineWidth * outlineTex * projectedNormal * clamp(1.0 - abs(output.normal_inView.z), 0.0, 1.0), 0.0, 0.0); // ignore offset when normal toward camera

      output.position = vertex;
    #else
      output.position = projectionMatrix * viewMatrix * geom.position_inWorld;
    #endif
  #else
    output.position = projectionMatrix * viewMatrix * geom.position_inWorld;
  #endif

  #ifdef RN_USE_TANGENT
    output.tangent_inWorld = normalMatrix * tangent.xyz;
    output.binormal_inWorld = cross(geom.normal_inWorld, output.tangent_inWorld) * tangent.w;
  #endif

  output.texcoord_0 = texcoord_0;
  output.baryCentricCoord = baryCentricCoord.xyz;

  return output;
}
`,shaderStage:"vertex",isFragmentShader:!1}});var J2,Z2=C(()=>{J2={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

const EPS_COL: f32 = 0.00001;

fn edge_ratio(bary3: vec3f, wireframeWidthInner: f32, wireframeWidthRelativeScale: f32) -> f32 {
  let d: vec3f = fwidth(bary3);
  let x: vec3f = bary3 + vec3f(1.0 - wireframeWidthInner) * d;
  let a3: vec3f = smoothstep(vec3f(0.0), d, x);
  let factor = min(min(a3.x, a3.y), a3.z);

  return clamp((1.0 - factor), 0.0, 1.0);
}

struct Light {
  lightType: i32, // 0 = directional, 1 = point, 2 = spot
  position: vec3<f32>,
  intensity: vec3<f32>,
  attenuatedIntensity: vec3<f32>,
  directionOfLightObject: vec3<f32>,
  direction: vec3<f32>, // direction of light vector, equal to normalize(light.pointToLight)
  pointToLight: vec3<f32>, // not normalized
  innerConeCos: f32,
  outerConeCos: f32,
  effectiveRange: f32,
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
fn getRangeAttenuation(light: Light) -> f32
{
  let distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
fn getSpotAttenuation(light: Light) -> f32
{
  let actualCos = dot(light.direction, -light.directionOfLightObject);
  if (actualCos > light.outerConeCos) {
    if (actualCos < light.innerConeCos) {
      let attenuation = (actualCos - light.outerConeCos) / (light.innerConeCos - light.outerConeCos);
      return attenuation * attenuation;
    }
    return 1.0;
  }
  return 0.0;
}

fn getLightAttenuated(light: Light) -> Light {
  var newLight: Light = light;
  newLight.attenuatedIntensity = light.intensity;
  // if (light.lightType == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light && Spot Light
  if (light.lightType != 0)
  {
    newLight.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot Light
  if (light.lightType == 2)
  {
    newLight.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return newLight;
}

fn getLight(lightIdx: u32, v_position_inWorld: vec3<f32>) -> Light {
  let lightPosition: vec3<f32> = get_lightPosition(0u, lightIdx);
  let direction_and_w_of_LightObject: vec3<f32> = get_lightDirection(0u, lightIdx);
  let lightIntensity: vec3<f32> = get_lightIntensity(0u, lightIdx);
  let lightProperty: vec4<f32> = get_lightProperty(0u, lightIdx);
  var light: Light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  let lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.innerConeCos = lightProperty.z;
  light.outerConeCos = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3f(0.0);
    light.lightType = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.lightType = 1;
  } else { // is Directional Light
    light.lightType = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.lightType = 2;
  }

  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  let newLight = getLightAttenuated(light);

  return newLight;
}

#ifdef RN_USE_TANGENT
  fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
    let tangent_inWorld = normalize(input.tangent_inWorld);
    let binormal_inWorld = normalize(input.binormal_inWorld);
    let tbnMat_tangent_to_world = mat3x3<f32>(tangent_inWorld, binormal_inWorld, normal_inWorld);

    return tbnMat_tangent_to_world;
  }
#else
    // This is based on http://www.thetenthplanet.de/archives/1180
    fn cotangent_frame(normal_inWorld: vec3f, position: vec3f, uv_: vec2f, isFront: bool) -> mat3x3<f32> {
      var uv: vec2f;
      if (isFront) {
        uv = uv_;
      } else {
        uv = -uv_;
      }

      // get edge vectors of the pixel triangle
      let dp1 = dpdx(position);
      let dp2 = -dpdy(position); // Because the Y direction of the window coordinate system is different from that of WebGL, this one is set to minus to make the result match the WebGL version.
      let duv1 = dpdx(uv);
      let duv2 = -dpdy(uv); // Because the Y direction of the window coordinate system is different from that of WebGL, this one is set to minus to make the result match the WebGL version.

      // solve the linear system
      let dp2perp = cross(dp2, normal_inWorld);
      let dp1perp = cross(normal_inWorld, dp1);
      let tangent = dp2perp * duv1.x + dp1perp * duv2.x;
      var bitangent = dp2perp * duv1.y + dp1perp * duv2.y;
      bitangent *= -1.0;

      // construct a scale-invariant frame
      let invMat = 1.0 / sqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));
      return mat3x3<f32>(tangent * invMat, bitangent * invMat, normal_inWorld);
    }

    fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
      let tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord, isFront);

      return tbnMat_tangent_to_world;
    }
#endif

// This file includes portions of code from the glTF-Sample-Renderer project by Khronos Group (Apache License 2.0).
// https://github.com/KhronosGroup/glTF-Sample-Renderer
// Modified by Yuki Shimada

fn srgbToLinear(srgbColor: vec3f) -> vec3f {
  return pow(srgbColor, vec3f(2.2));
}

fn linearToSrgb(linearColor: vec3f) -> vec3f {
  return pow(linearColor, vec3f(1.0/2.2));
}

// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66
fn Schlick_to_F0_F90(f: vec3f, f90: vec3f, VdotH: f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0_F90_F32(f: f32, f90: f32, VdotH: f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0(f: vec3f, VdotH: f32) -> vec3f {
    return Schlick_to_F0_F90(f, vec3(1.0), VdotH);
}

fn Schlick_to_F0_F32(f: f32, VdotH: f32) -> f32 {
    return Schlick_to_F0_F90_F32(f, 1.0, VdotH);
}


// The Schlick Approximation to Fresnel
fn fresnelSchlick(f0 : vec3f, f90 : vec3f, VdotH : f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnelSchlickF32(f0 : f32, f90 : f32, VdotH : f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnelSchlick2(f0: vec3f, VdotH: f32) -> vec3f
{
  let f90 = vec3f(1.0); //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelSchlick(f0, f90, VdotH);
}

fn fresnel2F32(f0: f32, VdotH: f32) -> f32
{
  let f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelSchlickF32(f0, f90, VdotH);
}

// Roughness Dependent Fresnel
// https://www.jcgt.org/published/0008/01/03/paper.pdf
fn fresnelSchlickRoughness(F0: vec3f, cosTheta: f32, roughness: f32) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);
  return k_S;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf
fn BRDF_lambertian(diffuseAlbedo: vec3f) -> vec3f
{
  return diffuseAlbedo * RECIPROCAL_PI;
}


// GGX NDF
fn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {
  let roughnessSqr = alphaRoughness * alphaRoughness;
  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
fn v_GGXCorrelated(NL: f32, NV: f32, alphaRoughness: f32) -> f32 {
  let a2 = alphaRoughness * alphaRoughness;
  let GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  let GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  let GGX = GGXV + GGXL;
  if (GGX > 0.0) {
    return clamp(0.5 / GGX, 0.0, 1.0);
  }
  return 1.0;
}

fn BRDF_specularGGX(NH: f32, NL: f32, NV: f32, alphaRoughness: f32) -> vec3f {
  let D = d_GGX(NH, alphaRoughness);
  let V = v_GGXCorrelated(NL, NV, alphaRoughness);
  return vec3f(D) * vec3f(V);
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
fn envBRDFApprox( Roughness: f32, NoV: f32 ) -> vec2f {
  let c0 = vec4f(-1, -0.0275, -0.572, 0.022 );
  let c1 = vec4f(1, 0.0425, 1.04, -0.04 );
  let r = Roughness * c0 + c1;
  let a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  let AB = vec2f( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}


// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes
fn specular_btdf(alphaRoughness: f32, NdotL: f32, NdotV: f32, NdotHt: f32) -> f32 {
  let V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  let D = d_GGX(NdotHt, alphaRoughness);
  return V * D;
}

fn IsotropicNDFFiltering(normal: vec3f, roughness2: f32) -> f32 {
  let SIGMA2 = 0.15915494;
  let KAPPA = 0.18;
  let dndu  = dpdx(normal);
  let dndv = dpdy(normal);
  let kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));
  let clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);
  let filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);
  return filteredRoughness2;
}

////////////////////////////////////////
// glTF KHR_materials_transmission
////////////////////////////////////////

#ifdef RN_USE_TRANSMISSION

// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
fn volumeAttenuation(attenuationColor: vec3f, attenuationDistance: f32, intensity: vec3f, transmissionDistance: f32) -> vec3f
{
  if (attenuationDistance == 0.0) { // means Infinite distance
    return intensity; // No attenuation
  } else {
    // let attenuationCo: vec3f = -log(attenuationColor) / attenuationDistance;
    // let attenuatedTransmittance: vec3f = exp(-attenuationCo * transmissionDistance);
    let attenuatedTransmittance: vec3f = pow(attenuationColor, vec3f(transmissionDistance / attenuationDistance));
    return intensity * attenuatedTransmittance;
  }
}

// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer
fn getVolumeTransmissionRay(n: vec3f, v: vec3f, thickness: f32, ior: f32, instanceInfo: u32) -> vec3f
{
  let refractionVector = refract(-v, normalize(n), 1.0 / ior);
  let worldMatrix = get_worldMatrix(instanceInfo);

  var modelScale: vec3f;
  modelScale.x = length(vec3f(worldMatrix[0].xyz));
  modelScale.y = length(vec3f(worldMatrix[1].xyz));
  modelScale.z = length(vec3f(worldMatrix[2].xyz));

  return normalize(refractionVector) * thickness * modelScale;
}
#endif

fn applyIorToRoughness(roughness: f32, ior: f32) -> f32
{
    return clamp(roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0), c_MinRoughness, 1.0);
}

fn calculateRadianceTransmission(normal: vec3f, view: vec3f, pointToLight: vec3f, alphaRoughness: f32, baseColor: vec3f, ior: f32) -> vec3f
{
    let transmissionRoughness = applyIorToRoughness(alphaRoughness, ior);

    let n = normalize(normal);
    let v = normalize(view);
    let l = normalize(pointToLight);
    let mirrorL = normalize(l + 2.0 * n * dot(-l, n));
    let h = normalize(mirrorL + v);

    let D = d_GGX(clamp(dot(n, h), 0.0, 1.0), transmissionRoughness);
    let V = v_GGXCorrelated(clamp(dot(n, mirrorL), 0.0, 1.0), clamp(dot(n, v), 0.0, 1.0), transmissionRoughness);

    return baseColor * D * V;
}




////////////////////////////////////////
// glTF KHR_materials_anisotropy
////////////////////////////////////////
#ifdef RN_USE_ANISOTROPY
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
fn D_GGX_anisotropic(NdotH: f32, TdotH: f32, BdotH: f32, at: f32, ab: f32) -> f32
{
    let a2 = at * ab;
    let f = vec3f(ab * TdotH, at * BdotH, a2 * NdotH);
    let w2 = a2 / dot(f, f);
    return a2 * w2 * w2 / M_PI;
}

fn V_GGX_anisotropic(NdotL: f32, NdotV: f32, BdotV: f32, TdotV: f32, TdotL: f32, BdotL: f32,
    at: f32, ab: f32) -> f32
{
    let GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));
    let GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));
    let GGX = GGXV + GGXL;
    if (GGX > 0.0) {
      return clamp(0.5 / GGX, 0.0, 1.0);
    }
    return 1.0;
}

fn BRDF_specularAnisotropicGGX(alphaRoughness: f32,
    VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32, BdotV: f32, TdotV: f32,
    TdotL: f32, BdotL: f32, TdotH: f32, BdotH: f32, anisotropy: f32) -> vec3f
{
    let at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
    let ab = clamp(alphaRoughness, 0.001, 1.0);

    let V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);
    let D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);

    return vec3f(V * D);
}
#endif

////////////////////////////////////////
// glTF KHR_materials_sheen
////////////////////////////////////////

#ifdef RN_USE_SHEEN
fn d_Charlie(sheenPerceptualRoughness: f32, NoH: f32) -> f32 {
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  let sheenRoughness = max(sheenPerceptualRoughness, 0.000001);
  let alphaG = sheenRoughness * sheenRoughness;
  let invAlpha  = 1.0 / alphaG;
  let cos2h = NoH * NoH;
  let sin2h = 1.0 - cos2h;
  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * M_PI);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn sheenSimpleVisibility(NdotL: f32, NdotV: f32) -> f32 {
  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn charlieL(x: f32, alphaG: f32) -> f32 {
  let oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
  let a = mix(21.5473, 25.3245, oneMinusAlphaSq);
  let b = mix(3.82987, 3.32435, oneMinusAlphaSq);
  let c = mix(0.19823, 0.16801, oneMinusAlphaSq);
  let d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
  let e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
  return a / (1.0 + b * pow(x, c)) + d * x + e;
}

fn lambdaSheen(cosTheta: f32, alphaG: f32) -> f32
{
  return select(exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG)), exp(charlieL(cosTheta, alphaG)), abs(cosTheta) < 0.5);
}

fn sheenCharlieVisibility(NdotL: f32, NdotV: f32, sheenPerceptualRoughness: f32) -> f32 {
  let sheenRoughness = max(sheenPerceptualRoughness, 0.000001);
  let alphaG = sheenRoughness * sheenRoughness;
  let sheenVisibility = clamp(1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL)), 0.0, 1.0);
  return sheenVisibility;
}

fn BRDF_specularSheen(sheenColor: vec3f, sheenPerceptualRoughness: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f {
  let sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);
  let sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);
  return sheenColor * sheenDistribution * sheenVisibility;
}
#endif // RN_USE_SHEEN

////////////////////////////////////////
// glTF KHR_materials_irirdescence
////////////////////////////////////////

#ifdef RN_USE_IRIDESCENCE
// XYZ to REC709(sRGB) conversion matrix
const XYZ_TO_REC709 = mat3x3<f32>(
     3.2404542, -0.9692660,  0.0556434,
    -1.5371385,  1.8760108, -0.2040259,
    -0.4985314,  0.0415560,  1.0572252
);

fn fresnelSchlickRoughnessWithIridescence(
  F0: vec3f, cosTheta: f32, roughness: f32,
  iridescenceFresnel: vec3f, iridescence: f32
  ) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);
  return k_S;
}

// Assume air interface for top
fn Fresnel0ToIor(F0: vec3f) -> vec3f {
    let sqrtF0 = sqrt(F0);
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// Conversion from IOR to F0
// ior is a value between 1.0 and 3.0. 1.0 is air interface
fn IorToFresnel0Vec3f(transmittedIor: vec3f, incidentIor: f32) -> vec3f {
    return sqVec3f((transmittedIor - vec3f(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
fn IorToFresnel0F32(transmittedIor: f32, incidentIor: f32) -> f32 {
    return sqF32((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration
 */
fn evalSensitivity(OPD: f32, shift: vec3f) -> vec3f {
    let phase = 2.0 * M_PI * OPD * 1.0e-9;
    let val = vec3f(5.4856e-13, 4.4201e-13, 5.2481e-13);
    let pos = vec3f(1.6810e+06, 1.7953e+06, 2.2084e+06);
    let var_ = vec3f(4.3278e+09, 9.3046e+09, 6.6121e+09);

    var xyz = val * sqrt(2.0 * M_PI * var_) * cos(pos * phase + shift) * exp(-(phase * phase) * var_);
    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));
    xyz /= 1.0685e-7;

    let rgb = XYZ_TO_REC709 * xyz;
    return rgb;
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel
 */
fn calcIridescence(outsideIor: f32, eta2: f32, cosTheta1: f32, thinFilmThickness: f32, baseF0: vec3f) -> vec3f {


  // iridescenceIor is the index of refraction of the thin-film layer
  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
  let iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));

  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)
  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.
  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.
  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):
  let sinTheta2Sq = sqF32(outsideIor / iridescenceIor) * (1.0 - sqF32(cosTheta1));
  let cosTheta2Sq = 1.0 - sinTheta2Sq;

  // Handle total internal reflection
  if (cosTheta2Sq < 0.0) {
      return vec3f(1.0);
  }

  let cosTheta2 = sqrt(cosTheta2Sq);

  /// Material Interfaces
  // The iridescence model defined by Belcour/Barla models two material interfaces
  // - one from the outside to the thin-film layer
  // and another one from the thin-film to the base material. These two interfaces are defined as follows:

  // First interface (from the outside to the thin-film layer)
  let R0 = IorToFresnel0F32(iridescenceIor, outsideIor);
  let R12 = fresnel2F32(R0, cosTheta1);
  let R21 = R12;
  let T121 = 1.0 - R12;

  // Second interface (from the thin-film to the base material)
  let baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0
  let R1 = IorToFresnel0Vec3f(baseIor, iridescenceIor);
  let R23 = fresnelSchlick2(R1, cosTheta2);

  // phi12 and phi23 define the base phases per interface and are approximated with 0.0
  // if the IOR of the hit material (iridescenceIor or baseIor) is higher
  // than the IOR of the previous material (outsideIor or iridescenceIor) and \u03C0 otherwise.
  // Also here, polarization is ignored.  float phi12 = 0.0;

  // First interface (from the outside to the thin-film layer)
  var phi12 = 0.0;
  if (iridescenceIor < outsideIor) { phi12 = M_PI; }
  let phi21 = M_PI - phi12;

  // Second interface (from the thin-film to the base material)
  var phi23 = vec3f(0.0);
  if (baseIor[0] < iridescenceIor) { phi23[0] = M_PI; }
  if (baseIor[1] < iridescenceIor) { phi23[1] = M_PI; }
  if (baseIor[2] < iridescenceIor) { phi23[2] = M_PI; }

  // OPD (optical path difference)
  let OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
  // Phase shift
  let phi = vec3f(phi21) + phi23;

  // Compound terms
  let R123 = clamp(R12 * R23, vec3f(1e-5), vec3f(0.9999));
  let r123 = sqrt(R123);
  let Rs = (T121 * T121) * R23 / (vec3f(1.0) - R123);

  // Reflectance term for m = 0 (DC term amplitude)
  let C0 = R12 + Rs;
  var I = C0;

  // Reflectance term for m > 0 (pairs of diracs)
  var Cm = Rs - T121;
  for (var m = 1; m <= 2; m++)
  {
      Cm *= r123;
      let Sm = 2.0 * evalSensitivity(f32(m) * OPD, f32(m) * phi);
      I += Cm * Sm;
  }

  let F_iridescence = max(I, vec3f(0.0));

  return F_iridescence;
}

//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB
fn BRDF_lambertianIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, iridescenceFactor: f32, diffuseColor: vec3f, specularWeight: f32, VdotH: f32) -> vec3f
{
    let iridescenceFresnelMax = vec3f(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));

    let schlickFresnel = Schlick_to_F0_F90(f0, f90, VdotH);

    let F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);

    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);
}

fn BRDF_specularGGXIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, alphaRoughness: f32, iridescenceFactor: f32, specularWeight: f32, VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f
{
    let F = mix(Schlick_to_F0_F90(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);
    let Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
    let D = d_GGX(NdotH, alphaRoughness);

    return specularWeight * F * Vis * D;
}

fn rgb_mix(base: vec3f, specular_brdf: vec3f, rgb_alpha: vec3f) -> vec3f
{
    let rgb_alpha_max = max(rgb_alpha.r, max(rgb_alpha.g, rgb_alpha.b));
    return (1.0 - rgb_alpha_max) * base + rgb_alpha * specular_brdf;
}

#endif // RN_USE_IRIDESCENCE


////////////////////////////////////////
// lighting with a punctual light
////////////////////////////////////////
fn lightingWithPunctualLight(
  light_: Light,
  normal_inWorld: vec3f,
  viewDirection: vec3f,
  NdotV: f32,
  baseColor: vec3f,
  perceptualRoughness: f32,
  metallic: f32,
  dielectricF0: vec3f,
  dielectricF90: vec3f,
  transmission: f32,
  thickness: f32,
  ior: f32,
  clearcoat: f32,
  clearcoatRoughness: f32,
  clearcoatF0: vec3f,
  clearcoatF90: vec3f,
  clearcoatFresnel: vec3f,
  clearcoatNormal_inWorld: vec3f,
  VdotNc: f32,
  attenuationColor: vec3f,
  attenuationDistance: f32,
  anisotropy: f32,
  anisotropicT: vec3f,
  anisotropicB: vec3f,
  BdotV: f32,
  TdotV: f32,
  sheenColor: vec3f,
  sheenRoughness: f32,
  albedoSheenScalingNdotV: f32,
  iridescence: f32,
  iridescenceFresnel_dielectric: vec3f,
  iridescenceFresnel_metal: vec3f,
  specularWeight: f32,
  instanceInfo: u32,
  diffuseTransmission: f32,
  diffuseTransmissionColor: vec3f,
  diffuseTransmissionThickness: f32
  ) -> vec3f
{
  var light = light_;
  let alphaRoughness = perceptualRoughness * perceptualRoughness;

  // Fresnel
  let halfVector = normalize(light.direction + viewDirection);
  let VdotH = saturate(dot(viewDirection, halfVector));
  var dielectricFresnel = fresnelSchlick(dielectricF0, dielectricF90, VdotH);
  let metalFresnel = fresnelSchlick(baseColor, vec3f(1.0), VdotH);

  let NdotL = saturateEpsilonToOne(dot(normal_inWorld, light.direction));

  // Diffuse
  let diffuseBrdf = BRDF_lambertian(baseColor);
  var diffuseContrib = diffuseBrdf * vec3f(NdotL) * light.attenuatedIntensity;

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  diffuseContrib = diffuseContrib * (vec3f(1.0) - diffuseTransmission);
  if (dot(normal_inWorld, light.direction) < 0.0) {
    let diffuseNdotL = saturate(dot(normal_inWorld, -light.direction));
    var diffuseBtdf = BRDF_lambertian(diffuseTransmissionColor) * vec3f(diffuseNdotL) * light.attenuatedIntensity;
    let mirrorL = normalize(light.direction + 2.0 * normal_inWorld * dot(normal_inWorld, -light.direction));
    let diffuseVdotH = saturate(dot(viewDirection, normalize(mirrorL + viewDirection)));
    dielectricFresnel = fresnelSchlick(dielectricF0 * specularWeight, dielectricF90, abs(diffuseVdotH));
#ifdef RN_USE_VOLUME
    diffuseBtdf = volumeAttenuation(attenuationColor, attenuationDistance, diffuseBtdf, diffuseTransmissionThickness);
#endif // RN_USE_VOLUME
    diffuseContrib += diffuseBtdf * diffuseTransmission;
  }
#endif // RN_USE_DIFFUSE_TRANSMISSION

#ifdef RN_USE_TRANSMISSION
  let transmittionRay = getVolumeTransmissionRay(normal_inWorld, viewDirection, thickness, ior, instanceInfo);
  light.pointToLight -= transmittionRay;
  light.direction = normalize(light.pointToLight);
  var transmittedContrib = calculateRadianceTransmission(normal_inWorld, viewDirection, light.direction, alphaRoughness, baseColor, ior) * light.attenuatedIntensity;

#ifdef RN_USE_VOLUME
  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittionRay));
#endif // RN_USE_VOLUME

  diffuseContrib = mix(diffuseContrib, vec3f(transmittedContrib), transmission);
#endif // RN_USE_TRANSMISSION

  // Specular
  let NdotH = saturate(dot(normal_inWorld, halfVector));

#ifdef RN_USE_ANISOTROPY
  let TdotL = dot(anisotropicT, light.direction);
  let BdotL = dot(anisotropicB, light.direction);
  let TdotH = dot(anisotropicT, halfVector);
  let BdotH = dot(anisotropicB, halfVector);
  let specularMetalContrib = BRDF_specularAnisotropicGGX(alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3f(NdotL) * light.attenuatedIntensity;
  let specularDielectricContrib = specularMetalContrib;
#else
  let specularMetalContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, alphaRoughness) * vec3f(NdotL) * light.attenuatedIntensity;
  let specularDielectricContrib = specularMetalContrib;
#endif

  // Base Layer
  var metal = specularMetalContrib * metalFresnel;
  var dielectric = mix(diffuseContrib, specularDielectricContrib, dielectricFresnel);

#ifdef RN_USE_IRIDESCENCE
  metal = mix(metal, specularMetalContrib * iridescenceFresnel_metal, iridescence);
  dielectric = mix(dielectric, rgb_mix(diffuseContrib, specularDielectricContrib, iridescenceFresnel_dielectric), iridescence);
#endif // RN_USE_IRIDESCENCE

#ifdef RN_USE_CLEARCOAT
  // Clear Coat Layer
  let NdotHc = saturate(dot(clearcoatNormal_inWorld, halfVector));
  let LdotNc = saturate(dot(light.direction, clearcoatNormal_inWorld));
  let clearcoatContrib = BRDF_specularGGX(NdotHc, LdotNc, VdotNc, clearcoatRoughness * clearcoatRoughness) * vec3f(LdotNc) * light.attenuatedIntensity;
#else
  let clearcoatContrib = vec3f(0.0);
#endif // RN_USE_CLEARCOAT

#ifdef RN_USE_SHEEN
  // Sheen
  let sheenContrib = BRDF_specularSheen(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;
  let albedoSheenScaling = min(
    albedoSheenScalingNdotV,
    1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotL, sheenRoughness)).r);
#else
  let sheenContrib = vec3f(0.0);
  let albedoSheenScaling = 1.0;
#endif // RN_USE_SHEEN

  var color = mix(dielectric, metal, metallic);
  color = sheenContrib + color * albedoSheenScaling;
  color = mix(color, clearcoatContrib, clearcoat * clearcoatFresnel);

  return color;
}


@group(1) @binding(16) var diffuseEnvTexture: texture_cube<f32>; // initialValue=black, isInternalSetting=true
@group(2) @binding(16) var diffuseEnvSampler: sampler;
@group(1) @binding(17) var specularEnvTexture: texture_cube<f32>; // initialValue=black, isInternalSetting=true
@group(2) @binding(17) var specularEnvSampler: sampler;

// #param inverseEnvironment: bool; // initialValue=false
// #param iblParameter: vec4<f32>; // initialValue=(1,1,1,1), isInternalSetting=true
// #param hdriFormat: vec2<i32>; // initialValue=(0,0), isInternalSetting=true

// This file includes portions of code from the glTF-Sample-Renderer project by Khronos Group (Apache License 2.0).
// https://github.com/KhronosGroup/glTF-Sample-Renderer
// Modified by Yuki Shimada

fn getIBLIrradiance(normal_forEnv: vec3f, iblParameter: vec4f, hdriFormat: vec2<i32>) -> vec3f {
  let diffuseTexel: vec4f = textureSample(diffuseEnvTexture, diffuseEnvSampler, normal_forEnv);

  var irradiance: vec3f;
  if (hdriFormat.x == 0) {
    // LDR_SRGB
    irradiance = srgbToLinear(diffuseTexel.rgb);
  }
  else if (hdriFormat.x == 3) {
    // RGBE
    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  }
  else {
    irradiance = diffuseTexel.rgb;
  }

  // scale with user parameters
  let IBLDiffuseContribution = iblParameter.y;
  irradiance *= IBLDiffuseContribution;

  return irradiance;
}

fn get_radiance(reflection: vec3f, lod: f32, hdriFormat: vec2<i32>) -> vec3f {
  let specularTexel = textureSampleLevel(specularEnvTexture, specularEnvSampler, reflection, lod);

  var radiance: vec3f;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

#ifdef RN_USE_SHEEN

fn get_radiance_sheen(reflection: vec3f, lod: f32, hdriFormat: vec2<i32>) -> vec3f {
  let specularTexel = textureSampleLevel(sheenEnvTexture, sheenEnvSampler, reflection, lod);

  var radiance: vec3f;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

fn sheenIBL(NdotV: f32, sheenPerceptualRoughness: f32, sheenColor: vec3f, iblParameter: vec4f, reflection: vec3f, hdriFormat: vec2i) -> vec3f
{
  let mipCount = iblParameter.x;
  let lod = (sheenPerceptualRoughness * (mipCount - 1.0));

  let sheenLutUV = vec2f(NdotV, sheenPerceptualRoughness);
  let brdf = textureSample(sheenLutTexture, sheenLutSampler, sheenLutUV).b;
  var sheenLight = get_radiance_sheen(reflection, lod, hdriFormat);
  let IBLSpecularContribution = iblParameter.z;
  sheenLight *= IBLSpecularContribution;

  return sheenLight * sheenColor * brdf;
}
#endif

fn getNormalForEnv(rotEnvMatrix: mat3x3<f32>, normal_inWorld: vec3f, materialSID: u32) -> vec3f {
  var normal_forEnv = rotEnvMatrix * normal_inWorld;
  if (get_inverseEnvironment(materialSID, 0)) {
    normal_forEnv.x *= -1.0;
  }
  return normal_forEnv;
}

fn getReflection(rotEnvMatrix: mat3x3<f32>, viewDirection: vec3f, normal_inWorld: vec3f,
  materialSID: u32, perceptualRoughness: f32,
  anisotropy: f32, anisotropyDirection: vec3f
  ) -> vec3f {
#ifdef RN_USE_ANISOTROPY
  let tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);
  let anisotropicTangent  = cross(anisotropyDirection, viewDirection);
  let anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);
  let bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);
  let bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;
  let bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));
  var reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);
#else
  var reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);
#endif
  if (get_inverseEnvironment(materialSID, 0)) {
    reflection.x *= -1.0;
  }
  return reflection;
}

fn scaleForLod(perceptualRoughness: f32, ior: f32) -> f32
{
  // Scale roughness to the range [0, 1],
  // ior=1.0 will be scale 0,
  // ior=1.5 will be scale 1.0,
  // ior=2 will be scale 1.0 (clamped)
  //

  let scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);
  return perceptualRoughness * scale;
}

#ifdef RN_USE_TRANSMISSION
fn get_sample_from_backbuffer(sampleCoord: vec2f, perceptualRoughness: f32, ior: f32) -> vec3f {
  let vrState: vec2<i32> = get_vrState(0, 0);
  let backBufferTextureSize = vec2f(textureDimensions(backBufferTexture, 0));
  var backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);
  var newSampleCoord = sampleCoord;
  newSampleCoord.y = 1.0 - newSampleCoord.y;
  if (vrState.x == 1) { // For VR
    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
    newSampleCoord.x = sampleCoord.x * 0.5;
    if (vrState.y == 1) { // For right eye
      newSampleCoord.x += 0.5;
    }
  }
  let framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);

  let transmittedLight = textureSampleLevel(backBufferTexture, backBufferSampler, newSampleCoord, framebufferLod).rgb;

  return transmittedLight;
}

fn getIBLVolumeRefraction(baseColor: vec3f, normal: vec3f, view: vec3f, cameraSID: u32, materialSID: u32, thickness: f32, perceptualRoughness: f32, ior: f32, attenuationColor: vec3f, attenuationDistance: f32, position_inWorld: vec3f, instanceInfo: u32) -> vec3f {
#ifdef RN_USE_DISPERSION
  let dispersion = get_dispersion(materialSID, 0);
  let halfSpread = (ior - 1.0) * 0.025 * dispersion;
  let iors = vec3f(ior - halfSpread, ior, ior + halfSpread);

  var transmittedLight: vec3f;
  var transmissionRayLength: f32;
  for(var i=0; i<3; i++) {
    let transmissionRay = getVolumeTransmissionRay(normal, view, thickness, iors[i], instanceInfo);
    transmissionRayLength = length(transmissionRay);
    let refractedRayExit = position_inWorld + transmissionRay;

    let ndcPos = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4f(refractedRayExit, 1.0);
    var refractionCoords = ndcPos.xy / ndcPos.w;
    refractionCoords += 1.0;
    refractionCoords /= 2.0;

    transmittedLight[i] = get_sample_from_backbuffer(refractionCoords, perceptualRoughness, iors[i])[i];
  }
#else
  let transmissionRay = getVolumeTransmissionRay(normal, view, thickness, ior, instanceInfo);
  let transmissionRayLength = length(transmissionRay);
  let refractedRayExit = position_inWorld + transmissionRay;

  let ndcPos = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4f(refractedRayExit, 1.0);
  var refractionCoords = ndcPos.xy / ndcPos.w;
  refractionCoords += 1.0;
  refractionCoords /= 2.0;

  let transmittedLight = get_sample_from_backbuffer(refractionCoords, perceptualRoughness, ior);
#endif
  let attenuatedColor = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, transmissionRayLength);

  return attenuatedColor * baseColor;
}

#endif // RN_USE_TRANSMISSION

struct IblResult
{
  specular: vec3f,
  diffuse: vec3f,
  FssEss: vec3f,
};

fn getIBLRadianceGGX(perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, reflection: vec3f) -> vec3f
{
  // get radiance
  let mipCount = iblParameter.x;
  let lod = (perceptualRoughness * (mipCount - 1.0));
  var radiance: vec3f = get_radiance(reflection, lod, hdriFormat);

  let IBLSpecularContribution = iblParameter.z;
  radiance *= IBLSpecularContribution;

  return radiance;
}

fn getIBLFresnelGGX(perceptualRoughness: f32, NdotV: f32, F0: vec3f, specularWeight: f32) -> vec3f {
  // https://bruop.github.io/ibl/#single_scattering_results

  // Roughness dependent fresnel
  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss: vec3f = vec3f(specularWeight) * (kS * f_ab.x + f_ab.y);

  // Multiple scattering
  let Ems: f32 = (1.0 - (f_ab.x + f_ab.y));
  let F_avg: vec3f = vec3f(specularWeight) * (F0 + (1.0 - F0) / 21.0);
  let FmsEms: vec3f = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);

  return FssEss + FmsEms;
}

fn IBLContribution(materialSID: u32, cameraSID: u32, normal_inWorld: vec3f, NdotV: f32, viewDirection: vec3f,
  baseColor: vec3f, perceptualRoughness: f32,
  clearcoatRoughness: f32, clearcoatNormal_inWorld: vec3f, clearcoat: f32, clearcoatFresnel: vec3f, VdotNc: f32, geomNormal_inWorld: vec3f,
  transmission: f32, position_inWorld: vec3f, instanceInfo: u32, thickness: f32, ior: f32,
  sheenColor: vec3f, sheenRoughness: f32, albedoSheenScalingNdotV: f32,
  iridescenceFresnel_dielectric: vec3f, iridescenceFresnel_metal: vec3f, iridescence: f32,
  anisotropy: f32, anisotropyDirection: vec3f, specularWeight: f32, dielectricF0: vec3f, metallic: f32,
  diffuseTransmission: f32, diffuseTransmissionColor: vec3f, diffuseTransmissionThickness: f32
  ) -> vec3f
{
  let iblParameter: vec4f = get_iblParameter(materialSID, 0);
  let rot = iblParameter.w;
  let rotEnvMatrix = mat3x3<f32>(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  let hdriFormat: vec2<i32> = get_hdriFormat(materialSID, 0);

  let normal_forEnv: vec3f = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  let reflection: vec3f = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);

  // get irradiance
  let irradiance: vec3f = getIBLIrradiance(normal_forEnv, iblParameter, hdriFormat);
  var diffuse: vec3f = irradiance * baseColor;

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  var diffuseTransmissionIBL: vec3f = getIBLIrradiance(-normal_forEnv, iblParameter, hdriFormat) * diffuseTransmissionColor;
#ifdef RN_USE_VOLUME
  diffuseTransmissionIBL = volumeAttenuation(attenuationColor, attenuationDistance, diffuseTransmissionIBL, diffuseTransmissionThickness);
#endif
  diffuse = mix(diffuse, diffuseTransmissionIBL, diffuseTransmission);
#endif

#ifdef RN_USE_TRANSMISSION
  let attenuationColor: vec3f = get_attenuationColor(materialSID, 0);
  let attenuationDistance: f32 = get_attenuationDistance(materialSID, 0);
  let specularTransmission: vec3f = getIBLVolumeRefraction(baseColor, normal_inWorld, viewDirection, cameraSID, materialSID, thickness, perceptualRoughness, ior, attenuationColor, attenuationDistance, position_inWorld, instanceInfo);
  diffuse = mix(diffuse, specularTransmission, transmission);
#endif

  // take account of anisotropy with reflection
  let specularMetal: vec3f = getIBLRadianceGGX(perceptualRoughness, iblParameter, hdriFormat, reflection);
  let specularDielectric: vec3f = specularMetal;

  // Calculate fresnel mix
  let fresnelMetal: vec3f = getIBLFresnelGGX(perceptualRoughness, NdotV, baseColor, 1.0);
  var metalContrib: vec3f = fresnelMetal * specularMetal;
  let fresnelDielectric: vec3f = getIBLFresnelGGX(perceptualRoughness, NdotV, dielectricF0, specularWeight);
  var dielectricContrib: vec3f = mix(diffuse, specularDielectric, fresnelDielectric);

#ifdef RN_USE_IRIDESCENCE
  metalContrib = mix(metalContrib, specularMetal * iridescenceFresnel_metal, iridescence);
  dielectricContrib = mix(dielectricContrib, rgb_mix(diffuse, specularDielectric, iridescenceFresnel_dielectric), iridescence);
#endif

#ifdef RN_USE_CLEARCOAT
  let clearcoatReflection: vec3f = getReflection(rotEnvMatrix, viewDirection, clearcoatNormal_inWorld, materialSID, clearcoatRoughness, 0.0, vec3(0.0));
  let clearcoatContrib: vec3f = getIBLRadianceGGX(clearcoatRoughness, iblParameter, hdriFormat, clearcoatReflection);
#else
  let clearcoatContrib: vec3f = vec3(0.0);
#endif

#ifdef RN_USE_SHEEN
  let sheenContrib: vec3f = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);
  let albedoSheenScaling: f32 = albedoSheenScalingNdotV;
#else
  let sheenContrib: vec3f = vec3(0.0);
  let albedoSheenScaling: f32 = 1.0;
#endif

  var color: vec3f = mix(dielectricContrib, metalContrib, metallic);
  color = sheenContrib + color * albedoSheenScaling;
  color = mix(color, clearcoatContrib, clearcoat * clearcoatFresnel);
  return color;
}



const PI_2: f32 = 6.28318530718;

fn uvAnimation(origUv: vec2f, time: f32, uvAnimationMask: f32, uvAnimationScrollXSpeedFactor: f32, uvAnimationScrollYSpeedFactor: f32, uvAnimationRotationSpeedFactor: f32) -> vec2f {
  let uvAnim = uvAnimationMask * time;
  var uv = origUv;
  uv += vec2f(uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor) * uvAnim;
  let rotateRad = uvAnimationRotationSpeedFactor * PI_2 * uvAnim;
  let rotatePivot = vec2f(0.5);
  uv = mat2x2f(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (uv - rotatePivot) + rotatePivot;
  return uv;
}

@fragment
fn main (
  input: VertexOutput,
  @builtin(front_facing) isFront: bool
) -> @location(0) vec4<f32> {
  var rt0 = vec4f(0.0, 0.0, 0.0, 1.0);

  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_NONE
      discard;
    #endif
  #endif

let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  // uv animation
  let uvAnimationMaskTexture = textureSample(uvAnimationMaskTexture, uvAnimationMaskSampler, input.texcoord_0).r;
  let uvAnimationScrollXSpeedFactor = get_uvAnimationScrollXSpeedFactor(materialSID, 0);
  let uvAnimationScrollYSpeedFactor = get_uvAnimationScrollYSpeedFactor(materialSID, 0);
  let uvAnimationRotationSpeedFactor = get_uvAnimationRotationSpeedFactor(materialSID, 0);
  let time = get_time(0, 0);
  let mainUv = uvAnimation(input.texcoord_0, time, uvAnimationMaskTexture, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);

  // main color
  let litTextureColor: vec4f = textureSample(litColorTexture, litColorSampler, mainUv);
  let litColorFactor: vec4f = get_litColor(materialSID, 0);

  // alpha
  var alpha = 1.0;

  #ifdef RN_ALPHATEST_ON
    alpha = litTextureColor.a * litColorFactor.a;
    let cutoff: f32 = get_cutoff(materialSID, 0);
    if (alpha < cutoff) { discard; }
  #elif defined(RN_ALPHABLEND_ON)
    alpha = litTextureColor.a * litColorFactor.a;
  #endif

  if (alpha < 0.01) {
    discard;
  } else {
    rt0.w = alpha;
  }


  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_COLOR_FIXED
      let outlineColor: vec3f = get_outlineColor(materialSID, 0);
      rt0 = vec4f(outlineColor, rt0.w);

      rt0 = vec4(srgbToLinear(rt0.xyz), rt0.w);
      return rt0;
    #endif
  #endif

  // view vector
  let viewPosition: vec3f = get_viewPosition(cameraSID, 0);
  let viewVector: vec3f = viewPosition - input.position_inWorld.xyz;
  let viewDirection: vec3f = normalize(viewVector);

  // Normal
  var normal_inWorld: vec3f = normalize(input.normal_inWorld);
  #ifdef RN_MTOON_HAS_BUMPMAP
    let normal: vec3f = textureSample(normalTexture, normalSampler, mainUv).xyz * 2.0 - 1.0;
    let TBN: mat3x3<f32> = getTBN(normal_inWorld, input, viewDirection, mainUv, isFront);
    normal_inWorld = normalize(TBN * normal);
  #endif

  #ifdef RN_MTOON_IS_OUTLINE
    normal_inWorld *= -1.0;
  #endif


  // Lighting, Direct Light

  let shadowAttenuation = 1.0;
  // TODO: shadowmap computation

  let receiveShadowRate: f32 = get_receiveShadowRate(materialSID, 0);
  var lightAttenuation: f32 = shadowAttenuation * mix(1.0, shadowAttenuation, receiveShadowRate * textureSample(receiveShadowTexture, receiveShadowSampler, mainUv).r);

  let shadingGradeRate: f32 = get_shadingGradeRate(materialSID, 0);
  let shadingGrade: f32 = 1.0 - shadingGradeRate * (1.0 - textureSample(shadingGradeTexture, shadingGradeSampler, mainUv).r);
  let lightColorAttenuation: f32 = get_lightColorAttenuation(materialSID, 0);

  let shadeColorFactor: vec3f = get_shadeColor(materialSID, 0);
  var shadeColor: vec3f = shadeColorFactor * srgbToLinear(textureSample(shadeColorTexture, shadeColorSampler, mainUv).xyz);

  var litColor: vec3f = litColorFactor.xyz * srgbToLinear(litTextureColor.xyz);

  let shadeShift: f32 = get_shadeShift(materialSID, 0);
  let shadeToony: f32 = get_shadeToony(materialSID, 0);

  var lightings: array<vec3<f32>, /* shaderity: @{Config.maxLightNumberInShader} */>;
  #ifdef RN_MTOON_DEBUG_LITSHADERATE
    var lightIntensities[/* shaderity: @{Config.maxLightNumberInShader} */]: array<f32>;
  #endif
  let lightNumber = u32(get_lightNumber(0u, 0u));
  for (var i = 0u; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {
    if (i >= lightNumber) {
      break;
    }

    // Light
    let light: Light = getLight(i, input.position_inWorld.xyz);

    // lightAttenuation *= distanceAttenuation * spotEffect;
    let dotNL: f32 = dot(light.direction, normal_inWorld);
    var lightIntensity: f32 = dotNL * 0.5 + 0.5; // from [-1, +1] to [0, 1]
    lightIntensity = lightIntensity * lightAttenuation; // TODO: receive shadow
    lightIntensity = lightIntensity * shadingGrade; // darker
    lightIntensity = lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]

    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]
    let maxIntensityThreshold: f32 = mix(1.0, shadeShift, shadeToony);
    let minIntensityThreshold: f32 = shadeShift;
    lightIntensity = clamp((lightIntensity - minIntensityThreshold) / max(EPS_COL, (maxIntensityThreshold - minIntensityThreshold)), 0.0, 1.0);
    #ifdef RN_MTOON_DEBUG_LITSHADERATE
      lightIntensities[i] = lightIntensity;
    #endif

    // Albedo color
    var col: vec3f = mix(shadeColor, litColor, lightIntensity);

    // Direct Light
    var lighting: vec3f = light.attenuatedIntensity;
    lighting = mix(lighting, vec3(max(EPS_COL, max(lighting.x, max(lighting.y, lighting.z)))), lightColorAttenuation); // color atten


    if(i > 0){
      lighting *= 0.5; // darken if additional light.
      lighting *= min(0.0, dotNL) + 1.0; // darken dotNL < 0 area by using half lambert
      // lighting *= shadowAttenuation; // darken if receiving shadow
      #ifdef RN_ALPHABLEND_ON
        lighting *= step(0.0, dotNL); // darken if transparent. Because Unity's transparent material can't receive shadowAttenuation.
      #endif
    }

    col *= lighting * RECIPROCAL_PI;
    lightings[i] = lighting;

    rt0 += vec4f(col, 0.0);

    lightAttenuation = 1.0;
  }


  // Indirect Light
  let indirectLightIntensity = get_indirectLightIntensity(materialSID, 0);
  let worldUpVector = vec3f(0.0, 1.0, 0.0);
  let worldDownVector = vec3f(0.0, -1.0, 0.0);
  let iblParameter = get_iblParameter(materialSID, 0);
  let rot = iblParameter.w;
  let IBLDiffuseContribution = iblParameter.y;
  let rotEnvMatrix = mat3x3f(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  let normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  let hdriFormat = get_hdriFormat(materialSID, 0);
  let rawGiUp = getIBLIrradiance(worldUpVector, iblParameter, hdriFormat) * IBLDiffuseContribution;
  let rawGiDown = getIBLIrradiance(worldDownVector, iblParameter, hdriFormat) * IBLDiffuseContribution;
  let rawGiNormal = getIBLIrradiance(normal_forEnv, iblParameter, hdriFormat) * IBLDiffuseContribution;
  let uniformedGi = (rawGiUp + rawGiDown) / 2.0;
  let passthroughGi = rawGiNormal;
  var indirectLighting = mix(uniformedGi, passthroughGi, indirectLightIntensity);
  indirectLighting = mix(indirectLighting, vec3f(max(EPS_COL, max(indirectLighting.x, max(indirectLighting.y, indirectLighting.z)))), lightColorAttenuation); // color atten
  rt0 += vec4f(indirectLighting * litColor * RECIPROCAL_PI, 0.0);
  // rt0 = vec4f(min(rt0.xyz, litColor), rt0.w); // comment out if you want to PBR absolutely.


  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_COLOR_MIXED
      var outlineColor: vec3f = get_outlineColor(materialSID, 0);
      // outlineColor = srgbToLinear(outlineColor);
      let outlineLightingMix: f32 = get_outlineLightingMix(materialSID, 0);
      rt0 = vec4f(outlineColor * mix(vec3f(1.0), rt0.xyz, outlineLightingMix), rt0.w);
    #endif
  #else
    let rimFresnelPower: f32 = get_rimFresnelPower(materialSID, 0);
    let rimLift: f32 = get_rimLift(materialSID, 0);
    let rimColorFactor: vec3f = get_rimColor(materialSID, 0);
    let rimTextureColor: vec3f = textureSample(rimTexture, rimSampler, mainUv).xyz;
    let rimColor: vec3f = rimColorFactor * srgbToLinear(rimTextureColor);
    let rim: vec3f = pow(clamp(1.0 - dot(normal_inWorld, viewDirection) + rimLift, 0.0, 1.0), rimFresnelPower) * rimColor;

    var staticRimLighting = 1.0;
    let rimLightingMix: f32 = get_rimLightingMix(materialSID, 0);
    for (var i = 0u; i < /* shaderity: @{Config.maxLightNumberInShader} */u; i++) {
      if (i >= lightNumber) { break; }

      if (i > 0) { staticRimLighting = 0.0; }

      let rimLighting: vec3f = mix(vec3f(staticRimLighting), lightings[i], vec3f(rimLightingMix));
      rt0 += vec4f(rim * rimLighting, 0.0);
    }

    // additive matcap
    let cameraUp: vec3f = get_cameraUp(0u, 0u); //solo datum
    let worldViewUp: vec3f = normalize(cameraUp - viewDirection * dot(viewDirection, cameraUp));
    let worldViewRight: vec3f = normalize(cross(viewDirection, worldViewUp));
    let matcapUv: vec2f = vec2f(dot(worldViewRight, normal_inWorld), dot(worldViewUp, normal_inWorld)) * 0.5 + 0.5;
    let matCapColor: vec3f = srgbToLinear(textureSample(matCapTexture, matCapSampler, matcapUv).xyz);
    rt0 += vec4f(matCapColor, 0.0);


    // Emission
    let emissionColor: vec3f = get_emissionColor(materialSID, 0);
    let emission: vec3f = srgbToLinear(textureSample(emissionTexture, emissionSampler, mainUv).xyz) * emissionColor;
    rt0 += vec4f(emission, 0.0);
  #endif


  // debug
  #ifdef RN_MTOON_DEBUG_NORMAL
    rt0 = vec4f(normal_inWorld * 0.5 + 0.5, alpha);

    rt0 = vec4f(srgbToLinear(rt0.xyz), rt0.w);
    return rt0;
  #elif defined(RN_MTOON_DEBUG_LITSHADERATE)
    rt0 = vec4f(0.0);
    for (var i = 0u; i < /* shaderity: @{Config.maxLightNumberInShader} */u; i++) {
      if (i >= lightNumber) { break; }
      rt0 += vec4f(lightIntensities[i] * lightings[i], alpha);
    }

    rt0 = vec4f(srgbToLinear(rt0.xyz), rt0.w);
    return rt0;
  #endif


  // Wireframe
  let threshold = 0.001;
  let wireframe: vec3f = get_wireframe(materialSID, 0);
  let wireframeWidthInner = wireframe.z;
  let wireframeWidthRelativeScale = 1.0;
  if (wireframe.x > 0.5 && wireframe.y < 0.5) {
    rt0.a = 0.0;
  }
  var wireframeResult = rt0;
  let wireframeColor = vec4f(0.2, 0.75, 0.0, 1.0);
  let edgeRatio: f32 = edge_ratio(input.baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);
  let edgeRatioModified: f32 = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);
  // if r0.a is 0.0, it is wireframe not on shaded
  wireframeResult = vec4f(wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified), wireframeResult.a);
  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));

  if (wireframe.x > 0.5) {
    rt0 = wireframeResult;
    if (wireframe.y < 0.5 && rt0.a == 0.0) {
      discard;
    }
  }

  let makeOutputSrgb = get_makeOutputSrgb(materialSID, 0);
  rt0 = vec4f(select(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb), rt0.w);

  return rt0;
}
`,shaderStage:"fragment",isFragmentShader:!0}});function HW(m){return de({typeList:XW,index:m})}var $s,ba,$2,e3,t3,n3,o3,r3,i3,XW,yn,Jh=C(()=>{"use strict";st();ba=($s=class extends fe{constructor({index:t,str:o,webgpu:r}){super({index:t,str:o});f(this,"__webgpu");this.__webgpu=r}get webgpu(){if(this.__webgpu===void 0)throw new Error(`does not support ${this.str}`);return this.__webgpu}},h($s,"BlendClass"),$s),$2=new ba({index:32774,str:"Equation_FUNC_ADD",webgpu:"add"}),e3=new ba({index:0,str:"ZERO",webgpu:"zero"}),t3=new ba({index:1,str:"ONE",webgpu:"one"}),n3=new ba({index:770,str:"SRC_ALPHA",webgpu:"src-alpha"}),o3=new ba({index:771,str:"ONE_MINUS_SRC_ALPHA",webgpu:"one-minus-src-alpha"}),r3=new ba({index:32775,str:"Equation_FUNC_MIN",webgpu:"min"}),i3=new ba({index:32776,str:"Equation_FUNC_MAX",webgpu:"max"}),XW=[$2,e3,t3,n3,o3,r3,i3];h(HW,"from");yn=Object.freeze({EquationFuncAdd:$2,Zero:e3,One:t3,SrcAlpha:n3,OneMinusSrcAlpha:o3,Min:r3,Max:i3,from:HW})});var Ae,Pc,$h=C(()=>{"use strict";Go();ni();$t();ft();St();xe();se();tt();Tn();So();Zt();ye();It();Ao();X2();q2();Y2();Z2();jl();Pn();Jh();mo();Ze();un();it();fo();sr();Ae=class Ae extends He{constructor(t,o,r,i,a,s,l,c,u,_,d){var x,v,y;super(d,{isMorphing:a,isSkinning:s,isLighting:l});f(this,"__OutlineWidthModeIsScreen",!1);f(this,"__floatProperties",{});f(this,"__vectorProperties",{});f(this,"__textureProperties",{});let p=this.doShaderReflection(H2,j2,K2,J2);switch(Ae.__diffuseIblCubeMapSampler.created||Ae.__diffuseIblCubeMapSampler.create(),Ae.__specularIblCubeMapSampler.created||Ae.__specularIblCubeMapSampler.create(),o!=null?(this.__floatProperties=o.floatProperties,this.__vectorProperties=o.vectorProperties,this.__textureProperties=JSON.parse(JSON.stringify(o.textureProperties))):(this.__floatProperties._BlendMode=0,this.__floatProperties._BumpScale=1,this.__floatProperties._CullMode=2,this.__floatProperties._Cutoff=.5,this.__floatProperties._DebugMode=0,this.__floatProperties._DstBlend=0,this.__floatProperties._IndirectLightIntensity=.1,this.__floatProperties._LightColorAttenuation=0,this.__floatProperties._OutlineColorMode=0,this.__floatProperties._OutlineCullMode=1,this.__floatProperties._OutlineLightingMix=1,this.__floatProperties._OutlineScaledMaxDistance=1,this.__floatProperties._OutlineWidth=.5,this.__floatProperties._OutlineWidthMode=0,this.__floatProperties._ReceiveShadowRate=1,this.__floatProperties._RimFresnelPower=1,this.__floatProperties._RimLift=0,this.__floatProperties._RimLightingMix=0,this.__floatProperties._ShadeShift=0,this.__floatProperties._ShadeToony=.9,this.__floatProperties._ShadingGradeRate=1,this.__floatProperties._SrcBlend=1,this.__floatProperties._ZWrite=1,this.__floatProperties._UvAnimScrollX=0,this.__floatProperties._UvAnimScrollY=0,this.__floatProperties._UvAnimRotation=0,this.__vectorProperties._Color=[1,1,1,1],this.__vectorProperties._EmissionColor=[0,0,0],this.__vectorProperties._OutlineColor=[0,0,0,1],this.__vectorProperties._ShadeColor=[.97,.81,.86,1],this.__vectorProperties._RimColor=[0,0,0]),u&&(this.__floatProperties._DebugMode=u),p.push({semantic:"cutoff",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(this.__floatProperties._Cutoff),min:0,max:1},{semantic:"litColor",componentType:I.Float,compositionType:b.Vec4,stage:D.PixelShader,initialValue:q.fromCopyArray(this.__vectorProperties._Color),min:0,max:1},{semantic:"shadeColor",componentType:I.Float,compositionType:b.Vec3,stage:D.PixelShader,initialValue:S.fromCopyArray(this.__vectorProperties._ShadeColor),min:0,max:1},{semantic:"bumpScale",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(this.__floatProperties._BumpScale),min:0,max:1},{semantic:"receiveShadowRate",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(this.__floatProperties._ReceiveShadowRate),min:0,max:1},{semantic:"shadingGradeRate",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(this.__floatProperties._ShadingGradeRate),min:0,max:1},{semantic:"shadeShift",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(this.__floatProperties._ShadeShift),min:0,max:1},{semantic:"shadeToony",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(this.__floatProperties._ShadeToony),min:0,max:1},{semantic:"lightColorAttenuation",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(this.__floatProperties._LightColorAttenuation),min:0,max:1},{semantic:"indirectLightIntensity",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(this.__floatProperties._IndirectLightIntensity),min:0,max:1},{semantic:"rimColor",componentType:I.Float,compositionType:b.Vec3,stage:D.PixelShader,initialValue:S.fromCopyArray(this.__vectorProperties._RimColor),min:0,max:1},{semantic:"rimLightingMix",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(this.__floatProperties._RimLightingMix),min:0,max:1},{semantic:"rimFresnelPower",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(this.__floatProperties._RimFresnelPower),min:0,max:1},{semantic:"rimLift",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(this.__floatProperties._RimLift),min:0,max:1},{semantic:"cameraUp",componentType:I.Float,compositionType:b.Vec3,stage:D.PixelShader,soloDatum:!0,initialValue:S.fromCopyArray([0,1,0]),min:0,max:1},{semantic:"emissionColor",componentType:I.Float,compositionType:b.Vec3,stage:D.PixelShader,initialValue:S.fromCopyArray(this.__vectorProperties._EmissionColor),min:0,max:1},{semantic:"uvAnimationScrollXSpeedFactor",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,isInternalSetting:!1,initialValue:te.fromCopyNumber((x=this.__floatProperties._UvAnimScrollX)!=null?x:0),min:0,max:1},{semantic:"uvAnimationScrollYSpeedFactor",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,isInternalSetting:!1,initialValue:te.fromCopyNumber((v=this.__floatProperties._UvAnimScrollY)!=null?v:0),min:0,max:1},{semantic:"uvAnimationRotationSpeedFactor",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,isInternalSetting:!1,initialValue:te.fromCopyNumber((y=this.__floatProperties._UvAnimRotation)!=null?y:0),min:0,max:1},{semantic:"wireframe",componentType:I.Float,compositionType:b.Vec3,stage:D.PixelShader,initialValue:S.fromCopyArray([0,0,1]),min:0,max:10},{semantic:"makeOutputSrgb",compositionType:b.Scalar,componentType:I.Bool,stage:D.PixelShader,min:0,max:1,initialValue:te.fromCopyNumber(_?1:0)}),this.__floatProperties._DebugMode){case 1:this.__definitions+=`#define RN_MTOON_DEBUG_NORMAL
`;break;case 2:this.__definitions+=`#define RN_MTOON_DEBUG_LITSHADERATE
`;break}if(t){switch(this.__definitions+=`#define RN_MTOON_IS_OUTLINE
`,this.__floatProperties._OutlineWidthMode){case 0:this.__definitions+=`#define RN_MTOON_OUTLINE_NONE
`;break;case 1:this.__definitions+=`#define RN_MTOON_OUTLINE_WIDTH_WORLD
`;break;case 2:this.__definitions+=`#define RN_MTOON_OUTLINE_WIDTH_SCREEN
`,this.__OutlineWidthModeIsScreen=!0;break}switch(this.__floatProperties._OutlineColorMode){case 0:this.__definitions+=`#define RN_MTOON_OUTLINE_COLOR_FIXED
`;break;case 1:this.__definitions+=`#define RN_MTOON_OUTLINE_COLOR_MIXED
`;break}p.push({semantic:"outlineWidth",componentType:I.Float,compositionType:b.Scalar,stage:D.VertexShader,initialValue:te.fromCopyNumber(this.__floatProperties._OutlineWidth),min:0,max:1},{semantic:"outlineScaledMaxDistance",componentType:I.Float,compositionType:b.Scalar,stage:D.VertexShader,initialValue:te.fromCopyNumber(this.__floatProperties._OutlineScaledMaxDistance),min:0,max:1},{semantic:"outlineColor",componentType:I.Float,compositionType:b.Vec3,stage:D.PixelShader,initialValue:S.fromCopyArray(this.__vectorProperties._OutlineColor),min:0,max:1},{semantic:"outlineLightingMix",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(this.__floatProperties._OutlineLightingMix),min:0,max:1},{semantic:"aspect",componentType:I.Float,compositionType:b.Scalar,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:te.fromCopyNumber(1),min:0,max:1})}l&&(this.__definitions+=`#define RN_IS_LIGHTING
`),s&&(this.__definitions+=`#define RN_IS_SKINNING
`),a&&(this.__definitions+=`#define RN_IS_MORPHING
`,p.push({semantic:"dataTextureMorphOffsetPosition",componentType:I.Int,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,initialValue:new ve(new Int32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:I.Float,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,initialValue:new ve(new Float32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0})),c&&(this.__definitions+=`#define RN_USE_TANGENT_ATTRIBUTE
`),this.__textureProperties._BumpMap>=0&&(this.__definitions+=`#define RN_MTOON_HAS_BUMPMAP
`),this.__textureProperties._OutlineWidthTexture>=0&&(this.__definitions+=`#define RN_MTOON_HAS_OUTLINE_WIDTH_TEXTURE
`),r=[ct,rn],this.__textureProperties._BumpMap=0,this.__textureProperties._EmissionMap=1,this.__textureProperties._MainTex=0,this.__textureProperties._OutlineWidthTexture=0,this.__textureProperties._UvAnimMaskTexture=0,this.__textureProperties._ReceiveShadowTexture=0,this.__textureProperties._RimTexture=1,this.__textureProperties._ShadeTexture=0,this.__textureProperties._ShadingGradeTexture=0,this.__textureProperties._SphereAdd=1,this.__setDummyTextures(r,i,p,t),this.setShaderSemanticsInfoArray(p)}__setDummyTextures(t,o,r,i){r.push({semantic:"litColorTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[0,t[this.__textureProperties._MainTex],o[this.__textureProperties._MainTex]],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"shadeColorTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[1,t[this.__textureProperties._ShadeTexture],o[this.__textureProperties._ShadeTexture]],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"receiveShadowTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[2,t[this.__textureProperties._ReceiveShadowTexture],o[this.__textureProperties._ReceiveShadowTexture]],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"shadingGradeTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[3,t[this.__textureProperties._ShadingGradeTexture],o[this.__textureProperties._ShadingGradeTexture]],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"rimTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[4,t[this.__textureProperties._RimTexture],o[this.__textureProperties._RimTexture]],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"matCapTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[8,t[this.__textureProperties._SphereAdd],o[this.__textureProperties._SphereAdd]],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"emissionTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[9,t[this.__textureProperties._EmissionMap],o[this.__textureProperties._EmissionMap]],min:0,max:Number.MAX_SAFE_INTEGER}),r.push({semantic:"normalTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[10,t[this.__textureProperties._BumpMap],o[this.__textureProperties._BumpMap]],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"uvAnimationMaskTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[11,t[this.__textureProperties._UvAnimMaskTexture],o[this.__textureProperties._UvAnimMaskTexture]],min:0,max:Number.MAX_SAFE_INTEGER}),i&&r.push({semantic:"outlineWidthTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.VertexShader,initialValue:[12,t[this.__textureProperties._OutlineWidthTexture],o[this.__textureProperties._OutlineWidthTexture]],min:0,max:Number.MAX_SAFE_INTEGER})}setMaterialParameters(t,o){if(Ae.usableBlendEquationModeAlpha==null&&Ae.__initializeUsableBlendEquationModeAlpha(),this.__floatProperties._BlendMode!==0){switch(this.__floatProperties._BlendMode){case 1:this.__definitions+=`#define RN_ALPHATEST_ON
`,t.alphaMode=Tt.Mask;break;case 2:this.__definitions+=`#define RN_ALPHABLEND_ON
`,t.alphaMode=Tt.Blend;break;case 3:this.__definitions+=`#define RN_ALPHABLEND_ON
`,t.alphaMode=Tt.Blend;break}let r=32774,i=Ae.usableBlendEquationModeAlpha,a=Ae.unityBlendEnumCorrespondence(this.__floatProperties._SrcBlend),s=Ae.unityBlendEnumCorrespondence(this.__floatProperties._DstBlend);t.setBlendEquationMode(yn.from(r),i!=null?yn.from(i):void 0),t.setBlendFuncFactor(yn.from(a),yn.from(s))}if(o)switch(this.__floatProperties._OutlineCullMode){case 0:t.cullFace=!1;break;case 1:t.cullFace=!0,t.cullFaceBack=!1;break;case 2:t.cullFace=!0,t.cullFaceBack=!0;break}else switch(this.__floatProperties._CullMode){case 0:t.cullFace=!1;break;case 1:t.cullFace=!0,t.cullFaceBack=!1;break;case 2:t.cullFace=!0,t.cullFaceBack=!0;break}t.zWriteWhenBlend=this.__floatProperties._ZWrite===1}static __initializeUsableBlendEquationModeAlpha(){if(K.currentProcessApproach===Z.WebGPU)Ae.usableBlendEquationModeAlpha=32776;else{let o=G.getWebGLResourceRepository().currentWebGLContextWrapper,r=o.getRawContextAsWebGL2();o.isWebGL2?Ae.usableBlendEquationModeAlpha=r.MAX:o.webgl1ExtBM?Ae.usableBlendEquationModeAlpha=o.webgl1ExtBM.MAX_EXT:Ae.usableBlendEquationModeAlpha=r.FUNC_ADD}}_setInternalSettingParametersToGpuWebGpu({material:t,args:o}){let r=J.getComponentFromComponentTID(Q.CameraComponentTID,o.cameraComponentSid);t.setParameter("cameraUp",r.upInner),this.__OutlineWidthModeIsScreen&&t.setParameter("aspect",r.aspect);let{mipmapLevelNumber:i,meshRenderComponent:a,diffuseHdriType:s,specularHdriType:l}=Ae.__setupHdriParameters(o),c=He.__tmp_vector4;c.x=i,c.y=a.diffuseCubeMapContribution,c.z=a.specularCubeMapContribution,c.w=a.rotationOfCubeMap,t.setParameter("iblParameter",c);let u=He.__tmp_vector2;u.x=s,u.y=l,t.setParameter("hdriFormat",u);let _=o.entity.tryToGetMeshRenderer();if(_!=null&&_.diffuseCubeMap!=null&&_.specularCubeMap!=null){let d=pe.zero(),p=pt.zero();d.x=_.specularCubeMap.mipmapLevelNumber,d.y=_.diffuseCubeMapContribution,d.z=_.specularCubeMapContribution,d.w=_.rotationOfCubeMap,t.setParameter("iblParameter",d),p.x=_.diffuseCubeMap.hdriFormat.index,p.y=_.specularCubeMap.hdriFormat.index,t.setParameter("hdriFormat",p)}}_setInternalSettingParametersToGpuWebGL({material:t,shaderProgram:o,firstTime:r,args:i}){let a=i.renderPass.cameraComponent;if(a==null&&(a=J.getComponent(re,re.current)),i.setUniform){this.setWorldMatrix(o,i.worldMatrix),this.setNormalMatrix(o,i.normalMatrix),this.setViewInfo(o,a,i.isVr,i.displayIdx),this.setProjection(o,a,i.isVr,i.displayIdx);let c=i.entity.tryToGetSkeletal();this.setSkinning(o,i.setUniform,c),this.setLightsInfo(o,i.lightComponents,t,i.setUniform),o._gl.uniform3fv(o.cameraUp,a.upInner._v),this.__OutlineWidthModeIsScreen&&o._gl.uniform1f(o.aspect,a.aspect)}else t.setParameter("cameraUp",a.upInner),this.__OutlineWidthModeIsScreen&&t.setParameter("aspect",a.aspect);let s=G.getWebGLResourceRepository();if(i.diffuseCube&&i.diffuseCube.isTextureReady?s.setUniform1iForTexture(o,Xe.DiffuseEnvTexture.str,[5,i.diffuseCube,Ae.__diffuseIblCubeMapSampler]):s.setUniform1iForTexture(o,Xe.DiffuseEnvTexture.str,[5,qt]),i.specularCube&&i.specularCube.isTextureReady?s.setUniform1iForTexture(o,Xe.SpecularEnvTexture.str,[6,i.specularCube,Ae.__specularIblCubeMapSampler]):s.setUniform1iForTexture(o,Xe.SpecularEnvTexture.str,[6,qt]),i.setUniform){if(r){let{mipmapLevelNumber:c,meshRenderComponent:u,diffuseHdriType:_,specularHdriType:d}=Ae.__setupHdriParameters(i);s.setUniformValue(o,Xe.IBLParameter.str,r,{x:c,y:u.diffuseCubeMapContribution,z:u.specularCubeMapContribution,w:u.rotationOfCubeMap}),s.setUniformValue(o,Xe.HDRIFormat.str,r,{x:_,y:d})}}else{let{mipmapLevelNumber:c,meshRenderComponent:u,diffuseHdriType:_,specularHdriType:d}=Ae.__setupHdriParameters(i),p=He.__tmp_vector4;p.x=c,p.y=u.diffuseCubeMapContribution,p.z=u.specularCubeMapContribution,p.w=u.rotationOfCubeMap,t.setParameter("iblParameter",p);let x=He.__tmp_vector2;x.x=_,x.y=d,t.setParameter("hdriFormat",x)}let l=i.entity.tryToGetBlendShape();this.setMorphInfo(o,i.entity.getMesh(),i.primitive,l)}static unityBlendEnumCorrespondence(t){let o=0;switch(t){case 0:o=0;break;case 1:o=1;break;case 2:o=774;break;case 3:o=768;break;case 4:o=775;break;case 5:o=770;break;case 6:o=769;break;case 7:o=772;break;case 8:o=773;break;case 9:o=776;break;case 10:o=771;break}return o}static __setupHdriParameters(t){let o=1;t.specularCube&&(o=t.specularCube.mipmapLevelNumber);let r=t.entity.getMeshRenderer(),i=wt.LDR_SRGB.index,a=wt.LDR_SRGB.index;return r.diffuseCubeMap&&(i=r.diffuseCubeMap.hdriFormat.index),r.specularCubeMap&&(a=r.specularCubeMap.hdriFormat.index),{mipmapLevelNumber:o,meshRenderComponent:r,diffuseHdriType:i,specularHdriType:a}}};h(Ae,"MToon0xMaterialContent"),f(Ae,"__diffuseIblCubeMapSampler",new Ge({minFilter:U.Linear,magFilter:U.Linear,wrapS:U.ClampToEdge,wrapT:U.ClampToEdge,wrapR:U.ClampToEdge})),f(Ae,"__specularIblCubeMapSampler",new Ge({minFilter:U.LinearMipmapLinear,magFilter:U.Linear,wrapS:U.ClampToEdge,wrapT:U.ClampToEdge,wrapR:U.ClampToEdge})),f(Ae,"_Cutoff",new B({str:"cutoff"})),f(Ae,"_Color",new B({str:"litColor"})),f(Ae,"_ShadeColor",new B({str:"shadeColor"})),f(Ae,"_litColorTexture",new B({str:"litColorTexture"})),f(Ae,"_shadeColorTexture",new B({str:"shadeColorTexture"})),f(Ae,"_BumpScale",new B({str:"normalScale"})),f(Ae,"_normalTexture",new B({str:"normalTexture"})),f(Ae,"_ReceiveShadowRate",new B({str:"receiveShadowRate"})),f(Ae,"_receiveShadowTexture",new B({str:"receiveShadowTexture"})),f(Ae,"_ShadingGradeRate",new B({str:"shadingGradeRate"})),f(Ae,"_shadingGradeTexture",new B({str:"shadingGradeTexture"})),f(Ae,"_ShadeShift",new B({str:"shadeShift"})),f(Ae,"_ShadeToony",new B({str:"shadeToony"})),f(Ae,"_LightColorAttenuation",new B({str:"lightColorAttenuation"})),f(Ae,"_AmbientColor",new B({str:"ambientColor"})),f(Ae,"_IndirectLightIntensity",new B({str:"indirectLightIntensity"})),f(Ae,"_rimTexture",new B({str:"rimTexture"})),f(Ae,"_RimColor",new B({str:"rimColor"})),f(Ae,"_RimLightingMix",new B({str:"rimLightingMix"})),f(Ae,"_RimFresnelPower",new B({str:"rimFresnelPower"})),f(Ae,"_RimLift",new B({str:"rimLift"})),f(Ae,"_matCapTexture",new B({str:"matCapTexture"})),f(Ae,"_EmissionColor",new B({str:"emissionColor"})),f(Ae,"_emissionTexture",new B({str:"emissionTexture"})),f(Ae,"_OutlineWidthTexture",new B({str:"outlineWidthTexture"})),f(Ae,"_OutlineWidth",new B({str:"outlineWidth"})),f(Ae,"_OutlineScaledMaxDistance",new B({str:"outlineScaledMaxDistance"})),f(Ae,"_OutlineColor",new B({str:"outlineColor"})),f(Ae,"_OutlineLightingMix",new B({str:"outlineLightingMix"})),f(Ae,"Aspect",new B({str:"aspect"})),f(Ae,"CameraUp",new B({str:"cameraUp"})),f(Ae,"usableBlendEquationModeAlpha");Pc=Ae});var no,bn,ep=C(()=>{"use strict";So();Go();St();$t();bi();Er();mo();fo();sr();ft();Pn();Vo();no=class no extends He{constructor({name:n,isMorphing:t,isSkinning:o,isLighting:r,vertexShader:i,pixelShader:a,additionalShaderSemanticInfo:s,vertexShaderWebGpu:l,pixelShaderWebGpu:c}){super(n,{isMorphing:t,isSkinning:o,isLighting:r});let u=this.doShaderReflection(i,a,l,c);no.__diffuseIblCubeMapSampler.created||no.__diffuseIblCubeMapSampler.create(),no.__specularIblCubeMapSampler.created||no.__specularIblCubeMapSampler.create(),this.setShaderSemanticsInfoArray(u.concat(s))}_setInternalSettingParametersToGpuWebGpu({material:n,args:t}){let{mipmapLevelNumber:o,meshRenderComponent:r,diffuseHdriType:i,specularHdriType:a}=no.__setupHdriParameters(t),s=He.__tmp_vector4;s.x=o,s.y=r.diffuseCubeMapContribution,s.z=r.specularCubeMapContribution,s.w=r.rotationOfCubeMap,n.setParameter("iblParameter",s);let l=He.__tmp_vector2;l.x=i,l.y=a,n.setParameter("hdriFormat",l);let c=t.entity.tryToGetMeshRenderer();if(c!=null&&c.diffuseCubeMap!=null&&c.specularCubeMap!=null){let u=pe.zero(),_=pt.zero();u.x=c.specularCubeMap.mipmapLevelNumber,u.y=c.diffuseCubeMapContribution,u.z=c.specularCubeMapContribution,u.w=c.rotationOfCubeMap,n.setParameter("iblParameter",u),_.x=c.diffuseCubeMap.hdriFormat.index,_.y=c.specularCubeMap.hdriFormat.index,n.setParameter("hdriFormat",_)}}_setInternalSettingParametersToGpuWebGL({material:n,shaderProgram:t,firstTime:o,args:r}){if(r.setUniform){if(this.setWorldMatrix(t,r.worldMatrix),this.setNormalMatrix(t,r.normalMatrix),this.setIsBillboard(t,r.isBillboard),o||r.isVr){let u=r.renderPass.cameraComponent;u==null&&(u=J.getComponent(re,re.current)),this.setViewInfo(t,u,r.isVr,r.displayIdx),this.setProjection(t,u,r.isVr,r.displayIdx)}this.setLightsInfo(t,r.lightComponents,n,r.setUniform);let c=r.entity.tryToGetSkeletal();this.setSkinning(t,r.setUniform,c)}let i=G.getWebGLResourceRepository(),a=n.getTextureParameter(Xe.DiffuseEnvTexture.str);if(a!=null){let c=a[0];r.diffuseCube&&r.diffuseCube.isTextureReady?i.setUniform1iForTexture(t,Xe.DiffuseEnvTexture.str,[c,r.diffuseCube,no.__diffuseIblCubeMapSampler]):i.setUniform1iForTexture(t,Xe.DiffuseEnvTexture.str,[c,qt])}let s=n.getTextureParameter(Xe.SpecularEnvTexture.str);if(s!=null){let c=s[0];r.specularCube&&r.specularCube.isTextureReady?i.setUniform1iForTexture(t,Xe.SpecularEnvTexture.str,[c,r.specularCube,no.__specularIblCubeMapSampler]):i.setUniform1iForTexture(t,Xe.SpecularEnvTexture.str,[c,qt])}let l=n.getTextureParameter(Xe.SheenEnvTexture.str);if(l!=null){let c=l[0];r.sheenCube&&r.sheenCube.isTextureReady?i.setUniform1iForTexture(t,Xe.SheenEnvTexture.str,[c,r.sheenCube,no.__specularIblCubeMapSampler]):r.specularCube&&r.specularCube.isTextureReady?i.setUniform1iForTexture(t,Xe.SheenEnvTexture.str,[c,r.specularCube,no.__specularIblCubeMapSampler]):i.setUniform1iForTexture(t,Xe.SheenEnvTexture.str,[c,qt])}if(r.setUniform){if(o){let{mipmapLevelNumber:c,meshRenderComponent:u,diffuseHdriType:_,specularHdriType:d}=no.__setupHdriParameters(r);i.setUniformValue(t,Xe.IBLParameter.str,o,{x:c,y:u.diffuseCubeMapContribution,z:u.specularCubeMapContribution,w:u.rotationOfCubeMap}),i.setUniformValue(t,Xe.HDRIFormat.str,o,{x:_,y:d})}}else{let{mipmapLevelNumber:c,meshRenderComponent:u,diffuseHdriType:_,specularHdriType:d}=no.__setupHdriParameters(r),p=He.__tmp_vector4;p.x=c,p.y=u.diffuseCubeMapContribution,p.z=u.specularCubeMapContribution,p.w=u.rotationOfCubeMap,n.setParameter("iblParameter",p);let x=He.__tmp_vector2;x.x=_,x.y=d,n.setParameter("hdriFormat",x)}}_setInternalSettingParametersToGpuWebGLPerPrimitive({material:n,shaderProgram:t,firstTime:o,args:r}){let i=r.entity.tryToGetBlendShape();this.setMorphInfo(t,r.entity.getMesh(),r.primitive,i)}static __setupHdriParameters(n){let t=1;n.specularCube&&(t=n.specularCube.mipmapLevelNumber);let o=n.entity.getMeshRenderer(),r=wt.LDR_SRGB.index,i=wt.LDR_SRGB.index;return o.diffuseCubeMap&&(r=o.diffuseCubeMap.hdriFormat.index),o.specularCubeMap&&(i=o.specularCubeMap.hdriFormat.index),{mipmapLevelNumber:t,meshRenderComponent:o,diffuseHdriType:r,specularHdriType:i}}};h(no,"CustomMaterialContent"),f(no,"__globalDataRepository",gt.getInstance()),f(no,"__diffuseIblCubeMapSampler",new Ge({minFilter:U.Linear,magFilter:U.Linear,wrapS:U.ClampToEdge,wrapT:U.ClampToEdge,wrapR:U.ClampToEdge})),f(no,"__specularIblCubeMapSampler",new Ge({minFilter:U.LinearMipmapLinear,magFilter:U.Linear,wrapS:U.ClampToEdge,wrapT:U.ClampToEdge,wrapR:U.ClampToEdge}));bn=no});var s3,a3=C(()=>{s3={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec4 a_instanceInfo;
in vec2 a_texcoord;
in vec3 a_position;
in vec3 a_color;
in vec3 a_normal;
in vec4 a_joint;
in vec4 a_weight;

out vec2 v_texcoord;
out vec3 v_normal_inWorld;
out vec4 v_position_inWorld;

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

mat3 toNormalMatrix(mat4 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];

  float b00 = a00 * a11 - a01 * a10,
  b01 = a00 * a12 - a02 * a10,
  b02 = a00 * a13 - a03 * a10,
  b03 = a01 * a12 - a02 * a11,
  b04 = a01 * a13 - a03 * a11,
  b05 = a02 * a13 - a03 * a12,
  b06 = a20 * a31 - a21 * a30,
  b07 = a20 * a32 - a22 * a30,
  b08 = a20 * a33 - a23 * a30,
  b09 = a21 * a32 - a22 * a31,
  b10 = a21 * a33 - a23 * a31,
  b11 = a22 * a33 - a23 * a32;

  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3(
    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,
    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,
    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;
}



#ifdef RN_IS_SKINNING

highp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {
  highp vec4 q = quaternion;
  highp vec3 t = translation;

  highp float sx = q.x * q.x;
  highp float sy = q.y * q.y;
  highp float sz = q.z * q.z;
  highp float cx = q.y * q.z;
  highp float cy = q.x * q.z;
  highp float cz = q.x * q.y;
  highp float wx = q.w * q.x;
  highp float wy = q.w * q.y;
  highp float wz = q.w * q.z;

  highp mat4 mat = mat4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  highp mat4 uniformScaleMat = mat4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return mat*uniformScaleMat;
}

highp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){

  highp float r;
  highp float g;
  highp float b;
  highp float a;

  highp float ix = floor(vec_xy.x * criteria);
  highp float v1x = ix / criteria;
  highp float v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  highp float iy = floor( vec_xy.y * criteria);
  highp float v2x = iy / criteria;
  highp float v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4(r, g, b, a);
}

mat4 getSkinMatrix(float skeletalComponentSID) {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));
  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));
  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));
  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  vec2 criteria = vec2(4096.0, 4096.0);

  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));
  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));
  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));
  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));
  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));
  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));
  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));

  vec2 criteria = vec2(4096.0, 4096.0);
  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif



#ifdef RN_IS_SKINNING
bool skinning(
  float skeletalComponentSID,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
  )
{
  mat4 skinMat = getSkinMatrix(skeletalComponentSID);
  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);
  outNormalMatrix = toNormalMatrix(skinMat);
  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);

  return true;
}
#endif

bool processGeometryWithMorphingAndSkinning(
  float skeletalComponentSID,
  in mat4 worldMatrix,
  in mat4 viewMatrix,
  in bool isBillboard,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
) {
  bool isSkinning = false;

  vec3 position_inLocal;
#ifdef RN_IS_MORPHING
  if (u_morphTargetNumber == 0) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    float vertexIdx = a_baryCentricCoord.w;
    position_inLocal = get_position(vertexIdx, inPosition_inLocal);
  }
#endif

  mat4 worldMatrixInner = worldMatrix;
  if (isBillboard) {
    mat4 inverseViewMatrix = inverse(viewMatrix);
    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];
    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];
    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];
    worldMatrixInner = inverseViewMatrix * worldMatrix;
  }

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0.0) {
    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);
  } else {
#endif
    outNormalMatrix = inNormalMatrix;
    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
#ifdef RN_IS_SKINNING
  }
#endif

  return isSkinning;
}


void main(){
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
gl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4(a_position, 1.0);


  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);
  v_normal_inWorld = normalMatrix * a_normal;
  v_position_inWorld = worldMatrix * vec4(a_position, 1.0);
  v_texcoord = a_texcoord;

}
`,shaderStage:"vertex",isFragmentShader:!1}});var c3,l3=C(()=>{c3={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec2 v_texcoord;
in vec3 v_normal_inWorld;
in vec4 v_position_inWorld;

/* shaderity: @{renderTargetBegin} */



/* shaderity: @{getters} */

#define MATH_PI 3.141592

// These codes are referenced from https://github.com/knarkowicz/FurnaceTest
float roughnessRemap(float userRoughness) {
  return userRoughness * userRoughness;
}

// GGX NDF
float d_ggx(float userRoughness, float NH) {
  float alphaRoughness = userRoughness * userRoughness;
  float roughnessSqr = alphaRoughness * alphaRoughness;
  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (MATH_PI * f * f);
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec2 envBRDFApprox( float Roughness, float NoV ) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022 );
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );
  vec4 r = Roughness * c0 + c1;
  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}

float specularIBL(float userRoughness, float NV, float f0) {
  /// Use specular BRDF LUT
  // vec3 brdf = texture(u_brdfLutTexture, vec2(NV, 1.0 - userRoughness)).rgb;
  // float specular = 1.0 * (f0 * brdf.x + brdf.y);

  /// Use specular BRDF Approx
  vec2 f_ab = envBRDFApprox(userRoughness, NV);
  vec3 specular = vec3(f0) * f_ab.x + f_ab.y;
  return specular.x;
}

// The Schlick Approximation to Fresnel
float fresnel(float f0, float VH) {
  return f0 + (1.0 - f0) * pow(1.0 - VH, 5.0);
}

float smithG1(float roughness, float NoV)
{
	float a = roughnessRemap( roughness );
	float a2 = a * a;
	float NoV2 = NoV * NoV;
	float lambda = (-1.0 + sqrt(1.0 + a2 * (1.0 - NoV2) / NoV2)) * 0.5;
	return 1.0 / (1.0 + lambda);
}

float smithG(float roughness, float NoV, float NoL)
{
	float a = roughnessRemap( roughness );
	float a2 = a * a;
	float NoV2 = NoV * NoV;
	float NoL2 = NoL * NoL;
	float lambdaV = (-1.0 + sqrt(1.0 + a2 * (1.0 - NoV2) / NoV2)) * 0.5;
	float lambdaL = (-1.0 + sqrt(1.0 + a2 * (1.0 - NoL2) / NoL2)) * 0.5;
	return 1.0 / (1.0 + lambdaV + lambdaL);
}

float g_shieldingForWeak(float alphaRoughness, float NV, float NL) {
  float r = alphaRoughness;

  // Local Masking using "Schlick-Smith" Masking Function
  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));

  return localMasking;
}


float g_shielding(float roughness, float NV, float NL) {
  float a = roughnessRemap( roughness );
  float r = a;

  // Local Shadowing using "Schlick-Smith" Masking Function
  float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));

  // Local Masking using "Schlick-Smith" Masking Function
  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));

  return localShadowing * localMasking;
}

float v_GGXCorrelatedForWeak(float roughness, float NV, float NL) {
  float a = roughnessRemap( roughness );
  float a2 = a * a;
  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  return 0.5 / (GGXV);
}

float v_GGXCorrelated(float roughness, float NV, float NL) {
  float a = roughnessRemap( roughness );
  float a2 = a * a;
  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  float GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  return 0.5 / (GGXV + GGXL);
}

// this is from https://learnopengl.com/PBR/IBL/Specular-IBL
float vanDerCorpus(int n, int base)
{
    float invBase = 1.0 / float(base);
    float denom   = 1.0;
    float result  = 0.0;

    for(int i = 0; i < 32; ++i)
    {
        if(n > 0)
        {
            denom   = mod(float(n), 2.0);
            result += denom * invBase;
            invBase = invBase / 2.0;
            n       = int(float(n) / 2.0);
        }
    }

    return result;
}

vec2 hammersleyNoBitOps(int i, int N)
{
  return vec2(float(i)/float(N), vanDerCorpus(i, 2));
}

float radicalInverse_VdC(uint bits)
{
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}
// ----------------------------------------------------------------------------
vec2 hammersley(uint i, uint N)
{
    return vec2(float(i)/float(N), radicalInverse_VdC(i));
}

vec3 sampleHemisphereGGX(vec2 Xi, float roughness) {
  float a = roughnessRemap(roughness);
	float a2 = a * a;

  float phi = 2.0 * MATH_PI * Xi.x;
  float cosPhi = cos(phi);
  float sinPhi = sin(phi);
  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y)); // GGX
  float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

  return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
}

float weakWhiteFurnaceTest(float roughness, float NoV, float f0, int g_type, int disable_fresnel)
{
	float vx = sqrt(1.0 - NoV * NoV);
	float vy = 0.0;
	float vz = NoV;

	float integral = 0.0;
	const uint sampleNum = 2048u;
	for (uint i = 0u; i < sampleNum; ++i)
	{
    vec2 Xi = hammersley(i, sampleNum);

    vec3 hvec = sampleHemisphereGGX(Xi, roughness);

		float VoHUnsat = vx * hvec.x + vy * hvec.y + vz * hvec.z;

    float lz = 2.0 * VoHUnsat * hvec.z - vz;

    float NoL = max(lz, 0.0);
		float NoH = max(hvec.z, 0.0);
		float VoH = max(VoHUnsat, 0.0);

    float f = fresnel(f0, VoH);

    float g1 = 0.0;
    if (g_type == 0) {
      g1 = smithG1(roughness, NoV);
    } else if (g_type == 1) {
      g1 = g_shieldingForWeak(roughness, NoV, NoL);
    } else if (g_type == 2) {
      g1 = v_GGXCorrelatedForWeak(roughness, NoV, NoL) * 4.0 * NoV * NoL;
    }

    float pdf = 4.0 * VoH / NoH;
    float integralValue = (g1 * pdf) / (4.0 * NoV);
    if (disable_fresnel == 0) {
      integralValue *= f;
    }
    // integralValue *= 0.5; // Set furnace color 0.5

    integral += integralValue;

	}
	integral /= float(sampleNum);
	return clamp(integral, 0.0, 1.0);
}

float whiteFurnaceTest(float roughness, float NoV, float f0, int g_type, int disable_fresnel)
{
	float vx = sqrt(1.0 - NoV * NoV);
	float vy = 0.0;
	float vz = NoV;

	float integral = 0.0;
	const uint sampleNum = 4096u;
	for (uint i = 0u; i < sampleNum; ++i)
	{

    vec2 Xi = hammersley(i, sampleNum);

    vec3 hvec = sampleHemisphereGGX(Xi, roughness);

		float VoHUnsat = vx * hvec.x + vy * hvec.y + vz * hvec.z;
		float lx = 2.0 * VoHUnsat * hvec.x - vx;
		float ly = 2.0 * VoHUnsat * hvec.y - vy;
		float lz = 2.0 * VoHUnsat * hvec.z - vz;

		float NoL = max(lz, 0.0);
		float NoH = max(hvec.z, 0.0);
    float VoH = max(VoHUnsat, 0.0);

    float f = fresnel(f0, VoH);

    float g = 0.0;
    if (g_type == 0) {
      g = smithG(roughness, NoV, NoL);
    } else if (g_type == 1){
      g = g_shielding(roughness, NoV, NoL);
    } else if (g_type == 2){
      g = v_GGXCorrelated(roughness, NoV, NoL) * (4.0 * NoV * NoL);
    } else if (g_type == 3) {
      g = 0.0;
    }

    float pdf = 4.0 * VoH / NoH;
    float integralValue = (g * pdf) / (4.0 * NoV);
    if (disable_fresnel == 0 && g_type != 3) {
      integralValue *= f;
    }
    // integralValue *= 0.5; // Set furnace color 0.5
    integral += integralValue;
	}
  integral /= float(sampleNum);
  if (g_type == 3) {
    integral = specularIBL(roughness, NoV, f0);
  }
	return clamp(integral, 0.0, 1.0);
}

void main ()
{
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  vec2 quadSizeInPixel = get_screenInfo(materialSID, 0);
  float roughness = 0.0;
  float NoV = 0.0; // normal dot view vector

  // 2D mode
  int mode = get_mode(materialSID, 0);
  if (mode == 0) {
    roughness = (gl_FragCoord.y) / quadSizeInPixel.y;
    NoV = (gl_FragCoord.x) / quadSizeInPixel.x;
  } else {
    // object mode
    // Roughness
    const float c_MinRoughness = 0.04;
    vec2 metallicRoughnessFactor = get_metallicRoughnessFactor(materialSID, 0);
    float userRoughness = metallicRoughnessFactor.y;
    float metallic = metallicRoughnessFactor.x;

    vec4 ormTexel = texture(u_metallicRoughnessTexture, v_texcoord);
    userRoughness = ormTexel.g * userRoughness;
    userRoughness = clamp(userRoughness, c_MinRoughness, 1.0);
    roughness = userRoughness;

    // vec3 viewVector = normalize(vec3(0.0, 0.0, 10.0) - v_position_inWorld.xyz);
    // vec3 viewVector = normalize(u_viewPosition - v_position_inWorld.xyz);
    vec3 viewVector = vec3(0.0, 0.0, 1.0);
    NoV = dot(v_normal_inWorld, viewVector);
  }

  int debugView = get_debugView(materialSID, 0);
  float f0 = get_f0(materialSID, 0);
  int g_type = get_g_type(materialSID, 0);
  int disable_fresnel = get_disable_fresnel(materialSID, 0);

  if (debugView == 0) {
    float whiteFurnaceResult = whiteFurnaceTest(roughness, NoV, f0, g_type, disable_fresnel);
    rt0 = vec4(whiteFurnaceResult, whiteFurnaceResult, whiteFurnaceResult, 1.0);

  } else if (debugView == 1) {
    float weakWhiteFurnaceResult = weakWhiteFurnaceTest(roughness, NoV, f0, g_type, disable_fresnel);
    rt0 = vec4(weakWhiteFurnaceResult, weakWhiteFurnaceResult, weakWhiteFurnaceResult, 1.0);

  } else if (debugView == 2){
    float nn = NoV*0.5+0.5;
    rt0 = vec4(nn, nn, nn, 1.0);

  } else if (debugView == 3){
    rt0 = vec4(v_normal_inWorld.xyz, 1.0);

  } else if (debugView == 4){
    float whiteFurnaceResult = whiteFurnaceTest(roughness, NoV, f0, g_type, disable_fresnel);
    float weakWhiteFurnaceResult = weakWhiteFurnaceTest(roughness, NoV, f0, g_type, disable_fresnel);
    rt0 = vec4(whiteFurnaceResult, weakWhiteFurnaceResult, 0.0, 1.0);

  } else if (debugView == 5){
    rt0 = vec4(roughness, NoV, 0.0, 1.0);

  } else {
    rt0 = vec4(1.0, 1.0, 1.0, 1.0);
  }

/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var Mi,Mc,tp=C(()=>{"use strict";xe();se();Tn();So();Zt();Xo();Go();St();$t();a3();l3();mo();Mi=class Mi extends He{constructor(n){super(n,{},s3,c3);let t=[{semantic:"debugView",componentType:I.Int,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(0),min:0,max:1},{semantic:"disable_fresnel",componentType:I.Int,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(0),min:0,max:1},{semantic:"f0",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(1),min:0,max:1},{semantic:"g_type",componentType:I.Int,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(0),min:0,max:3},{semantic:"mode",componentType:I.Int,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(0),min:0,max:1},{semantic:"screenInfo",componentType:I.Float,compositionType:b.Vec2,stage:D.PixelShader,initialValue:Ee.fromCopyArray2([0,0]),min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"metallicRoughnessFactor",componentType:I.Float,compositionType:b.Vec2,stage:D.PixelShader,initialValue:Ee.fromCopyArray2([1,1]),min:0,max:2},{semantic:"metallicRoughnessTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[1,ct],min:0,max:Number.MAX_SAFE_INTEGER}];this.setShaderSemanticsInfoArray(t)}_setInternalSettingParametersToGpuWebGL({material:n,shaderProgram:t,firstTime:o,args:r}){if(r.setUniform&&(this.setWorldMatrix(t,r.worldMatrix),this.setNormalMatrix(t,r.normalMatrix),o)){let i=r.renderPass.cameraComponent;i==null&&(i=J.getComponent(re,re.current)),this.setViewInfo(t,i,r.isVr,r.displayIdx),this.setProjection(t,i,r.isVr,r.displayIdx),this.setLightsInfo(t,r.lightComponents,n,r.setUniform)}}};h(Mi,"FurnaceTestMaterialContent"),f(Mi,"mode",new B({str:"mode"})),f(Mi,"debugView",new B({str:"debugView"})),f(Mi,"g_type",new B({str:"g_type"})),f(Mi,"disable_fresnel",new B({str:"disable_fresnel"})),f(Mi,"f0",new B({str:"f0"}));Mc=Mi});var u3,f3=C(()=>{u3={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


in vec4 a_instanceInfo;
in vec3 a_position;
in vec2 a_texcoord_0;
out vec2 v_texcoord_0;

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

void main(){
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif

float x = float((gl_VertexID & 1) << 2);
float y = float((gl_VertexID & 2) << 1);
v_texcoord_0.x = x * 0.5;
v_texcoord_0.y = y * 0.5;
gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);

}
`,shaderStage:"vertex",isFragmentShader:!1}});var _3,m3=C(()=>{_3={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{renderTargetBegin} */


precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

in vec2 v_texcoord_0;

void main ()
{
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  vec4 baseColor = texture(u_baseColorTexture, v_texcoord_0);

  float luminance = dot(baseColor.rgb, vec3(0.2126, 0.7152, 0.0722));

  float luminanceCriterion = get_luminanceCriterion(materialSID, 0);

  baseColor.rgb = mix(vec3(0.0), baseColor.rgb, (luminance - luminanceCriterion) / luminanceCriterion);
  baseColor.a = 1.0;

  rt0 = baseColor;

/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var h3,d3=C(()=>{h3={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

@vertex
fn main(
  @builtin(vertex_index) vertexIdx : u32,
) -> VertexOutput {
  var output : VertexOutput;
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


let x = f32((vertexIdx & 1u) << 2u);
let y = f32((vertexIdx & 2u) << 1u);
output.texcoord_0.x = x * 0.5;
output.texcoord_0.y = y * 0.5;
output.texcoord_0.y = 1.0 - output.texcoord_0.y;
output.position = vec4f(x - 1.0, y - 1.0, 0, 1);


  return output;

}
`,shaderStage:"vertex",isFragmentShader:!1}});var x3,p3=C(()=>{x3={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */

@fragment
fn main (
  input: VertexOutput,
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  var baseColor = textureSampleLevel(baseColorTexture, baseColorSampler, input.texcoord_0, 0.0);

  let luminance = dot(baseColor.rgb, vec3f(0.2126, 0.7152, 0.0722));

  let luminanceCriterion: f32 = get_luminanceCriterion(materialSID, 0);
  baseColor = vec4f(mix(vec3f(0.0), baseColor.rgb, (luminance - luminanceCriterion) / luminanceCriterion), 1.0);

  return baseColor;
}
`,shaderStage:"fragment",isFragmentShader:!0}});var bm,Dc,np=C(()=>{"use strict";So();se();xe();Zt();St();$t();Tn();Go();f3();m3();d3();p3();Ze();Ke();Pn();un();bm=class bm extends He{constructor(n,t){super(n,{});let o=new Ge({wrapS:U.ClampToEdge,wrapT:U.ClampToEdge,minFilter:U.Linear,magFilter:U.Linear});o.create();let r=[{semantic:"luminanceCriterion",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(2),min:0,max:Number.MAX_VALUE},{semantic:"baseColorTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[0,t,o],min:0,max:Number.MAX_SAFE_INTEGER}];K.currentProcessApproach===Z.WebGPU?(this.setVertexShaderityObject(h3),this.setPixelShaderityObject(x3)):(this.setVertexShaderityObject(u3),this.setPixelShaderityObject(_3)),this.setShaderSemanticsInfoArray(r)}_setInternalSettingParametersToGpuWebGL({material:n,shaderProgram:t,firstTime:o,args:r}){if(r.setUniform){this.setWorldMatrix(t,r.worldMatrix);let i=r.renderPass.cameraComponent;i==null&&(i=J.getComponent(re,re.current)),i&&(this.setViewInfo(t,i,r.isVr,r.displayIdx),this.setProjection(t,i,r.isVr,r.displayIdx))}}};h(bm,"DetectHighLuminanceMaterialContent"),f(bm,"LuminanceCriterion",new B({str:"luminanceCriterion"}));Dc=bm});var g3,v3=C(()=>{g3={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


in vec4 a_instanceInfo;
in vec3 a_position;
in vec2 a_texcoord_0;
out vec2 v_texcoord_0;

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

void main(){
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif

float x = float((gl_VertexID & 1) << 2);
float y = float((gl_VertexID & 2) << 1);
v_texcoord_0.x = x * 0.5;
v_texcoord_0.y = y * 0.5;
gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);

}
`,shaderStage:"vertex",isFragmentShader:!1}});var b3,y3=C(()=>{b3={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{renderTargetBegin} */


precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

in vec2 v_texcoord_0;

float edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {
  vec3 d = fwidth(bary3);
  vec3 x = bary3 + vec3(1.0 - wireframeWidthInner) * d;
  vec3 a3 = smoothstep(vec3(0.0), d, x);
  float factor = min(min(a3.x, a3.y), a3.z);

  return clamp((1.0 - factor), 0.0, 1.0);
}

void main ()
{
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  float synthesizeCoefficient0 = u_synthesizeCoefficient[0];
  vec4 color = synthesizeCoefficient0 * texture(u_synthesizeTexture0, v_texcoord_0);

  float synthesizeCoefficient1 = u_synthesizeCoefficient[1];
  float synthesizeCoefficient2 = u_synthesizeCoefficient[2];
  float synthesizeCoefficient3 = u_synthesizeCoefficient[3];
  float synthesizeCoefficient4 = u_synthesizeCoefficient[4];
  float synthesizeCoefficient5 = u_synthesizeCoefficient[5];

  color += synthesizeCoefficient1 * texture(u_synthesizeTexture1, v_texcoord_0);
  color += synthesizeCoefficient2 * texture(u_synthesizeTexture2, v_texcoord_0);
  color += synthesizeCoefficient3 * texture(u_synthesizeTexture3, v_texcoord_0);
  color += synthesizeCoefficient4 * texture(u_synthesizeTexture4, v_texcoord_0);
  color += synthesizeCoefficient5 * texture(u_synthesizeTexture5, v_texcoord_0);

  rt0 = color;

/* shaderity: @{renderTargetEnd} */

}

`,shaderStage:"fragment",isFragmentShader:!0}});var I3,A3=C(()=>{I3={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

@vertex
fn main(
  @builtin(vertex_index) vertexIdx : u32,
) -> VertexOutput {
  var output : VertexOutput;
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


let x = f32((vertexIdx & 1u) << 2u);
let y = f32((vertexIdx & 2u) << 1u);
output.texcoord_0.x = x * 0.5;
output.texcoord_0.y = y * 0.5;
output.texcoord_0.y = 1.0 - output.texcoord_0.y;
output.position = vec4f(x - 1.0, y - 1.0, 0, 1);


  return output;

}
`,shaderStage:"vertex",isFragmentShader:!1}});var T3,S3=C(()=>{T3={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */

@fragment
fn main (
  input: VertexOutput,
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  let synthesizeCoefficient0 = get_synthesizeCoefficient(materialSID, 0);
  var color: vec4f = synthesizeCoefficient0 * textureSample(synthesizeTexture0, synthesizeSampler0, input.texcoord_0);

  let synthesizeCoefficient1 = get_synthesizeCoefficient(materialSID, 1);
  let synthesizeCoefficient2 = get_synthesizeCoefficient(materialSID, 2);
  let synthesizeCoefficient3 = get_synthesizeCoefficient(materialSID, 3);
  let synthesizeCoefficient4 = get_synthesizeCoefficient(materialSID, 4);
  let synthesizeCoefficient5 = get_synthesizeCoefficient(materialSID, 5);

  color += synthesizeCoefficient1 * textureSample(synthesizeTexture1, synthesizeSampler0, input.texcoord_0);
  color += synthesizeCoefficient2 * textureSample(synthesizeTexture2, synthesizeSampler0, input.texcoord_0);
  color += synthesizeCoefficient3 * textureSample(synthesizeTexture3, synthesizeSampler0, input.texcoord_0);
  color += synthesizeCoefficient4 * textureSample(synthesizeTexture4, synthesizeSampler0, input.texcoord_0);
  color += synthesizeCoefficient5 * textureSample(synthesizeTexture5, synthesizeSampler0, input.texcoord_0);

  return color;
}

`,shaderStage:"fragment",isFragmentShader:!0}});var Cr,Bc,op=C(()=>{"use strict";$t();St();xe();se();So();Zt();Go();Ao();v3();y3();A3();S3();mo();Pn();Vo();Ze();Ke();Cr=class Cr extends He{constructor(t,o){var a,s,l,c,u,_;super(t,{});f(this,"textureNumber");this.textureNumber=o.length;let r=new Ge({wrapS:U.ClampToEdge,wrapT:U.ClampToEdge,minFilter:U.Linear,magFilter:U.Linear});r.create();let i=[{semantic:"synthesizeCoefficient",componentType:I.Float,compositionType:b.ScalarArray,arrayLength:6,stage:D.PixelShader,initialValue:new ve(new Float32Array(6)),min:0,max:1,needUniformInDataTextureMode:!0},{semantic:"synthesizeTexture0",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[0,(a=o[0])!=null?a:Tr,r],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"synthesizeTexture1",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[1,(s=o[1])!=null?s:Tr,r],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"synthesizeTexture2",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[2,(l=o[2])!=null?l:Tr,r],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"synthesizeTexture3",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[3,(c=o[3])!=null?c:Tr,r],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"synthesizeTexture4",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[4,(u=o[4])!=null?u:Tr,r],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"synthesizeTexture5",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[5,(_=o[5])!=null?_:Tr,r],min:0,max:Number.MAX_SAFE_INTEGER}];K.currentProcessApproach===Z.WebGPU?(this.setVertexShaderityObject(I3),this.setPixelShaderityObject(T3)):(this.setVertexShaderityObject(g3),this.setPixelShaderityObject(b3)),this.setShaderSemanticsInfoArray(i)}_setInternalSettingParametersToGpuWebGL({material:t,shaderProgram:o,firstTime:r,args:i}){if(i.setUniform){this.setWorldMatrix(o,i.worldMatrix);let a=i.renderPass.cameraComponent;a==null&&(a=J.getComponent(re,re.current)),a&&(this.setViewInfo(o,a,i.isVr,i.displayIdx),this.setProjection(o,a,i.isVr,i.displayIdx))}o._gl.uniform1fv(o.synthesizeCoefficient,t.getParameter("synthesizeCoefficient")._v)}get synthesizeTextureNumber(){return this.textureNumber}};h(Cr,"SynthesizeHdrMaterialContent"),f(Cr,"SynthesizeCoefficient",new B({str:"synthesizeCoefficient"})),f(Cr,"TargetRegionTexture",new B({str:"targetRegionTexture"})),f(Cr,"SynthesizeTexture0",new B({str:"synthesizeTexture0"})),f(Cr,"SynthesizeTexture1",new B({str:"synthesizeTexture1"})),f(Cr,"SynthesizeTexture2",new B({str:"synthesizeTexture2"})),f(Cr,"SynthesizeTexture3",new B({str:"synthesizeTexture3"})),f(Cr,"SynthesizeTexture4",new B({str:"synthesizeTexture4"})),f(Cr,"SynthesizeTexture5",new B({str:"synthesizeTexture5"}));Bc=Cr});var C3,E3=C(()=>{C3={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


in vec4 a_instanceInfo;
in vec2 a_texcoord;
in vec3 a_position;

out vec2 v_texcoord;

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

void main(){
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
gl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4(a_position, 1.0);


  v_texcoord = a_texcoord;
}
`,shaderStage:"vertex",isFragmentShader:!1}});var R3,w3=C(()=>{R3={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


in vec2 v_texcoord;

/* shaderity: @{renderTargetBegin} */


precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

void main ()
{
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  vec4 textureColor = texture(u_baseColorTexture, v_texcoord);

  float r = textureColor.r;
  float g = textureColor.g;
  float b = textureColor.b;
  float r16 = r * 15.0;
  float g16 = g * 15.0;
  float b16 = b * 15.0;
  float rInt = floor(r16);
  float gInt = floor(g16);
  float bInt = floor(b16);

  float rRate, gRate, bRate;
  float rIntAdjust, gIntAdjust, bIntAdjust;

  vec3 newColor = vec3(0.0);
  for(int i=0; i<8; i++){
    rRate = 1.0 - fract(r16);
    gRate = 1.0 - fract(g16);
    bRate = 1.0 - fract(b16);
    rIntAdjust = rInt;
    gIntAdjust = gInt;
    bIntAdjust = bInt;

    if(fract(float(i) / 2.0) != 0.0){
      rIntAdjust += 1.0;
      rRate = 1.0 - rRate;
    }
    if(fract(float(i / 2) / 2.0) != 0.0){
      gIntAdjust += 1.0;
      gRate = 1.0 - gRate;
    }
    if(fract(float(i / 4) / 2.0) != 0.0){
      bIntAdjust += 1.0;
      bRate = 1.0 - bRate;
    }

    if( rRate * gRate * bRate != 0.0){
      newColor += texture(u_lookupTableTexture, vec2(rIntAdjust / 256.0 + bIntAdjust / 16.0  + 1.0 / 512.0, gIntAdjust / 16.0 + 1.0 / 32.0)).rgb * rRate * gRate * bRate;
    }
  }

  rt0 = vec4(newColor, 1.0);
/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var Am,Fc,rp=C(()=>{"use strict";Sr();$t();se();St();xe();So();Zt();Ni();Vo();Go();E3();w3();Pn();mo();me();Am=class Am extends He{constructor(n,t,o,r,i){super(n,{},C3,R3);let a,s=t.getFramebuffer();s!=null&&s.colorAttachments[o]!=null?a=s.colorAttachments[o]:(a=rn,s!=null?N.warn("renderPass does not have framebuffer.colorAttachments["+o+"]"):N.warn("renderPass does not have framebuffer"));let l;typeof r=="string"?(l=new Jt,async function(_){l.generateTextureFromUri(_,{type:I.UnsignedByte}),await l.loadFromUrlLazy()}(r)):i instanceof mn?l=i:(N.warn("no LUT texture is specified"),l=rn);let c=new Ge({minFilter:U.Nearest,magFilter:U.Nearest,wrapS:U.ClampToEdge,wrapT:U.ClampToEdge,anisotropy:!1});c.create();let u=[{semantic:"baseColorTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[0,a],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"lookupTableTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[1,l,c],min:0,max:Number.MAX_SAFE_INTEGER}];this.setShaderSemanticsInfoArray(u)}_setInternalSettingParametersToGpuWebGL({material:n,shaderProgram:t,firstTime:o,args:r}){r.setUniform&&this.setWorldMatrix(t,r.worldMatrix);let i=r.renderPass.cameraComponent;i==null&&(i=J.getComponent(re,re.current)),i&&(this.setViewInfo(t,i,r.isVr,r.displayIdx),this.setProjection(t,i,r.isVr,r.displayIdx))}};h(Am,"ColorGradingUsingLUTsMaterialContent"),f(Am,"lookupTableTexture",new B({str:"lookupTableTexture"}));Fc=Am});var P3,N3=C(()=>{P3={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec4 a_instanceInfo;
in vec3 a_baryCentricCoord;
in vec3 a_position;
in vec3 a_normal;
in vec4 a_joint;
in vec4 a_weight;

out vec3 v_baryCentricCoord;
out vec3 v_normal_inView;
out vec3 v_normal_inWorld;
out vec4 v_position_inWorld;

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

mat3 toNormalMatrix(mat4 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];

  float b00 = a00 * a11 - a01 * a10,
  b01 = a00 * a12 - a02 * a10,
  b02 = a00 * a13 - a03 * a10,
  b03 = a01 * a12 - a02 * a11,
  b04 = a01 * a13 - a03 * a11,
  b05 = a02 * a13 - a03 * a12,
  b06 = a20 * a31 - a21 * a30,
  b07 = a20 * a32 - a22 * a30,
  b08 = a20 * a33 - a23 * a30,
  b09 = a21 * a32 - a22 * a31,
  b10 = a21 * a33 - a23 * a31,
  b11 = a22 * a33 - a23 * a32;

  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3(
    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,
    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,
    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;
}



#ifdef RN_IS_SKINNING

highp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {
  highp vec4 q = quaternion;
  highp vec3 t = translation;

  highp float sx = q.x * q.x;
  highp float sy = q.y * q.y;
  highp float sz = q.z * q.z;
  highp float cx = q.y * q.z;
  highp float cy = q.x * q.z;
  highp float cz = q.x * q.y;
  highp float wx = q.w * q.x;
  highp float wy = q.w * q.y;
  highp float wz = q.w * q.z;

  highp mat4 mat = mat4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  highp mat4 uniformScaleMat = mat4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return mat*uniformScaleMat;
}

highp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){

  highp float r;
  highp float g;
  highp float b;
  highp float a;

  highp float ix = floor(vec_xy.x * criteria);
  highp float v1x = ix / criteria;
  highp float v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  highp float iy = floor( vec_xy.y * criteria);
  highp float v2x = iy / criteria;
  highp float v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4(r, g, b, a);
}

mat4 getSkinMatrix(float skeletalComponentSID) {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));
  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));
  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));
  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  vec2 criteria = vec2(4096.0, 4096.0);

  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));
  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));
  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));
  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));
  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));
  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));
  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));

  vec2 criteria = vec2(4096.0, 4096.0);
  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif



#ifdef RN_IS_SKINNING
bool skinning(
  float skeletalComponentSID,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
  )
{
  mat4 skinMat = getSkinMatrix(skeletalComponentSID);
  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);
  outNormalMatrix = toNormalMatrix(skinMat);
  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);

  return true;
}
#endif

bool processGeometryWithMorphingAndSkinning(
  float skeletalComponentSID,
  in mat4 worldMatrix,
  in mat4 viewMatrix,
  in bool isBillboard,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
) {
  bool isSkinning = false;

  vec3 position_inLocal;
#ifdef RN_IS_MORPHING
  if (u_morphTargetNumber == 0) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    float vertexIdx = a_baryCentricCoord.w;
    position_inLocal = get_position(vertexIdx, inPosition_inLocal);
  }
#endif

  mat4 worldMatrixInner = worldMatrix;
  if (isBillboard) {
    mat4 inverseViewMatrix = inverse(viewMatrix);
    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];
    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];
    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];
    worldMatrixInner = inverseViewMatrix * worldMatrix;
  }

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0.0) {
    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);
  } else {
#endif
    outNormalMatrix = inNormalMatrix;
    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
#ifdef RN_IS_SKINNING
  }
#endif

  return isSkinning;
}


void main(){
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);

  bool isSkinning = false;
  isSkinning = processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    worldMatrix,
    viewMatrix,
    false,
    normalMatrix,
    normalMatrix,
    a_position,
    v_position_inWorld,
    a_normal,
    v_normal_inWorld
  );

  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;

  v_normal_inView = vec3(viewMatrix * vec4(normalMatrix * a_normal, 0.0));

// #ifdef RN_IS_POINTSPRITE

vec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);
vec3 viewPosition = get_viewPosition(cameraSID, 0);
float distanceFromCamera = length(position_inWorld.xyz - viewPosition);
vec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);
float distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));
float maxPointSize = get_pointSize(materialSID, 0);
gl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);

// #endif


  v_baryCentricCoord = a_baryCentricCoord;

}
`,shaderStage:"vertex",isFragmentShader:!1}});var D3,M3=C(()=>{D3={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


in vec3 v_baryCentricCoord;
in vec3 v_normal_inView;

/* shaderity: @{renderTargetBegin} */


precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

float edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {
  vec3 d = fwidth(bary3);
  vec3 x = bary3+vec3(1.0 - wireframeWidthInner)*d;
  vec3 a3 = smoothstep(vec3(0.0), d, x);
  float factor = min(min(a3.x, a3.y), a3.z);

  return clamp((1.0 - factor), 0.0, 1.0);
}

void main ()
{
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  vec3 normal_inView = normalize(v_normal_inView);
  normal_inView.y *= -1.0;
  vec2 normalUVCordinate = normal_inView.xy * 0.5 + 0.5;
  vec4 matCapColor = texture(u_matCapTexture, normalUVCordinate);
  rt0 = matCapColor;

  // Wireframe
  float threshold = 0.001;
  vec3 wireframe = get_wireframe(materialSID, 0);
  float wireframeWidthInner = wireframe.z;
  float wireframeWidthRelativeScale = 1.0;
  if (wireframe.x > 0.5 && wireframe.y < 0.5) {
    rt0.a = 0.0;
  }
  vec4 wireframeResult = rt0;
  vec4 wireframeColor = vec4(0.2, 0.75, 0.0, 1.0);
  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);
  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);
  // if r0.a is 0.0, it is wireframe not on shaded
  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified);
  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));

  if (wireframe.x > 0.5) {
    rt0 = wireframeResult;
    if (wireframe.y < 0.5 && rt0.a == 0.0) {
      discard;
    }
  }

/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var Im,Lc,ip=C(()=>{"use strict";Sr();$t();St();xe();se();Tn();So();Zt();Ni();ye();Go();N3();M3();mo();me();Im=class Im extends He{constructor(n,t,o,r,i){super(n,{isSkinning:t},P3,D3);let a;typeof o=="string"?(a=new Jt,async function(l){a.generateTextureFromUri(l,{type:I.UnsignedByte}),await a.loadFromUrlLazy()}(o)):r instanceof mn?a=r:(N.warn("no matcap texture"),a=rn);let s=[];s.push({semantic:"wireframe",componentType:I.Float,compositionType:b.Vec3,stage:D.PixelShader,initialValue:S.fromCopyArray([0,0,1]),min:0,max:10}),s.push({semantic:"pointSize",componentType:I.Float,compositionType:b.Scalar,stage:D.VertexShader,soloDatum:!0,initialValue:te.fromCopyNumber(30),min:0,max:100},{semantic:"pointDistanceAttenuation",componentType:I.Float,compositionType:b.Vec3,stage:D.VertexShader,soloDatum:!0,initialValue:S.fromCopyArray([0,.1,.01]),min:0,max:1}),s.push({semantic:"matCapTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[0,a,i],min:0,max:Number.MAX_SAFE_INTEGER}),this.setShaderSemanticsInfoArray(s)}_setInternalSettingParametersToGpuWebGL({material:n,shaderProgram:t,firstTime:o,args:r}){if(r.setUniform){this.setWorldMatrix(t,r.worldMatrix),this.setNormalMatrix(t,r.normalMatrix);let i=r.renderPass.cameraComponent;i==null&&(i=J.getComponent(re,re.current)),this.setViewInfo(t,i,r.isVr,r.displayIdx),this.setProjection(t,i,r.isVr,r.displayIdx);let a=r.entity.tryToGetSkeletal();this.setSkinning(t,r.setUniform,a)}}};h(Im,"MatCapMaterialContent"),f(Im,"MatCapTexture",new B({str:"matCapTexture"}));Lc=Im});var F3,B3=C(()=>{F3={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec3 a_position;
in vec3 a_color;
in vec3 a_normal;
in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec4 a_joint;
in vec4 a_weight;
in vec4 a_baryCentricCoord;
out vec3 v_color;
out vec3 v_normal_inWorld;
out vec4 v_position_inWorld;
out vec2 v_texcoord_0;
out vec4 v_texcoord_1;
out vec4 v_projPosition_from_light;
out vec3 v_baryCentricCoord;

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

mat3 toNormalMatrix(mat4 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];

  float b00 = a00 * a11 - a01 * a10,
  b01 = a00 * a12 - a02 * a10,
  b02 = a00 * a13 - a03 * a10,
  b03 = a01 * a12 - a02 * a11,
  b04 = a01 * a13 - a03 * a11,
  b05 = a02 * a13 - a03 * a12,
  b06 = a20 * a31 - a21 * a30,
  b07 = a20 * a32 - a22 * a30,
  b08 = a20 * a33 - a23 * a30,
  b09 = a21 * a32 - a22 * a31,
  b10 = a21 * a33 - a23 * a31,
  b11 = a22 * a33 - a23 * a32;

  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3(
    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,
    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,
    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;
}



#ifdef RN_IS_SKINNING

highp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {
  highp vec4 q = quaternion;
  highp vec3 t = translation;

  highp float sx = q.x * q.x;
  highp float sy = q.y * q.y;
  highp float sz = q.z * q.z;
  highp float cx = q.y * q.z;
  highp float cy = q.x * q.z;
  highp float cz = q.x * q.y;
  highp float wx = q.w * q.x;
  highp float wy = q.w * q.y;
  highp float wz = q.w * q.z;

  highp mat4 mat = mat4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  highp mat4 uniformScaleMat = mat4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return mat*uniformScaleMat;
}

highp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){

  highp float r;
  highp float g;
  highp float b;
  highp float a;

  highp float ix = floor(vec_xy.x * criteria);
  highp float v1x = ix / criteria;
  highp float v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  highp float iy = floor( vec_xy.y * criteria);
  highp float v2x = iy / criteria;
  highp float v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4(r, g, b, a);
}

mat4 getSkinMatrix(float skeletalComponentSID) {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));
  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));
  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));
  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  vec2 criteria = vec2(4096.0, 4096.0);

  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));
  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));
  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));
  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));
  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));
  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));
  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));

  vec2 criteria = vec2(4096.0, 4096.0);
  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif



#ifdef RN_IS_SKINNING
bool skinning(
  float skeletalComponentSID,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
  )
{
  mat4 skinMat = getSkinMatrix(skeletalComponentSID);
  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);
  outNormalMatrix = toNormalMatrix(skinMat);
  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);

  return true;
}
#endif

bool processGeometryWithMorphingAndSkinning(
  float skeletalComponentSID,
  in mat4 worldMatrix,
  in mat4 viewMatrix,
  in bool isBillboard,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
) {
  bool isSkinning = false;

  vec3 position_inLocal;
#ifdef RN_IS_MORPHING
  if (u_morphTargetNumber == 0) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    float vertexIdx = a_baryCentricCoord.w;
    position_inLocal = get_position(vertexIdx, inPosition_inLocal);
  }
#endif

  mat4 worldMatrixInner = worldMatrix;
  if (isBillboard) {
    mat4 inverseViewMatrix = inverse(viewMatrix);
    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];
    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];
    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];
    worldMatrixInner = inverseViewMatrix * worldMatrix;
  }

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0.0) {
    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);
  } else {
#endif
    outNormalMatrix = inNormalMatrix;
    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
#ifdef RN_IS_SKINNING
  }
#endif

  return isSkinning;
}


void main(){
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);
  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);

  bool isSkinning = false;
  isSkinning = processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    worldMatrix,
    viewMatrix,
    false,
    normalMatrix,
    normalMatrix,
    a_position,
    v_position_inWorld,
    a_normal,
    v_normal_inWorld
  );

  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;

// #ifdef RN_IS_POINTSPRITE

vec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);
vec3 viewPosition = get_viewPosition(cameraSID, 0);
float distanceFromCamera = length(position_inWorld.xyz - viewPosition);
vec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);
float distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));
float maxPointSize = get_pointSize(materialSID, 0);
gl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);

// #endif


  v_baryCentricCoord = a_baryCentricCoord.xyz;
  v_color = a_color;
  v_texcoord_0 = a_texcoord_0;

  // Shadow mapping
  mat4 lightViewProjectionMatrix = get_lightViewProjectionMatrix(materialSID, 0);
  v_projPosition_from_light = lightViewProjectionMatrix * v_position_inWorld;

  // Following tMatrix is based on https://wgld.org/d/webgl/w051.html
  mat4 tMatrix = mat4(
    0.5, 0.0, 0.0, 0.0,
    0.0, 0.5, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    0.5, 0.5, 0.0, 1.0
  );
  v_texcoord_1 = tMatrix * v_projPosition_from_light;

}
`,shaderStage:"vertex",isFragmentShader:!1}});var V3,L3=C(()=>{V3={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec3 v_color;
in vec3 v_normal_inWorld;
in vec4 v_position_inWorld;
in vec2 v_texcoord_0;
in vec4 v_texcoord_1;
in vec4 v_projPosition_from_light;
in vec3 v_baryCentricCoord;

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

struct Light {
  int type; // 0 = directional, 1 = point, 2 = spot
  vec3 position;
  vec3 intensity;
  vec3 attenuatedIntensity;
  vec3 directionOfLightObject;
  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)
  vec3 pointToLight; // not normalized
  float innerConeCos;
  float outerConeCos;
  float effectiveRange;
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
float getRangeAttenuation(Light light)
{
  float distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
float getSpotAttenuation(Light light)
{
  float actualCos = dot(light.direction, -light.directionOfLightObject);
  if (actualCos > light.outerConeCos) {
    if (actualCos < light.innerConeCos) {
      float attenuation = (actualCos - light.outerConeCos) / (light.innerConeCos - light.outerConeCos);
      return attenuation * attenuation;
    }
    return 1.0;
  }
  return 0.0;
}

vec3 getLightAttenuated(Light light) {
  light.attenuatedIntensity = light.intensity;
  // if (light.type == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light && Spot Light
  if (light.type != 0)
  {
    light.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot Light
  if (light.type == 2)
  {
    light.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return light.attenuatedIntensity;
}

Light getLight(int lightIdx, vec3 v_position_inWorld) {
  vec3 lightPosition = get_lightPosition(0.0, lightIdx);
  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);
  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);
  vec4 lightProperty = get_lightProperty(0.0, lightIdx);
  Light light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  float lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.innerConeCos = lightProperty.z;
  light.outerConeCos = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3(0.0);
    light.type = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.type = 1;
  } else { // is Directional Light
    light.type = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.type = 2;
  }

  const float M_PI = 3.141592653589793;
  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  light.attenuatedIntensity = getLightAttenuated(light);

  return light;
}


float edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {
  vec3 d = fwidth(bary3);
  vec3 x = bary3+vec3(1.0 - wireframeWidthInner)*d;
  vec3 a3 = smoothstep(vec3(0.0), d, x);
  float factor = min(min(a3.x, a3.y), a3.z);

  return clamp((1.0 - factor), 0.0, 1.0);
}

float decodeRGBAToDepth(vec4 RGBA){
  const float rMask = 1.0;
  const float gMask = 1.0 / 255.0;
  const float bMask = 1.0 / (255.0 * 255.0);
  const float aMask = 1.0 / (255.0 * 255.0 * 255.0);
  float depth = dot(RGBA, vec4(rMask, gMask, bMask, aMask));
  return depth;
}

float linstep(float min,float max,float v){
  return clamp((v-min)/(max-min),0.0,1.0);
}

float reduceLightBleeding(float p_max, float parameter){
  return linstep(parameter,1.0,p_max);
}

float chebyshevUpperBound(float materialSID){
  float textureDepth = decodeRGBAToDepth(textureProj(u_depthTexture, v_texcoord_1));
  float textureSquareDepth = decodeRGBAToDepth(textureProj(u_squareDepthTexture, v_texcoord_1));
  if(textureDepth == 1.0 || textureSquareDepth == 1.0){
    return 1.0;
  }

  float nonShadowProb = 1.0;

  if(v_projPosition_from_light.w > 0.0){
    float measureDepth;
    bool isPointLight = get_isPointLight(materialSID, 0);
    if(isPointLight){
      float zNear = get_zNearInner(materialSID, 0);
      float zFar = get_zFarInner(materialSID, 0);
      float normalizationCoefficient = 1.0 / (zFar - zNear);
      measureDepth = normalizationCoefficient * length(v_projPosition_from_light);
    }else{
      measureDepth = (v_projPosition_from_light / v_projPosition_from_light.w).z;
    }

    float depthAdjustment = get_depthAdjustment(materialSID, 0);
    measureDepth += depthAdjustment;

    float textureDepthAdjustment = get_textureDepthAdjustment(materialSID, 0);
    textureDepth += textureDepthAdjustment;

    float d = measureDepth - textureDepth;
    if(d < 0.0) return 1.0;

    float variance = textureSquareDepth - textureDepth * textureDepth;
    float minimumVariance = get_minimumVariance(materialSID, 0);
    variance = max(variance, minimumVariance);

    nonShadowProb = variance / (variance + d * d);


    float lightBleedingParameter = get_lightBleedingParameter(materialSID, 0);
    nonShadowProb = reduceLightBleeding(nonShadowProb, lightBleedingParameter);
  }
  return nonShadowProb;
}

void main ()
{
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  // Normal
  vec3 normal_inWorld = normalize(v_normal_inWorld);

  // diffuseColor
  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);
  float alpha = 1.0;

  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);
  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {
    diffuseColor = v_color * diffuseColorFactor.rgb;
    alpha = diffuseColorFactor.a;
  } else if (v_color == diffuseColor) {
    diffuseColor = diffuseColorFactor.rgb;
    alpha = diffuseColorFactor.a;
  } else if (diffuseColorFactor.rgb == diffuseColor) {
    diffuseColor = v_color;
  } else {
    diffuseColor = vec3(1.0, 1.0, 1.0);
  }

  // diffuseColorTexture
  vec4 textureColor = texture(u_diffuseColorTexture, v_texcoord_0);
  if (textureColor.r > 0.05) {
    diffuseColor *= textureColor.rgb;
    alpha *= textureColor.a;
  }

  // shadow mapping
  vec4 shadowColor = get_shadowColor(materialSID, 0);

  float nonShadowProb = chebyshevUpperBound(materialSID);
  diffuseColor = nonShadowProb * diffuseColor + (1.0 - nonShadowProb) * shadowColor.rgb;
  alpha = nonShadowProb * alpha + (1.0 - nonShadowProb) * shadowColor.a;

  // Lighting
  vec3 shadingColor = vec3(0.0, 0.0, 0.0);

  int shadingModel = get_shadingModel(materialSID, 0);
  if (shadingModel > 0) {
    vec3 diffuse = vec3(0.0, 0.0, 0.0);
    vec3 specular = vec3(0.0, 0.0, 0.0);
    int lightNumber = get_lightNumber(materialSID, 0);
    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */ ; i++) {
      if (i >= lightNumber) {
        break;
      }

      // Light
      Light light = getLight(i, v_position_inWorld.xyz);

      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, light.direction)) * light.attenuatedIntensity;

      vec3 viewPosition = get_viewPosition(materialSID, 0);
      float shininess = get_shininess(materialSID, 0);
      if (shadingModel == 2) {// BLINN
        // ViewDirection
        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);
        vec3 halfVector = normalize(light.direction + viewDirection);
        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), shininess);
      } else if (shadingModel == 3) { // PHONG
        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);
        vec3 R = reflect(light.direction, normal_inWorld);
        specular += pow(max(0.0, dot(R, viewDirection)), shininess);
      }

    }

    shadingColor = diffuse + specular;
  } else {
    shadingColor = diffuseColor;
  }

  rt0 = vec4(shadingColor, alpha);

  // Wireframe
  float threshold = 0.001;
  vec3 wireframe = get_wireframe(materialSID, 0);
  float wireframeWidthInner = wireframe.z;
  float wireframeWidthRelativeScale = 1.0;
  if (wireframe.x > 0.5 && wireframe.y < 0.5) {
    rt0.a = 0.0;
  }
  vec4 wireframeResult = rt0;
  vec4 wireframeColor = vec4(0.2, 0.75, 0.0, 1.0);
  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);
  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);
  // if r0.a is 0.0, it is wireframe not on shaded
  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified);
  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));

  if (wireframe.x > 0.5) {
    rt0 = wireframeResult;
    if (wireframe.y < 0.5 && rt0.a == 0.0) {
      discard;
    }
  }

/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var _n,Vc,ap=C(()=>{"use strict";So();Go();se();xe();It();ye();Jl();Zt();St();$t();Ao();Tn();tt();ft();Yt();B3();L3();mo();me();_n=class _n extends He{constructor(t,{isMorphing:o,isSkinning:r,isLighting:i,isDebugging:a,colorAttachmentsNumberDepth:s,colorAttachmentsNumberSquareDepth:l,depthCameraComponent:c},u){super(t,{isMorphing:o,isSkinning:r,isLighting:i},F3,V3);f(this,"__depthCameraComponent");u.length!==2&&N.error("invalid length of renderPasses"),c==null?N.warn("need to set depth camera component"):this.__depthCameraComponent=c;for(let y of u){let g=y.getViewport();g.setComponents(1,1,g.z-1,g.w-1),y.setViewport(g)}let _,d=u[0].getFramebuffer();d?_=d.colorAttachments[s]:(N.warn("renderPass of depth does not have framebuffer"),_=rn);let p,x=u[1].getFramebuffer();x?p=x.colorAttachments[l]:(N.warn("renderPass of square depth does not have framebuffer"),p=rn);let v=[{semantic:"lightViewProjectionMatrix",compositionType:b.Mat4,componentType:I.Float,stage:D.VertexShader,isInternalSetting:!0,initialValue:$.zero(),min:-Number.MAX_VALUE,max:Number.MAX_VALUE},{semantic:"shadingModel",compositionType:b.Scalar,componentType:I.Int,stage:D.PixelShader,initialValue:te.fromCopyNumber(To.Constant.index),min:0,max:3},{semantic:"shininess",compositionType:b.Scalar,componentType:I.Float,stage:D.PixelShader,initialValue:te.fromCopyNumber(5),min:0,max:Number.MAX_VALUE},{semantic:"allowableDepthError",compositionType:b.Scalar,componentType:I.Float,stage:D.PixelShader,initialValue:te.fromCopyNumber(1e-4),min:0,max:1},{semantic:"shadowColor",compositionType:b.Vec4,componentType:I.Float,stage:D.PixelShader,initialValue:q.fromCopyArray([.5,.5,.5,1]),min:0,max:1},{semantic:"diffuseColorFactor",compositionType:b.Vec4,componentType:I.Float,stage:D.PixelShader,initialValue:q.fromCopyArray([1,1,1,1]),min:0,max:2},{semantic:"zNearInner",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,isInternalSetting:!0,initialValue:te.fromCopyNumber(.1),min:1e-4,max:Number.MAX_SAFE_INTEGER},{semantic:"zFarInner",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,isInternalSetting:!0,initialValue:te.fromCopyNumber(1e4),min:1e-4,max:Number.MAX_SAFE_INTEGER},{semantic:"isPointLight",componentType:I.Bool,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(1),min:0,max:1},{semantic:"wireframe",componentType:I.Float,compositionType:b.Vec3,stage:D.PixelShader,initialValue:S.fromCopyArray([0,0,1]),min:0,max:10},{semantic:"depthAdjustment",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(0),min:0,max:1},{semantic:"lightBleedingParameter",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(0),min:0,max:1},{semantic:"minimumVariance",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(1e-7),min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"textureDepthAdjustment",componentType:I.Float,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(0),min:0,max:1},{semantic:"normalTexture",compositionType:b.Texture2D,componentType:I.Int,stage:D.PixelShader,initialValue:[0,Ur],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"diffuseColorTexture",compositionType:b.Texture2D,componentType:I.Int,stage:D.PixelShader,initialValue:[1,ct],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"depthTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[2,_],min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"squareDepthTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[3,p],min:0,max:Number.MAX_SAFE_INTEGER}];v.push({semantic:"pointSize",componentType:I.Float,compositionType:b.Scalar,stage:D.VertexShader,soloDatum:!0,initialValue:te.fromCopyNumber(30),min:0,max:100},{semantic:"pointDistanceAttenuation",componentType:I.Float,compositionType:b.Vec3,stage:D.VertexShader,soloDatum:!0,initialValue:S.fromCopyArray([0,.1,.01]),min:0,max:1}),o&&v.push({semantic:"morphTargetNumber",componentType:I.Int,compositionType:b.Scalar,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:te.fromCopyNumber(0),min:0,max:F.maxVertexMorphNumberInShader,needUniformInDataTextureMode:!0},{semantic:"dataTextureMorphOffsetPosition",componentType:I.Int,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Int32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:I.Float,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Float32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0}),a&&v.push({semantic:"debugColorFactor",compositionType:b.Vec4,componentType:I.Float,stage:D.PixelShader,initialValue:q.fromCopyArray([1,0,0,1]),min:0,max:2}),this.setShaderSemanticsInfoArray(v)}_setInternalSettingParametersToGpuWebGL({material:t,shaderProgram:o,firstTime:r,args:i}){var _;let a=i.renderPass.cameraComponent;a==null&&(a=J.getComponent(re,re.current));let s=(_=this.__depthCameraComponent)!=null?_:i.renderPass.cameraComponent;i.setUniform?(this.setWorldMatrix(o,i.worldMatrix),this.setNormalMatrix(o,i.normalMatrix),this.setViewInfo(o,a,i.isVr,i.displayIdx),this.setProjection(o,a,i.isVr,i.displayIdx),_n.__lastZNear!==s.zNearInner&&(o._gl.uniform1f(o.zNearInner,s.zNearInner),_n.__lastZNear=s.zNearInner),_n.__lastZFar!==s.zFarInner&&(o._gl.uniform1f(o.zFarInner,s.zFarInner),_n.__lastZFar=s.zFarInner),G.getWebGLResourceRepository().setUniformValue(o,Xe.LightViewProjectionMatrix.str,!0,s.viewProjectionMatrix)):(t.setParameter("zNearInner",s.zNearInner),t.setParameter("zFarInner",s.zFarInner),t.setParameter("lightViewProjectionMatrix",s.viewProjectionMatrix));let l=i.entity.tryToGetSkeletal();this.setSkinning(o,i.setUniform,l),this.setLightsInfo(o,i.lightComponents,t,i.setUniform);let c=i.entity.tryToGetBlendShape();this.setMorphInfo(o,i.entity.getMesh(),i.primitive,c),G.getWebGLResourceRepository().setUniformValue(o,Xe.LightViewProjectionMatrix.str,!0,s.viewProjectionMatrix)}set depthCameraComponent(t){this.__depthCameraComponent=t}};h(_n,"VarianceShadowMapDecodeClassicMaterialContent"),f(_n,"IsPointLight",new B({str:"isPointLight"})),f(_n,"DepthTexture",new B({str:"depthTexture"})),f(_n,"SquareDepthTexture",new B({str:"squareDepthTexture"})),f(_n,"DepthAdjustment",new B({str:"depthAdjustment"})),f(_n,"TextureDepthAdjustment",new B({str:"textureDepthAdjustment"})),f(_n,"MinimumVariance",new B({str:"minimumVariance"})),f(_n,"LightBleedingParameter",new B({str:"lightBleedingParameter"})),f(_n,"ShadowColor",new B({str:"shadowColor"})),f(_n,"AllowableDepthError",new B({str:"allowableDepthError"})),f(_n,"zNearInner",new B({str:"zNearInner"})),f(_n,"zFarInner",new B({str:"zFarInner"})),f(_n,"DebugColorFactor",new B({str:"debugColorFactor"})),f(_n,"__lastZNear",0),f(_n,"__lastZFar",0);Vc=_n});var G3,z3=C(()=>{G3={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

#ifdef WEBGL2_MULTI_VIEW
  layout(num_views=2) in;
#endif

in vec3 a_position;
in vec3 a_color;
in vec3 a_normal;
in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec4 a_joint;
in vec4 a_weight;
in vec4 a_baryCentricCoord;
out vec3 v_color;
out vec3 v_normal_inWorld;
out vec4 v_position_inWorld;
out vec2 v_texcoord_0;
out vec3 v_baryCentricCoord;
out vec4 v_shadowCoord;

uniform float u_pointSize; // initialValue=30
uniform vec3 u_pointDistanceAttenuation; // initialValue=(0,0.1,0.01)

// BiasMatrix * LightProjectionMatrix * LightViewMatrix, See: http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/#basic-shader
uniform mat4 u_depthBiasPV; // initialValue=(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

mat3 toNormalMatrix(mat4 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];

  float b00 = a00 * a11 - a01 * a10,
  b01 = a00 * a12 - a02 * a10,
  b02 = a00 * a13 - a03 * a10,
  b03 = a01 * a12 - a02 * a11,
  b04 = a01 * a13 - a03 * a11,
  b05 = a02 * a13 - a03 * a12,
  b06 = a20 * a31 - a21 * a30,
  b07 = a20 * a32 - a22 * a30,
  b08 = a20 * a33 - a23 * a30,
  b09 = a21 * a32 - a22 * a31,
  b10 = a21 * a33 - a23 * a31,
  b11 = a22 * a33 - a23 * a32;

  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3(
    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,
    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,
    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;
}



#ifdef RN_IS_SKINNING

highp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {
  highp vec4 q = quaternion;
  highp vec3 t = translation;

  highp float sx = q.x * q.x;
  highp float sy = q.y * q.y;
  highp float sz = q.z * q.z;
  highp float cx = q.y * q.z;
  highp float cy = q.x * q.z;
  highp float cz = q.x * q.y;
  highp float wx = q.w * q.x;
  highp float wy = q.w * q.y;
  highp float wz = q.w * q.z;

  highp mat4 mat = mat4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  highp mat4 uniformScaleMat = mat4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return mat*uniformScaleMat;
}

highp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){

  highp float r;
  highp float g;
  highp float b;
  highp float a;

  highp float ix = floor(vec_xy.x * criteria);
  highp float v1x = ix / criteria;
  highp float v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  highp float iy = floor( vec_xy.y * criteria);
  highp float v2x = iy / criteria;
  highp float v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4(r, g, b, a);
}

mat4 getSkinMatrix(float skeletalComponentSID) {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));
  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));
  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));
  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  vec2 criteria = vec2(4096.0, 4096.0);

  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));
  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));
  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));
  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));
  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));
  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));
  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));

  vec2 criteria = vec2(4096.0, 4096.0);
  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif



#ifdef RN_IS_SKINNING
bool skinning(
  float skeletalComponentSID,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
  )
{
  mat4 skinMat = getSkinMatrix(skeletalComponentSID);
  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);
  outNormalMatrix = toNormalMatrix(skinMat);
  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);

  return true;
}
#endif

bool processGeometryWithMorphingAndSkinning(
  float skeletalComponentSID,
  in mat4 worldMatrix,
  in mat4 viewMatrix,
  in bool isBillboard,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
) {
  bool isSkinning = false;

  vec3 position_inLocal;
#ifdef RN_IS_MORPHING
  if (u_morphTargetNumber == 0) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    float vertexIdx = a_baryCentricCoord.w;
    position_inLocal = get_position(vertexIdx, inPosition_inLocal);
  }
#endif

  mat4 worldMatrixInner = worldMatrix;
  if (isBillboard) {
    mat4 inverseViewMatrix = inverse(viewMatrix);
    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];
    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];
    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];
    worldMatrixInner = inverseViewMatrix * worldMatrix;
  }

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0.0) {
    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);
  } else {
#endif
    outNormalMatrix = inNormalMatrix;
    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
#ifdef RN_IS_SKINNING
  }
#endif

  return isSkinning;
}


void main()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);
  bool isBillboard = get_isBillboard(a_instanceInfo.x);

  // Skeletal
  processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    worldMatrix,
    viewMatrix,
    isBillboard,
    normalMatrix,
    normalMatrix,
    a_position,
    v_position_inWorld,
    a_normal,
    v_normal_inWorld
  );

  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;


  v_color = a_color;
  v_normal_inWorld = normalMatrix * a_normal;
  v_texcoord_0 = a_texcoord_0;
  v_baryCentricCoord = a_baryCentricCoord.xyz;

  bool visibility = get_isVisible(a_instanceInfo.x);
  if (!visibility)
  {
    gl_Position = vec4(0.0);
  }

  v_shadowCoord = get_depthBiasPV(materialSID, 0) * v_position_inWorld;

// #ifdef RN_IS_POINTSPRITE

vec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);
vec3 viewPosition = get_viewPosition(cameraSID, 0);
float distanceFromCamera = length(position_inWorld.xyz - viewPosition);
vec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);
float distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));
float maxPointSize = get_pointSize(materialSID, 0);
gl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);

// #endif


}
`,shaderStage:"vertex",isFragmentShader:!1}});var U3,O3=C(()=>{U3={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec3 v_color;
in vec3 v_normal_inWorld;
in vec4 v_position_inWorld;
in vec2 v_texcoord_0;
in vec3 v_baryCentricCoord;
in vec4 v_shadowCoord;

uniform int u_shadingModel; // initialValue=0
uniform float u_alphaCutoff; // initialValue=0.01
uniform float u_shininess; // initialValue=5
uniform vec4 u_diffuseColorFactor; // initialValue=(1,1,1,1)
uniform sampler2D u_diffuseColorTexture; // initialValue=(0,white)
uniform sampler2D u_normalTexture; // initialValue=(1,blue)
uniform vec4 u_diffuseColorTextureTransform; // initialValue=(1,1,0,0)
uniform float u_diffuseColorTextureRotation; // initialValue=0
uniform sampler2DShadow u_depthTexture; // initialValue=(2,white)

/* shaderity: @{renderTargetBegin} */

// #pragma shaderity: require(../common/deliot2019SeamlessTexture.glsl)
// uniform sampler2D u_tInvTexture; // initialValue=(1,white)
// uniform vec3 u_colorSpaceOrigin;
// uniform vec3 u_colorSpaceVector1;
// uniform vec3 u_colorSpaceVector2;
// uniform vec3 u_colorSpaceVector3;
// uniform vec4 u_scaleTranslate;


vec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {
  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  mat3 rotationMat = mat3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  mat3 matrix = translationMat * rotationMat * scaleMat;
  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;

  return uvTransformed;
}


/* shaderity: @{getters} */

struct Light {
  int type; // 0 = directional, 1 = point, 2 = spot
  vec3 position;
  vec3 intensity;
  vec3 attenuatedIntensity;
  vec3 directionOfLightObject;
  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)
  vec3 pointToLight; // not normalized
  float innerConeCos;
  float outerConeCos;
  float effectiveRange;
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
float getRangeAttenuation(Light light)
{
  float distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
float getSpotAttenuation(Light light)
{
  float actualCos = dot(light.direction, -light.directionOfLightObject);
  if (actualCos > light.outerConeCos) {
    if (actualCos < light.innerConeCos) {
      float attenuation = (actualCos - light.outerConeCos) / (light.innerConeCos - light.outerConeCos);
      return attenuation * attenuation;
    }
    return 1.0;
  }
  return 0.0;
}

vec3 getLightAttenuated(Light light) {
  light.attenuatedIntensity = light.intensity;
  // if (light.type == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light && Spot Light
  if (light.type != 0)
  {
    light.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot Light
  if (light.type == 2)
  {
    light.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return light.attenuatedIntensity;
}

Light getLight(int lightIdx, vec3 v_position_inWorld) {
  vec3 lightPosition = get_lightPosition(0.0, lightIdx);
  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);
  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);
  vec4 lightProperty = get_lightProperty(0.0, lightIdx);
  Light light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  float lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.innerConeCos = lightProperty.z;
  light.outerConeCos = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3(0.0);
    light.type = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.type = 1;
  } else { // is Directional Light
    light.type = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.type = 2;
  }

  const float M_PI = 3.141592653589793;
  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  light.attenuatedIntensity = getLightAttenuated(light);

  return light;
}


void main ()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  // Normal
  vec3 normal_inWorld = normalize(v_normal_inWorld);

  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);


  // diffuseColor (Considered to be premultiplied alpha)
  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);
  float alpha = 1.0;
  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {
    diffuseColor = v_color * diffuseColorFactor.rgb;
    alpha = diffuseColorFactor.a;
  } else if (v_color == diffuseColor) {
    diffuseColor = diffuseColorFactor.rgb;
    alpha = diffuseColorFactor.a;
  } else if (diffuseColorFactor.rgb == diffuseColor) {
    diffuseColor = v_color;
  } else {
    diffuseColor = vec3(1.0, 1.0, 1.0);
  }

  // diffuseColorTexture (Considered to be premultiplied alpha)
  vec4 diffuseColorTextureTransform = get_diffuseColorTextureTransform(materialSID, 0);
  float diffuseColorTextureRotation = get_diffuseColorTextureRotation(materialSID, 0);
  vec2 diffuseColorTexUv = uvTransform(diffuseColorTextureTransform.xy, diffuseColorTextureTransform.zw, diffuseColorTextureRotation, v_texcoord_0);
  vec4 textureColor = texture(u_diffuseColorTexture, diffuseColorTexUv);
  diffuseColor *= textureColor.rgb;
  alpha *= textureColor.a;

#ifdef RN_IS_ALPHA_MODE_MASK
  float alphaCutoff = get_alphaCutoff(materialSID, 0);
  if (alpha < alphaCutoff) {
    discard;
  }
#endif


  // Lighting
  vec3 shadingColor = vec3(0.0, 0.0, 0.0);
#ifdef RN_IS_LIGHTING
  int shadingModel = get_shadingModel(materialSID, 0);
  if (shadingModel > 0) {

    vec3 diffuse = vec3(0.0, 0.0, 0.0);
    vec3 specular = vec3(0.0, 0.0, 0.0);
    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */ ; i++) {
      if (i >= lightNumber) {
        break;
      }

      // Light
      Light light = getLight(i, v_position_inWorld.xyz);

      // Diffuse
      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, light.direction)) * light.attenuatedIntensity;

      float shininess = get_shininess(materialSID, 0);
      int shadingModel = get_shadingModel(materialSID, 0);

      vec3 viewPosition = get_viewPosition(cameraSID, 0);

      // Specular
      if (shadingModel == 2) {// BLINN
        // ViewDirection
        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);
        vec3 halfVector = normalize(light.direction + viewDirection);
        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), shininess);
      } else if (shadingModel == 3) { // PHONG
        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);
        vec3 R = reflect(light.direction, normal_inWorld);
        specular += pow(max(0.0, dot(R, viewDirection)), shininess);
      }

    }

    shadingColor = diffuse + specular;
  } else {
    shadingColor = diffuseColor;
  }
#else
  shadingColor = diffuseColor;
#endif

  // Shadow
#ifdef RN_USE_SHADOW_MAPPING
  float visibility = 1.0;
  float bias = 0.001;

  // Non PCF
  // if ( textureProj( u_depthTexture, v_shadowCoord ).r  < (v_shadowCoord.z - bias) / v_shadowCoord.w ) {
  //   visibility = 0.5;
  // }
  // shadingColor *= visibility;

  // Hardware PCF
  vec4 shadowCoord = v_shadowCoord;
  shadowCoord.z -= bias;
  shadingColor *= textureProj( u_depthTexture, shadowCoord ) * 0.5 + 0.5;

  // shadingColor.rgb = texture( u_depthTexture, v_shadowCoord.xy ).rrr;
  // shadingColor.rgb = vec3(v_shadowCoord.xy, 0.0);
  // shadingColor.rgb = vec3(diffuseColorTexUv, 0.0);
  // shadingColor.rgb = vec3(texture( u_depthTexture, diffuseColorTexUv).rrr);
  // shadingColor.rgb = texture( u_depthTexture, diffuseColorTexUv).rgb;
  // shadingColor.rgb = vec3(textureProj( u_depthTexture, v_shadowCoord ).z, 0.0, 0.0);
  alpha = 1.0;
#endif

#ifdef RN_IS_ALPHA_MODE_BLEND
#else
  alpha = 1.0;
#endif

  rt0 = vec4(shadingColor * alpha, alpha);
  // rt0 = vec4(u_lightNumber, 0.0, 0.0, 1.0);
  // rt0 = vec4(1.0, 0.0, 0.0, 1.0);
  // rt0 = vec4(normal_inWorld*0.5+0.5, 1.0);

/* shaderity: @{renderTargetEnd} */


}
`,shaderStage:"fragment",isFragmentShader:!0}});var W3,k3=C(()=>{W3={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */


#ifdef RN_IS_SKINNING

fn createMatrixFromQuaternionTranslationScale( quaternion: vec4<f32>, translation: vec3<f32>, scale: vec3<f32> ) -> mat4x4<f32> {
  let q = quaternion;
  let t = translation;

  let sx = q.x * q.x;
  let sy = q.y * q.y;
  let sz = q.z * q.z;
  let cx = q.y * q.z;
  let cy = q.x * q.z;
  let cz = q.x * q.y;
  let wx = q.w * q.x;
  let wy = q.w * q.y;
  let wz = q.w * q.z;

  let mat = mat4x4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  let uniformScaleMat = mat4x4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  let mat44 = mat*uniformScaleMat;
  return mat44;

}

fn unpackedVec2ToNormalizedVec4(vec_xy: vec2<f32>, criteria: f32) -> vec4<f32> {

  var r: f32;
  var g: f32;
  var b: f32;
  var a: f32;

  let ix = floor(vec_xy.x * criteria);
  let v1x = ix / criteria;
  let v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  let iy = floor( vec_xy.y * criteria);
  let v2x = iy / criteria;
  let v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4<f32>(r, g, b, a);
}

fn get_boneMatrixAsMat4x4(skeletalComponentSID: u32, joint: u32) -> mat4x4<f32> {
  let mat43: mat4x3<f32> = get_boneMatrix(skeletalComponentSID, joint);
  return mat4x4<f32>(
    vec4<f32>(mat43[0], 0.0),
    vec4<f32>(mat43[1], 0.0),
    vec4<f32>(mat43[2], 0.0),
    vec4<f32>(mat43[3], 1.0)
  );
}

fn getSkinMatrix(skeletalComponentSID: u32, joint: vec4<u32>, weight: vec4<f32>) -> mat4x4<f32> {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  var skinMat: mat4x4<f32> = weight.x * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.x);
  skinMat += weight.y * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.y);
  skinMat += weight.z * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.z);
  skinMat += weight.w * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.w);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  let criteria = vec2<f32>(4096.0, 4096.0);

  let tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, joint.x);
  let sq_x = get_boneScalePackedQuat(skeletalComponentSID, joint.x);
  var quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  let tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, joint.y);
  let sq_y = get_boneScalePackedQuat(skeletalComponentSID, joint.y);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  let tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, joint.z);
  let sq_z = get_boneScalePackedQuat(skeletalComponentSID, joint.z);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  let tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, joint.w);
  let sq_w = get_boneScalePackedQuat(skeletalComponentSID, joint.w);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  let ts_x = get_boneTranslateScale(skeletalComponentSID, joint.x);
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.x), ts_x.xyz, vec3(ts_x.w));
  let ts_y = get_boneTranslateScale(skeletalComponentSID, joint.y);
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.y), ts_y.xyz, vec3(ts_y.w));
  let ts_z = get_boneTranslateScale(skeletalComponentSID, joint.z);
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.z), ts_z.xyz, vec3(ts_z.w));
  let ts_w = get_boneTranslateScale(skeletalComponentSID, joint.w);
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.w), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  let boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, joint.x);
  let boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, joint.y);
  let boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, joint.z);
  let boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, joint.w);

  let criteria = vec2<f32>(4096.0, 4096.0);
  let boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  let ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  let ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  let ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  let ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif

fn toNormalMatrix(m: mat4x4<f32>) -> mat3x3<f32> {
  let a00 = m[0][0];
  let a01 = m[0][1];
  let a02 = m[0][2];
  let a03 = m[0][3];
  let a10 = m[1][0];
  let a11 = m[1][1];
  let a12 = m[1][2];
  let a13 = m[1][3];
  let a20 = m[2][0];
  let a21 = m[2][1];
  let a22 = m[2][2];
  let a23 = m[2][3];
  let a30 = m[3][0];
  let a31 = m[3][1];
  let a32 = m[3][2];
  let a33 = m[3][3];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  let determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3x3<f32>(
    (a11 * b11 - a12 * b10 + a13 * b09) / determinantVal,
    (a12 * b08 - a10 * b11 - a13 * b07) / determinantVal,
    (a10 * b10 - a11 * b08 + a13 * b06) / determinantVal,
    (a02 * b10 - a01 * b11 - a03 * b09) / determinantVal,
    (a00 * b11 - a02 * b08 + a03 * b07) / determinantVal,
    (a01 * b08 - a00 * b10 - a03 * b06) / determinantVal,
    (a31 * b05 - a32 * b04 + a33 * b03) / determinantVal,
    (a32 * b02 - a30 * b05 - a33 * b01) / determinantVal,
    (a30 * b04 - a31 * b02 + a33 * b00) / determinantVal
  );
}

struct GeometoryOutput {
  normalMatrix: mat3x3<f32>,
  position_inWorld: vec4<f32>,
  normal_inWorld: vec3<f32>,
  isSkinning: bool,
}

#ifdef RN_IS_SKINNING
fn skinning(
  skeletalComponentSID: u32,
  inNormalMatrix: mat3x3<f32>,
  inPosition_inLocal: vec3<f32>,
  inNormal_inLocal: vec3<f32>,
  joint: vec4<u32>,
  weight: vec4<f32>,
  ) -> GeometoryOutput
{
  var output: GeometoryOutput;
  let skinMat = getSkinMatrix(skeletalComponentSID, joint, weight);
  output.position_inWorld = skinMat * vec4<f32>(inPosition_inLocal, 1.0);
  output.normalMatrix = toNormalMatrix(skinMat);
  output.normal_inWorld = normalize(output.normalMatrix * inNormal_inLocal);
  output.isSkinning = true;

  return output;
}
#endif


fn processGeometryWithMorphingAndSkinning(
  skeletalComponentSID: i32,
  blendShapeComponentSID: u32,
  worldMatrix: mat4x4<f32>,
  viewMatrix: mat4x4<f32>,
  isBillboard: bool,
  inNormalMatrix: mat3x3<f32>,
  inPosition_inLocal: vec3<f32>,
  inNormal_inLocal: vec3<f32>,
  baryCentricCoord: vec4<f32>,
  joint: vec4<u32>,
  weight: vec4<f32>,
) -> GeometoryOutput {
  var output: GeometoryOutput;

  var position_inLocal: vec3<f32>;
#ifdef RN_IS_MORPHING
  if (uniformDrawParameters.morphTargetNumber == 0u) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    let vertexIdx = u32(baryCentricCoord.w);
    position_inLocal = get_position(vertexIdx, inPosition_inLocal, blendShapeComponentSID);
  }
#endif

  var worldMatrixInner = worldMatrix;

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0) {
    output = skinning(u32(skeletalComponentSID), inNormalMatrix, position_inLocal, inNormal_inLocal, joint, weight);
  } else {
#endif
    output.normalMatrix = inNormalMatrix;
    output.position_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    output.normal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
    output.isSkinning = false;
#ifdef RN_IS_SKINNING
  }
#endif

  return output;
}


// BiasMatrix * LightProjectionMatrix * LightViewMatrix, See: http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/#basic-shader
// #param depthBiasPV: mat4x4<f32>; // initialValue=(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)

@vertex
fn main(
#ifdef RN_USE_INSTANCE
  @location(8) instance_ids: vec4<f32>,
#endif


#ifdef RN_USE_POSITION_FLOAT
  @location(0) position: vec3<f32>,
#endif
#ifdef RN_USE_POSITION_INT
  @location(0) position: vec3<i32>,
#endif
#ifdef RN_USE_POSITION_UINT
  @location(0) position: vec3<u32>,
#endif

#ifdef RN_USE_NORMAL
  @location(1) normal: vec3<f32>,
#endif
#ifdef RN_USE_TANGENT
  @location(2) tangent: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_0
  @location(3) texcoord_0: vec2<f32>,
#endif
#ifdef RN_USE_TEXCOORD_1
  @location(4) texcoord_1: vec2<f32>,
#endif

#ifdef RN_USE_COLOR_0_FLOAT
  @location(5) color_0: vec4<f32>,
#endif
#ifdef RN_USE_COLOR_0_INT
  @location(5) color_0: vec4<i32>,
#endif
#ifdef RN_USE_COLOR_0_UINT
  @location(5) color_0: vec4<u32>,
#endif

#ifdef RN_USE_JOINTS_0
  @location(6) joints_0: vec4<u32>,
#endif
#ifdef RN_USE_WEIGHTS_0
  @location(7) weights_0: vec4<f32>,
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
  @location(10) baryCentricCoord: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_2
  @location(11) texcoord_2: vec2<f32>,
#endif
  @builtin(vertex_index) vertexIdx : u32,


) -> VertexOutput {

let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  var output : VertexOutput;
  let instanceId = u32(instance_ids.x);

  let worldMatrix = get_worldMatrix(instanceId);
  let viewMatrix = get_viewMatrix(cameraSID, 0);
  let projectionMatrix = get_projectionMatrix(cameraSID, 0);
  let normalMatrix = get_normalMatrix(instanceId);
  // let isBillboard = get_isBillboard(instanceId);

  let skeletalComponentSID = i32(instance_ids.y);
  let blendShapeComponentSID = u32(instance_ids.z);


#ifdef RN_USE_NORMAL
#else
  let normal = vec3<f32>(0.0, 0.0, 0.0);
#endif

#ifdef RN_USE_JOINTS_0
  let joint = joints_0;
#else
  let joint = vec4<u32>(0, 0, 0, 0);
#endif
#ifdef RN_USE_WEIGHTS_0
  let weight = weights_0;
#else
  let weight = vec4<f32>(0.0, 0.0, 0.0, 0.0);
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
#else
  let baryCentricCoord = vec4<f32>(0.0, 0.0, 0.0, 0.0);
#endif

  // Skeletal
  let geom = processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    blendShapeComponentSID,
    worldMatrix,
    viewMatrix,
    false,
    normalMatrix,
    position,
    normal,
    baryCentricCoord,
    joint,
    weight
  );

  output.position = projectionMatrix * viewMatrix * geom.position_inWorld;
  output.position_inWorld = geom.position_inWorld.xyz;

#ifdef RN_USE_COLOR_0
  output.color_0 = vec4f(color_0);
#else
  output.color_0 = vec4f(1.0, 1.0, 1.0, 1.0);
#endif

  output.normal_inWorld = normalMatrix * normal;

#ifdef RN_USE_TEXCOORD_0
  output.texcoord_0 = texcoord_0;
#endif
#ifdef RN_USE_TEXCOORD_1
  output.texcoord_1 = texcoord_1;
#endif
#ifdef RN_USE_TEXCOORD_2
  output.texcoord_2 = texcoord_2;
#endif

  output.baryCentricCoord = baryCentricCoord.xyz;

  let visibility = get_isVisible(instanceId);
  if (!visibility)
  {
    output.position = vec4f(0.0, 0.0, 0.0, 1.0);
  }

#ifdef RN_USE_SHADOW_MAPPING
  output.shadowCoord = get_depthBiasPV(materialSID, 0) * geom.position_inWorld;
#endif

  return output;

}
`,shaderStage:"vertex",isFragmentShader:!1}});var X3,Q3=C(()=>{X3={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

struct Light {
  lightType: i32, // 0 = directional, 1 = point, 2 = spot
  position: vec3<f32>,
  intensity: vec3<f32>,
  attenuatedIntensity: vec3<f32>,
  directionOfLightObject: vec3<f32>,
  direction: vec3<f32>, // direction of light vector, equal to normalize(light.pointToLight)
  pointToLight: vec3<f32>, // not normalized
  innerConeCos: f32,
  outerConeCos: f32,
  effectiveRange: f32,
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
fn getRangeAttenuation(light: Light) -> f32
{
  let distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
fn getSpotAttenuation(light: Light) -> f32
{
  let actualCos = dot(light.direction, -light.directionOfLightObject);
  if (actualCos > light.outerConeCos) {
    if (actualCos < light.innerConeCos) {
      let attenuation = (actualCos - light.outerConeCos) / (light.innerConeCos - light.outerConeCos);
      return attenuation * attenuation;
    }
    return 1.0;
  }
  return 0.0;
}

fn getLightAttenuated(light: Light) -> Light {
  var newLight: Light = light;
  newLight.attenuatedIntensity = light.intensity;
  // if (light.lightType == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light && Spot Light
  if (light.lightType != 0)
  {
    newLight.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot Light
  if (light.lightType == 2)
  {
    newLight.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return newLight;
}

fn getLight(lightIdx: u32, v_position_inWorld: vec3<f32>) -> Light {
  let lightPosition: vec3<f32> = get_lightPosition(0u, lightIdx);
  let direction_and_w_of_LightObject: vec3<f32> = get_lightDirection(0u, lightIdx);
  let lightIntensity: vec3<f32> = get_lightIntensity(0u, lightIdx);
  let lightProperty: vec4<f32> = get_lightProperty(0u, lightIdx);
  var light: Light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  let lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.innerConeCos = lightProperty.z;
  light.outerConeCos = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3f(0.0);
    light.lightType = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.lightType = 1;
  } else { // is Directional Light
    light.lightType = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.lightType = 2;
  }

  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  let newLight = getLightAttenuated(light);

  return newLight;
}

#ifdef RN_USE_TANGENT
  fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
    let tangent_inWorld = normalize(input.tangent_inWorld);
    let binormal_inWorld = normalize(input.binormal_inWorld);
    let tbnMat_tangent_to_world = mat3x3<f32>(tangent_inWorld, binormal_inWorld, normal_inWorld);

    return tbnMat_tangent_to_world;
  }
#else
    // This is based on http://www.thetenthplanet.de/archives/1180
    fn cotangent_frame(normal_inWorld: vec3f, position: vec3f, uv_: vec2f, isFront: bool) -> mat3x3<f32> {
      var uv: vec2f;
      if (isFront) {
        uv = uv_;
      } else {
        uv = -uv_;
      }

      // get edge vectors of the pixel triangle
      let dp1 = dpdx(position);
      let dp2 = -dpdy(position); // Because the Y direction of the window coordinate system is different from that of WebGL, this one is set to minus to make the result match the WebGL version.
      let duv1 = dpdx(uv);
      let duv2 = -dpdy(uv); // Because the Y direction of the window coordinate system is different from that of WebGL, this one is set to minus to make the result match the WebGL version.

      // solve the linear system
      let dp2perp = cross(dp2, normal_inWorld);
      let dp1perp = cross(normal_inWorld, dp1);
      let tangent = dp2perp * duv1.x + dp1perp * duv2.x;
      var bitangent = dp2perp * duv1.y + dp1perp * duv2.y;
      bitangent *= -1.0;

      // construct a scale-invariant frame
      let invMat = 1.0 / sqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));
      return mat3x3<f32>(tangent * invMat, bitangent * invMat, normal_inWorld);
    }

    fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
      let tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord, isFront);

      return tbnMat_tangent_to_world;
    }
#endif

// This file includes portions of code from the glTF-Sample-Renderer project by Khronos Group (Apache License 2.0).
// https://github.com/KhronosGroup/glTF-Sample-Renderer
// Modified by Yuki Shimada

fn srgbToLinear(srgbColor: vec3f) -> vec3f {
  return pow(srgbColor, vec3f(2.2));
}

fn linearToSrgb(linearColor: vec3f) -> vec3f {
  return pow(linearColor, vec3f(1.0/2.2));
}

// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66
fn Schlick_to_F0_F90(f: vec3f, f90: vec3f, VdotH: f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0_F90_F32(f: f32, f90: f32, VdotH: f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0(f: vec3f, VdotH: f32) -> vec3f {
    return Schlick_to_F0_F90(f, vec3(1.0), VdotH);
}

fn Schlick_to_F0_F32(f: f32, VdotH: f32) -> f32 {
    return Schlick_to_F0_F90_F32(f, 1.0, VdotH);
}


// The Schlick Approximation to Fresnel
fn fresnelSchlick(f0 : vec3f, f90 : vec3f, VdotH : f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnelSchlickF32(f0 : f32, f90 : f32, VdotH : f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnelSchlick2(f0: vec3f, VdotH: f32) -> vec3f
{
  let f90 = vec3f(1.0); //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelSchlick(f0, f90, VdotH);
}

fn fresnel2F32(f0: f32, VdotH: f32) -> f32
{
  let f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelSchlickF32(f0, f90, VdotH);
}

// Roughness Dependent Fresnel
// https://www.jcgt.org/published/0008/01/03/paper.pdf
fn fresnelSchlickRoughness(F0: vec3f, cosTheta: f32, roughness: f32) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);
  return k_S;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf
fn BRDF_lambertian(diffuseAlbedo: vec3f) -> vec3f
{
  return diffuseAlbedo * RECIPROCAL_PI;
}


// GGX NDF
fn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {
  let roughnessSqr = alphaRoughness * alphaRoughness;
  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
fn v_GGXCorrelated(NL: f32, NV: f32, alphaRoughness: f32) -> f32 {
  let a2 = alphaRoughness * alphaRoughness;
  let GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  let GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  let GGX = GGXV + GGXL;
  if (GGX > 0.0) {
    return clamp(0.5 / GGX, 0.0, 1.0);
  }
  return 1.0;
}

fn BRDF_specularGGX(NH: f32, NL: f32, NV: f32, alphaRoughness: f32) -> vec3f {
  let D = d_GGX(NH, alphaRoughness);
  let V = v_GGXCorrelated(NL, NV, alphaRoughness);
  return vec3f(D) * vec3f(V);
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
fn envBRDFApprox( Roughness: f32, NoV: f32 ) -> vec2f {
  let c0 = vec4f(-1, -0.0275, -0.572, 0.022 );
  let c1 = vec4f(1, 0.0425, 1.04, -0.04 );
  let r = Roughness * c0 + c1;
  let a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  let AB = vec2f( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}


// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes
fn specular_btdf(alphaRoughness: f32, NdotL: f32, NdotV: f32, NdotHt: f32) -> f32 {
  let V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  let D = d_GGX(NdotHt, alphaRoughness);
  return V * D;
}

fn IsotropicNDFFiltering(normal: vec3f, roughness2: f32) -> f32 {
  let SIGMA2 = 0.15915494;
  let KAPPA = 0.18;
  let dndu  = dpdx(normal);
  let dndv = dpdy(normal);
  let kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));
  let clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);
  let filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);
  return filteredRoughness2;
}

////////////////////////////////////////
// glTF KHR_materials_transmission
////////////////////////////////////////

#ifdef RN_USE_TRANSMISSION

// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
fn volumeAttenuation(attenuationColor: vec3f, attenuationDistance: f32, intensity: vec3f, transmissionDistance: f32) -> vec3f
{
  if (attenuationDistance == 0.0) { // means Infinite distance
    return intensity; // No attenuation
  } else {
    // let attenuationCo: vec3f = -log(attenuationColor) / attenuationDistance;
    // let attenuatedTransmittance: vec3f = exp(-attenuationCo * transmissionDistance);
    let attenuatedTransmittance: vec3f = pow(attenuationColor, vec3f(transmissionDistance / attenuationDistance));
    return intensity * attenuatedTransmittance;
  }
}

// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer
fn getVolumeTransmissionRay(n: vec3f, v: vec3f, thickness: f32, ior: f32, instanceInfo: u32) -> vec3f
{
  let refractionVector = refract(-v, normalize(n), 1.0 / ior);
  let worldMatrix = get_worldMatrix(instanceInfo);

  var modelScale: vec3f;
  modelScale.x = length(vec3f(worldMatrix[0].xyz));
  modelScale.y = length(vec3f(worldMatrix[1].xyz));
  modelScale.z = length(vec3f(worldMatrix[2].xyz));

  return normalize(refractionVector) * thickness * modelScale;
}
#endif

fn applyIorToRoughness(roughness: f32, ior: f32) -> f32
{
    return clamp(roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0), c_MinRoughness, 1.0);
}

fn calculateRadianceTransmission(normal: vec3f, view: vec3f, pointToLight: vec3f, alphaRoughness: f32, baseColor: vec3f, ior: f32) -> vec3f
{
    let transmissionRoughness = applyIorToRoughness(alphaRoughness, ior);

    let n = normalize(normal);
    let v = normalize(view);
    let l = normalize(pointToLight);
    let mirrorL = normalize(l + 2.0 * n * dot(-l, n));
    let h = normalize(mirrorL + v);

    let D = d_GGX(clamp(dot(n, h), 0.0, 1.0), transmissionRoughness);
    let V = v_GGXCorrelated(clamp(dot(n, mirrorL), 0.0, 1.0), clamp(dot(n, v), 0.0, 1.0), transmissionRoughness);

    return baseColor * D * V;
}




////////////////////////////////////////
// glTF KHR_materials_anisotropy
////////////////////////////////////////
#ifdef RN_USE_ANISOTROPY
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
fn D_GGX_anisotropic(NdotH: f32, TdotH: f32, BdotH: f32, at: f32, ab: f32) -> f32
{
    let a2 = at * ab;
    let f = vec3f(ab * TdotH, at * BdotH, a2 * NdotH);
    let w2 = a2 / dot(f, f);
    return a2 * w2 * w2 / M_PI;
}

fn V_GGX_anisotropic(NdotL: f32, NdotV: f32, BdotV: f32, TdotV: f32, TdotL: f32, BdotL: f32,
    at: f32, ab: f32) -> f32
{
    let GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));
    let GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));
    let GGX = GGXV + GGXL;
    if (GGX > 0.0) {
      return clamp(0.5 / GGX, 0.0, 1.0);
    }
    return 1.0;
}

fn BRDF_specularAnisotropicGGX(alphaRoughness: f32,
    VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32, BdotV: f32, TdotV: f32,
    TdotL: f32, BdotL: f32, TdotH: f32, BdotH: f32, anisotropy: f32) -> vec3f
{
    let at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
    let ab = clamp(alphaRoughness, 0.001, 1.0);

    let V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);
    let D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);

    return vec3f(V * D);
}
#endif

////////////////////////////////////////
// glTF KHR_materials_sheen
////////////////////////////////////////

#ifdef RN_USE_SHEEN
fn d_Charlie(sheenPerceptualRoughness: f32, NoH: f32) -> f32 {
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  let sheenRoughness = max(sheenPerceptualRoughness, 0.000001);
  let alphaG = sheenRoughness * sheenRoughness;
  let invAlpha  = 1.0 / alphaG;
  let cos2h = NoH * NoH;
  let sin2h = 1.0 - cos2h;
  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * M_PI);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn sheenSimpleVisibility(NdotL: f32, NdotV: f32) -> f32 {
  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn charlieL(x: f32, alphaG: f32) -> f32 {
  let oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
  let a = mix(21.5473, 25.3245, oneMinusAlphaSq);
  let b = mix(3.82987, 3.32435, oneMinusAlphaSq);
  let c = mix(0.19823, 0.16801, oneMinusAlphaSq);
  let d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
  let e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
  return a / (1.0 + b * pow(x, c)) + d * x + e;
}

fn lambdaSheen(cosTheta: f32, alphaG: f32) -> f32
{
  return select(exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG)), exp(charlieL(cosTheta, alphaG)), abs(cosTheta) < 0.5);
}

fn sheenCharlieVisibility(NdotL: f32, NdotV: f32, sheenPerceptualRoughness: f32) -> f32 {
  let sheenRoughness = max(sheenPerceptualRoughness, 0.000001);
  let alphaG = sheenRoughness * sheenRoughness;
  let sheenVisibility = clamp(1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL)), 0.0, 1.0);
  return sheenVisibility;
}

fn BRDF_specularSheen(sheenColor: vec3f, sheenPerceptualRoughness: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f {
  let sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);
  let sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);
  return sheenColor * sheenDistribution * sheenVisibility;
}
#endif // RN_USE_SHEEN

////////////////////////////////////////
// glTF KHR_materials_irirdescence
////////////////////////////////////////

#ifdef RN_USE_IRIDESCENCE
// XYZ to REC709(sRGB) conversion matrix
const XYZ_TO_REC709 = mat3x3<f32>(
     3.2404542, -0.9692660,  0.0556434,
    -1.5371385,  1.8760108, -0.2040259,
    -0.4985314,  0.0415560,  1.0572252
);

fn fresnelSchlickRoughnessWithIridescence(
  F0: vec3f, cosTheta: f32, roughness: f32,
  iridescenceFresnel: vec3f, iridescence: f32
  ) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);
  return k_S;
}

// Assume air interface for top
fn Fresnel0ToIor(F0: vec3f) -> vec3f {
    let sqrtF0 = sqrt(F0);
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// Conversion from IOR to F0
// ior is a value between 1.0 and 3.0. 1.0 is air interface
fn IorToFresnel0Vec3f(transmittedIor: vec3f, incidentIor: f32) -> vec3f {
    return sqVec3f((transmittedIor - vec3f(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
fn IorToFresnel0F32(transmittedIor: f32, incidentIor: f32) -> f32 {
    return sqF32((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration
 */
fn evalSensitivity(OPD: f32, shift: vec3f) -> vec3f {
    let phase = 2.0 * M_PI * OPD * 1.0e-9;
    let val = vec3f(5.4856e-13, 4.4201e-13, 5.2481e-13);
    let pos = vec3f(1.6810e+06, 1.7953e+06, 2.2084e+06);
    let var_ = vec3f(4.3278e+09, 9.3046e+09, 6.6121e+09);

    var xyz = val * sqrt(2.0 * M_PI * var_) * cos(pos * phase + shift) * exp(-(phase * phase) * var_);
    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));
    xyz /= 1.0685e-7;

    let rgb = XYZ_TO_REC709 * xyz;
    return rgb;
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel
 */
fn calcIridescence(outsideIor: f32, eta2: f32, cosTheta1: f32, thinFilmThickness: f32, baseF0: vec3f) -> vec3f {


  // iridescenceIor is the index of refraction of the thin-film layer
  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
  let iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));

  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)
  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.
  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.
  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):
  let sinTheta2Sq = sqF32(outsideIor / iridescenceIor) * (1.0 - sqF32(cosTheta1));
  let cosTheta2Sq = 1.0 - sinTheta2Sq;

  // Handle total internal reflection
  if (cosTheta2Sq < 0.0) {
      return vec3f(1.0);
  }

  let cosTheta2 = sqrt(cosTheta2Sq);

  /// Material Interfaces
  // The iridescence model defined by Belcour/Barla models two material interfaces
  // - one from the outside to the thin-film layer
  // and another one from the thin-film to the base material. These two interfaces are defined as follows:

  // First interface (from the outside to the thin-film layer)
  let R0 = IorToFresnel0F32(iridescenceIor, outsideIor);
  let R12 = fresnel2F32(R0, cosTheta1);
  let R21 = R12;
  let T121 = 1.0 - R12;

  // Second interface (from the thin-film to the base material)
  let baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0
  let R1 = IorToFresnel0Vec3f(baseIor, iridescenceIor);
  let R23 = fresnelSchlick2(R1, cosTheta2);

  // phi12 and phi23 define the base phases per interface and are approximated with 0.0
  // if the IOR of the hit material (iridescenceIor or baseIor) is higher
  // than the IOR of the previous material (outsideIor or iridescenceIor) and \u03C0 otherwise.
  // Also here, polarization is ignored.  float phi12 = 0.0;

  // First interface (from the outside to the thin-film layer)
  var phi12 = 0.0;
  if (iridescenceIor < outsideIor) { phi12 = M_PI; }
  let phi21 = M_PI - phi12;

  // Second interface (from the thin-film to the base material)
  var phi23 = vec3f(0.0);
  if (baseIor[0] < iridescenceIor) { phi23[0] = M_PI; }
  if (baseIor[1] < iridescenceIor) { phi23[1] = M_PI; }
  if (baseIor[2] < iridescenceIor) { phi23[2] = M_PI; }

  // OPD (optical path difference)
  let OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
  // Phase shift
  let phi = vec3f(phi21) + phi23;

  // Compound terms
  let R123 = clamp(R12 * R23, vec3f(1e-5), vec3f(0.9999));
  let r123 = sqrt(R123);
  let Rs = (T121 * T121) * R23 / (vec3f(1.0) - R123);

  // Reflectance term for m = 0 (DC term amplitude)
  let C0 = R12 + Rs;
  var I = C0;

  // Reflectance term for m > 0 (pairs of diracs)
  var Cm = Rs - T121;
  for (var m = 1; m <= 2; m++)
  {
      Cm *= r123;
      let Sm = 2.0 * evalSensitivity(f32(m) * OPD, f32(m) * phi);
      I += Cm * Sm;
  }

  let F_iridescence = max(I, vec3f(0.0));

  return F_iridescence;
}

//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB
fn BRDF_lambertianIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, iridescenceFactor: f32, diffuseColor: vec3f, specularWeight: f32, VdotH: f32) -> vec3f
{
    let iridescenceFresnelMax = vec3f(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));

    let schlickFresnel = Schlick_to_F0_F90(f0, f90, VdotH);

    let F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);

    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);
}

fn BRDF_specularGGXIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, alphaRoughness: f32, iridescenceFactor: f32, specularWeight: f32, VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f
{
    let F = mix(Schlick_to_F0_F90(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);
    let Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
    let D = d_GGX(NdotH, alphaRoughness);

    return specularWeight * F * Vis * D;
}

fn rgb_mix(base: vec3f, specular_brdf: vec3f, rgb_alpha: vec3f) -> vec3f
{
    let rgb_alpha_max = max(rgb_alpha.r, max(rgb_alpha.g, rgb_alpha.b));
    return (1.0 - rgb_alpha_max) * base + rgb_alpha * specular_brdf;
}

#endif // RN_USE_IRIDESCENCE


////////////////////////////////////////
// lighting with a punctual light
////////////////////////////////////////
fn lightingWithPunctualLight(
  light_: Light,
  normal_inWorld: vec3f,
  viewDirection: vec3f,
  NdotV: f32,
  baseColor: vec3f,
  perceptualRoughness: f32,
  metallic: f32,
  dielectricF0: vec3f,
  dielectricF90: vec3f,
  transmission: f32,
  thickness: f32,
  ior: f32,
  clearcoat: f32,
  clearcoatRoughness: f32,
  clearcoatF0: vec3f,
  clearcoatF90: vec3f,
  clearcoatFresnel: vec3f,
  clearcoatNormal_inWorld: vec3f,
  VdotNc: f32,
  attenuationColor: vec3f,
  attenuationDistance: f32,
  anisotropy: f32,
  anisotropicT: vec3f,
  anisotropicB: vec3f,
  BdotV: f32,
  TdotV: f32,
  sheenColor: vec3f,
  sheenRoughness: f32,
  albedoSheenScalingNdotV: f32,
  iridescence: f32,
  iridescenceFresnel_dielectric: vec3f,
  iridescenceFresnel_metal: vec3f,
  specularWeight: f32,
  instanceInfo: u32,
  diffuseTransmission: f32,
  diffuseTransmissionColor: vec3f,
  diffuseTransmissionThickness: f32
  ) -> vec3f
{
  var light = light_;
  let alphaRoughness = perceptualRoughness * perceptualRoughness;

  // Fresnel
  let halfVector = normalize(light.direction + viewDirection);
  let VdotH = saturate(dot(viewDirection, halfVector));
  var dielectricFresnel = fresnelSchlick(dielectricF0, dielectricF90, VdotH);
  let metalFresnel = fresnelSchlick(baseColor, vec3f(1.0), VdotH);

  let NdotL = saturateEpsilonToOne(dot(normal_inWorld, light.direction));

  // Diffuse
  let diffuseBrdf = BRDF_lambertian(baseColor);
  var diffuseContrib = diffuseBrdf * vec3f(NdotL) * light.attenuatedIntensity;

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  diffuseContrib = diffuseContrib * (vec3f(1.0) - diffuseTransmission);
  if (dot(normal_inWorld, light.direction) < 0.0) {
    let diffuseNdotL = saturate(dot(normal_inWorld, -light.direction));
    var diffuseBtdf = BRDF_lambertian(diffuseTransmissionColor) * vec3f(diffuseNdotL) * light.attenuatedIntensity;
    let mirrorL = normalize(light.direction + 2.0 * normal_inWorld * dot(normal_inWorld, -light.direction));
    let diffuseVdotH = saturate(dot(viewDirection, normalize(mirrorL + viewDirection)));
    dielectricFresnel = fresnelSchlick(dielectricF0 * specularWeight, dielectricF90, abs(diffuseVdotH));
#ifdef RN_USE_VOLUME
    diffuseBtdf = volumeAttenuation(attenuationColor, attenuationDistance, diffuseBtdf, diffuseTransmissionThickness);
#endif // RN_USE_VOLUME
    diffuseContrib += diffuseBtdf * diffuseTransmission;
  }
#endif // RN_USE_DIFFUSE_TRANSMISSION

#ifdef RN_USE_TRANSMISSION
  let transmittionRay = getVolumeTransmissionRay(normal_inWorld, viewDirection, thickness, ior, instanceInfo);
  light.pointToLight -= transmittionRay;
  light.direction = normalize(light.pointToLight);
  var transmittedContrib = calculateRadianceTransmission(normal_inWorld, viewDirection, light.direction, alphaRoughness, baseColor, ior) * light.attenuatedIntensity;

#ifdef RN_USE_VOLUME
  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittionRay));
#endif // RN_USE_VOLUME

  diffuseContrib = mix(diffuseContrib, vec3f(transmittedContrib), transmission);
#endif // RN_USE_TRANSMISSION

  // Specular
  let NdotH = saturate(dot(normal_inWorld, halfVector));

#ifdef RN_USE_ANISOTROPY
  let TdotL = dot(anisotropicT, light.direction);
  let BdotL = dot(anisotropicB, light.direction);
  let TdotH = dot(anisotropicT, halfVector);
  let BdotH = dot(anisotropicB, halfVector);
  let specularMetalContrib = BRDF_specularAnisotropicGGX(alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3f(NdotL) * light.attenuatedIntensity;
  let specularDielectricContrib = specularMetalContrib;
#else
  let specularMetalContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, alphaRoughness) * vec3f(NdotL) * light.attenuatedIntensity;
  let specularDielectricContrib = specularMetalContrib;
#endif

  // Base Layer
  var metal = specularMetalContrib * metalFresnel;
  var dielectric = mix(diffuseContrib, specularDielectricContrib, dielectricFresnel);

#ifdef RN_USE_IRIDESCENCE
  metal = mix(metal, specularMetalContrib * iridescenceFresnel_metal, iridescence);
  dielectric = mix(dielectric, rgb_mix(diffuseContrib, specularDielectricContrib, iridescenceFresnel_dielectric), iridescence);
#endif // RN_USE_IRIDESCENCE

#ifdef RN_USE_CLEARCOAT
  // Clear Coat Layer
  let NdotHc = saturate(dot(clearcoatNormal_inWorld, halfVector));
  let LdotNc = saturate(dot(light.direction, clearcoatNormal_inWorld));
  let clearcoatContrib = BRDF_specularGGX(NdotHc, LdotNc, VdotNc, clearcoatRoughness * clearcoatRoughness) * vec3f(LdotNc) * light.attenuatedIntensity;
#else
  let clearcoatContrib = vec3f(0.0);
#endif // RN_USE_CLEARCOAT

#ifdef RN_USE_SHEEN
  // Sheen
  let sheenContrib = BRDF_specularSheen(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;
  let albedoSheenScaling = min(
    albedoSheenScalingNdotV,
    1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotL, sheenRoughness)).r);
#else
  let sheenContrib = vec3f(0.0);
  let albedoSheenScaling = 1.0;
#endif // RN_USE_SHEEN

  var color = mix(dielectric, metal, metallic);
  color = sheenContrib + color * albedoSheenScaling;
  color = mix(color, clearcoatContrib, clearcoat * clearcoatFresnel);

  return color;
}


// #param shadingModel: u32; // initialValue=0
// #param alphaCutoff: f32; // initialValue=0.01
// #param shininess: f32; // initialValue=5
// #param diffuseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)
@group(1) @binding(0) var diffuseColorTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(0) var diffuseColorSampler: sampler;
@group(1) @binding(1) var normalTexture: texture_2d<f32>; // initialValue=blue
@group(2) @binding(1) var normalSampler: sampler;
// #param diffuseColorTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)
// #param diffuseColorTextureRotation: f32; // initialValue=0
@group(1) @binding(2) var depthTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(2) var depthSampler: sampler;

@fragment
fn main (
  input: VertexOutput,
  @builtin(front_facing) isFront: bool,
) -> @location(0) vec4<f32> {

let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  // Normal
  let normal_inWorld = normalize(input.normal_inWorld);

  let diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);

  // diffuseColor (Considered to be premultiplied alpha)
  var diffuseColor = vec3f(1.0, 1.0, 1.0);
  var alpha = 1.0;
#ifdef RN_USE_COLOR_0
  diffuseColor = input.color_0.rgb;
  alpha = input.color_0.a;
#endif
  diffuseColor *= diffuseColorFactor.rgb;
  alpha *= diffuseColorFactor.a;

#ifdef RN_USE_TEXCOORD_0
  // diffuseColorTexture (Considered to be premultiplied alpha)
  let diffuseColorTextureTransform = get_diffuseColorTextureTransform(materialSID, 0);
  let diffuseColorTextureRotation = get_diffuseColorTextureRotation(materialSID, 0);
  let diffuseColorTexUv = uvTransform(diffuseColorTextureTransform.xy, diffuseColorTextureTransform.zw, diffuseColorTextureRotation, input.texcoord_0);
  let textureColor = textureSample(diffuseColorTexture, diffuseColorSampler, diffuseColorTexUv);
  diffuseColor *= textureColor.rgb;
  alpha *= textureColor.a;
#endif

#ifdef RN_IS_ALPHA_MODE_MASK
  let alphaCutoff = get_alphaCutoff(materialSID, 0);
  if (baseColor.a < alphaCutoff) {
    discard;
  }
#endif


  // Lighting
  var shadingColor = vec3f(0.0, 0.0, 0.0);
#ifdef RN_IS_LIGHTING
  let shadingModel = get_shadingModel(materialSID, 0);
  if (shadingModel > 0) {

    var diffuse = vec3(0.0, 0.0, 0.0);
    var specular = vec3(0.0, 0.0, 0.0);
    let lightNumber = u32(get_lightNumber(0u, 0u));
    for (var i = 0u; i < lightNumber ; i++) {

      // Light
      let light: Light = getLight(i, input.position_inWorld.xyz);

      // Diffuse
      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, light.direction)) * light.attenuatedIntensity;

      let shininess = get_shininess(materialSID, 0);
      let shadingModel = get_shadingModel(materialSID, 0);

      let viewPosition = get_viewPosition(cameraSID, 0);

      // Specular
      if (shadingModel == 2) {// BLINN
        // ViewDirection
        let viewDirection = normalize(viewPosition - input.position_inWorld.xyz);
        let halfVector = normalize(light.direction + viewDirection);
        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), shininess);
      } else if (shadingModel == 3) { // PHONG
        let viewDirection = normalize(viewPosition - input.position_inWorld.xyz);
        let R = reflect(light.direction, normal_inWorld);
        specular += pow(max(0.0, dot(R, viewDirection)), shininess);
      }

    }

    shadingColor = diffuse + specular;
  } else {
    shadingColor = diffuseColor;
  }
#else
  shadingColor = diffuseColor;
#endif

  // Shadow
// #ifdef RN_USE_SHADOW_MAPPING
//   float visibility = 1.0;
//   float bias = 0.001;

// //  Non PCF
//   if ( textureProj( u_depthTexture, v_shadowCoord ).r  < (v_shadowCoord.z - bias) / v_shadowCoord.w ) {
//     visibility = 0.5;
//   }
//   shadingColor *= visibility;

//   // Hardware PCF
//   // vec4 shadowCoord = v_shadowCoord;
//   // shadowCoord.z -= bias;
//   // shadingColor *= textureProj( u_depthTexture, shadowCoord ) * 0.5 + 0.5;

//   alpha = 1.0;
// #endif

#ifdef RN_IS_ALPHA_MODE_BLEND
#else
  alpha = 1.0;
#endif

  var finalColor = vec4f(shadingColor * alpha, alpha);
  // rt0 = vec4(u_lightNumber, 0.0, 0.0, 1.0);
  // rt0 = vec4(1.0, 0.0, 0.0, 1.0);
  // rt0 = vec4(normal_inWorld*0.5+0.5, 1.0);

  return finalColor;
}
`,shaderStage:"fragment",isFragmentShader:!0}});var q3,H3=C(()=>{q3={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

#ifdef WEBGL2_MULTI_VIEW
  layout(num_views=2) in;
#endif

in vec3 a_position;
in vec3 a_color;
in vec3 a_normal;
in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec2 a_texcoord_1;
in vec2 a_texcoord_2;
in vec4 a_joint;
in vec4 a_weight;
in vec4 a_baryCentricCoord;
out vec3 v_color;
out vec3 v_normal_inWorld;
out vec4 v_position_inWorld;
out vec2 v_texcoord_0;
out vec2 v_texcoord_1;
out vec2 v_texcoord_2;
out vec3 v_baryCentricCoord;
out float v_instanceInfo;
out float v_displayIdx;
#ifdef RN_USE_TANGENT
  in vec4 a_tangent;
  out vec3 v_tangent_inWorld;
  out vec3 v_binormal_inWorld;
#endif

uniform float u_pointSize; // initialValue=30, soloDatum=true
uniform vec3 u_pointDistanceAttenuation; // initialValue=(0.0, 0.1, 0.01), soloDatum=true

#ifdef RN_USE_SHADOW_MAPPING
  uniform int u_lightIndex; // initialValue=0
#endif
precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

mat3 toNormalMatrix(mat4 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];

  float b00 = a00 * a11 - a01 * a10,
  b01 = a00 * a12 - a02 * a10,
  b02 = a00 * a13 - a03 * a10,
  b03 = a01 * a12 - a02 * a11,
  b04 = a01 * a13 - a03 * a11,
  b05 = a02 * a13 - a03 * a12,
  b06 = a20 * a31 - a21 * a30,
  b07 = a20 * a32 - a22 * a30,
  b08 = a20 * a33 - a23 * a30,
  b09 = a21 * a32 - a22 * a31,
  b10 = a21 * a33 - a23 * a31,
  b11 = a22 * a33 - a23 * a32;

  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3(
    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,
    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,
    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;
}



#ifdef RN_IS_SKINNING

highp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {
  highp vec4 q = quaternion;
  highp vec3 t = translation;

  highp float sx = q.x * q.x;
  highp float sy = q.y * q.y;
  highp float sz = q.z * q.z;
  highp float cx = q.y * q.z;
  highp float cy = q.x * q.z;
  highp float cz = q.x * q.y;
  highp float wx = q.w * q.x;
  highp float wy = q.w * q.y;
  highp float wz = q.w * q.z;

  highp mat4 mat = mat4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  highp mat4 uniformScaleMat = mat4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return mat*uniformScaleMat;
}

highp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){

  highp float r;
  highp float g;
  highp float b;
  highp float a;

  highp float ix = floor(vec_xy.x * criteria);
  highp float v1x = ix / criteria;
  highp float v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  highp float iy = floor( vec_xy.y * criteria);
  highp float v2x = iy / criteria;
  highp float v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4(r, g, b, a);
}

mat4 getSkinMatrix(float skeletalComponentSID) {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));
  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));
  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));
  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  vec2 criteria = vec2(4096.0, 4096.0);

  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));
  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));
  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));
  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));
  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));
  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));
  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));

  vec2 criteria = vec2(4096.0, 4096.0);
  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif



#ifdef RN_IS_SKINNING
bool skinning(
  float skeletalComponentSID,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
  )
{
  mat4 skinMat = getSkinMatrix(skeletalComponentSID);
  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);
  outNormalMatrix = toNormalMatrix(skinMat);
  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);

  return true;
}
#endif

bool processGeometryWithMorphingAndSkinning(
  float skeletalComponentSID,
  in mat4 worldMatrix,
  in mat4 viewMatrix,
  in bool isBillboard,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
) {
  bool isSkinning = false;

  vec3 position_inLocal;
#ifdef RN_IS_MORPHING
  if (u_morphTargetNumber == 0) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    float vertexIdx = a_baryCentricCoord.w;
    position_inLocal = get_position(vertexIdx, inPosition_inLocal);
  }
#endif

  mat4 worldMatrixInner = worldMatrix;
  if (isBillboard) {
    mat4 inverseViewMatrix = inverse(viewMatrix);
    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];
    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];
    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];
    worldMatrixInner = inverseViewMatrix * worldMatrix;
  }

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0.0) {
    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);
  } else {
#endif
    outNormalMatrix = inNormalMatrix;
    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
#ifdef RN_IS_SKINNING
  }
#endif

  return isSkinning;
}


void main()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);
  bool isBillboard = get_isBillboard(a_instanceInfo.x);

  v_color = a_color;

  bool isSkinning = false;

  isSkinning = processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    worldMatrix,
    viewMatrix,
    isBillboard,
    normalMatrix,
    normalMatrix,
    a_position,
    v_position_inWorld,
    a_normal,
    v_normal_inWorld
  );

  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;

  v_texcoord_0 = a_texcoord_0;
  v_texcoord_1 = a_texcoord_1;
  v_texcoord_2 = a_texcoord_2;

  #ifdef RN_USE_TANGENT
    v_tangent_inWorld = normalMatrix * a_tangent.xyz;
    v_binormal_inWorld = cross(v_tangent_inWorld, v_normal_inWorld) * a_tangent.w;
  #endif
  v_baryCentricCoord = a_baryCentricCoord.xyz;

  v_instanceInfo = a_instanceInfo.x;

#ifdef WEBGL2_MULTI_VIEW
  v_displayIdx = float(gl_ViewID_OVR);
#endif

  bool visibility = get_isVisible(a_instanceInfo.x);
  if (!visibility)
  {
    gl_Position = vec4(0.0);
  }

// #ifdef RN_IS_POINTSPRITE

vec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);
vec3 viewPosition = get_viewPosition(cameraSID, 0);
float distanceFromCamera = length(position_inWorld.xyz - viewPosition);
vec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);
float distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));
float maxPointSize = get_pointSize(materialSID, 0);
gl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);

// #endif


}
`,shaderStage:"vertex",isFragmentShader:!1}});var Y3,j3=C(()=>{Y3={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec3 v_color;
in vec3 v_normal_inWorld;
in vec4 v_position_inWorld;
in vec2 v_texcoord_0;
in vec2 v_texcoord_1;
in vec2 v_texcoord_2;
in vec3 v_baryCentricCoord;
in float v_instanceInfo;
in float v_displayIdx;

#ifdef RN_USE_TANGENT
  in vec3 v_tangent_inWorld;
  in vec3 v_binormal_inWorld;
#endif

#ifdef RN_USE_SHADOW_MAPPING
in vec4 v_shadowCoord;
#endif

uniform vec4 u_baseColorFactor; // initialValue=(1,1,1,1)
uniform sampler2D u_baseColorTexture; // initialValue=(0,white)
uniform float u_metallicFactor; // initialValue=1
uniform float u_roughnessFactor; // initialValue=1
uniform sampler2D u_metallicRoughnessTexture; // initialValue=(1,white)
uniform sampler2D u_occlusionTexture; // initialValue=(3,white)
uniform vec3 u_emissiveFactor; // initialValue=(0,0,0)
uniform sampler2D u_emissiveTexture; // initialValue=(4,white)
#ifdef RN_USE_EMISSIVE_STRENGTH
  uniform float u_emissiveStrength; // initialValue=1
#endif
uniform vec3 u_wireframe; // initialValue=(0,0,1)
uniform bool u_isOutputHDR; // initialValue=0
uniform bool u_makeOutputSrgb; // initialValue=1
uniform vec4 u_iblParameter; // initialValue=(1,1,1,1), isInternalSetting=true
uniform ivec2 u_hdriFormat; // initialValue=(0,0), isInternalSetting=true
uniform samplerCube u_diffuseEnvTexture; // initialValue=(5,black), isInternalSetting=true
uniform samplerCube u_specularEnvTexture; // initialValue=(6,black), isInternalSetting=true
uniform vec2 u_baseColorTextureTransformScale; // initialValue=(1,1)
uniform vec2 u_baseColorTextureTransformOffset; // initialValue=(0,0)
uniform float u_baseColorTextureTransformRotation; // initialValue=0
uniform vec2 u_metallicRoughnessTextureTransformScale; // initialValue=(1,1)
uniform vec2 u_metallicRoughnessTextureTransformOffset; // initialValue=(0,0)
uniform float u_metallicRoughnessTextureTransformRotation; // initialValue=0
uniform int u_baseColorTexcoordIndex; // initialValue=0
uniform int u_metallicRoughnessTexcoordIndex; // initialValue=0
uniform int u_occlusionTexcoordIndex; // initialValue=0
uniform vec2 u_occlusionTextureTransformScale; // initialValue=(1,1)
uniform vec2 u_occlusionTextureTransformOffset; // initialValue=(0,0)
uniform float u_occlusionTextureTransformRotation; // initialValue=0
uniform int u_emissiveTexcoordIndex; // initialValue=0
uniform vec2 u_emissiveTextureTransformScale; // initialValue=(1,1)
uniform vec2 u_emissiveTextureTransformOffset; // initialValue=(0,0)
uniform float u_emissiveTextureTransformRotation; // initialValue=0
uniform float u_occlusionStrength; // initialValue=1
uniform bool u_inverseEnvironment; // initialValue=false
uniform float u_ior; // initialValue=1.5

#ifdef RN_USE_NORMAL_TEXTURE
  uniform sampler2D u_normalTexture; // initialValue=(2,black)
  uniform vec2 u_normalTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_normalTextureTransformOffset; // initialValue=(0,0)
  uniform float u_normalTextureTransformRotation; // initialValue=0
  uniform int u_normalTexcoordIndex; // initialValue=0
  uniform float u_normalScale; // initialValue=(1)
#endif

#ifdef RN_USE_CLEARCOAT
  uniform float u_clearcoatFactor; // initialValue=0
  uniform float u_clearcoatRoughnessFactor; // initialValue=0
  uniform vec2 u_clearcoatTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_clearcoatTextureTransformOffset; // initialValue=(0,0)
  uniform float u_clearcoatTextureTransformRotation; // initialValue=0
  uniform vec2 u_clearcoatRoughnessTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_clearcoatRoughnessTextureTransformOffset; // initialValue=(0,0)
  uniform float u_clearcoatRoughnessTextureTransformRotation; // initialValue=0
  uniform vec2 u_clearcoatNormalTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_clearcoatNormalTextureTransformOffset; // initialValue=(0,0)
  uniform float u_clearcoatNormalTextureTransformRotation; // initialValue=0
  uniform int u_clearcoatTexcoordIndex; // initialValue=0
  uniform int u_clearcoatRoughnessTexcoordIndex; // initialValue=0
  uniform int u_clearcoatNormalTexcoordIndex; // initialValue=0
#endif

#ifdef RN_USE_TRANSMISSION
  uniform float u_transmissionFactor; // initialValue=(0)
  uniform vec2 u_transmissionTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_transmissionTextureTransformOffset; // initialValue=(0,0)
  uniform float u_transmissionTextureTransformRotation; // initialValue=0
  uniform int u_transmissionTexcoordIndex; // initialValue=0
#endif

#ifdef RN_USE_VOLUME
  uniform float u_thicknessFactor; // initialValue=(0)
  uniform float u_attenuationDistance; // initialValue=(0.000001)
  uniform vec3 u_attenuationColor; // initialValue=(1,1,1)
  uniform vec2 u_thicknessTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_thicknessTextureTransformOffset; // initialValue=(0,0)
  uniform float u_thicknessTextureTransformRotation; // initialValue=0
  uniform int u_thicknessTexcoordIndex; // initialValue=0
#endif

#ifdef RN_USE_SHEEN
  uniform vec3 u_sheenColorFactor; // initialValue=(0,0,0)
  uniform float u_sheenRoughnessFactor; // initialValue=(0)
  uniform vec2 u_sheenColorTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_sheenColorTextureTransformOffset; // initialValue=(0,0)
  uniform float u_sheenColorTextureTransformRotation; // initialValue=0
  uniform int u_sheenColorTexcoordIndex; // initialValue=0
  uniform vec2 u_sheenRoughnessTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_sheenRoughnessTextureTransformOffset; // initialValue=(0,0)
  uniform float u_sheenRoughnessTextureTransformRotation; // initialValue=0
  uniform int u_sheenRoughnessTexcoordIndex; // initialValue=0
#endif

#ifdef RN_USE_SPECULAR
  uniform float u_specularFactor; // initialValue=1.0
  uniform vec3 u_specularColorFactor; // initialValue=(1,1,1)
  uniform vec2 u_specularTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_specularTextureTransformOffset; // initialValue=(0,0)
  uniform float u_specularTextureTransformRotation; // initialValue=0
  uniform int u_specularTexcoordIndex; // initialValue=0
  uniform vec2 u_specularColorTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_specularColorTextureTransformOffset; // initialValue=(0,0)
  uniform float u_specularColorTextureTransformRotation; // initialValue=0
  uniform int u_specularColorTexcoordIndex; // initialValue=0
#endif

#ifdef RN_USE_IRIDESCENCE
  uniform float u_iridescenceFactor; // initialValue=0
  uniform float u_iridescenceIor; // initialValue=1.3
  uniform float u_iridescenceThicknessMinimum; // initialValue=100
  uniform float u_iridescenceThicknessMaximum; // initialValue=400
  uniform vec2 u_iridescenceTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_iridescenceTextureTransformOffset; // initialValue=(0,0)
  uniform float u_iridescenceTextureTransformRotation; // initialValue=0
  uniform int u_iridescenceTexcoordIndex; // initialValue=0
  uniform vec2 u_iridescenceThicknessTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_iridescenceThicknessTextureTransformOffset; // initialValue=(0,0)
  uniform float u_iridescenceThicknessTextureTransformRotation; // initialValue=0
  uniform int u_iridescenceThicknessTexcoordIndex; // initialValue=0
#endif

#ifdef RN_USE_ANISOTROPY
  uniform float u_anisotropyStrength; // initialValue=0
  uniform vec2 u_anisotropyRotation; // initialValue=(1,0)
  uniform vec2 u_anisotropyTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_anisotropyTextureTransformOffset; // initialValue=(0,0)
  uniform float u_anisotropyTextureTransformRotation; // initialValue=0
  uniform int u_anisotropyTexcoordIndex; // initialValue=0
#endif

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  uniform float u_diffuseTransmissionFactor; // initialValue=0
  uniform vec3 u_diffuseTransmissionColorFactor; // initialValue=(1,1,1)
  uniform vec2 u_diffuseTransmissionTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_diffuseTransmissionTextureTransformOffset; // initialValue=(0,0)
  uniform float u_diffuseTransmissionTextureTransformRotation; // initialValue=0
  uniform int u_diffuseTransmissionTexcoordIndex; // initialValue=0
  uniform vec2 u_diffuseTransmissionColorTextureTransformScale; // initialValue=(1,1)
  uniform vec2 u_diffuseTransmissionColorTextureTransformOffset; // initialValue=(0,0)
  uniform float u_diffuseTransmissionColorTextureTransformRotation; // initialValue=0
  uniform int u_diffuseTransmissionColorTexcoordIndex; // initialValue=0
#endif

#ifdef RN_USE_DISPERSION
  uniform float u_dispersion; // initialValue=0
#endif

uniform float u_alphaCutoff; // initialValue=(0.01)

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

struct Light {
  int type; // 0 = directional, 1 = point, 2 = spot
  vec3 position;
  vec3 intensity;
  vec3 attenuatedIntensity;
  vec3 directionOfLightObject;
  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)
  vec3 pointToLight; // not normalized
  float innerConeCos;
  float outerConeCos;
  float effectiveRange;
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
float getRangeAttenuation(Light light)
{
  float distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
float getSpotAttenuation(Light light)
{
  float actualCos = dot(light.direction, -light.directionOfLightObject);
  if (actualCos > light.outerConeCos) {
    if (actualCos < light.innerConeCos) {
      float attenuation = (actualCos - light.outerConeCos) / (light.innerConeCos - light.outerConeCos);
      return attenuation * attenuation;
    }
    return 1.0;
  }
  return 0.0;
}

vec3 getLightAttenuated(Light light) {
  light.attenuatedIntensity = light.intensity;
  // if (light.type == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light && Spot Light
  if (light.type != 0)
  {
    light.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot Light
  if (light.type == 2)
  {
    light.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return light.attenuatedIntensity;
}

Light getLight(int lightIdx, vec3 v_position_inWorld) {
  vec3 lightPosition = get_lightPosition(0.0, lightIdx);
  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);
  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);
  vec4 lightProperty = get_lightProperty(0.0, lightIdx);
  Light light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  float lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.innerConeCos = lightProperty.z;
  light.outerConeCos = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3(0.0);
    light.type = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.type = 1;
  } else { // is Directional Light
    light.type = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.type = 2;
  }

  const float M_PI = 3.141592653589793;
  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  light.attenuatedIntensity = getLightAttenuated(light);

  return light;
}


/* shaderity: @{matricesGetters} */

#ifdef RN_USE_SHADOW_MAPPING
  uniform float u_pointLightFarPlane; // initialValue=1000.0
  uniform float u_pointLightShadowMapUvScale; // initialValue=0.93
#endif

#ifdef RN_USE_SHADOW_MAPPING

const float g_minVariance = 0.00001;

float chebyshevUpperBound(vec2 moments, float t) {
  float p = (t <= moments.x) ? 1.0 : 0.0;

  float variance = moments.y - sq(moments.x);
  variance = max(variance, g_minVariance);

  float d = t - moments.x;
  float p_max = variance / (variance + sq(d));

  return max(p, p_max);
}

float varianceShadowContribution(vec2 lightTexCoord, float distanceToLight, int depthTextureIndex) {
  vec2 moments = texture(u_depthTexture, vec3(lightTexCoord, depthTextureIndex)).xy;

  return chebyshevUpperBound(moments, distanceToLight);
}

float varianceShadowContributionParaboloid(vec3 worldPos, vec3 lightPos, float farPlane, float uvScale, int depthTextureIndex) {
  vec3 L = worldPos - lightPos;
  float currentDist = length(L);
  vec3 Lnorm = normalize(L);

  // Determine whether it is front or back simply by the sign of the z component
  bool isFront = (Lnorm.z >= 0.0);

  // Denominators for paraboloid projection
  float denom = 1.0 + (isFront ? Lnorm.z : -Lnorm.z);

  // Convert to UV coordinates (normalized)
  // Lnorm.xy / denom is in [-1,1], so map it to [0,1]
  vec2 uv = (Lnorm.xy / denom) * uvScale * 0.5 + 0.5;

  vec2 storedMoments = isFront
      ? texture(u_paraboloidDepthTexture, vec3(uv, depthTextureIndex)).rg
      : texture(u_paraboloidDepthTexture, vec3(uv, depthTextureIndex)).ba;
      // : vec2(texture(u_paraboloidDepthTexture, uv).b, sq(texture(u_paraboloidDepthTexture, uv).b));
      // : vec2(sqrt(texture(u_paraboloidDepthTexture, uv).a), texture(u_paraboloidDepthTexture, uv).a);

  float currentDepth = currentDist / farPlane;


  return chebyshevUpperBound(storedMoments, currentDepth);

  // float shadow = (currentDepth > storedMoments.r + 0.00001) ? 0.5 : 1.0;
  // return shadow;
}


#endif



// https://github.com/KhronosGroup/glTF-Sample-Renderer
// Modified by Yuki Shimada

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

float angular_n_h(float NH) {
  return acos(NH);
}

float d_phong(float NH, float c1) {
  return pow(
    cos(acos(NH))
    , c1
  );
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec2 envBRDFApprox( float Roughness, float NoV ) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022 );
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );
  vec4 r = Roughness * c0 + c1;
  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}

// GGX NDF
float d_GGX(float NH, float alphaRoughness) {
  float roughnessSqr = alphaRoughness * alphaRoughness;
  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

float d_torrance_reiz(float NH, float c3) {
  float CosSquared = NH*NH;
  float TanSquared = (1.0 - CosSquared)/CosSquared;
  //return (1.0/M_PI) * sq(c3/(CosSquared * (c3*c3 + TanSquared)));  // gamma = 2, aka GGX
  return (1.0/sqrt(M_PI)) * (sq(c3)/(CosSquared * (c3*c3 + TanSquared))); // gamma = 1, D_Berry
}

float d_beckmann(float NH, float m) {
  float co = 1.0 / (4.0 * m * m * NH * NH * NH * NH);
  float expx = exp((NH * NH - 1.0) / (m * m * NH * NH));
  return co * expx;
}

// the same as glTF WebGL sample
// https://github.com/KhronosGroup/glTF-WebGL-PBR/blob/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders/pbr-frag.glsl#L188
// That is, Unreal Engine based approach, but modified to use alphaRoughness (squared artist's roughness parameter),
// and based on 'Separable Masking and Shadowing' approximation (propesed by Christophe Schlick)
// https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf
float g_shielding(float NL, float NV, float alphaRoughness) {
  float r = alphaRoughness;

  // Local Shadowing using "Schlick-Smith" Masking Function
  float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));

  // Local Masking using "Schlick-Smith" Masking Function
  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));

  return localShadowing * localMasking;
}

// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
float v_GGXCorrelated(float NL, float NV, float alphaRoughness) {
  float a2 = alphaRoughness * alphaRoughness;
  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  float GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  float GGX = GGXV + GGXL;
  if (GGX > 0.0) {
    return clamp(0.5 / GGX, 0.0, 1.0);
  }
  return 1.0;
}

float v_GGXCorrelatedFast(float NL, float NV, float alphaRoughness) {
  float a = alphaRoughness;
  float GGXV = NL * (NV * (1.0 - a) + a);
  float GGXL = NV * (NL * (1.0 - a) + a);
  float GGX = GGXV + GGXL;
  if (GGX > 0.0) {
    return 0.5 / GGX;
  }
  return 0.0;
}

// The Schlick Approximation to Fresnel
float fresnelSchlick(float f0, float f90, float VdotH) {
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

vec3 fresnelSchlick(vec3 f0, vec3 f90, float VdotH) {
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

vec3 fresnelSchlick(vec3 f0, float f90, float VdotH)
{
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

float fresnelSchlick(float f0, float VdotH)
{
  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelSchlick(f0, f90, VdotH);
}
vec3 fresnelSchlick(vec3 f0, float VdotH)
{
  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelSchlick(f0, f90, VdotH);
}

vec3 BRDF_specularGGX(float NH, float NL, float NV, float alphaRoughness) {
  float D = d_GGX(NH, alphaRoughness);
  float V = v_GGXCorrelated(NL, NV, alphaRoughness);
  return vec3(D) * vec3(V);
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf
vec3 BRDF_lambertian(vec3 diffuseAlbedo)
{
  // (1/pi) * diffuseAlbedo
  return diffuseAlbedo * RECIPROCAL_PI;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#specular-brdf
float specular_brdf(float alphaRoughness, float NdotL, float NdotV, float NdotH) {
  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  float D = d_GGX(NdotH, alphaRoughness);
  return V * D;
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes
float specular_btdf(float alphaRoughness, float NdotL, float NdotV, float NdotHt) {
  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  float D = d_GGX(NdotHt, alphaRoughness);
  return V * D;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel
vec3 conductor_fresnel(vec3 f0, float brdf, float alphaRoughness, float VdotH) {
  return vec3(brdf) * (f0.rgb + (vec3(1.0) - f0.rgb) * vec3(pow(1.0 - abs(VdotH), 5.0)));
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel
vec3 fresnel_mix(float ior, vec3 base, vec3 layer, float VdotH) {
  float f0 = pow((1.0 - ior)/(1.0 + ior), 2.0);
  float fr = f0 + (1.0 - f0) * pow(1.0 - abs(VdotH), 5.0);
  return mix(base, layer, fr);
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf
vec3 metal_brdf(float perceptualRoughness, vec3 baseColor, float NdotL, float NdotV, float NdotH, float VdotH) {
  float alphaRoughness = perceptualRoughness * perceptualRoughness;
  return conductor_fresnel(
    baseColor,
    specular_brdf(alphaRoughness, NdotL, NdotV, NdotH),
    alphaRoughness,
    VdotH
  );
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf
// vec3 dielectric_brdf(float ior, vec3 baseColor, float perceptualRoughness, float NdotL, float NdotV, float NdotH, float VdotH) {
//   vec3 base = BRDF_lambertian(baseColor);
//   float alphaRoughness = perceptualRoughness * perceptualRoughness;
//   vec3 layer = vec3(specular_brdf(alphaRoughness, NdotL, NdotV, NdotH));
//   return fresnel_mix(ior, base, layer, VdotH);
// }

vec3 srgbToLinear(vec3 srgbColor) {
  return pow(srgbColor, vec3(2.2));
}

float srgbToLinear(float value) {
  return pow(value, 2.2);
}

vec3 linearToSrgb(vec3 linearColor) {
  return pow(linearColor, vec3(1.0/2.2));
}

float linearToSrgb(float value) {
  return pow(value, 1.0/2.2);
}

// Roughness Dependent Fresnel
// https://www.jcgt.org/published/0008/01/03/paper.pdf
vec3 fresnelSchlickRoughness(vec3 F0, float cosTheta, float roughness)
{
  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;
  vec3 k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);
  return k_S;
}

// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66
vec3 Schlick_to_F0(vec3 f, vec3 f90, float VdotH) {
    float x = clamp(1.0 - VdotH, 0.0, 1.0);
    float x2 = x * x;
    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

float Schlick_to_F0(float f, float f90, float VdotH) {
    float x = clamp(1.0 - VdotH, 0.0, 1.0);
    float x2 = x * x;
    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

vec3 Schlick_to_F0(vec3 f, float VdotH) {
    return Schlick_to_F0(f, vec3(1.0), VdotH);
}

float Schlick_to_F0(float f, float VdotH) {
    return Schlick_to_F0(f, 1.0, VdotH);
}

vec3 normalBlendingUDN(sampler2D baseMap, sampler2D detailMap, vec2 baseUv, vec2 detailUv) {
  vec3 t = texture(baseMap,   baseUv).xyz * 2.0 - 1.0;
  vec3 u = texture(detailMap, detailUv).xyz * 2.0 - 1.0;
  vec3 r = normalize(vec3(t.xy + u.xy, t.z));
  return r;
}

vec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {
  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  mat3 rotationMat = mat3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  mat3 matrix = translationMat * rotationMat * scaleMat;
  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;

  return uvTransformed;
}

float IsotropicNDFFiltering(vec3 normal, float roughness2) {
  float SIGMA2 = 0.15915494;
  float KAPPA = 0.18;
  vec3 dndu = dFdx(normal);
  vec3 dndv = dFdy(normal);
  float kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));
  float clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);
  float filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);
  return filteredRoughness2;
}

////////////////////////////////////////
// glTF KHR_materials_transmission
////////////////////////////////////////

#ifdef RN_USE_TRANSMISSION
// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
vec3 volumeAttenuation(vec3 attenuationColor, float attenuationDistance, vec3 intensity, float transmissionDistance)
{
  if (attenuationDistance == 0.0) { // means Infinite distance
    return intensity; // No attenuation
  } else {
    // vec3 attenuationCo = -log(attenuationColor) / attenuationDistance;
    // vec3 attenuatedTransmittance = exp(-attenuationCo * transmissionDistance);
    vec3 attenuatedTransmittance = pow(attenuationColor, vec3(transmissionDistance / attenuationDistance));
    return intensity * attenuatedTransmittance;
  }
}

// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer
vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior)
{
  vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);
  mat4 worldMatrix = get_worldMatrix(v_instanceInfo);

  vec3 modelScale;
  modelScale.x = length(vec3(worldMatrix[0].xyz));
  modelScale.y = length(vec3(worldMatrix[1].xyz));
  modelScale.z = length(vec3(worldMatrix[2].xyz));

  return normalize(refractionVector) * thickness * modelScale;
}

float applyIorToRoughness(float roughness, float ior)
{
  return clamp(roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0), c_MinRoughness, 1.0);
}

vec3 calculateRadianceTransmission(vec3 normal, vec3 view, vec3 pointToLight, float alphaRoughness, vec3 baseColor, float ior)
{
  float transmissionRoughness = applyIorToRoughness(alphaRoughness, ior);

  vec3 n = normalize(normal);
  vec3 v = normalize(view);
  vec3 l = normalize(pointToLight);
  vec3 mirrorL = normalize(l + 2.0 * n * dot(-l, n));
  vec3 h = normalize(mirrorL + v);

  float D = d_GGX(clamp(dot(n, h), 0.0, 1.0), transmissionRoughness);
  float V = v_GGXCorrelated(clamp(dot(n, mirrorL), 0.0, 1.0), clamp(dot(n, v), 0.0, 1.0), transmissionRoughness);

  return baseColor * D * V;
}

#endif


////////////////////////////////////////
// glTF KHR_materials_anisotropy
////////////////////////////////////////
#ifdef RN_USE_ANISOTROPY
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
float D_GGX_anisotropic(float NdotH, float TdotH, float BdotH, float at, float ab)
{
    float a2 = at * ab;
    vec3 f = vec3(ab * TdotH, at * BdotH, a2 * NdotH);
    float w2 = a2 / dot(f, f);
    return a2 * w2 * w2 / M_PI;
}

float V_GGX_anisotropic(float NdotL, float NdotV, float BdotV, float TdotV, float TdotL, float BdotL,
    float at, float ab)
{
    float GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));
    float GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));
    float GGX = GGXV + GGXL;
    if (GGX > 0.0) {
      return clamp(0.5 / GGX, 0.0, 1.0);
    }
    return 1.0;
}

vec3 BRDF_specularAnisotropicGGX(float alphaRoughness,
    float VdotH, float NdotL, float NdotV, float NdotH, float BdotV, float TdotV,
    float TdotL, float BdotL, float TdotH, float BdotH, float anisotropy)
{
    float at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
    float ab = clamp(alphaRoughness, 0.001, 1.0);

    float V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);
    float D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);

    return vec3(V * D);
}
#endif



////////////////////////////////////////
// glTF KHR_materials_sheen
////////////////////////////////////////

#ifdef RN_USE_SHEEN
float d_Charlie(float sheenPerceptualRoughness, float NoH) {
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  float sheenRoughness = max(sheenPerceptualRoughness, 0.000001);
  float alphaG = sheenRoughness * sheenRoughness;
  float invAlpha  = 1.0 / alphaG;
  float cos2h = NoH * NoH;
  float sin2h = 1.0 - cos2h;
  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
float sheenSimpleVisibility(float NdotL, float NdotV) {
  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
float charlieL(float x, float alphaG) {
  float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
  float a = mix(21.5473, 25.3245, oneMinusAlphaSq);
  float b = mix(3.82987, 3.32435, oneMinusAlphaSq);
  float c = mix(0.19823, 0.16801, oneMinusAlphaSq);
  float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
  float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
  return a / (1.0 + b * pow(x, c)) + d * x + e;
}

float lambdaSheen(float cosTheta, float alphaG)
{
  return abs(cosTheta) < 0.5 ? exp(charlieL(cosTheta, alphaG)) : exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG));
}

float sheenCharlieVisibility(float NdotL, float NdotV, float sheenPerceptualRoughness) {
  float sheenRoughness = max(sheenPerceptualRoughness, 0.000001);
  float alphaG = sheenRoughness * sheenRoughness;
  float sheenVisibility = clamp(1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL)), 0.0, 1.0);
  return sheenVisibility;
}

vec3 BRDF_specularSheen(vec3 sheenColor, float sheenPerceptualRoughness, float NdotL, float NdotV, float NdotH) {
  float sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);
  float sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);
  return sheenColor * sheenDistribution * sheenVisibility;
}
#endif









////////////////////////////////////////
// glTF KHR_materials_irirdescence
////////////////////////////////////////

#ifdef RN_USE_IRIDESCENCE
// XYZ to REC709(sRGB) conversion matrix
const mat3 XYZ_TO_REC709 = mat3(
     3.2404542, -0.9692660,  0.0556434,
    -1.5371385,  1.8760108, -0.2040259,
    -0.4985314,  0.0415560,  1.0572252
);

vec3 fresnelSchlickRoughnessWithIridescence(
  vec3 F0, float cosTheta, float roughness,
  vec3 iridescenceFresnel, float iridescence
  )
{
  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;
  vec3 k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);
  return k_S;
}

// Assume air interface for top
vec3 Fresnel0ToIor(vec3 F0) {
    vec3 sqrtF0 = sqrt(F0);
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// Conversion from IOR to F0
// ior is a value between 1.0 and 3.0. 1.0 is air interface
vec3 IorToFresnel0(vec3 transmittedIor, float incidentIor) {
    return sq((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
float IorToFresnel0(float transmittedIor, float incidentIor) {
    return sq((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration
 */
vec3 evalSensitivity(float OPD, vec3 shift) {
    float phase = 2.0 * M_PI * OPD * 1.0e-9;
    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);

    vec3 xyz = val * sqrt(2.0 * M_PI * var) * cos(pos * phase + shift) * exp(-(phase * phase) * var);
    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));
    xyz /= 1.0685e-7;

    vec3 rgb = XYZ_TO_REC709 * xyz;
    return rgb;
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel
 */
vec3 calcIridescence(float outsideIor, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {


  // iridescenceIor is the index of refraction of the thin-film layer
  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
  float iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));

  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)
  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.
  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.
  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):
  float sinTheta2Sq = sq(outsideIor / iridescenceIor) * (1.0 - sq(cosTheta1));
  float cosTheta2Sq = 1.0 - sinTheta2Sq;

  // Handle total internal reflection
  if (cosTheta2Sq < 0.0) {
      return vec3(1.0);
  }

  float cosTheta2 = sqrt(cosTheta2Sq);

  /// Material Interfaces
  // The iridescence model defined by Belcour/Barla models two material interfaces
  // - one from the outside to the thin-film layer
  // and another one from the thin-film to the base material. These two interfaces are defined as follows:

  // First interface (from the outside to the thin-film layer)
  float R0 = IorToFresnel0(iridescenceIor, outsideIor);
  float R12 = fresnelSchlick(R0, cosTheta1);
  float R21 = R12;
  float T121 = 1.0 - R12;

  // Second interface (from the thin-film to the base material)
  vec3 baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0
  vec3 R1 = IorToFresnel0(baseIor, iridescenceIor);
  vec3 R23 = fresnelSchlick(R1, cosTheta2);

  // phi12 and phi23 define the base phases per interface and are approximated with 0.0
  // if the IOR of the hit material (iridescenceIor or baseIor) is higher
  // than the IOR of the previous material (outsideIor or iridescenceIor) and \u03C0 otherwise.
  // Also here, polarization is ignored.  float phi12 = 0.0;

  // First interface (from the outside to the thin-film layer)
  float phi12 = 0.0;
  if (iridescenceIor < outsideIor) phi12 = M_PI;
  float phi21 = M_PI - phi12;

  // Second interface (from the thin-film to the base material)
  vec3 phi23 = vec3(0.0);
  if (baseIor[0] < iridescenceIor) phi23[0] = M_PI;
  if (baseIor[1] < iridescenceIor) phi23[1] = M_PI;
  if (baseIor[2] < iridescenceIor) phi23[2] = M_PI;

  // OPD (optical path difference)
  float OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
  // Phase shift
  vec3 phi = vec3(phi21) + phi23;

  // Compound terms
  vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);
  vec3 r123 = sqrt(R123);
  vec3 Rs = (T121 * T121) * R23 / (vec3(1.0) - R123);

  // Reflectance term for m = 0 (DC term amplitude)
  vec3 C0 = R12 + Rs;
  vec3 I = C0;

  // Reflectance term for m > 0 (pairs of diracs)
  vec3 Cm = Rs - T121;
  for (int m = 1; m <= 2; ++m)
  {
      Cm *= r123;
      vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);
      I += Cm * Sm;
  }

  vec3 F_iridescence = max(I, vec3(0.0));

  return F_iridescence;
}

//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB
vec3 BRDF_lambertianIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float iridescenceFactor, vec3 diffuseColor, float specularWeight, float VdotH)
{
    vec3 iridescenceFresnelMax = vec3(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));
    vec3 schlickFresnel = Schlick_to_F0(f0, f90, VdotH);
    vec3 F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);

    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);
}

vec3 BRDF_specularGGXIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float alphaRoughness, float iridescenceFactor, float specularWeight, float VdotH, float NdotL, float NdotV, float NdotH)
{
    vec3 F = mix(Schlick_to_F0(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);
    float Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
    float D = d_GGX(NdotH, alphaRoughness);

    return specularWeight * F * Vis * D;
}

vec3 rgb_mix(vec3 base, vec3 specular_brdf, vec3 rgb_alpha)
{
    float rgb_alpha_max = max(rgb_alpha.r, max(rgb_alpha.g, rgb_alpha.b));
    return (1.0 - rgb_alpha_max) * base + rgb_alpha * specular_brdf;
}

#endif // RN_USE_IRIDESCENCE





////////////////////////////////////////
// lighting with a punctual light
////////////////////////////////////////
vec3 lightingWithPunctualLight(
  Light light,
  vec3 normal_inWorld,
  vec3 viewDirection,
  float NdotV,
  vec3 baseColor,
  float perceptualRoughness,
  float metallic,
  vec3 dielectricF0,
  vec3 dielectricF90,
  float ior,
  float transmission,
  float thickness,
  float clearcoat,
  float clearcoatRoughness,
  vec3 clearcoatF0,
  vec3 clearcoatF90,
  vec3 clearcoatFresnel,
  vec3 clearcoatNormal_inWorld,
  float VdotNc,
  vec3 attenuationColor,
  float attenuationDistance,
  float anisotropy,
  vec3 anisotropicT,
  vec3 anisotropicB,
  float BdotV,
  float TdotV,
  vec3 sheenColor,
  float sheenRoughness,
  float albedoSheenScalingNdotV,
  float iridescence,
  vec3 iridescenceFresnel_dielectric,
  vec3 iridescenceFresnel_metal,
  float specularWeight,
  float diffuseTransmission,
  vec3 diffuseTransmissionColor,
  float diffuseTransmissionThickness
  )
{
  float alphaRoughness = perceptualRoughness * perceptualRoughness;

  // Fresnel
  vec3 halfVector = normalize(light.direction + viewDirection);
  float VdotH = saturate(dot(viewDirection, halfVector));
  vec3 dielectricFresnel = fresnelSchlick(dielectricF0, dielectricF90, VdotH);
  vec3 metalFresnel = fresnelSchlick(baseColor, vec3(1.0), VdotH);

  float NdotL = saturateEpsilonToOne(dot(normal_inWorld, light.direction));

  // Diffuse
  vec3 diffuseBrdf = BRDF_lambertian(baseColor);
  vec3 diffuseContrib = diffuseBrdf * vec3(NdotL) * light.attenuatedIntensity;

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  diffuseContrib = diffuseContrib * (vec3(1.0) - diffuseTransmission);
  if (dot(normal_inWorld, light.direction) < 0.0) {
    float diffuseNdotL = saturate(dot(normal_inWorld, -light.direction));
    vec3 diffuseBtdf = BRDF_lambertian(diffuseTransmissionColor) * vec3(diffuseNdotL) * light.attenuatedIntensity;
    vec3 mirrorL = normalize(light.direction + 2.0 * normal_inWorld * dot(normal_inWorld, -light.direction));
    float diffuseVdotH = saturate(dot(viewDirection, normalize(mirrorL + viewDirection)));
    dielectricFresnel = fresnelSchlick(dielectricF0 * specularWeight, dielectricF90, abs(diffuseVdotH));
#ifdef RN_USE_VOLUME
    diffuseBtdf = volumeAttenuation(attenuationColor, attenuationDistance, diffuseBtdf, diffuseTransmissionThickness);
#endif // RN_USE_VOLUME
    diffuseContrib += diffuseBtdf * diffuseTransmission;
  }
#endif // RN_USE_DIFFUSE_TRANSMISSION


#ifdef RN_USE_TRANSMISSION
  vec3 transmittionRay = getVolumeTransmissionRay(normal_inWorld, viewDirection, thickness, ior);
  light.pointToLight -= transmittionRay;
  light.direction = normalize(light.pointToLight);
  vec3 transmittedContrib = calculateRadianceTransmission(normal_inWorld, viewDirection, light.direction, alphaRoughness, baseColor, ior) * light.attenuatedIntensity;

#ifdef RN_USE_VOLUME
  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittionRay));
#endif // RN_USE_VOLUME

  diffuseContrib = mix(diffuseContrib, vec3(transmittedContrib), transmission);
#endif // RN_USE_TRANSMISSION

  light.attenuatedIntensity = getLightAttenuated(light);
  // Specular
  float NdotH = saturate(dot(normal_inWorld, halfVector));

#ifdef RN_USE_ANISOTROPY
  float TdotL = dot(anisotropicT, light.direction);
  float BdotL = dot(anisotropicB, light.direction);
  float TdotH = dot(anisotropicT, halfVector);
  float BdotH = dot(anisotropicB, halfVector);
  vec3 specularMetalContrib = BRDF_specularAnisotropicGGX(alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3(NdotL) * light.attenuatedIntensity;
  vec3 specularDielectricContrib = specularMetalContrib;
#else
  vec3 specularMetalContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, alphaRoughness) * vec3(NdotL) * light.attenuatedIntensity;
  vec3 specularDielectricContrib = specularMetalContrib;
#endif // RN_USE_ANISOTROPY

  // Base Layer
  vec3 metal = specularMetalContrib * metalFresnel;
  vec3 dielectric = mix(diffuseContrib, specularDielectricContrib, dielectricFresnel);

#ifdef RN_USE_IRIDESCENCE
  metal = mix(metal, specularMetalContrib * iridescenceFresnel_metal, iridescence);
  dielectric = mix(dielectric, rgb_mix(diffuseContrib, specularDielectricContrib, iridescenceFresnel_dielectric), iridescence);
#endif // RN_USE_IRIDESCENCE

#ifdef RN_USE_CLEARCOAT
  // Clear Coat Layer
  float NdotHc = saturate(dot(clearcoatNormal_inWorld, halfVector));
  float LdotNc = saturate(dot(light.direction, clearcoatNormal_inWorld));
  vec3 clearcoatContrib = BRDF_specularGGX(NdotHc, LdotNc, VdotNc, clearcoatRoughness * clearcoatRoughness) * vec3(LdotNc) * light.attenuatedIntensity;
#else
  vec3 clearcoatContrib = vec3(0.0);
#endif // RN_USE_CLEARCOAT

#ifdef RN_USE_SHEEN
  // Sheen
  vec3 sheenContrib = BRDF_specularSheen(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;
  float albedoSheenScaling = min(
    albedoSheenScalingNdotV,
    1.0 - max3(sheenColor) * texture(u_sheenLutTexture, vec2(NdotL, sheenRoughness)).r);
#else
  vec3 sheenContrib = vec3(0.0);
  float albedoSheenScaling = 1.0;
#endif // RN_USE_SHEEN

  vec3 color = mix(dielectric, metal, metallic);
  color = sheenContrib + color * albedoSheenScaling;
  color = mix(color, clearcoatContrib, clearcoat * clearcoatFresnel);

  return color;
}

// This file includes portions of code from the glTF-Sample-Renderer project by Khronos Group (Apache License 2.0).
// https://github.com/KhronosGroup/glTF-Sample-Renderer
// Modified by Yuki Shimada


vec3 getIBLIrradiance(vec3 normal_forEnv, vec4 iblParameter, ivec2 hdriFormat) {
  vec4 diffuseTexel = texture(u_diffuseEnvTexture, normal_forEnv);

  vec3 irradiance;
  if (hdriFormat.x == 0) {
    // LDR_SRGB
    irradiance = srgbToLinear(diffuseTexel.rgb);
  }
  else if (hdriFormat.x == 3) {
    // RGBE
    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  }
  else {
    irradiance = diffuseTexel.rgb;
  }

  // scale with user parameters
  float IBLDiffuseContribution = iblParameter.y;
  irradiance *= IBLDiffuseContribution;

  return irradiance;
}

float scaleForLod(float perceptualRoughness, float ior)
{
  // Scale roughness to the range [0, 1],
  // ior=1.0 will be scale 0,
  // ior=1.5 will be scale 1.0,
  // ior=2 will be scale 1.0 (clamped)
  //

  float scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);
  return perceptualRoughness * scale;
}

#ifdef RN_USE_TRANSMISSION
vec3 get_sample_from_backbuffer(vec2 sampleCoord, float perceptualRoughness, float ior) {
  ivec2 vrState = get_vrState(0.0, 0);
  vec2 backBufferTextureSize = vec2(textureSize(u_backBufferTexture, 0));
  float backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);

#ifdef WEBGL2_MULTI_VIEW
  // For VR
  backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
  sampleCoord.x = sampleCoord.x * 0.5;
  if (v_displayIdx == 1.0) { // For right eye
    sampleCoord.x += 0.5;
  }
#else
  if (vrState.x == 1) { // For VR
    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
    sampleCoord.x = sampleCoord.x * 0.5;
    if (vrState.y == 1) { // For right eye
      sampleCoord.x += 0.5;
    }
  }
#endif

  float framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);
  vec3 transmittedLight = textureLod(u_backBufferTexture, sampleCoord, framebufferLod).rgb;

  return transmittedLight;
}

vec3 getIBLVolumeRefraction(vec3 baseColor, vec3 normal, vec3 view, float cameraSID, float materialSID, float thickness, float perceptualRoughness, float ior, vec3 attenuationColor, float attenuationDistance) {
#ifdef RN_USE_DISPERSION
  float dispersion = get_dispersion(materialSID, 0);
  float halfSpread = (ior - 1.0) * 0.025 * dispersion;
  vec3 iors = vec3(ior - halfSpread, ior, ior + halfSpread);

  vec3 transmittedLight;
  float transmissionRayLength;
  for(int i=0;i<3;i++) {
    vec3 transmissionRay = getVolumeTransmissionRay(normal, view, thickness, iors[i]);
    transmissionRayLength = length(transmissionRay);
    vec3 refractedRayExit = v_position_inWorld.xyz + transmissionRay;

    vec4 ndcPos = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4(refractedRayExit, 1.0);
    vec2 refractionCoords = ndcPos.xy / ndcPos.w;
    refractionCoords += 1.0;
    refractionCoords /= 2.0;

    transmittedLight[i] = get_sample_from_backbuffer(refractionCoords, perceptualRoughness, iors[i])[i];
  }
#else
  vec3 transmissionRay = getVolumeTransmissionRay(normal, view, thickness, ior);
  float transmissionRayLength = length(transmissionRay);
  vec3 refractedRayExit = v_position_inWorld.xyz + transmissionRay;

  vec4 ndcPos = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4(refractedRayExit, 1.0);
  vec2 refractionCoords = ndcPos.xy / ndcPos.w;
  refractionCoords += 1.0;
  refractionCoords /= 2.0;

  vec3 transmittedLight = get_sample_from_backbuffer(refractionCoords, perceptualRoughness, ior);
#endif
  vec3 attenuatedColor = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, transmissionRayLength);
  return attenuatedColor * baseColor;
}

#endif // RN_USE_TRANSMISSION

vec3 get_radiance(vec3 reflection, float lod, ivec2 hdriFormat) {
  vec4 specularTexel = textureLod(u_specularEnvTexture, reflection, lod);

  vec3 radiance;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

struct IblResult
{
  vec3 specular;
  vec3 diffuse;
  vec3 FssEss;
};

vec3 getIBLRadianceGGX(float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, vec3 reflection)
{
  // get radiance
  float mipCount = iblParameter.x;
  float lod = (perceptualRoughness * (mipCount - 1.0));
  vec3 radiance = get_radiance(reflection, lod, hdriFormat);

  // scale with user parameters
  float IBLSpecularContribution = iblParameter.z;
  radiance *= IBLSpecularContribution;

  return radiance;
}

vec3 getIBLFresnelGGX(float perceptualRoughness, float NdotV, vec3 F0, float specularWeight) {
  // https://bruop.github.io/ibl/#single_scattering_results

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = vec3(specularWeight) * (kS * f_ab.x + f_ab.y);

  // Multiple scattering
  float Ems = (1.0 - (f_ab.x + f_ab.y));
  vec3 F_avg = vec3(specularWeight) * (F0 + (1.0 - F0) / 21.0);
  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);

  return FssEss + FmsEms;
}

#ifdef RN_USE_SHEEN

vec3 get_radiance_sheen(vec3 reflection, float lod, ivec2 hdriFormat) {
  vec4 specularTexel = textureLod(u_sheenEnvTexture, reflection, lod);

  vec3 radiance;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

vec3 sheenIBL(float NdotV, float sheenPerceptualRoughness, vec3 sheenColor, vec4 iblParameter, vec3 reflection, ivec2 hdriFormat)
{
  float mipCount = iblParameter.x;
  float lod = (sheenPerceptualRoughness * (mipCount - 1.0));

  vec2 sheenLutUV = vec2(NdotV, sheenPerceptualRoughness);
  float brdf = texture(u_sheenLutTexture, sheenLutUV).b;
  vec3 sheenLight = get_radiance_sheen(reflection, lod, hdriFormat);
  float IBLSpecularContribution = iblParameter.z;
  sheenLight *= IBLSpecularContribution;

  return sheenLight * sheenColor * brdf;
}
#endif

vec3 getNormalForEnv(mat3 rotEnvMatrix, vec3 normal_inWorld, float materialSID) {
  vec3 normal_forEnv = rotEnvMatrix * normal_inWorld;
  if (get_inverseEnvironment(materialSID, 0)) {
    normal_forEnv.x *= -1.0;
  }
  return normal_forEnv;
}

vec3 getReflection(mat3 rotEnvMatrix, vec3 viewDirection, vec3 normal_inWorld, float materialSID, float perceptualRoughness, float anisotropy, vec3 anisotropyDirection) {
#ifdef RN_USE_ANISOTROPY

  float tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);
  vec3  anisotropicTangent  = cross(anisotropyDirection, viewDirection);
  vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);
  float bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);
  float bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;
  vec3  bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));
  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);
#else
  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);
#endif
  if (get_inverseEnvironment(materialSID, 0)) {
    reflection.x *= -1.0;
  }
  return reflection;
}

vec3 IBLContribution(float materialSID, vec3 normal_inWorld, float NdotV, vec3 viewDirection,
  vec3 baseColor, float perceptualRoughness, float clearcoatRoughness, vec3 clearcoatNormal_inWorld,
  float clearcoat, vec3 clearcoatFresnel, float VdotNc, vec3 geomNormal_inWorld, float cameraSID, float transmission, vec3 v_position_inWorld,
  float thickness, vec3 sheenColor, float sheenRoughness, float albedoSheenScalingNdotV, float ior,
  vec3 iridescenceFresnel_dielectric, vec3 iridescenceFresnel_metal, float iridescence, float anisotropy, vec3 anisotropyDirection,
  float specularWeight, vec3 dielectricF0, float metallic, float diffuseTransmission, vec3 diffuseTransmissionColor, float diffuseTransmissionThickness)
{
  vec4 iblParameter = get_iblParameter(materialSID, 0);
  float rot = iblParameter.w;
  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);

  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  vec3 reflection = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);

  // get irradiance
  vec3 irradiance = getIBLIrradiance(normal_forEnv, iblParameter, hdriFormat);
  vec3 diffuse = irradiance * baseColor;

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  vec3 diffuseTransmissionIBL = getIBLIrradiance(-normal_forEnv, iblParameter, hdriFormat) * diffuseTransmissionColor;
#ifdef RN_USE_VOLUME
  diffuseTransmissionIBL = volumeAttenuation(attenuationColor, attenuationDistance, diffuseTransmissionIBL, diffuseTransmissionThickness);
#endif
  diffuse = mix(diffuse, diffuseTransmissionIBL, diffuseTransmission);
#endif

#ifdef RN_USE_TRANSMISSION
  vec3 attenuationColor = get_attenuationColor(materialSID, 0);
  float attenuationDistance = get_attenuationDistance(materialSID, 0);
  vec3 specularTransmission = getIBLVolumeRefraction(baseColor, normal_inWorld, viewDirection, cameraSID, materialSID, thickness, perceptualRoughness, ior, attenuationColor, attenuationDistance);
  diffuse = mix(diffuse, specularTransmission, transmission);
#endif

  // take account of anisotropy with reflection
  vec3 specularMetal = getIBLRadianceGGX(perceptualRoughness, iblParameter, hdriFormat, reflection);
  vec3 specularDielectric = specularMetal;

  // Calculate fresnel mix
  vec3 fresnelMetal = getIBLFresnelGGX(perceptualRoughness, NdotV, baseColor, 1.0);
  vec3 metalContrib = fresnelMetal * specularMetal;
  vec3 fresnelDielectric = getIBLFresnelGGX(perceptualRoughness, NdotV, dielectricF0, specularWeight);
  vec3 dielectricContrib = mix(diffuse, specularDielectric, fresnelDielectric);

#ifdef RN_USE_IRIDESCENCE
  metalContrib = mix(metalContrib, specularMetal * iridescenceFresnel_metal, iridescence);
  dielectricContrib = mix(dielectricContrib, rgb_mix(diffuse, specularDielectric, iridescenceFresnel_dielectric), iridescence);
#endif

#ifdef RN_USE_CLEARCOAT
  vec3 clearcoatReflection = getReflection(rotEnvMatrix, viewDirection, clearcoatNormal_inWorld, materialSID, clearcoatRoughness, 0.0, vec3(0.0));
  vec3 clearcoatContrib = getIBLRadianceGGX(clearcoatRoughness, iblParameter, hdriFormat, clearcoatReflection);
#else
  vec3 clearcoatContrib = vec3(0.0);
#endif

#ifdef RN_USE_SHEEN
  vec3 sheenContrib = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);
  float albedoSheenScaling = albedoSheenScalingNdotV;
#else
  vec3 sheenContrib = vec3(0.0);
  float albedoSheenScaling = 1.0;
#endif

  vec3 color = mix(dielectricContrib, metalContrib, metallic);
  color = sheenContrib + color * albedoSheenScaling;
  color = mix(color, clearcoatContrib, clearcoat * clearcoatFresnel);

  return color;
}


float edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {
  vec3 d = fwidth(bary3);
  vec3 x = bary3+vec3(1.0 - wireframeWidthInner)*d;
  vec3 a3 = smoothstep(vec3(0.0), d, x);
  float factor = min(min(a3.x, a3.y), a3.z);

  return clamp((1.0 - factor), 0.0, 1.0);
}

vec2 getTexcoord(int texcoordIndex) {
  vec2 texcoord;
  if(texcoordIndex == 2){
    texcoord = v_texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = v_texcoord_1;
  }else{
    texcoord = v_texcoord_0;
  }
  return texcoord;
}

#ifdef RN_USE_TANGENT
  mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {
    vec3 tangent_inWorld = normalize(v_tangent_inWorld);
    vec3 binormal_inWorld = normalize(v_binormal_inWorld);
    mat3 tbnMat_tangent_to_world = mat3(tangent_inWorld, binormal_inWorld, normal_inWorld);

    return tbnMat_tangent_to_world;
  }
#else
    // This is based on http://www.thetenthplanet.de/archives/1180
    mat3 cotangent_frame(vec3 normal_inWorld, vec3 position, vec2 uv) {
      uv = gl_FrontFacing ? uv : -uv;

      // get edge vectors of the pixel triangle
      vec3 dp1 = dFdx(position);
      vec3 dp2 = dFdy(position);
      vec2 duv1 = dFdx(uv);
      vec2 duv2 = dFdy(uv);

      // solve the linear system
      vec3 dp2perp = cross(dp2, normal_inWorld);
      vec3 dp1perp = cross(normal_inWorld, dp1);
      vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;
      vec3 bitangent = dp2perp * duv1.y + dp1perp * duv2.y;
      bitangent *= -1.0;

      // construct a scale-invariant frame
      float invMat = inversesqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));
      return mat3(tangent * invMat, bitangent * invMat, normal_inWorld);
    }

    mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {
      mat3 tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord);

      return tbnMat_tangent_to_world;
    }
#endif


void main ()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  // View direction
  vec3 viewPosition = get_viewPosition(cameraSID, 0);
  vec3 viewVector = viewPosition - v_position_inWorld.xyz;
  vec3 viewDirection = normalize(viewVector);

  // BaseColor
  vec3 baseColor = vec3(0.0, 0.0, 0.0);
  float alpha = 1.0;
  vec4 baseColorFactor = get_baseColorFactor(materialSID, 0);
  if (v_color != baseColor && baseColorFactor.rgb != baseColor) {
    baseColor = v_color * baseColorFactor.rgb;
    alpha = baseColorFactor.a;
  } else if (v_color == baseColor) {
    baseColor = baseColorFactor.rgb;
    alpha = baseColorFactor.a;
  } else if (baseColorFactor.rgb == baseColor) {
    baseColor = v_color;
  } else {
    baseColor = vec3(1.0, 1.0, 1.0);
  }
  vec2 baseColorTextureTransformScale = get_baseColorTextureTransformScale(materialSID, 0);
  vec2 baseColorTextureTransformOffset = get_baseColorTextureTransformOffset(materialSID, 0);
  float baseColorTextureTransformRotation = get_baseColorTextureTransformRotation(materialSID, 0);
  int baseColorTexcoordIndex = get_baseColorTexcoordIndex(materialSID, 0);
  vec2 baseColorTexcoord = getTexcoord(baseColorTexcoordIndex);
  vec2 baseColorTexUv = uvTransform(baseColorTextureTransformScale, baseColorTextureTransformOffset, baseColorTextureTransformRotation, baseColorTexcoord);
  vec4 textureColor = texture(u_baseColorTexture, baseColorTexUv);
  baseColor *= srgbToLinear(textureColor.rgb);
  alpha *= textureColor.a;

#ifdef RN_IS_ALPHA_MODE_MASK
  float alphaCutoff = get_alphaCutoff(materialSID, 0);
  if (alpha < alphaCutoff) {
    discard;
  }
#endif


  // Normal
  vec3 normal_inWorld = normalize(v_normal_inWorld);
  vec3 geomNormal_inWorld = normal_inWorld;
  #ifdef RN_USE_NORMAL_TEXTURE
    vec2 normalTextureTransformScale = get_normalTextureTransformScale(materialSID, 0);
    vec2 normalTextureTransformOffset = get_normalTextureTransformOffset(materialSID, 0);
    float normalTextureTransformRotation = get_normalTextureTransformRotation(materialSID, 0);
    int normalTexcoordIndex = get_normalTexcoordIndex(materialSID, 0);
    vec2 normalTexcoord = getTexcoord(normalTexcoordIndex);
    vec2 normalTexUv = uvTransform(normalTextureTransformScale, normalTextureTransformOffset, normalTextureTransformRotation, normalTexcoord);
    mat3 TBN = getTBN(normal_inWorld, viewVector, normalTexUv);
    vec3 normalTexValue = texture(u_normalTexture, normalTexUv).xyz;
    if(normalTexValue.b >= 128.0 / 255.0) {
      // normal texture is existence
      vec3 normalTex = normalTexValue * 2.0 - 1.0;
      float normalScale = get_normalScale(materialSID, 0);
      vec3 scaledNormal = normalize(normalTex * vec3(normalScale, normalScale, 1.0));
      normal_inWorld = normalize(TBN * scaledNormal);
    }
  #endif

#ifdef RN_IS_LIGHTING
  // Metallic & Roughness
  vec2 metallicRoughnessTextureTransformScale = get_metallicRoughnessTextureTransformScale(materialSID, 0);
  vec2 metallicRoughnessTextureTransformOffset = get_metallicRoughnessTextureTransformOffset(materialSID, 0);
  float metallicRoughnessTextureTransformRotation = get_metallicRoughnessTextureTransformRotation(materialSID, 0);
  int metallicRoughnessTexcoordIndex = get_metallicRoughnessTexcoordIndex(materialSID, 0);
  vec2 metallicRoughnessTexcoord = getTexcoord(metallicRoughnessTexcoordIndex);
  vec2 metallicRoughnessTexUv = uvTransform(metallicRoughnessTextureTransformScale, metallicRoughnessTextureTransformOffset, metallicRoughnessTextureTransformRotation, metallicRoughnessTexcoord);
  vec4 ormTexel = texture(u_metallicRoughnessTexture, metallicRoughnessTexUv);
  float perceptualRoughness = ormTexel.g * get_roughnessFactor(materialSID, 0);
  float metallic = ormTexel.b * get_metallicFactor(materialSID, 0);
  metallic = clamp(metallic, 0.0, 1.0);
  perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
  float alphaRoughness = perceptualRoughness * perceptualRoughness;
    // filter NDF for specular AA --- https://jcgt.org/published/0010/02/02/
  float alphaRoughness2 = alphaRoughness * alphaRoughness;
  float filteredRoughness2 = IsotropicNDFFiltering(normal_inWorld, alphaRoughness2);
  perceptualRoughness = sqrt(sqrt(filteredRoughness2));

  // Albedo
  vec3 black = vec3(0.0);
  vec3 albedo = mix(baseColor.rgb, black, metallic);

  // NdotV
  float NdotV = saturate(dot(normal_inWorld, viewDirection));

  #ifdef RN_USE_ANISOTROPY
    float anisotropy = get_anisotropyStrength(materialSID, 0);
    vec2 anisotropyRotation = get_anisotropyRotation(materialSID, 0);
    vec2 direction = anisotropyRotation;
    vec2 anisotropyTextureTransformScale = get_anisotropyTextureTransformScale(materialSID, 0);
    vec2 anisotropyTextureTransformOffset = get_anisotropyTextureTransformOffset(materialSID, 0);
    float anisotropyTextureTransformRotation = get_anisotropyTextureTransformRotation(materialSID, 0);
    int anisotropyTexcoordIndex = get_anisotropyTexcoordIndex(materialSID, 0);
    vec2 anisotropyTexcoord = getTexcoord(anisotropyTexcoordIndex);
    vec2 anisotropyTexUv = uvTransform(anisotropyTextureTransformScale, anisotropyTextureTransformOffset, anisotropyTextureTransformRotation, anisotropyTexcoord);
    vec3 anisotropyTex = texture(u_anisotropyTexture, anisotropyTexUv).rgb;
    direction = anisotropyTex.rg * 2.0 - vec2(1.0);
    direction = mat2(anisotropyRotation.x, anisotropyRotation.y, -anisotropyRotation.y, anisotropyRotation.x) * normalize(direction);
    anisotropy *= anisotropyTex.b;
    vec3 anisotropicT = normalize(TBN * vec3(direction, 0.0));
    vec3 anisotropicB = normalize(cross(geomNormal_inWorld, anisotropicT));
    float BdotV = dot(anisotropicB, viewDirection);
    float TdotV = dot(anisotropicT, viewDirection);
  #else
    float anisotropy = 0.0;
    vec3 anisotropicT = vec3(0.0, 0.0, 0.0);
    vec3 anisotropicB = vec3(0.0, 0.0, 0.0);
    float BdotV = 0.0;
    float TdotV = 0.0;
  #endif

  float ior = get_ior(materialSID, 0);

    // Transmission
  #ifdef RN_USE_TRANSMISSION
    float transmissionFactor = get_transmissionFactor(materialSID, 0);
    vec2 transmissionTextureTransformScale = get_transmissionTextureTransformScale(materialSID, 0);
    vec2 transmissionTextureTransformOffset = get_transmissionTextureTransformOffset(materialSID, 0);
    float transmissionTextureTransformRotation = get_transmissionTextureTransformRotation(materialSID, 0);
    int transmissionTexcoordIndex = get_transmissionTexcoordIndex(materialSID, 0);
    vec2 transmissionTexcoord = getTexcoord(transmissionTexcoordIndex);
    vec2 transmissionTexUv = uvTransform(transmissionTextureTransformScale, transmissionTextureTransformOffset, transmissionTextureTransformRotation, transmissionTexcoord);
    float transmissionTexture = texture(u_transmissionTexture, transmissionTexUv).r;
    float transmission = transmissionFactor * transmissionTexture;
    // alpha *= transmission;
  #else
    float transmission = 0.0;
  #endif // RN_USE_TRANSMISSION

  #ifdef RN_USE_SPECULAR
    vec2 specularTextureTransformScale = get_specularTextureTransformScale(materialSID, 0);
    vec2 specularTextureTransformOffset = get_specularTextureTransformOffset(materialSID, 0);
    float specularTextureTransformRotation = get_specularTextureTransformRotation(materialSID, 0);
    int specularTexcoordIndex = get_specularTexcoordIndex(materialSID, 0);
    vec2 specularTexcoord = getTexcoord(specularTexcoordIndex);
    vec2 specularTexUv = uvTransform(specularTextureTransformScale, specularTextureTransformOffset, specularTextureTransformRotation, specularTexcoord);
    float specularTexture = texture(u_specularTexture, specularTexUv).a;
    float specularWeight = get_specularFactor(materialSID, 0) * specularTexture;
    vec2 specularColorTextureTransformScale = get_specularColorTextureTransformScale(materialSID, 0);
    vec2 specularColorTextureTransformOffset = get_specularColorTextureTransformOffset(materialSID, 0);
    float specularColorTextureTransformRotation = get_specularColorTextureTransformRotation(materialSID, 0);
    int specularColorTexcoordIndex = get_specularColorTexcoordIndex(materialSID, 0);
    vec2 specularColorTexcoord = getTexcoord(specularColorTexcoordIndex);
    vec2 specularColorTexUv = uvTransform(specularColorTextureTransformScale, specularColorTextureTransformOffset, specularColorTextureTransformRotation, specularColorTexcoord);
    vec3 specularColorTexture = srgbToLinear(texture(u_specularColorTexture, specularColorTexUv).rgb);
    vec3 specularColor = get_specularColorFactor(materialSID, 0) * specularColorTexture;
  #else
    float specularWeight = 1.0;
    vec3 specularColor = vec3(1.0, 1.0, 1.0);
  #endif // RN_USE_SPECULAR

  // F0, F90
  float outsideIor = 1.0;
  vec3 dielectricF0 = vec3(sq((ior - outsideIor) / (ior + outsideIor)));
  dielectricF0 = min(dielectricF0 * specularColor, vec3(1.0));
  vec3 dielectricF90 = vec3(specularWeight);

  // Iridescence
  #ifdef RN_USE_IRIDESCENCE
    float iridescenceFactor = get_iridescenceFactor(materialSID, 0);
    vec2 iridescenceTextureTransformScale = get_iridescenceTextureTransformScale(materialSID, 0);
    vec2 iridescenceTextureTransformOffset = get_iridescenceTextureTransformOffset(materialSID, 0);
    float iridescenceTextureTransformRotation = get_iridescenceTextureTransformRotation(materialSID, 0);
    int iridescenceTexcoordIndex = get_iridescenceTexcoordIndex(materialSID, 0);
    vec2 iridescenceTexcoord = getTexcoord(iridescenceTexcoordIndex);
    vec2 iridescenceTexUv = uvTransform(iridescenceTextureTransformScale, iridescenceTextureTransformOffset, iridescenceTextureTransformRotation, iridescenceTexcoord);
    float iridescenceTexture = texture(u_iridescenceTexture, iridescenceTexUv).r;
    float iridescence = iridescenceFactor * iridescenceTexture;

    vec2 iridescenceThicknessTextureTransformScale = get_iridescenceThicknessTextureTransformScale(materialSID, 0);
    vec2 iridescenceThicknessTextureTransformOffset = get_iridescenceThicknessTextureTransformOffset(materialSID, 0);
    float iridescenceThicknessTextureTransformRotation = get_iridescenceThicknessTextureTransformRotation(materialSID, 0);
    int iridescenceThicknessTexcoordIndex = get_iridescenceThicknessTexcoordIndex(materialSID, 0);
    vec2 iridescenceThicknessTexcoord = getTexcoord(iridescenceThicknessTexcoordIndex);
    vec2 iridescenceThicknessTexUv = uvTransform(iridescenceThicknessTextureTransformScale, iridescenceThicknessTextureTransformOffset, iridescenceThicknessTextureTransformRotation, iridescenceThicknessTexcoord);
    float thicknessRatio = texture(u_iridescenceThicknessTexture, iridescenceThicknessTexUv).g;
    float iridescenceThicknessMinimum = get_iridescenceThicknessMinimum(materialSID, 0);
    float iridescenceThicknessMaximum = get_iridescenceThicknessMaximum(materialSID, 0);
    float iridescenceThickness = mix(iridescenceThicknessMinimum, iridescenceThicknessMaximum, thicknessRatio);

    float iridescenceIor = get_iridescenceIor(materialSID, 0);
    vec3 iridescenceFresnel_dielectric = calcIridescence(1.0, iridescenceIor, NdotV, iridescenceThickness, dielectricF0);
    vec3 iridescenceFresnel_metal = calcIridescence(1.0, iridescenceIor, NdotV, iridescenceThickness, baseColor.rgb);

    if (iridescenceThickness == 0.0) {
      iridescence = 0.0;
    }
  #else
    float iridescence = 0.0;
    vec3 iridescenceFresnel_dielectric = vec3(0.0);
    vec3 iridescenceFresnel_metal = vec3(0.0);
  #endif // RN_USE_IRIDESCENCE

  #ifdef RN_USE_CLEARCOAT
    // Clearcoat
    float clearcoatFactor = get_clearcoatFactor(materialSID, 0);
    vec2 clearcoatTextureTransformScale = get_clearcoatTextureTransformScale(materialSID, 0);
    vec2 clearcoatTextureTransformOffset = get_clearcoatTextureTransformOffset(materialSID, 0);
    float clearcoatTextureTransformRotation = get_clearcoatTextureTransformRotation(materialSID, 0);
    int clearcoatTexcoordIndex = get_clearcoatTexcoordIndex(materialSID, 0);
    vec2 clearcoatTexcoord = getTexcoord(clearcoatTexcoordIndex);
    vec2 clearcoatTexUv = uvTransform(clearcoatTextureTransformScale, clearcoatTextureTransformOffset, clearcoatTextureTransformRotation, clearcoatTexcoord);
    float clearcoatTexture = texture(u_clearcoatTexture, clearcoatTexUv).r;
    float clearcoat = clearcoatFactor * clearcoatTexture;

    float clearcoatRoughnessFactor = get_clearcoatRoughnessFactor(materialSID, 0);
    int clearcoatRoughnessTexcoordIndex = get_clearcoatRoughnessTexcoordIndex(materialSID, 0);
    vec2 clearcoatRoughnessTexcoord = getTexcoord(clearcoatRoughnessTexcoordIndex);
    vec2 clearcoatRoughnessTextureTransformScale = get_clearcoatRoughnessTextureTransformScale(materialSID, 0);
    vec2 clearcoatRoughnessTextureTransformOffset = get_clearcoatRoughnessTextureTransformOffset(materialSID, 0);
    float clearcoatRoughnessTextureTransformRotation = get_clearcoatRoughnessTextureTransformRotation(materialSID, 0);
    vec2 clearcoatRoughnessTexUv = uvTransform(clearcoatRoughnessTextureTransformScale, clearcoatRoughnessTextureTransformOffset, clearcoatRoughnessTextureTransformRotation, clearcoatRoughnessTexcoord);
    float textureRoughnessTexture = texture(u_clearcoatRoughnessTexture, clearcoatRoughnessTexUv).g;
    float clearcoatRoughness = clearcoatRoughnessFactor * textureRoughnessTexture;

    int clearcoatNormalTexcoordIndex = get_clearcoatNormalTexcoordIndex(materialSID, 0);
    vec2 clearcoatNormalTexcoord = getTexcoord(clearcoatNormalTexcoordIndex);
    vec2 clearcoatNormalTextureTransformScale = get_clearcoatNormalTextureTransformScale(materialSID, 0);
    vec2 clearcoatNormalTextureTransformOffset = get_clearcoatNormalTextureTransformOffset(materialSID, 0);
    float clearcoatNormalTextureTransformRotation = get_clearcoatNormalTextureTransformRotation(materialSID, 0);
    vec2 clearcoatNormalTexUv = uvTransform(clearcoatNormalTextureTransformScale, clearcoatNormalTextureTransformOffset, clearcoatNormalTextureTransformRotation, clearcoatNormalTexcoord);
    vec3 textureNormal_tangent = texture(u_clearcoatNormalTexture, clearcoatNormalTexUv).xyz * vec3(2.0) - vec3(1.0);
    vec3 clearcoatNormal_inWorld = normalize(TBN * textureNormal_tangent);
    float VdotNc = saturate(dot(viewDirection, clearcoatNormal_inWorld));

    vec3 clearcoatF0 = vec3(pow((ior - 1.0) / (ior + 1.0), 2.0));
    vec3 clearcoatF90 = vec3(1.0);
    vec3 clearcoatFresnel = fresnelSchlick(clearcoatF0, clearcoatF90, VdotNc);
  #else
    float clearcoat = 0.0;
    float clearcoatRoughness = 0.0;
    vec3 clearcoatNormal_inWorld = vec3(0.0);
    float VdotNc = 0.0;
    vec3 clearcoatF0 = vec3(0.0);
    vec3 clearcoatF90 = vec3(0.0);
    vec3 clearcoatFresnel = vec3(0.0);
  #endif // RN_USE_CLEARCOAT

  #ifdef RN_USE_VOLUME
    // Volume
    float thicknessFactor = get_thicknessFactor(materialSID, 0);
    vec2 thicknessTextureTransformScale = get_thicknessTextureTransformScale(materialSID, 0);
    vec2 thicknessTextureTransformOffset = get_thicknessTextureTransformOffset(materialSID, 0);
    float thicknessTextureTransformRotation = get_thicknessTextureTransformRotation(materialSID, 0);
    int thicknessTexcoordIndex = get_thicknessTexcoordIndex(materialSID, 0);
    vec2 thicknessTexcoord = getTexcoord(thicknessTexcoordIndex);
    vec2 thicknessTexUv = uvTransform(thicknessTextureTransformScale, thicknessTextureTransformOffset, thicknessTextureTransformRotation, thicknessTexcoord);
    float thicknessTexture = texture(u_thicknessTexture, thicknessTexUv).g;
    float attenuationDistance = get_attenuationDistance(materialSID, 0);
    vec3 attenuationColor = get_attenuationColor(materialSID, 0);
    float thickness = thicknessFactor * thicknessTexture;
  #else
    float thickness = 0.0;
    vec3 attenuationColor = vec3(0.0);
    float attenuationDistance = 0.000001;
  #endif // RN_USE_VOLUME

  #ifdef RN_USE_SHEEN
    // Sheen
    vec3 sheenColorFactor = get_sheenColorFactor(materialSID, 0);
    vec2 sheenColorTextureTransformScale = get_sheenColorTextureTransformScale(materialSID, 0);
    vec2 sheenColorTextureTransformOffset = get_sheenColorTextureTransformOffset(materialSID, 0);
    float sheenColorTextureTransformRotation = get_sheenColorTextureTransformRotation(materialSID, 0);
    int sheenColorTexcoordIndex = get_sheenColorTexcoordIndex(materialSID, 0);
    vec2 sheenColorTexcoord = getTexcoord(sheenColorTexcoordIndex);
    vec2 sheenColorTexUv = uvTransform(sheenColorTextureTransformScale, sheenColorTextureTransformOffset, sheenColorTextureTransformRotation, sheenColorTexcoord);
    vec3 sheenColorTexture = texture(u_sheenColorTexture, sheenColorTexUv).rgb;

    float sheenRoughnessFactor = get_sheenRoughnessFactor(materialSID, 0);
    vec2 sheenRoughnessTextureTransformScale = get_sheenRoughnessTextureTransformScale(materialSID, 0);
    vec2 sheenRoughnessTextureTransformOffset = get_sheenRoughnessTextureTransformOffset(materialSID, 0);
    float sheenRoughnessTextureTransformRotation = get_sheenRoughnessTextureTransformRotation(materialSID, 0);
    int sheenRoughnessTexcoordIndex = get_sheenRoughnessTexcoordIndex(materialSID, 0);
    vec2 sheenRoughnessTexcoord = getTexcoord(sheenRoughnessTexcoordIndex);
    vec2 sheenRoughnessTexUv = uvTransform(sheenRoughnessTextureTransformScale, sheenRoughnessTextureTransformOffset, sheenRoughnessTextureTransformRotation, sheenRoughnessTexcoord);
    float sheenRoughnessTexture = texture(u_sheenRoughnessTexture, sheenRoughnessTexUv).a;

    vec3 sheenColor = sheenColorFactor * sheenColorTexture;
    float sheenRoughness = clamp(sheenRoughnessFactor * sheenRoughnessTexture, 0.000001, 1.0);
    float albedoSheenScalingNdotV = 1.0 - max3(sheenColor) * texture(u_sheenLutTexture, vec2(NdotV, sheenRoughness)).r;
  #else
    vec3 sheenColor = vec3(0.0);
    float sheenRoughness = 0.000001;
    float albedoSheenScalingNdotV = 1.0;
  #endif // RN_USE_SHEEN

  #ifdef RN_USE_DIFFUSE_TRANSMISSION
    float diffuseTransmissionFactor = get_diffuseTransmissionFactor(materialSID, 0);
    vec2 diffuseTransmissionTextureTransformScale = get_diffuseTransmissionTextureTransformScale(materialSID, 0);
    vec2 diffuseTransmissionTextureTransformOffset = get_diffuseTransmissionTextureTransformOffset(materialSID, 0);
    float diffuseTransmissionTextureTransformRotation = get_diffuseTransmissionTextureTransformRotation(materialSID, 0);
    int diffuseTransmissionTexcoordIndex = get_diffuseTransmissionTexcoordIndex(materialSID, 0);
    vec2 diffuseTransmissionTexcoord = getTexcoord(diffuseTransmissionTexcoordIndex);
    vec2 diffuseTransmissionTexUv = uvTransform(diffuseTransmissionTextureTransformScale, diffuseTransmissionTextureTransformOffset, diffuseTransmissionTextureTransformRotation, diffuseTransmissionTexcoord);
    float diffuseTransmissionTexture = texture(u_diffuseTransmissionTexture, diffuseTransmissionTexUv).a;
    float diffuseTransmission = diffuseTransmissionFactor * diffuseTransmissionTexture;

    vec3 diffuseTransmissionColorFactor = get_diffuseTransmissionColorFactor(materialSID, 0);
    vec2 diffuseTransmissionColorTextureTransformScale = get_diffuseTransmissionColorTextureTransformScale(materialSID, 0);
    vec2 diffuseTransmissionColorTextureTransformOffset = get_diffuseTransmissionColorTextureTransformOffset(materialSID, 0);
    float diffuseTransmissionColorTextureTransformRotation = get_diffuseTransmissionColorTextureTransformRotation(materialSID, 0);
    int diffuseTransmissionColorTexcoordIndex = get_diffuseTransmissionColorTexcoordIndex(materialSID, 0);
    vec2 diffuseTransmissionColorTexcoord = getTexcoord(diffuseTransmissionColorTexcoordIndex);
    vec2 diffuseTransmissionColorTexUv = uvTransform(diffuseTransmissionColorTextureTransformScale, diffuseTransmissionColorTextureTransformOffset, diffuseTransmissionColorTextureTransformRotation, diffuseTransmissionColorTexcoord);
    vec3 diffuseTransmissionColorTexture = texture(u_diffuseTransmissionColorTexture, diffuseTransmissionColorTexUv).rgb;
    vec3 diffuseTransmissionColor = diffuseTransmissionColorFactor * diffuseTransmissionColorTexture;

    float diffuseTransmissionThickness = 1.0;
  #ifdef RN_USE_VOLUME
    mat4 worldMatrix = get_worldMatrix(v_instanceInfo);
    diffuseTransmissionThickness = thickness * (length(worldMatrix[0].xyz) * length(worldMatrix[1].xyz) * length(worldMatrix[2].xyz)) / 3.0;
  #endif // RN_USE_VOLUME

  #else
    float diffuseTransmission = 0.0;
    vec3 diffuseTransmissionColor = vec3(0.0);
    float diffuseTransmissionThickness = 0.0;
  #endif // RN_USE_DIFFUSE_TRANSMISSION

  rt0 = vec4(0.0, 0.0, 0.0, alpha);

  // Punctual Lights
  for (int i = 0; i < lightNumber; i++) {
    Light light = getLight(i, v_position_inWorld.xyz);
    if (light.type < 0) {
      continue;
    }
    vec3 lighting = lightingWithPunctualLight(light, normal_inWorld, viewDirection, NdotV, baseColor.rgb,
                        perceptualRoughness, metallic, dielectricF0, dielectricF90, ior, transmission, thickness,
                        clearcoat, clearcoatRoughness, clearcoatF0, clearcoatF90, clearcoatFresnel, clearcoatNormal_inWorld, VdotNc,
                        attenuationColor, attenuationDistance,
                        anisotropy, anisotropicT, anisotropicB, BdotV, TdotV,
                        sheenColor, sheenRoughness, albedoSheenScalingNdotV,
                        iridescence, iridescenceFresnel_dielectric, iridescenceFresnel_metal, specularWeight,
                        diffuseTransmission, diffuseTransmissionColor, diffuseTransmissionThickness);

  #ifdef RN_USE_SHADOW_MAPPING
    int depthTextureIndex = get_depthTextureIndexList(materialSID, i);
    if (light.type == 1 && depthTextureIndex >= 0) { // Point Light
      float pointLightFarPlane = get_pointLightFarPlane(materialSID, 0);
      float pointLightShadowMapUvScale = get_pointLightShadowMapUvScale(materialSID, 0);
      float shadowContribution = varianceShadowContributionParaboloid(v_position_inWorld.xyz, light.position, pointLightFarPlane, pointLightShadowMapUvScale, depthTextureIndex);
      lighting *= shadowContribution;
    } else if ((light.type == 0 || light.type == 2) && depthTextureIndex >= 0) { // Spot Light
      vec4 v_shadowCoord = get_depthBiasPV(materialSID, i) * v_position_inWorld;
      float bias = 0.001;
      vec2 shadowCoord = v_shadowCoord.xy / v_shadowCoord.w;
      vec3 lightDirection = normalize(get_lightDirection(0.0, i));
      vec3 lightPosToWorldPos = normalize(v_position_inWorld.xyz - light.position);
      float dotProduct = dot(lightPosToWorldPos, lightDirection);
      float shadowContribution = 1.0;
      if (dotProduct > 0.0 && shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0) {
        shadowContribution = varianceShadowContribution(shadowCoord, (v_shadowCoord.z - bias)/v_shadowCoord.w, depthTextureIndex);
      }
      lighting *= shadowContribution;
    }
  #endif

    rt0.rgb += lighting;
  }

  // Image-based Lighting
  vec3 ibl = IBLContribution(materialSID, normal_inWorld, NdotV, viewDirection,
    baseColor.rgb, perceptualRoughness, clearcoatRoughness, clearcoatNormal_inWorld,
    clearcoat, clearcoatFresnel, VdotNc, geomNormal_inWorld, cameraSID, transmission, v_position_inWorld.xyz, thickness,
    sheenColor, sheenRoughness, albedoSheenScalingNdotV,
    ior, iridescenceFresnel_dielectric, iridescenceFresnel_metal, iridescence,
    anisotropy, anisotropicB, specularWeight, dielectricF0, metallic,
    diffuseTransmission, diffuseTransmissionColor, diffuseTransmissionThickness);

  int occlusionTexcoordIndex = get_occlusionTexcoordIndex(materialSID, 0);
  vec2 occlusionTexcoord = getTexcoord(occlusionTexcoordIndex);
  vec2 occlusionTextureTransformScale = get_occlusionTextureTransformScale(materialSID, 0);
  vec2 occlusionTextureTransformOffset = get_occlusionTextureTransformOffset(materialSID, 0);
  float occlusionTextureTransformRotation = get_occlusionTextureTransformRotation(materialSID, 0);
  vec2 occlusionTexUv = uvTransform(occlusionTextureTransformScale, occlusionTextureTransformOffset, occlusionTextureTransformRotation, occlusionTexcoord);
  float occlusion = texture(u_occlusionTexture, occlusionTexUv).r;
  float occlusionStrength = get_occlusionStrength(materialSID, 0);

  // Occlusion to Indirect Lights
  vec3 indirectLight = ibl * (1.0 + occlusionStrength * (occlusion - 1.0));
  rt0.xyz += indirectLight;
#else
  rt0 = vec4(baseColor, alpha);
#endif // RN_IS_LIGHTING

  // Emissive
  vec3 emissiveFactor = get_emissiveFactor(materialSID, 0);
  int emissiveTexcoordIndex = get_emissiveTexcoordIndex(materialSID, 0);
  vec2 emissiveTexcoord = getTexcoord(emissiveTexcoordIndex);
  vec2 emissiveTextureTransformScale = get_emissiveTextureTransformScale(materialSID, 0);
  vec2 emissiveTextureTransformOffset = get_emissiveTextureTransformOffset(materialSID, 0);
  float emissiveTextureTransformRotation = get_emissiveTextureTransformRotation(materialSID, 0);
  vec2 emissiveTexUv = uvTransform(emissiveTextureTransformScale, emissiveTextureTransformOffset, emissiveTextureTransformRotation, emissiveTexcoord);
  vec3 emissive = emissiveFactor * srgbToLinear(texture(u_emissiveTexture, emissiveTexUv).xyz);
#ifdef RN_USE_EMISSIVE_STRENGTH
  float emissiveStrength = get_emissiveStrength(materialSID, 0);
  emissive *= emissiveStrength;
#endif // RN_USE_EMISSIVE_STRENGTH

#ifdef RN_USE_CLEARCOAT
  vec3 coated_emissive = emissive * mix(vec3(1.0), vec3(0.04 + (1.0 - 0.04) * pow(1.0 - NdotV, 5.0)), clearcoat);
  rt0.xyz += coated_emissive;
#else
  rt0.xyz += emissive;
#endif // RN_USE_CLEARCOAT

  bool isOutputHDR = get_isOutputHDR(materialSID, 0);
  if(isOutputHDR){
/* shaderity: @{renderTargetEnd} */

    return;
  }

  // Wireframe
  float threshold = 0.001;
  vec3 wireframe = get_wireframe(materialSID, 0);
  float wireframeWidthInner = wireframe.z;
  float wireframeWidthRelativeScale = 1.0;
  if (wireframe.x > 0.5 && wireframe.y < 0.5) {
    rt0.a = 0.0;
  }
  vec4 wireframeResult = rt0;
  vec4 wireframeColor = vec4(0.2, 0.75, 0.0, 1.0);
  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);
  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);
  // if r0.a is 0.0, it is wireframe not on shaded
  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified);
  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));

  if (wireframe.x > 0.5) {
    rt0 = wireframeResult;
    if (wireframe.y < 0.5 && rt0.a == 0.0) {
      discard;
    }
  }


#ifdef RN_IS_ALPHA_MODE_BLEND
#else
  rt0.a = 1.0;
#endif

float makeOutputSrgb = float(get_makeOutputSrgb(materialSID, 0));
rt0.rgb = mix(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb);

rt0.rgb = rt0.rgb * rt0.a; // alpha premultiplied
rt1 = rt0;
rt2 = rt0;
rt3 = rt0;
/* shaderity: @{renderTargetEnd} */


}
`,shaderStage:"fragment",isFragmentShader:!0}});var Z3,K3=C(()=>{Z3={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */


#ifdef RN_IS_SKINNING

fn createMatrixFromQuaternionTranslationScale( quaternion: vec4<f32>, translation: vec3<f32>, scale: vec3<f32> ) -> mat4x4<f32> {
  let q = quaternion;
  let t = translation;

  let sx = q.x * q.x;
  let sy = q.y * q.y;
  let sz = q.z * q.z;
  let cx = q.y * q.z;
  let cy = q.x * q.z;
  let cz = q.x * q.y;
  let wx = q.w * q.x;
  let wy = q.w * q.y;
  let wz = q.w * q.z;

  let mat = mat4x4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  let uniformScaleMat = mat4x4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  let mat44 = mat*uniformScaleMat;
  return mat44;

}

fn unpackedVec2ToNormalizedVec4(vec_xy: vec2<f32>, criteria: f32) -> vec4<f32> {

  var r: f32;
  var g: f32;
  var b: f32;
  var a: f32;

  let ix = floor(vec_xy.x * criteria);
  let v1x = ix / criteria;
  let v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  let iy = floor( vec_xy.y * criteria);
  let v2x = iy / criteria;
  let v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4<f32>(r, g, b, a);
}

fn get_boneMatrixAsMat4x4(skeletalComponentSID: u32, joint: u32) -> mat4x4<f32> {
  let mat43: mat4x3<f32> = get_boneMatrix(skeletalComponentSID, joint);
  return mat4x4<f32>(
    vec4<f32>(mat43[0], 0.0),
    vec4<f32>(mat43[1], 0.0),
    vec4<f32>(mat43[2], 0.0),
    vec4<f32>(mat43[3], 1.0)
  );
}

fn getSkinMatrix(skeletalComponentSID: u32, joint: vec4<u32>, weight: vec4<f32>) -> mat4x4<f32> {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  var skinMat: mat4x4<f32> = weight.x * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.x);
  skinMat += weight.y * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.y);
  skinMat += weight.z * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.z);
  skinMat += weight.w * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.w);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  let criteria = vec2<f32>(4096.0, 4096.0);

  let tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, joint.x);
  let sq_x = get_boneScalePackedQuat(skeletalComponentSID, joint.x);
  var quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  let tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, joint.y);
  let sq_y = get_boneScalePackedQuat(skeletalComponentSID, joint.y);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  let tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, joint.z);
  let sq_z = get_boneScalePackedQuat(skeletalComponentSID, joint.z);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  let tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, joint.w);
  let sq_w = get_boneScalePackedQuat(skeletalComponentSID, joint.w);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  let ts_x = get_boneTranslateScale(skeletalComponentSID, joint.x);
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.x), ts_x.xyz, vec3(ts_x.w));
  let ts_y = get_boneTranslateScale(skeletalComponentSID, joint.y);
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.y), ts_y.xyz, vec3(ts_y.w));
  let ts_z = get_boneTranslateScale(skeletalComponentSID, joint.z);
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.z), ts_z.xyz, vec3(ts_z.w));
  let ts_w = get_boneTranslateScale(skeletalComponentSID, joint.w);
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.w), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  let boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, joint.x);
  let boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, joint.y);
  let boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, joint.z);
  let boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, joint.w);

  let criteria = vec2<f32>(4096.0, 4096.0);
  let boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  let ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  let ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  let ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  let ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif

fn toNormalMatrix(m: mat4x4<f32>) -> mat3x3<f32> {
  let a00 = m[0][0];
  let a01 = m[0][1];
  let a02 = m[0][2];
  let a03 = m[0][3];
  let a10 = m[1][0];
  let a11 = m[1][1];
  let a12 = m[1][2];
  let a13 = m[1][3];
  let a20 = m[2][0];
  let a21 = m[2][1];
  let a22 = m[2][2];
  let a23 = m[2][3];
  let a30 = m[3][0];
  let a31 = m[3][1];
  let a32 = m[3][2];
  let a33 = m[3][3];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  let determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3x3<f32>(
    (a11 * b11 - a12 * b10 + a13 * b09) / determinantVal,
    (a12 * b08 - a10 * b11 - a13 * b07) / determinantVal,
    (a10 * b10 - a11 * b08 + a13 * b06) / determinantVal,
    (a02 * b10 - a01 * b11 - a03 * b09) / determinantVal,
    (a00 * b11 - a02 * b08 + a03 * b07) / determinantVal,
    (a01 * b08 - a00 * b10 - a03 * b06) / determinantVal,
    (a31 * b05 - a32 * b04 + a33 * b03) / determinantVal,
    (a32 * b02 - a30 * b05 - a33 * b01) / determinantVal,
    (a30 * b04 - a31 * b02 + a33 * b00) / determinantVal
  );
}

struct GeometoryOutput {
  normalMatrix: mat3x3<f32>,
  position_inWorld: vec4<f32>,
  normal_inWorld: vec3<f32>,
  isSkinning: bool,
}

#ifdef RN_IS_SKINNING
fn skinning(
  skeletalComponentSID: u32,
  inNormalMatrix: mat3x3<f32>,
  inPosition_inLocal: vec3<f32>,
  inNormal_inLocal: vec3<f32>,
  joint: vec4<u32>,
  weight: vec4<f32>,
  ) -> GeometoryOutput
{
  var output: GeometoryOutput;
  let skinMat = getSkinMatrix(skeletalComponentSID, joint, weight);
  output.position_inWorld = skinMat * vec4<f32>(inPosition_inLocal, 1.0);
  output.normalMatrix = toNormalMatrix(skinMat);
  output.normal_inWorld = normalize(output.normalMatrix * inNormal_inLocal);
  output.isSkinning = true;

  return output;
}
#endif


fn processGeometryWithMorphingAndSkinning(
  skeletalComponentSID: i32,
  blendShapeComponentSID: u32,
  worldMatrix: mat4x4<f32>,
  viewMatrix: mat4x4<f32>,
  isBillboard: bool,
  inNormalMatrix: mat3x3<f32>,
  inPosition_inLocal: vec3<f32>,
  inNormal_inLocal: vec3<f32>,
  baryCentricCoord: vec4<f32>,
  joint: vec4<u32>,
  weight: vec4<f32>,
) -> GeometoryOutput {
  var output: GeometoryOutput;

  var position_inLocal: vec3<f32>;
#ifdef RN_IS_MORPHING
  if (uniformDrawParameters.morphTargetNumber == 0u) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    let vertexIdx = u32(baryCentricCoord.w);
    position_inLocal = get_position(vertexIdx, inPosition_inLocal, blendShapeComponentSID);
  }
#endif

  var worldMatrixInner = worldMatrix;

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0) {
    output = skinning(u32(skeletalComponentSID), inNormalMatrix, position_inLocal, inNormal_inLocal, joint, weight);
  } else {
#endif
    output.normalMatrix = inNormalMatrix;
    output.position_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    output.normal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
    output.isSkinning = false;
#ifdef RN_IS_SKINNING
  }
#endif

  return output;
}


@vertex
fn main(
#ifdef RN_USE_INSTANCE
  @location(8) instance_ids: vec4<f32>,
#endif


#ifdef RN_USE_POSITION_FLOAT
  @location(0) position: vec3<f32>,
#endif
#ifdef RN_USE_POSITION_INT
  @location(0) position: vec3<i32>,
#endif
#ifdef RN_USE_POSITION_UINT
  @location(0) position: vec3<u32>,
#endif

#ifdef RN_USE_NORMAL
  @location(1) normal: vec3<f32>,
#endif
#ifdef RN_USE_TANGENT
  @location(2) tangent: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_0
  @location(3) texcoord_0: vec2<f32>,
#endif
#ifdef RN_USE_TEXCOORD_1
  @location(4) texcoord_1: vec2<f32>,
#endif

#ifdef RN_USE_COLOR_0_FLOAT
  @location(5) color_0: vec4<f32>,
#endif
#ifdef RN_USE_COLOR_0_INT
  @location(5) color_0: vec4<i32>,
#endif
#ifdef RN_USE_COLOR_0_UINT
  @location(5) color_0: vec4<u32>,
#endif

#ifdef RN_USE_JOINTS_0
  @location(6) joints_0: vec4<u32>,
#endif
#ifdef RN_USE_WEIGHTS_0
  @location(7) weights_0: vec4<f32>,
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
  @location(10) baryCentricCoord: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_2
  @location(11) texcoord_2: vec2<f32>,
#endif
  @builtin(vertex_index) vertexIdx : u32,


) -> VertexOutput {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  var output : VertexOutput;
  let instanceId = u32(instance_ids.x);
  let worldMatrix = get_worldMatrix(instanceId);
  let normalMatrix = get_normalMatrix(instanceId);
  let viewMatrix = get_viewMatrix(cameraSID, 0);
  let projectionMatrix = get_projectionMatrix(cameraSID, 0);

  let skeletalComponentSID = i32(instance_ids.y);

#ifdef RN_USE_NORMAL
#else
  let normal = vec3<f32>(0.0, 0.0, 0.0);
#endif

#ifdef RN_USE_JOINTS_0
  let joint = joints_0;
#else
  let joint = vec4<u32>(0, 0, 0, 0);
#endif
#ifdef RN_USE_WEIGHTS_0
  let weight = weights_0;
#else
  let weight = vec4<f32>(0.0, 0.0, 0.0, 0.0);
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
#else
  let baryCentricCoord = vec4<f32>(0.0, 0.0, 0.0, 0.0);
#endif

  let blendShapeComponentSID = u32(instance_ids.z);
  let geom = processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    blendShapeComponentSID,
    worldMatrix,
    viewMatrix,
    false,
    normalMatrix,
    position,
    normal,
    baryCentricCoord,
    joint,
    weight
  );

  output.position = projectionMatrix * viewMatrix * geom.position_inWorld;
  output.position_inWorld = geom.position_inWorld.xyz;
  output.normal_inWorld = geom.normal_inWorld;

#ifdef RN_USE_TEXCOORD_0
  output.texcoord_0 = texcoord_0;
#endif
#ifdef RN_USE_TEXCOORD_1
  output.texcoord_1 = texcoord_1;
#endif
#ifdef RN_USE_TEXCOORD_2
  output.texcoord_2 = texcoord_2;
#endif

#ifdef RN_USE_COLOR_0
  output.color_0 = vec4f(color_0);
#else
  output.color_0 = vec4<f32>(1.0, 1.0, 1.0, 1.0);
#endif

#ifdef RN_USE_TANGENT
  output.tangent_inWorld = normalMatrix * tangent.xyz;
  output.binormal_inWorld = cross(output.tangent_inWorld, output.normal_inWorld) * tangent.w;
#endif

  output.instanceInfo = instance_ids.x;

  let visibility = get_isVisible(instanceId);
  if (!visibility)
  {
    output.position = vec4f(0.0, 0.0, 0.0, 1.0);
  }

  return output;
}
`,shaderStage:"vertex",isFragmentShader:!1}});var $3,J3=C(()=>{$3={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

struct Light {
  lightType: i32, // 0 = directional, 1 = point, 2 = spot
  position: vec3<f32>,
  intensity: vec3<f32>,
  attenuatedIntensity: vec3<f32>,
  directionOfLightObject: vec3<f32>,
  direction: vec3<f32>, // direction of light vector, equal to normalize(light.pointToLight)
  pointToLight: vec3<f32>, // not normalized
  innerConeCos: f32,
  outerConeCos: f32,
  effectiveRange: f32,
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
fn getRangeAttenuation(light: Light) -> f32
{
  let distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
fn getSpotAttenuation(light: Light) -> f32
{
  let actualCos = dot(light.direction, -light.directionOfLightObject);
  if (actualCos > light.outerConeCos) {
    if (actualCos < light.innerConeCos) {
      let attenuation = (actualCos - light.outerConeCos) / (light.innerConeCos - light.outerConeCos);
      return attenuation * attenuation;
    }
    return 1.0;
  }
  return 0.0;
}

fn getLightAttenuated(light: Light) -> Light {
  var newLight: Light = light;
  newLight.attenuatedIntensity = light.intensity;
  // if (light.lightType == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light && Spot Light
  if (light.lightType != 0)
  {
    newLight.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot Light
  if (light.lightType == 2)
  {
    newLight.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return newLight;
}

fn getLight(lightIdx: u32, v_position_inWorld: vec3<f32>) -> Light {
  let lightPosition: vec3<f32> = get_lightPosition(0u, lightIdx);
  let direction_and_w_of_LightObject: vec3<f32> = get_lightDirection(0u, lightIdx);
  let lightIntensity: vec3<f32> = get_lightIntensity(0u, lightIdx);
  let lightProperty: vec4<f32> = get_lightProperty(0u, lightIdx);
  var light: Light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  let lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.innerConeCos = lightProperty.z;
  light.outerConeCos = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3f(0.0);
    light.lightType = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.lightType = 1;
  } else { // is Directional Light
    light.lightType = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.lightType = 2;
  }

  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  let newLight = getLightAttenuated(light);

  return newLight;
}

#ifdef RN_USE_TANGENT
  fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
    let tangent_inWorld = normalize(input.tangent_inWorld);
    let binormal_inWorld = normalize(input.binormal_inWorld);
    let tbnMat_tangent_to_world = mat3x3<f32>(tangent_inWorld, binormal_inWorld, normal_inWorld);

    return tbnMat_tangent_to_world;
  }
#else
    // This is based on http://www.thetenthplanet.de/archives/1180
    fn cotangent_frame(normal_inWorld: vec3f, position: vec3f, uv_: vec2f, isFront: bool) -> mat3x3<f32> {
      var uv: vec2f;
      if (isFront) {
        uv = uv_;
      } else {
        uv = -uv_;
      }

      // get edge vectors of the pixel triangle
      let dp1 = dpdx(position);
      let dp2 = -dpdy(position); // Because the Y direction of the window coordinate system is different from that of WebGL, this one is set to minus to make the result match the WebGL version.
      let duv1 = dpdx(uv);
      let duv2 = -dpdy(uv); // Because the Y direction of the window coordinate system is different from that of WebGL, this one is set to minus to make the result match the WebGL version.

      // solve the linear system
      let dp2perp = cross(dp2, normal_inWorld);
      let dp1perp = cross(normal_inWorld, dp1);
      let tangent = dp2perp * duv1.x + dp1perp * duv2.x;
      var bitangent = dp2perp * duv1.y + dp1perp * duv2.y;
      bitangent *= -1.0;

      // construct a scale-invariant frame
      let invMat = 1.0 / sqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));
      return mat3x3<f32>(tangent * invMat, bitangent * invMat, normal_inWorld);
    }

    fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
      let tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord, isFront);

      return tbnMat_tangent_to_world;
    }
#endif


// #param makeOutputSrgb: bool; // initialValue=1

// Color
// #param baseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)
@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(0) var baseColorSampler: sampler;
// #param baseColorTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param baseColorTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param baseColorTextureTransformRotation: f32; // initialValue=0
// #param baseColorTexcoordIndex: f32; // initialValue=0

// #param ior: f32; // initialValue=1.5

// #param metallicFactor: f32; // initialValue=1
// #param roughnessFactor: f32; // initialValue=1
@group(1) @binding(1) var metallicRoughnessTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(1) var metallicRoughnessSampler: sampler;
// #param metallicRoughnessTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param metallicRoughnessTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param metallicRoughnessTextureTransformRotation: f32; // initialValue=0
// #param metallicRoughnessTexcoordIndex: f32; // initialValue=0

#ifdef RN_USE_NORMAL_TEXTURE
  @group(1) @binding(2) var normalTexture: texture_2d<f32>; // initialValue=black
  @group(2) @binding(2) var normalSampler: sampler;
  // #param normalTextureTransformScale: vec2<f32>; // initialValue=(1,1)
  // #param normalTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
  // #param normalTextureTransformRotation: f32; // initialValue=0
  // #param normalTexcoordIndex: f32; // initialValue=(0)
  // #param normalScale: f32; // initialValue=(1)
#endif

@group(1) @binding(3) var occlusionTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(3) var occlusionSampler: sampler;
// #param occlusionTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param occlusionTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param occlusionTextureTransformRotation: f32; // initialValue=0
// #param occlusionTexcoordIndex: u32; // initialValue=0
// #param occlusionStrength: f32; // initialValue=1

// #param emissiveFactor: vec3<f32>; // initialValue=(0,0,0)
// #param emissiveTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param emissiveTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param emissiveTextureTransformRotation: f32; // initialValue=0
// #param emissiveTexcoordIndex: u32; // initialValue=0
@group(1) @binding(4) var emissiveTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(4) var emissiveSampler: sampler;

#ifdef RN_USE_EMISSIVE_STRENGTH
  // #param emissiveStrength: f32; // initialValue=1
#endif

#ifdef RN_USE_CLEARCOAT
// #param clearcoatFactor: f32; // initialValue=0
// #param clearcoatRoughnessFactor: f32; // initialValue=0
// #param clearcoatTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param clearcoatTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param clearcoatTextureTransformRotation: f32; // initialValue=0
// #param clearcoatRoughnessTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param clearcoatRoughnessTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param clearcoatRoughnessTextureTransformRotation: f32; // initialValue=0
// #param clearcoatNormalTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param clearcoatNormalTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param clearcoatNormalTextureTransformRotation: f32; // initialValue=0
// #param clearcoatTexcoordIndex: u32; // initialValue=(0)
// #param clearcoatRoughnessTexcoordIndex: u32; // initialValue=(0)
// #param clearcoatNormalTexcoordIndex: u32; // initialValue=(0)
#endif // RN_USE_CLEARCOAT


#ifdef RN_USE_TRANSMISSION
// #param transmissionFactor: f32; // initialValue=(0)
// #param transmissionTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param transmissionTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param transmissionTextureTransformRotation: f32; // initialValue=0
// #param transmissionTexcoordIndex: u32; // initialValue=0
#endif // RN_USE_TRANSMISSION

#ifdef RN_USE_VOLUME
// #param thicknessFactor: f32; // initialValue=(0)
// #param attenuationDistance: f32; // initialValue=(0.000001)
// #param attenuationColor: vec3<f32>; // initialValue=(1,1,1)
// #param thicknessTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param thicknessTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param thicknessTextureTransformRotation: f32; // initialValue=0
// #param thicknessTexcoordIndex: u32; // initialValue=0
#endif

#ifdef RN_USE_SHEEN
// #param sheenColorFactor: vec3<f32>; // initialValue=(0,0,0)
// #param sheenRoughnessFactor: f32; // initialValue=(0)
// #param sheenColorTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param sheenColorTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param sheenColorTextureTransformRotation: f32; // initialValue=0
// #param sheenColorTexcoordIndex: u32; // initialValue=0
// #param sheenRoughnessTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param sheenRoughnessTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param sheenRoughnessTextureTransformRotation: f32; // initialValue=0
// #param sheenRoughnessTexcoordIndex: u32; // initialValue=0
#endif

#ifdef RN_USE_SPECULAR
// #param specularFactor: f32; // initialValue=1.0
// #param specularColorFactor: vec3<f32>; // initialValue=(1,1,1)
// #param specularTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param specularTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param specularTextureTransformRotation: f32; // initialValue=0
// #param specularTexcoordIndex: u32; // initialValue=0
// #param specularColorTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param specularColorTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param specularColorTextureTransformRotation: f32; // initialValue=0
// #param specularColorTexcoordIndex: u32; // initialValue=0
#endif

#ifdef RN_USE_IRIDESCENCE
// #param iridescenceFactor: f32; // initialValue=0
// #param iridescenceIor: f32; // initialValue=1.3
// #param iridescenceThicknessMinimum: f32; // initialValue=100
// #param iridescenceThicknessMaximum: f32; // initialValue=400
// #param iridescenceTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param iridescenceTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param iridescenceTextureTransformRotation: f32; // initialValue=0
// #param iridescenceTexcoordIndex: u32; // initialValue=0
// #param iridescenceThicknessTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param iridescenceThicknessTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param iridescenceThicknessTextureTransformRotation: f32; // initialValue=0
// #param iridescenceThicknessTexcoordIndex: u32; // initialValue=0
#endif

#ifdef RN_USE_ANISOTROPY
// #param anisotropyStrength: f32; // initialValue=0
// #param anisotropyRotation: vec2<f32>; // initialValue=(1,0)
// #param anisotropyTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param anisotropyTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param anisotropyTextureTransformRotation: f32; // initialValue=0
// #param anisotropyTexcoordIndex: u32; // initialValue=0
#endif

#ifdef RN_USE_DIFFUSE_TRANSMISSION
// #param diffuseTransmissionFactor: f32; // initialValue=0
// #param diffuseTransmissionColorFactor: vec3<f32>; // initialValue=(1,1,1)
// #param diffuseTransmissionTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param diffuseTransmissionTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param diffuseTransmissionTextureTransformRotation: f32; // initialValue=0
// #param diffuseTransmissionTexcoordIndex: u32; // initialValue=0
// #param diffuseTransmissionColorTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param diffuseTransmissionColorTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param diffuseTransmissionColorTextureTransformRotation: f32; // initialValue=0
// #param diffuseTransmissionColorTexcoordIndex: u32; // initialValue=0
#endif

#ifdef RN_USE_DISPERSION
// #param dispersion: f32; // initialValue=0
#endif

// #param alphaCutoff: f32; // initialValue=0.01

@group(1) @binding(16) var diffuseEnvTexture: texture_cube<f32>; // initialValue=black, isInternalSetting=true
@group(2) @binding(16) var diffuseEnvSampler: sampler;
@group(1) @binding(17) var specularEnvTexture: texture_cube<f32>; // initialValue=black, isInternalSetting=true
@group(2) @binding(17) var specularEnvSampler: sampler;


// #param iblParameter: vec4<f32>; // initialValue=(1,1,1,1), isInternalSetting=true
// #param hdriFormat: vec2<i32>; // initialValue=(0,0), isInternalSetting=true
// #param inverseEnvironment: bool; // initialValue=false
#ifdef RN_USE_SHADOW_MAPPING
  // #param pointLightFarPlane: f32; // initialValue=1000.0
  // #param pointLightShadowMapUvScale: f32; // initialValue=0.93
#endif

#ifdef RN_USE_SHADOW_MAPPING

const g_minVariance: f32 = 0.00001;

fn chebyshevUpperBound(moments: vec2<f32>, t: f32) -> f32 {
  let p = select(0.0, 1.0, t <= moments.x);

  var variance = moments.y - sqF32(moments.x);
  variance = max(variance, g_minVariance);

  let d = t - moments.x;
  let p_max = variance / (variance + sqF32(d));

  return max(p, p_max);
}

fn varianceShadowContribution(lightTexCoord: vec2<f32>, distanceToLight: f32, depthTextureIndex: u32) -> f32 {
  let moments = textureSample(depthTexture, depthSampler, lightTexCoord, depthTextureIndex).xy;

  return chebyshevUpperBound(moments, distanceToLight);
}

fn varianceShadowContributionParaboloid(worldPos: vec3<f32>, lightPos: vec3<f32>, farPlane: f32, uvScale: f32, depthTextureIndex: u32) -> f32 {
  let L = worldPos - lightPos;
  let currentDist = length(L);
  let Lnorm = normalize(L);

  // Determine whether it is front or back simply by the sign of the z component
  let isFront = (Lnorm.z >= 0.0);

  // Denominators for paraboloid projection
  let denom = 1.0 + select(-Lnorm.z, Lnorm.z, isFront);

  // Convert to UV coordinates (normalized)
  // Lnorm.xy / denom is in [-1,1], so map it to [0,1]
  var uv = (Lnorm.xy / denom) * uvScale * 0.5 + 0.5;
  uv.y = 1.0 - uv.y;

  let storedMoments = select(
      textureSample(paraboloidDepthTexture, paraboloidDepthSampler, uv, depthTextureIndex).ba,
      textureSample(paraboloidDepthTexture, paraboloidDepthSampler, uv, depthTextureIndex).rg,
      isFront);

  let currentDepth = currentDist / farPlane;


  return chebyshevUpperBound(storedMoments, currentDepth);

  // float shadow = (currentDepth > storedMoments.r + 0.00001) ? 0.5 : 1.0;
  // return shadow;
}


#endif


// This file includes portions of code from the glTF-Sample-Renderer project by Khronos Group (Apache License 2.0).
// https://github.com/KhronosGroup/glTF-Sample-Renderer
// Modified by Yuki Shimada

fn srgbToLinear(srgbColor: vec3f) -> vec3f {
  return pow(srgbColor, vec3f(2.2));
}

fn linearToSrgb(linearColor: vec3f) -> vec3f {
  return pow(linearColor, vec3f(1.0/2.2));
}

// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66
fn Schlick_to_F0_F90(f: vec3f, f90: vec3f, VdotH: f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0_F90_F32(f: f32, f90: f32, VdotH: f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0(f: vec3f, VdotH: f32) -> vec3f {
    return Schlick_to_F0_F90(f, vec3(1.0), VdotH);
}

fn Schlick_to_F0_F32(f: f32, VdotH: f32) -> f32 {
    return Schlick_to_F0_F90_F32(f, 1.0, VdotH);
}


// The Schlick Approximation to Fresnel
fn fresnelSchlick(f0 : vec3f, f90 : vec3f, VdotH : f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnelSchlickF32(f0 : f32, f90 : f32, VdotH : f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnelSchlick2(f0: vec3f, VdotH: f32) -> vec3f
{
  let f90 = vec3f(1.0); //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelSchlick(f0, f90, VdotH);
}

fn fresnel2F32(f0: f32, VdotH: f32) -> f32
{
  let f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelSchlickF32(f0, f90, VdotH);
}

// Roughness Dependent Fresnel
// https://www.jcgt.org/published/0008/01/03/paper.pdf
fn fresnelSchlickRoughness(F0: vec3f, cosTheta: f32, roughness: f32) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);
  return k_S;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf
fn BRDF_lambertian(diffuseAlbedo: vec3f) -> vec3f
{
  return diffuseAlbedo * RECIPROCAL_PI;
}


// GGX NDF
fn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {
  let roughnessSqr = alphaRoughness * alphaRoughness;
  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
fn v_GGXCorrelated(NL: f32, NV: f32, alphaRoughness: f32) -> f32 {
  let a2 = alphaRoughness * alphaRoughness;
  let GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  let GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  let GGX = GGXV + GGXL;
  if (GGX > 0.0) {
    return clamp(0.5 / GGX, 0.0, 1.0);
  }
  return 1.0;
}

fn BRDF_specularGGX(NH: f32, NL: f32, NV: f32, alphaRoughness: f32) -> vec3f {
  let D = d_GGX(NH, alphaRoughness);
  let V = v_GGXCorrelated(NL, NV, alphaRoughness);
  return vec3f(D) * vec3f(V);
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
fn envBRDFApprox( Roughness: f32, NoV: f32 ) -> vec2f {
  let c0 = vec4f(-1, -0.0275, -0.572, 0.022 );
  let c1 = vec4f(1, 0.0425, 1.04, -0.04 );
  let r = Roughness * c0 + c1;
  let a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  let AB = vec2f( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}


// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes
fn specular_btdf(alphaRoughness: f32, NdotL: f32, NdotV: f32, NdotHt: f32) -> f32 {
  let V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  let D = d_GGX(NdotHt, alphaRoughness);
  return V * D;
}

fn IsotropicNDFFiltering(normal: vec3f, roughness2: f32) -> f32 {
  let SIGMA2 = 0.15915494;
  let KAPPA = 0.18;
  let dndu  = dpdx(normal);
  let dndv = dpdy(normal);
  let kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));
  let clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);
  let filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);
  return filteredRoughness2;
}

////////////////////////////////////////
// glTF KHR_materials_transmission
////////////////////////////////////////

#ifdef RN_USE_TRANSMISSION

// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
fn volumeAttenuation(attenuationColor: vec3f, attenuationDistance: f32, intensity: vec3f, transmissionDistance: f32) -> vec3f
{
  if (attenuationDistance == 0.0) { // means Infinite distance
    return intensity; // No attenuation
  } else {
    // let attenuationCo: vec3f = -log(attenuationColor) / attenuationDistance;
    // let attenuatedTransmittance: vec3f = exp(-attenuationCo * transmissionDistance);
    let attenuatedTransmittance: vec3f = pow(attenuationColor, vec3f(transmissionDistance / attenuationDistance));
    return intensity * attenuatedTransmittance;
  }
}

// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer
fn getVolumeTransmissionRay(n: vec3f, v: vec3f, thickness: f32, ior: f32, instanceInfo: u32) -> vec3f
{
  let refractionVector = refract(-v, normalize(n), 1.0 / ior);
  let worldMatrix = get_worldMatrix(instanceInfo);

  var modelScale: vec3f;
  modelScale.x = length(vec3f(worldMatrix[0].xyz));
  modelScale.y = length(vec3f(worldMatrix[1].xyz));
  modelScale.z = length(vec3f(worldMatrix[2].xyz));

  return normalize(refractionVector) * thickness * modelScale;
}
#endif

fn applyIorToRoughness(roughness: f32, ior: f32) -> f32
{
    return clamp(roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0), c_MinRoughness, 1.0);
}

fn calculateRadianceTransmission(normal: vec3f, view: vec3f, pointToLight: vec3f, alphaRoughness: f32, baseColor: vec3f, ior: f32) -> vec3f
{
    let transmissionRoughness = applyIorToRoughness(alphaRoughness, ior);

    let n = normalize(normal);
    let v = normalize(view);
    let l = normalize(pointToLight);
    let mirrorL = normalize(l + 2.0 * n * dot(-l, n));
    let h = normalize(mirrorL + v);

    let D = d_GGX(clamp(dot(n, h), 0.0, 1.0), transmissionRoughness);
    let V = v_GGXCorrelated(clamp(dot(n, mirrorL), 0.0, 1.0), clamp(dot(n, v), 0.0, 1.0), transmissionRoughness);

    return baseColor * D * V;
}




////////////////////////////////////////
// glTF KHR_materials_anisotropy
////////////////////////////////////////
#ifdef RN_USE_ANISOTROPY
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
fn D_GGX_anisotropic(NdotH: f32, TdotH: f32, BdotH: f32, at: f32, ab: f32) -> f32
{
    let a2 = at * ab;
    let f = vec3f(ab * TdotH, at * BdotH, a2 * NdotH);
    let w2 = a2 / dot(f, f);
    return a2 * w2 * w2 / M_PI;
}

fn V_GGX_anisotropic(NdotL: f32, NdotV: f32, BdotV: f32, TdotV: f32, TdotL: f32, BdotL: f32,
    at: f32, ab: f32) -> f32
{
    let GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));
    let GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));
    let GGX = GGXV + GGXL;
    if (GGX > 0.0) {
      return clamp(0.5 / GGX, 0.0, 1.0);
    }
    return 1.0;
}

fn BRDF_specularAnisotropicGGX(alphaRoughness: f32,
    VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32, BdotV: f32, TdotV: f32,
    TdotL: f32, BdotL: f32, TdotH: f32, BdotH: f32, anisotropy: f32) -> vec3f
{
    let at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
    let ab = clamp(alphaRoughness, 0.001, 1.0);

    let V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);
    let D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);

    return vec3f(V * D);
}
#endif

////////////////////////////////////////
// glTF KHR_materials_sheen
////////////////////////////////////////

#ifdef RN_USE_SHEEN
fn d_Charlie(sheenPerceptualRoughness: f32, NoH: f32) -> f32 {
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  let sheenRoughness = max(sheenPerceptualRoughness, 0.000001);
  let alphaG = sheenRoughness * sheenRoughness;
  let invAlpha  = 1.0 / alphaG;
  let cos2h = NoH * NoH;
  let sin2h = 1.0 - cos2h;
  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * M_PI);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn sheenSimpleVisibility(NdotL: f32, NdotV: f32) -> f32 {
  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn charlieL(x: f32, alphaG: f32) -> f32 {
  let oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
  let a = mix(21.5473, 25.3245, oneMinusAlphaSq);
  let b = mix(3.82987, 3.32435, oneMinusAlphaSq);
  let c = mix(0.19823, 0.16801, oneMinusAlphaSq);
  let d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
  let e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
  return a / (1.0 + b * pow(x, c)) + d * x + e;
}

fn lambdaSheen(cosTheta: f32, alphaG: f32) -> f32
{
  return select(exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG)), exp(charlieL(cosTheta, alphaG)), abs(cosTheta) < 0.5);
}

fn sheenCharlieVisibility(NdotL: f32, NdotV: f32, sheenPerceptualRoughness: f32) -> f32 {
  let sheenRoughness = max(sheenPerceptualRoughness, 0.000001);
  let alphaG = sheenRoughness * sheenRoughness;
  let sheenVisibility = clamp(1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL)), 0.0, 1.0);
  return sheenVisibility;
}

fn BRDF_specularSheen(sheenColor: vec3f, sheenPerceptualRoughness: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f {
  let sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);
  let sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);
  return sheenColor * sheenDistribution * sheenVisibility;
}
#endif // RN_USE_SHEEN

////////////////////////////////////////
// glTF KHR_materials_irirdescence
////////////////////////////////////////

#ifdef RN_USE_IRIDESCENCE
// XYZ to REC709(sRGB) conversion matrix
const XYZ_TO_REC709 = mat3x3<f32>(
     3.2404542, -0.9692660,  0.0556434,
    -1.5371385,  1.8760108, -0.2040259,
    -0.4985314,  0.0415560,  1.0572252
);

fn fresnelSchlickRoughnessWithIridescence(
  F0: vec3f, cosTheta: f32, roughness: f32,
  iridescenceFresnel: vec3f, iridescence: f32
  ) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);
  return k_S;
}

// Assume air interface for top
fn Fresnel0ToIor(F0: vec3f) -> vec3f {
    let sqrtF0 = sqrt(F0);
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// Conversion from IOR to F0
// ior is a value between 1.0 and 3.0. 1.0 is air interface
fn IorToFresnel0Vec3f(transmittedIor: vec3f, incidentIor: f32) -> vec3f {
    return sqVec3f((transmittedIor - vec3f(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
fn IorToFresnel0F32(transmittedIor: f32, incidentIor: f32) -> f32 {
    return sqF32((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration
 */
fn evalSensitivity(OPD: f32, shift: vec3f) -> vec3f {
    let phase = 2.0 * M_PI * OPD * 1.0e-9;
    let val = vec3f(5.4856e-13, 4.4201e-13, 5.2481e-13);
    let pos = vec3f(1.6810e+06, 1.7953e+06, 2.2084e+06);
    let var_ = vec3f(4.3278e+09, 9.3046e+09, 6.6121e+09);

    var xyz = val * sqrt(2.0 * M_PI * var_) * cos(pos * phase + shift) * exp(-(phase * phase) * var_);
    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));
    xyz /= 1.0685e-7;

    let rgb = XYZ_TO_REC709 * xyz;
    return rgb;
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel
 */
fn calcIridescence(outsideIor: f32, eta2: f32, cosTheta1: f32, thinFilmThickness: f32, baseF0: vec3f) -> vec3f {


  // iridescenceIor is the index of refraction of the thin-film layer
  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
  let iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));

  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)
  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.
  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.
  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):
  let sinTheta2Sq = sqF32(outsideIor / iridescenceIor) * (1.0 - sqF32(cosTheta1));
  let cosTheta2Sq = 1.0 - sinTheta2Sq;

  // Handle total internal reflection
  if (cosTheta2Sq < 0.0) {
      return vec3f(1.0);
  }

  let cosTheta2 = sqrt(cosTheta2Sq);

  /// Material Interfaces
  // The iridescence model defined by Belcour/Barla models two material interfaces
  // - one from the outside to the thin-film layer
  // and another one from the thin-film to the base material. These two interfaces are defined as follows:

  // First interface (from the outside to the thin-film layer)
  let R0 = IorToFresnel0F32(iridescenceIor, outsideIor);
  let R12 = fresnel2F32(R0, cosTheta1);
  let R21 = R12;
  let T121 = 1.0 - R12;

  // Second interface (from the thin-film to the base material)
  let baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0
  let R1 = IorToFresnel0Vec3f(baseIor, iridescenceIor);
  let R23 = fresnelSchlick2(R1, cosTheta2);

  // phi12 and phi23 define the base phases per interface and are approximated with 0.0
  // if the IOR of the hit material (iridescenceIor or baseIor) is higher
  // than the IOR of the previous material (outsideIor or iridescenceIor) and \u03C0 otherwise.
  // Also here, polarization is ignored.  float phi12 = 0.0;

  // First interface (from the outside to the thin-film layer)
  var phi12 = 0.0;
  if (iridescenceIor < outsideIor) { phi12 = M_PI; }
  let phi21 = M_PI - phi12;

  // Second interface (from the thin-film to the base material)
  var phi23 = vec3f(0.0);
  if (baseIor[0] < iridescenceIor) { phi23[0] = M_PI; }
  if (baseIor[1] < iridescenceIor) { phi23[1] = M_PI; }
  if (baseIor[2] < iridescenceIor) { phi23[2] = M_PI; }

  // OPD (optical path difference)
  let OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
  // Phase shift
  let phi = vec3f(phi21) + phi23;

  // Compound terms
  let R123 = clamp(R12 * R23, vec3f(1e-5), vec3f(0.9999));
  let r123 = sqrt(R123);
  let Rs = (T121 * T121) * R23 / (vec3f(1.0) - R123);

  // Reflectance term for m = 0 (DC term amplitude)
  let C0 = R12 + Rs;
  var I = C0;

  // Reflectance term for m > 0 (pairs of diracs)
  var Cm = Rs - T121;
  for (var m = 1; m <= 2; m++)
  {
      Cm *= r123;
      let Sm = 2.0 * evalSensitivity(f32(m) * OPD, f32(m) * phi);
      I += Cm * Sm;
  }

  let F_iridescence = max(I, vec3f(0.0));

  return F_iridescence;
}

//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB
fn BRDF_lambertianIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, iridescenceFactor: f32, diffuseColor: vec3f, specularWeight: f32, VdotH: f32) -> vec3f
{
    let iridescenceFresnelMax = vec3f(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));

    let schlickFresnel = Schlick_to_F0_F90(f0, f90, VdotH);

    let F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);

    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);
}

fn BRDF_specularGGXIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, alphaRoughness: f32, iridescenceFactor: f32, specularWeight: f32, VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f
{
    let F = mix(Schlick_to_F0_F90(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);
    let Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
    let D = d_GGX(NdotH, alphaRoughness);

    return specularWeight * F * Vis * D;
}

fn rgb_mix(base: vec3f, specular_brdf: vec3f, rgb_alpha: vec3f) -> vec3f
{
    let rgb_alpha_max = max(rgb_alpha.r, max(rgb_alpha.g, rgb_alpha.b));
    return (1.0 - rgb_alpha_max) * base + rgb_alpha * specular_brdf;
}

#endif // RN_USE_IRIDESCENCE


////////////////////////////////////////
// lighting with a punctual light
////////////////////////////////////////
fn lightingWithPunctualLight(
  light_: Light,
  normal_inWorld: vec3f,
  viewDirection: vec3f,
  NdotV: f32,
  baseColor: vec3f,
  perceptualRoughness: f32,
  metallic: f32,
  dielectricF0: vec3f,
  dielectricF90: vec3f,
  transmission: f32,
  thickness: f32,
  ior: f32,
  clearcoat: f32,
  clearcoatRoughness: f32,
  clearcoatF0: vec3f,
  clearcoatF90: vec3f,
  clearcoatFresnel: vec3f,
  clearcoatNormal_inWorld: vec3f,
  VdotNc: f32,
  attenuationColor: vec3f,
  attenuationDistance: f32,
  anisotropy: f32,
  anisotropicT: vec3f,
  anisotropicB: vec3f,
  BdotV: f32,
  TdotV: f32,
  sheenColor: vec3f,
  sheenRoughness: f32,
  albedoSheenScalingNdotV: f32,
  iridescence: f32,
  iridescenceFresnel_dielectric: vec3f,
  iridescenceFresnel_metal: vec3f,
  specularWeight: f32,
  instanceInfo: u32,
  diffuseTransmission: f32,
  diffuseTransmissionColor: vec3f,
  diffuseTransmissionThickness: f32
  ) -> vec3f
{
  var light = light_;
  let alphaRoughness = perceptualRoughness * perceptualRoughness;

  // Fresnel
  let halfVector = normalize(light.direction + viewDirection);
  let VdotH = saturate(dot(viewDirection, halfVector));
  var dielectricFresnel = fresnelSchlick(dielectricF0, dielectricF90, VdotH);
  let metalFresnel = fresnelSchlick(baseColor, vec3f(1.0), VdotH);

  let NdotL = saturateEpsilonToOne(dot(normal_inWorld, light.direction));

  // Diffuse
  let diffuseBrdf = BRDF_lambertian(baseColor);
  var diffuseContrib = diffuseBrdf * vec3f(NdotL) * light.attenuatedIntensity;

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  diffuseContrib = diffuseContrib * (vec3f(1.0) - diffuseTransmission);
  if (dot(normal_inWorld, light.direction) < 0.0) {
    let diffuseNdotL = saturate(dot(normal_inWorld, -light.direction));
    var diffuseBtdf = BRDF_lambertian(diffuseTransmissionColor) * vec3f(diffuseNdotL) * light.attenuatedIntensity;
    let mirrorL = normalize(light.direction + 2.0 * normal_inWorld * dot(normal_inWorld, -light.direction));
    let diffuseVdotH = saturate(dot(viewDirection, normalize(mirrorL + viewDirection)));
    dielectricFresnel = fresnelSchlick(dielectricF0 * specularWeight, dielectricF90, abs(diffuseVdotH));
#ifdef RN_USE_VOLUME
    diffuseBtdf = volumeAttenuation(attenuationColor, attenuationDistance, diffuseBtdf, diffuseTransmissionThickness);
#endif // RN_USE_VOLUME
    diffuseContrib += diffuseBtdf * diffuseTransmission;
  }
#endif // RN_USE_DIFFUSE_TRANSMISSION

#ifdef RN_USE_TRANSMISSION
  let transmittionRay = getVolumeTransmissionRay(normal_inWorld, viewDirection, thickness, ior, instanceInfo);
  light.pointToLight -= transmittionRay;
  light.direction = normalize(light.pointToLight);
  var transmittedContrib = calculateRadianceTransmission(normal_inWorld, viewDirection, light.direction, alphaRoughness, baseColor, ior) * light.attenuatedIntensity;

#ifdef RN_USE_VOLUME
  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittionRay));
#endif // RN_USE_VOLUME

  diffuseContrib = mix(diffuseContrib, vec3f(transmittedContrib), transmission);
#endif // RN_USE_TRANSMISSION

  // Specular
  let NdotH = saturate(dot(normal_inWorld, halfVector));

#ifdef RN_USE_ANISOTROPY
  let TdotL = dot(anisotropicT, light.direction);
  let BdotL = dot(anisotropicB, light.direction);
  let TdotH = dot(anisotropicT, halfVector);
  let BdotH = dot(anisotropicB, halfVector);
  let specularMetalContrib = BRDF_specularAnisotropicGGX(alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3f(NdotL) * light.attenuatedIntensity;
  let specularDielectricContrib = specularMetalContrib;
#else
  let specularMetalContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, alphaRoughness) * vec3f(NdotL) * light.attenuatedIntensity;
  let specularDielectricContrib = specularMetalContrib;
#endif

  // Base Layer
  var metal = specularMetalContrib * metalFresnel;
  var dielectric = mix(diffuseContrib, specularDielectricContrib, dielectricFresnel);

#ifdef RN_USE_IRIDESCENCE
  metal = mix(metal, specularMetalContrib * iridescenceFresnel_metal, iridescence);
  dielectric = mix(dielectric, rgb_mix(diffuseContrib, specularDielectricContrib, iridescenceFresnel_dielectric), iridescence);
#endif // RN_USE_IRIDESCENCE

#ifdef RN_USE_CLEARCOAT
  // Clear Coat Layer
  let NdotHc = saturate(dot(clearcoatNormal_inWorld, halfVector));
  let LdotNc = saturate(dot(light.direction, clearcoatNormal_inWorld));
  let clearcoatContrib = BRDF_specularGGX(NdotHc, LdotNc, VdotNc, clearcoatRoughness * clearcoatRoughness) * vec3f(LdotNc) * light.attenuatedIntensity;
#else
  let clearcoatContrib = vec3f(0.0);
#endif // RN_USE_CLEARCOAT

#ifdef RN_USE_SHEEN
  // Sheen
  let sheenContrib = BRDF_specularSheen(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;
  let albedoSheenScaling = min(
    albedoSheenScalingNdotV,
    1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotL, sheenRoughness)).r);
#else
  let sheenContrib = vec3f(0.0);
  let albedoSheenScaling = 1.0;
#endif // RN_USE_SHEEN

  var color = mix(dielectric, metal, metallic);
  color = sheenContrib + color * albedoSheenScaling;
  color = mix(color, clearcoatContrib, clearcoat * clearcoatFresnel);

  return color;
}

// This file includes portions of code from the glTF-Sample-Renderer project by Khronos Group (Apache License 2.0).
// https://github.com/KhronosGroup/glTF-Sample-Renderer
// Modified by Yuki Shimada

fn getIBLIrradiance(normal_forEnv: vec3f, iblParameter: vec4f, hdriFormat: vec2<i32>) -> vec3f {
  let diffuseTexel: vec4f = textureSample(diffuseEnvTexture, diffuseEnvSampler, normal_forEnv);

  var irradiance: vec3f;
  if (hdriFormat.x == 0) {
    // LDR_SRGB
    irradiance = srgbToLinear(diffuseTexel.rgb);
  }
  else if (hdriFormat.x == 3) {
    // RGBE
    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  }
  else {
    irradiance = diffuseTexel.rgb;
  }

  // scale with user parameters
  let IBLDiffuseContribution = iblParameter.y;
  irradiance *= IBLDiffuseContribution;

  return irradiance;
}

fn get_radiance(reflection: vec3f, lod: f32, hdriFormat: vec2<i32>) -> vec3f {
  let specularTexel = textureSampleLevel(specularEnvTexture, specularEnvSampler, reflection, lod);

  var radiance: vec3f;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

#ifdef RN_USE_SHEEN

fn get_radiance_sheen(reflection: vec3f, lod: f32, hdriFormat: vec2<i32>) -> vec3f {
  let specularTexel = textureSampleLevel(sheenEnvTexture, sheenEnvSampler, reflection, lod);

  var radiance: vec3f;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

fn sheenIBL(NdotV: f32, sheenPerceptualRoughness: f32, sheenColor: vec3f, iblParameter: vec4f, reflection: vec3f, hdriFormat: vec2i) -> vec3f
{
  let mipCount = iblParameter.x;
  let lod = (sheenPerceptualRoughness * (mipCount - 1.0));

  let sheenLutUV = vec2f(NdotV, sheenPerceptualRoughness);
  let brdf = textureSample(sheenLutTexture, sheenLutSampler, sheenLutUV).b;
  var sheenLight = get_radiance_sheen(reflection, lod, hdriFormat);
  let IBLSpecularContribution = iblParameter.z;
  sheenLight *= IBLSpecularContribution;

  return sheenLight * sheenColor * brdf;
}
#endif

fn getNormalForEnv(rotEnvMatrix: mat3x3<f32>, normal_inWorld: vec3f, materialSID: u32) -> vec3f {
  var normal_forEnv = rotEnvMatrix * normal_inWorld;
  if (get_inverseEnvironment(materialSID, 0)) {
    normal_forEnv.x *= -1.0;
  }
  return normal_forEnv;
}

fn getReflection(rotEnvMatrix: mat3x3<f32>, viewDirection: vec3f, normal_inWorld: vec3f,
  materialSID: u32, perceptualRoughness: f32,
  anisotropy: f32, anisotropyDirection: vec3f
  ) -> vec3f {
#ifdef RN_USE_ANISOTROPY
  let tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);
  let anisotropicTangent  = cross(anisotropyDirection, viewDirection);
  let anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);
  let bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);
  let bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;
  let bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));
  var reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);
#else
  var reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);
#endif
  if (get_inverseEnvironment(materialSID, 0)) {
    reflection.x *= -1.0;
  }
  return reflection;
}

fn scaleForLod(perceptualRoughness: f32, ior: f32) -> f32
{
  // Scale roughness to the range [0, 1],
  // ior=1.0 will be scale 0,
  // ior=1.5 will be scale 1.0,
  // ior=2 will be scale 1.0 (clamped)
  //

  let scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);
  return perceptualRoughness * scale;
}

#ifdef RN_USE_TRANSMISSION
fn get_sample_from_backbuffer(sampleCoord: vec2f, perceptualRoughness: f32, ior: f32) -> vec3f {
  let vrState: vec2<i32> = get_vrState(0, 0);
  let backBufferTextureSize = vec2f(textureDimensions(backBufferTexture, 0));
  var backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);
  var newSampleCoord = sampleCoord;
  newSampleCoord.y = 1.0 - newSampleCoord.y;
  if (vrState.x == 1) { // For VR
    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
    newSampleCoord.x = sampleCoord.x * 0.5;
    if (vrState.y == 1) { // For right eye
      newSampleCoord.x += 0.5;
    }
  }
  let framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);

  let transmittedLight = textureSampleLevel(backBufferTexture, backBufferSampler, newSampleCoord, framebufferLod).rgb;

  return transmittedLight;
}

fn getIBLVolumeRefraction(baseColor: vec3f, normal: vec3f, view: vec3f, cameraSID: u32, materialSID: u32, thickness: f32, perceptualRoughness: f32, ior: f32, attenuationColor: vec3f, attenuationDistance: f32, position_inWorld: vec3f, instanceInfo: u32) -> vec3f {
#ifdef RN_USE_DISPERSION
  let dispersion = get_dispersion(materialSID, 0);
  let halfSpread = (ior - 1.0) * 0.025 * dispersion;
  let iors = vec3f(ior - halfSpread, ior, ior + halfSpread);

  var transmittedLight: vec3f;
  var transmissionRayLength: f32;
  for(var i=0; i<3; i++) {
    let transmissionRay = getVolumeTransmissionRay(normal, view, thickness, iors[i], instanceInfo);
    transmissionRayLength = length(transmissionRay);
    let refractedRayExit = position_inWorld + transmissionRay;

    let ndcPos = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4f(refractedRayExit, 1.0);
    var refractionCoords = ndcPos.xy / ndcPos.w;
    refractionCoords += 1.0;
    refractionCoords /= 2.0;

    transmittedLight[i] = get_sample_from_backbuffer(refractionCoords, perceptualRoughness, iors[i])[i];
  }
#else
  let transmissionRay = getVolumeTransmissionRay(normal, view, thickness, ior, instanceInfo);
  let transmissionRayLength = length(transmissionRay);
  let refractedRayExit = position_inWorld + transmissionRay;

  let ndcPos = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4f(refractedRayExit, 1.0);
  var refractionCoords = ndcPos.xy / ndcPos.w;
  refractionCoords += 1.0;
  refractionCoords /= 2.0;

  let transmittedLight = get_sample_from_backbuffer(refractionCoords, perceptualRoughness, ior);
#endif
  let attenuatedColor = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, transmissionRayLength);

  return attenuatedColor * baseColor;
}

#endif // RN_USE_TRANSMISSION

struct IblResult
{
  specular: vec3f,
  diffuse: vec3f,
  FssEss: vec3f,
};

fn getIBLRadianceGGX(perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, reflection: vec3f) -> vec3f
{
  // get radiance
  let mipCount = iblParameter.x;
  let lod = (perceptualRoughness * (mipCount - 1.0));
  var radiance: vec3f = get_radiance(reflection, lod, hdriFormat);

  let IBLSpecularContribution = iblParameter.z;
  radiance *= IBLSpecularContribution;

  return radiance;
}

fn getIBLFresnelGGX(perceptualRoughness: f32, NdotV: f32, F0: vec3f, specularWeight: f32) -> vec3f {
  // https://bruop.github.io/ibl/#single_scattering_results

  // Roughness dependent fresnel
  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss: vec3f = vec3f(specularWeight) * (kS * f_ab.x + f_ab.y);

  // Multiple scattering
  let Ems: f32 = (1.0 - (f_ab.x + f_ab.y));
  let F_avg: vec3f = vec3f(specularWeight) * (F0 + (1.0 - F0) / 21.0);
  let FmsEms: vec3f = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);

  return FssEss + FmsEms;
}

fn IBLContribution(materialSID: u32, cameraSID: u32, normal_inWorld: vec3f, NdotV: f32, viewDirection: vec3f,
  baseColor: vec3f, perceptualRoughness: f32,
  clearcoatRoughness: f32, clearcoatNormal_inWorld: vec3f, clearcoat: f32, clearcoatFresnel: vec3f, VdotNc: f32, geomNormal_inWorld: vec3f,
  transmission: f32, position_inWorld: vec3f, instanceInfo: u32, thickness: f32, ior: f32,
  sheenColor: vec3f, sheenRoughness: f32, albedoSheenScalingNdotV: f32,
  iridescenceFresnel_dielectric: vec3f, iridescenceFresnel_metal: vec3f, iridescence: f32,
  anisotropy: f32, anisotropyDirection: vec3f, specularWeight: f32, dielectricF0: vec3f, metallic: f32,
  diffuseTransmission: f32, diffuseTransmissionColor: vec3f, diffuseTransmissionThickness: f32
  ) -> vec3f
{
  let iblParameter: vec4f = get_iblParameter(materialSID, 0);
  let rot = iblParameter.w;
  let rotEnvMatrix = mat3x3<f32>(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  let hdriFormat: vec2<i32> = get_hdriFormat(materialSID, 0);

  let normal_forEnv: vec3f = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  let reflection: vec3f = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);

  // get irradiance
  let irradiance: vec3f = getIBLIrradiance(normal_forEnv, iblParameter, hdriFormat);
  var diffuse: vec3f = irradiance * baseColor;

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  var diffuseTransmissionIBL: vec3f = getIBLIrradiance(-normal_forEnv, iblParameter, hdriFormat) * diffuseTransmissionColor;
#ifdef RN_USE_VOLUME
  diffuseTransmissionIBL = volumeAttenuation(attenuationColor, attenuationDistance, diffuseTransmissionIBL, diffuseTransmissionThickness);
#endif
  diffuse = mix(diffuse, diffuseTransmissionIBL, diffuseTransmission);
#endif

#ifdef RN_USE_TRANSMISSION
  let attenuationColor: vec3f = get_attenuationColor(materialSID, 0);
  let attenuationDistance: f32 = get_attenuationDistance(materialSID, 0);
  let specularTransmission: vec3f = getIBLVolumeRefraction(baseColor, normal_inWorld, viewDirection, cameraSID, materialSID, thickness, perceptualRoughness, ior, attenuationColor, attenuationDistance, position_inWorld, instanceInfo);
  diffuse = mix(diffuse, specularTransmission, transmission);
#endif

  // take account of anisotropy with reflection
  let specularMetal: vec3f = getIBLRadianceGGX(perceptualRoughness, iblParameter, hdriFormat, reflection);
  let specularDielectric: vec3f = specularMetal;

  // Calculate fresnel mix
  let fresnelMetal: vec3f = getIBLFresnelGGX(perceptualRoughness, NdotV, baseColor, 1.0);
  var metalContrib: vec3f = fresnelMetal * specularMetal;
  let fresnelDielectric: vec3f = getIBLFresnelGGX(perceptualRoughness, NdotV, dielectricF0, specularWeight);
  var dielectricContrib: vec3f = mix(diffuse, specularDielectric, fresnelDielectric);

#ifdef RN_USE_IRIDESCENCE
  metalContrib = mix(metalContrib, specularMetal * iridescenceFresnel_metal, iridescence);
  dielectricContrib = mix(dielectricContrib, rgb_mix(diffuse, specularDielectric, iridescenceFresnel_dielectric), iridescence);
#endif

#ifdef RN_USE_CLEARCOAT
  let clearcoatReflection: vec3f = getReflection(rotEnvMatrix, viewDirection, clearcoatNormal_inWorld, materialSID, clearcoatRoughness, 0.0, vec3(0.0));
  let clearcoatContrib: vec3f = getIBLRadianceGGX(clearcoatRoughness, iblParameter, hdriFormat, clearcoatReflection);
#else
  let clearcoatContrib: vec3f = vec3(0.0);
#endif

#ifdef RN_USE_SHEEN
  let sheenContrib: vec3f = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);
  let albedoSheenScaling: f32 = albedoSheenScalingNdotV;
#else
  let sheenContrib: vec3f = vec3(0.0);
  let albedoSheenScaling: f32 = 1.0;
#endif

  var color: vec3f = mix(dielectricContrib, metalContrib, metallic);
  color = sheenContrib + color * albedoSheenScaling;
  color = mix(color, clearcoatContrib, clearcoat * clearcoatFresnel);
  return color;
}



@fragment
fn main(
  input: VertexOutput,
  @builtin(front_facing) isFront: bool,
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;

  let viewPosition = get_viewPosition(cameraSID, 0);
  let viewVector = viewPosition - input.position_inWorld.xyz;
  let viewDirection = normalize(viewVector);

// BaseColor
  var baseColor = vec4<f32>(1, 1, 1, 1);
  var baseColorFactor = get_baseColorFactor(materialSID, 0u);

#ifdef RN_USE_COLOR_0
  baseColor = input.color_0;
#endif

  baseColor *= baseColorFactor;

#ifdef RN_USE_TEXCOORD_0
  let baseColorTextureTransformScale: vec2f = get_baseColorTextureTransformScale(materialSID, 0);
  let baseColorTextureTransformOffset: vec2f = get_baseColorTextureTransformOffset(materialSID, 0);
  let baseColorTextureTransformRotation: f32 = get_baseColorTextureTransformRotation(materialSID, 0);
  let baseColorTexcoordIndex: u32 = u32(get_baseColorTexcoordIndex(materialSID, 0));
  let baseColorTexcoord = getTexcoord(baseColorTexcoordIndex, input);
  let baseColorTexUv = uvTransform(baseColorTextureTransformScale, baseColorTextureTransformOffset, baseColorTextureTransformRotation, baseColorTexcoord);
  let textureColor = textureSample(baseColorTexture, baseColorSampler, baseColorTexUv);
  baseColor *= vec4(srgbToLinear(textureColor.rgb), textureColor.a);
#else
  let baseColorTexUv = vec2f(0.0, 0.0);
#endif

#ifdef RN_IS_ALPHA_MODE_MASK
  let alphaCutoff = get_alphaCutoff(materialSID, 0);
  if (baseColor.a < alphaCutoff) {
    discard;
  }
#endif



// Normal
  var normal_inWorld = normalize(input.normal_inWorld);
  let geomNormal_inWorld = normal_inWorld;
  let normalTextureTransformScale: vec2f = get_normalTextureTransformScale(materialSID, 0);
  let normalTextureTransformOffset: vec2f = get_normalTextureTransformOffset(materialSID, 0);
  let normalTextureTransformRotation: f32 = get_normalTextureTransformRotation(materialSID, 0);
  let normalTexcoordIndex: u32 = u32(get_normalTexcoordIndex(materialSID, 0));
  let normalTexcoord: vec2f = getTexcoord(normalTexcoordIndex, input);
  let normalTexUv: vec2f = uvTransform(normalTextureTransformScale, normalTextureTransformOffset, normalTextureTransformRotation, normalTexcoord);
  let TBN: mat3x3<f32> = getTBN(normal_inWorld, input, viewVector, normalTexUv, isFront);
  #ifdef RN_USE_NORMAL_TEXTURE
    let normalTexValue: vec3f = textureSample(normalTexture, normalSampler, normalTexUv).xyz;
    if(normalTexValue.b >= 128.0 / 255.0) {
      // normal texture is existence
      let normalTex = normalTexValue * 2.0 - 1.0;
      let normalScale = get_normalScale(materialSID, 0);
      let scaledNormal = normalize(normalTex * vec3(normalScale, normalScale, 1.0));
      normal_inWorld = normalize(TBN * scaledNormal);
    }
  #endif

#ifdef RN_IS_LIGHTING
  // Metallic & Roughness
  let metallicRoughnessTextureTransformScale: vec2f = get_metallicRoughnessTextureTransformScale(materialSID, 0);
  let metallicRoughnessTextureTransformOffset: vec2f = get_metallicRoughnessTextureTransformOffset(materialSID, 0);
  let metallicRoughnessTextureTransformRotation: f32 = get_metallicRoughnessTextureTransformRotation(materialSID, 0);
  let metallicRoughnessTexcoordIndex = u32(get_metallicRoughnessTexcoordIndex(materialSID, 0));
  let metallicRoughnessTexcoord = getTexcoord(metallicRoughnessTexcoordIndex, input);
  let metallicRoughnessTexUv = uvTransform(metallicRoughnessTextureTransformScale, metallicRoughnessTextureTransformOffset, metallicRoughnessTextureTransformRotation, metallicRoughnessTexcoord);
  let ormTexel = textureSample(metallicRoughnessTexture, metallicRoughnessSampler, metallicRoughnessTexUv);
  var perceptualRoughness = ormTexel.g * get_roughnessFactor(materialSID, 0);
  var metallic = ormTexel.b * get_metallicFactor(materialSID, 0);
  metallic = clamp(metallic, 0.0, 1.0);
  perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
  let alphaRoughness = perceptualRoughness * perceptualRoughness;
    // filter NDF for specular AA --- https://jcgt.org/published/0010/02/02/
  let alphaRoughness2 = alphaRoughness * alphaRoughness;
  let filteredRoughness2 = IsotropicNDFFiltering(normal_inWorld, alphaRoughness2);
  perceptualRoughness = sqrt(sqrt(filteredRoughness2));

  // Albedo
  let black = vec3f(0.0);
  let albedo = mix(baseColor.rgb, black, metallic);

  // NdotV
  let NdotV = saturate(dot(normal_inWorld, viewDirection));

#ifdef RN_USE_ANISOTROPY
  // Anisotropy
  var anisotropy: f32 = get_anisotropyStrength(materialSID, 0);
  let anisotropyRotation: vec2f = get_anisotropyRotation(materialSID, 0);
  var direction: vec2f = anisotropyRotation;
  let anisotropyTexcoordIndex = u32(get_anisotropyTexcoordIndex(materialSID, 0));
  let anisotropyTexcoord = getTexcoord(anisotropyTexcoordIndex, input);
  let anisotropyTextureTransformScale: vec2f = get_anisotropyTextureTransformScale(materialSID, 0);
  let anisotropyTextureTransformOffset: vec2f = get_anisotropyTextureTransformOffset(materialSID, 0);
  let anisotropyTextureTransformRotation: f32 = get_anisotropyTextureTransformRotation(materialSID, 0);
  let anisotropyTexUv = uvTransform(anisotropyTextureTransformScale, anisotropyTextureTransformOffset, anisotropyTextureTransformRotation, anisotropyTexcoord);
  let anisotropyTex = textureSample(anisotropyTexture, anisotropySampler, anisotropyTexUv);
  direction = anisotropyTex.rg * 2.0 - vec2f(1.0);
  direction = mat2x2<f32>(anisotropyRotation.x, anisotropyRotation.y, -anisotropyRotation.y, anisotropyRotation.x) * normalize(direction);
  anisotropy *= anisotropyTex.b;
  let anisotropicT: vec3f = normalize(TBN * vec3f(direction, 0.0));
  let anisotropicB: vec3f = normalize(cross(geomNormal_inWorld, anisotropicT));
  let BdotV: f32 = dot(anisotropicB, viewDirection);
  let TdotV: f32 = dot(anisotropicT, viewDirection);
#else
  let anisotropy = 0.0;
  let anisotropicT = vec3f(0.0, 0.0, 0.0);
  let anisotropicB = vec3f(0.0, 0.0, 0.0);
  let BdotV = 0.0;
  let TdotV = 0.0;
#endif

let ior = get_ior(materialSID, 0);

  // Transmission
#ifdef RN_USE_TRANSMISSION
  let transmissionFactor = get_transmissionFactor(materialSID, 0);
  let transmissionTextureTransformScale: vec2f = get_transmissionTextureTransformScale(materialSID, 0);
  let transmissionTextureTransformOffset: vec2f = get_transmissionTextureTransformOffset(materialSID, 0);
  let transmissionTextureTransformRotation: f32 = get_transmissionTextureTransformRotation(materialSID, 0);
  let transmissionTexcoordIndex = get_transmissionTexcoordIndex(materialSID, 0);
  let transmissionTexcoord = getTexcoord(transmissionTexcoordIndex, input);
  let transmissionTexUv = uvTransform(transmissionTextureTransformScale, transmissionTextureTransformOffset, transmissionTextureTransformRotation, transmissionTexcoord);
  let transmissionTexture = textureSample(transmissionTexture, transmissionSampler, transmissionTexUv).r;
  let transmission = transmissionFactor * transmissionTexture;
    // alpha *= transmission;
#else
  let transmission = 0.0;
#endif // RN_USE_TRANSMISSION

#ifdef RN_USE_SPECULAR
  let specularTextureTransformScale: vec2f = get_specularTextureTransformScale(materialSID, 0);
  let specularTextureTransformOffset: vec2f = get_specularTextureTransformOffset(materialSID, 0);
  let specularTextureTransformRotation: f32 = get_specularTextureTransformRotation(materialSID, 0);
  let specularTexcoordIndex = get_specularTexcoordIndex(materialSID, 0);
  let specularTexcoord = getTexcoord(specularTexcoordIndex, input);
  let specularTexUv = uvTransform(specularTextureTransformScale, specularTextureTransformOffset, specularTextureTransformRotation, specularTexcoord);
  let specularTexture: f32 = textureSample(specularTexture, specularSampler, specularTexUv).a;
  let specularWeight: f32 = get_specularFactor(materialSID, 0) * specularTexture;
  let specularColorTextureTransformScale: vec2f = get_specularColorTextureTransformScale(materialSID, 0);
  let specularColorTextureTransformOffset: vec2f = get_specularColorTextureTransformOffset(materialSID, 0);
  let specularColorTextureTransformRotation: f32 = get_specularColorTextureTransformRotation(materialSID, 0);
  let specularColorTexcoordIndex = get_specularColorTexcoordIndex(materialSID, 0);
  let specularColorTexcoord = getTexcoord(specularColorTexcoordIndex, input);
  let specularColorTexUv = uvTransform(specularColorTextureTransformScale, specularColorTextureTransformOffset, specularColorTextureTransformRotation, specularColorTexcoord);
  let specularColorTexture: vec3f = srgbToLinear(textureSample(specularColorTexture, specularColorSampler, specularColorTexUv).rgb);
  let specularColor: vec3f = get_specularColorFactor(materialSID, 0) * specularColorTexture;
#else
  let specularWeight = 1.0;
  let specularColor = vec3f(1.0, 1.0, 1.0);
#endif // RN_USE_SPECULAR

  // F0, F90
  let outsideIor = 1.0;
  var dielectricF0 = vec3f(sqF32((ior - outsideIor) / (ior + outsideIor)));
  dielectricF0 = min(dielectricF0 * specularColor, vec3f(1.0));
  let dielectricF90 = vec3f(specularWeight);

// Iridescence
#ifdef RN_USE_IRIDESCENCE
  let iridescenceFactor: f32 = get_iridescenceFactor(materialSID, 0);
  let iridescenceTextureTransformScale: vec2f = get_iridescenceTextureTransformScale(materialSID, 0);
  let iridescenceTextureTransformOffset: vec2f = get_iridescenceTextureTransformOffset(materialSID, 0);
  let iridescenceTextureTransformRotation: f32 = get_iridescenceTextureTransformRotation(materialSID, 0);
  let iridescenceTexcoordIndex = get_iridescenceTexcoordIndex(materialSID, 0);
  let iridescenceTexcoord = getTexcoord(iridescenceTexcoordIndex, input);
  let iridescenceTexUv = uvTransform(iridescenceTextureTransformScale, iridescenceTextureTransformOffset, iridescenceTextureTransformRotation, iridescenceTexcoord);
  let iridescenceTexture: f32 = textureSample(iridescenceTexture, iridescenceSampler, iridescenceTexUv).r;
  let iridescence: f32 = iridescenceFactor * iridescenceTexture;

  let iridescenceThicknessTextureTransformScale: vec2f = get_iridescenceThicknessTextureTransformScale(materialSID, 0);
  let iridescenceThicknessTextureTransformOffset: vec2f = get_iridescenceThicknessTextureTransformOffset(materialSID, 0);
  let iridescenceThicknessTextureTransformRotation: f32 = get_iridescenceThicknessTextureTransformRotation(materialSID, 0);
  let iridescenceThicknessTexcoordIndex = get_iridescenceThicknessTexcoordIndex(materialSID, 0);
  let iridescenceThicknessTexcoord = getTexcoord(iridescenceThicknessTexcoordIndex, input);
  let iridescenceThicknessTexUv = uvTransform(iridescenceThicknessTextureTransformScale, iridescenceThicknessTextureTransformOffset, iridescenceThicknessTextureTransformRotation, iridescenceThicknessTexcoord);
  let thicknessRatio: f32 = textureSample(iridescenceThicknessTexture, iridescenceThicknessSampler, iridescenceThicknessTexUv).g;
  let iridescenceThicknessMinimum: f32 = get_iridescenceThicknessMinimum(materialSID, 0);
  let iridescenceThicknessMaximum: f32 = get_iridescenceThicknessMaximum(materialSID, 0);
  let iridescenceThickness: f32 = mix(iridescenceThicknessMinimum, iridescenceThicknessMaximum, thicknessRatio);

  let iridescenceIor: f32 = get_iridescenceIor(materialSID, 0);
  let iridescenceFresnel_dielectric: vec3f = calcIridescence(1.0, iridescenceIor, NdotV, iridescenceThickness, dielectricF0);
  let iridescenceFresnel_metal: vec3f = calcIridescence(1.0, iridescenceIor, NdotV, iridescenceThickness, baseColor.rgb);
#else
  let iridescence = 0.0;
  let iridescenceFresnel_dielectric = vec3f(0.0);
  let iridescenceFresnel_metal = vec3f(0.0);
#endif // RN_USE_IRIDESCENCE

// Clearcoat
#ifdef RN_USE_CLEARCOAT
  let clearcoatFactor = get_clearcoatFactor(materialSID, 0);
  let clearcoatTextureTransformScale: vec2f = get_clearcoatTextureTransformScale(materialSID, 0);
  let clearcoatTextureTransformOffset: vec2f = get_clearcoatTextureTransformOffset(materialSID, 0);
  let clearcoatTextureTransformRotation: f32 = get_clearcoatTextureTransformRotation(materialSID, 0);
  let clearcoatTexcoordIndex = get_clearcoatTexcoordIndex(materialSID, 0);
  let clearcoatTexcoord = getTexcoord(clearcoatTexcoordIndex, input);
  let clearcoatTexUv = uvTransform(clearcoatTextureTransformScale, clearcoatTextureTransformOffset, clearcoatTextureTransformRotation, clearcoatTexcoord);
  let clearcoatTexture = textureSample(clearcoatTexture, clearcoatSampler, clearcoatTexUv).r;
  let clearcoat = clearcoatFactor * clearcoatTexture;

  let clearcoatRoughnessFactor = get_clearcoatRoughnessFactor(materialSID, 0);
  let clearcoatRoughnessTexcoordIndex = get_clearcoatRoughnessTexcoordIndex(materialSID, 0);
  let clearcoatRoughnessTexcoord = getTexcoord(clearcoatRoughnessTexcoordIndex, input);
  let clearcoatRoughnessTextureTransformScale: vec2f = get_clearcoatRoughnessTextureTransformScale(materialSID, 0);
  let clearcoatRoughnessTextureTransformOffset: vec2f = get_clearcoatRoughnessTextureTransformOffset(materialSID, 0);
  let clearcoatRoughnessTextureTransformRotation: f32 = get_clearcoatRoughnessTextureTransformRotation(materialSID, 0);
  let clearcoatRoughnessTexUv = uvTransform(clearcoatRoughnessTextureTransformScale, clearcoatRoughnessTextureTransformOffset, clearcoatRoughnessTextureTransformRotation, clearcoatRoughnessTexcoord);
  let textureRoughnessTexture = textureSample(clearcoatRoughnessTexture, clearcoatRoughnessSampler, clearcoatRoughnessTexUv).g;
  let clearcoatRoughness = clearcoatRoughnessFactor * textureRoughnessTexture;

  let clearcoatNormalTexcoordIndex = get_clearcoatNormalTexcoordIndex(materialSID, 0);
  let clearcoatNormalTexcoord = getTexcoord(clearcoatNormalTexcoordIndex, input);
  let clearcoatNormalTextureTransformScale: vec2f = get_clearcoatNormalTextureTransformScale(materialSID, 0);
  let clearcoatNormalTextureTransformOffset: vec2f = get_clearcoatNormalTextureTransformOffset(materialSID, 0);
  let clearcoatNormalTextureTransformRotation: f32 = get_clearcoatNormalTextureTransformRotation(materialSID, 0);
  let clearcoatNormalTexUv = uvTransform(clearcoatNormalTextureTransformScale, clearcoatNormalTextureTransformOffset, clearcoatNormalTextureTransformRotation, clearcoatNormalTexcoord);
  let textureNormal_tangent = textureSample(clearcoatNormalTexture, clearcoatNormalSampler, clearcoatNormalTexUv).xyz * vec3(2.0) - vec3(1.0);
  let clearcoatNormal_inWorld = normalize(TBN * textureNormal_tangent);
  let VdotNc = saturate(dot(viewDirection, clearcoatNormal_inWorld));

  let clearcoatF0 = vec3f(pow((ior - 1.0) / (ior + 1.0), 2.0));
  let clearcoatF90 = vec3f(1.0);
  let clearcoatFresnel = fresnelSchlick(clearcoatF0, clearcoatF90, VdotNc);
#else
  let clearcoat = 0.0;
  let clearcoatRoughness = 0.0;
  let clearcoatNormal_inWorld = vec3f(0.0);
  let VdotNc = 0.0;
  let clearcoatF0 = vec3f(0.0);
  let clearcoatF90 = vec3f(0.0);
  let clearcoatFresnel = vec3f(0.0);
#endif // RN_USE_CLEARCOAT


#ifdef RN_USE_VOLUME
  // Volume
  let thicknessFactor: f32 = get_thicknessFactor(materialSID, 0);
  let thicknessTexcoordIndex = get_thicknessTexcoordIndex(materialSID, 0);
  let thicknessTexcoord = getTexcoord(thicknessTexcoordIndex, input);
  let thicknessTextureTransformScale: vec2f = get_thicknessTextureTransformScale(materialSID, 0);
  let thicknessTextureTransformOffset: vec2f = get_thicknessTextureTransformOffset(materialSID, 0);
  let thicknessTextureTransformRotation: f32 = get_thicknessTextureTransformRotation(materialSID, 0);
  let thicknessTexUv = uvTransform(thicknessTextureTransformScale, thicknessTextureTransformOffset, thicknessTextureTransformRotation, thicknessTexcoord);
  let thicknessTexture: f32 = textureSample(thicknessTexture, thicknessSampler, thicknessTexUv).g;
  let attenuationDistance: f32 = get_attenuationDistance(materialSID, 0);
  let attenuationColor: vec3f = get_attenuationColor(materialSID, 0);
  let thickness: f32 = thicknessFactor * thicknessTexture;
#else
  let thickness = 0.0;
  let attenuationColor = vec3f(0.0);
  let attenuationDistance = 0.000001;
#endif // RN_USE_VOLUME

#ifdef RN_USE_SHEEN
  // Sheen
  let sheenColorFactor: vec3f = get_sheenColorFactor(materialSID, 0);
  let sheenColorTextureTransformScale: vec2f = get_sheenColorTextureTransformScale(materialSID, 0);
  let sheenColorTextureTransformOffset: vec2f = get_sheenColorTextureTransformOffset(materialSID, 0);
  let sheenColorTextureTransformRotation: f32 = get_sheenColorTextureTransformRotation(materialSID, 0);
  let sheenColorTexcoordIndex = get_sheenColorTexcoordIndex(materialSID, 0);
  let sheenColorTexcoord = getTexcoord(sheenColorTexcoordIndex, input);
  let sheenColorTexUv = uvTransform(sheenColorTextureTransformScale, sheenColorTextureTransformOffset, sheenColorTextureTransformRotation, sheenColorTexcoord);
  let sheenColorTexture: vec3f = textureSample(sheenColorTexture, sheenColorSampler, sheenColorTexUv).rgb;

  let sheenRoughnessFactor: f32 = get_sheenRoughnessFactor(materialSID, 0);
  let sheenRoughnessTextureTransformScale: vec2f = get_sheenRoughnessTextureTransformScale(materialSID, 0);
  let sheenRoughnessTextureTransformOffset: vec2f = get_sheenRoughnessTextureTransformOffset(materialSID, 0);
  let sheenRoughnessTextureTransformRotation: f32 = get_sheenRoughnessTextureTransformRotation(materialSID, 0);
  let sheenRoughnessTexcoordIndex = get_sheenRoughnessTexcoordIndex(materialSID, 0);
  let sheenRoughnessTexcoord = getTexcoord(sheenRoughnessTexcoordIndex, input);
  let sheenRoughnessTexUv = uvTransform(sheenRoughnessTextureTransformScale, sheenRoughnessTextureTransformOffset, sheenRoughnessTextureTransformRotation, sheenRoughnessTexcoord);
  let sheenRoughnessTexture: f32 = textureSample(sheenRoughnessTexture, sheenRoughnessSampler, sheenRoughnessTexUv).a;

  let sheenColor: vec3f = sheenColorFactor * sheenColorTexture;
  let sheenRoughness: f32 = clamp(sheenRoughnessFactor * sheenRoughnessTexture, 0.000001, 1.0);
  let albedoSheenScalingNdotV: f32 = 1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotV, sheenRoughness)).r;
#else
  let sheenColor = vec3f(0.0);
  let sheenRoughness = 0.000001;
  let albedoSheenScalingNdotV = 1.0;
#endif // RN_USE_SHEEN

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  let diffuseTransmissionFactor = get_diffuseTransmissionFactor(materialSID, 0);
  let diffuseTransmissionTextureTransformScale = get_diffuseTransmissionTextureTransformScale(materialSID, 0);
  let diffuseTransmissionTextureTransformOffset = get_diffuseTransmissionTextureTransformOffset(materialSID, 0);
  let diffuseTransmissionTextureTransformRotation = get_diffuseTransmissionTextureTransformRotation(materialSID, 0);
  let diffuseTransmissionTexcoordIndex = get_diffuseTransmissionTexcoordIndex(materialSID, 0);
  let diffuseTransmissionTexcoord = getTexcoord(diffuseTransmissionTexcoordIndex, input);
  let diffuseTransmissionTexUv = uvTransform(diffuseTransmissionTextureTransformScale, diffuseTransmissionTextureTransformOffset, diffuseTransmissionTextureTransformRotation, diffuseTransmissionTexcoord);
  let diffuseTransmissionTexture = textureSample(diffuseTransmissionTexture, diffuseTransmissionSampler, diffuseTransmissionTexUv).a;
  let diffuseTransmission = diffuseTransmissionFactor * diffuseTransmissionTexture;

  let diffuseTransmissionColorFactor = get_diffuseTransmissionColorFactor(materialSID, 0);
  let diffuseTransmissionColorTextureTransformScale = get_diffuseTransmissionColorTextureTransformScale(materialSID, 0);
  let diffuseTransmissionColorTextureTransformOffset = get_diffuseTransmissionColorTextureTransformOffset(materialSID, 0);
  let diffuseTransmissionColorTextureTransformRotation = get_diffuseTransmissionColorTextureTransformRotation(materialSID, 0);
  let diffuseTransmissionColorTexcoordIndex = get_diffuseTransmissionColorTexcoordIndex(materialSID, 0);
  let diffuseTransmissionColorTexcoord = getTexcoord(diffuseTransmissionColorTexcoordIndex, input);
  let diffuseTransmissionColorTexUv = uvTransform(diffuseTransmissionColorTextureTransformScale, diffuseTransmissionColorTextureTransformOffset, diffuseTransmissionColorTextureTransformRotation, diffuseTransmissionColorTexcoord);
  let diffuseTransmissionColorTexture = textureSample(diffuseTransmissionColorTexture, diffuseTransmissionColorSampler, diffuseTransmissionColorTexUv).rgb;
  let diffuseTransmissionColor = diffuseTransmissionColorFactor * diffuseTransmissionColorTexture;
  var diffuseTransmissionThickness = 1.0;

#ifdef RN_USE_VOLUME
  let worldMatrix = get_worldMatrix(u32(input.instanceInfo));
  diffuseTransmissionThickness = thickness * (length(worldMatrix[0].xyz) * length(worldMatrix[1].xyz) * length(worldMatrix[2].xyz)) / 3.0;
#endif // RN_USE_VOLUME

#else
  let diffuseTransmission = 0.0;
  let diffuseTransmissionColor = vec3f(0.0);
  let diffuseTransmissionThickness = 0.0;
#endif // RN_USE_DIFFUSE_TRANSMISSION

  var resultColor = vec3<f32>(0, 0, 0);
  var resultAlpha = baseColor.a;

  // Punctual Lights
  let lightNumber = u32(get_lightNumber(0u, 0u));
  for (var i = 0u; i < lightNumber; i++) {
    let light: Light = getLight(i, input.position_inWorld);
    var lighting = lightingWithPunctualLight(light, normal_inWorld, viewDirection,
                            NdotV, baseColor.rgb, perceptualRoughness, metallic, dielectricF0, dielectricF90,
                            transmission, thickness, ior,
                            clearcoat, clearcoatRoughness, clearcoatF0, clearcoatF90, clearcoatFresnel, clearcoatNormal_inWorld, VdotNc,
                            attenuationColor, attenuationDistance,
                            anisotropy, anisotropicT, anisotropicB, BdotV, TdotV,
                            sheenColor, sheenRoughness, albedoSheenScalingNdotV,
                            iridescence, iridescenceFresnel_dielectric, iridescenceFresnel_metal, specularWeight, u32(input.instanceInfo),
                            diffuseTransmission, diffuseTransmissionColor, diffuseTransmissionThickness
                            );

    #ifdef RN_USE_SHADOW_MAPPING
      // Point Light
      let depthTextureIndex = u32(get_depthTextureIndexList(materialSID, i));
      let pointLightFarPlane = get_pointLightFarPlane(materialSID, 0);
      let pointLightShadowMapUvScale = get_pointLightShadowMapUvScale(materialSID, 0);
      let shadowContributionParaboloid = varianceShadowContributionParaboloid(input.position_inWorld.xyz, light.position, pointLightFarPlane, pointLightShadowMapUvScale, depthTextureIndex);

      // Directional Light or Spot Light
      let v_shadowCoord = get_depthBiasPV(materialSID, i) * vec4f(input.position_inWorld, 1.0);
      let bias = 0.001;
      let shadowCoord = v_shadowCoord.xy / v_shadowCoord.w;
      let lightDirection = normalize(get_lightDirection(0, i));
      let lightPosToWorldPos = normalize(input.position_inWorld.xyz - light.position);
      let dotProduct = dot(lightPosToWorldPos, lightDirection);
      var shadowContribution = 1.0;
      shadowContribution = varianceShadowContribution(shadowCoord, (v_shadowCoord.z - bias)/v_shadowCoord.w, depthTextureIndex);

      if (light.lightType == 1 && depthTextureIndex >= 0) { // Point Light
        lighting *= shadowContributionParaboloid;
      } else if ((light.lightType == 0 || light.lightType == 2) && depthTextureIndex >= 0) { // Directional Light or Spot Light
        if (dotProduct > 0.0 && shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0) {
          lighting *= shadowContribution;
        }
      }
    #endif

    lighting = select(lighting, vec3f(0.0), light.lightType < 0);

    resultColor += lighting;
  }

  // Image-based Lighting
  let ibl: vec3f = IBLContribution(materialSID, cameraSID, normal_inWorld, NdotV, viewDirection,
    baseColor.rgb, perceptualRoughness,
    clearcoatRoughness, clearcoatNormal_inWorld, clearcoat, clearcoatFresnel, VdotNc, geomNormal_inWorld,
    transmission, input.position_inWorld.xyz, u32(input.instanceInfo), thickness, ior,
    sheenColor, sheenRoughness, albedoSheenScalingNdotV,
    iridescenceFresnel_dielectric, iridescenceFresnel_metal, iridescence,
    anisotropy, anisotropicB, specularWeight, dielectricF0, metallic,
    diffuseTransmission, diffuseTransmissionColor, diffuseTransmissionThickness
  );

  let occlusionTexcoordIndex = get_occlusionTexcoordIndex(materialSID, 0);
  let occlusionTexcoord = getTexcoord(occlusionTexcoordIndex, input);
  let occlusionTextureTransformScale: vec2f = get_occlusionTextureTransformScale(materialSID, 0);
  let occlusionTextureTransformOffset: vec2f = get_occlusionTextureTransformOffset(materialSID, 0);
  let occlusionTextureTransformRotation: f32 = get_occlusionTextureTransformRotation(materialSID, 0);
  let occlusionTexUv = uvTransform(occlusionTextureTransformScale, occlusionTextureTransformOffset, occlusionTextureTransformRotation, occlusionTexcoord);
  let occlusion = textureSample(occlusionTexture, occlusionSampler, occlusionTexUv).r;
  let occlusionStrength = get_occlusionStrength(materialSID, 0);

  // Occlusion to Indirect Lights
  let indirectLight = ibl * (1.0 + occlusionStrength * (occlusion - 1.0));
  resultColor += indirectLight;
#else
  var resultColor = baseColor.rgb;
  var resultAlpha = baseColor.a;
#endif // RN_IS_LIGHTING

  // Emissive
  let emissiveFactor = get_emissiveFactor(materialSID, 0);
  let emissiveTexcoordIndex = get_emissiveTexcoordIndex(materialSID, 0);
  let emissiveTexcoord = getTexcoord(emissiveTexcoordIndex, input);
  let emissiveTextureTransformScale: vec2f = get_emissiveTextureTransformScale(materialSID, 0);
  let emissiveTextureTransformOffset: vec2f = get_emissiveTextureTransformOffset(materialSID, 0);
  let emissiveTextureTransformRotation: f32 = get_emissiveTextureTransformRotation(materialSID, 0);
  let emissiveTexUv = uvTransform(emissiveTextureTransformScale, emissiveTextureTransformOffset, emissiveTextureTransformRotation, emissiveTexcoord);
  var emissive = emissiveFactor * srgbToLinear(textureSample(emissiveTexture, emissiveSampler, emissiveTexUv).xyz);
#ifdef RN_USE_EMISSIVE_STRENGTH
  let emissiveStrength = get_emissiveStrength(materialSID, 0);
  emissive *= emissiveStrength;
#endif // RN_USE_EMISSIVE_STRENGTH

#ifdef RN_USE_CLEARCOAT
  let coated_emissive = emissive * mix(vec3f(1.0), vec3f(0.04 + (1.0 - 0.04) * pow(1.0 - NdotV, 5.0)), clearcoat);
  resultColor += coated_emissive;
#else
  resultColor += emissive;
#endif // RN_USE_CLEARCOAT

#ifdef RN_IS_ALPHA_MODE_BLEND
#else
  resultAlpha = 1.0;
#endif

let makeOutputSrgb = get_makeOutputSrgb(materialSID, 0);
resultColor = select(resultColor.rgb, linearToSrgb(resultColor.rgb), makeOutputSrgb);

  return vec4f(resultColor * resultAlpha, resultAlpha);
}
`,shaderStage:"fragment",isFragmentShader:!0}});var tS,eS=C(()=>{tS={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

#ifdef WEBGL2_MULTI_VIEW
  layout(num_views=2) in;
#endif

in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec3 a_position;
in vec3 a_color;
in vec3 a_normal;

out vec2 v_texcoord_0;
out vec3 v_color;
out vec3 v_normal_inWorld;
out vec3 v_position_inWorld;

uniform bool u_enableViewMatrix; // initialValue=true

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

void main(){
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);

  if (get_enableViewMatrix(materialSID, 0)) {
    mat4 rotateMatrix = viewMatrix;
    rotateMatrix[3][0] = 0.0;
    rotateMatrix[3][1] = 0.0;
    rotateMatrix[3][2] = 0.0;
    gl_Position = projectionMatrix * rotateMatrix * worldMatrix * vec4(a_position, 1.0);
  } else {
    gl_Position = projectionMatrix * worldMatrix * vec4(a_position, 1.0);
  }

  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);
  v_normal_inWorld = normalMatrix * a_normal;

  v_color = a_color;
  v_position_inWorld = (worldMatrix * vec4(a_position, 1.0)).xyz;
  v_texcoord_0 = a_texcoord_0;

}
`,shaderStage:"vertex",isFragmentShader:!1}});var oS,nS=C(()=>{oS={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec2 v_texcoord_0;
in vec3 v_color;
in vec3 v_normal_inWorld;
in vec3 v_position_inWorld;

uniform int u_envHdriFormat; // initialValue=0
uniform float u_envRotation; // initialValue=0
uniform vec4 u_diffuseColorFactor; // initialValue=(1,1,1,1)
uniform samplerCube u_colorEnvTexture; // initialValue=(0,black)
uniform bool u_makeOutputSrgb; // initialValue=true
uniform bool u_inverseEnvironment; // initialValue=false

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

vec3 linearToSrgb(vec3 linearColor) {
  return pow(linearColor, vec3(1.0/2.2));
}

vec3 srgbToLinear(vec3 srgbColor) {
  return pow(srgbColor, vec3(2.2));
}

void main() {
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  // diffuseColor
  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);
  float alpha = 1.0;
  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);
  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {
    diffuseColor = v_color * diffuseColorFactor.rgb;
    alpha = diffuseColorFactor.a;
  } else if (v_color == diffuseColor) {
    diffuseColor = diffuseColorFactor.rgb;
    alpha = diffuseColorFactor.a;
  } else if (diffuseColorFactor.rgb == diffuseColor) {
    diffuseColor = v_color;
  } else {
    diffuseColor = vec3(1.0, 1.0, 1.0);
  }

  // diffuseColorTexture

  // adapt OpenGL (RenderMan) CubeMap convention
  float envRotation = get_envRotation(materialSID, 0);
  float rot = envRotation;
  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  vec3 envNormal = normalize(rotEnvMatrix * v_position_inWorld);

  if (get_inverseEnvironment(materialSID, 0)) {
    envNormal.x *= -1.0;
  }

  vec4 diffuseTexel = texture(u_colorEnvTexture, envNormal);
  vec3 textureColor;
  int EnvHdriFormat = get_envHdriFormat(materialSID, 0);
  if (EnvHdriFormat == 0) { // LDR_SRGB
    textureColor = srgbToLinear(diffuseTexel.rgb);
  } else if (EnvHdriFormat == 3) { // RGBE
    textureColor = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  } else {
    textureColor = diffuseTexel.rgb;
  }
  diffuseColor *= textureColor;

  rt0 = vec4(diffuseColor, alpha);

float makeOutputSrgb = float(get_makeOutputSrgb(materialSID, 0));
rt0.rgb = mix(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb);


/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var iS,rS=C(()=>{iS={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

// #param enableViewMatrix: bool; // initialValue=true

@vertex
fn main(
#ifdef RN_USE_INSTANCE
  @location(8) instance_ids: vec4<f32>,
#endif


#ifdef RN_USE_POSITION_FLOAT
  @location(0) position: vec3<f32>,
#endif
#ifdef RN_USE_POSITION_INT
  @location(0) position: vec3<i32>,
#endif
#ifdef RN_USE_POSITION_UINT
  @location(0) position: vec3<u32>,
#endif

#ifdef RN_USE_NORMAL
  @location(1) normal: vec3<f32>,
#endif
#ifdef RN_USE_TANGENT
  @location(2) tangent: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_0
  @location(3) texcoord_0: vec2<f32>,
#endif
#ifdef RN_USE_TEXCOORD_1
  @location(4) texcoord_1: vec2<f32>,
#endif

#ifdef RN_USE_COLOR_0_FLOAT
  @location(5) color_0: vec4<f32>,
#endif
#ifdef RN_USE_COLOR_0_INT
  @location(5) color_0: vec4<i32>,
#endif
#ifdef RN_USE_COLOR_0_UINT
  @location(5) color_0: vec4<u32>,
#endif

#ifdef RN_USE_JOINTS_0
  @location(6) joints_0: vec4<u32>,
#endif
#ifdef RN_USE_WEIGHTS_0
  @location(7) weights_0: vec4<f32>,
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
  @location(10) baryCentricCoord: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_2
  @location(11) texcoord_2: vec2<f32>,
#endif
  @builtin(vertex_index) vertexIdx : u32,


) -> VertexOutput {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  var output : VertexOutput;

  let worldMatrix = get_worldMatrix(u32(instance_ids.x));
  let viewMatrix = get_viewMatrix(cameraSID, 0u);
  let projectionMatrix = get_projectionMatrix(cameraSID, 0u);

  if (get_enableViewMatrix(materialSID, 0u)) {
    var rotateMatrix = viewMatrix;
    rotateMatrix[3][0] = 0.0;
    rotateMatrix[3][1] = 0.0;
    rotateMatrix[3][2] = 0.0;
    output.position = projectionMatrix * rotateMatrix * worldMatrix * vec4f(position, 1.0);
  } else {
    output.position = projectionMatrix * worldMatrix * vec4f(position, 1.0);
  }

  let normalMatrix = get_normalMatrix(u32(instance_ids.x));
  output.normal_inWorld = normalMatrix * normal;

#ifdef RN_USE_COLOR_0
  output.color_0 = color_0;
#endif
  output.position_inWorld = (worldMatrix * vec4f(position, 1.0)).xyz;
  output.texcoord_0 = texcoord_0;

  return output;
}
`,shaderStage:"vertex",isFragmentShader:!1}});var sS,aS=C(()=>{sS={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */

// #param envHdriFormat: i32; // initialValue=0
// #param envRotation: f32; // initialValue=0
// #param diffuseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)
@group(1) @binding(0) var colorEnvTexture: texture_cube<f32>; // initialValue=black
@group(2) @binding(0) var colorEnvSampler: sampler;
// #param makeOutputSrgb: bool; // initialValue=1
// #param inverseEnvironment: bool; // initialValue=false

fn linearToSrgb(linearColor: vec3f) -> vec3f {
  return pow(linearColor, vec3f(1.0/2.2));
}

fn srgbToLinear(srgbColor: vec3f) -> vec3f {
  return pow(srgbColor, vec3f(2.2));
}


@fragment
fn main(
  input: VertexOutput,
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  var diffuseColor = vec4<f32>(1, 1, 1, 1);
#ifdef RN_USE_COLOR_0
  diffuseColor = input.color_0;
#endif
  let diffuseColorFactor = get_diffuseColorFactor(materialSID, 0u);
  diffuseColor *= diffuseColorFactor;

  let envRotation: f32 = get_envRotation(materialSID, 0u);
  let rot = envRotation;
  let rotEnvMatrix = mat3x3<f32>(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  var envNormal: vec3f = normalize(rotEnvMatrix * input.position_inWorld);

  if (get_inverseEnvironment(materialSID, 0)) {
    envNormal.x *= -1.0;
  }

  let diffuseTexel = textureSampleLevel(colorEnvTexture, colorEnvSampler, envNormal, 0.0);
  var textureColor: vec3f;
  let EnvHdriFormat: i32 = get_envHdriFormat(materialSID, 0);
  if (EnvHdriFormat == 0) { // LDR_SRGB
    textureColor = srgbToLinear(diffuseTexel.rgb);
  } else if (EnvHdriFormat == 3) { // RGBE
    textureColor = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  } else {
    textureColor = diffuseTexel.rgb;
  }
  diffuseColor *= vec4f(textureColor, 1.0);

  var resultColor = diffuseColor.rgb;
  let resultAlpha = diffuseColor.a;

let makeOutputSrgb = get_makeOutputSrgb(materialSID, 0);
resultColor = select(resultColor.rgb, linearToSrgb(resultColor.rgb), makeOutputSrgb);


  return vec4f(resultColor, resultAlpha);
}
`,shaderStage:"fragment",isFragmentShader:!0}});var cS,lS=C(()=>{cS={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec3 a_position;
out vec2 v_texcoord_0;

/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

void main(){
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif

float x = float((gl_VertexID & 1) << 2);
float y = float((gl_VertexID & 2) << 1);
v_texcoord_0.x = x * 0.5;
v_texcoord_0.y = y * 0.5;
gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);

}
`,shaderStage:"vertex",isFragmentShader:!1}});var uS,fS=C(()=>{uS={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/**
 * This file contains source code provided by NVIDIA Corporation.
 * FXAA antialiasing is developed by NVIDIA.
 * The codes of this file is modified from original code to work on WebGL1.
 * The modification for GLSL 100 is referred from Three.js, https://github.com/mrdoob/three.js/blob/5ba4c25bcb74577e1b1e14906f345135610a94f3/examples/js/shaders/FXAAShader.js
 * The original FXAA code is https://github.com/NVIDIAGameWorks/GraphicsSamples/blob/80e8ba8f5e8935821513207033490735dd3279d8/samples/es3-kepler/FXAA/FXAA3_11.h
 */

//----------------------------------------------------------------------------------
// File:        es3-kepler\\FXAA/FXAA3_11.h
// SDK Version: v3.00
// Email:       gameworks@nvidia.com
// Site:        http://developer.nvidia.com/
//
// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name of NVIDIA CORPORATION nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS 'AS IS' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//----------------------------------------------------------------------------------
/*============================================================================
                    NVIDIA FXAA 3.11 by TIMOTHY LOTTES
============================================================================*/


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec2 v_texcoord_0;

uniform sampler2D u_baseColorTexture; // initialValue=(0,white)

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */



  #define FXAA_PC 1
  #define FXAA_QUALITYPRESET 39
  #define FXAA_GREEN_AS_LUMA 0
  #define FXAA_GLSL_100 1

  /*============================================================================
                                INTEGRATION KNOBS
  ============================================================================*/
  //
  // FXAA_PS3 and FXAA_360 choose the console algorithm (FXAA3 CONSOLE).
  // FXAA_360_OPT is a prototype for the new optimized 360 version.
  //
  // 1 = Use API.
  // 0 = Don't use API.
  //
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_PS3
  #define FXAA_PS3 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_360
  #define FXAA_360 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_360_OPT
  #define FXAA_360_OPT 0
  #endif
  /*==========================================================================*/
  #ifndef FXAA_PC
  //
  // FXAA Quality
  // The high quality PC algorithm.
  //
  #define FXAA_PC 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_PC_CONSOLE
  //
  // The console algorithm for PC is included
  // for developers targeting really low spec machines.
  // Likely better to just run FXAA_PC, and use a really low preset.
  //
  #define FXAA_PC_CONSOLE 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_GLSL_120
  #define FXAA_GLSL_120 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_GLSL_130
  #define FXAA_GLSL_130 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_HLSL_3
  #define FXAA_HLSL_3 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_HLSL_4
  #define FXAA_HLSL_4 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_HLSL_5
  #define FXAA_HLSL_5 0
  #endif
  /*==========================================================================*/
  #ifndef FXAA_GREEN_AS_LUMA
  //
  // For those using non-linear color,
  // and either not able to get luma in alpha, or not wanting to,
  // this enables FXAA to run using green as a proxy for luma.
  // So with this enabled, no need to pack luma in alpha.
  //
  // This will turn off AA on anything which lacks some amount of green.
  // Pure red and blue or combination of only R and B, will get no AA.
  //
  // Might want to lower the settings for both,
  //    fxaaConsoleEdgeThresholdMin
  //    fxaaQualityEdgeThresholdMin
  // In order to insure AA does not get turned off on colors
  // which contain a minor amount of green.
  //
  // 1 = On.
  // 0 = Off.
  //
  #define FXAA_GREEN_AS_LUMA 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_EARLY_EXIT
  //
  // Controls algorithm's early exit path.
  // On PS3 turning this ON adds 2 cycles to the shader.
  // On 360 turning this OFF adds 10ths of a millisecond to the shader.
  // Turning this off on console will result in a more blurry image.
  // So this defaults to on.
  //
  // 1 = On.
  // 0 = Off.
  //
  #define FXAA_EARLY_EXIT 1
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_DISCARD
  //
  // Only valid for PC OpenGL currently.
  // Probably will not work when FXAA_GREEN_AS_LUMA = 1.
  //
  // 1 = Use discard on pixels which don't need AA.
  //     For APIs which enable concurrent TEX+ROP from same surface.
  // 0 = Return unchanged color on pixels which don't need AA.
  //
  #define FXAA_DISCARD 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_FAST_PIXEL_OFFSET
  //
  // Used for GLSL 120 only.
  //
  // 1 = GL API supports fast pixel offsets
  // 0 = do not use fast pixel offsets
  //
  #ifdef GLEXT_gpu_shader4
  #define FXAA_FAST_PIXEL_OFFSET 1
  #endif
  #ifdef GLNV_gpu_shader5
  #define FXAA_FAST_PIXEL_OFFSET 1
  #endif
  #ifdef GLARB_gpu_shader5
  #define FXAA_FAST_PIXEL_OFFSET 1
  #endif
  #ifndef FXAA_FAST_PIXEL_OFFSET
  #define FXAA_FAST_PIXEL_OFFSET 0
  #endif
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_GATHER4_ALPHA
  //
  // 1 = API supports gather4 on alpha channel.
  // 0 = API does not support gather4 on alpha channel.
  //
  #if (FXAA_HLSL_5 == 1)
  #define FXAA_GATHER4_ALPHA 1
  #endif
  #ifdef GLARB_gpu_shader5
  #define FXAA_GATHER4_ALPHA 1
  #endif
  #ifdef GLNV_gpu_shader5
  #define FXAA_GATHER4_ALPHA 1
  #endif
  #ifndef FXAA_GATHER4_ALPHA
  #define FXAA_GATHER4_ALPHA 0
  #endif
  #endif

  /*============================================================================
                        FXAA CONSOLE PS3 - TUNING KNOBS
  ============================================================================*/
  #ifndef FXAA_CONSOLEPS3_EDGE_SHARPNESS
  //
  // Consoles the sharpness of edges on PS3 only.
  // Non-PS3 tuning is done with shader input.
  //
  // Due to the PS3 being ALU bound,
  // there are only two safe values here: 4 and 8.
  // These options use the shaders ability to a free *|/ by 2|4|8.
  //
  // 8.0 is sharper
  // 4.0 is softer
  // 2.0 is really soft (good for vector graphics inputs)
  //
  #if 1
  #define FXAA_CONSOLEPS3_EDGE_SHARPNESS 8.0
  #endif
  #if 0
  #define FXAA_CONSOLEPS3_EDGE_SHARPNESS 4.0
  #endif
  #if 0
  #define FXAA_CONSOLEPS3_EDGE_SHARPNESS 2.0
  #endif
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_CONSOLEPS3_EDGE_THRESHOLD
  //
  // Only effects PS3.
  // Non-PS3 tuning is done with shader input.
  //
  // The minimum amount of local contrast required to apply algorithm.
  // The console setting has a different mapping than the quality setting.
  //
  // This only applies when FXAA_EARLY_EXIT is 1.
  //
  // Due to the PS3 being ALU bound,
  // there are only two safe values here: 0.25 and 0.125.
  // These options use the shaders ability to a free *|/ by 2|4|8.
  //
  // 0.125 leaves less aliasing, but is softer
  // 0.25 leaves more aliasing, and is sharper
  //
  #if 1
  #define FXAA_CONSOLEPS3_EDGE_THRESHOLD 0.125
  #else
  #define FXAA_CONSOLEPS3_EDGE_THRESHOLD 0.25
  #endif
  #endif

  /*============================================================================
                          FXAA QUALITY - TUNING KNOBS
  ------------------------------------------------------------------------------
  NOTE the other tuning knobs are now in the shader function inputs!
  ============================================================================*/
  #ifndef FXAA_QUALITYPRESET
  //
  // Choose the quality preset.
  // This needs to be compiled into the shader as it effects code.
  // Best option to include multiple presets is to
  // in each shader define the preset, then include this file.
  //
  // OPTIONS
  // -----------------------------------------------------------------------
  // 10 to 15 - default medium dither (10=fastest, 15=highest quality)
  // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)
  // 39       - no dither, very expensive
  //
  // NOTES
  // -----------------------------------------------------------------------
  // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)
  // 13 = about same speed as FXAA 3.9 and better than 12
  // 23 = closest to FXAA 3.9 visually and performance wise
  //  _ = the lowest digit is directly related to performance
  // _  = the highest digit is directly related to style
  //
  #define FXAA_QUALITYPRESET 12
  #endif


  /*============================================================================
                             FXAA QUALITY - PRESETS
  ============================================================================*/

  /*============================================================================
                       FXAA QUALITY - MEDIUM DITHER PRESETS
  ============================================================================*/
  #if(FXAA_QUALITYPRESET == 10)
#define FXAA_QUALITYPS 3
#define FXAA_QUALITYP0 1.5
#define FXAA_QUALITYP1 3.0
#define FXAA_QUALITYP2 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 11)
#define FXAA_QUALITYPS 4
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 3.0
#define FXAA_QUALITYP3 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 12)
#define FXAA_QUALITYPS 5
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 4.0
#define FXAA_QUALITYP4 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 13)
#define FXAA_QUALITYPS 6
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 4.0
#define FXAA_QUALITYP5 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 14)
#define FXAA_QUALITYPS 7
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 4.0
#define FXAA_QUALITYP6 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 15)
#define FXAA_QUALITYPS 8
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 2.0
#define FXAA_QUALITYP6 4.0
#define FXAA_QUALITYP7 12.0
#endif

/*============================================================================
                     FXAA QUALITY - LOW DITHER PRESETS
============================================================================*/
#if (FXAA_QUALITYPRESET == 20)
#define FXAA_QUALITYPS 3
#define FXAA_QUALITYP0 1.5
#define FXAA_QUALITYP1 2.0
#define FXAA_QUALITYP2 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 21)
#define FXAA_QUALITYPS 4
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 22)
#define FXAA_QUALITYPS 5
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 23)
#define FXAA_QUALITYPS 6
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 24)
#define FXAA_QUALITYPS 7
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 3.0
#define FXAA_QUALITYP6 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 25)
#define FXAA_QUALITYPS 8
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 2.0
#define FXAA_QUALITYP6 4.0
#define FXAA_QUALITYP7 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 26)
#define FXAA_QUALITYPS 9
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 2.0
#define FXAA_QUALITYP6 2.0
#define FXAA_QUALITYP7 4.0
#define FXAA_QUALITYP8 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 27)
#define FXAA_QUALITYPS 10
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 2.0
#define FXAA_QUALITYP6 2.0
#define FXAA_QUALITYP7 2.0
#define FXAA_QUALITYP8 4.0
#define FXAA_QUALITYP9 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 28)
#define FXAA_QUALITYPS 11
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 2.0
#define FXAA_QUALITYP6 2.0
#define FXAA_QUALITYP7 2.0
#define FXAA_QUALITYP8 2.0
#define FXAA_QUALITYP9 4.0
#define FXAA_QUALITYP10 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 29)
#define FXAA_QUALITYPS 12
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 2.0
#define FXAA_QUALITYP6 2.0
#define FXAA_QUALITYP7 2.0
#define FXAA_QUALITYP8 2.0
#define FXAA_QUALITYP9 2.0
#define FXAA_QUALITYP10 4.0
#define FXAA_QUALITYP11 8.0
#endif

/*============================================================================
                     FXAA QUALITY - EXTREME QUALITY
============================================================================*/
#if (FXAA_QUALITYPRESET == 39)
#define FXAA_QUALITYPS 12
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.0
#define FXAA_QUALITYP2 1.0
#define FXAA_QUALITYP3 1.0
#define FXAA_QUALITYP4 1.0
#define FXAA_QUALITYP5 1.5
#define FXAA_QUALITYP6 2.0
#define FXAA_QUALITYP7 2.0
#define FXAA_QUALITYP8 2.0
#define FXAA_QUALITYP9 2.0
#define FXAA_QUALITYP10 4.0
#define FXAA_QUALITYP11 8.0
#endif



/*============================================================================
                                API PORTING
============================================================================*/
#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)
#define FxaaBool bool
#define FxaaDiscard discard
#define FxaaFloat float
#define FxaaFloat2 vec2
#define FxaaFloat3 vec3
#define FxaaFloat4 vec4
#define FxaaHalf float
#define FxaaHalf2 vec2
#define FxaaHalf3 vec3
#define FxaaHalf4 vec4
#define FxaaInt2 ivec2
#define FxaaSat(x) clamp(x, 0.0, 1.0)
#define FxaaTex sampler2D
#else
#define FxaaBool bool
#define FxaaDiscard clip(-1)
#define FxaaFloat float
#define FxaaFloat2 float2
#define FxaaFloat3 float3
#define FxaaFloat4 float4
#define FxaaHalf half
#define FxaaHalf2 half2
#define FxaaHalf3 half3
#define FxaaHalf4 half4
#define FxaaSat(x) saturate(x)
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_GLSL_100 == 1)
#define FxaaTexTop(t, p) texture(t, p, 0.0)
#define FxaaTexOff(t, p, o, r) texture(t, p + (o * r), 0.0)
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_GLSL_120 == 1)
// Requires,
//  #version 120
// And at least,
//  #extension GLEXT_gpu_shader4 : enable
//  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)
#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)
#if (FXAA_FAST_PIXEL_OFFSET == 1)
#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)
#else
#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)
#endif
#if (FXAA_GATHER4_ALPHA == 1)
// use #extension GLARB_gpu_shader5 : enable
#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
#define FxaaTexGreen4(t, p) textureGather(t, p, 1)
#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
#endif
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_GLSL_130 == 1)
// Requires "#version 130" or better
#define FxaaTexTop(t, p) textureLod(t, p, 0.0)
#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)
#if (FXAA_GATHER4_ALPHA == 1)
// use #extension GLARB_gpu_shader5 : enable
#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
#define FxaaTexGreen4(t, p) textureGather(t, p, 1)
#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
#endif
#endif


/*============================================================================
                   GREEN AS LUMA OPTION SUPPORT FUNCTION
============================================================================*/
#if (FXAA_GREEN_AS_LUMA == 0)
  FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return dot(rgba.rgb, vec3(0.298912, 0.586611, 0.114478)); }
  // FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }
#else
  FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }
#endif









/*============================================================================
                             FXAA3 QUALITY - PC
============================================================================*/
#if (FXAA_PC == 1)
  /*--------------------------------------------------------------------------*/
  FxaaFloat4 FxaaPixelShader(
    //
    // Use noperspective interpolation here (turn off perspective interpolation).
    // {xy} = center of pixel
    FxaaFloat2 pos,
    //
    // Used only for FXAA Console, and not used on the 360 version.
    // Use noperspective interpolation here (turn off perspective interpolation).
    // {xy} = upper left of pixel
    // {zw} = lower right of pixel
    FxaaFloat4 fxaaConsolePosPos,
    //
    // Input color texture.
    // {rgb_} = color in linear or perceptual color space
    // if (FXAA_GREEN_AS_LUMA == 0)
    //     {_a} = luma in perceptual color space (not linear)
    FxaaTex tex,
    //
    // Only used on the optimized 360 version of FXAA Console.
    // For everything but 360, just use the same input here as for "tex".
    // For 360, same texture, just alias with a 2nd sampler.
    // This sampler needs to have an exponent bias of -1.
    FxaaTex fxaaConsole360TexExpBiasNegOne,
    //
    // Only used on the optimized 360 version of FXAA Console.
    // For everything but 360, just use the same input here as for "tex".
    // For 360, same texture, just alias with a 3nd sampler.
    // This sampler needs to have an exponent bias of -2.
    FxaaTex fxaaConsole360TexExpBiasNegTwo,
    //
    // Only used on FXAA Quality.
    // This must be from a constant/uniform.
    // {x_} = 1.0/screenWidthInPixels
    // {_y} = 1.0/screenHeightInPixels
    FxaaFloat2 fxaaQualityRcpFrame,
    //
    // Only used on FXAA Console.
    // This must be from a constant/uniform.
    // This effects sub-pixel AA quality and inversely sharpness.
    //   Where N ranges between,
    //     N = 0.50 (default)
    //     N = 0.33 (sharper)
    // {x_} = -N/screenWidthInPixels
    // {_y} = -N/screenHeightInPixels
    // {z_} =  N/screenWidthInPixels
    // {_w} =  N/screenHeightInPixels
    FxaaFloat4 fxaaConsoleRcpFrameOpt,
    //
    // Only used on FXAA Console.
    // Not used on 360, but used on PS3 and PC.
    // This must be from a constant/uniform.
    // {x_} = -2.0/screenWidthInPixels
    // {_y} = -2.0/screenHeightInPixels
    // {z_} =  2.0/screenWidthInPixels
    // {_w} =  2.0/screenHeightInPixels
    FxaaFloat4 fxaaConsoleRcpFrameOpt2,
    //
    // Only used on FXAA Console.
    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.
    // This must be from a constant/uniform.
    // {x_} =  8.0/screenWidthInPixels
    // {_y} =  8.0/screenHeightInPixels
    // {z_} = -4.0/screenWidthInPixels
    // {_w} = -4.0/screenHeightInPixels
    FxaaFloat4 fxaaConsole360RcpFrameOpt2,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITYSUBPIX define.
    // It is here now to allow easier tuning.
    // Choose the amount of sub-pixel aliasing removal.
    // This can effect sharpness.
    //   1.00 - upper limit (softer)
    //   0.75 - default amount of filtering
    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)
    //   0.25 - almost off
    //   0.00 - completely off
    FxaaFloat fxaaQualitySubpix,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITYEDGE_THRESHOLD define.
    // It is here now to allow easier tuning.
    // The minimum amount of local contrast required to apply algorithm.
    //   0.333 - too little (faster)
    //   0.250 - low quality
    //   0.166 - default
    //   0.125 - high quality
    //   0.063 - overkill (slower)
    FxaaFloat fxaaQualityEdgeThreshold,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITYEDGE_THRESHOLD_MIN define.
    // It is here now to allow easier tuning.
    // Trims the algorithm from processing darks.
    //   0.0833 - upper limit (default, the start of visible unfiltered edges)
    //   0.0625 - high quality (faster)
    //   0.0312 - visible limit (slower)
    // Special notes when using FXAA_GREEN_AS_LUMA,
    //   Likely want to set this to zero.
    //   As colors that are mostly not-green
    //   will appear very dark in the green channel!
    //   Tune by looking at mostly non-green content,
    //   then start at zero and increase until aliasing is a problem.
    FxaaFloat fxaaQualityEdgeThresholdMin,
    //
    // Only used on FXAA Console.
    // This used to be the FXAA_CONSOLEEDGE_SHARPNESS define.
    // It is here now to allow easier tuning.
    // This does not effect PS3, as this needs to be compiled in.
    //   Use FXAA_CONSOLEPS3_EDGE_SHARPNESS for PS3.
    //   Due to the PS3 being ALU bound,
    //   there are only three safe values here: 2 and 4 and 8.
    //   These options use the shaders ability to a free *|/ by 2|4|8.
    // For all other platforms can be a non-power of two.
    //   8.0 is sharper (default!!!)
    //   4.0 is softer
    //   2.0 is really soft (good only for vector graphics inputs)
    FxaaFloat fxaaConsoleEdgeSharpness,
    //
    // Only used on FXAA Console.
    // This used to be the FXAA_CONSOLEEDGE_THRESHOLD define.
    // It is here now to allow easier tuning.
    // This does not effect PS3, as this needs to be compiled in.
    //   Use FXAA_CONSOLEPS3_EDGE_THRESHOLD for PS3.
    //   Due to the PS3 being ALU bound,
    //   there are only two safe values here: 1/4 and 1/8.
    //   These options use the shaders ability to a free *|/ by 2|4|8.
    // The console setting has a different mapping than the quality setting.
    // Other platforms can use other values.
    //   0.125 leaves less aliasing, but is softer (default!!!)
    //   0.25 leaves more aliasing, and is sharper
    FxaaFloat fxaaConsoleEdgeThreshold,
    //
    // Only used on FXAA Console.
    // This used to be the FXAA_CONSOLEEDGE_THRESHOLD_MIN define.
    // It is here now to allow easier tuning.
    // Trims the algorithm from processing darks.
    // The console setting has a different mapping than the quality setting.
    // This only applies when FXAA_EARLY_EXIT is 1.
    // This does not apply to PS3,
    // PS3 was simplified to avoid more shader instructions.
    //   0.06 - faster but more aliasing in darks
    //   0.05 - default
    //   0.04 - slower and less aliasing in darks
    // Special notes when using FXAA_GREEN_AS_LUMA,
    //   Likely want to set this to zero.
    //   As colors that are mostly not-green
    //   will appear very dark in the green channel!
    //   Tune by looking at mostly non-green content,
    //   then start at zero and increase until aliasing is a problem.
    FxaaFloat fxaaConsoleEdgeThresholdMin,
    //
    // Extra constants for 360 FXAA Console only.
    // Use zeros or anything else for other platforms.
    // These must be in physical constant registers and NOT immedates.
    // Immedates will result in compiler un-optimizing.
    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)
    FxaaFloat4 fxaaConsole360ConstDir
  ) {
  /*--------------------------------------------------------------------------*/
  FxaaFloat2 posM;
  posM.x = pos.x;
  posM.y = pos.y;
  #if (FXAA_GATHER4_ALPHA == 1)
  #if (FXAA_DISCARD == 0)
    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
  #if (FXAA_GREEN_AS_LUMA == 0)
  #define lumaM rgbyM.w
  #else
  #define lumaM rgbyM.y
  #endif
  #endif
  #if (FXAA_GREEN_AS_LUMA == 0)
    FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);
  FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));
  #else
  FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);
  FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));
  #endif
  #if (FXAA_DISCARD == 1)
  #define lumaM luma4A.w
  #endif
  #define lumaE luma4A.z
  #define lumaS luma4A.x
  #define lumaSE luma4A.y
  #define lumaNW luma4B.w
  #define lumaN luma4B.z
  #define lumaW luma4B.x
  #else
  FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
  #if (FXAA_GREEN_AS_LUMA == 0)
  #define lumaM rgbyM.w
  #else
  #define lumaM rgbyM.y
  #endif
  #if (FXAA_GLSL_100 == 1)
    FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0, 1.0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 0.0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0, -1.0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));
  #else
  FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, 1), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, -1), fxaaQualityRcpFrame.xy));
  #endif
  #endif
  /*--------------------------------------------------------------------------*/
  FxaaFloat maxSM = max(lumaS, lumaM);
  FxaaFloat minSM = min(lumaS, lumaM);
  FxaaFloat maxESM = max(lumaE, maxSM);
  FxaaFloat minESM = min(lumaE, minSM);
  FxaaFloat maxWN = max(lumaN, lumaW);
  FxaaFloat minWN = min(lumaN, lumaW);
  FxaaFloat rangeMax = max(maxWN, maxESM);
  FxaaFloat rangeMin = min(minWN, minESM);
  FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
  FxaaFloat range = rangeMax - rangeMin;
  FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
  FxaaBool earlyExit = range < rangeMaxClamped;
  /*--------------------------------------------------------------------------*/
  if (earlyExit)
  #if (FXAA_DISCARD == 1)
    FxaaDiscard;
  #else
  return rgbyM;
  #endif
  /*--------------------------------------------------------------------------*/
  #if (FXAA_GATHER4_ALPHA == 0)
  #if (FXAA_GLSL_100 == 1)
    FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, -1.0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 1.0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, -1.0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));
  #else
  FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, -1), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 1), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
  #endif
  #else
  FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
  #endif
  /*--------------------------------------------------------------------------*/
  FxaaFloat lumaNS = lumaN + lumaS;
  FxaaFloat lumaWE = lumaW + lumaE;
  FxaaFloat subpixRcpRange = 1.0 / range;
  FxaaFloat subpixNSWE = lumaNS + lumaWE;
  FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;
  FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;
  /*--------------------------------------------------------------------------*/
  FxaaFloat lumaNESE = lumaNE + lumaSE;
  FxaaFloat lumaNWNE = lumaNW + lumaNE;
  FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
  FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
  /*--------------------------------------------------------------------------*/
  FxaaFloat lumaNWSW = lumaNW + lumaSW;
  FxaaFloat lumaSWSE = lumaSW + lumaSE;
  FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
  FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
  FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
  FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
  FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;
  FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;
  /*--------------------------------------------------------------------------*/
  FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;
  FxaaFloat lengthSign = fxaaQualityRcpFrame.x;
  FxaaBool horzSpan = edgeHorz >= edgeVert;
  FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
  /*--------------------------------------------------------------------------*/
  if (!horzSpan) lumaN = lumaW;
  if (!horzSpan) lumaS = lumaE;
  if (horzSpan) lengthSign = fxaaQualityRcpFrame.y;
  FxaaFloat subpixB = (subpixA * (1.0 / 12.0)) - lumaM;
  /*--------------------------------------------------------------------------*/
  FxaaFloat gradientN = lumaN - lumaM;
  FxaaFloat gradientS = lumaS - lumaM;
  FxaaFloat lumaNN = lumaN + lumaM;
  FxaaFloat lumaSS = lumaS + lumaM;
  FxaaBool pairN = abs(gradientN) >= abs(gradientS);
  FxaaFloat gradient = max(abs(gradientN), abs(gradientS));
  if (pairN) lengthSign = -lengthSign;
  FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
  /*--------------------------------------------------------------------------*/
  FxaaFloat2 posB;
  posB.x = posM.x;
  posB.y = posM.y;
  FxaaFloat2 offNP;
  offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
  offNP.y = (horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
  if (!horzSpan) posB.x += lengthSign * 0.5;
  if (horzSpan) posB.y += lengthSign * 0.5;
  /*--------------------------------------------------------------------------*/
  FxaaFloat2 posN;
  posN.x = posB.x - offNP.x * FXAA_QUALITYP0;
  posN.y = posB.y - offNP.y * FXAA_QUALITYP0;
  FxaaFloat2 posP;
  posP.x = posB.x + offNP.x * FXAA_QUALITYP0;
  posP.y = posB.y + offNP.y * FXAA_QUALITYP0;
  FxaaFloat subpixD = ((-2.0) * subpixC) + 3.0;
  FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));
  FxaaFloat subpixE = subpixC * subpixC;
  FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));
  /*--------------------------------------------------------------------------*/
  if (!pairN) lumaNN = lumaSS;
  FxaaFloat gradientScaled = gradient * 1.0 / 4.0;
  FxaaFloat lumaMM = lumaM - lumaNN * 0.5;
  FxaaFloat subpixF = subpixD * subpixE;
  FxaaBool lumaMLTZero = lumaMM < 0.0;
  /*--------------------------------------------------------------------------*/
  lumaEndN -= lumaNN * 0.5;
  lumaEndP -= lumaNN * 0.5;
  FxaaBool doneN = abs(lumaEndN) >= gradientScaled;
  FxaaBool doneP = abs(lumaEndP) >= gradientScaled;
  if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP1;
  if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP1;
  FxaaBool doneNP = (!doneN) || (!doneP);
  if (!doneP) posP.x += offNP.x * FXAA_QUALITYP1;
  if (!doneP) posP.y += offNP.y * FXAA_QUALITYP1;
  /*--------------------------------------------------------------------------*/
  if (doneNP) {
    if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
    if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
    if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
    if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
    doneN = abs(lumaEndN) >= gradientScaled;
    doneP = abs(lumaEndP) >= gradientScaled;
    if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP2;
    if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP2;
    doneNP = (!doneN) || (!doneP);
    if (!doneP) posP.x += offNP.x * FXAA_QUALITYP2;
    if (!doneP) posP.y += offNP.y * FXAA_QUALITYP2;
    /*--------------------------------------------------------------------------*/
    #if (FXAA_QUALITYPS > 3)
      if (doneNP) {
        if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
        if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
        if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
        if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
        doneN = abs(lumaEndN) >= gradientScaled;
        doneP = abs(lumaEndP) >= gradientScaled;
        if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP3;
        if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP3;
        doneNP = (!doneN) || (!doneP);
        if (!doneP) posP.x += offNP.x * FXAA_QUALITYP3;
        if (!doneP) posP.y += offNP.y * FXAA_QUALITYP3;
        /*--------------------------------------------------------------------------*/
        #if (FXAA_QUALITYPS > 4)
          if (doneNP) {
            if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
            if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
            if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
            if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
            doneN = abs(lumaEndN) >= gradientScaled;
            doneP = abs(lumaEndP) >= gradientScaled;
            if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP4;
            if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP4;
            doneNP = (!doneN) || (!doneP);
            if (!doneP) posP.x += offNP.x * FXAA_QUALITYP4;
            if (!doneP) posP.y += offNP.y * FXAA_QUALITYP4;
            /*--------------------------------------------------------------------------*/
            #if (FXAA_QUALITYPS > 5)
              if (doneNP) {
                if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                doneN = abs(lumaEndN) >= gradientScaled;
                doneP = abs(lumaEndP) >= gradientScaled;
                if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP5;
                if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP5;
                doneNP = (!doneN) || (!doneP);
                if (!doneP) posP.x += offNP.x * FXAA_QUALITYP5;
                if (!doneP) posP.y += offNP.y * FXAA_QUALITYP5;
                /*--------------------------------------------------------------------------*/
                #if (FXAA_QUALITYPS > 6)
                  if (doneNP) {
                    if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                    if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                    if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                    if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                    doneN = abs(lumaEndN) >= gradientScaled;
                    doneP = abs(lumaEndP) >= gradientScaled;
                    if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP6;
                    if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP6;
                    doneNP = (!doneN) || (!doneP);
                    if (!doneP) posP.x += offNP.x * FXAA_QUALITYP6;
                    if (!doneP) posP.y += offNP.y * FXAA_QUALITYP6;
                    /*--------------------------------------------------------------------------*/
                    #if (FXAA_QUALITYPS > 7)
                      if (doneNP) {
                        if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                        if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                        if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                        if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                        doneN = abs(lumaEndN) >= gradientScaled;
                        doneP = abs(lumaEndP) >= gradientScaled;
                        if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP7;
                        if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP7;
                        doneNP = (!doneN) || (!doneP);
                        if (!doneP) posP.x += offNP.x * FXAA_QUALITYP7;
                        if (!doneP) posP.y += offNP.y * FXAA_QUALITYP7;
                        /*--------------------------------------------------------------------------*/
                        #if (FXAA_QUALITYPS > 8)
                          if (doneNP) {
                            if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                            if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                            if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                            if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                            doneN = abs(lumaEndN) >= gradientScaled;
                            doneP = abs(lumaEndP) >= gradientScaled;
                            if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP8;
                            if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP8;
                            doneNP = (!doneN) || (!doneP);
                            if (!doneP) posP.x += offNP.x * FXAA_QUALITYP8;
                            if (!doneP) posP.y += offNP.y * FXAA_QUALITYP8;
                            /*--------------------------------------------------------------------------*/
                            #if (FXAA_QUALITYPS > 9)
                              if (doneNP) {
                                if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                doneN = abs(lumaEndN) >= gradientScaled;
                                doneP = abs(lumaEndP) >= gradientScaled;
                                if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP9;
                                if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP9;
                                doneNP = (!doneN) || (!doneP);
                                if (!doneP) posP.x += offNP.x * FXAA_QUALITYP9;
                                if (!doneP) posP.y += offNP.y * FXAA_QUALITYP9;
                                /*--------------------------------------------------------------------------*/
                                #if (FXAA_QUALITYPS > 10)
                                  if (doneNP) {
                                    if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                    if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                    if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                    if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                    doneN = abs(lumaEndN) >= gradientScaled;
                                    doneP = abs(lumaEndP) >= gradientScaled;
                                    if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP10;
                                    if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP10;
                                    doneNP = (!doneN) || (!doneP);
                                    if (!doneP) posP.x += offNP.x * FXAA_QUALITYP10;
                                    if (!doneP) posP.y += offNP.y * FXAA_QUALITYP10;
                                    /*--------------------------------------------------------------------------*/
                                    #if (FXAA_QUALITYPS > 11)
                                      if (doneNP) {
                                        if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                        if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                        if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                        if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                        doneN = abs(lumaEndN) >= gradientScaled;
                                        doneP = abs(lumaEndP) >= gradientScaled;
                                        if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP11;
                                        if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP11;
                                        doneNP = (!doneN) || (!doneP);
                                        if (!doneP) posP.x += offNP.x * FXAA_QUALITYP11;
                                        if (!doneP) posP.y += offNP.y * FXAA_QUALITYP11;
                                        /*--------------------------------------------------------------------------*/
                                        #if (FXAA_QUALITYPS > 12)
                                          if (doneNP) {
                                            if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                            if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                            if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                            if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                            doneN = abs(lumaEndN) >= gradientScaled;
                                            doneP = abs(lumaEndP) >= gradientScaled;
                                            if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP12;
                                            if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP12;
                                            doneNP = (!doneN) || (!doneP);
                                            if (!doneP) posP.x += offNP.x * FXAA_QUALITYP12;
                                            if (!doneP) posP.y += offNP.y * FXAA_QUALITYP12;
                                            /*--------------------------------------------------------------------------*/
                                          }
                                        #endif
                                        /*--------------------------------------------------------------------------*/
                                      }
                                    #endif
                                    /*--------------------------------------------------------------------------*/
                                  }
                                #endif
                                /*--------------------------------------------------------------------------*/
                              }
                            #endif
                            /*--------------------------------------------------------------------------*/
                          }
                        #endif
                        /*--------------------------------------------------------------------------*/
                      }
                    #endif
                    /*--------------------------------------------------------------------------*/
                  }
                #endif
                /*--------------------------------------------------------------------------*/
              }
            #endif
            /*--------------------------------------------------------------------------*/
          }
        #endif
        /*--------------------------------------------------------------------------*/
      }
    #endif
    /*--------------------------------------------------------------------------*/
  }
  /*--------------------------------------------------------------------------*/
  FxaaFloat dstN = posM.x - posN.x;
  FxaaFloat dstP = posP.x - posM.x;
  if (!horzSpan) dstN = posM.y - posN.y;
  if (!horzSpan) dstP = posP.y - posM.y;
  /*--------------------------------------------------------------------------*/
  FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
  FxaaFloat spanLength = (dstP + dstN);
  FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
  FxaaFloat spanLengthRcp = 1.0 / spanLength;
  /*--------------------------------------------------------------------------*/
  FxaaBool directionN = dstN < dstP;
  FxaaFloat dst = min(dstN, dstP);
  FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;
  FxaaFloat subpixG = subpixF * subpixF;
  FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
  FxaaFloat subpixH = subpixG * fxaaQualitySubpix;
  /*--------------------------------------------------------------------------*/
  FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
  FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
  if (!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
  if (horzSpan) posM.y += pixelOffsetSubpix * lengthSign;
  #if (FXAA_DISCARD == 1)
    return FxaaTexTop(tex, posM);
  #else
  return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);
  #endif
}
/*==========================================================================*/
#endif


void main(){
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  vec2 screenInfo = vec2(textureSize(u_baseColorTexture, 0));
  rt0 = FxaaPixelShader(
      v_texcoord_0,
      vec4(0.0),
      u_baseColorTexture,
      u_baseColorTexture,
      u_baseColorTexture,
      1.0 / screenInfo,
      vec4(0.0),
      vec4(0.0),
      vec4(0.0),
      0.75,
      0.166,
      0.0833,
      0.0,
      0.0,
      0.0,
      vec4(0.0)
  );
  rt0.a = 1.0;

/* shaderity: @{renderTargetEnd} */


}
`,shaderStage:"fragment",isFragmentShader:!0}});var _S,mS=C(()=>{_S={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec3 a_position;
out vec2 v_texcoord_0;

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

void main()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif

float x = float((gl_VertexID & 1) << 2);
float y = float((gl_VertexID & 2) << 1);
v_texcoord_0.x = x * 0.5;
v_texcoord_0.y = y * 0.5;
gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);


}
`,shaderStage:"vertex",isFragmentShader:!1}});var hS,dS=C(()=>{hS={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec2 v_texcoord_0;

uniform sampler2D u_baseColorTexture; // initialValue=(0,white)
uniform bool u_enableLinearToSrgb; // initialValue=true

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

vec3 linearToSrgb(vec3 linearColor) {
  return pow(linearColor, vec3(1.0/2.2));
}

vec3 srgbToLinear(vec3 srgbColor) {
  return pow(srgbColor, vec3(2.2));
}


void main ()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


vec4 baseColor = texture(u_baseColorTexture, v_texcoord_0);

if (get_enableLinearToSrgb(materialSID, 0)) {
  baseColor.rgb = linearToSrgb(baseColor.rgb);
}

rt0 = baseColor;

/* shaderity: @{renderTargetEnd} */


}
`,shaderStage:"fragment",isFragmentShader:!0}});var xS,pS=C(()=>{xS={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

@vertex
fn main(
  @builtin(vertex_index) vertexIdx : u32,
) -> VertexOutput {
  var output : VertexOutput;
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


let x = f32((vertexIdx & 1u) << 2u);
let y = f32((vertexIdx & 2u) << 1u);
output.texcoord_0.x = x * 0.5;
output.texcoord_0.y = y * 0.5;
output.texcoord_0.y = 1.0 - output.texcoord_0.y;
output.position = vec4f(x - 1.0, y - 1.0, 0, 1);


  return output;

}
`,shaderStage:"vertex",isFragmentShader:!1}});var gS,vS=C(()=>{gS={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */

@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(0) var baseColorSampler: sampler;

// #param enableLinearToSrgb: bool; // initialValue=true

fn linearToSrgb(linearColor: vec3f) -> vec3f {
  return pow(linearColor, vec3f(1.0/2.2));
}

fn srgbToLinear(srgbColor: vec3f) -> vec3f {
  return pow(srgbColor, vec3f(2.2));
}


@fragment
fn main (
  input: VertexOutput,
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  var baseColor = textureSampleLevel(baseColorTexture, baseColorSampler, input.texcoord_0, 0.0);

  if (get_enableLinearToSrgb(materialSID, 0)) {
    baseColor = vec4f(linearToSrgb(baseColor.rgb), baseColor.a);
  }

  return baseColor;

}
`,shaderStage:"fragment",isFragmentShader:!0}});var bS,yS=C(()=>{bS={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec3 a_position;
out vec2 v_texcoord_0;

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

void main()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif

float x = float((gl_VertexID & 1) << 2);
float y = float((gl_VertexID & 2) << 1);
v_texcoord_0.x = x * 0.5;
v_texcoord_0.y = y * 0.5;
gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);


}
`,shaderStage:"vertex",isFragmentShader:!1}});var IS,AS=C(()=>{IS={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec2 v_texcoord_0;

uniform sampler2D u_baseColorTexture; // initialValue=(0,white)
uniform bool u_enableLinearToSrgb; // initialValue=true

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

vec3 linearToSrgb(vec3 linearColor) {
  return pow(linearColor, vec3(1.0/2.2));
}

vec3 srgbToLinear(vec3 srgbColor) {
  return pow(srgbColor, vec3(2.2));
}


#ifdef RN_USE_KHRONOS_PBR_NEUTRAL
// Input color is non-negative and resides in the Linear Rec. 709 color space.
// Output color is also Linear Rec. 709, but in the [0, 1] range.
// See: https://github.com/KhronosGroup/ToneMapping/tree/main/PBR_Neutral
vec3 PBRNeutralToneMapping( vec3 color ) {
  const float startCompression = 0.8 - 0.04;
  const float desaturation = 0.15;

  float x = min(color.r, min(color.g, color.b));
  float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
  color -= offset;

  float peak = max(color.r, max(color.g, color.b));
  if (peak < startCompression) return color;

  const float d = 1. - startCompression;
  float newPeak = 1. - d * d / (peak + d - startCompression);
  color *= newPeak / peak;

  float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
  return mix(color, newPeak * vec3(1, 1, 1), g);
}
#endif

#ifdef RN_USE_REINHARD
vec3 ReinhardToneMapping( vec3 color ) {
  return color / (vec3(1.0) + color);
}
#endif

#ifdef RN_USE_ACES_NARKOWICZ
// ACES tone map (faster approximation)
// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
vec3 ACES_Narkowicz_ToneMapping(vec3 color)
{
    const float A = 2.51;
    const float B = 0.03;
    const float C = 2.43;
    const float D = 0.59;
    const float E = 0.14;
    return clamp((color * (A * color + B)) / (color * (C * color + D) + E), 0.0, 1.0);
}
#endif

#if defined(RN_USE_ACES_HILL) || defined(RN_USE_ACES_HILL_EXPOSURE_BOOST)
// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
const mat3 ACESInputMat = mat3
(
  0.59719, 0.07600, 0.02840,
  0.35458, 0.90834, 0.13383,
  0.04823, 0.01566, 0.83777
);

// ODT_SAT => XYZ => D60_2_D65 => sRGB
const mat3 ACESOutputMat = mat3
(
  1.60475, -0.10208, -0.00327,
  -0.53108,  1.10813, -0.07276,
  -0.07367, -0.00605,  1.07602
);

vec3 RRTAndODTFit(vec3 v)
{
  vec3 a = v * (v + 0.0245786f) - 0.000090537f;
  vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;
  return a / b;
}

vec3 ACES_Hill_ToneMapping(vec3 color)
{
  color = ACESInputMat * color;

  // Apply RRT and ODT
  color = RRTAndODTFit(color);

  color = ACESOutputMat * color;

  // Clamp to [0, 1]
  color = clamp(color, 0.0, 1.0);

  return color;
}
#endif

#ifdef RN_USE_GT_TONEMAP
float W_f(float x, float e0, float e1) {
  if (x <= e0)
    return 0.;
  if (x >= e1)
    return 1.;
  float a = (x - e0) / (e1 - e0);
  return a * a * (3. - 2. * a);
}
float H_f(float x, float e0, float e1) {
  if (x <= e0)
    return 0.;
  if (x >= e1)
    return 1.;
  return (x - e0) / (e1 - e0);
}

const float e = 2.71828;

float GT_ToneMaping(float x) {
  float P = 1.; // peak luminance
  float a = 1.; // contrast parameter
  float m = 0.22; // beginning of the linear part
  float l = 0.4; // length of the linear part
  float c = 1.33; // parameter of black color
  float b = 0.; // parameter of black color
  float l0 = (P - m) * l / a;
  float T_x = m * pow(x / m, c) + b;
  float L_x = m + a * (x - m);
  float S0 = m + l0;
  float S1 = m + a * l0;
  float C2 = a * P / (P - S1);
  float S_x = P - (P - S1) * pow(e, -(C2 * (x - S0) / P));
  float w0_x = 1. - W_f(x, 0., m);
  float w2_x = H_f(x, m + l0, m + l0);
  float w1_x = 1. - w0_x - w2_x;
  float f_x = T_x * w0_x + L_x * w1_x + S_x * w2_x;
  return f_x;
}
#endif

void main ()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


vec4 baseColor = texture(u_baseColorTexture, v_texcoord_0);

// Apply Tone Mapping
#ifdef RN_USE_KHRONOS_PBR_NEUTRAL
baseColor.rgb = PBRNeutralToneMapping(baseColor.rgb);
#endif

#ifdef RN_USE_REINHARD
baseColor.rgb = ReinhardToneMapping(baseColor.rgb);
#endif

#ifdef RN_USE_ACES_NARKOWICZ
baseColor.rgb = ACES_Narkowicz_ToneMapping(baseColor.rgb);
#endif

#ifdef RN_USE_ACES_HILL
baseColor.rgb = ACES_Hill_ToneMapping(baseColor.rgb);
#endif

#ifdef RN_USE_ACES_HILL_EXPOSURE_BOOST
baseColor.rgb /= 0.6;
baseColor.rgb = ACES_Hill_ToneMapping(baseColor.rgb);
#endif

#ifdef RN_USE_GT_TONEMAP
baseColor.r = GT_ToneMaping(baseColor.r);
baseColor.g = GT_ToneMaping(baseColor.g);
baseColor.b = GT_ToneMaping(baseColor.b);
#endif


// Convert linear color to sRGB color space.
if (get_enableLinearToSrgb(materialSID, 0)) {
  baseColor.rgb = linearToSrgb(baseColor.rgb);
}

rt0 = baseColor;

/* shaderity: @{renderTargetEnd} */


}
`,shaderStage:"fragment",isFragmentShader:!0}});var TS,SS=C(()=>{TS={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

@vertex
fn main(
  @builtin(vertex_index) vertexIdx : u32,
) -> VertexOutput {
  var output : VertexOutput;
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


let x = f32((vertexIdx & 1u) << 2u);
let y = f32((vertexIdx & 2u) << 1u);
output.texcoord_0.x = x * 0.5;
output.texcoord_0.y = y * 0.5;
output.texcoord_0.y = 1.0 - output.texcoord_0.y;
output.position = vec4f(x - 1.0, y - 1.0, 0, 1);


  return output;

}
`,shaderStage:"vertex",isFragmentShader:!1}});var CS,ES=C(()=>{CS={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */

@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(0) var baseColorSampler: sampler;

// #param enableLinearToSrgb: bool; // initialValue=true

fn linearToSrgb(linearColor: vec3f) -> vec3f {
  return pow(linearColor, vec3f(1.0/2.2));
}

fn srgbToLinear(srgbColor: vec3f) -> vec3f {
  return pow(srgbColor, vec3f(2.2));
}


#ifdef RN_USE_KHRONOS_PBR_NEUTRAL
// Input color is non-negative and resides in the Linear Rec. 709 color space.
// Output color is also Linear Rec. 709, but in the [0, 1] range.
// See: https://github.com/KhronosGroup/ToneMapping/tree/main/PBR_Neutral
fn PBRNeutralToneMapping( inColor: vec3f ) -> vec3f {
  let startCompression = 0.8 - 0.04;
  let desaturation = 0.15;

  let x = min(inColor.r, min(inColor.g, inColor.b));
  let offset = select(0.04, x - 6.25 * x * x, x < 0.08);
  var color = inColor - offset;

  let peak = max(color.r, max(color.g, color.b));
  if (peak < startCompression) {
    return color;
  }

  let d = 1.0 - startCompression;
  let newPeak = 1.0 - d * d / (peak + d - startCompression);
  color *= newPeak / peak;

  let g = 1.0 - 1.0 / (desaturation * (peak - newPeak) + 1.0);
  return mix(color, newPeak * vec3f(1.0, 1.0, 1.0), g);
}
#endif

#ifdef RN_USE_REINHARD
fn ReinhardToneMapping(color: vec3<f32> ) -> vec3<f32> {
  return color / (vec3<f32>(1.0) + color);
}
#endif

#ifdef RN_USE_ACES_NARKOWICZ
// ACES tone map (faster approximation)
// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
fn ACES_Narkowicz_ToneMapping(color: vec3<f32>) -> vec3<f32>
{
    const A = 2.51;
    const B = 0.03;
    const C = 2.43;
    const D = 0.59;
    const E = 0.14;
    return clamp((color * (A * color + B)) / (color * (C * color + D) + E), vec3<f32>(0.0), vec3<f32>(1.0));
}
#endif

// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
const ACESInputMat = mat3x3<f32>
(
  0.59719, 0.07600, 0.02840,
  0.35458, 0.90834, 0.13383,
  0.04823, 0.01566, 0.83777
);

// ODT_SAT => XYZ => D60_2_D65 => sRGB
const ACESOutputMat = mat3x3<f32>
(
  1.60475, -0.10208, -0.00327,
  -0.53108,  1.10813, -0.07276,
  -0.07367, -0.00605,  1.07602
);

fn RRTAndODTFit(v: vec3<f32>) -> vec3<f32>
{
  let a = v * (v + 0.0245786f) - 0.000090537f;
  let b = v * (0.983729f * v + 0.4329510f) + 0.238081f;
  return a / b;
}

fn ACES_Hill_ToneMapping(inColor: vec3<f32>) -> vec3<f32>
{
  var color = ACESInputMat * inColor;

  // Apply RRT and ODT
  color = RRTAndODTFit(color);

  color = ACESOutputMat * color;

  // Clamp to [0, 1]
  color = saturateVec3f(color);

  return color;
}

#ifdef RN_USE_GT_TONEMAP
  fn W_f(x: f32, e0: f32, e1: f32) -> f32 {
    if (x <= e0) { return 0.; }
    if (x >= e1) { return 1.; }
    let a = (x - e0) / (e1 - e0);
    return a * a * (3. - 2. * a);
  }
  fn H_f(x: f32, e0: f32, e1: f32) -> f32 {
    if (x <= e0) { return 0.; }
    if (x >= e1) { return 1.; }
    return (x - e0) / (e1 - e0);
  }

  const e = 2.71828;

  fn GT_ToneMaping(x: f32) -> f32 {
    let P = 1.; // peak luminance
    let a = 1.; // contrast parameter
    let m = 0.22; // beginning of the linear part
    let l = 0.4; // length of the linear part
    let c = 1.33; // parameter of black color
    let b = 0.; // parameter of black color
    let l0 = (P - m) * l / a;
    let T_x = m * pow(x / m, c) + b;
    let L_x = m + a * (x - m);
    let S0 = m + l0;
    let S1 = m + a * l0;
    let C2 = a * P / (P - S1);
    let S_x = P - (P - S1) * pow(e, -(C2 * (x - S0) / P));
    let w0_x = 1. - W_f(x, 0., m);
    let w2_x = H_f(x, m + l0, m + l0);
    let w1_x = 1. - w0_x - w2_x;
    let f_x = T_x * w0_x + L_x * w1_x + S_x * w2_x;
    return f_x;
  }
#endif

@fragment
fn main (
  input: VertexOutput,
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  var baseColor = textureSample(baseColorTexture, baseColorSampler, input.texcoord_0);

#ifdef RN_USE_KHRONOS_PBR_NEUTRAL
  baseColor = vec4f(PBRNeutralToneMapping(baseColor.rgb), baseColor.a);
#endif

#ifdef RN_USE_REINHARD
  baseColor = vec4f(ReinhardToneMapping(baseColor.rgb), baseColor.a);
#endif

#ifdef RN_USE_ACES_NARKOWICZ
  baseColor = vec4f(ACES_Narkowicz_ToneMapping(baseColor.rgb), baseColor.a);
#endif

#ifdef RN_USE_ACES_HILL
  baseColor = vec4f(ACES_Hill_ToneMapping(baseColor.rgb), baseColor.a);
#endif

#ifdef RN_USE_ACES_HILL_EXPOSURE_BOOST
  baseColor /= 0.6;
  baseColor = vec4f(ACES_Hill_ToneMapping(baseColor.rgb), baseColor.a);
#endif


#ifdef RN_USE_GT_TONEMAP
  baseColor.r = GT_ToneMaping(baseColor.r);
  baseColor.g = GT_ToneMaping(baseColor.g);
  baseColor.b = GT_ToneMaping(baseColor.b);
#endif

  if (get_enableLinearToSrgb(materialSID, 0)) {
    baseColor = vec4f(linearToSrgb(baseColor.rgb), baseColor.a);
  }

  return baseColor;
}
`,shaderStage:"fragment",isFragmentShader:!0}});var RS,wS=C(()=>{RS={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec3 a_position;
out vec2 v_texcoord_0;

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

void main()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
gl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4(a_position, 1.0);


v_texcoord_0 = a_texcoord_0;

}
`,shaderStage:"vertex",isFragmentShader:!1}});var PS,NS=C(()=>{PS={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec2 v_texcoord_0;

uniform sampler2DRect u_baseColorTexture; // initialValue=(0,white)
uniform float u_count; // initialValue=0.0
uniform float u_direction; // initialValue=0.0
/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

void main ()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


float i = get_count(materialSID, 0);
float dir = get_direction(materialSID, 0);

rt0 = texture(u_baseColorTexture, gl_FragCoord.xy);

if (dir > 0.0) {
  // horizontal
  rt0 += texture(u_baseColorTexture, vec2(gl_FragCoord.x + pow(2.0, i), gl_FragCoord.y));
} else {
  // virtical
  rt0 += texture(u_baseColorTexture, vec2(gl_FragCoord.x, gl_FragCoord.y + pow(2.0, i)));
}

/* shaderity: @{renderTargetEnd} */


}
`,shaderStage:"fragment",isFragmentShader:!0}});var DS,MS=C(()=>{DS={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec3 a_position;
in vec3 a_color;
in vec3 a_normal;
in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec4 a_joint;
in vec4 a_weight;
in vec4 a_baryCentricCoord;
out vec3 v_color;
out vec3 v_normal_inWorld;
out vec4 v_position_inWorld;
out vec2 v_texcoord_0;
out vec3 v_baryCentricCoord;

uniform float u_pointSize; // initialValue=30
uniform vec3 u_pointDistanceAttenuation; // initialValue=(0,0.1,0.01)

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

mat3 toNormalMatrix(mat4 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];

  float b00 = a00 * a11 - a01 * a10,
  b01 = a00 * a12 - a02 * a10,
  b02 = a00 * a13 - a03 * a10,
  b03 = a01 * a12 - a02 * a11,
  b04 = a01 * a13 - a03 * a11,
  b05 = a02 * a13 - a03 * a12,
  b06 = a20 * a31 - a21 * a30,
  b07 = a20 * a32 - a22 * a30,
  b08 = a20 * a33 - a23 * a30,
  b09 = a21 * a32 - a22 * a31,
  b10 = a21 * a33 - a23 * a31,
  b11 = a22 * a33 - a23 * a32;

  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3(
    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,
    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,
    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;
}



#ifdef RN_IS_SKINNING

highp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {
  highp vec4 q = quaternion;
  highp vec3 t = translation;

  highp float sx = q.x * q.x;
  highp float sy = q.y * q.y;
  highp float sz = q.z * q.z;
  highp float cx = q.y * q.z;
  highp float cy = q.x * q.z;
  highp float cz = q.x * q.y;
  highp float wx = q.w * q.x;
  highp float wy = q.w * q.y;
  highp float wz = q.w * q.z;

  highp mat4 mat = mat4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  highp mat4 uniformScaleMat = mat4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return mat*uniformScaleMat;
}

highp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){

  highp float r;
  highp float g;
  highp float b;
  highp float a;

  highp float ix = floor(vec_xy.x * criteria);
  highp float v1x = ix / criteria;
  highp float v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  highp float iy = floor( vec_xy.y * criteria);
  highp float v2x = iy / criteria;
  highp float v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4(r, g, b, a);
}

mat4 getSkinMatrix(float skeletalComponentSID) {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));
  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));
  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));
  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  vec2 criteria = vec2(4096.0, 4096.0);

  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));
  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));
  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));
  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));
  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));
  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));
  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));

  vec2 criteria = vec2(4096.0, 4096.0);
  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif



#ifdef RN_IS_SKINNING
bool skinning(
  float skeletalComponentSID,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
  )
{
  mat4 skinMat = getSkinMatrix(skeletalComponentSID);
  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);
  outNormalMatrix = toNormalMatrix(skinMat);
  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);

  return true;
}
#endif

bool processGeometryWithMorphingAndSkinning(
  float skeletalComponentSID,
  in mat4 worldMatrix,
  in mat4 viewMatrix,
  in bool isBillboard,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
) {
  bool isSkinning = false;

  vec3 position_inLocal;
#ifdef RN_IS_MORPHING
  if (u_morphTargetNumber == 0) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    float vertexIdx = a_baryCentricCoord.w;
    position_inLocal = get_position(vertexIdx, inPosition_inLocal);
  }
#endif

  mat4 worldMatrixInner = worldMatrix;
  if (isBillboard) {
    mat4 inverseViewMatrix = inverse(viewMatrix);
    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];
    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];
    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];
    worldMatrixInner = inverseViewMatrix * worldMatrix;
  }

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0.0) {
    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);
  } else {
#endif
    outNormalMatrix = inNormalMatrix;
    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
#ifdef RN_IS_SKINNING
  }
#endif

  return isSkinning;
}


void main()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);
  bool isBillboard = get_isBillboard(a_instanceInfo.x);

  // Skeletal
  processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    worldMatrix,
    viewMatrix,
    isBillboard,
    normalMatrix,
    normalMatrix,
    a_position,
    v_position_inWorld,
    a_normal,
    v_normal_inWorld
  );

  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;


  v_color = a_color;
  v_normal_inWorld = normalMatrix * a_normal;
  v_texcoord_0 = a_texcoord_0;
  v_baryCentricCoord = a_baryCentricCoord.xyz;

  bool visibility = get_isVisible(a_instanceInfo.x);
  if (!visibility)
  {
    gl_Position = vec4(0.0);
  }

// #ifdef RN_IS_POINTSPRITE

vec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);
vec3 viewPosition = get_viewPosition(cameraSID, 0);
float distanceFromCamera = length(position_inWorld.xyz - viewPosition);
vec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);
float distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));
float maxPointSize = get_pointSize(materialSID, 0);
gl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);

// #endif


}
`,shaderStage:"vertex",isFragmentShader:!1}});var FS,BS=C(()=>{FS={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec3 v_color;
in vec3 v_normal_inWorld;
in vec4 v_position_inWorld;
in vec2 v_texcoord_0;
in vec3 v_baryCentricCoord;

uniform int u_shadingModel; // initialValue=0
uniform float u_alphaCutoff; // initialValue=0.01
uniform vec4 u_diffuseColorFactor; // initialValue=(1,1,1,1)
uniform sampler2D u_diffuseColorTexture; // initialValue=(0,white)
uniform sampler2D u_normalTexture; // initialValue=(1,blue)
uniform vec4 u_diffuseColorTextureTransform; // initialValue=(1,1,0,0)
uniform float u_diffuseColorTextureRotation; // initialValue=0

/* shaderity: @{renderTargetBegin} */



vec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {
  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  mat3 rotationMat = mat3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  mat3 matrix = translationMat * rotationMat * scaleMat;
  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;

  return uvTransformed;
}


/* shaderity: @{getters} */

struct Light {
  int type; // 0 = directional, 1 = point, 2 = spot
  vec3 position;
  vec3 intensity;
  vec3 attenuatedIntensity;
  vec3 directionOfLightObject;
  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)
  vec3 pointToLight; // not normalized
  float innerConeCos;
  float outerConeCos;
  float effectiveRange;
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
float getRangeAttenuation(Light light)
{
  float distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
float getSpotAttenuation(Light light)
{
  float actualCos = dot(light.direction, -light.directionOfLightObject);
  if (actualCos > light.outerConeCos) {
    if (actualCos < light.innerConeCos) {
      float attenuation = (actualCos - light.outerConeCos) / (light.innerConeCos - light.outerConeCos);
      return attenuation * attenuation;
    }
    return 1.0;
  }
  return 0.0;
}

vec3 getLightAttenuated(Light light) {
  light.attenuatedIntensity = light.intensity;
  // if (light.type == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light && Spot Light
  if (light.type != 0)
  {
    light.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot Light
  if (light.type == 2)
  {
    light.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return light.attenuatedIntensity;
}

Light getLight(int lightIdx, vec3 v_position_inWorld) {
  vec3 lightPosition = get_lightPosition(0.0, lightIdx);
  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);
  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);
  vec4 lightProperty = get_lightProperty(0.0, lightIdx);
  Light light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  float lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.innerConeCos = lightProperty.z;
  light.outerConeCos = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3(0.0);
    light.type = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.type = 1;
  } else { // is Directional Light
    light.type = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.type = 2;
  }

  const float M_PI = 3.141592653589793;
  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  light.attenuatedIntensity = getLightAttenuated(light);

  return light;
}


void main ()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


#ifdef RN_IS_ALPHA_MODE_MASK
  float alphaCutoff = get_alphaCutoff(materialSID, 0);
  if (alpha < alphaCutoff) {
    discard;
  }
#endif


  // Normal
  vec3 normal_inWorld = normalize(v_normal_inWorld);

  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);


  // diffuseColor (Considered to be premultiplied alpha)
  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);
  float alpha = 1.0;
  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {
    diffuseColor = v_color * diffuseColorFactor.rgb;
    alpha = diffuseColorFactor.a;
  } else if (v_color == diffuseColor) {
    diffuseColor = diffuseColorFactor.rgb;
    alpha = diffuseColorFactor.a;
  } else if (diffuseColorFactor.rgb == diffuseColor) {
    diffuseColor = v_color;
  } else {
    diffuseColor = vec3(1.0, 1.0, 1.0);
  }

  // diffuseColorTexture (Considered to be premultiplied alpha)
  vec4 diffuseColorTextureTransform = get_diffuseColorTextureTransform(materialSID, 0);
  float diffuseColorTextureRotation = get_diffuseColorTextureRotation(materialSID, 0);
  vec2 diffuseColorTexUv = uvTransform(diffuseColorTextureTransform.xy, diffuseColorTextureTransform.zw, diffuseColorTextureRotation, v_texcoord_0);
  vec4 textureColor = texture(u_diffuseColorTexture, diffuseColorTexUv);
  diffuseColor *= textureColor.rgb;
  alpha *= textureColor.a;


#ifdef RN_IS_ALPHA_MODE_BLEND
#else
  alpha = 1.0;
#endif

  rt0 = vec4(diffuseColor * alpha, alpha);

/* shaderity: @{renderTargetEnd} */


}

`,shaderStage:"fragment",isFragmentShader:!0}});var VS,LS=C(()=>{VS={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

@vertex
fn main(
#ifdef RN_USE_INSTANCE
  @location(8) instance_ids: vec4<f32>,
#endif


#ifdef RN_USE_POSITION_FLOAT
  @location(0) position: vec3<f32>,
#endif
#ifdef RN_USE_POSITION_INT
  @location(0) position: vec3<i32>,
#endif
#ifdef RN_USE_POSITION_UINT
  @location(0) position: vec3<u32>,
#endif

#ifdef RN_USE_NORMAL
  @location(1) normal: vec3<f32>,
#endif
#ifdef RN_USE_TANGENT
  @location(2) tangent: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_0
  @location(3) texcoord_0: vec2<f32>,
#endif
#ifdef RN_USE_TEXCOORD_1
  @location(4) texcoord_1: vec2<f32>,
#endif

#ifdef RN_USE_COLOR_0_FLOAT
  @location(5) color_0: vec4<f32>,
#endif
#ifdef RN_USE_COLOR_0_INT
  @location(5) color_0: vec4<i32>,
#endif
#ifdef RN_USE_COLOR_0_UINT
  @location(5) color_0: vec4<u32>,
#endif

#ifdef RN_USE_JOINTS_0
  @location(6) joints_0: vec4<u32>,
#endif
#ifdef RN_USE_WEIGHTS_0
  @location(7) weights_0: vec4<f32>,
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
  @location(10) baryCentricCoord: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_2
  @location(11) texcoord_2: vec2<f32>,
#endif
  @builtin(vertex_index) vertexIdx : u32,


) -> VertexOutput {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  var output : VertexOutput;

  let worldMatrix = get_worldMatrix(u32(instance_ids.x));
  let viewMatrix = get_viewMatrix(cameraSID, 0u);
  let projectionMatrix = get_projectionMatrix(cameraSID, 0u);

  output.position = projectionMatrix * viewMatrix * worldMatrix * vec4<f32>(position, 1.0);

#ifdef RN_USE_NORMAL
  output.normal_inWorld = normalize((worldMatrix * vec4<f32>(normal, 0.0)).xyz);
#endif

#ifdef RN_USE_TEXCOORD_0
  output.texcoord_0 = texcoord_0;
#endif

  // output.Position = vec4<f32>(position, 1.0);

  return output;
}
`,shaderStage:"vertex",isFragmentShader:!1}});var GS,zS=C(()=>{GS={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */

// #param diffuseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)

@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=blue
@group(2) @binding(0) var baseColorSampler: sampler;

@fragment
fn main(
  input: VertexOutput
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  var Normal = input.normal_inWorld * 0.5 + 0.5;
  // return vec4<f32>(Normal.x, Normal.y, Normal.z, 1);

#ifdef RN_USE_TEXCOORD_0
  var baseColor = textureSample(baseColorTexture, baseColorSampler, input.texcoord_0);
  return baseColor;
#else
  return vec4<f32>(1, 0, 0, 1);
#endif

}
`,shaderStage:"fragment",isFragmentShader:!0}});var US,OS=C(()=>{US={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec3 a_position;
in vec3 a_color;
in vec3 a_normal;
in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec2 a_texcoord_1;
in vec2 a_texcoord_2;
in vec4 a_joint;
in vec4 a_weight;
in vec4 a_baryCentricCoord;
out vec3 v_color;
out vec3 v_normal_inWorld;
out vec4 v_position_inWorld;

uniform float u_pointSize; // initialValue=30, soloDatum=true
uniform vec3 u_pointDistanceAttenuation; // initialValue=(0.0, 0.1, 0.01), soloDatum=true

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

mat3 toNormalMatrix(mat4 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];

  float b00 = a00 * a11 - a01 * a10,
  b01 = a00 * a12 - a02 * a10,
  b02 = a00 * a13 - a03 * a10,
  b03 = a01 * a12 - a02 * a11,
  b04 = a01 * a13 - a03 * a11,
  b05 = a02 * a13 - a03 * a12,
  b06 = a20 * a31 - a21 * a30,
  b07 = a20 * a32 - a22 * a30,
  b08 = a20 * a33 - a23 * a30,
  b09 = a21 * a32 - a22 * a31,
  b10 = a21 * a33 - a23 * a31,
  b11 = a22 * a33 - a23 * a32;

  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3(
    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,
    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,
    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;
}



#ifdef RN_IS_SKINNING

highp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {
  highp vec4 q = quaternion;
  highp vec3 t = translation;

  highp float sx = q.x * q.x;
  highp float sy = q.y * q.y;
  highp float sz = q.z * q.z;
  highp float cx = q.y * q.z;
  highp float cy = q.x * q.z;
  highp float cz = q.x * q.y;
  highp float wx = q.w * q.x;
  highp float wy = q.w * q.y;
  highp float wz = q.w * q.z;

  highp mat4 mat = mat4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  highp mat4 uniformScaleMat = mat4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return mat*uniformScaleMat;
}

highp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){

  highp float r;
  highp float g;
  highp float b;
  highp float a;

  highp float ix = floor(vec_xy.x * criteria);
  highp float v1x = ix / criteria;
  highp float v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  highp float iy = floor( vec_xy.y * criteria);
  highp float v2x = iy / criteria;
  highp float v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4(r, g, b, a);
}

mat4 getSkinMatrix(float skeletalComponentSID) {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));
  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));
  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));
  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  vec2 criteria = vec2(4096.0, 4096.0);

  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));
  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));
  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));
  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));
  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));
  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));
  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));

  vec2 criteria = vec2(4096.0, 4096.0);
  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif



#ifdef RN_IS_SKINNING
bool skinning(
  float skeletalComponentSID,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
  )
{
  mat4 skinMat = getSkinMatrix(skeletalComponentSID);
  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);
  outNormalMatrix = toNormalMatrix(skinMat);
  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);

  return true;
}
#endif

bool processGeometryWithMorphingAndSkinning(
  float skeletalComponentSID,
  in mat4 worldMatrix,
  in mat4 viewMatrix,
  in bool isBillboard,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
) {
  bool isSkinning = false;

  vec3 position_inLocal;
#ifdef RN_IS_MORPHING
  if (u_morphTargetNumber == 0) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    float vertexIdx = a_baryCentricCoord.w;
    position_inLocal = get_position(vertexIdx, inPosition_inLocal);
  }
#endif

  mat4 worldMatrixInner = worldMatrix;
  if (isBillboard) {
    mat4 inverseViewMatrix = inverse(viewMatrix);
    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];
    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];
    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];
    worldMatrixInner = inverseViewMatrix * worldMatrix;
  }

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0.0) {
    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);
  } else {
#endif
    outNormalMatrix = inNormalMatrix;
    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
#ifdef RN_IS_SKINNING
  }
#endif

  return isSkinning;
}


void main()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);
  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);
  bool isBillboard = get_isBillboard(a_instanceInfo.x);

  v_color = a_color;

  bool isSkinning = false;

  isSkinning = processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    worldMatrix,
    viewMatrix,
    isBillboard,
    normalMatrix,
    normalMatrix,
    a_position,
    v_position_inWorld,
    a_normal,
    v_normal_inWorld
  );

  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;

  bool visibility = get_isVisible(a_instanceInfo.x);
  if (!visibility)
  {
    gl_Position = vec4(0.0);
  }

// #ifdef RN_IS_POINTSPRITE

vec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);
vec3 viewPosition = get_viewPosition(cameraSID, 0);
float distanceFromCamera = length(position_inWorld.xyz - viewPosition);
vec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);
float distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));
float maxPointSize = get_pointSize(materialSID, 0);
gl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);

// #endif


}

`,shaderStage:"vertex",isFragmentShader:!1}});var WS,kS=C(()=>{WS={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec3 v_color;
in vec3 v_normal_inWorld;
in vec4 v_position_inWorld;

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */


void main (){

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  float depth = gl_FragCoord.z;
  float dx = dFdx(depth);
  float dy = dFdy(depth);

  rt0.x = depth; // M1
  rt0.y = sq(depth) + 0.25 * (sq(dx) + sq(dy)); // M2
  rt0.z = 0.0;
  rt0.w = 1.0;

/* shaderity: @{renderTargetEnd} */

}

`,shaderStage:"fragment",isFragmentShader:!0}});var XS,QS=C(()=>{XS={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */


#ifdef RN_IS_SKINNING

fn createMatrixFromQuaternionTranslationScale( quaternion: vec4<f32>, translation: vec3<f32>, scale: vec3<f32> ) -> mat4x4<f32> {
  let q = quaternion;
  let t = translation;

  let sx = q.x * q.x;
  let sy = q.y * q.y;
  let sz = q.z * q.z;
  let cx = q.y * q.z;
  let cy = q.x * q.z;
  let cz = q.x * q.y;
  let wx = q.w * q.x;
  let wy = q.w * q.y;
  let wz = q.w * q.z;

  let mat = mat4x4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  let uniformScaleMat = mat4x4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  let mat44 = mat*uniformScaleMat;
  return mat44;

}

fn unpackedVec2ToNormalizedVec4(vec_xy: vec2<f32>, criteria: f32) -> vec4<f32> {

  var r: f32;
  var g: f32;
  var b: f32;
  var a: f32;

  let ix = floor(vec_xy.x * criteria);
  let v1x = ix / criteria;
  let v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  let iy = floor( vec_xy.y * criteria);
  let v2x = iy / criteria;
  let v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4<f32>(r, g, b, a);
}

fn get_boneMatrixAsMat4x4(skeletalComponentSID: u32, joint: u32) -> mat4x4<f32> {
  let mat43: mat4x3<f32> = get_boneMatrix(skeletalComponentSID, joint);
  return mat4x4<f32>(
    vec4<f32>(mat43[0], 0.0),
    vec4<f32>(mat43[1], 0.0),
    vec4<f32>(mat43[2], 0.0),
    vec4<f32>(mat43[3], 1.0)
  );
}

fn getSkinMatrix(skeletalComponentSID: u32, joint: vec4<u32>, weight: vec4<f32>) -> mat4x4<f32> {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  var skinMat: mat4x4<f32> = weight.x * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.x);
  skinMat += weight.y * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.y);
  skinMat += weight.z * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.z);
  skinMat += weight.w * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.w);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  let criteria = vec2<f32>(4096.0, 4096.0);

  let tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, joint.x);
  let sq_x = get_boneScalePackedQuat(skeletalComponentSID, joint.x);
  var quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  let tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, joint.y);
  let sq_y = get_boneScalePackedQuat(skeletalComponentSID, joint.y);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  let tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, joint.z);
  let sq_z = get_boneScalePackedQuat(skeletalComponentSID, joint.z);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  let tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, joint.w);
  let sq_w = get_boneScalePackedQuat(skeletalComponentSID, joint.w);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  let ts_x = get_boneTranslateScale(skeletalComponentSID, joint.x);
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.x), ts_x.xyz, vec3(ts_x.w));
  let ts_y = get_boneTranslateScale(skeletalComponentSID, joint.y);
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.y), ts_y.xyz, vec3(ts_y.w));
  let ts_z = get_boneTranslateScale(skeletalComponentSID, joint.z);
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.z), ts_z.xyz, vec3(ts_z.w));
  let ts_w = get_boneTranslateScale(skeletalComponentSID, joint.w);
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.w), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  let boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, joint.x);
  let boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, joint.y);
  let boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, joint.z);
  let boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, joint.w);

  let criteria = vec2<f32>(4096.0, 4096.0);
  let boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  let ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  let ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  let ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  let ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif

fn toNormalMatrix(m: mat4x4<f32>) -> mat3x3<f32> {
  let a00 = m[0][0];
  let a01 = m[0][1];
  let a02 = m[0][2];
  let a03 = m[0][3];
  let a10 = m[1][0];
  let a11 = m[1][1];
  let a12 = m[1][2];
  let a13 = m[1][3];
  let a20 = m[2][0];
  let a21 = m[2][1];
  let a22 = m[2][2];
  let a23 = m[2][3];
  let a30 = m[3][0];
  let a31 = m[3][1];
  let a32 = m[3][2];
  let a33 = m[3][3];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  let determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3x3<f32>(
    (a11 * b11 - a12 * b10 + a13 * b09) / determinantVal,
    (a12 * b08 - a10 * b11 - a13 * b07) / determinantVal,
    (a10 * b10 - a11 * b08 + a13 * b06) / determinantVal,
    (a02 * b10 - a01 * b11 - a03 * b09) / determinantVal,
    (a00 * b11 - a02 * b08 + a03 * b07) / determinantVal,
    (a01 * b08 - a00 * b10 - a03 * b06) / determinantVal,
    (a31 * b05 - a32 * b04 + a33 * b03) / determinantVal,
    (a32 * b02 - a30 * b05 - a33 * b01) / determinantVal,
    (a30 * b04 - a31 * b02 + a33 * b00) / determinantVal
  );
}

struct GeometoryOutput {
  normalMatrix: mat3x3<f32>,
  position_inWorld: vec4<f32>,
  normal_inWorld: vec3<f32>,
  isSkinning: bool,
}

#ifdef RN_IS_SKINNING
fn skinning(
  skeletalComponentSID: u32,
  inNormalMatrix: mat3x3<f32>,
  inPosition_inLocal: vec3<f32>,
  inNormal_inLocal: vec3<f32>,
  joint: vec4<u32>,
  weight: vec4<f32>,
  ) -> GeometoryOutput
{
  var output: GeometoryOutput;
  let skinMat = getSkinMatrix(skeletalComponentSID, joint, weight);
  output.position_inWorld = skinMat * vec4<f32>(inPosition_inLocal, 1.0);
  output.normalMatrix = toNormalMatrix(skinMat);
  output.normal_inWorld = normalize(output.normalMatrix * inNormal_inLocal);
  output.isSkinning = true;

  return output;
}
#endif


fn processGeometryWithMorphingAndSkinning(
  skeletalComponentSID: i32,
  blendShapeComponentSID: u32,
  worldMatrix: mat4x4<f32>,
  viewMatrix: mat4x4<f32>,
  isBillboard: bool,
  inNormalMatrix: mat3x3<f32>,
  inPosition_inLocal: vec3<f32>,
  inNormal_inLocal: vec3<f32>,
  baryCentricCoord: vec4<f32>,
  joint: vec4<u32>,
  weight: vec4<f32>,
) -> GeometoryOutput {
  var output: GeometoryOutput;

  var position_inLocal: vec3<f32>;
#ifdef RN_IS_MORPHING
  if (uniformDrawParameters.morphTargetNumber == 0u) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    let vertexIdx = u32(baryCentricCoord.w);
    position_inLocal = get_position(vertexIdx, inPosition_inLocal, blendShapeComponentSID);
  }
#endif

  var worldMatrixInner = worldMatrix;

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0) {
    output = skinning(u32(skeletalComponentSID), inNormalMatrix, position_inLocal, inNormal_inLocal, joint, weight);
  } else {
#endif
    output.normalMatrix = inNormalMatrix;
    output.position_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    output.normal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
    output.isSkinning = false;
#ifdef RN_IS_SKINNING
  }
#endif

  return output;
}


@vertex
fn main(
#ifdef RN_USE_INSTANCE
  @location(8) instance_ids: vec4<f32>,
#endif


#ifdef RN_USE_POSITION_FLOAT
  @location(0) position: vec3<f32>,
#endif
#ifdef RN_USE_POSITION_INT
  @location(0) position: vec3<i32>,
#endif
#ifdef RN_USE_POSITION_UINT
  @location(0) position: vec3<u32>,
#endif

#ifdef RN_USE_NORMAL
  @location(1) normal: vec3<f32>,
#endif
#ifdef RN_USE_TANGENT
  @location(2) tangent: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_0
  @location(3) texcoord_0: vec2<f32>,
#endif
#ifdef RN_USE_TEXCOORD_1
  @location(4) texcoord_1: vec2<f32>,
#endif

#ifdef RN_USE_COLOR_0_FLOAT
  @location(5) color_0: vec4<f32>,
#endif
#ifdef RN_USE_COLOR_0_INT
  @location(5) color_0: vec4<i32>,
#endif
#ifdef RN_USE_COLOR_0_UINT
  @location(5) color_0: vec4<u32>,
#endif

#ifdef RN_USE_JOINTS_0
  @location(6) joints_0: vec4<u32>,
#endif
#ifdef RN_USE_WEIGHTS_0
  @location(7) weights_0: vec4<f32>,
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
  @location(10) baryCentricCoord: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_2
  @location(11) texcoord_2: vec2<f32>,
#endif
  @builtin(vertex_index) vertexIdx : u32,


) -> VertexOutput {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;

  var output : VertexOutput;

#ifdef RN_USE_NORMAL
#else
  let normal = vec3<f32>(0.0, 0.0, 0.0);
#endif

#ifdef RN_USE_JOINTS_0
  let joint = joints_0;
#else
  let joint = vec4<u32>(0, 0, 0, 0);
#endif
#ifdef RN_USE_WEIGHTS_0
  let weight = weights_0;
#else
  let weight = vec4<f32>(0.0, 0.0, 0.0, 0.0);
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
#else
  let baryCentricCoord = vec4<f32>(0.0, 0.0, 0.0, 0.0);
#endif

  let instanceId = u32(instance_ids.x);
  let worldMatrix = get_worldMatrix(u32(instance_ids.x));
  let normalMatrix = get_normalMatrix(instanceId);
  let viewMatrix = get_viewMatrix(cameraSID, 0u);
  let skeletalComponentSID = i32(instance_ids.y);
  let blendShapeComponentSID = u32(instance_ids.z);

  let geom = processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    blendShapeComponentSID,
    worldMatrix,
    viewMatrix,
    false,
    normalMatrix,
    position,
    normal,
    baryCentricCoord,
    joint,
    weight
  );

  let projectionMatrix = get_projectionMatrix(cameraSID, 0u);

  output.position = projectionMatrix * viewMatrix * geom.position_inWorld;

  return output;
}
`,shaderStage:"vertex",isFragmentShader:!1}});var qS,HS=C(()=>{qS={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */

@fragment
fn main(
  input: VertexOutput
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  let depth = input.position.z;
  let dx = dpdx(depth);
  let dy = dpdy(depth);

  var rt0: vec4<f32>;
  rt0.x = depth; // M1
  rt0.y = sqF32(depth) + 0.25 * (sqF32(dx) + sqF32(dy)); // M2
  rt0.z = 0.0;
  rt0.w = 1.0;

  return rt0;
}
`,shaderStage:"fragment",isFragmentShader:!0}});var YS,jS=C(()=>{YS={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec3 a_position;
in vec3 a_color;
in vec3 a_normal;
in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec2 a_texcoord_1;
in vec2 a_texcoord_2;
in vec4 a_joint;
in vec4 a_weight;
in vec4 a_baryCentricCoord;
out vec3 v_color;
out vec3 v_normal_inWorld;
out vec4 v_position_inWorld;

uniform bool u_frontHemisphere; // initialValue=true
uniform int u_lightIndex; // initialValue=0
uniform float u_farPlane; // initialValue=1000.0

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

mat3 toNormalMatrix(mat4 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];

  float b00 = a00 * a11 - a01 * a10,
  b01 = a00 * a12 - a02 * a10,
  b02 = a00 * a13 - a03 * a10,
  b03 = a01 * a12 - a02 * a11,
  b04 = a01 * a13 - a03 * a11,
  b05 = a02 * a13 - a03 * a12,
  b06 = a20 * a31 - a21 * a30,
  b07 = a20 * a32 - a22 * a30,
  b08 = a20 * a33 - a23 * a30,
  b09 = a21 * a32 - a22 * a31,
  b10 = a21 * a33 - a23 * a31,
  b11 = a22 * a33 - a23 * a32;

  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3(
    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,
    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,
    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;
}



#ifdef RN_IS_SKINNING

highp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {
  highp vec4 q = quaternion;
  highp vec3 t = translation;

  highp float sx = q.x * q.x;
  highp float sy = q.y * q.y;
  highp float sz = q.z * q.z;
  highp float cx = q.y * q.z;
  highp float cy = q.x * q.z;
  highp float cz = q.x * q.y;
  highp float wx = q.w * q.x;
  highp float wy = q.w * q.y;
  highp float wz = q.w * q.z;

  highp mat4 mat = mat4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  highp mat4 uniformScaleMat = mat4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return mat*uniformScaleMat;
}

highp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){

  highp float r;
  highp float g;
  highp float b;
  highp float a;

  highp float ix = floor(vec_xy.x * criteria);
  highp float v1x = ix / criteria;
  highp float v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  highp float iy = floor( vec_xy.y * criteria);
  highp float v2x = iy / criteria;
  highp float v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4(r, g, b, a);
}

mat4 getSkinMatrix(float skeletalComponentSID) {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));
  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));
  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));
  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  vec2 criteria = vec2(4096.0, 4096.0);

  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));
  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));
  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));
  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));
  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));
  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));
  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));

  vec2 criteria = vec2(4096.0, 4096.0);
  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif



#ifdef RN_IS_SKINNING
bool skinning(
  float skeletalComponentSID,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
  )
{
  mat4 skinMat = getSkinMatrix(skeletalComponentSID);
  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);
  outNormalMatrix = toNormalMatrix(skinMat);
  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);

  return true;
}
#endif

bool processGeometryWithMorphingAndSkinning(
  float skeletalComponentSID,
  in mat4 worldMatrix,
  in mat4 viewMatrix,
  in bool isBillboard,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
) {
  bool isSkinning = false;

  vec3 position_inLocal;
#ifdef RN_IS_MORPHING
  if (u_morphTargetNumber == 0) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    float vertexIdx = a_baryCentricCoord.w;
    position_inLocal = get_position(vertexIdx, inPosition_inLocal);
  }
#endif

  mat4 worldMatrixInner = worldMatrix;
  if (isBillboard) {
    mat4 inverseViewMatrix = inverse(viewMatrix);
    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];
    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];
    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];
    worldMatrixInner = inverseViewMatrix * worldMatrix;
  }

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0.0) {
    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);
  } else {
#endif
    outNormalMatrix = inNormalMatrix;
    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
#ifdef RN_IS_SKINNING
  }
#endif

  return isSkinning;
}


void main()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  bool visibility = get_isVisible(a_instanceInfo.x);
  if (!visibility)
  {
    gl_Position = vec4(2.0, 2.0, 2.0, 1.0);
    return;
  }

  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);
  bool isBillboard = get_isBillboard(a_instanceInfo.x);

  v_color = a_color;

  bool isSkinning = false;

  isSkinning = processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    worldMatrix,
    viewMatrix,
    isBillboard,
    normalMatrix,
    normalMatrix,
    a_position,
    v_position_inWorld,
    a_normal,
    v_normal_inWorld
  );

  int lightIndex = get_lightIndex(materialSID, 0);
  vec3 lightPosition = get_lightPosition(0.0, lightIndex);
  vec3 L = v_position_inWorld.xyz - lightPosition;
  float dist = length(L);
  L = normalize(L);

  bool frontHemisphere = get_frontHemisphere(materialSID, 0);
  float signHemisphere = frontHemisphere ? 1.0 : -1.0;
  float denom = 1.0 + signHemisphere * L.z;

  vec2 uv = L.xy / denom;

  if (abs(denom) < 1e-6) {
    gl_Position = vec4(0.0, 0.0, -1000000.0, 1.0);
    return;
  }
  // if ((u_frontHemisphere && L.z < 0.0) ||
  //      (!u_frontHemisphere && L.z > 0.0))
  // {
  //   gl_Position = vec4(0.0, 0.0, -1000000.0, 1.0);
  //   return;
  // }

  float farPlane = get_farPlane(materialSID, 0);
  gl_Position = vec4(uv, dist / farPlane, 1.0);
  v_position_inWorld = vec4(uv, dist / farPlane, signHemisphere * L.z);
}
`,shaderStage:"vertex",isFragmentShader:!1}});var ZS,KS=C(()=>{ZS={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec3 v_color;
in vec3 v_normal_inWorld;
in vec4 v_position_inWorld;

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

uniform bool u_frontHemisphere; // initialValue=true

void main (){

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  float denom = v_position_inWorld.w;
  if (denom < 0.0) {
    discard;
  }

  float depth = v_position_inWorld.z;
  float dx = dFdx(depth);
  float dy = dFdy(depth);

  bool frontHemisphere = get_frontHemisphere(materialSID, 0);
  if (frontHemisphere) {
    rt0.r = depth; // M1
    rt0.g = sq(depth) + 0.25 * (sq(dx) + sq(dy)); // M2
    rt0.b = 1.0;
    rt0.a = 1.0;
  } else {
    rt0.r = 1.0;
    rt0.g = 1.0;
    rt0.b = depth; // M1
    rt0.a = sq(depth) + 0.25 * (sq(dx) + sq(dy)); // M2
  }

/* shaderity: @{renderTargetEnd} */

}

`,shaderStage:"fragment",isFragmentShader:!0}});var $S,JS=C(()=>{$S={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */


#ifdef RN_IS_SKINNING

fn createMatrixFromQuaternionTranslationScale( quaternion: vec4<f32>, translation: vec3<f32>, scale: vec3<f32> ) -> mat4x4<f32> {
  let q = quaternion;
  let t = translation;

  let sx = q.x * q.x;
  let sy = q.y * q.y;
  let sz = q.z * q.z;
  let cx = q.y * q.z;
  let cy = q.x * q.z;
  let cz = q.x * q.y;
  let wx = q.w * q.x;
  let wy = q.w * q.y;
  let wz = q.w * q.z;

  let mat = mat4x4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  let uniformScaleMat = mat4x4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  let mat44 = mat*uniformScaleMat;
  return mat44;

}

fn unpackedVec2ToNormalizedVec4(vec_xy: vec2<f32>, criteria: f32) -> vec4<f32> {

  var r: f32;
  var g: f32;
  var b: f32;
  var a: f32;

  let ix = floor(vec_xy.x * criteria);
  let v1x = ix / criteria;
  let v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  let iy = floor( vec_xy.y * criteria);
  let v2x = iy / criteria;
  let v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4<f32>(r, g, b, a);
}

fn get_boneMatrixAsMat4x4(skeletalComponentSID: u32, joint: u32) -> mat4x4<f32> {
  let mat43: mat4x3<f32> = get_boneMatrix(skeletalComponentSID, joint);
  return mat4x4<f32>(
    vec4<f32>(mat43[0], 0.0),
    vec4<f32>(mat43[1], 0.0),
    vec4<f32>(mat43[2], 0.0),
    vec4<f32>(mat43[3], 1.0)
  );
}

fn getSkinMatrix(skeletalComponentSID: u32, joint: vec4<u32>, weight: vec4<f32>) -> mat4x4<f32> {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  var skinMat: mat4x4<f32> = weight.x * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.x);
  skinMat += weight.y * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.y);
  skinMat += weight.z * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.z);
  skinMat += weight.w * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.w);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  let criteria = vec2<f32>(4096.0, 4096.0);

  let tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, joint.x);
  let sq_x = get_boneScalePackedQuat(skeletalComponentSID, joint.x);
  var quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  let tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, joint.y);
  let sq_y = get_boneScalePackedQuat(skeletalComponentSID, joint.y);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  let tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, joint.z);
  let sq_z = get_boneScalePackedQuat(skeletalComponentSID, joint.z);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  let tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, joint.w);
  let sq_w = get_boneScalePackedQuat(skeletalComponentSID, joint.w);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  let ts_x = get_boneTranslateScale(skeletalComponentSID, joint.x);
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.x), ts_x.xyz, vec3(ts_x.w));
  let ts_y = get_boneTranslateScale(skeletalComponentSID, joint.y);
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.y), ts_y.xyz, vec3(ts_y.w));
  let ts_z = get_boneTranslateScale(skeletalComponentSID, joint.z);
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.z), ts_z.xyz, vec3(ts_z.w));
  let ts_w = get_boneTranslateScale(skeletalComponentSID, joint.w);
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.w), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  let boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, joint.x);
  let boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, joint.y);
  let boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, joint.z);
  let boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, joint.w);

  let criteria = vec2<f32>(4096.0, 4096.0);
  let boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  let ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  let ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  let ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  let ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif

fn toNormalMatrix(m: mat4x4<f32>) -> mat3x3<f32> {
  let a00 = m[0][0];
  let a01 = m[0][1];
  let a02 = m[0][2];
  let a03 = m[0][3];
  let a10 = m[1][0];
  let a11 = m[1][1];
  let a12 = m[1][2];
  let a13 = m[1][3];
  let a20 = m[2][0];
  let a21 = m[2][1];
  let a22 = m[2][2];
  let a23 = m[2][3];
  let a30 = m[3][0];
  let a31 = m[3][1];
  let a32 = m[3][2];
  let a33 = m[3][3];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  let determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3x3<f32>(
    (a11 * b11 - a12 * b10 + a13 * b09) / determinantVal,
    (a12 * b08 - a10 * b11 - a13 * b07) / determinantVal,
    (a10 * b10 - a11 * b08 + a13 * b06) / determinantVal,
    (a02 * b10 - a01 * b11 - a03 * b09) / determinantVal,
    (a00 * b11 - a02 * b08 + a03 * b07) / determinantVal,
    (a01 * b08 - a00 * b10 - a03 * b06) / determinantVal,
    (a31 * b05 - a32 * b04 + a33 * b03) / determinantVal,
    (a32 * b02 - a30 * b05 - a33 * b01) / determinantVal,
    (a30 * b04 - a31 * b02 + a33 * b00) / determinantVal
  );
}

struct GeometoryOutput {
  normalMatrix: mat3x3<f32>,
  position_inWorld: vec4<f32>,
  normal_inWorld: vec3<f32>,
  isSkinning: bool,
}

#ifdef RN_IS_SKINNING
fn skinning(
  skeletalComponentSID: u32,
  inNormalMatrix: mat3x3<f32>,
  inPosition_inLocal: vec3<f32>,
  inNormal_inLocal: vec3<f32>,
  joint: vec4<u32>,
  weight: vec4<f32>,
  ) -> GeometoryOutput
{
  var output: GeometoryOutput;
  let skinMat = getSkinMatrix(skeletalComponentSID, joint, weight);
  output.position_inWorld = skinMat * vec4<f32>(inPosition_inLocal, 1.0);
  output.normalMatrix = toNormalMatrix(skinMat);
  output.normal_inWorld = normalize(output.normalMatrix * inNormal_inLocal);
  output.isSkinning = true;

  return output;
}
#endif


fn processGeometryWithMorphingAndSkinning(
  skeletalComponentSID: i32,
  blendShapeComponentSID: u32,
  worldMatrix: mat4x4<f32>,
  viewMatrix: mat4x4<f32>,
  isBillboard: bool,
  inNormalMatrix: mat3x3<f32>,
  inPosition_inLocal: vec3<f32>,
  inNormal_inLocal: vec3<f32>,
  baryCentricCoord: vec4<f32>,
  joint: vec4<u32>,
  weight: vec4<f32>,
) -> GeometoryOutput {
  var output: GeometoryOutput;

  var position_inLocal: vec3<f32>;
#ifdef RN_IS_MORPHING
  if (uniformDrawParameters.morphTargetNumber == 0u) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    let vertexIdx = u32(baryCentricCoord.w);
    position_inLocal = get_position(vertexIdx, inPosition_inLocal, blendShapeComponentSID);
  }
#endif

  var worldMatrixInner = worldMatrix;

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0) {
    output = skinning(u32(skeletalComponentSID), inNormalMatrix, position_inLocal, inNormal_inLocal, joint, weight);
  } else {
#endif
    output.normalMatrix = inNormalMatrix;
    output.position_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    output.normal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
    output.isSkinning = false;
#ifdef RN_IS_SKINNING
  }
#endif

  return output;
}


// #param frontHemisphere: bool; // initialValue=true
// #param lightIndex: u32; // initialValue=0
// #param farPlane: f32; // initialValue=1000.0

@vertex
fn main(
#ifdef RN_USE_INSTANCE
  @location(8) instance_ids: vec4<f32>,
#endif


#ifdef RN_USE_POSITION_FLOAT
  @location(0) position: vec3<f32>,
#endif
#ifdef RN_USE_POSITION_INT
  @location(0) position: vec3<i32>,
#endif
#ifdef RN_USE_POSITION_UINT
  @location(0) position: vec3<u32>,
#endif

#ifdef RN_USE_NORMAL
  @location(1) normal: vec3<f32>,
#endif
#ifdef RN_USE_TANGENT
  @location(2) tangent: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_0
  @location(3) texcoord_0: vec2<f32>,
#endif
#ifdef RN_USE_TEXCOORD_1
  @location(4) texcoord_1: vec2<f32>,
#endif

#ifdef RN_USE_COLOR_0_FLOAT
  @location(5) color_0: vec4<f32>,
#endif
#ifdef RN_USE_COLOR_0_INT
  @location(5) color_0: vec4<i32>,
#endif
#ifdef RN_USE_COLOR_0_UINT
  @location(5) color_0: vec4<u32>,
#endif

#ifdef RN_USE_JOINTS_0
  @location(6) joints_0: vec4<u32>,
#endif
#ifdef RN_USE_WEIGHTS_0
  @location(7) weights_0: vec4<f32>,
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
  @location(10) baryCentricCoord: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_2
  @location(11) texcoord_2: vec2<f32>,
#endif
  @builtin(vertex_index) vertexIdx : u32,


) -> VertexOutput {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;

  var output : VertexOutput;

  let instanceId = u32(instance_ids.x);
  let visibility: bool = get_isVisible(instanceId);
  if (!visibility)
  {
    output.position = vec4(2.0, 2.0, 2.0, 1.0);
    return output;
  }

#ifdef RN_USE_NORMAL
#else
  let normal = vec3<f32>(0.0, 0.0, 0.0);
#endif

#ifdef RN_USE_JOINTS_0
  let joint = joints_0;
#else
  let joint = vec4<u32>(0, 0, 0, 0);
#endif
#ifdef RN_USE_WEIGHTS_0
  let weight = weights_0;
#else
  let weight = vec4<f32>(0.0, 0.0, 0.0, 0.0);
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
#else
  let baryCentricCoord = vec4<f32>(0.0, 0.0, 0.0, 0.0);
#endif

  let worldMatrix = get_worldMatrix(u32(instance_ids.x));
  let normalMatrix = get_normalMatrix(instanceId);
  let viewMatrix = get_viewMatrix(cameraSID, 0u);
  let skeletalComponentSID = i32(instance_ids.y);
  let blendShapeComponentSID = u32(instance_ids.z);

  let geom = processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    blendShapeComponentSID,
    worldMatrix,
    viewMatrix,
    false,
    normalMatrix,
    position,
    normal,
    baryCentricCoord,
    joint,
    weight
  );

  let lightIndex = get_lightIndex(materialSID, 0);
  let lightPosition: vec3<f32> = get_lightPosition(0, lightIndex);
  var L: vec3<f32> = geom.position_inWorld.xyz - lightPosition;
  let dist: f32 = length(L);
  L = normalize(L);

  let frontHemisphere: bool = get_frontHemisphere(materialSID, 0);
  let signHemisphere: f32 = select(-1.0, 1.0, frontHemisphere);
  let denom: f32 = 1.0 + signHemisphere * L.z;

  let uv: vec2<f32> = L.xy / denom;

  if (abs(denom) < 1e-6) {
    output.position = vec4(0.0, 0.0, -1000000.0, 1.0);
    return output;
  }
  // if ((u_frontHemisphere && L.z < 0.0) ||
  //      (!u_frontHemisphere && L.z > 0.0))
  // {
  //   gl_Position = vec4(0.0, 0.0, -1000000.0, 1.0);
  //   return;
  // }

  let farPlane: f32 = get_farPlane(materialSID, 0);
  output.position = vec4(uv, dist / farPlane, 1.0);
  output.color_0= vec4(uv, dist / farPlane, signHemisphere * L.z);

  return output;
}
`,shaderStage:"vertex",isFragmentShader:!1}});var tT,eT=C(()=>{tT={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */

// #param frontHemisphere: bool; // initialValue=true

@fragment
fn main(
  input: VertexOutput
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  let denom = input.color_0.w;
  if (denom < 0.0) {
    discard;
  }

  let depth = input.color_0.z;
  let dx = dpdx(depth);
  let dy = dpdy(depth);

  let frontHemisphere = get_frontHemisphere(materialSID, 0);
  var rt0: vec4<f32>;
  if (frontHemisphere) {
    rt0.r = depth; // M1
    rt0.g = sqF32(depth) + 0.25 * (sqF32(dx) + sqF32(dy)); // M2
    rt0.b = 1.0;
    rt0.a = 1.0;
  } else {
    rt0.r = 1.0;
    rt0.g = 1.0;
    rt0.b = depth; // M1
    rt0.a = sqF32(depth) + 0.25 * (sqF32(dx) + sqF32(dy)); // M2
  }

  return rt0;
}

`,shaderStage:"fragment",isFragmentShader:!0}});function XQ(m){return m.replace(/\/\/.*|\/\*[\s\S]*?\*\//g,"")}function rT(m,n,t,o,r){let{attributeNames:i,attributeSemantics:a}=iT(t),[s,l]=zc._createShaderProgramWithCache(m,n,o.vertex,o.pixel,i,a,r);return[s,l]}function iT(m){let n=mr.getAttributeReflection(m.vertexShaderityObject),t=n.names,o=n.semantics;return{attributeNames:t,attributeSemantics:o}}function HQ(m,n){let t=`
// Vertex Attributes Binding Info
`;for(let o=0;o<m.length;o++)t+=`// ${m[o]}: ${n[o].str} 
`;return t}function aT(m,n,t,o,r,i){let a=G.getWebGLResourceRepository(),s=m._materialContent,l=s.getDefinitions(),c=m.getShaderDefines();for(let T of c)l+=`#define ${T}
`;let u=lT(n);l+=u;let _=oT(m.__materialTypeName,n);_+=`#define RN_IS_VERTEX_SHADER
`;let d=oT(m.__materialTypeName,n);d+=`#define RN_IS_PIXEL_SHADER
`,m.isBlend()&&(d+=`#define RN_IS_ALPHA_MODE_BLEND
`),m.isMask()&&(d+=`#define RN_IS_ALPHA_MODE_MASK
`);let p=mr.fillTemplate(s.vertexShaderityObject,{getters:t,definitions:l,dataUBODefinition:a.getGlslDataUBODefinitionString(),dataUBOVec4Size:a.getGlslDataUBOVec4SizeString(),matricesGetters:r}),x=mr.fillTemplate(s.pixelShaderityObject,{renderTargetBegin:a.getGlslRenderTargetBeginString(4),getters:o,definitions:l,dataUBODefinition:a.getGlslDataUBODefinitionString(),dataUBOVec4Size:a.getGlslDataUBOVec4SizeString(),matricesGetters:r,renderTargetEnd:a.getGlslRenderTargetEndString(4)});_+=p.code.replace(/#version\s+(100|300\s+es)/,""),d+=x.code.replace(/#version\s+(100|300\s+es)/,"");let{attributeNames:v,attributeSemantics:y}=iT(s),g=HQ(v,y);_+=g;let[E,w]=zc._createShaderProgramWithCache(m,n,_,d,v,y);return[E,w]}function oT(m,n){let t="",o=G.getWebGLResourceRepository(),r=o.currentWebGLContextWrapper;r.isWebGL2&&(t+=`#version 300 es
#define GLSL_ES3
`,F.isUboEnabled&&(t+=`#define RN_IS_UBO_ENABLED
`)),t+=`// RN_MATERIAL_TYPE_NAME: ${m}
`,Z.isDataTextureApproach(K.currentProcessApproach)?t+=`#define RN_IS_DATATEXTURE_MODE
`:t+=`#define RN_IS_UNIFORM_MODE
`;let i=Pe.getInstance().getModule("xr"),a=i==null?void 0:i.WebXRSystem.getInstance();return A.exist(a)&&a.isWebXRMode&&o.isSupportMultiViewVRRendering()&&(t+=`#define WEBGL2_MULTI_VIEW
`),(r.isWebGL2||r.webgl1ExtDRV)&&(t+=`#define RN_IS_SUPPORTING_STANDARD_DERIVATIVES
`),F.boneDataType===ke.Mat43x1?t+=`#define RN_BONE_DATA_TYPE_Mat43x1
`:F.boneDataType===ke.Vec4x2?t+=`#define RN_BONE_DATA_TYPE_VEC4X2
`:F.boneDataType===ke.Vec4x2Old?t+=`#define RN_BONE_DATA_TYPE_VEC4X2_OLD
`:F.boneDataType===ke.Vec4x1&&(t+=`#define RN_BONE_DATA_TYPE_VEC4X1
`),t}function sT(m,n,t,o,r){let i=m._materialContent,a=`// Material Type: ${m.materialTypeName}
`;a+=i.getDefinitions();let s=m.getShaderDefines();for(let y of s)a+=`#define ${y}
`;let l=lT(n);a+=l,F.boneDataType===ke.Mat43x1?a+=`#define RN_BONE_DATA_TYPE_Mat43x1
`:F.boneDataType===ke.Vec4x2?a+=`#define RN_BONE_DATA_TYPE_VEC4X2
`:F.boneDataType===ke.Vec4x2Old?a+=`#define RN_BONE_DATA_TYPE_VEC4X2_OLD
`:F.boneDataType===ke.Vec4x1&&(a+=`#define RN_BONE_DATA_TYPE_VEC4X1
`);let c=mr.fillTemplate(i.vertexShaderityObject,{getters:o,definitions:`// RN_IS_VERTEX_SHADER
#define RN_IS_VERTEX_SHADER
`+a,matricesGetters:t,maxMorphDataNumber:""+Math.ceil(F.maxVertexPrimitiveNumberInShader*F.maxVertexMorphNumberInShader/4)}),u="";m.isBlend()&&(u+=`#define RN_IS_ALPHA_MODE_BLEND
`),m.isMask()&&(u+=`#define RN_IS_ALPHA_MODE_MASK
`);let _=mr.fillTemplate(i.pixelShaderityObject,{getters:r,definitions:`// RN_IS_PIXEL_SHADER
#define RN_IS_PIXEL_SHADER
`+a+u,matricesGetters:t,maxMorphDataNumber:""+Math.ceil(F.maxVertexPrimitiveNumberInShader*F.maxVertexMorphNumberInShader/4)}),d=nT.processPragma(c),p=nT.processPragma(_),[x,v]=zc._createShaderProgramWithCache(m,n,d.code,p.code,[],[]);return x}function lT(m){let n="",t=m.attributeSemantics;for(let o of t){if(o.indexOf("POSITION")!==-1){n+=`#define RN_USE_POSITION
`;let r=m.getAttribute(o);r.componentType.isFloatingPoint()?n+=`#define RN_USE_POSITION_FLOAT
`:r.componentType.isInteger()?n+=`#define RN_USE_POSITION_INT
`:n+=`#define RN_USE_POSITION_UINT
`}if(o.indexOf("NORMAL")!==-1&&(n+=`#define RN_USE_NORMAL
`),o.indexOf("TANGENT")!==-1&&(n+=`#define RN_USE_TANGENT
`),o.indexOf("TEXCOORD_0")!==-1&&(n+=`#define RN_USE_TEXCOORD_0
`),o.indexOf("TEXCOORD_1")!==-1&&(n+=`#define RN_USE_TEXCOORD_1
`),o.indexOf("COLOR_0")!==-1){n+=`#define RN_USE_COLOR_0
`;let r=m.getAttribute(o);r.componentType.isFloatingPoint()?n+=`#define RN_USE_COLOR_0_FLOAT
`:r.componentType.isInteger()?n+=`#define RN_USE_COLOR_0_INT
`:n+=`#define RN_USE_COLOR_0_UINT
`}o.indexOf("JOINTS_0")!==-1&&(n+=`#define RN_USE_JOINTS_0
`),o.indexOf("WEIGHTS_0")!==-1&&(n+=`#define RN_USE_WEIGHTS_0
`),o.indexOf("FACE_NORMAL")!==-1&&(n+=`#define RN_USE_FACE_NORMAL
`),o.indexOf("BARY_CENTRIC_COORD")!==-1&&(n+=`#define RN_USE_BARY_CENTRIC_COORD
`),o.indexOf("TEXCOORD_2")!==-1&&(n+=`#define RN_USE_TEXCOORD_2
`)}return m.targets!=null&&m.targets.length>0&&(n+=`#define RN_IS_MORPHING
`),n+=`#define RN_USE_INSTANCE
`,n}var sp,nT,Sm,zc,cT=C(()=>{"use strict";sp=Hm(_m(),1);tt();Zi();Ke();ft();Ze();ym();Qn();ge();nT=sp.default.default||sp.default,Sm=class Sm{static _createShaderProgramWithCache(n,t,o,r,i,a,s){let l=XQ(o+r),c=this.__shaderStringMap.get(l);return c?[c,!1]:(c=G.getCgApiResourceRepository().createShaderProgram({material:n,primitive:t,vertexShaderStr:o,fragmentShaderStr:r,attributeNames:i,attributeSemantics:a,onError:s}),this.__shaderStringMap.set(l,c),[c,!0])}};h(Sm,"ShaderHandler"),f(Sm,"__shaderStringMap",new Map);zc=Sm;h(XQ,"__removeCommentsFromShader");h(rT,"_createProgramAsSingleOperationByUpdatedSources");h(iT,"_getAttributeInfo");h(HQ,"_outputVertexAttributeBindingInfo");h(aT,"_createProgramAsSingleOperationWebGL");h(oT,"_setupGlobalShaderDefinitionWebGL");h(sT,"_createProgramAsSingleOperationWebGpu");h(lT,"defineAttributes")});var Vt,oo,el=C(()=>{"use strict";zn();ni();se();ra();ft();Zt();Er();un();Pn();Jh();cT();me();_c();nm();ks();Ws();om();tm();ge();Vt=class Vt extends nt{constructor(t,o,r,i,a){super();f(this,"__materialTypeName");f(this,"_materialContent");f(this,"_allFieldVariables",new Map);f(this,"_autoFieldVariablesOnly",new Map);f(this,"_allFieldsInfo",new Map);f(this,"__belongPrimitives",new Map);f(this,"_shaderProgramUidMap",new Map);f(this,"__materialUid",-1);f(this,"__materialTid");f(this,"__materialSid",-1);f(this,"__alphaMode",Tt.Opaque);f(this,"zWriteWhenBlend",!1);f(this,"colorWriteMask",[!0,!0,!0,!0]);f(this,"isTranslucent",!1);f(this,"cullFace",!0);f(this,"cullFrontFaceCCW",!0);f(this,"cullFaceBack",!0);f(this,"__alphaToCoverage",!1);f(this,"__blendEquationMode",yn.EquationFuncAdd);f(this,"__blendEquationModeAlpha",yn.EquationFuncAdd);f(this,"__blendFuncSrcFactor",yn.One);f(this,"__blendFuncDstFactor",yn.OneMinusSrcAlpha);f(this,"__blendFuncAlphaSrcFactor",yn.One);f(this,"__blendFuncAlphaDstFactor",yn.OneMinusSrcAlpha);f(this,"__stateVersion",0);f(this,"__fingerPrint","");f(this,"__shaderDefines",new Set);this._materialContent=a,this.__materialTid=t,this.__materialUid=o,this.__materialSid=r,this.__materialTypeName=i}addShaderDefine(t){this.__shaderDefines.add(t),this.makeShadersInvalidate()}removeShaderDefine(t){this.__shaderDefines.delete(t),this.makeShadersInvalidate()}getShaderDefines(){return this.__shaderDefines}calcFingerPrint(){let t="";t+=this.alphaMode.index,t+=this.blendFuncSrcFactor.webgpu,t+=this.blendFuncDstFactor.webgpu,t+=this.blendFuncAlphaSrcFactor.webgpu,t+=this.blendFuncAlphaDstFactor.webgpu,t+=this.blendEquationMode.webgpu,t+=this.blendEquationModeAlpha.webgpu,t+=this.cullFace?"1":"0",t+=this.cullFrontFaceCCW?"1":"0",t+=this.cullFaceBack?"1":"0",this.__fingerPrint=t}_getFingerPrint(){return this.__fingerPrint}static get stateVersion(){return Vt.__stateVersion}_isAnimatedValue(t){return t instanceof ur||t instanceof zr||t instanceof $n||t instanceof Gr||t instanceof Ir||t instanceof Si}setParameter(t,o){let r=this._allFieldsInfo.get(t);if(r!=null){let i;r.soloDatum?i=Vt._soloDatumFields.get(this.__materialTypeName).get(t):i=this._allFieldVariables.get(t),this._isAnimatedValue(o)?(o.setFloat32Array(i.value._v),i.value=o,this.__stateVersion++,Vt.__stateVersion++,this.calcFingerPrint()):En._setForce(i.value,o)&&(this.__stateVersion++,Vt.__stateVersion++,this.calcFingerPrint())}}setTextureParameter(t,o,r){if(A.not.exist(r)&&(r=Vt.__defaultSampler),r.created||r.create(),this._allFieldsInfo.has(t)){let i=h(async()=>{typeof o.loadFromUrlLazy!="undefined"&&(await o.loadFromUrlLazy(),await o.loadFromImgLazy());let a=this._allFieldVariables.get(t),s={value:[a.value[0],o,r],info:a.info};this._allFieldVariables.set(t,s),a.info.isInternalSetting||this._autoFieldVariablesOnly.set(t,s),(t==="diffuseColorTexture"||t==="baseColorTexture")&&o.isTransparent&&(this.alphaMode=Tt.Blend),this.__stateVersion++,Vt.__stateVersion++,this.calcFingerPrint()},"setter");typeof o.hasDataToLoadLazy!="undefined"&&o.hasDataToLoadLazy?setTimeout(i,0):i()}}getTextureParameter(t){if(this._allFieldsInfo.has(t))return this._allFieldVariables.get(t).value}setTextureParameterAsPromise(t,o){o.then(r=>{if(this._allFieldsInfo.has(t)){let i=this._allFieldVariables.get(t),a={value:[i.value[0],r],info:i.info};this._allFieldVariables.set(t,a),i.info.isInternalSetting||this._autoFieldVariablesOnly.set(t,a),(t==="diffuseColorTexture"||t==="baseColorTexture")&&r.isTransparent&&(this.alphaMode=Tt.Blend)}this.__stateVersion++,Vt.__stateVersion++,this.calcFingerPrint()})}getParameter(t){var r,i;let o=this._allFieldsInfo.get(t);if(o!=null)return o.soloDatum?(r=Vt._soloDatumFields.get(this.__materialTypeName).get(t))==null?void 0:r.value:(i=this._allFieldVariables.get(t))==null?void 0:i.value}isShaderProgramReady(t){return this._shaderProgramUidMap.has(t._getFingerPrint())}_setUniformLocationsOfMaterialNodes(t,o){let r=G.getWebGLResourceRepository(),i=[];if(this._materialContent!=null){let s=this._materialContent._semanticsInfoArray;i=i.concat(s)}let a=this._shaderProgramUidMap.get(o._getFingerPrint());r.setupUniformLocations(a,i,t)}getShaderProgramUid(t){var r;let o=t._getFingerPrint();return(r=this._shaderProgramUidMap.get(o))!=null?r:-1}_addBelongPrimitive(t){this.__belongPrimitives.set(t.primitiveUid,t)}getBelongPrimitives(){return this.__belongPrimitives}_createProgramWebGL(t,o,r,i){let{vertexPropertiesStr:a,pixelPropertiesStr:s}=this._getProperties(o,i),[l,c]=aT(this,r,a,s,t,i);return this._shaderProgramUidMap.set(r._getFingerPrint(),l),Vt.__stateVersion++,[l,c]}_createProgramWebGpu(t,o,r){let{vertexPropertiesStr:i,pixelPropertiesStr:a}=this._getProperties(r,!0),s=sT(this,t,o,i,a);this._shaderProgramUidMap.set(t._getFingerPrint(),s),Vt.__stateVersion++}_createProgramByUpdatedSources(t,o,r){let[i,a]=rT(this,o,this._materialContent,t,r);return this._shaderProgramUidMap.set(o._getFingerPrint(),i),i>0,Vt.__stateVersion++,[i,a]}_setupBasicUniformsLocations(t){let o=G.getWebGLResourceRepository(),r=t._getFingerPrint(),i=this._shaderProgramUidMap.get(r);o.setupBasicUniformLocations(i)}_setupAdditionalUniformLocations(t,o,r){let i=G.getWebGLResourceRepository(),a=r._getFingerPrint(),s=this._shaderProgramUidMap.get(a);i.setupUniformLocations(s,t,o)}_setInternalSettingParametersToGpuWebGpu({material:t,args:o}){this._materialContent._setInternalSettingParametersToGpuWebGpu({material:t,args:o})}_setParametersToGpuWebGL({material:t,shaderProgram:o,firstTime:r,args:i}){this.__setAutoParametersToGpuWebGL(i.setUniform,r,o),this._materialContent._setInternalSettingParametersToGpuWebGL({material:t,shaderProgram:o,firstTime:r,args:i}),this.__setSoloDatumParametersToGpuWebGL({shaderProgram:o,firstTime:r,isUniformMode:i.setUniform})}_setParametersToGpuWebGLPerPrimitive({material:t,shaderProgram:o,firstTime:r,args:i}){this._materialContent._setInternalSettingParametersToGpuWebGLPerPrimitive({material:t,shaderProgram:o,firstTime:r,args:i})}_setParametersToGpuWebGLWithOutInternalSetting({shaderProgram:t,firstTime:o,isUniformMode:r}){this.__setAutoParametersToGpuWebGL(r,o,t),this.__setSoloDatumParametersToGpuWebGL({shaderProgram:t,firstTime:o,isUniformMode:r})}_getProperties(t,o){let r="",i="";return this._allFieldsInfo.forEach(s=>{(s.stage===D.VertexShader||s.stage===D.VertexAndPixelShader)&&(r+=t(this.__materialTypeName,s,!1,o)),(s.stage===D.PixelShader||s.stage===D.VertexAndPixelShader)&&(i+=t(this.__materialTypeName,s,!1,o))}),[r,i]=gt.getInstance()._addPropertiesStr(r,i,t,o),{vertexPropertiesStr:r,pixelPropertiesStr:i}}__setAutoParametersToGpuWebGL(t,o,r){Vt.__webglResourceRepository==null&&(Vt.__webglResourceRepository=G.getWebGLResourceRepository());let i=Vt.__webglResourceRepository;if(t)this._autoFieldVariablesOnly.forEach(a=>{let s=a.info;i.setUniformValue(r,s.semantic,o,a.value)});else for(let[a,s]of this._autoFieldVariablesOnly){let l=s.info;b.isTexture(l.compositionType)?o?i.setUniform1iForTexture(r,l.semantic,s.value):i.bindTexture(l,s.value):l.needUniformInDataTextureMode&&i.setUniformValue(r,l.semantic,o,s.value)}}__setSoloDatumParametersToGpuWebGL({shaderProgram:t,firstTime:o,isUniformMode:r}){let i=G.getWebGLResourceRepository(),a=this.__materialTypeName,s=Vt._soloDatumFields.get(a);if(s==null)return;let l=s.values();for(let c of l){let u=c.info;(r||b.isTexture(u.compositionType))&&(u.isInternalSetting||(o?i.setUniformValue(t,u.semantic,o,c.value):i.bindTexture(u,c.value)))}}setBlendEquationMode(t,o){this.__blendEquationMode=t,this.__blendEquationModeAlpha=o!=null?o:t,this.__treatForMinMax(),this.__stateVersion++,Vt.__stateVersion++,this.calcFingerPrint()}__treatForMinMax(){(this.__blendEquationMode===yn.Min||this.__blendEquationMode===yn.Max)&&(this.__blendFuncDstFactor=yn.One,this.__blendFuncSrcFactor=yn.One),(this.__blendEquationModeAlpha===yn.Min||this.__blendEquationModeAlpha===yn.Max)&&(this.__blendFuncAlphaDstFactor=yn.One,this.__blendFuncAlphaSrcFactor=yn.One)}setBlendFuncSeparateFactor(t,o,r,i){this.__blendFuncSrcFactor=t,this.__blendFuncDstFactor=o,this.__blendFuncAlphaSrcFactor=r,this.__blendFuncAlphaDstFactor=i,this.__treatForMinMax(),this.__stateVersion++,Vt.__stateVersion++,this.calcFingerPrint()}setBlendFuncFactor(t,o){this.__blendFuncSrcFactor=t,this.__blendFuncDstFactor=o,this.__blendFuncAlphaSrcFactor=t,this.__blendFuncAlphaDstFactor=o,this.__treatForMinMax(),this.__stateVersion++,Vt.__stateVersion++,this.calcFingerPrint()}isBlend(){return this.alphaMode===Tt.Blend}isTranslucentOpaque(){return!!(this.alphaMode!==Tt.Blend&&this.isTranslucent)}isBlendOrTranslucent(){return!!(this.alphaMode===Tt.Blend||this.isTranslucent)}isOpaque(){return this.alphaMode===Tt.Opaque}isMask(){return this.alphaMode===Tt.Mask}set alphaToCoverage(t){t&&this.alphaMode===Tt.Blend&&N.warn("If you set alphaToCoverage = true on a material whose AlphaMode is Translucent, you may get drawing problems."),this.__alphaToCoverage=t,this.makeShadersInvalidate(),this.calcFingerPrint()}get alphaToCoverage(){return this.__alphaToCoverage}get materialTID(){return this.__materialTid}get fieldsInfoArray(){return Array.from(this._allFieldsInfo.values())}get blendEquationMode(){return this.__blendEquationMode}get blendEquationModeAlpha(){return this.__blendEquationModeAlpha}get blendFuncSrcFactor(){return this.__blendFuncSrcFactor}get blendFuncDstFactor(){return this.__blendFuncDstFactor}get blendFuncAlphaSrcFactor(){return this.__blendFuncAlphaSrcFactor}get blendFuncAlphaDstFactor(){return this.__blendFuncAlphaDstFactor}get alphaMode(){return this.__alphaMode}set alphaMode(t){this.__alphaMode=t,this.makeShadersInvalidate()}get materialUID(){return this.__materialUid}get materialSID(){return this.__materialSid}get isSkinning(){return this._materialContent.isSkinning}get isMorphing(){return this._materialContent.isMorphing}get isLighting(){return this._materialContent.isLighting}get materialTypeName(){return this.__materialTypeName}get stateVersion(){return this.__stateVersion}makeShadersInvalidate(){this._shaderProgramUidMap.clear(),this.__stateVersion++,Vt.__stateVersion++}};h(Vt,"Material"),f(Vt,"__stateVersion",0),f(Vt,"__webglResourceRepository"),f(Vt,"__defaultSampler",new Ge({magFilter:U.Linear,minFilter:U.Linear,wrapS:U.Repeat,wrapT:U.Repeat})),f(Vt,"_soloDatumFields",new Map);oo=Vt});var Je,Mn,tl=C(()=>{"use strict";tt();jo();cr();xe();se();Zu();ra();ge();me();el();Je=class Je{static registerMaterial(n,t,o=F.maxMaterialInstanceForEachType){return Je.__materialNodes.has(n)?!1:(Je.__registerInner(n,t,o),!0)}static forceRegisterMaterial(n,t,o=F.maxMaterialInstanceForEachType){return this.__registerInner(n,t,o),!0}static isRegisteredMaterialType(n){return Je.__materialNodes.has(n)}static getMaterialByMaterialUid(n){var t;return(t=this.__materialMap.get(n))==null?void 0:t.deref()}static getAllMaterials(){return Array.from(Je.__materialMap.values())}static createMaterial(n,t){let o=Je.__materialInstanceCountOfType.get(n),r=new oo(Je.__materialTids.get(n),++Je.__materialUidCount,o++,n,t);return this.__initializeMaterial(r,o),r}static isFullOrOverOfThisMaterialType(n){let t=Je.__materialInstanceCountOfType.get(n);if(A.not.exist(t))return!1;let o=Je.__maxInstances.get(n);return A.not.exist(o)?!1:t>=o}static isMaterialCompatible(n,t){var a;let o=(a=Je.__materialMap.get(n.materialUID))==null?void 0:a.deref();if(A.not.exist(o))return!1;let r=Array.from(o._allFieldsInfo.values()),i=t._semanticsInfoArray;return JSON.stringify(r)===JSON.stringify(i)}static __initializeMaterial(n,t){n.tryToSetUniqueName(n.__materialTypeName,!0);{Je.__materialMap.set(n.materialUID,new WeakRef(n));let o=Je.__instances.get(n.__materialTypeName);A.not.exist(o)&&(o=new Map,Je.__instances.set(n.materialTypeName,o)),o.set(n.materialSID,new WeakRef(n)),Je.__materialInstanceCountOfType.set(n.materialTypeName,t)}if(A.exist(n._materialContent)){let o=n._materialContent._semanticsInfoArray,r=Je.__accessors.get(n.materialTypeName);o.forEach(i=>{if(n._allFieldsInfo.set(i.semantic,i),!i.soloDatum){let s=r.get(i.semantic).takeOne(),l={info:i,value:En.initWithFloat32Array(i.initialValue,i.initialValue,s,i.compositionType)};n._allFieldVariables.set(i.semantic,l),i.isInternalSetting||n._autoFieldVariablesOnly.set(i.semantic,l)}})}}static getLocationOffsetOfMemberOfMaterial(n,t){let o=Je.__instances.get(n),r=Array.from(o.values()).find(s=>s.deref()!==void 0);if(A.not.exist(r==null?void 0:r.deref()))return N.warn(`Material is not found. getLocationOffsetOfMemberOfMaterial returns invalid 0 value. materialTypeName: ${n}`),0;let i=r.deref();return i._allFieldsInfo.get(t).soloDatum?oo._soloDatumFields.get(i.materialTypeName).get(t).value._v.byteOffset/4/4:this.__accessors.get(n).get(t).byteOffsetInBuffer/4/4}static __registerInner(n,t,o){let r=++Je.__materialTidCount;Je.__materialNodes.set(n,t),Je.__materialTids.set(n,r),Je.__maxInstances.set(n,o),Je.__allocateBufferView(n,t),Je.__materialInstanceCountOfType.set(n,0)}static __allocateBufferView(n,t){let o=0,r=[];for(let s of t._semanticsInfoArray){let l=Kl(s),c=1;s.soloDatum||(c=Je.__maxInstances.get(n)),o+=l*c,r.push({alignedByte:l,semanticInfo:s})}this.__accessors.has(n)||this.__accessors.set(n,new Map);let i=we.getInstance().createOrGetBuffer(Ce.GPUInstanceData),a;this.__bufferViews.has(n)?a=this.__bufferViews.get(n):(a=i.takeBufferView({byteLengthToNeed:o,byteStride:0}).unwrapForce(),this.__bufferViews.set(n,a));for(let s=0;s<r.length;s++){let l=r[s].alignedByte,c=r[s].semanticInfo,u=1;c.soloDatum||(u=Je.__maxInstances.get(n));let _=c.arrayLength;b.isArray(c.compositionType)&&_==null&&(_=100);let d=a.takeAccessor({compositionType:c.compositionType,componentType:I.Float,count:u,byteStride:l,arrayLength:_}).unwrapForce();if(c.soloDatum){let p=d.takeOne(),x=oo._soloDatumFields.get(n);x==null&&(x=new Map,oo._soloDatumFields.set(n,x)),x.set(c.semantic,{info:c,value:En.initWithFloat32Array(c.initialValue,c.initialValue,p,c.compositionType)})}else this.__accessors.get(n).set(c.semantic,d)}return a}static _makeShaderInvalidateToAllMaterials(){var n;for(let t of Je.__materialMap.values())(n=t.deref())==null||n.makeShadersInvalidate()}};h(Je,"MaterialRepository"),f(Je,"__materialMap",new Map),f(Je,"__instances",new Map),f(Je,"__materialTids",new Map),f(Je,"__materialInstanceCountOfType",new Map),f(Je,"__materialNodes",new Map),f(Je,"__maxInstances",new Map),f(Je,"__bufferViews",new Map),f(Je,"__accessors",new Map),f(Je,"__materialTidCount",-1),f(Je,"__materialUidCount",-1);Mn=Je});var uT,fT=C(()=>{uT={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec4 a_instanceInfo;
in vec3 a_position;
in vec2 a_texcoord_0;
out vec2 v_texcoord_0;

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

void main(){
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif

float x = float((gl_VertexID & 1) << 2);
float y = float((gl_VertexID & 2) << 1);
v_texcoord_0.x = x * 0.5;
v_texcoord_0.y = y * 0.5;
gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);

}
`,shaderStage:"vertex",isFragmentShader:!1}});var _T,mT=C(()=>{_T={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{renderTargetBegin} */


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

in vec2 v_texcoord_0;


void main ()
{
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  vec2 offset = gl_FragCoord.st;
  ivec2 vrState = get_vrState(0.0, 0);
  vec2 framebufferSize = get_framebufferSize(materialSID, 0);
  vec2 blurDirection;
  bool isHorizontal = get_isHorizontal(materialSID, 0);
  if (isHorizontal) {
    blurDirection = vec2(1.0, 0.0);
  } else { // vertical
    blurDirection = vec2(0.0, 1.0);
  }
	vec2 tFrag = 1.0 / framebufferSize;

  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
  int gaussianKernelSize = get_gaussianKernelSize(materialSID, 0);
  float minStrideLength = -float(gaussianKernelSize - 1) / 2.0;

  for(int i = 0; i < gaussianKernelSize; i++) {
    float strideLength = minStrideLength + float(i);
    vec2 stride = strideLength * blurDirection;
    float gaussianRatio = get_gaussianRatio(materialSID, i);
    vec2 uv = (offset + stride) * tFrag;
    if (vrState.x == 1 && isHorizontal) { // if in VR mode and horizontal blur
      if (gl_FragCoord.x < framebufferSize.x / 2.0) { // left eye
        uv.x = min(uv.x, 0.5);
      } else { // right eye
        uv.x = max(uv.x, 0.5);
      }
    }
    color += texture(u_baseColorTexture, uv) * gaussianRatio;
  }

  rt0 = color;

/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var hT,dT=C(()=>{hT={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

@vertex
fn main(
  @builtin(vertex_index) vertexIdx : u32,
) -> VertexOutput {
  var output : VertexOutput;
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


let x = f32((vertexIdx & 1u) << 2u);
let y = f32((vertexIdx & 2u) << 1u);
output.texcoord_0.x = x * 0.5;
output.texcoord_0.y = y * 0.5;
output.texcoord_0.y = 1.0 - output.texcoord_0.y;
output.position = vec4f(x - 1.0, y - 1.0, 0, 1);


  return output;

}
`,shaderStage:"vertex",isFragmentShader:!1}});var xT,pT=C(()=>{xT={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */

@fragment
fn main(
  input: VertexOutput,
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  let offset = input.position.xy;

  let framebufferSize: vec2f = get_framebufferSize(materialSID, 0);
  var blurDirection: vec2f;
  let isHorizontal: bool = get_isHorizontal(materialSID, 0);
  if (isHorizontal) {
    blurDirection = vec2f(1.0, 0.0);
  } else { // vertical
    blurDirection = vec2f(0.0, 1.0);
  }
	let tFrag: vec2f = 1.0 / framebufferSize;

  var color = vec4f(0.0, 0.0, 0.0, 0.0);
  let gaussianKernelSize: i32 = get_gaussianKernelSize(materialSID, 0);
  let minStrideLength = - f32(gaussianKernelSize - 1) / 2.0;

  for (var i=0u; i < u32(gaussianKernelSize); i++) {

    let strideLength = minStrideLength + f32(i);
    let stride: vec2f = strideLength * blurDirection;

    let gaussianRatio = get_gaussianRatio(materialSID, i);
    var uv = (offset + stride) * tFrag;
    // uv.y = 1.0 - uv.y;
    color += textureSampleLevel(baseColorTexture, baseColorSampler, uv, 0.0) * gaussianRatio;
  }

  return color;
}
`,shaderStage:"fragment",isFragmentShader:!0}});var gT,vT=C(()=>{gT={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec4 a_instanceInfo;
in vec3 a_position;
in vec2 a_texcoord_0;
out vec2 v_texcoord_0;
precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

void main(){
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif

float x = float((gl_VertexID & 1) << 2);
float y = float((gl_VertexID & 2) << 1);
v_texcoord_0.x = x * 0.5;
v_texcoord_0.y = y * 0.5;
gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);

}
`,shaderStage:"vertex",isFragmentShader:!1}});var bT,yT=C(()=>{bT={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{renderTargetBegin} */


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

float decodeRGBAToDepth(vec4 RGBA){
  const float rMask = 1.0;
  const float gMask = 1.0 / 255.0;
  const float bMask = 1.0 / (255.0 * 255.0);
  const float aMask = 1.0 / (255.0 * 255.0 * 255.0);
  float depth = dot(RGBA, vec4(rMask, gMask, bMask, aMask));
  return depth;
}

vec4 encodeDepthToRGBA(float depth){
  float r = depth;
  float g = fract(r * 255.0);
  float b = fract(g * 255.0);
  float a = fract(b * 255.0);
  float coef = 1.0 / 255.0;
  r -= g * coef;
  g -= b * coef;
  b -= a * coef;
  return vec4(r, g, b, a);
}

void main ()
{
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  float framebufferSize;
  vec2 offset = gl_FragCoord.st;

  vec2 blurDirection;
  bool isHorizontal = get_isHorizontal(materialSID, 0);
  if(isHorizontal){
    framebufferSize = get_framebufferSize(materialSID, 0).x;
    blurDirection = vec2(1.0,0.0);
  }else{
    framebufferSize = get_framebufferSize(materialSID, 0).y;
    blurDirection = vec2(0.0,1.0);
  }
	float tFrag = 1.0 / framebufferSize;

  float depth = 0.0;
  int gaussianKernelSize = get_gaussianKernelSize(materialSID, 0);
  float minStrideLength = -float(gaussianKernelSize - 1) / 2.0;

  for(int i=0; i < 30; i++) {
    if(gaussianKernelSize == i) {
      break;
    }

    float strideLength = minStrideLength + float(i);
    vec2 stride = strideLength * blurDirection;
    float depthData = decodeRGBAToDepth(texture(u_baseColorTexture, (offset + stride) * tFrag));
    if(depthData > 1.0) depthData = 1.0;

    float gaussianRatio = u_gaussianRatio[i];
    depth +=  depthData * gaussianRatio;
  }

  rt0 = encodeDepthToRGBA(depth);

/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var IT,AT=C(()=>{IT={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec3 a_position;
out vec2 v_texcoord_0;

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

void main()
{
  
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif

float x = float((gl_VertexID & 1) << 2);
float y = float((gl_VertexID & 2) << 1);
v_texcoord_0.x = x * 0.5;
v_texcoord_0.y = y * 0.5;
gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);

  
}

`,shaderStage:"vertex",isFragmentShader:!1}});var TT,ST=C(()=>{TT={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec2 v_texcoord_0;

uniform sampler2D u_baseColorTexture; // initialValue=(0,white)
uniform int u_cubeMapFaceId; // initialValue=0

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

vec2 dirToPanoramaUV(vec3 dir)
{
	return vec2(
		0.5f + 0.5f * atan(dir.z, dir.x) / PI,
		1.f - acos(dir.y) / PI);
}

vec3 uvToDirection(int faceId, vec2 uv)
{
	if(faceId == 0)
		return vec3(1.f, uv.y, -uv.x);
	else if(faceId == 1)
		return vec3(-1.f, uv.y, uv.x);
	else if(faceId == 2)
		return vec3(+uv.x, -1.f, +uv.y);
	else if(faceId == 3)
		return vec3(+uv.x, 1.f, -uv.y);
	else if(faceId == 4)
		return vec3(+uv.x, uv.y, 1.f);
	else
    return vec3(-uv.x, +uv.y, -1.f);
}

// learned a lot from https://github.com/KhronosGroup/glTF-Sample-Viewer
void main ()
{
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


	vec2 uv = v_texcoord_0 * 2.0 - 1.0;
	vec3 direction = normalize(uvToDirection(get_cubeMapFaceId(materialSID, 0), uv));
	vec2 panoramaUv = dirToPanoramaUV(direction);
	rt0 = vec4(texture(u_baseColorTexture, panoramaUv).rgb, 1.0);

/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var CT,ET=C(()=>{CT={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

@vertex
fn main(
  @builtin(vertex_index) vertexIdx : u32,
) -> VertexOutput {
  var output : VertexOutput;
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


let x = f32((vertexIdx & 1u) << 2u);
let y = f32((vertexIdx & 2u) << 1u);
output.texcoord_0.x = x * 0.5;
output.texcoord_0.y = y * 0.5;
output.texcoord_0.y = 1.0 - output.texcoord_0.y;
output.position = vec4f(x - 1.0, y - 1.0, 0, 1);


  return output;

}

`,shaderStage:"vertex",isFragmentShader:!1}});var RT,wT=C(()=>{RT={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */

@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(0) var baseColorSampler: sampler;

// #param cubeMapFaceId: i32; // initialValue=0

fn dirToPanoramaUV(dir: vec3f) -> vec2f
{
	return vec2f(
		0.5f + 0.5f * atan2(dir.z, dir.x) / M_PI,
		1.f - acos(dir.y) / M_PI);
}

fn uvToDirection(faceId: i32, uv: vec2f) -> vec3f
{
	if (faceId == 0) {
		return vec3f(1.f, uv.y, -uv.x);
  } else if(faceId == 1) {
		return vec3f(-1.f, uv.y, uv.x);
  } else if(faceId == 2) {
		return vec3f(uv.x, -1.f, uv.y);
  } else if(faceId == 3) {
		return vec3f(uv.x, 1.f, -uv.y);
  } else if(faceId == 4) {
		return vec3f(uv.x, uv.y, 1.f);
  } else {
    return vec3f(-uv.x, uv.y, -1.f);
  }
}

// learned a lot from https://github.com/KhronosGroup/glTF-Sample-Viewer
@fragment
fn main (
  input: VertexOutput,
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


	let uv: vec2f = input.texcoord_0 * 2.0 - 1.0;
	let direction: vec3f = normalize(uvToDirection(get_cubeMapFaceId(materialSID, 0), uv));
  let panoramaUv: vec2f = dirToPanoramaUV(direction);
	let rt0: vec4f = vec4f(textureSampleLevel(baseColorTexture, baseColorSampler, panoramaUv, 0.0).rgb, 1.0);
  return rt0;
}
`,shaderStage:"fragment",isFragmentShader:!0}});var PT,NT=C(()=>{PT={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec3 a_position;
out vec2 v_texcoord_0;

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

void main()
{
  
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif

float x = float((gl_VertexID & 1) << 2);
float y = float((gl_VertexID & 2) << 1);
v_texcoord_0.x = x * 0.5;
v_texcoord_0.y = y * 0.5;
gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);

  
}

`,shaderStage:"vertex",isFragmentShader:!1}});var DT,MT=C(()=>{DT={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec2 v_texcoord_0;

uniform samplerCube u_baseColorTexture; // initialValue=(0,white)
uniform int u_cubeMapFaceId; // initialValue=0
uniform int u_distributionType; // initialValue=0
uniform float u_roughness; // initialValue=0.0
uniform int u_sampleCount; // initialValue=1024

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

const int cLambertian = 0;
const int cGGX = 1;
const int cCharlie = 2;

// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
float radicalInverse_VdC(uint bits)
{
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}

vec2 hammersley2d(int i, int N) {
    return vec2(float(i)/float(N), radicalInverse_VdC(uint(i)));
}

mat3 createTBN(vec3 normal)
{
    vec3 bitangent = vec3(0.0, 1.0, 0.0);
    float NdotUp = dot(normal, vec3(0.0, 1.0, 0.0));
    float epsilon = 0.0000001;
    if (1.0 - abs(NdotUp) <= epsilon)
    {
      bitangent = (NdotUp > 0.0) ? vec3(0.0, 0.0, 1.0) : vec3(0.0, 0.0, -1.0);
    }
    vec3 tangent = normalize(cross(bitangent, normal));
    bitangent = cross(normal, tangent);
    return mat3(tangent, bitangent, normal);
}

vec4 getImportanceSampleLambertian(int sampleIndex, vec3 N, float roughness, float materialSID)
{
    vec2 xi = hammersley2d(sampleIndex, get_sampleCount(materialSID, 0));

    float sinTheta = sqrt(1.0 - xi.y);
    float cosTheta = sqrt(xi.y);
    float phi = 2.0 * PI * xi.x;
    float pdf = cosTheta / PI;

    vec3 localDirection = normalize(vec3(
        sinTheta * cos(phi),
        sinTheta * sin(phi),
        cosTheta
    ));
    vec3 direction = createTBN(N) * localDirection;

    return vec4(direction, pdf);
}

// GGX NDF
float d_GGX(float NH, float alphaRoughness) {
  float roughnessSqr = alphaRoughness * alphaRoughness;
  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (PI * f * f);
}

// We learnd a lot from the following resources
// https://bruop.github.io/ibl/
vec4 getImportanceSampleGGX(int sampleIndex, vec3 N, float roughness, float materialSID)
{
    vec2 xi = hammersley2d(sampleIndex, get_sampleCount(materialSID, 0));

    float alpha = roughness * roughness;
    float cosTheta = clamp(sqrt((1.0 - xi.y) / (1.0 + (alpha * alpha - 1.0) * xi.y)), 0.0, 1.0);
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    float phi = 2.0 * PI * xi.x;
    float pdf = d_GGX(cosTheta, alpha);
    pdf /= 4.0;

    vec3 localDirection = normalize(vec3(
        sinTheta * cos(phi),
        sinTheta * sin(phi),
        cosTheta
    ));
    vec3 direction = createTBN(N) * localDirection;

    return vec4(direction, pdf);
}

float D_Charlie(float sheenRoughness, float NdotH)
{
    sheenRoughness = max(sheenRoughness, 0.000001); //clamp (0,1]
    float invR = 1.0 / sheenRoughness;
    float cos2h = NdotH * NdotH;
    float sin2h = 1.0 - cos2h;
    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);
}

vec4 getImportanceSampleCharlie(int sampleIndex, vec3 N, float roughness, float materialSID)
{
    vec2 xi = hammersley2d(sampleIndex, get_sampleCount(materialSID, 0));

    float alpha = roughness * roughness;
    float sinTheta = pow(xi.y, alpha / (2.0*alpha + 1.0));
    float cosTheta = sqrt(1.0 - sinTheta * sinTheta);
    float phi = 2.0 * PI * xi.x;
    float pdf = D_Charlie(alpha, cosTheta);
    pdf /= 4.0;

    vec3 localDirection = normalize(vec3(
        sinTheta * cos(phi),
        sinTheta * sin(phi),
        cosTheta
    ));
    vec3 direction = createTBN(N) * localDirection;

    return vec4(direction, pdf);
}

// We learnd a lot from the following resources
// https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling
// https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf
// https://google.github.io/filament/Filament.html#annex/importancesamplingfortheibl/pre-filteredimportancesampling
float computeLod(float pdf, int width, int sampleCount)
{
    // 6.0 is the number of faces of the cubemap
    // log4 = 0.5 * log2
    // We don't use the constant K in the filament document
    return 0.5 * log2( 6.0 * float(width) * float(width) / (float(sampleCount) * pdf));
}

vec3 prefilter(vec3 N, float materialSID)
{
    vec3 color = vec3(0.f);
    float weight = 0.0f;
    int sampleCount = get_sampleCount(materialSID, 0);

    ivec2 texSize = textureSize(u_baseColorTexture, 0);

    for(int i = 0; i < get_sampleCount(materialSID, 0); ++i)
    {
        vec4 importanceSample;

        int distributionType = get_distributionType(materialSID, 0);
        if(distributionType == cLambertian) {
            importanceSample = getImportanceSampleLambertian(i, N, get_roughness(materialSID, 0), materialSID);
        } else if(distributionType == cGGX) {
            importanceSample = getImportanceSampleGGX(i, N, get_roughness(materialSID, 0), materialSID);
        } else {
            importanceSample = getImportanceSampleCharlie(i, N, get_roughness(materialSID, 0), materialSID);
        }

        vec3 H = vec3(importanceSample.xyz);
        float pdf = importanceSample.w;
        float lod = computeLod(pdf, texSize.x, sampleCount);

        if(distributionType == cLambertian)
        {
            vec3 lambertian = textureLod(u_baseColorTexture, H, lod).rgb;
            color += lambertian;
        }
        else if(distributionType == cGGX || distributionType == cCharlie)
        {
            vec3 V = N;
            vec3 L = normalize(reflect(-V, H));
            float NdotL = dot(N, L);

            if (NdotL > 0.0)
            {
                vec3 sampleColor = textureLod(u_baseColorTexture, L, lod).rgb;
                color += sampleColor * NdotL;
                weight += NdotL;
            }
        }
    }

    if(weight != 0.0f)
    {
        color /= weight;
    }
    else
    {
        color /= float(sampleCount);
    }

    return color.rgb;
}

vec3 uvToDir(int faceId, vec2 uv)
{
	if(faceId == 0)
		return vec3(1.f, uv.y, -uv.x);
	else if(faceId == 1)
		return vec3(-1.f, uv.y, uv.x);
	else if(faceId == 2)
		return vec3(+uv.x, -1.f, +uv.y);
	else if(faceId == 3)
		return vec3(+uv.x, 1.f, -uv.y);
	else if(faceId == 4)
		return vec3(+uv.x, uv.y, 1.f);
	else
    return vec3(-uv.x, +uv.y, -1.f);
}

// learned a lot from https://github.com/KhronosGroup/glTF-Sample-Viewer
void main ()
{
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  vec2 uv = v_texcoord_0 * 2.0 - 1.0;
  vec3 scan = uvToDir(get_cubeMapFaceId(materialSID, 0), uv);
  vec3 direction = normalize(scan);
  direction.y = -direction.y;

  rt0 = vec4(prefilter(direction, materialSID), 1.0);

/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var FT,BT=C(()=>{FT={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

@vertex
fn main(
  @builtin(vertex_index) vertexIdx : u32,
) -> VertexOutput {
  var output : VertexOutput;
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


let x = f32((vertexIdx & 1u) << 2u);
let y = f32((vertexIdx & 2u) << 1u);
output.texcoord_0.x = x * 0.5;
output.texcoord_0.y = y * 0.5;
output.texcoord_0.y = 1.0 - output.texcoord_0.y;
output.position = vec4f(x - 1.0, y - 1.0, 0, 1);


  return output;

}


`,shaderStage:"vertex",isFragmentShader:!1}});var VT,LT=C(()=>{VT={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */


@group(1) @binding(0) var baseColorTexture: texture_cube<f32>; // initialValue=white
@group(2) @binding(0) var baseColorSampler: sampler;
// #param cubeMapFaceId: i32; // initialValue=0
// #param distributionType: i32; // initialValue=0
// #param roughness: f32; // initialValue=0.0
// #param sampleCount: i32; // initialValue=1024

const cLambertian: i32 = 0;
const cGGX: i32 = 1;
const cCharlie: i32 = 2;
// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
fn radicalInverse_VdC(_bits: u32) -> f32
{
    var bits = (_bits << 16u) | (_bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return f32(bits) * 2.3283064365386963e-10; // / 0x100000000
}

fn hammersley2d(i: i32, N: i32) -> vec2f {
    return vec2f(f32(i)/f32(N), radicalInverse_VdC(u32(i)));
}

fn createTBN(normal: vec3f) -> mat3x3<f32>
{
    var bitangent = vec3f(0.0, 1.0, 0.0);
    let NdotUp = dot(normal, vec3f(0.0, 1.0, 0.0));
    let epsilon = 0.0000001;
    if (1.0 - abs(NdotUp) <= epsilon)
    {
      bitangent = select(vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, 1.0), NdotUp > 0.0);
    }
    let tangent = normalize(cross(bitangent, normal));
    bitangent = cross(normal, tangent);
    return mat3x3<f32>(tangent, bitangent, normal);
}

fn getImportanceSampleLambertian(sampleIndex: i32, N: vec3f, roughness: f32, materialSID: u32) -> vec4f
{
    let xi = hammersley2d(sampleIndex, get_sampleCount(materialSID, 0));

    let sinTheta = sqrt(1.0 - xi.y);
    let cosTheta = sqrt(xi.y);
    let phi = 2.0 * M_PI * xi.x;
    let pdf = cosTheta / M_PI;

    let localDirection = normalize(vec3f(
        sinTheta * cos(phi),
        sinTheta * sin(phi),
        cosTheta
    ));
    let direction = createTBN(N) * localDirection;

    return vec4f(direction, pdf);
}

// GGX NDF
fn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {
  let roughnessSqr = alphaRoughness * alphaRoughness;
  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

// We learnd a lot from the following resources
// https://bruop.github.io/ibl/
fn getImportanceSampleGGX(sampleIndex: i32, N: vec3f, roughness: f32, materialSID: u32) -> vec4f
{
    let xi = hammersley2d(sampleIndex, get_sampleCount(materialSID, 0));

    let alpha = roughness * roughness;
    let cosTheta = clamp(sqrt((1.0 - xi.y) / (1.0 + (alpha * alpha - 1.0) * xi.y)), 0.0, 1.0);
    let sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    let phi = 2.0 * M_PI * xi.x;
    var pdf = d_GGX(cosTheta, alpha);
    pdf /= 4.0;

    let localDirection = normalize(vec3f(
        sinTheta * cos(phi),
        sinTheta * sin(phi),
        cosTheta
    ));
    let direction = createTBN(N) * localDirection;

    return vec4f(direction, pdf);
}

fn D_Charlie(sheenRoughness_: f32, NdotH: f32) -> f32
{
    let sheenRoughness = max(sheenRoughness_, 0.000001); //clamp (0,1]
    let invR = 1.0 / sheenRoughness;
    let cos2h = NdotH * NdotH;
    let sin2h = 1.0 - cos2h;
    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * M_PI);
}

fn getImportanceSampleCharlie(sampleIndex: i32, N: vec3f, roughness: f32, materialSID: u32) -> vec4f
{
  let xi = hammersley2d(sampleIndex, get_sampleCount(materialSID, 0));

  let alpha = roughness * roughness;
  let sinTheta = pow(xi.y, alpha / (2.0*alpha + 1.0));
  let cosTheta = sqrt(1.0 - sinTheta * sinTheta);
  let phi = 2.0 * M_PI * xi.x;
  var pdf = D_Charlie(alpha, cosTheta);
  pdf /= 4.0;

  let localDirection = normalize(vec3f(
      sinTheta * cos(phi),
      sinTheta * sin(phi),
      cosTheta
  ));
  let direction = createTBN(N) * localDirection;

  return vec4f(direction, pdf);
}

// We learnd a lot from the following resources
// https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling
// https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf
// https://google.github.io/filament/Filament.html#annex/importancesamplingfortheibl/pre-filteredimportancesampling
fn computeLod(pdf: f32, width: u32, sampleCount: i32) -> f32
{
    // 6.0 is the number of faces of the cubemap
    // log4 = 0.5 * log2
    // We don't use the constant K in the filament document
    return 0.5 * log2( 6.0 * f32(width) * f32(width) / (f32(sampleCount) * pdf));
}

fn prefilter(N: vec3f, materialSID: u32) -> vec3f
{
    var color = vec3f(0.f);
    var weight = 0.0f;
    let sampleCount = get_sampleCount(materialSID, 0);

    let texSize: vec2<u32> = textureDimensions(baseColorTexture, 0);

    for(var i = 0; i < get_sampleCount(materialSID, 0); i++)
    {
        var importanceSample: vec4<f32>;

        let distributionType = get_distributionType(materialSID, 0);
        if(distributionType == cLambertian) {
            importanceSample = getImportanceSampleLambertian(i, N, get_roughness(materialSID, 0), materialSID);
        } else if(distributionType == cGGX) {
            importanceSample = getImportanceSampleGGX(i, N, get_roughness(materialSID, 0), materialSID);
        } else {
            importanceSample = getImportanceSampleCharlie(i, N, get_roughness(materialSID, 0), materialSID);
        }

        let H = vec3f(importanceSample.xyz);
        let pdf = importanceSample.w;
        let lod = computeLod(pdf, texSize.x, sampleCount);

        if(distributionType == cLambertian)
        {
            let lambertian = textureSampleLevel(baseColorTexture, baseColorSampler, H, lod).rgb;
            color += lambertian;
        }
        else if(distributionType == cGGX || distributionType == cCharlie)
        {
            let V = N;
            let L = normalize(reflect(-V, H));
            let NdotL = dot(N, L);

            if (NdotL > 0.0)
            {
                let sampleColor = textureSampleLevel(baseColorTexture, baseColorSampler, L, lod).rgb;
                color += sampleColor * NdotL;
                weight += NdotL;
            }
        }
    }

    if(weight != 0.0f)
    {
        color /= weight;
    }
    else
    {
        color /= f32(sampleCount);
    }

    return color.rgb;
}

fn uvToDir(faceId: i32, uv: vec2f) -> vec3f
{
	if (faceId == 0) {
		return vec3f(1.f, uv.y, -uv.x);
  } else if(faceId == 1) {
		return vec3f(-1.f, uv.y, uv.x);
  } else if(faceId == 2) {
		return vec3f(uv.x, -1.f, uv.y);
  } else if(faceId == 3) {
		return vec3f(uv.x, 1.f, -uv.y);
  } else if(faceId == 4) {
		return vec3f(uv.x, uv.y, 1.f);
  } else {
    return vec3f(-uv.x, uv.y, -1.f);
  }
}

// learned a lot from https://github.com/KhronosGroup/glTF-Sample-Viewer
@fragment
fn main (
  input: VertexOutput,
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  let uv = input.texcoord_0 * 2.0 - 1.0;
  let scan = uvToDir(get_cubeMapFaceId(materialSID, 0), uv);
  var direction = normalize(scan);
  direction.y = -direction.y;

  let rt0 = vec4f(prefilter(direction, materialSID), 1.0);

  return rt0;
}
`,shaderStage:"fragment",isFragmentShader:!0}});var GT,zT=C(()=>{GT={code:`
#ifdef WEBGL2_MULTI_VIEW
#extension GL_OVR_multiview2 : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

in vec4 a_instanceInfo;
in vec2 a_texcoord_0;
in vec2 a_texcoord_1;
in vec2 a_texcoord_2;
in vec3 a_position;
in vec3 a_normal;
in vec4 a_baryCentricCoord;
in vec4 a_joint;
in vec4 a_weight;

out vec2 v_texcoord_0;
out vec2 v_texcoord_1;
out vec2 v_texcoord_2;
out vec3 v_baryCentricCoord;
out vec3 v_normal_inView;
out vec3 v_normal_inWorld;
out vec4 v_position_inWorld;
out float v_instanceInfo;

#ifdef RN_USE_TANGENT
in vec4 a_tangent;
out vec3 v_tangent_inWorld;
out vec3 v_binormal_inWorld; // bitangent_inWorld
#endif

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


/* shaderity: @{getters} */

/* shaderity: @{matricesGetters} */

mat3 toNormalMatrix(mat4 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];

  float b00 = a00 * a11 - a01 * a10,
  b01 = a00 * a12 - a02 * a10,
  b02 = a00 * a13 - a03 * a10,
  b03 = a01 * a12 - a02 * a11,
  b04 = a01 * a13 - a03 * a11,
  b05 = a02 * a13 - a03 * a12,
  b06 = a20 * a31 - a21 * a30,
  b07 = a20 * a32 - a22 * a30,
  b08 = a20 * a33 - a23 * a30,
  b09 = a21 * a32 - a22 * a31,
  b10 = a21 * a33 - a23 * a31,
  b11 = a22 * a33 - a23 * a32;

  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3(
    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,
    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,
    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;
}



#ifdef RN_IS_SKINNING

highp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {
  highp vec4 q = quaternion;
  highp vec3 t = translation;

  highp float sx = q.x * q.x;
  highp float sy = q.y * q.y;
  highp float sz = q.z * q.z;
  highp float cx = q.y * q.z;
  highp float cy = q.x * q.z;
  highp float cz = q.x * q.y;
  highp float wx = q.w * q.x;
  highp float wy = q.w * q.y;
  highp float wz = q.w * q.z;

  highp mat4 mat = mat4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  highp mat4 uniformScaleMat = mat4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return mat*uniformScaleMat;
}

highp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){

  highp float r;
  highp float g;
  highp float b;
  highp float a;

  highp float ix = floor(vec_xy.x * criteria);
  highp float v1x = ix / criteria;
  highp float v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  highp float iy = floor( vec_xy.y * criteria);
  highp float v2x = iy / criteria;
  highp float v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4(r, g, b, a);
}

mat4 getSkinMatrix(float skeletalComponentSID) {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));
  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));
  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));
  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  vec2 criteria = vec2(4096.0, 4096.0);

  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));
  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));
  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));
  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));
  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));
  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));
  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));
  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));

  vec2 criteria = vec2(4096.0, 4096.0);
  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif



#ifdef RN_IS_SKINNING
bool skinning(
  float skeletalComponentSID,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
  )
{
  mat4 skinMat = getSkinMatrix(skeletalComponentSID);
  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);
  outNormalMatrix = toNormalMatrix(skinMat);
  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);

  return true;
}
#endif

bool processGeometryWithMorphingAndSkinning(
  float skeletalComponentSID,
  in mat4 worldMatrix,
  in mat4 viewMatrix,
  in bool isBillboard,
  in mat3 inNormalMatrix,
  out mat3 outNormalMatrix,
  in vec3 inPosition_inLocal,
  out vec4 outPosition_inWorld,
  in vec3 inNormal_inLocal,
  out vec3 outNormal_inWorld
) {
  bool isSkinning = false;

  vec3 position_inLocal;
#ifdef RN_IS_MORPHING
  if (u_morphTargetNumber == 0) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    float vertexIdx = a_baryCentricCoord.w;
    position_inLocal = get_position(vertexIdx, inPosition_inLocal);
  }
#endif

  mat4 worldMatrixInner = worldMatrix;
  if (isBillboard) {
    mat4 inverseViewMatrix = inverse(viewMatrix);
    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];
    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];
    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];
    worldMatrixInner = inverseViewMatrix * worldMatrix;
  }

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0.0) {
    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);
  } else {
#endif
    outNormalMatrix = inNormalMatrix;
    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
#ifdef RN_IS_SKINNING
  }
#endif

  return isSkinning;
}


uniform int u_outlineWidthMode; // initialValue=0
uniform float u_outlineWidthFactor; // initialValue=0.0008
uniform sampler2D u_outlineWidthMultiplyTexture; // initialValue=(0,white)

void main(){

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);
  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);
  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);
  bool isSkinning = false;
  isSkinning = processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    worldMatrix,
    viewMatrix,
    false,
    normalMatrix,
    normalMatrix,
    a_position,
    v_position_inWorld,
    a_normal,
    v_normal_inWorld
  );

  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);

  v_normal_inView = vec3(viewMatrix * vec4(v_normal_inWorld, 0.0));

#ifdef RN_MTOON_IS_OUTLINE
  int outlineWidthType = get_outlineWidthMode(materialSID, 0);
  if (outlineWidthType == 0) { // 0 ("none")
    gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;
  } else {
    float worldNormalLength = length(normalMatrix * a_normal);
    float outlineWidthFactor = get_outlineWidthFactor(materialSID, 0);
    vec3 outlineOffset = outlineWidthFactor * worldNormalLength * v_normal_inWorld;

    float outlineWidthMultiply = texture(u_outlineWidthMultiplyTexture, a_texcoord_0).g;
    outlineOffset *= outlineWidthMultiply;

    if (outlineWidthType == 2) { // "screenCoordinates"
      vec4 vViewPosition = viewMatrix * v_position_inWorld;
      outlineOffset *= abs(vViewPosition.z) / projectionMatrix[1].y;
    }
    gl_Position = projectionMatrix * viewMatrix * vec4(v_position_inWorld.xyz + outlineOffset, 1.0);
    gl_Position.z += 0.000001 * gl_Position.w;
  }
#else
  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;
#endif

#ifdef RN_USE_TANGENT
  v_tangent_inWorld = normalMatrix * a_tangent.xyz;
  v_binormal_inWorld = cross(v_normal_inWorld, v_tangent_inWorld) * a_tangent.w;
#endif

  v_texcoord_0 = a_texcoord_0;
  v_texcoord_1 = a_texcoord_1;
  v_texcoord_2 = a_texcoord_2;
  v_baryCentricCoord = a_baryCentricCoord.xyz;
  v_instanceInfo = a_instanceInfo.x;
}
`,shaderStage:"vertex",isFragmentShader:!1}});var UT,OT=C(()=>{UT={code:`
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

precision highp sampler2DArray;

const float Epsilon = 0.0000001;
#define saturate(x) clamp(x, 0.0, 1.0)
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}


in vec2 v_texcoord_0;
in vec2 v_texcoord_1;
in vec2 v_texcoord_2;
in vec3 v_baryCentricCoord;
in vec3 v_normal_inView;
in vec3 v_normal_inWorld;
in vec4 v_position_inWorld;
in float v_instanceInfo;
#ifdef RN_USE_TANGENT
  in vec3 v_tangent_inWorld;
  in vec3 v_binormal_inWorld; // bitangent_inWorld
#endif

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

struct Light {
  int type; // 0 = directional, 1 = point, 2 = spot
  vec3 position;
  vec3 intensity;
  vec3 attenuatedIntensity;
  vec3 directionOfLightObject;
  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)
  vec3 pointToLight; // not normalized
  float innerConeCos;
  float outerConeCos;
  float effectiveRange;
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
float getRangeAttenuation(Light light)
{
  float distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
float getSpotAttenuation(Light light)
{
  float actualCos = dot(light.direction, -light.directionOfLightObject);
  if (actualCos > light.outerConeCos) {
    if (actualCos < light.innerConeCos) {
      float attenuation = (actualCos - light.outerConeCos) / (light.innerConeCos - light.outerConeCos);
      return attenuation * attenuation;
    }
    return 1.0;
  }
  return 0.0;
}

vec3 getLightAttenuated(Light light) {
  light.attenuatedIntensity = light.intensity;
  // if (light.type == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light && Spot Light
  if (light.type != 0)
  {
    light.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot Light
  if (light.type == 2)
  {
    light.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return light.attenuatedIntensity;
}

Light getLight(int lightIdx, vec3 v_position_inWorld) {
  vec3 lightPosition = get_lightPosition(0.0, lightIdx);
  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);
  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);
  vec4 lightProperty = get_lightProperty(0.0, lightIdx);
  Light light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  float lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.innerConeCos = lightProperty.z;
  light.outerConeCos = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3(0.0);
    light.type = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.type = 1;
  } else { // is Directional Light
    light.type = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.type = 2;
  }

  const float M_PI = 3.141592653589793;
  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  light.attenuatedIntensity = getLightAttenuated(light);

  return light;
}


// https://github.com/KhronosGroup/glTF-Sample-Renderer
// Modified by Yuki Shimada

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

float angular_n_h(float NH) {
  return acos(NH);
}

float d_phong(float NH, float c1) {
  return pow(
    cos(acos(NH))
    , c1
  );
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec2 envBRDFApprox( float Roughness, float NoV ) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022 );
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );
  vec4 r = Roughness * c0 + c1;
  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}

// GGX NDF
float d_GGX(float NH, float alphaRoughness) {
  float roughnessSqr = alphaRoughness * alphaRoughness;
  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

float d_torrance_reiz(float NH, float c3) {
  float CosSquared = NH*NH;
  float TanSquared = (1.0 - CosSquared)/CosSquared;
  //return (1.0/M_PI) * sq(c3/(CosSquared * (c3*c3 + TanSquared)));  // gamma = 2, aka GGX
  return (1.0/sqrt(M_PI)) * (sq(c3)/(CosSquared * (c3*c3 + TanSquared))); // gamma = 1, D_Berry
}

float d_beckmann(float NH, float m) {
  float co = 1.0 / (4.0 * m * m * NH * NH * NH * NH);
  float expx = exp((NH * NH - 1.0) / (m * m * NH * NH));
  return co * expx;
}

// the same as glTF WebGL sample
// https://github.com/KhronosGroup/glTF-WebGL-PBR/blob/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders/pbr-frag.glsl#L188
// That is, Unreal Engine based approach, but modified to use alphaRoughness (squared artist's roughness parameter),
// and based on 'Separable Masking and Shadowing' approximation (propesed by Christophe Schlick)
// https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf
float g_shielding(float NL, float NV, float alphaRoughness) {
  float r = alphaRoughness;

  // Local Shadowing using "Schlick-Smith" Masking Function
  float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));

  // Local Masking using "Schlick-Smith" Masking Function
  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));

  return localShadowing * localMasking;
}

// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
float v_GGXCorrelated(float NL, float NV, float alphaRoughness) {
  float a2 = alphaRoughness * alphaRoughness;
  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  float GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  float GGX = GGXV + GGXL;
  if (GGX > 0.0) {
    return clamp(0.5 / GGX, 0.0, 1.0);
  }
  return 1.0;
}

float v_GGXCorrelatedFast(float NL, float NV, float alphaRoughness) {
  float a = alphaRoughness;
  float GGXV = NL * (NV * (1.0 - a) + a);
  float GGXL = NV * (NL * (1.0 - a) + a);
  float GGX = GGXV + GGXL;
  if (GGX > 0.0) {
    return 0.5 / GGX;
  }
  return 0.0;
}

// The Schlick Approximation to Fresnel
float fresnelSchlick(float f0, float f90, float VdotH) {
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

vec3 fresnelSchlick(vec3 f0, vec3 f90, float VdotH) {
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

vec3 fresnelSchlick(vec3 f0, float f90, float VdotH)
{
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

float fresnelSchlick(float f0, float VdotH)
{
  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelSchlick(f0, f90, VdotH);
}
vec3 fresnelSchlick(vec3 f0, float VdotH)
{
  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelSchlick(f0, f90, VdotH);
}

vec3 BRDF_specularGGX(float NH, float NL, float NV, float alphaRoughness) {
  float D = d_GGX(NH, alphaRoughness);
  float V = v_GGXCorrelated(NL, NV, alphaRoughness);
  return vec3(D) * vec3(V);
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf
vec3 BRDF_lambertian(vec3 diffuseAlbedo)
{
  // (1/pi) * diffuseAlbedo
  return diffuseAlbedo * RECIPROCAL_PI;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#specular-brdf
float specular_brdf(float alphaRoughness, float NdotL, float NdotV, float NdotH) {
  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  float D = d_GGX(NdotH, alphaRoughness);
  return V * D;
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes
float specular_btdf(float alphaRoughness, float NdotL, float NdotV, float NdotHt) {
  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  float D = d_GGX(NdotHt, alphaRoughness);
  return V * D;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel
vec3 conductor_fresnel(vec3 f0, float brdf, float alphaRoughness, float VdotH) {
  return vec3(brdf) * (f0.rgb + (vec3(1.0) - f0.rgb) * vec3(pow(1.0 - abs(VdotH), 5.0)));
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel
vec3 fresnel_mix(float ior, vec3 base, vec3 layer, float VdotH) {
  float f0 = pow((1.0 - ior)/(1.0 + ior), 2.0);
  float fr = f0 + (1.0 - f0) * pow(1.0 - abs(VdotH), 5.0);
  return mix(base, layer, fr);
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf
vec3 metal_brdf(float perceptualRoughness, vec3 baseColor, float NdotL, float NdotV, float NdotH, float VdotH) {
  float alphaRoughness = perceptualRoughness * perceptualRoughness;
  return conductor_fresnel(
    baseColor,
    specular_brdf(alphaRoughness, NdotL, NdotV, NdotH),
    alphaRoughness,
    VdotH
  );
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf
// vec3 dielectric_brdf(float ior, vec3 baseColor, float perceptualRoughness, float NdotL, float NdotV, float NdotH, float VdotH) {
//   vec3 base = BRDF_lambertian(baseColor);
//   float alphaRoughness = perceptualRoughness * perceptualRoughness;
//   vec3 layer = vec3(specular_brdf(alphaRoughness, NdotL, NdotV, NdotH));
//   return fresnel_mix(ior, base, layer, VdotH);
// }

vec3 srgbToLinear(vec3 srgbColor) {
  return pow(srgbColor, vec3(2.2));
}

float srgbToLinear(float value) {
  return pow(value, 2.2);
}

vec3 linearToSrgb(vec3 linearColor) {
  return pow(linearColor, vec3(1.0/2.2));
}

float linearToSrgb(float value) {
  return pow(value, 1.0/2.2);
}

// Roughness Dependent Fresnel
// https://www.jcgt.org/published/0008/01/03/paper.pdf
vec3 fresnelSchlickRoughness(vec3 F0, float cosTheta, float roughness)
{
  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;
  vec3 k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);
  return k_S;
}

// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66
vec3 Schlick_to_F0(vec3 f, vec3 f90, float VdotH) {
    float x = clamp(1.0 - VdotH, 0.0, 1.0);
    float x2 = x * x;
    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

float Schlick_to_F0(float f, float f90, float VdotH) {
    float x = clamp(1.0 - VdotH, 0.0, 1.0);
    float x2 = x * x;
    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

vec3 Schlick_to_F0(vec3 f, float VdotH) {
    return Schlick_to_F0(f, vec3(1.0), VdotH);
}

float Schlick_to_F0(float f, float VdotH) {
    return Schlick_to_F0(f, 1.0, VdotH);
}

vec3 normalBlendingUDN(sampler2D baseMap, sampler2D detailMap, vec2 baseUv, vec2 detailUv) {
  vec3 t = texture(baseMap,   baseUv).xyz * 2.0 - 1.0;
  vec3 u = texture(detailMap, detailUv).xyz * 2.0 - 1.0;
  vec3 r = normalize(vec3(t.xy + u.xy, t.z));
  return r;
}

vec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {
  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  mat3 rotationMat = mat3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  mat3 matrix = translationMat * rotationMat * scaleMat;
  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;

  return uvTransformed;
}

float IsotropicNDFFiltering(vec3 normal, float roughness2) {
  float SIGMA2 = 0.15915494;
  float KAPPA = 0.18;
  vec3 dndu = dFdx(normal);
  vec3 dndv = dFdy(normal);
  float kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));
  float clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);
  float filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);
  return filteredRoughness2;
}

////////////////////////////////////////
// glTF KHR_materials_transmission
////////////////////////////////////////

#ifdef RN_USE_TRANSMISSION
// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
vec3 volumeAttenuation(vec3 attenuationColor, float attenuationDistance, vec3 intensity, float transmissionDistance)
{
  if (attenuationDistance == 0.0) { // means Infinite distance
    return intensity; // No attenuation
  } else {
    // vec3 attenuationCo = -log(attenuationColor) / attenuationDistance;
    // vec3 attenuatedTransmittance = exp(-attenuationCo * transmissionDistance);
    vec3 attenuatedTransmittance = pow(attenuationColor, vec3(transmissionDistance / attenuationDistance));
    return intensity * attenuatedTransmittance;
  }
}

// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer
vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior)
{
  vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);
  mat4 worldMatrix = get_worldMatrix(v_instanceInfo);

  vec3 modelScale;
  modelScale.x = length(vec3(worldMatrix[0].xyz));
  modelScale.y = length(vec3(worldMatrix[1].xyz));
  modelScale.z = length(vec3(worldMatrix[2].xyz));

  return normalize(refractionVector) * thickness * modelScale;
}

float applyIorToRoughness(float roughness, float ior)
{
  return clamp(roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0), c_MinRoughness, 1.0);
}

vec3 calculateRadianceTransmission(vec3 normal, vec3 view, vec3 pointToLight, float alphaRoughness, vec3 baseColor, float ior)
{
  float transmissionRoughness = applyIorToRoughness(alphaRoughness, ior);

  vec3 n = normalize(normal);
  vec3 v = normalize(view);
  vec3 l = normalize(pointToLight);
  vec3 mirrorL = normalize(l + 2.0 * n * dot(-l, n));
  vec3 h = normalize(mirrorL + v);

  float D = d_GGX(clamp(dot(n, h), 0.0, 1.0), transmissionRoughness);
  float V = v_GGXCorrelated(clamp(dot(n, mirrorL), 0.0, 1.0), clamp(dot(n, v), 0.0, 1.0), transmissionRoughness);

  return baseColor * D * V;
}

#endif


////////////////////////////////////////
// glTF KHR_materials_anisotropy
////////////////////////////////////////
#ifdef RN_USE_ANISOTROPY
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
float D_GGX_anisotropic(float NdotH, float TdotH, float BdotH, float at, float ab)
{
    float a2 = at * ab;
    vec3 f = vec3(ab * TdotH, at * BdotH, a2 * NdotH);
    float w2 = a2 / dot(f, f);
    return a2 * w2 * w2 / M_PI;
}

float V_GGX_anisotropic(float NdotL, float NdotV, float BdotV, float TdotV, float TdotL, float BdotL,
    float at, float ab)
{
    float GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));
    float GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));
    float GGX = GGXV + GGXL;
    if (GGX > 0.0) {
      return clamp(0.5 / GGX, 0.0, 1.0);
    }
    return 1.0;
}

vec3 BRDF_specularAnisotropicGGX(float alphaRoughness,
    float VdotH, float NdotL, float NdotV, float NdotH, float BdotV, float TdotV,
    float TdotL, float BdotL, float TdotH, float BdotH, float anisotropy)
{
    float at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
    float ab = clamp(alphaRoughness, 0.001, 1.0);

    float V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);
    float D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);

    return vec3(V * D);
}
#endif



////////////////////////////////////////
// glTF KHR_materials_sheen
////////////////////////////////////////

#ifdef RN_USE_SHEEN
float d_Charlie(float sheenPerceptualRoughness, float NoH) {
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  float sheenRoughness = max(sheenPerceptualRoughness, 0.000001);
  float alphaG = sheenRoughness * sheenRoughness;
  float invAlpha  = 1.0 / alphaG;
  float cos2h = NoH * NoH;
  float sin2h = 1.0 - cos2h;
  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
float sheenSimpleVisibility(float NdotL, float NdotV) {
  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
float charlieL(float x, float alphaG) {
  float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
  float a = mix(21.5473, 25.3245, oneMinusAlphaSq);
  float b = mix(3.82987, 3.32435, oneMinusAlphaSq);
  float c = mix(0.19823, 0.16801, oneMinusAlphaSq);
  float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
  float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
  return a / (1.0 + b * pow(x, c)) + d * x + e;
}

float lambdaSheen(float cosTheta, float alphaG)
{
  return abs(cosTheta) < 0.5 ? exp(charlieL(cosTheta, alphaG)) : exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG));
}

float sheenCharlieVisibility(float NdotL, float NdotV, float sheenPerceptualRoughness) {
  float sheenRoughness = max(sheenPerceptualRoughness, 0.000001);
  float alphaG = sheenRoughness * sheenRoughness;
  float sheenVisibility = clamp(1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL)), 0.0, 1.0);
  return sheenVisibility;
}

vec3 BRDF_specularSheen(vec3 sheenColor, float sheenPerceptualRoughness, float NdotL, float NdotV, float NdotH) {
  float sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);
  float sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);
  return sheenColor * sheenDistribution * sheenVisibility;
}
#endif









////////////////////////////////////////
// glTF KHR_materials_irirdescence
////////////////////////////////////////

#ifdef RN_USE_IRIDESCENCE
// XYZ to REC709(sRGB) conversion matrix
const mat3 XYZ_TO_REC709 = mat3(
     3.2404542, -0.9692660,  0.0556434,
    -1.5371385,  1.8760108, -0.2040259,
    -0.4985314,  0.0415560,  1.0572252
);

vec3 fresnelSchlickRoughnessWithIridescence(
  vec3 F0, float cosTheta, float roughness,
  vec3 iridescenceFresnel, float iridescence
  )
{
  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;
  vec3 k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);
  return k_S;
}

// Assume air interface for top
vec3 Fresnel0ToIor(vec3 F0) {
    vec3 sqrtF0 = sqrt(F0);
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// Conversion from IOR to F0
// ior is a value between 1.0 and 3.0. 1.0 is air interface
vec3 IorToFresnel0(vec3 transmittedIor, float incidentIor) {
    return sq((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
float IorToFresnel0(float transmittedIor, float incidentIor) {
    return sq((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration
 */
vec3 evalSensitivity(float OPD, vec3 shift) {
    float phase = 2.0 * M_PI * OPD * 1.0e-9;
    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);

    vec3 xyz = val * sqrt(2.0 * M_PI * var) * cos(pos * phase + shift) * exp(-(phase * phase) * var);
    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));
    xyz /= 1.0685e-7;

    vec3 rgb = XYZ_TO_REC709 * xyz;
    return rgb;
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel
 */
vec3 calcIridescence(float outsideIor, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {


  // iridescenceIor is the index of refraction of the thin-film layer
  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
  float iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));

  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)
  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.
  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.
  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):
  float sinTheta2Sq = sq(outsideIor / iridescenceIor) * (1.0 - sq(cosTheta1));
  float cosTheta2Sq = 1.0 - sinTheta2Sq;

  // Handle total internal reflection
  if (cosTheta2Sq < 0.0) {
      return vec3(1.0);
  }

  float cosTheta2 = sqrt(cosTheta2Sq);

  /// Material Interfaces
  // The iridescence model defined by Belcour/Barla models two material interfaces
  // - one from the outside to the thin-film layer
  // and another one from the thin-film to the base material. These two interfaces are defined as follows:

  // First interface (from the outside to the thin-film layer)
  float R0 = IorToFresnel0(iridescenceIor, outsideIor);
  float R12 = fresnelSchlick(R0, cosTheta1);
  float R21 = R12;
  float T121 = 1.0 - R12;

  // Second interface (from the thin-film to the base material)
  vec3 baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0
  vec3 R1 = IorToFresnel0(baseIor, iridescenceIor);
  vec3 R23 = fresnelSchlick(R1, cosTheta2);

  // phi12 and phi23 define the base phases per interface and are approximated with 0.0
  // if the IOR of the hit material (iridescenceIor or baseIor) is higher
  // than the IOR of the previous material (outsideIor or iridescenceIor) and \u03C0 otherwise.
  // Also here, polarization is ignored.  float phi12 = 0.0;

  // First interface (from the outside to the thin-film layer)
  float phi12 = 0.0;
  if (iridescenceIor < outsideIor) phi12 = M_PI;
  float phi21 = M_PI - phi12;

  // Second interface (from the thin-film to the base material)
  vec3 phi23 = vec3(0.0);
  if (baseIor[0] < iridescenceIor) phi23[0] = M_PI;
  if (baseIor[1] < iridescenceIor) phi23[1] = M_PI;
  if (baseIor[2] < iridescenceIor) phi23[2] = M_PI;

  // OPD (optical path difference)
  float OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
  // Phase shift
  vec3 phi = vec3(phi21) + phi23;

  // Compound terms
  vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);
  vec3 r123 = sqrt(R123);
  vec3 Rs = (T121 * T121) * R23 / (vec3(1.0) - R123);

  // Reflectance term for m = 0 (DC term amplitude)
  vec3 C0 = R12 + Rs;
  vec3 I = C0;

  // Reflectance term for m > 0 (pairs of diracs)
  vec3 Cm = Rs - T121;
  for (int m = 1; m <= 2; ++m)
  {
      Cm *= r123;
      vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);
      I += Cm * Sm;
  }

  vec3 F_iridescence = max(I, vec3(0.0));

  return F_iridescence;
}

//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB
vec3 BRDF_lambertianIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float iridescenceFactor, vec3 diffuseColor, float specularWeight, float VdotH)
{
    vec3 iridescenceFresnelMax = vec3(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));
    vec3 schlickFresnel = Schlick_to_F0(f0, f90, VdotH);
    vec3 F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);

    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);
}

vec3 BRDF_specularGGXIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float alphaRoughness, float iridescenceFactor, float specularWeight, float VdotH, float NdotL, float NdotV, float NdotH)
{
    vec3 F = mix(Schlick_to_F0(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);
    float Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
    float D = d_GGX(NdotH, alphaRoughness);

    return specularWeight * F * Vis * D;
}

vec3 rgb_mix(vec3 base, vec3 specular_brdf, vec3 rgb_alpha)
{
    float rgb_alpha_max = max(rgb_alpha.r, max(rgb_alpha.g, rgb_alpha.b));
    return (1.0 - rgb_alpha_max) * base + rgb_alpha * specular_brdf;
}

#endif // RN_USE_IRIDESCENCE





////////////////////////////////////////
// lighting with a punctual light
////////////////////////////////////////
vec3 lightingWithPunctualLight(
  Light light,
  vec3 normal_inWorld,
  vec3 viewDirection,
  float NdotV,
  vec3 baseColor,
  float perceptualRoughness,
  float metallic,
  vec3 dielectricF0,
  vec3 dielectricF90,
  float ior,
  float transmission,
  float thickness,
  float clearcoat,
  float clearcoatRoughness,
  vec3 clearcoatF0,
  vec3 clearcoatF90,
  vec3 clearcoatFresnel,
  vec3 clearcoatNormal_inWorld,
  float VdotNc,
  vec3 attenuationColor,
  float attenuationDistance,
  float anisotropy,
  vec3 anisotropicT,
  vec3 anisotropicB,
  float BdotV,
  float TdotV,
  vec3 sheenColor,
  float sheenRoughness,
  float albedoSheenScalingNdotV,
  float iridescence,
  vec3 iridescenceFresnel_dielectric,
  vec3 iridescenceFresnel_metal,
  float specularWeight,
  float diffuseTransmission,
  vec3 diffuseTransmissionColor,
  float diffuseTransmissionThickness
  )
{
  float alphaRoughness = perceptualRoughness * perceptualRoughness;

  // Fresnel
  vec3 halfVector = normalize(light.direction + viewDirection);
  float VdotH = saturate(dot(viewDirection, halfVector));
  vec3 dielectricFresnel = fresnelSchlick(dielectricF0, dielectricF90, VdotH);
  vec3 metalFresnel = fresnelSchlick(baseColor, vec3(1.0), VdotH);

  float NdotL = saturateEpsilonToOne(dot(normal_inWorld, light.direction));

  // Diffuse
  vec3 diffuseBrdf = BRDF_lambertian(baseColor);
  vec3 diffuseContrib = diffuseBrdf * vec3(NdotL) * light.attenuatedIntensity;

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  diffuseContrib = diffuseContrib * (vec3(1.0) - diffuseTransmission);
  if (dot(normal_inWorld, light.direction) < 0.0) {
    float diffuseNdotL = saturate(dot(normal_inWorld, -light.direction));
    vec3 diffuseBtdf = BRDF_lambertian(diffuseTransmissionColor) * vec3(diffuseNdotL) * light.attenuatedIntensity;
    vec3 mirrorL = normalize(light.direction + 2.0 * normal_inWorld * dot(normal_inWorld, -light.direction));
    float diffuseVdotH = saturate(dot(viewDirection, normalize(mirrorL + viewDirection)));
    dielectricFresnel = fresnelSchlick(dielectricF0 * specularWeight, dielectricF90, abs(diffuseVdotH));
#ifdef RN_USE_VOLUME
    diffuseBtdf = volumeAttenuation(attenuationColor, attenuationDistance, diffuseBtdf, diffuseTransmissionThickness);
#endif // RN_USE_VOLUME
    diffuseContrib += diffuseBtdf * diffuseTransmission;
  }
#endif // RN_USE_DIFFUSE_TRANSMISSION


#ifdef RN_USE_TRANSMISSION
  vec3 transmittionRay = getVolumeTransmissionRay(normal_inWorld, viewDirection, thickness, ior);
  light.pointToLight -= transmittionRay;
  light.direction = normalize(light.pointToLight);
  vec3 transmittedContrib = calculateRadianceTransmission(normal_inWorld, viewDirection, light.direction, alphaRoughness, baseColor, ior) * light.attenuatedIntensity;

#ifdef RN_USE_VOLUME
  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittionRay));
#endif // RN_USE_VOLUME

  diffuseContrib = mix(diffuseContrib, vec3(transmittedContrib), transmission);
#endif // RN_USE_TRANSMISSION

  light.attenuatedIntensity = getLightAttenuated(light);
  // Specular
  float NdotH = saturate(dot(normal_inWorld, halfVector));

#ifdef RN_USE_ANISOTROPY
  float TdotL = dot(anisotropicT, light.direction);
  float BdotL = dot(anisotropicB, light.direction);
  float TdotH = dot(anisotropicT, halfVector);
  float BdotH = dot(anisotropicB, halfVector);
  vec3 specularMetalContrib = BRDF_specularAnisotropicGGX(alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3(NdotL) * light.attenuatedIntensity;
  vec3 specularDielectricContrib = specularMetalContrib;
#else
  vec3 specularMetalContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, alphaRoughness) * vec3(NdotL) * light.attenuatedIntensity;
  vec3 specularDielectricContrib = specularMetalContrib;
#endif // RN_USE_ANISOTROPY

  // Base Layer
  vec3 metal = specularMetalContrib * metalFresnel;
  vec3 dielectric = mix(diffuseContrib, specularDielectricContrib, dielectricFresnel);

#ifdef RN_USE_IRIDESCENCE
  metal = mix(metal, specularMetalContrib * iridescenceFresnel_metal, iridescence);
  dielectric = mix(dielectric, rgb_mix(diffuseContrib, specularDielectricContrib, iridescenceFresnel_dielectric), iridescence);
#endif // RN_USE_IRIDESCENCE

#ifdef RN_USE_CLEARCOAT
  // Clear Coat Layer
  float NdotHc = saturate(dot(clearcoatNormal_inWorld, halfVector));
  float LdotNc = saturate(dot(light.direction, clearcoatNormal_inWorld));
  vec3 clearcoatContrib = BRDF_specularGGX(NdotHc, LdotNc, VdotNc, clearcoatRoughness * clearcoatRoughness) * vec3(LdotNc) * light.attenuatedIntensity;
#else
  vec3 clearcoatContrib = vec3(0.0);
#endif // RN_USE_CLEARCOAT

#ifdef RN_USE_SHEEN
  // Sheen
  vec3 sheenContrib = BRDF_specularSheen(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;
  float albedoSheenScaling = min(
    albedoSheenScalingNdotV,
    1.0 - max3(sheenColor) * texture(u_sheenLutTexture, vec2(NdotL, sheenRoughness)).r);
#else
  vec3 sheenContrib = vec3(0.0);
  float albedoSheenScaling = 1.0;
#endif // RN_USE_SHEEN

  vec3 color = mix(dielectric, metal, metallic);
  color = sheenContrib + color * albedoSheenScaling;
  color = mix(color, clearcoatContrib, clearcoat * clearcoatFresnel);

  return color;
}


/* shaderity: @{matricesGetters} */

// This file includes portions of code from the glTF-Sample-Renderer project by Khronos Group (Apache License 2.0).
// https://github.com/KhronosGroup/glTF-Sample-Renderer
// Modified by Yuki Shimada


vec3 getIBLIrradiance(vec3 normal_forEnv, vec4 iblParameter, ivec2 hdriFormat) {
  vec4 diffuseTexel = texture(u_diffuseEnvTexture, normal_forEnv);

  vec3 irradiance;
  if (hdriFormat.x == 0) {
    // LDR_SRGB
    irradiance = srgbToLinear(diffuseTexel.rgb);
  }
  else if (hdriFormat.x == 3) {
    // RGBE
    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  }
  else {
    irradiance = diffuseTexel.rgb;
  }

  // scale with user parameters
  float IBLDiffuseContribution = iblParameter.y;
  irradiance *= IBLDiffuseContribution;

  return irradiance;
}

float scaleForLod(float perceptualRoughness, float ior)
{
  // Scale roughness to the range [0, 1],
  // ior=1.0 will be scale 0,
  // ior=1.5 will be scale 1.0,
  // ior=2 will be scale 1.0 (clamped)
  //

  float scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);
  return perceptualRoughness * scale;
}

#ifdef RN_USE_TRANSMISSION
vec3 get_sample_from_backbuffer(vec2 sampleCoord, float perceptualRoughness, float ior) {
  ivec2 vrState = get_vrState(0.0, 0);
  vec2 backBufferTextureSize = vec2(textureSize(u_backBufferTexture, 0));
  float backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);

#ifdef WEBGL2_MULTI_VIEW
  // For VR
  backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
  sampleCoord.x = sampleCoord.x * 0.5;
  if (v_displayIdx == 1.0) { // For right eye
    sampleCoord.x += 0.5;
  }
#else
  if (vrState.x == 1) { // For VR
    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
    sampleCoord.x = sampleCoord.x * 0.5;
    if (vrState.y == 1) { // For right eye
      sampleCoord.x += 0.5;
    }
  }
#endif

  float framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);
  vec3 transmittedLight = textureLod(u_backBufferTexture, sampleCoord, framebufferLod).rgb;

  return transmittedLight;
}

vec3 getIBLVolumeRefraction(vec3 baseColor, vec3 normal, vec3 view, float cameraSID, float materialSID, float thickness, float perceptualRoughness, float ior, vec3 attenuationColor, float attenuationDistance) {
#ifdef RN_USE_DISPERSION
  float dispersion = get_dispersion(materialSID, 0);
  float halfSpread = (ior - 1.0) * 0.025 * dispersion;
  vec3 iors = vec3(ior - halfSpread, ior, ior + halfSpread);

  vec3 transmittedLight;
  float transmissionRayLength;
  for(int i=0;i<3;i++) {
    vec3 transmissionRay = getVolumeTransmissionRay(normal, view, thickness, iors[i]);
    transmissionRayLength = length(transmissionRay);
    vec3 refractedRayExit = v_position_inWorld.xyz + transmissionRay;

    vec4 ndcPos = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4(refractedRayExit, 1.0);
    vec2 refractionCoords = ndcPos.xy / ndcPos.w;
    refractionCoords += 1.0;
    refractionCoords /= 2.0;

    transmittedLight[i] = get_sample_from_backbuffer(refractionCoords, perceptualRoughness, iors[i])[i];
  }
#else
  vec3 transmissionRay = getVolumeTransmissionRay(normal, view, thickness, ior);
  float transmissionRayLength = length(transmissionRay);
  vec3 refractedRayExit = v_position_inWorld.xyz + transmissionRay;

  vec4 ndcPos = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4(refractedRayExit, 1.0);
  vec2 refractionCoords = ndcPos.xy / ndcPos.w;
  refractionCoords += 1.0;
  refractionCoords /= 2.0;

  vec3 transmittedLight = get_sample_from_backbuffer(refractionCoords, perceptualRoughness, ior);
#endif
  vec3 attenuatedColor = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, transmissionRayLength);
  return attenuatedColor * baseColor;
}

#endif // RN_USE_TRANSMISSION

vec3 get_radiance(vec3 reflection, float lod, ivec2 hdriFormat) {
  vec4 specularTexel = textureLod(u_specularEnvTexture, reflection, lod);

  vec3 radiance;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

struct IblResult
{
  vec3 specular;
  vec3 diffuse;
  vec3 FssEss;
};

vec3 getIBLRadianceGGX(float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, vec3 reflection)
{
  // get radiance
  float mipCount = iblParameter.x;
  float lod = (perceptualRoughness * (mipCount - 1.0));
  vec3 radiance = get_radiance(reflection, lod, hdriFormat);

  // scale with user parameters
  float IBLSpecularContribution = iblParameter.z;
  radiance *= IBLSpecularContribution;

  return radiance;
}

vec3 getIBLFresnelGGX(float perceptualRoughness, float NdotV, vec3 F0, float specularWeight) {
  // https://bruop.github.io/ibl/#single_scattering_results

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = vec3(specularWeight) * (kS * f_ab.x + f_ab.y);

  // Multiple scattering
  float Ems = (1.0 - (f_ab.x + f_ab.y));
  vec3 F_avg = vec3(specularWeight) * (F0 + (1.0 - F0) / 21.0);
  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);

  return FssEss + FmsEms;
}

#ifdef RN_USE_SHEEN

vec3 get_radiance_sheen(vec3 reflection, float lod, ivec2 hdriFormat) {
  vec4 specularTexel = textureLod(u_sheenEnvTexture, reflection, lod);

  vec3 radiance;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

vec3 sheenIBL(float NdotV, float sheenPerceptualRoughness, vec3 sheenColor, vec4 iblParameter, vec3 reflection, ivec2 hdriFormat)
{
  float mipCount = iblParameter.x;
  float lod = (sheenPerceptualRoughness * (mipCount - 1.0));

  vec2 sheenLutUV = vec2(NdotV, sheenPerceptualRoughness);
  float brdf = texture(u_sheenLutTexture, sheenLutUV).b;
  vec3 sheenLight = get_radiance_sheen(reflection, lod, hdriFormat);
  float IBLSpecularContribution = iblParameter.z;
  sheenLight *= IBLSpecularContribution;

  return sheenLight * sheenColor * brdf;
}
#endif

vec3 getNormalForEnv(mat3 rotEnvMatrix, vec3 normal_inWorld, float materialSID) {
  vec3 normal_forEnv = rotEnvMatrix * normal_inWorld;
  if (get_inverseEnvironment(materialSID, 0)) {
    normal_forEnv.x *= -1.0;
  }
  return normal_forEnv;
}

vec3 getReflection(mat3 rotEnvMatrix, vec3 viewDirection, vec3 normal_inWorld, float materialSID, float perceptualRoughness, float anisotropy, vec3 anisotropyDirection) {
#ifdef RN_USE_ANISOTROPY

  float tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);
  vec3  anisotropicTangent  = cross(anisotropyDirection, viewDirection);
  vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);
  float bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);
  float bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;
  vec3  bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));
  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);
#else
  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);
#endif
  if (get_inverseEnvironment(materialSID, 0)) {
    reflection.x *= -1.0;
  }
  return reflection;
}

vec3 IBLContribution(float materialSID, vec3 normal_inWorld, float NdotV, vec3 viewDirection,
  vec3 baseColor, float perceptualRoughness, float clearcoatRoughness, vec3 clearcoatNormal_inWorld,
  float clearcoat, vec3 clearcoatFresnel, float VdotNc, vec3 geomNormal_inWorld, float cameraSID, float transmission, vec3 v_position_inWorld,
  float thickness, vec3 sheenColor, float sheenRoughness, float albedoSheenScalingNdotV, float ior,
  vec3 iridescenceFresnel_dielectric, vec3 iridescenceFresnel_metal, float iridescence, float anisotropy, vec3 anisotropyDirection,
  float specularWeight, vec3 dielectricF0, float metallic, float diffuseTransmission, vec3 diffuseTransmissionColor, float diffuseTransmissionThickness)
{
  vec4 iblParameter = get_iblParameter(materialSID, 0);
  float rot = iblParameter.w;
  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);

  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  vec3 reflection = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);

  // get irradiance
  vec3 irradiance = getIBLIrradiance(normal_forEnv, iblParameter, hdriFormat);
  vec3 diffuse = irradiance * baseColor;

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  vec3 diffuseTransmissionIBL = getIBLIrradiance(-normal_forEnv, iblParameter, hdriFormat) * diffuseTransmissionColor;
#ifdef RN_USE_VOLUME
  diffuseTransmissionIBL = volumeAttenuation(attenuationColor, attenuationDistance, diffuseTransmissionIBL, diffuseTransmissionThickness);
#endif
  diffuse = mix(diffuse, diffuseTransmissionIBL, diffuseTransmission);
#endif

#ifdef RN_USE_TRANSMISSION
  vec3 attenuationColor = get_attenuationColor(materialSID, 0);
  float attenuationDistance = get_attenuationDistance(materialSID, 0);
  vec3 specularTransmission = getIBLVolumeRefraction(baseColor, normal_inWorld, viewDirection, cameraSID, materialSID, thickness, perceptualRoughness, ior, attenuationColor, attenuationDistance);
  diffuse = mix(diffuse, specularTransmission, transmission);
#endif

  // take account of anisotropy with reflection
  vec3 specularMetal = getIBLRadianceGGX(perceptualRoughness, iblParameter, hdriFormat, reflection);
  vec3 specularDielectric = specularMetal;

  // Calculate fresnel mix
  vec3 fresnelMetal = getIBLFresnelGGX(perceptualRoughness, NdotV, baseColor, 1.0);
  vec3 metalContrib = fresnelMetal * specularMetal;
  vec3 fresnelDielectric = getIBLFresnelGGX(perceptualRoughness, NdotV, dielectricF0, specularWeight);
  vec3 dielectricContrib = mix(diffuse, specularDielectric, fresnelDielectric);

#ifdef RN_USE_IRIDESCENCE
  metalContrib = mix(metalContrib, specularMetal * iridescenceFresnel_metal, iridescence);
  dielectricContrib = mix(dielectricContrib, rgb_mix(diffuse, specularDielectric, iridescenceFresnel_dielectric), iridescence);
#endif

#ifdef RN_USE_CLEARCOAT
  vec3 clearcoatReflection = getReflection(rotEnvMatrix, viewDirection, clearcoatNormal_inWorld, materialSID, clearcoatRoughness, 0.0, vec3(0.0));
  vec3 clearcoatContrib = getIBLRadianceGGX(clearcoatRoughness, iblParameter, hdriFormat, clearcoatReflection);
#else
  vec3 clearcoatContrib = vec3(0.0);
#endif

#ifdef RN_USE_SHEEN
  vec3 sheenContrib = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);
  float albedoSheenScaling = albedoSheenScalingNdotV;
#else
  vec3 sheenContrib = vec3(0.0);
  float albedoSheenScaling = 1.0;
#endif

  vec3 color = mix(dielectricContrib, metalContrib, metallic);
  color = sheenContrib + color * albedoSheenScaling;
  color = mix(color, clearcoatContrib, clearcoat * clearcoatFresnel);

  return color;
}


uniform vec4 u_baseColorFactor; // initialValue=(1,1,1,1)
uniform sampler2D u_baseColorTexture; // initialValue=(1,white)
uniform int u_baseColorTexcoordIndex; // initialValue=0
uniform vec2 u_baseColorTextureTransformScale; // initialValue=(1,1)
uniform vec2 u_baseColorTextureTransformOffset; // initialValue=(0,0)
uniform float u_baseColorTextureTransformRotation; // initialValue=0

uniform sampler2D u_normalTexture; // initialValue=(2,black)
uniform vec2 u_normalTextureTransformScale; // initialValue=(1,1)
uniform vec2 u_normalTextureTransformOffset; // initialValue=(0,0)
uniform float u_normalTextureTransformRotation; // initialValue=0
uniform int u_normalTexcoordIndex; // initialValue=0
uniform float u_normalScale; // initialValue=(1)

uniform float u_shadingShiftFactor; // initialValue=0.0
uniform sampler2D u_shadingShiftTexture; // initialValue=(3,black)
uniform int u_shadingShiftTexcoordIndex; // initialValue=0
uniform float u_shadingShiftTextureScale; // initialValue=1.0

uniform float u_shadingToonyFactor; // initialValue=0.9
uniform vec3 u_shadeColorFactor; // initialValue=(0,0,0)
uniform sampler2D u_shadeMultiplyTexture; // initialValue=(4,white)
uniform int u_shadeMultiplyTexcoordIndex; // initialValue=0

uniform samplerCube u_diffuseEnvTexture; // initialValue=(5,black), isInternalSetting=true
uniform samplerCube u_specularEnvTexture; // initialValue=(6,black), isInternalSetting=true

uniform float u_giEqualizationFactor; // initialValue=0.9

uniform sampler2D u_matcapTexture; // initialValue=(8,black)
uniform vec3 u_matcapFactor; // initialValue=(1,1,1)
uniform vec3 u_parametricRimColorFactor; // initialValue=(0,0,0)
uniform float u_parametricRimFresnelPowerFactor; // initialValue=5.0
uniform float u_parametricRimLiftFactor; // initialValue=0.0
uniform sampler2D u_rimMultiplyTexture; // initialValue=(9,white)
uniform int u_rimMultiplyTexcoordIndex; // initialValue=0
uniform float u_rimLightingMixFactor; // initialValue=1.0

uniform vec3 u_emissiveFactor; // initialValue=(0,0,0)
uniform sampler2D u_emissiveTexture; // initialValue=(10,white)
uniform int u_emissiveTexcoordIndex; // initialValue=0

uniform vec3 u_outlineColorFactor; // initialValue=(0,0,0)
uniform float u_outlineLightingMixFactor; // initialValue=1.0

uniform sampler2D u_uvAnimationMaskTexture; // initialValue=(11,white)
uniform int u_uvAnimationMaskTexcoordIndex; // initialValue=0
uniform float u_uvAnimationScrollXSpeedFactor; // initialValue=0.0
uniform float u_uvAnimationScrollYSpeedFactor; // initialValue=0.0
uniform float u_uvAnimationRotationSpeedFactor; // initialValue=0.0

uniform bool u_inverseEnvironment; // initialValue=false
uniform vec4 u_iblParameter; // initialValue=(1,1,1,1), isInternalSetting=true
uniform ivec2 u_hdriFormat; // initialValue=(0,0), isInternalSetting=true
uniform float u_alphaCutoff; // initialValue=0.5
uniform bool u_makeOutputSrgb; // initialValue=false

float linearstep(float a, float b, float t) {
  return clamp((t - a) / (b - a), 0.0, 1.0);
}

vec2 getTexcoord(int texcoordIndex) {
  vec2 texcoord;
  if(texcoordIndex == 2){
    texcoord = v_texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = v_texcoord_1;
  }else{
    texcoord = v_texcoord_0;
  }
  return texcoord;
}

vec2 uvAnimation(vec2 origUv, float time, float uvAnimMask, float uvAnimationScrollXSpeedFactor, float uvAnimationScrollYSpeedFactor, float uvAnimationRotationSpeedFactor) {
  float scrollX = uvAnimationScrollXSpeedFactor * time;
  float scrollY = uvAnimationScrollYSpeedFactor * time;
  float rotation = uvAnimationRotationSpeedFactor * time;
  float rotationCos = cos(rotation * uvAnimMask);
  float rotationSin = sin(rotation * uvAnimMask);
  vec2 uv = mat2(rotationCos, -rotationSin, rotationSin, rotationCos) * (origUv - vec2(0.5)) + vec2(0.5);
  uv += vec2(scrollX, scrollY) * uvAnimMask;
  return uv;
}

#ifdef RN_USE_TANGENT
  mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {
    vec3 tangent_inWorld = normalize(v_tangent_inWorld);
    vec3 binormal_inWorld = normalize(v_binormal_inWorld);
    mat3 tbnMat_tangent_to_world = mat3(tangent_inWorld, binormal_inWorld, normal_inWorld);

    return tbnMat_tangent_to_world;
  }
#else
    // This is based on http://www.thetenthplanet.de/archives/1180
    mat3 cotangent_frame(vec3 normal_inWorld, vec3 position, vec2 uv) {
      uv = gl_FrontFacing ? uv : -uv;

      // get edge vectors of the pixel triangle
      vec3 dp1 = dFdx(position);
      vec3 dp2 = dFdy(position);
      vec2 duv1 = dFdx(uv);
      vec2 duv2 = dFdy(uv);

      // solve the linear system
      vec3 dp2perp = cross(dp2, normal_inWorld);
      vec3 dp1perp = cross(normal_inWorld, dp1);
      vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;
      vec3 bitangent = dp2perp * duv1.y + dp1perp * duv2.y;
      bitangent *= -1.0;

      // construct a scale-invariant frame
      float invMat = inversesqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));
      return mat3(tangent * invMat, bitangent * invMat, normal_inWorld);
    }

    mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {
      mat3 tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord);

      return tbnMat_tangent_to_world;
    }
#endif


void main() {
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  rt0 = vec4(0.0, 0.0, 0.0, 1.0);

  // uv animation
  float uvAnimationScrollXSpeedFactor = get_uvAnimationScrollXSpeedFactor(materialSID, 0);
  float uvAnimationScrollYSpeedFactor = get_uvAnimationScrollYSpeedFactor(materialSID, 0);
  float uvAnimationRotationSpeedFactor = get_uvAnimationRotationSpeedFactor(materialSID, 0);
  int uvAnimationMaskTexcoordIndex = get_uvAnimationMaskTexcoordIndex(materialSID, 0);
  vec2 uvAnimationMaskTexcoord = getTexcoord(uvAnimationMaskTexcoordIndex);
  float uvAnimMask = texture(u_uvAnimationMaskTexture, uvAnimationMaskTexcoord).b;
  float time = get_time(0.0, 0);

  // base color
  vec2 baseColorTextureTransformScale = get_baseColorTextureTransformScale(materialSID, 0);
  vec2 baseColorTextureTransformOffset = get_baseColorTextureTransformOffset(materialSID, 0);
  float baseColorTextureTransformRotation = get_baseColorTextureTransformRotation(materialSID, 0);
  int baseColorTexcoordIndex = get_baseColorTexcoordIndex(materialSID, 0);
  vec2 baseColorTexcoord = getTexcoord(baseColorTexcoordIndex);
  baseColorTexcoord = uvAnimation(baseColorTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  vec2 baseColorTexUv = uvTransform(baseColorTextureTransformScale, baseColorTextureTransformOffset, baseColorTextureTransformRotation, baseColorTexcoord);
  vec4 baseColorTexture = texture(u_baseColorTexture, baseColorTexUv);
  baseColorTexture.rgb = srgbToLinear(baseColorTexture.rgb);
  vec4 baseColorFactor = get_baseColorFactor(materialSID, 0);
  vec3 baseColorTerm = baseColorTexture.rgb * baseColorFactor.rgb;

  // shade color
  vec3 shadeColorFactor = get_shadeColorFactor(materialSID, 0);
  int shadeMultiplyTexcoordIndex = get_shadeMultiplyTexcoordIndex(materialSID, 0);
  vec2 shadeMultiplyTexcoord = getTexcoord(shadeMultiplyTexcoordIndex);
  shadeMultiplyTexcoord = uvAnimation(shadeMultiplyTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  vec4 shadeMultiplyTexture = texture(u_shadeMultiplyTexture, shadeMultiplyTexcoord);
  shadeMultiplyTexture.rgb = srgbToLinear(shadeMultiplyTexture.rgb);
  vec3 shadeColorTerm = shadeColorFactor * shadeMultiplyTexture.rgb;

  // shading shift
  int shadingShiftTexcoordIndex = get_shadingShiftTexcoordIndex(materialSID, 0);
  vec2 shadingShiftTexcoord = getTexcoord(shadingShiftTexcoordIndex);
  shadingShiftTexcoord = uvAnimation(shadingShiftTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  float shadingShiftTexture = texture(u_shadingShiftTexture, shadingShiftTexcoord).r;
  float shadingShiftTextureScale = get_shadingShiftTextureScale(materialSID, 0);

  // emissive
  vec3 emissiveFactor = get_emissiveFactor(materialSID, 0);
  int emissiveTexcoordIndex = get_emissiveTexcoordIndex(materialSID, 0);
  vec2 emissiveTexcoord = getTexcoord(emissiveTexcoordIndex);
  emissiveTexcoord = uvAnimation(emissiveTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  vec4 emissiveTexture = texture(u_emissiveTexture, emissiveTexcoord);
  emissiveTexture.rgb = srgbToLinear(emissiveTexture.rgb);
  vec3 emissive = emissiveFactor * emissiveTexture.rgb;

  // alpha
  float alpha = baseColorTexture.a * baseColorFactor.a;
#ifdef RN_ALPHATEST_ON
  float cutoff = get_alphaCutoff(materialSID, 0);
  if(alpha < cutoff) discard;
#endif

  // view vector
  vec3 viewPosition = get_viewPosition(cameraSID, 0);
  vec3 viewVector = viewPosition - v_position_inWorld.xyz;
  vec3 viewDirection = normalize(viewVector);

  // Normal
  vec3 normal_inWorld = normalize(v_normal_inWorld);
#ifdef RN_USE_NORMAL_TEXTURE
  vec2 normalTextureTransformScale = get_normalTextureTransformScale(materialSID, 0);
  vec2 normalTextureTransformOffset = get_normalTextureTransformOffset(materialSID, 0);
  float normalTextureTransformRotation = get_normalTextureTransformRotation(materialSID, 0);
  int normalTexcoordIndex = get_normalTexcoordIndex(materialSID, 0);
  vec2 normalTexcoord = getTexcoord(normalTexcoordIndex);
  normalTexcoord = uvAnimation(normalTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  vec2 normalTexUv = uvTransform(normalTextureTransformScale, normalTextureTransformOffset, normalTextureTransformRotation, normalTexcoord);
  vec3 normal = texture(u_normalTexture, normalTexUv).xyz * 2.0 - 1.0;
  mat3 TBN = getTBN(normal_inWorld, viewDirection, normalTexUv);
  normal_inWorld = normalize(TBN * normal);
#endif

#ifdef RN_MTOON_IS_OUTLINE
  normal_inWorld *= -1.0;
#endif

  // direct lighting
  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation
  vec3 directLighting = vec3(0.0);
  for (int i = 0; i < lightNumber; i++) {
    Light light = getLight(i, v_position_inWorld.xyz);
    float shading = dot(light.direction, normal_inWorld);
    float shadingShiftFactor = get_shadingShiftFactor(materialSID, 0);
    shading += shadingShiftFactor + shadingShiftTexture * shadingShiftTextureScale;
    float shadingToonyFactor = get_shadingToonyFactor(materialSID, 0);
    shading = linearstep(-1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading);

    vec3 color = mix(shadeColorTerm, baseColorTerm, shading);
    color = color * light.attenuatedIntensity * RECIPROCAL_PI;
    directLighting += light.attenuatedIntensity;
    rt0.xyz += color;
  }

  // indirect lighting
  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation-1
  float giEqualizationFactor = get_giEqualizationFactor(materialSID, 0);
  vec3 worldUpVector = vec3(0.0, 1.0, 0.0);
  vec3 worldDownVector = vec3(0.0, -1.0, 0.0);
  vec4 iblParameter = get_iblParameter(materialSID, 0);
  float rot = iblParameter.w;
  float IBLDiffuseContribution = iblParameter.y;
  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);
  vec3 rawGiUp = getIBLIrradiance(worldUpVector, iblParameter, hdriFormat) * IBLDiffuseContribution;
  vec3 rawGiDown = getIBLIrradiance(worldDownVector, iblParameter, hdriFormat) * IBLDiffuseContribution;
  vec3 rawGiNormal = getIBLIrradiance(normal_forEnv, iblParameter, hdriFormat) * IBLDiffuseContribution;
  vec3 uniformedGi = (rawGiUp + rawGiDown) / 2.0;
  vec3 passthroughGi = rawGiNormal;
  vec3 gi = mix(uniformedGi, passthroughGi, giEqualizationFactor);
  rt0.xyz += gi * baseColorTerm * RECIPROCAL_PI;

  // rim lighting
  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation-2
  vec3 rim = vec3(0.0);
  vec3 worldViewX = normalize(vec3(viewDirection.z, 0.0, -viewDirection.x));
  vec3 worldViewY = cross(viewDirection, worldViewX);
  vec2 matcapUv = vec2( dot(worldViewX, normal_inWorld), dot(worldViewY, normal_inWorld)) * 0.495 + 0.5;
  float epsilon = 0.00001;
  vec3 matcapFactor = srgbToLinear(get_matcapFactor(materialSID, 0));
  rim = matcapFactor * texture(u_matcapTexture, matcapUv).rgb;
  float parametricRimLiftFactor = get_parametricRimLiftFactor(materialSID, 0);
  float parametricRim = clamp( 1.0 - dot(normal_inWorld, viewVector) + parametricRimLiftFactor, 0.0, 1.0);
  float parametricRimFresnelPowerFactor = get_parametricRimFresnelPowerFactor(materialSID, 0);
  parametricRim = pow(parametricRim, max(parametricRimFresnelPowerFactor, epsilon));
  vec3 parametricRimColorFactor = get_parametricRimColorFactor(materialSID, 0);
  rim += parametricRim * parametricRimColorFactor;
  int rimMultiplyTexcoordIndex = get_rimMultiplyTexcoordIndex(materialSID, 0);
  vec2 rimMultiplyTexcoord = getTexcoord(rimMultiplyTexcoordIndex);
  rimMultiplyTexcoord = uvAnimation(rimMultiplyTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  rim *= srgbToLinear(texture(u_rimMultiplyTexture, rimMultiplyTexcoord).rgb);
  float rimLightingMixFactor = get_rimLightingMixFactor(materialSID, 0);
  rim *= mix(vec3(1.0), directLighting + gi, rimLightingMixFactor);
  rt0.xyz += rim;

  // emissive
  rt0.xyz += emissive;

#ifdef RN_MTOON_IS_OUTLINE
  vec3 outlineColorFactor = get_outlineColorFactor(materialSID, 0);
  float outlineLightingMixFactor = get_outlineLightingMixFactor(materialSID, 0);
  rt0.xyz = outlineColorFactor * mix(vec3(1.0), rt0.xyz, outlineLightingMixFactor);
#endif

float makeOutputSrgb = float(get_makeOutputSrgb(materialSID, 0));
rt0.rgb = mix(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb);


  // alpha
  rt0.w = alpha;
  rt0.xyz *= alpha; // premultiplied alpha
  // rt0.xyz = vec3(alpha, 0.0, 0.0);

/* shaderity: @{renderTargetEnd} */

}
`,shaderStage:"fragment",isFragmentShader:!0}});var WT,kT=C(()=>{WT={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

// This shader is based on https://github.com/Santarh/MToon


#ifdef RN_IS_SKINNING

fn createMatrixFromQuaternionTranslationScale( quaternion: vec4<f32>, translation: vec3<f32>, scale: vec3<f32> ) -> mat4x4<f32> {
  let q = quaternion;
  let t = translation;

  let sx = q.x * q.x;
  let sy = q.y * q.y;
  let sz = q.z * q.z;
  let cx = q.y * q.z;
  let cy = q.x * q.z;
  let cz = q.x * q.y;
  let wx = q.w * q.x;
  let wy = q.w * q.y;
  let wz = q.w * q.z;

  let mat = mat4x4(
    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,
    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,
    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,
    t.x, t.y, t.z, 1.0
  );

  let uniformScaleMat = mat4x4(
    scale.x, 0.0, 0.0, 0.0,
    0.0, scale.y, 0.0, 0.0,
    0.0, 0.0, scale.z, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  let mat44 = mat*uniformScaleMat;
  return mat44;

}

fn unpackedVec2ToNormalizedVec4(vec_xy: vec2<f32>, criteria: f32) -> vec4<f32> {

  var r: f32;
  var g: f32;
  var b: f32;
  var a: f32;

  let ix = floor(vec_xy.x * criteria);
  let v1x = ix / criteria;
  let v1y = ix - floor(v1x) * criteria;

  r = ( v1x + 1.0 ) / (criteria-1.0);
  g = ( v1y + 1.0 ) / (criteria-1.0);

  let iy = floor( vec_xy.y * criteria);
  let v2x = iy / criteria;
  let v2y = iy - floor(v2x) * criteria;

  b = ( v2x + 1.0 ) / (criteria-1.0);
  a = ( v2y + 1.0 ) / (criteria-1.0);

  r -= 1.0/criteria;
  g -= 1.0/criteria;
  b -= 1.0/criteria;
  a -= 1.0/criteria;

  r = r*2.0-1.0;
  g = g*2.0-1.0;
  b = b*2.0-1.0;
  a = a*2.0-1.0;

  return vec4<f32>(r, g, b, a);
}

fn get_boneMatrixAsMat4x4(skeletalComponentSID: u32, joint: u32) -> mat4x4<f32> {
  let mat43: mat4x3<f32> = get_boneMatrix(skeletalComponentSID, joint);
  return mat4x4<f32>(
    vec4<f32>(mat43[0], 0.0),
    vec4<f32>(mat43[1], 0.0),
    vec4<f32>(mat43[2], 0.0),
    vec4<f32>(mat43[3], 1.0)
  );
}

fn getSkinMatrix(skeletalComponentSID: u32, joint: vec4<u32>, weight: vec4<f32>) -> mat4x4<f32> {

#ifdef RN_BONE_DATA_TYPE_Mat43x1
  var skinMat: mat4x4<f32> = weight.x * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.x);
  skinMat += weight.y * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.y);
  skinMat += weight.z * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.z);
  skinMat += weight.w * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.w);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2)
  let criteria = vec2<f32>(4096.0, 4096.0);

  let tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, joint.x);
  let sq_x = get_boneScalePackedQuat(skeletalComponentSID, joint.x);
  var quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);

  let tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, joint.y);
  let sq_y = get_boneScalePackedQuat(skeletalComponentSID, joint.y);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);

  let tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, joint.z);
  let sq_z = get_boneScalePackedQuat(skeletalComponentSID, joint.z);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);

  let tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, joint.w);
  let sq_w = get_boneScalePackedQuat(skeletalComponentSID, joint.w);
  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);

#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)
  let ts_x = get_boneTranslateScale(skeletalComponentSID, joint.x);
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.x), ts_x.xyz, vec3(ts_x.w));
  let ts_y = get_boneTranslateScale(skeletalComponentSID, joint.y);
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.y), ts_y.xyz, vec3(ts_y.w));
  let ts_z = get_boneTranslateScale(skeletalComponentSID, joint.z);
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.z), ts_z.xyz, vec3(ts_z.w));
  let ts_w = get_boneTranslateScale(skeletalComponentSID, joint.w);
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(
    get_boneQuaternion(skeletalComponentSID, joint.w), ts_w.xyz, vec3(ts_w.w));

#elif defined(RN_BONE_DATA_TYPE_VEC4X1)
  let boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, joint.x);
  let boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, joint.y);
  let boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, joint.z);
  let boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, joint.w);

  let criteria = vec2<f32>(4096.0, 4096.0);
  let boneCompressedInfo = get_boneCompressedInfo(0.0, 0);

  let ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;
  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));
  let ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));
  let ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));
  let ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;
  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(
    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));
#endif
  return skinMat;
}
#endif

fn toNormalMatrix(m: mat4x4<f32>) -> mat3x3<f32> {
  let a00 = m[0][0];
  let a01 = m[0][1];
  let a02 = m[0][2];
  let a03 = m[0][3];
  let a10 = m[1][0];
  let a11 = m[1][1];
  let a12 = m[1][2];
  let a13 = m[1][3];
  let a20 = m[2][0];
  let a21 = m[2][1];
  let a22 = m[2][2];
  let a23 = m[2][3];
  let a30 = m[3][0];
  let a31 = m[3][1];
  let a32 = m[3][2];
  let a33 = m[3][3];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  let determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat3x3<f32>(
    (a11 * b11 - a12 * b10 + a13 * b09) / determinantVal,
    (a12 * b08 - a10 * b11 - a13 * b07) / determinantVal,
    (a10 * b10 - a11 * b08 + a13 * b06) / determinantVal,
    (a02 * b10 - a01 * b11 - a03 * b09) / determinantVal,
    (a00 * b11 - a02 * b08 + a03 * b07) / determinantVal,
    (a01 * b08 - a00 * b10 - a03 * b06) / determinantVal,
    (a31 * b05 - a32 * b04 + a33 * b03) / determinantVal,
    (a32 * b02 - a30 * b05 - a33 * b01) / determinantVal,
    (a30 * b04 - a31 * b02 + a33 * b00) / determinantVal
  );
}

struct GeometoryOutput {
  normalMatrix: mat3x3<f32>,
  position_inWorld: vec4<f32>,
  normal_inWorld: vec3<f32>,
  isSkinning: bool,
}

#ifdef RN_IS_SKINNING
fn skinning(
  skeletalComponentSID: u32,
  inNormalMatrix: mat3x3<f32>,
  inPosition_inLocal: vec3<f32>,
  inNormal_inLocal: vec3<f32>,
  joint: vec4<u32>,
  weight: vec4<f32>,
  ) -> GeometoryOutput
{
  var output: GeometoryOutput;
  let skinMat = getSkinMatrix(skeletalComponentSID, joint, weight);
  output.position_inWorld = skinMat * vec4<f32>(inPosition_inLocal, 1.0);
  output.normalMatrix = toNormalMatrix(skinMat);
  output.normal_inWorld = normalize(output.normalMatrix * inNormal_inLocal);
  output.isSkinning = true;

  return output;
}
#endif


fn processGeometryWithMorphingAndSkinning(
  skeletalComponentSID: i32,
  blendShapeComponentSID: u32,
  worldMatrix: mat4x4<f32>,
  viewMatrix: mat4x4<f32>,
  isBillboard: bool,
  inNormalMatrix: mat3x3<f32>,
  inPosition_inLocal: vec3<f32>,
  inNormal_inLocal: vec3<f32>,
  baryCentricCoord: vec4<f32>,
  joint: vec4<u32>,
  weight: vec4<f32>,
) -> GeometoryOutput {
  var output: GeometoryOutput;

  var position_inLocal: vec3<f32>;
#ifdef RN_IS_MORPHING
  if (uniformDrawParameters.morphTargetNumber == 0u) {
#endif
    position_inLocal = inPosition_inLocal;
#ifdef RN_IS_MORPHING
  } else {
    let vertexIdx = u32(baryCentricCoord.w);
    position_inLocal = get_position(vertexIdx, inPosition_inLocal, blendShapeComponentSID);
  }
#endif

  var worldMatrixInner = worldMatrix;

#ifdef RN_IS_SKINNING
  if (skeletalComponentSID >= 0) {
    output = skinning(u32(skeletalComponentSID), inNormalMatrix, position_inLocal, inNormal_inLocal, joint, weight);
  } else {
#endif
    output.normalMatrix = inNormalMatrix;
    output.position_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);
    output.normal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);
    output.isSkinning = false;
#ifdef RN_IS_SKINNING
  }
#endif

  return output;
}


// #param outlineWidthMode: i32; // initialValue=0
// #param outlineWidthFactor: f32; // initialValue=0.0008
@group(1) @binding(0) var outlineWidthTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(0) var outlineWidthSampler: sampler;

@vertex
fn main(
#ifdef RN_USE_INSTANCE
  @location(8) instance_ids: vec4<f32>,
#endif


#ifdef RN_USE_POSITION_FLOAT
  @location(0) position: vec3<f32>,
#endif
#ifdef RN_USE_POSITION_INT
  @location(0) position: vec3<i32>,
#endif
#ifdef RN_USE_POSITION_UINT
  @location(0) position: vec3<u32>,
#endif

#ifdef RN_USE_NORMAL
  @location(1) normal: vec3<f32>,
#endif
#ifdef RN_USE_TANGENT
  @location(2) tangent: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_0
  @location(3) texcoord_0: vec2<f32>,
#endif
#ifdef RN_USE_TEXCOORD_1
  @location(4) texcoord_1: vec2<f32>,
#endif

#ifdef RN_USE_COLOR_0_FLOAT
  @location(5) color_0: vec4<f32>,
#endif
#ifdef RN_USE_COLOR_0_INT
  @location(5) color_0: vec4<i32>,
#endif
#ifdef RN_USE_COLOR_0_UINT
  @location(5) color_0: vec4<u32>,
#endif

#ifdef RN_USE_JOINTS_0
  @location(6) joints_0: vec4<u32>,
#endif
#ifdef RN_USE_WEIGHTS_0
  @location(7) weights_0: vec4<f32>,
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
  @location(10) baryCentricCoord: vec4<f32>,
#endif
#ifdef RN_USE_TEXCOORD_2
  @location(11) texcoord_2: vec2<f32>,
#endif
  @builtin(vertex_index) vertexIdx : u32,


) -> VertexOutput {
  var output : VertexOutput;
  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_NONE
      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);
      return output;
    #endif
  #endif

#ifdef RN_USE_NORMAL
#else
  let normal = vec3<f32>(0.0, 0.0, 0.0);
#endif

#ifdef RN_USE_JOINTS_0
  let joint = joints_0;
#else
  let joint = vec4<u32>(0, 0, 0, 0);
#endif
#ifdef RN_USE_WEIGHTS_0
  let weight = weights_0;
#else
  let weight = vec4<f32>(0.0, 0.0, 0.0, 0.0);
#endif
#ifdef RN_USE_BARY_CENTRIC_COORD
#else
  let baryCentricCoord = vec4<f32>(0.0, 0.0, 0.0, 0.0);
#endif

let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  let instanceId = u32(instance_ids.x);
  let worldMatrix = get_worldMatrix(instanceId);
  let normalMatrix = get_normalMatrix(instanceId);
  let viewMatrix = get_viewMatrix(cameraSID, 0);
  let skeletalComponentSID = i32(instance_ids.y);
  let blendShapeComponentSID = u32(instance_ids.z);
  let geom = processGeometryWithMorphingAndSkinning(
    skeletalComponentSID,
    blendShapeComponentSID,
    worldMatrix,
    viewMatrix,
    false,
    normalMatrix,
    position,
    normal,
    baryCentricCoord,
    joint,
    weight
  );

  let projectionMatrix = get_projectionMatrix(cameraSID, 0);

  output.position_inWorld = geom.position_inWorld.xyz;
  output.normal_inWorld = geom.normal_inWorld;
  output.normal_inView = (viewMatrix * vec4(geom.normal_inWorld, 0.0)).xyz;

#ifdef RN_MTOON_IS_OUTLINE
  let outlineWidthType = get_outlineWidthMode(materialSID, 0);
  if (outlineWidthType == 0) { // 0 ("none")
    output.position = projectionMatrix * viewMatrix * geom.position_inWorld;
  } else {
    let worldNormalLength = length(normalMatrix * normal);
    let outlineWidthFactor = get_outlineWidthFactor(materialSID, 0);
    var outlineOffset = outlineWidthFactor * worldNormalLength * geom.normal_inWorld;

    let textureSize = textureDimensions(outlineWidthTexture, 0);
    let outlineWidthMultiply = textureLoad(outlineWidthTexture, vec2u(vec2f(textureSize) * texcoord_0), 0).r;
    outlineOffset *= outlineWidthMultiply;

    if (outlineWidthType == 2) { // "screenCoordinates"
      let vViewPosition = viewMatrix * geom.position_inWorld;
      outlineOffset *= abs(vViewPosition.z) / projectionMatrix[1].y;
    }
    output.position = projectionMatrix * viewMatrix * vec4(geom.position_inWorld.xyz + outlineOffset, 1.0);
    output.position.z += 0.000001 * output.position.w;
  }
#else
  output.position = projectionMatrix * viewMatrix * geom.position_inWorld;
#endif

#ifdef RN_USE_TANGENT
  output.tangent_inWorld = normalMatrix * tangent.xyz;
  output.binormal_inWorld = cross(geom.normal_inWorld, output.tangent_inWorld) * tangent.w;
#endif

#ifdef RN_USE_TEXCOORD_0
  output.texcoord_0 = texcoord_0;
#endif
#ifdef RN_USE_TEXCOORD_1
  output.texcoord_1 = texcoord_1;
#endif
#ifdef RN_USE_TEXCOORD_2
  output.texcoord_2 = texcoord_2;
#endif

#ifdef RN_USE_BARY_CENTRIC_COORD
  output.baryCentricCoord = baryCentricCoord.xyz;
#endif

  output.instanceInfo = instance_ids.x;

  return output;
}
`,shaderStage:"vertex",isFragmentShader:!1}});var XT,QT=C(()=>{XT={code:`/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) instanceInfo : f32,
  @location(10) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;
const kEps: f32 = 1e-4;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturate(x: f32) -> f32 {
  return clamp(x, 0.0, 1.0);
}

fn saturateVec3f(v: vec3f) -> vec3f {
  return vec3f(saturate(v.x), saturate(v.y), saturate(v.z));
}

fn saturateEpsilonToOne(x: f32) -> f32 {
  return clamp(x, Epsilon, 1.0);
}

fn saturateEpsilonToOneVec3f(v: vec3f) -> vec3f {
  return vec3f(saturateEpsilonToOne(v.x), saturateEpsilonToOne(v.y), saturateEpsilonToOne(v.z));
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

const EPS_COL: f32 = 0.00001;

struct Light {
  lightType: i32, // 0 = directional, 1 = point, 2 = spot
  position: vec3<f32>,
  intensity: vec3<f32>,
  attenuatedIntensity: vec3<f32>,
  directionOfLightObject: vec3<f32>,
  direction: vec3<f32>, // direction of light vector, equal to normalize(light.pointToLight)
  pointToLight: vec3<f32>, // not normalized
  innerConeCos: f32,
  outerConeCos: f32,
  effectiveRange: f32,
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
fn getRangeAttenuation(light: Light) -> f32
{
  let distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
fn getSpotAttenuation(light: Light) -> f32
{
  let actualCos = dot(light.direction, -light.directionOfLightObject);
  if (actualCos > light.outerConeCos) {
    if (actualCos < light.innerConeCos) {
      let attenuation = (actualCos - light.outerConeCos) / (light.innerConeCos - light.outerConeCos);
      return attenuation * attenuation;
    }
    return 1.0;
  }
  return 0.0;
}

fn getLightAttenuated(light: Light) -> Light {
  var newLight: Light = light;
  newLight.attenuatedIntensity = light.intensity;
  // if (light.lightType == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light && Spot Light
  if (light.lightType != 0)
  {
    newLight.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot Light
  if (light.lightType == 2)
  {
    newLight.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return newLight;
}

fn getLight(lightIdx: u32, v_position_inWorld: vec3<f32>) -> Light {
  let lightPosition: vec3<f32> = get_lightPosition(0u, lightIdx);
  let direction_and_w_of_LightObject: vec3<f32> = get_lightDirection(0u, lightIdx);
  let lightIntensity: vec3<f32> = get_lightIntensity(0u, lightIdx);
  let lightProperty: vec4<f32> = get_lightProperty(0u, lightIdx);
  var light: Light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  let lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.innerConeCos = lightProperty.z;
  light.outerConeCos = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3f(0.0);
    light.lightType = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.lightType = 1;
  } else { // is Directional Light
    light.lightType = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.lightType = 2;
  }

  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  let newLight = getLightAttenuated(light);

  return newLight;
}

#ifdef RN_USE_TANGENT
  fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
    let tangent_inWorld = normalize(input.tangent_inWorld);
    let binormal_inWorld = normalize(input.binormal_inWorld);
    let tbnMat_tangent_to_world = mat3x3<f32>(tangent_inWorld, binormal_inWorld, normal_inWorld);

    return tbnMat_tangent_to_world;
  }
#else
    // This is based on http://www.thetenthplanet.de/archives/1180
    fn cotangent_frame(normal_inWorld: vec3f, position: vec3f, uv_: vec2f, isFront: bool) -> mat3x3<f32> {
      var uv: vec2f;
      if (isFront) {
        uv = uv_;
      } else {
        uv = -uv_;
      }

      // get edge vectors of the pixel triangle
      let dp1 = dpdx(position);
      let dp2 = -dpdy(position); // Because the Y direction of the window coordinate system is different from that of WebGL, this one is set to minus to make the result match the WebGL version.
      let duv1 = dpdx(uv);
      let duv2 = -dpdy(uv); // Because the Y direction of the window coordinate system is different from that of WebGL, this one is set to minus to make the result match the WebGL version.

      // solve the linear system
      let dp2perp = cross(dp2, normal_inWorld);
      let dp1perp = cross(normal_inWorld, dp1);
      let tangent = dp2perp * duv1.x + dp1perp * duv2.x;
      var bitangent = dp2perp * duv1.y + dp1perp * duv2.y;
      bitangent *= -1.0;

      // construct a scale-invariant frame
      let invMat = 1.0 / sqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));
      return mat3x3<f32>(tangent * invMat, bitangent * invMat, normal_inWorld);
    }

    fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
      let tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord, isFront);

      return tbnMat_tangent_to_world;
    }
#endif

// This file includes portions of code from the glTF-Sample-Renderer project by Khronos Group (Apache License 2.0).
// https://github.com/KhronosGroup/glTF-Sample-Renderer
// Modified by Yuki Shimada

fn srgbToLinear(srgbColor: vec3f) -> vec3f {
  return pow(srgbColor, vec3f(2.2));
}

fn linearToSrgb(linearColor: vec3f) -> vec3f {
  return pow(linearColor, vec3f(1.0/2.2));
}

// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66
fn Schlick_to_F0_F90(f: vec3f, f90: vec3f, VdotH: f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0_F90_F32(f: f32, f90: f32, VdotH: f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0(f: vec3f, VdotH: f32) -> vec3f {
    return Schlick_to_F0_F90(f, vec3(1.0), VdotH);
}

fn Schlick_to_F0_F32(f: f32, VdotH: f32) -> f32 {
    return Schlick_to_F0_F90_F32(f, 1.0, VdotH);
}


// The Schlick Approximation to Fresnel
fn fresnelSchlick(f0 : vec3f, f90 : vec3f, VdotH : f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnelSchlickF32(f0 : f32, f90 : f32, VdotH : f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnelSchlick2(f0: vec3f, VdotH: f32) -> vec3f
{
  let f90 = vec3f(1.0); //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelSchlick(f0, f90, VdotH);
}

fn fresnel2F32(f0: f32, VdotH: f32) -> f32
{
  let f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelSchlickF32(f0, f90, VdotH);
}

// Roughness Dependent Fresnel
// https://www.jcgt.org/published/0008/01/03/paper.pdf
fn fresnelSchlickRoughness(F0: vec3f, cosTheta: f32, roughness: f32) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);
  return k_S;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf
fn BRDF_lambertian(diffuseAlbedo: vec3f) -> vec3f
{
  return diffuseAlbedo * RECIPROCAL_PI;
}


// GGX NDF
fn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {
  let roughnessSqr = alphaRoughness * alphaRoughness;
  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
fn v_GGXCorrelated(NL: f32, NV: f32, alphaRoughness: f32) -> f32 {
  let a2 = alphaRoughness * alphaRoughness;
  let GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  let GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  let GGX = GGXV + GGXL;
  if (GGX > 0.0) {
    return clamp(0.5 / GGX, 0.0, 1.0);
  }
  return 1.0;
}

fn BRDF_specularGGX(NH: f32, NL: f32, NV: f32, alphaRoughness: f32) -> vec3f {
  let D = d_GGX(NH, alphaRoughness);
  let V = v_GGXCorrelated(NL, NV, alphaRoughness);
  return vec3f(D) * vec3f(V);
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
fn envBRDFApprox( Roughness: f32, NoV: f32 ) -> vec2f {
  let c0 = vec4f(-1, -0.0275, -0.572, 0.022 );
  let c1 = vec4f(1, 0.0425, 1.04, -0.04 );
  let r = Roughness * c0 + c1;
  let a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  let AB = vec2f( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}


// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes
fn specular_btdf(alphaRoughness: f32, NdotL: f32, NdotV: f32, NdotHt: f32) -> f32 {
  let V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  let D = d_GGX(NdotHt, alphaRoughness);
  return V * D;
}

fn IsotropicNDFFiltering(normal: vec3f, roughness2: f32) -> f32 {
  let SIGMA2 = 0.15915494;
  let KAPPA = 0.18;
  let dndu  = dpdx(normal);
  let dndv = dpdy(normal);
  let kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));
  let clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);
  let filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);
  return filteredRoughness2;
}

////////////////////////////////////////
// glTF KHR_materials_transmission
////////////////////////////////////////

#ifdef RN_USE_TRANSMISSION

// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
fn volumeAttenuation(attenuationColor: vec3f, attenuationDistance: f32, intensity: vec3f, transmissionDistance: f32) -> vec3f
{
  if (attenuationDistance == 0.0) { // means Infinite distance
    return intensity; // No attenuation
  } else {
    // let attenuationCo: vec3f = -log(attenuationColor) / attenuationDistance;
    // let attenuatedTransmittance: vec3f = exp(-attenuationCo * transmissionDistance);
    let attenuatedTransmittance: vec3f = pow(attenuationColor, vec3f(transmissionDistance / attenuationDistance));
    return intensity * attenuatedTransmittance;
  }
}

// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer
fn getVolumeTransmissionRay(n: vec3f, v: vec3f, thickness: f32, ior: f32, instanceInfo: u32) -> vec3f
{
  let refractionVector = refract(-v, normalize(n), 1.0 / ior);
  let worldMatrix = get_worldMatrix(instanceInfo);

  var modelScale: vec3f;
  modelScale.x = length(vec3f(worldMatrix[0].xyz));
  modelScale.y = length(vec3f(worldMatrix[1].xyz));
  modelScale.z = length(vec3f(worldMatrix[2].xyz));

  return normalize(refractionVector) * thickness * modelScale;
}
#endif

fn applyIorToRoughness(roughness: f32, ior: f32) -> f32
{
    return clamp(roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0), c_MinRoughness, 1.0);
}

fn calculateRadianceTransmission(normal: vec3f, view: vec3f, pointToLight: vec3f, alphaRoughness: f32, baseColor: vec3f, ior: f32) -> vec3f
{
    let transmissionRoughness = applyIorToRoughness(alphaRoughness, ior);

    let n = normalize(normal);
    let v = normalize(view);
    let l = normalize(pointToLight);
    let mirrorL = normalize(l + 2.0 * n * dot(-l, n));
    let h = normalize(mirrorL + v);

    let D = d_GGX(clamp(dot(n, h), 0.0, 1.0), transmissionRoughness);
    let V = v_GGXCorrelated(clamp(dot(n, mirrorL), 0.0, 1.0), clamp(dot(n, v), 0.0, 1.0), transmissionRoughness);

    return baseColor * D * V;
}




////////////////////////////////////////
// glTF KHR_materials_anisotropy
////////////////////////////////////////
#ifdef RN_USE_ANISOTROPY
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
fn D_GGX_anisotropic(NdotH: f32, TdotH: f32, BdotH: f32, at: f32, ab: f32) -> f32
{
    let a2 = at * ab;
    let f = vec3f(ab * TdotH, at * BdotH, a2 * NdotH);
    let w2 = a2 / dot(f, f);
    return a2 * w2 * w2 / M_PI;
}

fn V_GGX_anisotropic(NdotL: f32, NdotV: f32, BdotV: f32, TdotV: f32, TdotL: f32, BdotL: f32,
    at: f32, ab: f32) -> f32
{
    let GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));
    let GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));
    let GGX = GGXV + GGXL;
    if (GGX > 0.0) {
      return clamp(0.5 / GGX, 0.0, 1.0);
    }
    return 1.0;
}

fn BRDF_specularAnisotropicGGX(alphaRoughness: f32,
    VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32, BdotV: f32, TdotV: f32,
    TdotL: f32, BdotL: f32, TdotH: f32, BdotH: f32, anisotropy: f32) -> vec3f
{
    let at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
    let ab = clamp(alphaRoughness, 0.001, 1.0);

    let V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);
    let D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);

    return vec3f(V * D);
}
#endif

////////////////////////////////////////
// glTF KHR_materials_sheen
////////////////////////////////////////

#ifdef RN_USE_SHEEN
fn d_Charlie(sheenPerceptualRoughness: f32, NoH: f32) -> f32 {
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  let sheenRoughness = max(sheenPerceptualRoughness, 0.000001);
  let alphaG = sheenRoughness * sheenRoughness;
  let invAlpha  = 1.0 / alphaG;
  let cos2h = NoH * NoH;
  let sin2h = 1.0 - cos2h;
  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * M_PI);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn sheenSimpleVisibility(NdotL: f32, NdotV: f32) -> f32 {
  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn charlieL(x: f32, alphaG: f32) -> f32 {
  let oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
  let a = mix(21.5473, 25.3245, oneMinusAlphaSq);
  let b = mix(3.82987, 3.32435, oneMinusAlphaSq);
  let c = mix(0.19823, 0.16801, oneMinusAlphaSq);
  let d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
  let e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
  return a / (1.0 + b * pow(x, c)) + d * x + e;
}

fn lambdaSheen(cosTheta: f32, alphaG: f32) -> f32
{
  return select(exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG)), exp(charlieL(cosTheta, alphaG)), abs(cosTheta) < 0.5);
}

fn sheenCharlieVisibility(NdotL: f32, NdotV: f32, sheenPerceptualRoughness: f32) -> f32 {
  let sheenRoughness = max(sheenPerceptualRoughness, 0.000001);
  let alphaG = sheenRoughness * sheenRoughness;
  let sheenVisibility = clamp(1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL)), 0.0, 1.0);
  return sheenVisibility;
}

fn BRDF_specularSheen(sheenColor: vec3f, sheenPerceptualRoughness: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f {
  let sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);
  let sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);
  return sheenColor * sheenDistribution * sheenVisibility;
}
#endif // RN_USE_SHEEN

////////////////////////////////////////
// glTF KHR_materials_irirdescence
////////////////////////////////////////

#ifdef RN_USE_IRIDESCENCE
// XYZ to REC709(sRGB) conversion matrix
const XYZ_TO_REC709 = mat3x3<f32>(
     3.2404542, -0.9692660,  0.0556434,
    -1.5371385,  1.8760108, -0.2040259,
    -0.4985314,  0.0415560,  1.0572252
);

fn fresnelSchlickRoughnessWithIridescence(
  F0: vec3f, cosTheta: f32, roughness: f32,
  iridescenceFresnel: vec3f, iridescence: f32
  ) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);
  return k_S;
}

// Assume air interface for top
fn Fresnel0ToIor(F0: vec3f) -> vec3f {
    let sqrtF0 = sqrt(F0);
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// Conversion from IOR to F0
// ior is a value between 1.0 and 3.0. 1.0 is air interface
fn IorToFresnel0Vec3f(transmittedIor: vec3f, incidentIor: f32) -> vec3f {
    return sqVec3f((transmittedIor - vec3f(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
fn IorToFresnel0F32(transmittedIor: f32, incidentIor: f32) -> f32 {
    return sqF32((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration
 */
fn evalSensitivity(OPD: f32, shift: vec3f) -> vec3f {
    let phase = 2.0 * M_PI * OPD * 1.0e-9;
    let val = vec3f(5.4856e-13, 4.4201e-13, 5.2481e-13);
    let pos = vec3f(1.6810e+06, 1.7953e+06, 2.2084e+06);
    let var_ = vec3f(4.3278e+09, 9.3046e+09, 6.6121e+09);

    var xyz = val * sqrt(2.0 * M_PI * var_) * cos(pos * phase + shift) * exp(-(phase * phase) * var_);
    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));
    xyz /= 1.0685e-7;

    let rgb = XYZ_TO_REC709 * xyz;
    return rgb;
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel
 */
fn calcIridescence(outsideIor: f32, eta2: f32, cosTheta1: f32, thinFilmThickness: f32, baseF0: vec3f) -> vec3f {


  // iridescenceIor is the index of refraction of the thin-film layer
  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
  let iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));

  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)
  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.
  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.
  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):
  let sinTheta2Sq = sqF32(outsideIor / iridescenceIor) * (1.0 - sqF32(cosTheta1));
  let cosTheta2Sq = 1.0 - sinTheta2Sq;

  // Handle total internal reflection
  if (cosTheta2Sq < 0.0) {
      return vec3f(1.0);
  }

  let cosTheta2 = sqrt(cosTheta2Sq);

  /// Material Interfaces
  // The iridescence model defined by Belcour/Barla models two material interfaces
  // - one from the outside to the thin-film layer
  // and another one from the thin-film to the base material. These two interfaces are defined as follows:

  // First interface (from the outside to the thin-film layer)
  let R0 = IorToFresnel0F32(iridescenceIor, outsideIor);
  let R12 = fresnel2F32(R0, cosTheta1);
  let R21 = R12;
  let T121 = 1.0 - R12;

  // Second interface (from the thin-film to the base material)
  let baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0
  let R1 = IorToFresnel0Vec3f(baseIor, iridescenceIor);
  let R23 = fresnelSchlick2(R1, cosTheta2);

  // phi12 and phi23 define the base phases per interface and are approximated with 0.0
  // if the IOR of the hit material (iridescenceIor or baseIor) is higher
  // than the IOR of the previous material (outsideIor or iridescenceIor) and \u03C0 otherwise.
  // Also here, polarization is ignored.  float phi12 = 0.0;

  // First interface (from the outside to the thin-film layer)
  var phi12 = 0.0;
  if (iridescenceIor < outsideIor) { phi12 = M_PI; }
  let phi21 = M_PI - phi12;

  // Second interface (from the thin-film to the base material)
  var phi23 = vec3f(0.0);
  if (baseIor[0] < iridescenceIor) { phi23[0] = M_PI; }
  if (baseIor[1] < iridescenceIor) { phi23[1] = M_PI; }
  if (baseIor[2] < iridescenceIor) { phi23[2] = M_PI; }

  // OPD (optical path difference)
  let OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
  // Phase shift
  let phi = vec3f(phi21) + phi23;

  // Compound terms
  let R123 = clamp(R12 * R23, vec3f(1e-5), vec3f(0.9999));
  let r123 = sqrt(R123);
  let Rs = (T121 * T121) * R23 / (vec3f(1.0) - R123);

  // Reflectance term for m = 0 (DC term amplitude)
  let C0 = R12 + Rs;
  var I = C0;

  // Reflectance term for m > 0 (pairs of diracs)
  var Cm = Rs - T121;
  for (var m = 1; m <= 2; m++)
  {
      Cm *= r123;
      let Sm = 2.0 * evalSensitivity(f32(m) * OPD, f32(m) * phi);
      I += Cm * Sm;
  }

  let F_iridescence = max(I, vec3f(0.0));

  return F_iridescence;
}

//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB
fn BRDF_lambertianIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, iridescenceFactor: f32, diffuseColor: vec3f, specularWeight: f32, VdotH: f32) -> vec3f
{
    let iridescenceFresnelMax = vec3f(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));

    let schlickFresnel = Schlick_to_F0_F90(f0, f90, VdotH);

    let F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);

    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);
}

fn BRDF_specularGGXIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, alphaRoughness: f32, iridescenceFactor: f32, specularWeight: f32, VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f
{
    let F = mix(Schlick_to_F0_F90(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);
    let Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
    let D = d_GGX(NdotH, alphaRoughness);

    return specularWeight * F * Vis * D;
}

fn rgb_mix(base: vec3f, specular_brdf: vec3f, rgb_alpha: vec3f) -> vec3f
{
    let rgb_alpha_max = max(rgb_alpha.r, max(rgb_alpha.g, rgb_alpha.b));
    return (1.0 - rgb_alpha_max) * base + rgb_alpha * specular_brdf;
}

#endif // RN_USE_IRIDESCENCE


////////////////////////////////////////
// lighting with a punctual light
////////////////////////////////////////
fn lightingWithPunctualLight(
  light_: Light,
  normal_inWorld: vec3f,
  viewDirection: vec3f,
  NdotV: f32,
  baseColor: vec3f,
  perceptualRoughness: f32,
  metallic: f32,
  dielectricF0: vec3f,
  dielectricF90: vec3f,
  transmission: f32,
  thickness: f32,
  ior: f32,
  clearcoat: f32,
  clearcoatRoughness: f32,
  clearcoatF0: vec3f,
  clearcoatF90: vec3f,
  clearcoatFresnel: vec3f,
  clearcoatNormal_inWorld: vec3f,
  VdotNc: f32,
  attenuationColor: vec3f,
  attenuationDistance: f32,
  anisotropy: f32,
  anisotropicT: vec3f,
  anisotropicB: vec3f,
  BdotV: f32,
  TdotV: f32,
  sheenColor: vec3f,
  sheenRoughness: f32,
  albedoSheenScalingNdotV: f32,
  iridescence: f32,
  iridescenceFresnel_dielectric: vec3f,
  iridescenceFresnel_metal: vec3f,
  specularWeight: f32,
  instanceInfo: u32,
  diffuseTransmission: f32,
  diffuseTransmissionColor: vec3f,
  diffuseTransmissionThickness: f32
  ) -> vec3f
{
  var light = light_;
  let alphaRoughness = perceptualRoughness * perceptualRoughness;

  // Fresnel
  let halfVector = normalize(light.direction + viewDirection);
  let VdotH = saturate(dot(viewDirection, halfVector));
  var dielectricFresnel = fresnelSchlick(dielectricF0, dielectricF90, VdotH);
  let metalFresnel = fresnelSchlick(baseColor, vec3f(1.0), VdotH);

  let NdotL = saturateEpsilonToOne(dot(normal_inWorld, light.direction));

  // Diffuse
  let diffuseBrdf = BRDF_lambertian(baseColor);
  var diffuseContrib = diffuseBrdf * vec3f(NdotL) * light.attenuatedIntensity;

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  diffuseContrib = diffuseContrib * (vec3f(1.0) - diffuseTransmission);
  if (dot(normal_inWorld, light.direction) < 0.0) {
    let diffuseNdotL = saturate(dot(normal_inWorld, -light.direction));
    var diffuseBtdf = BRDF_lambertian(diffuseTransmissionColor) * vec3f(diffuseNdotL) * light.attenuatedIntensity;
    let mirrorL = normalize(light.direction + 2.0 * normal_inWorld * dot(normal_inWorld, -light.direction));
    let diffuseVdotH = saturate(dot(viewDirection, normalize(mirrorL + viewDirection)));
    dielectricFresnel = fresnelSchlick(dielectricF0 * specularWeight, dielectricF90, abs(diffuseVdotH));
#ifdef RN_USE_VOLUME
    diffuseBtdf = volumeAttenuation(attenuationColor, attenuationDistance, diffuseBtdf, diffuseTransmissionThickness);
#endif // RN_USE_VOLUME
    diffuseContrib += diffuseBtdf * diffuseTransmission;
  }
#endif // RN_USE_DIFFUSE_TRANSMISSION

#ifdef RN_USE_TRANSMISSION
  let transmittionRay = getVolumeTransmissionRay(normal_inWorld, viewDirection, thickness, ior, instanceInfo);
  light.pointToLight -= transmittionRay;
  light.direction = normalize(light.pointToLight);
  var transmittedContrib = calculateRadianceTransmission(normal_inWorld, viewDirection, light.direction, alphaRoughness, baseColor, ior) * light.attenuatedIntensity;

#ifdef RN_USE_VOLUME
  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittionRay));
#endif // RN_USE_VOLUME

  diffuseContrib = mix(diffuseContrib, vec3f(transmittedContrib), transmission);
#endif // RN_USE_TRANSMISSION

  // Specular
  let NdotH = saturate(dot(normal_inWorld, halfVector));

#ifdef RN_USE_ANISOTROPY
  let TdotL = dot(anisotropicT, light.direction);
  let BdotL = dot(anisotropicB, light.direction);
  let TdotH = dot(anisotropicT, halfVector);
  let BdotH = dot(anisotropicB, halfVector);
  let specularMetalContrib = BRDF_specularAnisotropicGGX(alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3f(NdotL) * light.attenuatedIntensity;
  let specularDielectricContrib = specularMetalContrib;
#else
  let specularMetalContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, alphaRoughness) * vec3f(NdotL) * light.attenuatedIntensity;
  let specularDielectricContrib = specularMetalContrib;
#endif

  // Base Layer
  var metal = specularMetalContrib * metalFresnel;
  var dielectric = mix(diffuseContrib, specularDielectricContrib, dielectricFresnel);

#ifdef RN_USE_IRIDESCENCE
  metal = mix(metal, specularMetalContrib * iridescenceFresnel_metal, iridescence);
  dielectric = mix(dielectric, rgb_mix(diffuseContrib, specularDielectricContrib, iridescenceFresnel_dielectric), iridescence);
#endif // RN_USE_IRIDESCENCE

#ifdef RN_USE_CLEARCOAT
  // Clear Coat Layer
  let NdotHc = saturate(dot(clearcoatNormal_inWorld, halfVector));
  let LdotNc = saturate(dot(light.direction, clearcoatNormal_inWorld));
  let clearcoatContrib = BRDF_specularGGX(NdotHc, LdotNc, VdotNc, clearcoatRoughness * clearcoatRoughness) * vec3f(LdotNc) * light.attenuatedIntensity;
#else
  let clearcoatContrib = vec3f(0.0);
#endif // RN_USE_CLEARCOAT

#ifdef RN_USE_SHEEN
  // Sheen
  let sheenContrib = BRDF_specularSheen(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;
  let albedoSheenScaling = min(
    albedoSheenScalingNdotV,
    1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotL, sheenRoughness)).r);
#else
  let sheenContrib = vec3f(0.0);
  let albedoSheenScaling = 1.0;
#endif // RN_USE_SHEEN

  var color = mix(dielectric, metal, metallic);
  color = sheenContrib + color * albedoSheenScaling;
  color = mix(color, clearcoatContrib, clearcoat * clearcoatFresnel);

  return color;
}


// #param baseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)
@group(1) @binding(1) var baseColorTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(1) var baseColorSampler: sampler;
// #param baseColorTexcoordIndex: f32; // initialValue=0
// #param baseColorTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param baseColorTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param baseColorTextureTransformRotation: f32; // initialValue=0

@group(1) @binding(2) var normalTexture: texture_2d<f32>; // initialValue=black
@group(2) @binding(2) var normalSampler: sampler;
// #param normalTexcoordIndex: f32; // initialValue=0
// #param normalTextureTransformScale: vec2<f32>; // initialValue=(1,1)
// #param normalTextureTransformOffset: vec2<f32>; // initialValue=(0,0)
// #param normalTextureTransformRotation: f32; // initialValue=0
// #param normalScale: f32; // initialValue=1

// #param shadingShiftFactor: f32; // initialValue=0.0
@group(1) @binding(3) var shadingShiftTexture: texture_2d<f32>; // initialValue=black
@group(2) @binding(3) var shadingShiftSampler: sampler;
// #param shadingShiftTexcoordIndex: f32; // initialValue=0
// #param shadingShiftTextureScale: f32; // initialValue=1.0

// #param shadingToonyFactor: f32; // initialValue=0.9
// #param shadeColorFactor: vec3<f32>; // initialValue=(0,0,0)
@group(1) @binding(4) var shadeMultiplyTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(4) var shadeMultiplySampler: sampler;
// #param shadeMultiplyTexcoordIndex: f32; // initialValue=0

@group(1) @binding(16) var diffuseEnvTexture: texture_cube<f32>; // initialValue=black, isInternalSetting=true
@group(2) @binding(16) var diffuseEnvSampler: sampler;
@group(1) @binding(17) var specularEnvTexture: texture_cube<f32>; // initialValue=black, isInternalSetting=true
@group(2) @binding(17) var specularEnvSampler: sampler;

// #param giEqualizationFactor: f32; // initialValue=0.9

@group(1) @binding(5) var matcapTexture: texture_2d<f32>; // initialValue=black
@group(2) @binding(5) var matcapSampler: sampler;
// #param matcapFactor: vec3<f32>; // initialValue=(1,1,1)
// #param parametricRimColorFactor: vec3<f32>; // initialValue=(0,0,0)
// #param parametricRimFresnelPowerFactor: f32; // initialValue=5.0
// #param parametricRimLiftFactor: f32; // initialValue=0.0
@group(1) @binding(6) var rimMultiplyTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(6) var rimMultiplySampler: sampler;
// #param rimMultiplyTexcoordIndex: f32; // initialValue=0
// #param rimLightingMixFactor: f32; // initialValue=1.0

// #param emissiveFactor: vec3<f32>; // initialValue=(0,0,0)
@group(1) @binding(7) var emissiveTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(7) var emissiveSampler: sampler;
// #param emissiveTexcoordIndex: f32; // initialValue=0

// #param outlineColorFactor: vec3<f32>; // initialValue=(0,0,0)
// #param outlineLightingMixFactor: f32; // initialValue=1.0

@group(1) @binding(8) var uvAnimationMaskTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(8) var uvAnimationMaskSampler: sampler;
// #param uvAnimationMaskTexcoordIndex: f32; // initialValue=0
// #param uvAnimationScrollXSpeedFactor: f32; // initialValue=0.0
// #param uvAnimationScrollYSpeedFactor: f32; // initialValue=0.0
// #param uvAnimationRotationSpeedFactor: f32; // initialValue=0.0

// #param inverseEnvironment: bool; // initialValue=false
// #param iblParameter: vec4<f32>; // initialValue=(1,1,1,1), isInternalSetting=true
// #param hdriFormat: vec2<i32>; // initialValue=(0,0), isInternalSetting=true
// #param alphaCutoff: f32; // initialValue=0.5
// #param makeOutputSrgb: bool; // initialValue=false

// This file includes portions of code from the glTF-Sample-Renderer project by Khronos Group (Apache License 2.0).
// https://github.com/KhronosGroup/glTF-Sample-Renderer
// Modified by Yuki Shimada

fn getIBLIrradiance(normal_forEnv: vec3f, iblParameter: vec4f, hdriFormat: vec2<i32>) -> vec3f {
  let diffuseTexel: vec4f = textureSample(diffuseEnvTexture, diffuseEnvSampler, normal_forEnv);

  var irradiance: vec3f;
  if (hdriFormat.x == 0) {
    // LDR_SRGB
    irradiance = srgbToLinear(diffuseTexel.rgb);
  }
  else if (hdriFormat.x == 3) {
    // RGBE
    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  }
  else {
    irradiance = diffuseTexel.rgb;
  }

  // scale with user parameters
  let IBLDiffuseContribution = iblParameter.y;
  irradiance *= IBLDiffuseContribution;

  return irradiance;
}

fn get_radiance(reflection: vec3f, lod: f32, hdriFormat: vec2<i32>) -> vec3f {
  let specularTexel = textureSampleLevel(specularEnvTexture, specularEnvSampler, reflection, lod);

  var radiance: vec3f;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

#ifdef RN_USE_SHEEN

fn get_radiance_sheen(reflection: vec3f, lod: f32, hdriFormat: vec2<i32>) -> vec3f {
  let specularTexel = textureSampleLevel(sheenEnvTexture, sheenEnvSampler, reflection, lod);

  var radiance: vec3f;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

fn sheenIBL(NdotV: f32, sheenPerceptualRoughness: f32, sheenColor: vec3f, iblParameter: vec4f, reflection: vec3f, hdriFormat: vec2i) -> vec3f
{
  let mipCount = iblParameter.x;
  let lod = (sheenPerceptualRoughness * (mipCount - 1.0));

  let sheenLutUV = vec2f(NdotV, sheenPerceptualRoughness);
  let brdf = textureSample(sheenLutTexture, sheenLutSampler, sheenLutUV).b;
  var sheenLight = get_radiance_sheen(reflection, lod, hdriFormat);
  let IBLSpecularContribution = iblParameter.z;
  sheenLight *= IBLSpecularContribution;

  return sheenLight * sheenColor * brdf;
}
#endif

fn getNormalForEnv(rotEnvMatrix: mat3x3<f32>, normal_inWorld: vec3f, materialSID: u32) -> vec3f {
  var normal_forEnv = rotEnvMatrix * normal_inWorld;
  if (get_inverseEnvironment(materialSID, 0)) {
    normal_forEnv.x *= -1.0;
  }
  return normal_forEnv;
}

fn getReflection(rotEnvMatrix: mat3x3<f32>, viewDirection: vec3f, normal_inWorld: vec3f,
  materialSID: u32, perceptualRoughness: f32,
  anisotropy: f32, anisotropyDirection: vec3f
  ) -> vec3f {
#ifdef RN_USE_ANISOTROPY
  let tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);
  let anisotropicTangent  = cross(anisotropyDirection, viewDirection);
  let anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);
  let bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);
  let bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;
  let bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));
  var reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);
#else
  var reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);
#endif
  if (get_inverseEnvironment(materialSID, 0)) {
    reflection.x *= -1.0;
  }
  return reflection;
}

fn scaleForLod(perceptualRoughness: f32, ior: f32) -> f32
{
  // Scale roughness to the range [0, 1],
  // ior=1.0 will be scale 0,
  // ior=1.5 will be scale 1.0,
  // ior=2 will be scale 1.0 (clamped)
  //

  let scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);
  return perceptualRoughness * scale;
}

#ifdef RN_USE_TRANSMISSION
fn get_sample_from_backbuffer(sampleCoord: vec2f, perceptualRoughness: f32, ior: f32) -> vec3f {
  let vrState: vec2<i32> = get_vrState(0, 0);
  let backBufferTextureSize = vec2f(textureDimensions(backBufferTexture, 0));
  var backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);
  var newSampleCoord = sampleCoord;
  newSampleCoord.y = 1.0 - newSampleCoord.y;
  if (vrState.x == 1) { // For VR
    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
    newSampleCoord.x = sampleCoord.x * 0.5;
    if (vrState.y == 1) { // For right eye
      newSampleCoord.x += 0.5;
    }
  }
  let framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);

  let transmittedLight = textureSampleLevel(backBufferTexture, backBufferSampler, newSampleCoord, framebufferLod).rgb;

  return transmittedLight;
}

fn getIBLVolumeRefraction(baseColor: vec3f, normal: vec3f, view: vec3f, cameraSID: u32, materialSID: u32, thickness: f32, perceptualRoughness: f32, ior: f32, attenuationColor: vec3f, attenuationDistance: f32, position_inWorld: vec3f, instanceInfo: u32) -> vec3f {
#ifdef RN_USE_DISPERSION
  let dispersion = get_dispersion(materialSID, 0);
  let halfSpread = (ior - 1.0) * 0.025 * dispersion;
  let iors = vec3f(ior - halfSpread, ior, ior + halfSpread);

  var transmittedLight: vec3f;
  var transmissionRayLength: f32;
  for(var i=0; i<3; i++) {
    let transmissionRay = getVolumeTransmissionRay(normal, view, thickness, iors[i], instanceInfo);
    transmissionRayLength = length(transmissionRay);
    let refractedRayExit = position_inWorld + transmissionRay;

    let ndcPos = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4f(refractedRayExit, 1.0);
    var refractionCoords = ndcPos.xy / ndcPos.w;
    refractionCoords += 1.0;
    refractionCoords /= 2.0;

    transmittedLight[i] = get_sample_from_backbuffer(refractionCoords, perceptualRoughness, iors[i])[i];
  }
#else
  let transmissionRay = getVolumeTransmissionRay(normal, view, thickness, ior, instanceInfo);
  let transmissionRayLength = length(transmissionRay);
  let refractedRayExit = position_inWorld + transmissionRay;

  let ndcPos = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4f(refractedRayExit, 1.0);
  var refractionCoords = ndcPos.xy / ndcPos.w;
  refractionCoords += 1.0;
  refractionCoords /= 2.0;

  let transmittedLight = get_sample_from_backbuffer(refractionCoords, perceptualRoughness, ior);
#endif
  let attenuatedColor = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, transmissionRayLength);

  return attenuatedColor * baseColor;
}

#endif // RN_USE_TRANSMISSION

struct IblResult
{
  specular: vec3f,
  diffuse: vec3f,
  FssEss: vec3f,
};

fn getIBLRadianceGGX(perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, reflection: vec3f) -> vec3f
{
  // get radiance
  let mipCount = iblParameter.x;
  let lod = (perceptualRoughness * (mipCount - 1.0));
  var radiance: vec3f = get_radiance(reflection, lod, hdriFormat);

  let IBLSpecularContribution = iblParameter.z;
  radiance *= IBLSpecularContribution;

  return radiance;
}

fn getIBLFresnelGGX(perceptualRoughness: f32, NdotV: f32, F0: vec3f, specularWeight: f32) -> vec3f {
  // https://bruop.github.io/ibl/#single_scattering_results

  // Roughness dependent fresnel
  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss: vec3f = vec3f(specularWeight) * (kS * f_ab.x + f_ab.y);

  // Multiple scattering
  let Ems: f32 = (1.0 - (f_ab.x + f_ab.y));
  let F_avg: vec3f = vec3f(specularWeight) * (F0 + (1.0 - F0) / 21.0);
  let FmsEms: vec3f = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);

  return FssEss + FmsEms;
}

fn IBLContribution(materialSID: u32, cameraSID: u32, normal_inWorld: vec3f, NdotV: f32, viewDirection: vec3f,
  baseColor: vec3f, perceptualRoughness: f32,
  clearcoatRoughness: f32, clearcoatNormal_inWorld: vec3f, clearcoat: f32, clearcoatFresnel: vec3f, VdotNc: f32, geomNormal_inWorld: vec3f,
  transmission: f32, position_inWorld: vec3f, instanceInfo: u32, thickness: f32, ior: f32,
  sheenColor: vec3f, sheenRoughness: f32, albedoSheenScalingNdotV: f32,
  iridescenceFresnel_dielectric: vec3f, iridescenceFresnel_metal: vec3f, iridescence: f32,
  anisotropy: f32, anisotropyDirection: vec3f, specularWeight: f32, dielectricF0: vec3f, metallic: f32,
  diffuseTransmission: f32, diffuseTransmissionColor: vec3f, diffuseTransmissionThickness: f32
  ) -> vec3f
{
  let iblParameter: vec4f = get_iblParameter(materialSID, 0);
  let rot = iblParameter.w;
  let rotEnvMatrix = mat3x3<f32>(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  let hdriFormat: vec2<i32> = get_hdriFormat(materialSID, 0);

  let normal_forEnv: vec3f = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  let reflection: vec3f = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);

  // get irradiance
  let irradiance: vec3f = getIBLIrradiance(normal_forEnv, iblParameter, hdriFormat);
  var diffuse: vec3f = irradiance * baseColor;

#ifdef RN_USE_DIFFUSE_TRANSMISSION
  var diffuseTransmissionIBL: vec3f = getIBLIrradiance(-normal_forEnv, iblParameter, hdriFormat) * diffuseTransmissionColor;
#ifdef RN_USE_VOLUME
  diffuseTransmissionIBL = volumeAttenuation(attenuationColor, attenuationDistance, diffuseTransmissionIBL, diffuseTransmissionThickness);
#endif
  diffuse = mix(diffuse, diffuseTransmissionIBL, diffuseTransmission);
#endif

#ifdef RN_USE_TRANSMISSION
  let attenuationColor: vec3f = get_attenuationColor(materialSID, 0);
  let attenuationDistance: f32 = get_attenuationDistance(materialSID, 0);
  let specularTransmission: vec3f = getIBLVolumeRefraction(baseColor, normal_inWorld, viewDirection, cameraSID, materialSID, thickness, perceptualRoughness, ior, attenuationColor, attenuationDistance, position_inWorld, instanceInfo);
  diffuse = mix(diffuse, specularTransmission, transmission);
#endif

  // take account of anisotropy with reflection
  let specularMetal: vec3f = getIBLRadianceGGX(perceptualRoughness, iblParameter, hdriFormat, reflection);
  let specularDielectric: vec3f = specularMetal;

  // Calculate fresnel mix
  let fresnelMetal: vec3f = getIBLFresnelGGX(perceptualRoughness, NdotV, baseColor, 1.0);
  var metalContrib: vec3f = fresnelMetal * specularMetal;
  let fresnelDielectric: vec3f = getIBLFresnelGGX(perceptualRoughness, NdotV, dielectricF0, specularWeight);
  var dielectricContrib: vec3f = mix(diffuse, specularDielectric, fresnelDielectric);

#ifdef RN_USE_IRIDESCENCE
  metalContrib = mix(metalContrib, specularMetal * iridescenceFresnel_metal, iridescence);
  dielectricContrib = mix(dielectricContrib, rgb_mix(diffuse, specularDielectric, iridescenceFresnel_dielectric), iridescence);
#endif

#ifdef RN_USE_CLEARCOAT
  let clearcoatReflection: vec3f = getReflection(rotEnvMatrix, viewDirection, clearcoatNormal_inWorld, materialSID, clearcoatRoughness, 0.0, vec3(0.0));
  let clearcoatContrib: vec3f = getIBLRadianceGGX(clearcoatRoughness, iblParameter, hdriFormat, clearcoatReflection);
#else
  let clearcoatContrib: vec3f = vec3(0.0);
#endif

#ifdef RN_USE_SHEEN
  let sheenContrib: vec3f = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);
  let albedoSheenScaling: f32 = albedoSheenScalingNdotV;
#else
  let sheenContrib: vec3f = vec3(0.0);
  let albedoSheenScaling: f32 = 1.0;
#endif

  var color: vec3f = mix(dielectricContrib, metalContrib, metallic);
  color = sheenContrib + color * albedoSheenScaling;
  color = mix(color, clearcoatContrib, clearcoat * clearcoatFresnel);
  return color;
}



fn linearstep(a: f32, b: f32, t: f32) -> f32 {
  return clamp((t - a) / (b - a), 0.0, 1.0);
}

fn uvAnimation(origUv: vec2f, time: f32, uvAnimMask: f32, uvAnimationScrollXSpeedFactor: f32, uvAnimationScrollYSpeedFactor: f32, uvAnimationRotationSpeedFactor: f32) -> vec2f {
  let scrollX = uvAnimationScrollXSpeedFactor * time;
  let scrollY = uvAnimationScrollYSpeedFactor * time;
  let rotation = uvAnimationRotationSpeedFactor * time;
  let rotationCos = cos(rotation * uvAnimMask);
  let rotationSin = sin(rotation * uvAnimMask);
  var uv = mat2x2f(rotationCos, -rotationSin, rotationSin, rotationCos) * (origUv - vec2f(0.5)) + vec2f(0.5);
  uv += vec2f(scrollX, scrollY) * uvAnimMask;
  return uv;
}

@fragment
fn main (
  input: VertexOutput,
  @builtin(front_facing) isFront: bool
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  // uv animation
  let uvAnimationScrollXSpeedFactor = get_uvAnimationScrollXSpeedFactor(materialSID, 0);
  let uvAnimationScrollYSpeedFactor = get_uvAnimationScrollYSpeedFactor(materialSID, 0);
  let uvAnimationRotationSpeedFactor = get_uvAnimationRotationSpeedFactor(materialSID, 0);
  let uvAnimationMaskTexcoordIndex = u32(get_uvAnimationMaskTexcoordIndex(materialSID, 0));
  let uvAnimationMaskTexcoord = getTexcoord(uvAnimationMaskTexcoordIndex, input);
  let uvAnimMask = textureSample(uvAnimationMaskTexture, uvAnimationMaskSampler, uvAnimationMaskTexcoord).b;
  let time = get_time(0, 0);

  // base color
  let baseColorTextureTransformScale = get_baseColorTextureTransformScale(materialSID, 0);
  let baseColorTextureTransformOffset = get_baseColorTextureTransformOffset(materialSID, 0);
  let baseColorTextureTransformRotation = get_baseColorTextureTransformRotation(materialSID, 0);
  let baseColorTexcoordIndex = u32(get_baseColorTexcoordIndex(materialSID, 0));
  var baseColorTexcoord = getTexcoord(baseColorTexcoordIndex, input);
  baseColorTexcoord = uvAnimation(baseColorTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  let baseColorTexUv = uvTransform(baseColorTextureTransformScale, baseColorTextureTransformOffset, baseColorTextureTransformRotation, baseColorTexcoord);
  var baseColorTexture = textureSample(baseColorTexture, baseColorSampler, baseColorTexUv);
  baseColorTexture = vec4(srgbToLinear(baseColorTexture.rgb), baseColorTexture.a);
  let baseColorFactor = get_baseColorFactor(materialSID, 0);
  let baseColorTerm = baseColorTexture.rgb * baseColorFactor.rgb;

  // shade color
  let shadeColorFactor = get_shadeColorFactor(materialSID, 0);
  let shadeMultiplyTexcoordIndex = u32(get_shadeMultiplyTexcoordIndex(materialSID, 0));
  var shadeMultiplyTexcoord = getTexcoord(shadeMultiplyTexcoordIndex, input);
  shadeMultiplyTexcoord = uvAnimation(shadeMultiplyTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  var shadeMultiplyTexture = textureSample(shadeMultiplyTexture, shadeMultiplySampler, shadeMultiplyTexcoord);
  shadeMultiplyTexture = vec4(srgbToLinear(shadeMultiplyTexture.rgb), shadeMultiplyTexture.a);
  let shadeColorTerm = shadeColorFactor * shadeMultiplyTexture.rgb;

  // shading shift
  let shadingShiftTexcoordIndex = u32(get_shadingShiftTexcoordIndex(materialSID, 0));
  var shadingShiftTexcoord = getTexcoord(shadingShiftTexcoordIndex, input);
  shadingShiftTexcoord = uvAnimation(shadingShiftTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  var shadingShiftTexture = textureSample(shadingShiftTexture, shadingShiftSampler, shadingShiftTexcoord).r;
  let shadingShiftTextureScale = get_shadingShiftTextureScale(materialSID, 0);

  // emissive
  let emissiveFactor = get_emissiveFactor(materialSID, 0);
  let emissiveTexcoordIndex = u32(get_emissiveTexcoordIndex(materialSID, 0));
  var emissiveTexcoord = getTexcoord(emissiveTexcoordIndex, input);
  emissiveTexcoord = uvAnimation(emissiveTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  var emissiveTexture = textureSample(emissiveTexture, emissiveSampler, emissiveTexcoord);
  emissiveTexture = vec4(srgbToLinear(emissiveTexture.rgb), emissiveTexture.a);
  let emissive = emissiveFactor * emissiveTexture.rgb;

  // alpha
  let alpha = baseColorTexture.a * baseColorFactor.a;
#ifdef RN_ALPHATEST_ON
  let cutoff = get_alphaCutoff(materialSID, 0);
  if(alpha < cutoff) { discard; }
#endif

  // view vector
  let viewPosition = get_viewPosition(cameraSID, 0);
  let viewVector = viewPosition - input.position_inWorld.xyz;
  let viewDirection = normalize(viewVector);

  // Normal
  var normal_inWorld = normalize(input.normal_inWorld);
#ifdef RN_USE_NORMAL_TEXTURE
  let normalTextureTransformScale = get_normalTextureTransformScale(materialSID, 0);
  let normalTextureTransformOffset = get_normalTextureTransformOffset(materialSID, 0);
  let normalTextureTransformRotation = get_normalTextureTransformRotation(materialSID, 0);
  let normalTexcoordIndex = u32(get_normalTexcoordIndex(materialSID, 0));
  var normalTexcoord = getTexcoord(normalTexcoordIndex, input);
  normalTexcoord = uvAnimation(normalTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  let normalTexUv = uvTransform(normalTextureTransformScale, normalTextureTransformOffset, normalTextureTransformRotation, normalTexcoord);
  let normal: vec3f = textureSample(normalTexture, normalSampler, normalTexUv).xyz * 2.0 - 1.0;
  let TBN: mat3x3<f32> = getTBN(normal_inWorld, input, viewDirection, normalTexUv, isFront);
  normal_inWorld = normalize(TBN * normal);
#endif

#ifdef RN_MTOON_IS_OUTLINE
  normal_inWorld *= -1.0;
#endif

  // direct lighting
  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation
  var rt0 = vec4f(0.0, 0.0, 0.0, 1.0);
  var directLighting = vec3f(0.0);
  let lightNumber = u32(get_lightNumber(0u, 0u));
  for (var i = 0u; i < lightNumber; i++) {
    let light: Light = getLight(i, input.position_inWorld.xyz);
    var shading = dot(light.direction, normal_inWorld);
    let shadingShiftFactor = get_shadingShiftFactor(materialSID, 0);
    shading += shadingShiftFactor + shadingShiftTexture * shadingShiftTextureScale;
    let shadingToonyFactor = get_shadingToonyFactor(materialSID, 0);
    shading = linearstep(-1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading);

    var color = mix(shadeColorTerm, baseColorTerm, shading);
    color = color * light.attenuatedIntensity * RECIPROCAL_PI;
    directLighting += light.attenuatedIntensity;
    rt0 += vec4f(color, rt0.a);
  }

  // indirect lighting
  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation-1
  let giEqualizationFactor = get_giEqualizationFactor(materialSID, 0);
  let worldUpVector = vec3f(0.0, 1.0, 0.0);
  let worldDownVector = vec3f(0.0, -1.0, 0.0);
  let iblParameter = get_iblParameter(materialSID, 0);
  let rot = iblParameter.w;
  let IBLDiffuseContribution = iblParameter.y;
  let rotEnvMatrix = mat3x3f(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  let normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  let hdriFormat = get_hdriFormat(materialSID, 0);
  let rawGiUp = getIBLIrradiance(worldUpVector, iblParameter, hdriFormat) * IBLDiffuseContribution;
  let rawGiDown = getIBLIrradiance(worldDownVector, iblParameter, hdriFormat) * IBLDiffuseContribution;
  let rawGiNormal = getIBLIrradiance(normal_forEnv, iblParameter, hdriFormat) * IBLDiffuseContribution;
  let uniformedGi = (rawGiUp + rawGiDown) / 2.0;
  let passthroughGi = rawGiNormal;
  let gi = mix(uniformedGi, passthroughGi, giEqualizationFactor);
  rt0 += vec4f(gi * baseColorTerm * RECIPROCAL_PI, rt0.a);

  // rim lighting
  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation-2
  var rim = vec3f(0.0);
  let worldViewX = normalize(vec3f(viewDirection.z, 0.0, -viewDirection.x));
  let worldViewY = cross(viewDirection, worldViewX);
  let matcapUv = vec2f( dot(worldViewX, normal_inWorld), dot(worldViewY, normal_inWorld)) * 0.495 + 0.5;
  let epsilon = 0.00001;
  let matcapFactor = srgbToLinear(get_matcapFactor(materialSID, 0));
  rim = matcapFactor * textureSample(matcapTexture, matcapSampler, matcapUv).rgb;
  let parametricRimLiftFactor = get_parametricRimLiftFactor(materialSID, 0);
  var parametricRim = clamp( 1.0 - dot(normal_inWorld, viewVector) + parametricRimLiftFactor, 0.0, 1.0);
  let parametricRimFresnelPowerFactor = get_parametricRimFresnelPowerFactor(materialSID, 0);
  parametricRim = pow(parametricRim, max(parametricRimFresnelPowerFactor, epsilon));
  let parametricRimColorFactor = get_parametricRimColorFactor(materialSID, 0);
  rim += parametricRim * parametricRimColorFactor;
  let rimMultiplyTexcoordIndex = u32(get_rimMultiplyTexcoordIndex(materialSID, 0));
  var rimMultiplyTexcoord = getTexcoord(rimMultiplyTexcoordIndex, input);
  rimMultiplyTexcoord = uvAnimation(rimMultiplyTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  rim *= srgbToLinear(textureSample(rimMultiplyTexture, rimMultiplySampler, rimMultiplyTexcoord).rgb);
  let rimLightingMixFactor = get_rimLightingMixFactor(materialSID, 0);
  rim *= mix(vec3(1.0), directLighting + gi, rimLightingMixFactor);
  rt0 += vec4f(rim, rt0.a);

  // emissive
  rt0 += vec4f(emissive, rt0.a);

#ifdef RN_MTOON_IS_OUTLINE
  let outlineColorFactor = get_outlineColorFactor(materialSID, 0);
  let outlineLightingMixFactor = get_outlineLightingMixFactor(materialSID, 0);
  rt0 = vec4f(outlineColorFactor * mix(vec3f(1.0), rt0.xyz, outlineLightingMixFactor), rt0.a);
#endif

  let makeOutputSrgb = get_makeOutputSrgb(materialSID, 0);
  rt0 = vec4f(select(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb), rt0.a);

  rt0.a = alpha;
  rt0 *= vec4f(alpha, alpha, alpha, 1.0);

  return rt0;
}
`,shaderStage:"fragment",isFragmentShader:!0}});var Oo,Gc,lp=C(()=>{"use strict";Go();zT();OT();kT();QT();St();$t();xe();se();tt();Zt();Ao();ft();So();Pn();Vo();mo();bi();fo();sr();Oo=class Oo extends He{constructor(n,t,o,r,i){super(n,{isMorphing:t,isSkinning:o,isLighting:r});let a=this.doShaderReflection(GT,UT,WT,XT);Oo.__diffuseIblCubeMapSampler.created||Oo.__diffuseIblCubeMapSampler.create(),Oo.__specularIblCubeMapSampler.created||Oo.__specularIblCubeMapSampler.create(),r&&(this.__definitions+=`#define RN_IS_LIGHTING
`),o&&(this.__definitions+=`#define RN_IS_SKINNING
`),t&&(this.__definitions+=`#define RN_IS_MORPHING
`,a.push({semantic:"dataTextureMorphOffsetPosition",componentType:I.Int,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,initialValue:new ve(new Int32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:I.Float,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,initialValue:new ve(new Float32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0})),i&&(this.__definitions+=`#define RN_MTOON_IS_OUTLINE
`),this.setShaderSemanticsInfoArray(a)}setMaterialParameters(n,t,o){t?(n.cullFace=!0,n.cullFaceBack=!1):o.doubleSided?n.cullFace=!1:(n.cullFace=!0,n.cullFaceBack=!0),o.alphaMode==="MASK"&&(this.__definitions+=`#define RN_ALPHATEST_ON
`)}_setInternalSettingParametersToGpuWebGpu({material:n,args:t}){let{mipmapLevelNumber:o,meshRenderComponent:r,diffuseHdriType:i,specularHdriType:a}=Oo.__setupHdriParameters(t),s=He.__tmp_vector4;s.x=o,s.y=r.diffuseCubeMapContribution,s.z=r.specularCubeMapContribution,s.w=r.rotationOfCubeMap,n.setParameter("iblParameter",s);let l=He.__tmp_vector2;l.x=i,l.y=a,n.setParameter("hdriFormat",l);let c=t.entity.tryToGetMeshRenderer();if(c!=null&&c.diffuseCubeMap!=null&&c.specularCubeMap!=null){let u=pe.zero(),_=pt.zero();u.x=c.specularCubeMap.mipmapLevelNumber,u.y=c.diffuseCubeMapContribution,u.z=c.specularCubeMapContribution,u.w=c.rotationOfCubeMap,n.setParameter("iblParameter",u),_.x=c.diffuseCubeMap.hdriFormat.index,_.y=c.specularCubeMap.hdriFormat.index,n.setParameter("hdriFormat",_)}}_setInternalSettingParametersToGpuWebGL({material:n,shaderProgram:t,firstTime:o,args:r}){if(r.setUniform){if(this.setWorldMatrix(t,r.worldMatrix),this.setNormalMatrix(t,r.normalMatrix),this.setIsBillboard(t,r.isBillboard),o||r.isVr){let l=r.renderPass.cameraComponent;l==null&&(l=J.getComponent(re,re.current)),this.setViewInfo(t,l,r.isVr,r.displayIdx),this.setProjection(t,l,r.isVr,r.displayIdx)}o&&this.setLightsInfo(t,r.lightComponents,n,r.setUniform);let s=r.entity.tryToGetSkeletal();this.setSkinning(t,r.setUniform,s)}let i=G.getWebGLResourceRepository();if(r.diffuseCube&&r.diffuseCube.isTextureReady?i.setUniform1iForTexture(t,Xe.DiffuseEnvTexture.str,[5,r.diffuseCube,Oo.__diffuseIblCubeMapSampler]):i.setUniform1iForTexture(t,Xe.DiffuseEnvTexture.str,[5,qt]),r.specularCube&&r.specularCube.isTextureReady?i.setUniform1iForTexture(t,Xe.SpecularEnvTexture.str,[6,r.specularCube,Oo.__specularIblCubeMapSampler]):i.setUniform1iForTexture(t,Xe.SpecularEnvTexture.str,[6,qt]),r.setUniform){if(o){let{mipmapLevelNumber:s,meshRenderComponent:l,diffuseHdriType:c,specularHdriType:u}=Oo.__setupHdriParameters(r);i.setUniformValue(t,Xe.IBLParameter.str,o,{x:s,y:l.diffuseCubeMapContribution,z:l.specularCubeMapContribution,w:l.rotationOfCubeMap}),i.setUniformValue(t,Xe.HDRIFormat.str,o,{x:c,y:u})}}else{let{mipmapLevelNumber:s,meshRenderComponent:l,diffuseHdriType:c,specularHdriType:u}=Oo.__setupHdriParameters(r),_=He.__tmp_vector4;_.x=s,_.y=l.diffuseCubeMapContribution,_.z=l.specularCubeMapContribution,_.w=l.rotationOfCubeMap,n.setParameter("iblParameter",_);let d=He.__tmp_vector2;d.x=c,d.y=u,n.setParameter("hdriFormat",d)}let a=r.entity.tryToGetBlendShape();this.setMorphInfo(t,r.entity.getMesh(),r.primitive,a)}static __setupHdriParameters(n){let t=1;n.specularCube&&(t=n.specularCube.mipmapLevelNumber);let o=n.entity.getMeshRenderer(),r=wt.LDR_SRGB.index,i=wt.LDR_SRGB.index;return o.diffuseCubeMap&&(r=o.diffuseCubeMap.hdriFormat.index),o.specularCubeMap&&(i=o.specularCubeMap.hdriFormat.index),{mipmapLevelNumber:t,meshRenderComponent:o,diffuseHdriType:r,specularHdriType:i}}};h(Oo,"MToon1MaterialContent"),f(Oo,"__diffuseIblCubeMapSampler",new Ge({minFilter:U.Linear,magFilter:U.Linear,wrapS:U.ClampToEdge,wrapT:U.ClampToEdge,wrapR:U.ClampToEdge})),f(Oo,"__specularIblCubeMapSampler",new Ge({minFilter:U.LinearMipmapLinear,magFilter:U.Linear,wrapS:U.ClampToEdge,wrapT:U.ClampToEdge,wrapR:U.ClampToEdge}));Gc=Oo});function zt(m,n){let t=0,o=!1;do{let r=m.getMaterialSemanticsVariantName()+`__group${t}`;if(o=Mn.isFullOrOverOfThisMaterialType(r),!o)return Mn.registerMaterial(r,m,n),Mn.createMaterial(r,m);t++}while(o);throw new Error("Failed to create material")}function u8(m,n,t){let o=m;if(Mn.isMaterialCompatible(o,n))return o._materialContent=n,o.makeShadersInvalidate(),o;{let r=n.getMaterialSemanticsVariantName();return Mn.registerMaterial(r,n,t),o=Mn.createMaterial(r,n),o}}function m8(m,n){let t=m.getMaterialSemanticsVariantName();return Mn.forceRegisterMaterial(t,m,n),Mn.createMaterial(t,m)}function _8({additionalName:m="",isMorphing:n=!0,isSkinning:t=!0,isLighting:o=!0,isClearCoat:r=!1,isTransmission:i=!1,isVolume:a=!1,isSheen:s=!1,isSpecular:l=!1,isIridescence:c=!1,isAnisotropy:u=!1,isDispersion:_=!1,isEmissiveStrength:d=!1,isDiffuseTransmission:p=!1,isShadow:x=!1,useTangentAttribute:v=!1,useNormalTexture:y=!0,maxInstancesNumber:g=F.maxMaterialInstanceForEachType}={}){let E=`PbrUber_${m}_`,w=[];w=[{semantic:"dataTextureMorphOffsetPosition",componentType:I.Int,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Int32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:I.Float,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Float32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0}];let T=new Ge({minFilter:U.Linear,magFilter:U.Linear,wrapS:U.ClampToEdge,wrapT:U.ClampToEdge});T.create();let R=8;r&&(w.push({semantic:"clearcoatTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,ct,T],min:0,max:Number.MAX_VALUE}),w.push({semantic:"clearcoatRoughnessTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,ct,T],min:0,max:Number.MAX_VALUE}),w.push({semantic:"clearcoatNormalTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,Ur,T],min:0,max:Number.MAX_VALUE})),i&&(w.push({semantic:"transmissionTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,ct,T],min:0,max:Number.MAX_VALUE}),w.push({semantic:"backBufferTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,rn,T],min:0,max:Number.MAX_VALUE})),a&&w.push({semantic:"thicknessTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,ct,T],min:0,max:Number.MAX_VALUE}),s&&(w.push({semantic:"sheenColorTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,ct,T],min:0,max:Number.MAX_VALUE}),w.push({semantic:"sheenRoughnessTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,ct,T],min:0,max:Number.MAX_VALUE}),w.push({semantic:"sheenLutTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,Zs,T],min:0,max:Number.MAX_VALUE}),w.push({semantic:"sheenEnvTexture",componentType:I.Int,compositionType:b.TextureCube,stage:D.PixelShader,isInternalSetting:!0,initialValue:[R++,qt,T],min:0,max:Number.MAX_VALUE})),l&&(w.push({semantic:"specularTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,ct,T],min:0,max:Number.MAX_VALUE}),w.push({semantic:"specularColorTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,ct,T],min:0,max:Number.MAX_VALUE})),c&&(w.push({semantic:"iridescenceTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,ct,T],min:0,max:Number.MAX_VALUE}),w.push({semantic:"iridescenceThicknessTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,ct,T],min:0,max:Number.MAX_VALUE})),u&&w.push({semantic:"anisotropyTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,Js,T],min:0,max:Number.MAX_VALUE}),p&&(w.push({semantic:"diffuseTransmissionTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,ct,T],min:0,max:Number.MAX_VALUE}),w.push({semantic:"diffuseTransmissionColorTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[R++,ct,T],min:0,max:Number.MAX_VALUE})),x&&(w.push({semantic:"depthTexture",componentType:I.Int,compositionType:b.Texture2DArray,stage:D.PixelShader,initialValue:[R++,va,T],min:0,max:Number.MAX_VALUE}),w.push({semantic:"paraboloidDepthTexture",componentType:I.Int,compositionType:b.Texture2DArray,stage:D.PixelShader,initialValue:[R++,va,T],min:0,max:Number.MAX_VALUE}),w.push({semantic:"depthTextureIndexList",componentType:I.Int,compositionType:b.ScalarArray,arrayLength:F.shadowMapTextureArrayLength,stage:D.PixelShader,initialValue:new ve(new Int32Array(F.shadowMapTextureArrayLength)),min:0,max:Number.MAX_VALUE}),w.push({semantic:"depthBiasPV",componentType:I.Float,compositionType:b.Mat4Array,arrayLength:F.shadowMapTextureArrayLength,stage:D.PixelShader,initialValue:new ve(new Float32Array(F.maxLightNumberInShader*16)),min:0,max:Number.MAX_VALUE}));let P=new bn({name:E,isSkinning:t,isLighting:o,isMorphing:n,vertexShader:q3,pixelShader:Y3,vertexShaderWebGpu:Z3,pixelShaderWebGpu:$3,additionalShaderSemanticInfo:w}),V=zt(P,g);return o&&V.addShaderDefine("RN_IS_LIGHTING"),x&&V.addShaderDefine("RN_USE_SHADOW_MAPPING"),y&&V.addShaderDefine("RN_USE_NORMAL_TEXTURE"),r&&V.addShaderDefine("RN_USE_CLEARCOAT"),i&&V.addShaderDefine("RN_USE_TRANSMISSION"),a&&V.addShaderDefine("RN_USE_VOLUME"),s&&V.addShaderDefine("RN_USE_SHEEN"),l&&V.addShaderDefine("RN_USE_SPECULAR"),c&&V.addShaderDefine("RN_USE_IRIDESCENCE"),u&&V.addShaderDefine("RN_USE_ANISOTROPY"),_&&V.addShaderDefine("RN_USE_DISPERSION"),d&&V.addShaderDefine("RN_USE_EMISSIVE_STRENGTH"),p&&V.addShaderDefine("RN_USE_DIFFUSE_TRANSMISSION"),V.addShaderDefine("RN_IS_SKINNING"),V}function d8({additionalName:m="",isSkinning:n=!0,isLighting:t=!1,isMorphing:o=!1,isShadow:r=!1,maxInstancesNumber:i=F.maxMaterialInstanceForEachType}={}){let a=`ClassicUber_${m}_`,s=[{semantic:"dataTextureMorphOffsetPosition",componentType:I.Int,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Int32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:I.Float,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Float32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0}],l=new bn({name:a,isSkinning:n,isLighting:t,isMorphing:o,vertexShader:G3,pixelShader:U3,vertexShaderWebGpu:W3,pixelShaderWebGpu:X3,additionalShaderSemanticInfo:s}),c=zt(l,i);return t&&c.addShaderDefine("RN_IS_LIGHTING"),r&&c.addShaderDefine("RN_USE_SHADOW_MAPPING"),c.addShaderDefine("RN_USE_NORMAL_TEXTURE"),c.addShaderDefine("RN_IS_SKINNING"),c}function h8({additionalName:m="",isSkinning:n=!0,isMorphing:t=!1,maxInstancesNumber:o=F.maxMaterialInstanceForEachType}={}){let r=`ParaboloidDepthMomentEncode_${m}_`,i=[{semantic:"dataTextureMorphOffsetPosition",componentType:I.Int,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Int32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:I.Float,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Float32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0}],a=new bn({name:r,isSkinning:n,isLighting:!0,isMorphing:t,vertexShader:YS,pixelShader:ZS,vertexShaderWebGpu:$S,pixelShaderWebGpu:tT,additionalShaderSemanticInfo:i}),s=zt(a,o);return s.addShaderDefine("RN_IS_SKINNING"),s}function p8({additionalName:m="",isSkinning:n=!0,isMorphing:t=!1,maxInstancesNumber:o=F.maxMaterialInstanceForEachType}={}){let r=`DepthMomentEncode_${m}_`,i=[{semantic:"dataTextureMorphOffsetPosition",componentType:I.Int,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Int32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0},{semantic:"morphWeights",componentType:I.Float,compositionType:b.ScalarArray,arrayLength:F.maxVertexMorphNumberInShader,stage:D.VertexShader,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Float32Array(F.maxVertexMorphNumberInShader)),min:-Number.MAX_VALUE,max:Number.MAX_VALUE,needUniformInDataTextureMode:!0}],a=new bn({name:r,isSkinning:n,isLighting:!1,isMorphing:t,vertexShader:US,pixelShader:WS,vertexShaderWebGpu:XS,pixelShaderWebGpu:qS,additionalShaderSemanticInfo:i}),s=zt(a,o);return s.addShaderDefine("RN_IS_SKINNING"),s}function x8({additionalName:m="",isSkinning:n=!0,isMorphing:t=!1,maxInstancesNumber:o=F.maxMaterialInstanceForEachType}={}){let r=`Flat_${m}_`,i=new bn({name:r,isSkinning:n,isLighting:!1,isMorphing:t,vertexShader:DS,pixelShader:FS,additionalShaderSemanticInfo:[],vertexShaderWebGpu:VS,pixelShaderWebGpu:GS}),a=zt(i,o);return a.addShaderDefine("RN_IS_SKINNING"),a}function v8({additionalName:m="",maxInstancesNumber:n=5,makeOutputSrgb:t=!0}={}){let o=`EnvConstant_${m}`,r=new bn({name:o,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:tS,pixelShader:oS,vertexShaderWebGpu:iS,pixelShaderWebGpu:sS,additionalShaderSemanticInfo:[]}),i=zt(r,n);return i.setParameter("makeOutputSrgb",t?1:0),i}function g8({additionalName:m="",maxInstancesNumber:n=1}={}){let t=`FXAA3Quality_${m}`,o=new bn({name:t,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:cS,pixelShader:uS,additionalShaderSemanticInfo:[]});return zt(o,n)}function y8({additionalName:m="",maxInstancesNumber:n=1}={}){let t=`FurnaceTest_${m}`,o=new Mc(t);return zt(o,n)}function b8({additionalName:m="",isSkinning:n=!1,depthPow:t=1,maxInstancesNumber:o=10}={}){let r=`DepthEncode_${m}_`,i=new wc(r,t,{isSkinning:n}),a=zt(i,o);return n&&a.addShaderDefine("RN_IS_SKINNING"),a}function A8({additionalName:m="",isMorphing:n=!1,isSkinning:t=!1,isLighting:o=!0,isDebugging:r=!1,colorAttachmentsNumber:i=0,maxInstancesNumber:a=20}={},s){let l=`ShadowMapDecodeClassic_${m}_`,c=new Rc(l,{isMorphing:n,isSkinning:t,isLighting:o,isDebugging:r,colorAttachmentsNumber:i},s),u=zt(c,a);return t&&u.addShaderDefine("RN_IS_SKINNING"),n&&u.addShaderDefine("RN_IS_MORPHING"),o&&u.addShaderDefine("RN_IS_LIGHTING"),r&&u.addShaderDefine("RN_IS_DEBUGGING"),u}function I8({additionalName:m="",maxInstancesNumber:n=10}={}){let t=`GaussianBlurForEncodedDepth_${m}`,o=[],r=new Float32Array(30);o.push({semantic:"isHorizontal",componentType:I.Bool,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(1),min:0,max:1},{semantic:"gaussianRatio",componentType:I.Float,compositionType:b.ScalarArray,arrayLength:30,stage:D.PixelShader,initialValue:new ve(r),min:0,max:1,needUniformInDataTextureMode:!0},{semantic:"gaussianKernelSize",componentType:I.Int,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(1),min:1,max:30},{semantic:"framebufferSize",componentType:I.Float,compositionType:b.Vec2,stage:D.PixelShader,initialValue:Ee.fromCopy2(1,1),min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"baseColorTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[0,rn],min:0,max:Number.MAX_SAFE_INTEGER});let i=new bn({name:t,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:gT,pixelShader:bT,additionalShaderSemanticInfo:o});return zt(i,n)}function S8({additionalName:m="",isMorphing:n=!1,isSkinning:t=!1,isDebugging:o=!1,isLighting:r=!0,colorAttachmentsNumberDepth:i=0,colorAttachmentsNumberSquareDepth:a=0,depthCameraComponent:s=void 0,maxInstancesNumber:l=10},c){let u=`VarianceShadowMapDecodeClassic_${m}_`,_=new Vc(u,{isMorphing:n,isSkinning:t,isLighting:r,isDebugging:o,colorAttachmentsNumberDepth:i,colorAttachmentsNumberSquareDepth:a,depthCameraComponent:s},c),d=zt(_,l);return t&&d.addShaderDefine("RN_IS_SKINNING"),r&&d.addShaderDefine("RN_IS_LIGHTING"),n&&d.addShaderDefine("RN_IS_MORPHING"),o&&d.addShaderDefine("RN_IS_DEBUGGING"),d}function T8({additionalName:m="",maxInstancesNumber:n=5}={},t){let o=`DetectHighLuminance_${m}_`,r=new Dc(o,t);return zt(r,n)}function E8({additionalName:m="",maxInstancesNumber:n=10}={}){let t=`GaussianBlur_${m}`,o=[],r=new Float32Array(30);o.push({semantic:"isHorizontal",componentType:I.Bool,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(1),min:0,max:1},{semantic:"gaussianRatio",componentType:I.Float,compositionType:b.ScalarArray,arrayLength:30,stage:D.PixelShader,initialValue:new ve(r),min:0,max:1},{semantic:"gaussianKernelSize",componentType:I.Int,compositionType:b.Scalar,stage:D.PixelShader,initialValue:te.fromCopyNumber(1),min:1,max:30},{semantic:"framebufferSize",componentType:I.Float,compositionType:b.Vec2,stage:D.PixelShader,initialValue:Ee.fromCopy2(1,1),min:0,max:Number.MAX_SAFE_INTEGER},{semantic:"baseColorTexture",componentType:I.Int,compositionType:b.Texture2D,stage:D.PixelShader,initialValue:[0,rn],min:0,max:Number.MAX_SAFE_INTEGER});let i=new bn({name:t,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:uT,pixelShader:_T,vertexShaderWebGpu:hT,pixelShaderWebGpu:xT,additionalShaderSemanticInfo:o});return zt(i,n)}function C8({additionalName:m="",maxInstancesNumber:n=1},t){let o=`SynthesizeHDR_${m}`,r=new Bc(o,t);return zt(r,n)}function w8({additionalName:m="",colorAttachmentsNumber:n=0,uri:t,texture:o,maxInstancesNumber:r=1},i){let a=`ColorGradingUsingLUTs_${m}`,s=new Fc(a,i,n,t,o);return zt(s,r)}function R8({additionalName:m="",maxInstancesNumber:n=1}={}){let t=`GammaCorrection_${m}`,o=new bn({name:t,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:_S,pixelShader:hS,vertexShaderWebGpu:xS,pixelShaderWebGpu:gS,additionalShaderSemanticInfo:[]});return zt(o,n)}function N8({additionalName:m="",maxInstancesNumber:n=1}={}){let t=`ToneMapping_${m}`,o=new bn({name:t,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:bS,pixelShader:IS,vertexShaderWebGpu:TS,pixelShaderWebGpu:CS,additionalShaderSemanticInfo:[]}),r=zt(o,n);return r.addShaderDefine("RN_USE_GT_TONEMAP"),r}function P8({additionalName:m="",maxInstancesNumber:n=1}={}){let t=`SummedAreaTable_${m}`,o=new bn({name:t,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:RS,pixelShader:PS,additionalShaderSemanticInfo:[]});return zt(o,n)}function M8({additionalName:m="",maxInstancesNumber:n=1}={}){let t=`PanoramaToCube_${m}`,o=new bn({name:t,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:IT,pixelShader:TT,vertexShaderWebGpu:CT,pixelShaderWebGpu:RT,additionalShaderSemanticInfo:[]});return zt(o,n)}function D8({additionalName:m="",maxInstancesNumber:n=1}={}){let t=`PrefilterIBL_${m}`,o=new bn({name:t,isSkinning:!1,isLighting:!1,isMorphing:!1,vertexShader:PT,pixelShader:DT,vertexShaderWebGpu:FT,pixelShaderWebGpu:VT,additionalShaderSemanticInfo:[]});return zt(o,n)}function B8({additionalName:m="",isSkinning:n=!1,uri:t,texture:o,sampler:r,maxInstancesNumber:i=10}){let a=`MatCap_${m}`,s=new Lc(a,n,t,o,r),l=zt(s,i);return n&&l.addShaderDefine("RN_IS_SKINNING"),l}function F8({additionalName:m="",maxInstancesNumber:n=10}={}){let t=`EntityUIDOutput_${m}`,o=new Nc(t),r=zt(o,n);return r.addShaderDefine("RN_IS_SKINNING"),r}function L8({additionalName:m="",isMorphing:n=!1,isSkinning:t=!1,isLighting:o=!0,useTangentAttribute:r=!1,isOutline:i=!1,materialProperties:a,textures:s,samplers:l,debugMode:c,maxInstancesNumber:u=F.maxMaterialInstanceForEachType,makeOutputSrgb:_=!0}){let d=`MToon0x_${m}_`,p=new Pc(i,a,s,l,n,t,o,r,c,_,d),x=zt(p,u);return p.setMaterialParameters(x,i),x}function V8({additionalName:m="",isMorphing:n=!1,isSkinning:t=!1,isLighting:o=!0,useTangentAttribute:r=!1,isOutline:i=!1,materialJson:a,textures:s,samplers:l,debugMode:c,maxInstancesNumber:u=F.maxMaterialInstanceForEachType,makeOutputSrgb:_=!0}){let d=`MToon1_${m}_`,p=new Gc(d,n,t,o,i),x=zt(p,u);return p.setMaterialParameters(x,i,a),x.setParameter("makeOutputSrgb",te.fromCopyNumber(_?1:0)),x.zWriteWhenBlend=a.extensions.VRMC_materials_mtoon.transparentWithZWrite,a.normalTexture!=null&&x.addShaderDefine("RN_USE_NORMAL_TEXTURE"),x}function z8(m,n,t,{additionalName:o="",isSkinning:r=!0,isLighting:i=!1,isMorphing:a=!1,maxInstancesNumber:s=F.maxMaterialInstanceForEachType}={}){let l=`Custom_${o}_`,c;K.currentProcessApproach===Z.WebGPU?c=new bn({name:l,isSkinning:r,isLighting:i,isMorphing:a,vertexShaderWebGpu:{code:n,shaderStage:"vertex",isFragmentShader:!1},pixelShaderWebGpu:{code:t,shaderStage:"fragment",isFragmentShader:!0},additionalShaderSemanticInfo:[]}):c=new bn({name:l,isSkinning:r,isLighting:i,isMorphing:a,vertexShader:{code:n,shaderStage:"vertex",isFragmentShader:!1},pixelShader:{code:t,shaderStage:"fragment",isFragmentShader:!0},additionalShaderSemanticInfo:[]});let u=u8(m,c,s);return u.addShaderDefine("RN_IS_SKINNING"),u}function G8(m,n,t){let o=m.getMeshRenderer();n.material=t,o.moveStageTo(Ne.Load)}var Oe,_r=C(()=>{"use strict";tt();jh();Yh();Zh();$h();ep();Cn();tp();np();op();rp();ip();ap();xe();se();Zt();Ao();z3();O3();k3();Q3();H3();j3();K3();J3();eS();nS();rS();aS();lS();fS();mS();dS();pS();vS();yS();AS();SS();ES();wS();NS();MS();BS();LS();zS();OS();kS();QS();HS();jS();KS();JS();eT();tl();Pn();mo();fT();mT();dT();pT();vT();yT();AT();ST();ET();wT();NT();MT();BT();LT();Tn();un();Xo();Ze();lp();h(zt,"createMaterial");h(u8,"reuseOrRecreateMaterial");h(m8,"recreateMaterial");h(_8,"createPbrUberMaterial");h(d8,"createClassicUberMaterial");h(h8,"createParaboloidDepthMomentEncodeMaterial");h(p8,"createDepthMomentEncodeMaterial");h(x8,"createFlatMaterial");h(v8,"createEnvConstantMaterial");h(g8,"createFXAA3QualityMaterial");h(y8,"createFurnaceTestMaterial");h(b8,"createDepthEncodeMaterial");h(A8,"createShadowMapDecodeClassicSingleMaterial");h(I8,"createGaussianBlurForEncodedDepthMaterial");h(S8,"createVarianceShadowMapDecodeClassicSingleMaterial");h(T8,"createDetectHighLuminanceMaterial");h(E8,"createGaussianBlurMaterial");h(C8,"createSynthesizeHDRMaterial");h(w8,"createColorGradingUsingLUTsMaterial");h(R8,"createGammaCorrectionMaterial");h(N8,"createToneMappingMaterial");h(P8,"createSummedAreaTableMaterial");h(M8,"createPanoramaToCubeMaterial");h(D8,"createPrefilterIBLMaterial");h(B8,"createMatCapMaterial");h(F8,"createEntityUIDOutputMaterial");h(L8,"createMToon0xMaterial");h(V8,"createMToon1Material");h(z8,"reuseOrRecreateCustomMaterial");h(G8,"changeMaterial");Oe=Object.freeze({createMaterial:zt,recreateMaterial:m8,reuseOrRecreateCustomMaterial:z8,createClassicUberMaterial:d8,createDepthMomentEncodeMaterial:p8,createParaboloidDepthMomentEncodeMaterial:h8,createFlatMaterial:x8,createPbrUberMaterial:_8,createEnvConstantMaterial:v8,createFXAA3QualityMaterial:g8,createDepthEncodeMaterial:b8,createShadowMapDecodeClassicSingleMaterial:A8,createGammaCorrectionMaterial:R8,createToneMappingMaterial:N8,createPanoramaToCubeMaterial:M8,createPrefilterIBLMaterial:D8,createSummedAreaTableMaterial:P8,createVarianceShadowMapDecodeClassicSingleMaterial:S8,createEntityUIDOutputMaterial:F8,createMToon0xMaterial:L8,createMToon1Material:V8,createFurnaceTestMaterial:y8,createGaussianBlurForEncodedDepthMaterial:I8,createDetectHighLuminanceMaterial:T8,createGaussianBlurMaterial:E8,createSynthesizeHDRMaterial:C8,createColorGradingUsingLUTsMaterial:w8,createMatCapMaterial:B8,changeMaterial:G8})});function Oc(m,n,t){let o=(1<<t)-1;return m._sortkey>>n&o}function hp(m){let n=Oc(m,13,2);return n===2||n===3}function nl(m){return Oc(m,13,2)===2}function Aa(m){return Oc(m,13,2)===3}function Uc(m){return Oc(m,13,2)===1}function pp(m){return Oc(m,13,2)===0}var cp,fp,up,mp,_p,dp,O8,U8,kc=C(()=>{"use strict";cp=2,fp=10,up=3,mp=0,_p=3,dp=13,O8=15,U8=32;h(Oc,"readBits");h(hp,"isBlend");h(nl,"isBlendWithZWrite");h(Aa,"isBlendWithoutZWrite");h(Uc,"isTranslucent");h(pp,"isOpaque")});var Nt,$e,_o=C(()=>{"use strict";Nn();Xt();zn();xe();jo();se();pi();_r();ft();ye();Ot();ge();kc();zl();co();tt();Bl();me();Nt=class Nt extends nt{constructor(){super();f(this,"__mode",Re.Unknown);f(this,"__material");f(this,"__materialVariants",new Map);f(this,"__currentVariantName","");f(this,"_prevMaterial");f(this,"__attributes",new Map);f(this,"__oIndices",new be);f(this,"__primitiveUid",-1);f(this,"__aabb",new jt);f(this,"__targets",[]);f(this,"__vertexHandles");f(this,"__mesh");f(this,"_sortkey",0);f(this,"_viewDepth",0);f(this,"__latestPositionAccessorVersion",0);f(this,"__positionAccessorVersion",0);f(this,"__fingerPrint","");Nt.__defaultMaterial==null&&(Nt.__defaultMaterial=Oe.createClassicUberMaterial({isSkinning:!0,isLighting:!0})),this.__material=Nt.__defaultMaterial,this._prevMaterial=new WeakRef(Nt.__defaultMaterial)}calcFingerPrint(){let t="";t+=this.__mode.index,this.__oIndices.has()&&(t+=this.getIndexBitSize()),t+=this.targets.length,t+=Nt.getPrimitiveIdxHasMorph(this.__primitiveUid);for(let[o,r]of this.__attributes)t+=o,t+=r.componentType.webgpu+r.compositionType.webgpu,t+=r.actualByteStride;this.__fingerPrint=t}_getFingerPrint(){return this.__fingerPrint}static getPrimitiveIdxHasMorph(t){return this.__primitiveUidIdxHasMorph.get(t)}static getPrimitiveHasMorph(t){var o;return(o=this.__idxPrimitiveUidHasMorph.get(t))==null?void 0:o.deref()}getIndexBitSize(){let t=this.__oIndices.unwrapOrUndefined();if(t==null)throw new Error("indexAccessor is null");if(t.componentType===I.UnsignedShort)return"uint16";if(t.componentType===I.UnsignedInt)return"uint32";if(t.componentType===I.UnsignedByte)return"uint16";throw new Error("unknown indexAccessor.componentType")}get _vertexHandles(){return this.__vertexHandles}static get variantUpdateCount(){return this.__variantUpdateCount}setMaterialVariant(t,o){this.__materialVariants.set(t,o),Nt.__variantUpdateCount++}applyMaterialVariant(t){let o=this.__materialVariants.get(t);o&&(this.material=o,this.__currentVariantName=t,Nt.__variantUpdateCount++)}getCurrentVariantName(){for(let[t,o]of this.__materialVariants)if(o===this.__material)return t;return""}getVariantNames(){return Array.from(this.__materialVariants.keys())}getVariantMaterial(t){return this.__materialVariants.get(t)}set material(t){this.__material=t,this.setSortKey(3,10,t.materialUID);let o=0;t.isTranslucentOpaque()?o=1:t.isBlend()&&(t.zWriteWhenBlend?o=2:o=3),this.setSortKey(13,2,o),t._addBelongPrimitive(this)}get material(){return this.__material}setSortKey(t,o,r){let i=r<<t;this._sortkey|=i;let a=(1<<o)-1;this._sortkey&=~(a<<t),this._sortkey|=(r&a)<<t}_belongToMesh(t){this.__mesh=t}get mesh(){return this.__mesh}_backupMaterial(){this._prevMaterial=new WeakRef(this.__material)}_restoreMaterial(){let t=this._prevMaterial.deref();t!=null&&(this.__material=t)}static getPrimitive(t){var o;return(o=this.__primitives[t])==null?void 0:o.deref()}static getPrimitiveCount(){return this.__primitiveCount}onAccessorUpdated(t){this.__positionAccessorVersion=t,this.__mesh!=null&&this.__mesh._onPrimitivePositionUpdated()}setData(t,o,r,i){i!=null?this.__oIndices=new lt(i):this.__oIndices=new be,this.__attributes=t;let a=this.__attributes.get(ee.Position.XYZ);a._primitive=new WeakRef(this),r!=null?this.material=r:this.material=Oe.createClassicUberMaterial({isSkinning:!0,isLighting:!0}),this.__mode=o,this.setSortKey(0,3,o.index),this.__primitiveUid=Nt.__primitiveCount++,Nt.__primitives[this.__primitiveUid]=new WeakRef(this),this.calcFingerPrint()}static get maxPrimitiveCount(){return 500}copyVertexData({attributes:t,attributeSemantics:o,primitiveMode:r,indices:i,material:a}){let s=0,l=4;t.forEach(g=>{s+=g.byteLength});let c=s;i!=null&&(c+=ie.addPaddingBytes(i.byteLength,l));let u=we.getInstance().createBufferOnDemand(c,this,l),_,d;if(i!=null){_=I.fromTypedArray(i);let g=u.takeBufferView({byteLengthToNeed:i.byteLength,byteStride:0});if(g.isErr())throw new rr(g.getRnError());let E=g.get().takeAccessor({compositionType:b.Scalar,componentType:_,count:i.byteLength/_.getSizeInBytes()});if(E.isErr())throw new rr(E.getRnError());d=E.get();for(let w=0;w<i.byteLength/d.componentSizeInBytes;w++)d.setScalar(w,i[w],{})}let p=u.takeBufferView({byteLengthToNeed:s,byteStride:0}).unwrapForce(),x=[],v=[];t.forEach((g,E)=>{let w=b.vectorFrom(ee.toVectorComponentN(o[E]));v[E]=I.fromTypedArray(t[E]);let T=p.takeAccessor({compositionType:w,componentType:I.fromTypedArray(t[E]),count:g.byteLength/w.getNumberOfComponents()/v[E].getSizeInBytes()}).unwrapForce();T.copyFromTypedArray(g),x.push(T)});let y=new Map;for(let g=0;g<o.length;g++){let E=o[g];y.set(E,x[g])}this.setData(y,r,a,d)}static createPrimitive(t){let o=new Nt;return o.copyVertexData(t),o}get indicesAccessor(){return this.__oIndices.unwrapOrUndefined()}getVertexCountAsIndicesBased(){return this.indicesAccessor?this.indicesAccessor.elementCount:this.getVertexCountAsVerticesBased()}getVertexCountAsVerticesBased(){for(let t of this.__attributes.values())return t.elementCount;return 0}getTriangleCountAsIndicesBased(){if(this.indicesAccessor)switch(this.__mode){case Re.Triangles:return this.indicesAccessor.elementCount/3;case Re.TriangleStrip:return this.indicesAccessor.elementCount-2;case Re.TriangleFan:return this.indicesAccessor.elementCount-2;default:return 0}else return this.getTriangleCountAsVerticesBased()}getTriangleCountAsVerticesBased(){for(let t of this.__attributes.values())switch(this.__mode){case Re.Triangles:return t.elementCount/3;case Re.TriangleStrip:return t.elementCount-2;case Re.TriangleFan:return t.elementCount-2;default:return 0}return 0}hasIndices(){return this.__oIndices.has()}get attributeAccessors(){let t=[];return this.__attributes.forEach((o,r)=>{t.push(o)}),t}getAttribute(t){return this.__attributes.get(t)}get attributeSemantics(){let t=[];return this.__attributes.forEach((o,r)=>{t.push(r)}),t}get attributeEntries(){return this.__attributes.entries()}get attributeCompositionTypes(){let t=[];return this.__attributes.forEach((o,r)=>{t.push(o.compositionType)}),t}get attributeComponentTypes(){let t=[];return this.__attributes.forEach((o,r)=>{t.push(o.componentType)}),t}get primitiveMode(){return this.__mode}get primitiveUid(){return this.__primitiveUid}get positionAccessorVersion(){return this.__positionAccessorVersion}get AABB(){if(this.__aabb.isVanilla()||this.positionAccessorVersion!==this.__latestPositionAccessorVersion){let t=this.__attributes.get(ee.Position.XYZ),o=t.min;this.__aabb.minPoint=Nt.__tmpVec3_0.setComponents(o[0],o[1],o[2]);let r=t.max;this.__aabb.maxPoint=Nt.__tmpVec3_0.setComponents(r[0],r[1],r[2]),this.__latestPositionAccessorVersion=t.version}return this.__aabb}setVertexAttribute(t,o){this.__attributes.set(o,t)}removeIndices(){this.__oIndices=new be}setIndices(t){this.__oIndices=new lt(t)}setBlendShapeTargets(t){Nt.__primitiveUidIdxHasMorph.size>=F.maxVertexPrimitiveNumberInShader?N.error("Primitive.__primitiveUidsHasMorph.size exceeds the Config.maxMorphPrimitiveNumber"):(Nt.__idxPrimitiveUidHasMorph.set(Nt.__primitiveCountHasMorph,new WeakRef(this)),Nt.__primitiveUidIdxHasMorph.set(this.__primitiveUid,Nt.__primitiveCountHasMorph++)),this.__targets=t,this.calcFingerPrint()}getBlendShapeTargets(){return this.__targets.concat()}get targets(){return this.__targets}isBlend(){return!(this.material==null||!this.material.isBlend())}isOpaque(){return!this.isBlend()}create3DAPIVertexData(){if(this.__vertexHandles!=null)return!1;let t=G.getCgApiResourceRepository();return this.__vertexHandles=t.createVertexBufferAndIndexBuffer(this),!0}update3DAPIVertexData(){let t=this.__vertexHandles;return A.not.exist(this.__vertexHandles)?!1:(G.getCgApiResourceRepository().updateVertexBufferAndIndexBuffer(this,t),!0)}delete3DAPIVertexData(){return this.__vertexHandles==null?!1:(G.getWebGLResourceRepository().deleteVertexDataResources(this.__vertexHandles),this.__vertexHandles=void 0,!0)}get vertexHandles(){return this.__vertexHandles}castRay(t,o,r,i,a,s){let l=Number.MAX_VALUE,c=3;if(this.__mode===Re.TriangleStrip)c=1;else if(this.__mode===Re.Points)return{result:!1};let u=0,_=0,d=0,p=0,x=0;if(this.hasIndices()){let v=this.__oIndices.unwrapForce();for(let y=0;y<v.elementCount-2;y++){let g=y*c;if(g+2>v.elementCount-1)break;let E=v.getScalar(g,{}),w=v.getScalar(g+1,{}),T=v.getScalar(g+2,{}),R=this.__castRayInnerTomasMoller(t,o,y,E,w,T,r,i,a,s);A.false(R)||A.not.exist(R.data)||R.data.t<l&&(l=R.data.t,p=R.data.u,x=R.data.v,u=E,_=w,u=T)}}else{let v=0;for(let y of this.__attributes.values()){v=y.elementCount;break}for(let y=0;y<v;y+=c){let g=y,E=y+1,w=y+2,T=this.__castRayInnerTomasMoller(t,o,y,g,E,w,r,i,a,s);if(T.result&&A.defined(T.data)){let R=T.data.t;R<l&&(l=R,p=T.data.u,x=T.data.v,u=g,_=E,u=w)}}}if(l===Number.MAX_VALUE)return{result:!1};{let v=S.fromCopy3(o.x*l+t.x,o.y*l+t.y,o.z*l+t.z);return{result:!0,data:{t:l,u:p,v:x,position:v}}}}__castRayInnerTomasMoller(t,o,r,i,a,s,l,c,u,_){if(_){let W=this.__attributes.get(ee.Normal.XYZ);if(W){let X=W.getVec3(r,{});if(X.dot(o)<u&&!l)return{result:!1};if(X.dot(o)>-u&&!c)return{result:!1}}}let d=this.__attributes.get(ee.Position.XYZ),p=d.getVec3(i,{}),x=d.getVec3(a,{}),v=d.getVec3(s,{}),y=L.zero(),g=L.zero(),E=L.zero(),w=L.zero(),T=L.zero(),R=0,P=0;L.subtractTo(x,p,y),L.subtractTo(v,p,g),L.crossTo(o,g,E);let V=S.dot(y,E);if(V>1e-4){if(L.subtractTo(t,p,w),R=S.dot(w,E),R<0||R>V)return{result:!1};if(L.crossTo(w,y,T),P=S.dot(o,T),P<0||R+P>V)return{result:!1}}else if(V<-1e-4){if(L.subtractTo(t,p,w),R=S.dot(w,E),R>0||R<V)return{result:!1};if(L.crossTo(w,y,T),P=S.dot(o,T),P>0||R+P<V)return{result:!1}}else return{result:!1};let z=1/V,k=S.dot(g,T);return k*=z,R*=z,P*=z,{result:!0,data:{t:k,u:R,v:P}}}__calcNormalFromUV(t,o,r,i,a){let s=1-i-a,l=this.__attributes.get(ee.Position.XYZ),c=l.getVec3(t,{}),u=l.getVec3(o,{}),_=l.getVec3(r,{}),d=S.multiply(c,s),p=S.multiply(u,i),x=S.multiply(_,a);return L.zero().add(d).add(p).add(x)}};h(Nt,"Primitive"),f(Nt,"__defaultMaterial"),f(Nt,"__primitiveCount",0),f(Nt,"__primitives",[]),f(Nt,"__primitiveUidIdxHasMorph",new Map),f(Nt,"__idxPrimitiveUidHasMorph",new Map),f(Nt,"__primitiveCountHasMorph",0),f(Nt,"__tmpVec3_0",L.zero()),f(Nt,"__variantUpdateCount",0);$e=Nt});function ii(m,n){let t=[];(!n||m.isJoint())&&t.push(m);let o=m.children;for(let r=0;r<o.length;r++){let i=ii(o[r],n);Array.prototype.push.apply(t,i)}return t}var Wc=C(()=>{"use strict";h(ii,"flattenHierarchy")});var Di,Dt,kr=C(()=>{"use strict";zn();It();Ei();_o();fo();it();Nn();ft();Wc();Di=class Di extends nt{constructor(){super();f(this,"__renderPassUID");f(this,"__entities",[]);f(this,"__sceneGraphDirectlyAdded",[]);f(this,"__topLevelSceneGraphComponents",[]);f(this,"__meshComponents",[]);f(this,"__optimizedMeshComponents",[]);f(this,"__frameBuffer");f(this,"__resolveFrameBuffer");f(this,"__resolveFrameBuffer2");f(this,"__viewport");f(this,"__material");f(this,"__primitiveMaterial",new Map);f(this,"toClearColorBuffer",!1);f(this,"toClearDepthBuffer",!0);f(this,"toClearStencilBuffer",!1);f(this,"isDepthTest",!0);f(this,"depthWriteMask",!0);f(this,"clearColor",q.fromCopyArray([1,1,1,1]));f(this,"clearDepth",1);f(this,"clearStencil",0);f(this,"cameraComponent");f(this,"_drawVertexNumberForBufferLessRendering",0);f(this,"_primitiveModeForBufferLessRendering",Re.Triangles);f(this,"_dummyPrimitiveForBufferLessRendering",new $e);f(this,"isVrRendering",!0);f(this,"isOutputForVr",!1);f(this,"_lastOpaqueIndex",-1);f(this,"_lastTranslucentIndex",-1);f(this,"_lastBlendWithZWriteIndex",-1);f(this,"_lastBlendWithoutZWriteIndex",-1);f(this,"_lastPrimitiveUids",[]);f(this,"_lastTransformComponentsUpdateCount",-1);f(this,"_lastCameraControllerComponentsUpdateCount",-1);f(this,"_lastSceneGraphComponentsUpdateCount",-1);f(this,"_renderedSomethingBefore",!0);f(this,"_isChangedSortRenderResult",!1);f(this,"_toRenderOpaquePrimitives",!0);f(this,"_toRenderTranslucentPrimitives",!0);f(this,"_toRenderBlendWithZWritePrimitives",!0);f(this,"_toRenderBlendWithoutZWritePrimitives",!0);f(this,"toRenderEffekseerEffects",!1);f(this,"__renderTargetColorAttachments");f(this,"__preEachRenderFunc");f(this,"__postEachRenderFunc");this.__renderPassUID=++Di.__mesh_uid_count}setToRenderOpaquePrimitives(t){this._toRenderOpaquePrimitives=t,this.__calcMeshComponents()}setToRenderBlendWithoutZWritePrimitives(t){this._toRenderBlendWithoutZWritePrimitives=t,this.__calcMeshComponents()}setToRenderBlendWithZWritePrimitives(t){this._toRenderBlendWithZWritePrimitives=t,this.__calcMeshComponents()}setToRenderTranslucentPrimitives(t){this._toRenderTranslucentPrimitives=t,this.__calcMeshComponents()}isBufferLessRenderingMode(){return this._drawVertexNumberForBufferLessRendering>0}setBufferLessRendering(t,o,r){this._primitiveModeForBufferLessRendering=t,this._drawVertexNumberForBufferLessRendering=o,this.__material=r}setBufferLessFullScreenRendering(t){this._primitiveModeForBufferLessRendering=Re.Triangles,this._drawVertexNumberForBufferLessRendering=3,this.__material=t}clone(){var o,r;let t=new Di;return t.tryToSetUniqueName(this.uniqueName+"_cloned",!0),t.__entities=this.__entities.concat(),t.__sceneGraphDirectlyAdded=this.__sceneGraphDirectlyAdded.concat(),t.__topLevelSceneGraphComponents=this.__topLevelSceneGraphComponents.concat(),t.__meshComponents=this.__meshComponents.concat(),t.__optimizedMeshComponents=this.__optimizedMeshComponents.concat(),t.__frameBuffer=this.__frameBuffer,t.__resolveFrameBuffer=this.__resolveFrameBuffer,t.__resolveFrameBuffer2=this.__resolveFrameBuffer2,t.__viewport=(o=this.__viewport)==null?void 0:o.clone(),t.toClearColorBuffer=this.toClearColorBuffer,t.toClearDepthBuffer=this.toClearDepthBuffer,t.toClearStencilBuffer=this.toClearStencilBuffer,t.isDepthTest=this.isDepthTest,t.clearColor=this.clearColor.clone(),t.clearDepth=this.clearDepth,t.clearStencil=this.clearStencil,t.cameraComponent=this.cameraComponent,t.__material=this.__material,t.__primitiveMaterial=new Map(this.__primitiveMaterial),t.isVrRendering=this.isVrRendering,t.isOutputForVr=this.isOutputForVr,t._toRenderOpaquePrimitives=this._toRenderOpaquePrimitives,t._toRenderTranslucentPrimitives=this._toRenderTranslucentPrimitives,t._toRenderBlendWithoutZWritePrimitives=this._toRenderBlendWithoutZWritePrimitives,t.__preEachRenderFunc=this.__preEachRenderFunc,t.__postEachRenderFunc=this.__postEachRenderFunc,t.__renderTargetColorAttachments=(r=this.__renderTargetColorAttachments)==null?void 0:r.concat(),t._lastOpaqueIndex=this._lastOpaqueIndex,t._lastTranslucentIndex=this._lastTranslucentIndex,t._lastBlendWithZWriteIndex=this._lastBlendWithZWriteIndex,t._lastBlendWithoutZWriteIndex=this._lastBlendWithoutZWriteIndex,t._lastPrimitiveUids=this._lastPrimitiveUids.concat(),t._lastTransformComponentsUpdateCount=this._lastTransformComponentsUpdateCount,t._lastCameraControllerComponentsUpdateCount=this._lastCameraControllerComponentsUpdateCount,t._lastSceneGraphComponentsUpdateCount=this._lastSceneGraphComponentsUpdateCount,t._renderedSomethingBefore=this._renderedSomethingBefore,t._isChangedSortRenderResult=this._isChangedSortRenderResult,t}setPreRenderFunction(t){this.__preEachRenderFunc=t}setPostRenderFunction(t){this.__postEachRenderFunc=t}doPreRender(){this.__preEachRenderFunc!=null&&this.__preEachRenderFunc()}doPostRender(){this.__postEachRenderFunc!=null&&this.__postEachRenderFunc()}addEntities(t){for(let o of t){let r=o.getSceneGraph();this.__sceneGraphDirectlyAdded.push(r);let a=ii(r,!1).map(l=>l.entity),s=this.__entities.concat(a).reduce((l,c)=>(l.set(c.entityUID,c),l),new Map);this.__entities=Array.from(s.values())}this.__calcMeshComponents(),this.__topLevelSceneGraphComponents=[],this.__collectTopLevelSceneGraphComponents()}__calcMeshComponents(){this.__meshComponents=[],this.__optimizedMeshComponents=[],this.__collectMeshComponents()}get entities(){return this.__entities}clearEntities(){this.__meshComponents=[],this.__optimizedMeshComponents=[],this.__topLevelSceneGraphComponents=[],this.__entities=[]}__collectTopLevelSceneGraphComponents(){let t=h(r=>(r.parent&&t(r.parent),r),"goToTopLevel");this.__topLevelSceneGraphComponents=this.__sceneGraphDirectlyAdded.map(r=>t(r));let o=new Set(this.__topLevelSceneGraphComponents);this.__topLevelSceneGraphComponents=Array.from(o)}__collectMeshComponents(){this.__meshComponents=[],this.__optimizedMeshComponents=[],this.__entities.filter(t=>{let o=t.getComponentByComponentTID(Q.MeshComponentTID);if(o!=null&&o.mesh!=null){if(this.__meshComponents.push(o),!this._toRenderOpaquePrimitives&&o.mesh.isExistOpaque()||!this._toRenderTranslucentPrimitives&&o.mesh.isExistTranslucent()||!this._toRenderBlendWithZWritePrimitives&&o.mesh.isExistBlendWithZWrite()||!this._toRenderBlendWithoutZWritePrimitives&&o.mesh.isExistBlendWithoutZWrite())return;this.__optimizedMeshComponents.push(o)}})}get meshComponents(){return this.__meshComponents}get _optimizedMeshComponents(){return this.__optimizedMeshComponents}get sceneTopLevelGraphComponents(){return this.__topLevelSceneGraphComponents}setFramebuffer(t){this.__frameBuffer=t,t!=null?this.setViewport(q.fromCopyArray([0,0,t.width,t.height])):this.__viewport=void 0}setRenderTargetColorAttachments(t){this.__renderTargetColorAttachments=t}getRenderTargetColorAttachments(){return this.__renderTargetColorAttachments}getFramebuffer(){return this.__frameBuffer}removeFramebuffer(){this.__frameBuffer=void 0}setViewport(t){this.__viewport!=null?this.__viewport.copyComponents(t):this.__viewport=pe.fromCopyArray([t.x,t.y,t.z,t.w])}getViewport(){let t=this.__viewport;return t!=null&&(t=Di.__tmp_Vector4_0.copyComponents(t)),t}setResolveFramebuffer(t){this.__resolveFrameBuffer=t}getResolveFramebuffer(){return this.__resolveFrameBuffer}setResolveFramebuffer2(t){this.__resolveFrameBuffer2=t}getResolveFramebuffer2(){return this.__resolveFrameBuffer2}_copyFramebufferToResolveFramebuffersWebGL(){this.__copyFramebufferToResolveFramebufferInner(this.__resolveFrameBuffer),this.__copyFramebufferToResolveFramebufferInner(this.__resolveFrameBuffer2)}__copyFramebufferToResolveFramebufferInner(t){if(t==null)return;let o=to.getInstance(),r=o.getWebGLResource(this.__frameBuffer.cgApiResourceUid),i=o.getWebGLResource(t.cgApiResourceUid);if(r==null||i==null)return;let s=o.currentWebGLContextWrapper.getRawContextAsWebGL2();s.bindFramebuffer(s.READ_FRAMEBUFFER,r),s.bindFramebuffer(s.DRAW_FRAMEBUFFER,i),s.blitFramebuffer(0,0,this.__frameBuffer.width,this.__frameBuffer.height,0,0,t.width,t.height,s.COLOR_BUFFER_BIT|s.DEPTH_BUFFER_BIT,s.NEAREST),s.bindFramebuffer(s.READ_FRAMEBUFFER,null),s.bindFramebuffer(s.DRAW_FRAMEBUFFER,null)}_copyResolve1ToResolve2WebGpu(){if(this.__resolveFrameBuffer==null||this.__resolveFrameBuffer2==null)return;let t=G.getWebGpuResourceRepository();for(let o=0;o<this.__resolveFrameBuffer.colorAttachments.length;o++)this.__resolveFrameBuffer.colorAttachments[o]==null||this.__resolveFrameBuffer2.colorAttachments[o]==null||this.__resolveFrameBuffer.colorAttachments[o]._textureResourceUid===-1||this.__resolveFrameBuffer2.colorAttachments[o]._textureResourceUid===-1||t.copyTextureData(this.__resolveFrameBuffer.colorAttachments[o]._textureResourceUid,this.__resolveFrameBuffer2.colorAttachments[o]._textureResourceUid)}setMaterialForPrimitive(t,o){this.__primitiveMaterial.set(o.objectUID,new WeakRef(t))}setMaterial(t){this.__material=t}get material(){return this.__material}_getMaterialOf(t){var o;return(o=this.__primitiveMaterial.get(t.objectUID))==null?void 0:o.deref()}__hasMaterialOf(t){return this.__primitiveMaterial.has(t.objectUID)}getAppropriateMaterial(t){let o=this._getMaterialOf(t);return o!=null||(this.__material!=null?o=this.__material:o=t.material),o}get renderPassUID(){return this.__renderPassUID}};h(Di,"RenderPass"),f(Di,"__tmp_Vector4_0",pe.zero()),f(Di,"__mesh_uid_count",-1);Dt=Di});var An,Et,Wr=C(()=>{"use strict";dn();at();it();Cn();yr();yh();br();An=class An extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"__rest");f(this,"__pose",new Us);f(this,"__updateCountAtLastLogic",0)}static get renderedPropertyCount(){return null}static get componentTID(){return Q.TransformComponentTID}get componentTID(){return Q.TransformComponentTID}get restOrPose(){return this.__rest!==void 0?this.__rest:this.__pose}static get updateCount(){return this.__updateCount}_backupTransformAsRest(){this.__rest===void 0&&(this.__rest=this.__pose.clone(),this.entity.tryToGetSceneGraph().setWorldMatrixRestDirty())}_restoreTransformFromRest(){this.__rest!==void 0&&this.__pose.setTransform(this.__rest.positionInner,this.__rest.scaleInner,Ye.fromCopyQuaternion(this.__rest.rotationInner))}get localTransform(){return this.__pose}set localTransform(t){this.__pose.setTransform(t.positionInner,t.scaleInner,Ye.fromCopyQuaternion(t.rotationInner)),An.__updateCount++}get localTransformRest(){return this.restOrPose}set localTransformRest(t){A.undefined(this.__rest)&&(this.__rest=new Us),this.__rest.setTransform(t.positionInner,t.scaleInner,Ye.fromCopyQuaternion(t.rotationInner)),An.__updateCount++}set localPosition(t){this.__pose.position=t,An.__updateCount++}setLocalPositionAsArray3(t){this.__pose.setPositionAsArray3(t),An.__updateCount++}get localPosition(){return this.__pose.position}get localPositionInner(){return this.__pose.positionInner}set localPositionRest(t){A.undefined(this.__rest)&&(this.__rest=this.__pose.clone()),this.__rest.position=t,An.__updateCount++}get localPositionRest(){return this.restOrPose.position}get localPositionRestInner(){return this.restOrPose.positionInner}set localEulerAngles(t){this.__pose.eulerAngles=t,An.__updateCount++}get localEulerAngles(){return this.__pose.eulerAngles}get localEulerAnglesInner(){return this.__pose.eulerAnglesInner}set localEulerAnglesRest(t){A.undefined(this.__rest)&&(this.__rest=this.__pose.clone()),this.__rest.eulerAngles=t,An.__updateCount++}get localEulerAnglesRest(){return this.restOrPose.eulerAngles}get localEulerAnglesRestInner(){return this.restOrPose.eulerAnglesInner}set localScale(t){this.__pose.scale=t,An.__updateCount++}setLocalScaleAsArray3(t){this.__pose.setScaleAsArray3(t),An.__updateCount++}get localScale(){return this.__pose.scale}get localScaleInner(){return this.__pose.scaleInner}set localScaleRest(t){A.undefined(this.__rest)&&(this.__rest=this.__pose.clone()),this.__rest.scale=t,An.__updateCount++}get localScaleRest(){return this.restOrPose.scale}get localScaleRestInner(){return this.restOrPose.scaleInner}set localRotation(t){this.__pose.rotation=t,An.__updateCount++}setLocalRotationAsArray4(t){this.__pose.setRotationAsArray4(t),An.__updateCount++}get localRotation(){return this.__pose.rotation}get localRotationInner(){return this.__pose.rotationInner}set localRotationRest(t){A.undefined(this.__rest)&&(this.__rest=this.__pose.clone()),this.__rest.rotation=t,An.__updateCount++}get localRotationRest(){return this.restOrPose.rotation}get localRotationRestInner(){return this.restOrPose.rotationInner}set localMatrix(t){this.__pose.matrix=t,An.__updateCount++}get localMatrix(){return this.__pose.matrix}get localMatrixInner(){return this.__pose.matrixInner}getLocalMatrixInnerTo(t){this.__pose.getMatrixInnerTo(t)}set localMatrixRest(t){A.undefined(this.__rest)&&(this.__rest=this.__pose.clone()),this.__rest.matrix=t,An.__updateCount++}get localMatrixRest(){return this.restOrPose.matrix}get localMatrixRestInner(){return this.restOrPose.matrixInner}$load(){this.moveStageTo(Ne.Logic)}$logic(){this.__updateCountAtLastLogic!==this.__pose.updateCount&&(this.entity.tryToGetSceneGraph().setWorldMatrixDirty(),this.__updateCountAtLastLogic=this.__pose.updateCount)}_shallowCopyFrom(t){let o=t;this.__pose=o.__pose.clone(),o.__rest!=null&&(this.__rest=o.__rest.clone()),this.__updateCountAtLastLogic=o.__updateCountAtLastLogic,An.__updateCount++}get entity(){return ne.getEntity(this.__entityUid)}_destroy(){super._destroy()}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(l,c,u){super(l,c,u);f(this,"__transformComponent")}getTransform(){return this.__transformComponent===void 0&&(this.__transformComponent=this.getComponentByComponentTID(Q.TransformComponentTID)),this.__transformComponent}set localPosition(l){let c=this.getTransform();c.localPosition=l}get localPosition(){return this.localPositionInner.clone()}get localPositionInner(){return this.getTransform().localPositionInner}set localPositionRest(l){let c=this.getTransform();c.localPositionRest=l}get localPositionRest(){return this.getTransform().localPositionRest}get localPositionRestInner(){return this.getTransform().localPositionRestInner}set localScale(l){let c=this.getTransform();c.localScale=l}get localScale(){return this.localScaleInner.clone()}get localScaleInner(){return this.getTransform().localScaleInner}set localScaleRest(l){let c=this.getTransform();c.localScaleRest=l}get localScaleRest(){return this.getTransform().localScaleRest}get localScaleRestInner(){return this.getTransform().localScaleRestInner}set localEulerAngles(l){let c=this.getTransform();c.localEulerAngles=l}get localEulerAngles(){return this.localEulerAnglesInner.clone()}get localEulerAnglesInner(){return this.getTransform().localEulerAnglesInner}set localEulerAnglesRest(l){let c=this.getTransform();c.localEulerAnglesRest=l}get localEulerAnglesRest(){return this.localEulerAnglesRestInner.clone()}get localEulerAnglesRestInner(){return this.getTransform().localEulerAnglesRestInner}set localRotation(l){let c=this.getTransform();c.localRotation=l}get localRotation(){return this.localRotationInner.clone()}get localRotationInner(){return this.getTransform().localRotationInner}set localRotationRest(l){let c=this.getTransform();c.localRotationRest=l}get localRotationRest(){return this.localQuaternionRestInner.clone()}get localRotationRestInner(){return this.getTransform().localRotationRestInner}set localMatrix(l){let c=this.getTransform();c.localMatrix=l}get localMatrix(){return this.localMatrixInner.clone()}get localMatrixInner(){return this.getTransform().localMatrixInner}set localMatrixRest(l){let c=this.getTransform();c.localMatrixRest=l}get localMatrixRest(){return this.localMatrixRestInner.clone()}get localMatrixRestInner(){return this.getTransform().localMatrixRestInner}},h(i,"TransformEntity"),i);return vt(t,r),t}};h(An,"TransformComponent"),f(An,"__updateCount",0);Et=An});var ol,an,Bi=C(()=>{"use strict";dn();at();it();j_();rd();pd();un();me();ol=class ol extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"__cameraController");this.__cameraController=new ea(this)}set type(t){this.__cameraController.unregisterEventListeners(),t===gs.Orbit?this.__cameraController=new ea(this):t===gs.WalkThrough?this.__cameraController=new Wl(this):N.warn("Not support type!")}get type(){return this.__cameraController instanceof ea?gs.Orbit:gs.WalkThrough}get controller(){return this.__cameraController}static get componentTID(){return Q.CameraControllerComponentTID}get componentTID(){return Q.CameraControllerComponentTID}$load(){this.moveStageTo(Ne.Logic)}$logic(){this.__cameraController&&this.__cameraController.logic(this.entity.tryToGetCamera())}_updateCount(t){ol.__updateCount=t}static get updateCount(){return ol.__updateCount}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(s,l,c){super(s,l,c)}getCameraController(){return this.getComponentByComponentTID(Q.CameraControllerComponentTID)}},h(i,"CameraControllerEntity"),i);return vt(t,r),t}};h(ol,"CameraControllerComponent"),f(ol,"__updateCount",0);an=ol});var xp,$o,Ia=C(()=>{"use strict";zn();Wc();xp=class xp extends nt{constructor(t){super();f(this,"__topEntity");f(this,"__target");f(this,"__isVisible",!1);this.__target=t,this.setGizmoTag()}set isVisible(t){this.__setVisible(t)}get isVisible(){return this.__isVisible}__setVisible(t){this.__isVisible=t,this.__topEntity&&this.__topEntity.getSceneGraph().setVisibilityRecursively(t)}__toSkipSetup(){return!!(this.isSetup||this.__target.matchTag("Being","gizmo"))}setGizmoTag(){if(this.__topEntity){this.__topEntity.tryToSetTag({tag:"Being",value:"gizmo"}),this.__topEntity.tryToSetTag({tag:"Gizmo",value:"top"});let t=ii(this.__topEntity.getSceneGraph(),!1);for(let o of t)o.entity.tryToSetTag({tag:"Being",value:"gizmo"});this.__topEntity.tryToSetTag({tag:"type",value:"background-assets"})}}};h(xp,"Gizmo");$o=xp});var rt,_t,ai=C(()=>{"use strict";Xt();Nn();jo();cr();xe();se();ye();pi();ft();Ot();ge();kc();Cn();me();rt=class rt{constructor(){f(this,"__meshUID");f(this,"__primitives",[]);f(this,"__opaquePrimitives",[]);f(this,"__translucentPrimitives",[]);f(this,"__blendWithZWritePrimitives",[]);f(this,"__blendWithoutZWritePrimitives",[]);f(this,"__morphPrimitives",[]);f(this,"__localAABB",new jt);f(this,"__vaoUids",[]);f(this,"__variationVBOUid",G.InvalidCGAPIResourceUid);f(this,"__latestPrimitivePositionAccessorVersionForAABB",0);f(this,"__latestPrimitivePositionAccessorVersionForSetUpDone",0);f(this,"__belongToEntities",[]);f(this,"tangentCalculationMode",1);f(this,"__hasFaceNormal",!1);f(this,"__primitivePositionUpdateCount",0);this.__meshUID=++rt.__mesh_uid_count}getVaoUids(n){return this.__vaoUids[n]}getVaoUidsByPrimitiveUid(n){let t=this.__primitives.findIndex(o=>o.primitiveUid===n);return this.__vaoUids[t]}get meshEntitiesInner(){return this.__belongToEntities}_belongToMeshComponent(n){this.__belongToEntities.push(n.entity)}addPrimitive(n){n._belongToMesh(this),pp(n)?this.__opaquePrimitives.push(n):Uc(n)?this.__translucentPrimitives.push(n):nl(n)?this.__blendWithZWritePrimitives.push(n):Aa(n)&&this.__blendWithoutZWritePrimitives.push(n),this.__setPrimitives(this.__opaquePrimitives.concat(this.__translucentPrimitives).concat(this.__blendWithZWritePrimitives).concat(this.__blendWithoutZWritePrimitives))}__setPrimitives(n){this.__primitives=n}isExistOpaque(){return this.__opaquePrimitives.length>0}isExistTranslucent(){return this.__translucentPrimitives.length>0}isExistBlendWithZWrite(){return this.__blendWithZWritePrimitives.length>0}isExistBlendWithoutZWrite(){return this.__blendWithoutZWritePrimitives.length>0}getPrimitiveAt(n){return this.__primitives[n]}getPrimitiveNumber(){return this.__primitives.length}updateVariationVBO(){let n=G.getCgApiResourceRepository();this.__variationVBOUid!==G.InvalidCGAPIResourceUid&&n.deleteVertexBuffer(this.__variationVBOUid);let t=this.__belongToEntities.length,o=new Float32Array(t*4);for(let r=0;r<t;r++){o[4*r+0]=this.__belongToEntities[r].getSceneGraph().componentSID;let i=this.__belongToEntities[r].tryToGetSkeletal();i!=null?o[4*r+1]=i.componentSID:o[4*r+1]=-1;let a=this.__belongToEntities[r].tryToGetBlendShape();a!=null?o[4*r+2]=a.componentSID:o[4*r+2]=-1}return this.__variationVBOUid=n.createVertexBufferFromTypedArray(o),!0}deleteVariationVBO(){let n=G.getCgApiResourceRepository();return this.__variationVBOUid!==G.InvalidCGAPIResourceUid?(n.deleteVertexBuffer(this.__variationVBOUid),this.__variationVBOUid=G.InvalidCGAPIResourceUid,!0):!1}updateVAO(){let n=G.getWebGLResourceRepository();for(let t=0;t<this.__primitives.length;t++){let o=this.__primitives[t],r=o.vertexHandles;if(A.undefined(r)){N.warn("Need to create 3DAPIVertexData before update VAO");continue}(isNaN(this.__vaoUids[t])||this.__vaoUids[t]===G.InvalidCGAPIResourceUid||r.vaoHandle===G.InvalidCGAPIResourceUid)&&(this.__vaoUids[t]=n.createVertexArray(),r.vaoHandle=this.__vaoUids[t]),n.setVertexDataToPipeline(r,o,this.__variationVBOUid)}for(let t=this.__primitives.length;t<this.__vaoUids.length;t++)this.__vaoUids[t]&&(n.deleteVertexArray(this.__vaoUids[t]),this.__vaoUids[t]=G.InvalidCGAPIResourceUid)}deleteVAO(){let n=G.getWebGLResourceRepository();for(let t=0;t<this.__vaoUids.length;t++)n.deleteVertexArray(this.__vaoUids[t]),this.__vaoUids[t]=G.InvalidCGAPIResourceUid}castRay(n,t,o=0){var l;let r,i=Number.MAX_VALUE,a=0,s=0;for(let c of this.__primitives){let u=c.castRay(n,t,!0,!0,o,this.__hasFaceNormal);A.defined(u.data)&&((l=u.data)==null?void 0:l.t)<i&&(i=u.data.t,r=u.data.position,a=u.data.u,s=u.data.v)}return A.defined(r)?{result:!0,data:{t:i,u:a,v:s,position:r}}:{result:!1}}get primitives(){return this.__primitives}get meshUID(){return this.__meshUID}get _variationVBOUid(){return this.__variationVBOUid}_onPrimitivePositionUpdated(){this.__primitivePositionUpdateCount++;for(let n of this.__belongToEntities)n.getMeshRenderer().moveStageTo(Ne.Load)}get primitivePositionUpdateCount(){return this.__primitivePositionUpdateCount}get AABB(){if(this.__primitivePositionUpdateCount!==this.__latestPrimitivePositionAccessorVersionForAABB&&(this.__localAABB.initialize(),this.__latestPrimitivePositionAccessorVersionForAABB=this.__primitivePositionUpdateCount),this.__localAABB.isVanilla())for(let n of this.__primitives)this.__localAABB.mergeAABB(n.AABB);return this.__localAABB}__calcMorphPrimitives(){for(let n=0;n<this.__primitives.length;n++){let t=this.__morphPrimitives[n],o=this.__primitives[n];o.targets[0].forEach((i,a)=>{let s=t.getAttribute(a),l=s.elementCount;for(let c=0;c<l;c++)s.setElementFromSameCompositionAccessor(c,o.getAttribute(a))})}}_calcTangents(){if(this.__usePreCalculatedTangent())for(let n of this.__primitives){if(n.attributeSemantics.indexOf(ee.Tangent.XYZ)!==-1&&this.tangentCalculationMode===2)continue;let o=n.attributeSemantics.indexOf(ee.Texcoord0.XY),r=n.attributeSemantics.indexOf(ee.Normal.XYZ);if(o!==-1&&r!==-1){let i=n.attributeSemantics.indexOf(ee.Position.XYZ),a=n.attributeAccessors[i],s=n.attributeAccessors[o],l=n.attributeAccessors[r],c=n.indicesAccessor,u=3;(n.primitiveMode===Re.TriangleStrip||n.primitiveMode===Re.TriangleFan)&&(u=1);let _=n.getVertexCountAsIndicesBased(),d=we.getInstance().createOrGetBuffer(Ce.CPUGeneric),p=a.byteLength*4/3,v=d.takeBufferView({byteLengthToNeed:p,byteStride:0}).unwrapForce().takeAccessor({compositionType:b.Vec4,componentType:I.Float,count:a.elementCount}).unwrapForce();for(let y=0;y<_-2;y+=u){let g=a.getVec3(y,{indicesAccessor:c}),E=a.getVec3(y+1,{indicesAccessor:c}),w=a.getVec3(y+2,{indicesAccessor:c}),T=s.getVec2(y,{indicesAccessor:c}),R=s.getVec2(y+1,{indicesAccessor:c}),P=s.getVec2(y+2,{indicesAccessor:c}),V=l.getVec3(y,{indicesAccessor:c});this.__calcTangentFor3Vertices(y,g,E,w,T,R,P,V,v,c)}n.setVertexAttribute(v,ee.Tangent.XYZ)}}}__calcTangentFor3Vertices(n,t,o,r,i,a,s,l,c,u){let _=this.__calcTangentPerVertex(t,o,r,i,a,s,l,rt.__tmpReturnVec3_0),d=this.__calcTangentPerVertex(o,r,t,a,s,i,l,rt.__tmpReturnVec3_1),p=this.__calcTangentPerVertex(r,t,o,s,i,a,l,rt.__tmpReturnVec3_2);c.setVec4(n,_.x,_.y,_.z,1,{indicesAccessor:u}),c.setVec4(n+1,d.x,d.y,d.z,1,{indicesAccessor:u}),c.setVec4(n+2,p.x,p.y,p.z,1,{indicesAccessor:u})}__calcTangentPerVertex(n,t,o,r,i,a,s,l){let c=[rt.__tmpVec3_0.setComponents(n.x,r.x,r.y),rt.__tmpVec3_1.setComponents(n.y,r.x,r.y),rt.__tmpVec3_2.setComponents(n.z,r.x,r.y)],u=[rt.__tmpVec3_3.setComponents(t.x,i.x,i.y),rt.__tmpVec3_4.setComponents(t.y,i.x,i.y),rt.__tmpVec3_5.setComponents(t.z,i.x,i.y)],_=[rt.__tmpVec3_6.setComponents(o.x,a.x,a.y),rt.__tmpVec3_7.setComponents(o.y,a.x,a.y),rt.__tmpVec3_8.setComponents(o.z,a.x,a.y)],d=[],p=[];for(let x=0;x<3;x++){let v=L.subtractTo(u[x],c[x],rt.__tmpVec3_9),y=L.subtractTo(_[x],u[x],rt.__tmpVec3_10),g=L.crossTo(v,y,rt.__tmpVec3_11),E=Math.abs(g.x)<Number.EPSILON;if(E)return N.assert(E,"Polygons or polygons on UV are degenerate!"),S.fromCopyArray([0,0,0]);d[x]=-g.y/g.x,p[x]=-g.z/g.x}return d[0]*d[0]+d[1]*d[1]+d[2]*d[2]<Number.EPSILON?(L.crossTo(s,t,l),l.normalize()):l.setComponents(d[0],d[1],d[2]).normalize()}__usePreCalculatedTangent(){return!(this.tangentCalculationMode===0||this.tangentCalculationMode===1||this.tangentCalculationMode===3)}_calcBaryCentricCoord(){for(let n of this.__primitives){if(n.attributeSemantics.indexOf(ee.BaryCentricCoord.XYZ)!==-1)return;let o=we.getInstance().createOrGetBuffer(Ce.CPUGeneric),r=n.attributeSemantics.indexOf(ee.Position.XYZ),s=n.attributeAccessors[r].elementCount,l=s*4*4,u=o.takeBufferView({byteLengthToNeed:l,byteStride:0}).unwrapForce().takeAccessor({compositionType:b.Vec4,componentType:I.Float,count:s}).unwrapForce();for(let _=0;_<s;_++)u.setVec4(_,_%3===0?1:0,_%3===1?1:0,_%3===2?1:0,_,{});n.setVertexAttribute(u,ee.BaryCentricCoord.XYZ)}}_calcFaceNormalsIfNonNormal(){for(let n of this.__primitives){if(n.attributeSemantics.indexOf(ee.Normal.XYZ)!==-1)return;this.__hasFaceNormal=!0;let o=n.attributeSemantics.indexOf(ee.Position.XYZ),r=n.attributeAccessors[o],i=n.indicesAccessor,a=3;(n.primitiveMode===Re.TriangleStrip||n.primitiveMode===Re.TriangleFan)&&(a=1);let s=n.getVertexCountAsIndicesBased(),l=we.getInstance().createOrGetBuffer(Ce.CPUGeneric),c=r.byteLength,_=l.takeBufferView({byteLengthToNeed:c,byteStride:0}).unwrapForce().takeAccessor({compositionType:b.Vec3,componentType:I.Float,count:r.elementCount}).unwrapForce();for(let d=0;d<s-2;d+=a){let p=r.getVec3(d,{indicesAccessor:i}),x=r.getVec3(d+1,{indicesAccessor:i}),v=r.getVec3(d+2,{indicesAccessor:i});this.__calcFaceNormalFor3Vertices(d,p,x,v,_,i)}n.setVertexAttribute(_,ee.Normal.XYZ)}}__calcFaceNormalFor3Vertices(n,t,o,r,i,a){let s=o.x-t.x,l=o.y-t.y,c=o.z-t.z,u=r.x-t.x,_=r.y-t.y,d=r.z-t.z,p=l*d-c*_,x=c*u-s*d,v=s*_-l*u,y=Math.hypot(p,x,v);y<=1e-6&&(y=1e-4),y=1/y,p*=y,x*=y,v*=y,i.setVec3(n,p,x,v,{indicesAccessor:a}),i.setVec3(n+1,p,x,v,{indicesAccessor:a}),i.setVec3(n+2,p,x,v,{indicesAccessor:a})}getPrimitiveIndexInMesh(n){return this.primitives.indexOf(n)}applyMaterialVariant(n){for(let t of this.primitives)t.applyMaterialVariant(n)}getCurrentVariantName(){function n(o){return o.every(r=>r===o[0])}h(n,"allEqual");let t=this.primitives.map(o=>o.getCurrentVariantName());return t.length===0?"":n(t)?t[0]:""}getVariantNames(){let n=[];for(let t of this.primitives)Array.prototype.push.apply(n,t.getVariantNames());return n}isSetUpDone(){let n=!0;for(let t of this.primitives)if(t.vertexHandles==null){n=!1;break}return n?this.__latestPrimitivePositionAccessorVersionForSetUpDone!==this.__primitivePositionUpdateCount?(this.__latestPrimitivePositionAccessorVersionForSetUpDone=this.__primitivePositionUpdateCount,!1):!0:!1}};h(rt,"Mesh"),f(rt,"invalidateMeshUID",-1),f(rt,"__mesh_uid_count",rt.invalidateMeshUID),f(rt,"__tmpVec3_0",L.zero()),f(rt,"__tmpVec3_1",L.zero()),f(rt,"__tmpVec3_2",L.zero()),f(rt,"__tmpVec3_3",L.zero()),f(rt,"__tmpVec3_4",L.zero()),f(rt,"__tmpVec3_5",L.zero()),f(rt,"__tmpVec3_6",L.zero()),f(rt,"__tmpVec3_7",L.zero()),f(rt,"__tmpVec3_8",L.zero()),f(rt,"__tmpVec3_9",L.zero()),f(rt,"__tmpVec3_10",L.zero()),f(rt,"__tmpVec3_11",L.zero()),f(rt,"__tmpReturnVec3_0",L.zero()),f(rt,"__tmpReturnVec3_1",L.zero()),f(rt,"__tmpReturnVec3_2",L.zero());_t=rt});function vp(){let m=ne.createEntity();return ne.tryToAddComponentToEntityByTID(Q.TransformComponentTID,m)}var gp=C(()=>{"use strict";at();it();h(vp,"createTransformEntity")});function en(){let m=vp();return ne.tryToAddComponentToEntityByTID(Q.SceneGraphComponentTID,m)}var dr=C(()=>{"use strict";at();gp();it();h(en,"createGroupEntity")});function Ct(){let m=en(),n=ne.tryToAddComponentToEntityByTID(Q.MeshComponentTID,m);return ne.tryToAddComponentToEntityByTID(Q.MeshRendererComponentTID,n)}var si=C(()=>{"use strict";at();dr();it();h(Ct,"createMeshEntity")});var Fi,Qc,yp=C(()=>{"use strict";Ia();Nn();Xt();_o();ye();ai();ge();si();Fi=class Fi extends $o{constructor(n){super(n)}get isSetup(){return this.__topEntity!=null}_setup(){if(this.__toSkipSetup())return;this.__topEntity=Ct(),this.__topEntity.tryToSetUniqueName(`AABBGizmo_of_${this.__target.uniqueName}`,!0),this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix=!0,this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph());let n=this.__topEntity.tryToGetMesh();Fi.__mesh=new _t,Fi.__mesh.addPrimitive(Fi.generatePrimitive()),n.setMesh(Fi.__mesh),this.setGizmoTag(),this._update()}static generatePrimitive(){let n=new Uint32Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,3,3,7,7,4,4,0,1,2,2,6,6,5,5,1,0,1,1,5,5,4,4,0,3,2,2,6,6,7,7,3]),t=1,o=new Float32Array([-t,-t,-t,t,-t,-t,t,t,-t,-t,t,-t,-t,-t,t,t,-t,t,t,t,t,-t,t,t]);return $e.createPrimitive({indices:n,attributeSemantics:[ee.Position.XYZ],attributes:[o],primitiveMode:Re.Lines})}_update(){if(this.__topEntity==null)return;let t=this.__target.getSceneGraph().worldMergedAABBWithSkeletal;this.__topEntity.getTransform().localPosition=t.centerPoint,this.__topEntity.getTransform().localScale=S.fromCopyArray([t.sizeX/2,t.sizeY/2,t.sizeZ/2])}_destroy(){A.exist(this.__topEntity)&&this.__topEntity._destroy()}};h(Fi,"AABBGizmo"),f(Fi,"__mesh");Qc=Fi});var wr,Xc,bp=C(()=>{"use strict";si();Nn();Xt();ai();_o();ye();ge();Ia();wr=class wr extends $o{constructor(n){super(n)}get isSetup(){return this.__topEntity!=null}set length(n){wr.__length=n}get length(){return wr.__length}_setup(){if(this.__toSkipSetup())return;this.__topEntity=Ct(),this.__topEntity.tryToSetUniqueName(`LocatorGizmo_of_${this.__target.uniqueName}`,!0),this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix=!0,this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph());let n=this.__topEntity.tryToGetMesh();wr.__mesh=new _t,wr.__mesh.addPrimitive(wr.__generatePrimitive()),n.setMesh(wr.__mesh),this.setGizmoTag()}_update(){if(this.__topEntity==null)return;let n=this.__target.getSceneGraph(),t=n.worldMergedAABBWithSkeletal;t.isVanilla()?this.__topEntity.getTransform().localPosition=n.position:this.__topEntity.getTransform().localPosition=t.centerPoint,this.__topEntity.getTransform().localScale=S.fromCopyArray([Math.max(1,t.isVanilla()?1:t.sizeX/2),Math.max(1,t.isVanilla()?1:t.sizeY/2),Math.max(1,t.isVanilla()?1:t.sizeZ/2)])}static __generatePrimitive(){let n=new Float32Array([0,0,0,this.__length,0,0,0,0,0,0,this.__length,0,0,0,0,0,0,this.__length]),t=new Float32Array([1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1]);return $e.createPrimitive({attributeSemantics:[ee.Position.XYZ,ee.Color0.XYZ],attributes:[n,t],primitiveMode:Re.Lines})}_destroy(){A.exist(this.__topEntity)&&this.__topEntity._destroy()}};h(wr,"LocatorGizmo"),f(wr,"__mesh"),f(wr,"__length",1);Xc=wr});var Ap,ro,li=C(()=>{"use strict";_o();Ap=class Ap extends $e{};h(Ap,"IShape");ro=Ap});var Ip,io,Hc=C(()=>{"use strict";Nn();Xt();ye();ge();li();Ip=class Ip extends ro{generate(n){var _;let t={widthVector:(_=n.widthVector)!=null?_:S.fromCopy3(1,1,1),color:n.color,material:n.material},o=[3,1,0,2,1,3,4,5,7,7,5,6,8,9,11,11,9,10,15,13,12,14,13,15,19,17,16,18,17,19,20,21,23,23,21,22],r=[-t.widthVector.x/2,t.widthVector.y/2,-t.widthVector.z/2,t.widthVector.x/2,t.widthVector.y/2,-t.widthVector.z/2,t.widthVector.x/2,t.widthVector.y/2,t.widthVector.z/2,-t.widthVector.x/2,t.widthVector.y/2,t.widthVector.z/2,-t.widthVector.x/2,-t.widthVector.y/2,-t.widthVector.z/2,t.widthVector.x/2,-t.widthVector.y/2,-t.widthVector.z/2,t.widthVector.x/2,-t.widthVector.y/2,t.widthVector.z/2,-t.widthVector.x/2,-t.widthVector.y/2,t.widthVector.z/2,-t.widthVector.x/2,-t.widthVector.y/2,t.widthVector.z/2,t.widthVector.x/2,-t.widthVector.y/2,t.widthVector.z/2,t.widthVector.x/2,t.widthVector.y/2,t.widthVector.z/2,-t.widthVector.x/2,t.widthVector.y/2,t.widthVector.z/2,-t.widthVector.x/2,-t.widthVector.y/2,-t.widthVector.z/2,t.widthVector.x/2,-t.widthVector.y/2,-t.widthVector.z/2,t.widthVector.x/2,t.widthVector.y/2,-t.widthVector.z/2,-t.widthVector.x/2,t.widthVector.y/2,-t.widthVector.z/2,t.widthVector.x/2,-t.widthVector.y/2,-t.widthVector.z/2,t.widthVector.x/2,-t.widthVector.y/2,t.widthVector.z/2,t.widthVector.x/2,t.widthVector.y/2,t.widthVector.z/2,t.widthVector.x/2,t.widthVector.y/2,-t.widthVector.z/2,-t.widthVector.x/2,-t.widthVector.y/2,-t.widthVector.z/2,-t.widthVector.x/2,-t.widthVector.y/2,t.widthVector.z/2,-t.widthVector.x/2,t.widthVector.y/2,t.widthVector.z/2,-t.widthVector.x/2,t.widthVector.y/2,-t.widthVector.z/2],i=A.not.exist(t.color)?[]:[t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a,t.color.r,t.color.g,t.color.b,t.color.a],a=[0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1],s=[0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0],l=[ee.Position.XYZ,ee.Normal.XYZ,ee.Texcoord0.XY],c=[new Float32Array(r),new Float32Array(s),new Float32Array(a)];A.exist(t.color)&&(l.push(ee.Color0.XYZ),c.push(new Float32Array(i)));let u=Re.Triangles;this.copyVertexData({attributes:c,attributeSemantics:l,primitiveMode:u,indices:new Uint16Array(o),material:t.material})}};h(Ip,"Cube");io=Ip});var Sp,er,qc=C(()=>{"use strict";Xt();Nn();li();Sp=class Sp extends ro{generate(n){var u,_,d,p,x,v;let t={width:(u=n.width)!=null?u:1,height:(_=n.height)!=null?_:1,uSpan:(d=n.uSpan)!=null?d:1,vSpan:(p=n.vSpan)!=null?p:1,isUVRepeat:(x=n.isUVRepeat)!=null?x:!1,flipTextureCoordinateY:(v=n.flipTextureCoordinateY)!=null?v:!1,material:n.material},o=[];for(let y=0;y<=t.vSpan;y++)for(let g=0;g<=t.uSpan;g++)o.push((g/t.uSpan-1/2)*t.width),o.push(0),o.push((y/t.vSpan-1/2)*t.height);let r=[];for(let y=0;y<t.vSpan;y++){let g=0,E=0;for(let w=0;w<=t.uSpan;w++)r.push(y*(t.uSpan+1)+w),r.push((y+1)*(t.uSpan+1)+w),w===0?g=(y+1)*(t.uSpan+1)+w:w===t.uSpan&&(E=(y+1)*(t.uSpan+1)+w);r.push(E),r.push(g)}let i=[];for(let y=0;y<=t.vSpan;y++)for(let g=0;g<=t.uSpan;g++)i.push(0),i.push(1),i.push(0);let a=[];for(let y=0;y<=t.vSpan;y++){let g=t.flipTextureCoordinateY?y:t.vSpan-y;for(let E=0;E<=t.uSpan;E++)t.isUVRepeat?(a.push(E),a.push(g)):(a.push(E/t.uSpan),a.push(g/t.vSpan))}let s=[ee.Position.XYZ,ee.Normal.XYZ,ee.Texcoord0.XY],l=Re.TriangleStrip,c=[new Float32Array(o),new Float32Array(i),new Float32Array(a)];this.copyVertexData({attributes:c,attributeSemantics:s,primitiveMode:l,indices:new Uint16Array(r),material:t==null?void 0:t.material})}};h(Sp,"Plane");er=Sp});var O,jc,Tp=C(()=>{"use strict";$t();St();tt();ni();Nn();Xt();ai();_o();Hc();qc();_r();yo();nn();ji();or();Bo();ye();It();ge();Vn();$a();Ia();dr();si();me();O=class O extends $o{constructor(t){super(t);f(this,"__pickStatedPoint",S.zero());f(this,"__deltaPoint",S.zero());f(this,"__targetPointBackup",S.zero());f(this,"__isPointerDown",!1);f(this,"__latestTargetEntity");f(this,"__onPointerDownFunc",this.__onPointerDown.bind(this));f(this,"__onPointerMoveFunc",this.__onPointerMove.bind(this));f(this,"__onPointerUpFunc",this.__onPointerUp.bind(this))}get isSetup(){return this.__topEntity!=null}set length(t){O.__length=t}get length(){return O.__length}set isVisible(t){if(this.__isVisible===!1&&t===!0){let o=window;if(A.exist(F.eventTargetDom)&&(o=F.eventTargetDom),Ft.register(vr,[{eventName:Kr("start"),handler:this.__onPointerDownFunc,options:{},classInstance:this,eventTargetDom:o},{eventName:Kr("move"),handler:this.__onPointerMoveFunc,options:{},classInstance:this,eventTargetDom:o},{eventName:Kr("end"),handler:this.__onPointerUpFunc,options:{},classInstance:this,eventTargetDom:o},{eventName:"pointerleave",handler:this.__onPointerUpFunc,options:{},classInstance:this,eventTargetDom:o}]),this.__topEntity.getSceneGraph().addChild(O.__groupEntity.getSceneGraph()),this.__latestTargetEntity=this.__target,O.__space==="local"){let r=this.__target.getSceneGraph().parent,i=H.identity();A.exist(r)&&(i=r.getQuaternionRecursively()),O.__groupEntity.getTransform().localRotation=i}else O.__space==="world"&&(O.__groupEntity.getTransform().localRotation=H.fromCopy4(0,0,0,1))}this.__isVisible===!0&&t===!1&&(Ft.unregister(vr),this.__deltaPoint=this.__target.getTransform().localPosition,this.__pickStatedPoint=S.zero(),this.__isPointerDown=!1,this.__targetPointBackup=this.__target.getTransform().localPosition,O.__activeAxis="none"),Ft.setActive(vr,t),this.__setVisible(t),O.__xyPlaneEntity.getSceneGraph().isVisible=!1,O.__yzPlaneEntity.getSceneGraph().isVisible=!1,O.__zxPlaneEntity.getSceneGraph().isVisible=!1}setSpace(t){O.__space=t,this.__isVisible&&(this.isVisible=!1,this.isVisible=!0)}get isVisible(){return this.__isVisible}_setup(){this.__toSkipSetup()||(this.__topEntity=en(),this.__topEntity.tryToSetUniqueName(`TranslationGizmo_of_${this.__target.uniqueName}`,!0),this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix=!0,this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph()),A.not.exist(O.__xCubeEntity)&&(O.__xCubeEntity=Ct(),O.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_xCube",!0),O.__xCubeEntity.getTransform().localPosition=S.fromCopy3(1,0,0),O.__xCubeMesh=new _t,O.__xCubeMaterial=Oe.createClassicUberMaterial(),O.__xCubeMaterial.setParameter("diffuseColorFactor",q.fromCopyArray4([1,0,0,1])),O.__xCubePrimitive=new io,O.__xCubePrimitive.generate({widthVector:S.fromCopy3(1,.05,.05),material:O.__xCubeMaterial}),O.__xCubeMesh.addPrimitive(O.__xCubePrimitive),O.__xCubeEntity.getMesh().setMesh(O.__xCubeMesh)),A.not.exist(O.__yCubeEntity)&&(O.__yCubeEntity=Ct(),O.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_yCube",!0),O.__yCubeEntity.getTransform().localPosition=S.fromCopy3(0,1,0),O.__yCubeMesh=new _t,O.__yCubeMaterial=Oe.createClassicUberMaterial(),O.__yCubeMaterial.setParameter("diffuseColorFactor",q.fromCopyArray4([0,1,0,1])),O.__yCubePrimitive=new io,O.__yCubePrimitive.generate({widthVector:S.fromCopy3(.05,1,.05),material:O.__yCubeMaterial}),O.__yCubeMesh.addPrimitive(O.__yCubePrimitive),O.__yCubeEntity.getMesh().setMesh(O.__yCubeMesh)),A.not.exist(O.__zCubeEntity)&&(O.__zCubeEntity=Ct(),O.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_zCube",!0),O.__zCubeEntity.getTransform().localPosition=S.fromCopy3(0,0,1),O.__zCubeMesh=new _t,O.__zCubeMaterial=Oe.createClassicUberMaterial(),O.__zCubeMaterial.setParameter("diffuseColorFactor",q.fromCopyArray4([0,0,1,1])),O.__zCubePrimitive=new io,O.__zCubePrimitive.generate({widthVector:S.fromCopy3(.05,.05,1),material:O.__zCubeMaterial}),O.__zCubeMesh.addPrimitive(O.__zCubePrimitive),O.__zCubeEntity.getMesh().setMesh(O.__zCubeMesh)),A.not.exist(O.__xyPlaneEntity)&&(O.__xyPlaneEntity=Ct(),O.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_xyPlane",!0),O.__xyPlaneEntity.getSceneGraph().isVisible=!1,O.__xyPlaneEntity.getTransform().localEulerAngles=S.fromCopy3(Y.degreeToRadian(90),0,0),O.__xyPlaneMaterial=Oe.createClassicUberMaterial(),O.__xyPlaneMaterial.alphaMode=Tt.Blend,O.__xyPlaneMaterial.setParameter("diffuseColorFactor",q.fromCopyArray4([0,0,.5,0])),O.__xyPlaneMesh=new _t,O.__xyPlanePrimitive=new er,O.__xyPlanePrimitive.generate({width:1e5,height:1e5,uSpan:1,vSpan:1,isUVRepeat:!0,flipTextureCoordinateY:!1,material:O.__xyPlaneMaterial}),O.__xyPlaneMesh.addPrimitive(O.__xyPlanePrimitive),O.__xyPlaneEntity.getMesh().setMesh(O.__xyPlaneMesh)),A.not.exist(O.__yzPlaneEntity)&&(O.__yzPlaneEntity=Ct(),O.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_yzPlane",!0),O.__yzPlaneEntity.getSceneGraph().isVisible=!1,O.__yzPlaneEntity.getTransform().localEulerAngles=S.fromCopy3(0,0,Y.degreeToRadian(90)),O.__yzPlaneMaterial=Oe.createClassicUberMaterial(),O.__yzPlaneMaterial.alphaMode=Tt.Blend,O.__yzPlaneMaterial.setParameter("diffuseColorFactor",q.fromCopyArray4([.5,0,0,0])),O.__yzPlaneMesh=new _t,O.__yzPlanePrimitive=new er,O.__yzPlanePrimitive.generate({width:1e5,height:1e5,uSpan:1,vSpan:1,isUVRepeat:!0,flipTextureCoordinateY:!1,material:O.__yzPlaneMaterial}),O.__yzPlaneMesh.addPrimitive(O.__yzPlanePrimitive),O.__yzPlaneEntity.getMesh().setMesh(O.__yzPlaneMesh)),A.not.exist(O.__zxPlaneEntity)&&(O.__zxPlaneEntity=Ct(),O.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_zxPlane",!0),O.__zxPlaneEntity.getSceneGraph().isVisible=!1,O.__zxPlaneMaterial=Oe.createClassicUberMaterial(),O.__zxPlaneMaterial.setParameter("diffuseColorFactor",q.fromCopyArray4([0,.5,0,0])),O.__zxPlaneMaterial.alphaMode=Tt.Blend,O.__zxPlaneMesh=new _t,O.__zxPlanePrimitive=new er,O.__zxPlanePrimitive.generate({width:1e5,height:1e5,uSpan:1,vSpan:1,isUVRepeat:!0,flipTextureCoordinateY:!1,material:O.__zxPlaneMaterial}),O.__zxPlaneMesh.addPrimitive(O.__zxPlanePrimitive),O.__zxPlaneEntity.getMesh().setMesh(O.__zxPlaneMesh)),A.not.exist(O.__groupEntity)&&(O.__groupEntity=en()),this.__topEntity.getSceneGraph().addChild(O.__groupEntity.getSceneGraph()),O.__groupEntity.getSceneGraph().addChild(O.__xCubeEntity.getSceneGraph()),O.__groupEntity.getSceneGraph().addChild(O.__yCubeEntity.getSceneGraph()),O.__groupEntity.getSceneGraph().addChild(O.__zCubeEntity.getSceneGraph()),O.__groupEntity.getSceneGraph().addChild(O.__xyPlaneEntity.getSceneGraph()),O.__groupEntity.getSceneGraph().addChild(O.__yzPlaneEntity.getSceneGraph()),O.__groupEntity.getSceneGraph().addChild(O.__zxPlaneEntity.getSceneGraph()),this.__latestTargetEntity=this.__target,this.setGizmoTag())}_update(){if(this.__topEntity==null)return;let t=this.__target.getSceneGraph(),o=t.worldMergedAABBWithSkeletal;o.isVanilla()?this.__topEntity.getTransform().localPosition=t.position:this.__topEntity.getTransform().localPosition=o.centerPoint;let r=Math.max(o.sizeX,o.sizeY,o.sizeZ);this.__topEntity.getTransform().localScale=S.fromCopyArray([Math.min(1,o.isVanilla()?1:r/2),Math.min(1,o.isVanilla()?1:r/2),Math.min(1,o.isVanilla()?1:r/2)]),this.__isPointerDown&&this.__latestTargetEntity===this.__target&&(this.__target.getTransform().localPosition=this.__deltaPoint.clone())}static __generatePrimitive(){let t=new Float32Array([0,0,0,this.__length,0,0,0,0,0,0,this.__length,0,0,0,0,0,0,this.__length]),o=new Float32Array([1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1]);return $e.createPrimitive({attributeSemantics:[ee.Position.XYZ,ee.Color0.XYZ],attributes:[t,o],primitiveMode:Re.Lines})}__onPointerDown(t){t.preventDefault(),this.__isPointerDown=!0,O.__originalX=t.clientX,O.__originalY=t.clientY;let o=this.__target.getSceneGraph().parent,r=Se.identity();A.exist(o)&&(r=o.matrixInner.getRotate());let i=S.one(),a=Ut.fromCopy9RowMajor(i.x*r.m00,i.x*r.m01,i.x*r.m02,i.y*r.m10,i.y*r.m11,i.y*r.m12,i.z*r.m20,i.z*r.m21,i.z*r.m22);O.__space==="local"?a=Ut.transpose(a):O.__space==="world"&&(a=We.identity());let{xResult:s,yResult:l,zResult:c}=O.castRay(t);s.result&&(jn(s.data),this.__pickStatedPoint=a.multiplyVector(s.data.position.clone()),N.debug("Down:"+this.__pickStatedPoint.toStringApproximately()),O.__activeAxis="x"),l.result&&(jn(l.data),this.__pickStatedPoint=a.multiplyVector(l.data.position.clone()),N.debug("Down:"+this.__pickStatedPoint.toStringApproximately()),O.__activeAxis="y"),c.result&&(jn(c.data),this.__pickStatedPoint=a.multiplyVector(c.data.position.clone()),N.debug("Down:"+this.__pickStatedPoint.toStringApproximately()),O.__activeAxis="z"),this.__latestTargetEntity===this.__target&&(this.__targetPointBackup=this.__target.getTransform().localPosition)}__onPointerMove(t){if(t.preventDefault(),A.false(this.__isPointerDown))return;let o=t.target.getBoundingClientRect(),r=t.target.clientWidth,i=t.target.clientHeight,a=t.clientX-o.left,s=o.height-(t.clientY-o.top),l=q.fromCopy4(0,0,r,i),c=J.getComponent(re,re.current),u=this.__target.getSceneGraph().parent,_=Se.identity();A.exist(u)&&(_=u.matrixInner.getRotate());let d=S.one(),p=Ut.fromCopy9RowMajor(d.x*_.m00,d.x*_.m01,d.x*_.m02,d.y*_.m10,d.y*_.m11,d.y*_.m12,d.z*_.m20,d.z*_.m21,d.z*_.m22);O.__space==="local"?p=Ut.transpose(p):O.__space==="world"&&(p=We.identity());let x=this.__pickStatedPoint.clone();if(O.__activeAxis==="x"){let y=O.__xyPlaneEntity.getMesh().castRayFromScreenInWorld(a,s,c,l,0);if(y.result){jn(y.data);let g=p.multiplyVector(y.data.position);x=S.fromCopy3(g.x,x.y,x.z)}Ft.disableCameraController()}if(O.__activeAxis==="y"){let y=O.__xyPlaneEntity.getMesh().castRayFromScreenInWorld(a,s,c,l,0);if(y.result){jn(y.data);let g=p.multiplyVector(y.data.position);x=S.fromCopy3(x.x,g.y,x.z)}Ft.disableCameraController()}if(O.__activeAxis==="z"){let y=O.__yzPlaneEntity.getMesh().castRayFromScreenInWorld(a,s,c,l,0);if(y.result){jn(y.data);let g=p.multiplyVector(y.data.position);x=S.fromCopy3(x.x,x.y,g.z)}Ft.disableCameraController()}let v=S.subtract(x,this.__pickStatedPoint);if(v.length()!==0){if(N.debug(`${this.__target.uniqueName}: `+v.toStringApproximately()),O.__space==="local")this.__deltaPoint=S.add(v,this.__targetPointBackup);else if(O.__space==="world"){let y=this.__target.getSceneGraph().parent,g=Se.identity();A.exist(y)&&(g=y.matrix.getRotate());let E=S.one(),w=Ut.fromCopy9RowMajor(E.x*g.m00,E.x*g.m01,E.x*g.m02,E.y*g.m10,E.y*g.m11,E.y*g.m12,E.z*g.m20,E.z*g.m21,E.z*g.m22);w=Ut.transpose(w);let T=S.add(this.__targetPointBackup,w.multiplyVector(v));this.__deltaPoint=T}}}__onPointerUp(t){t.preventDefault(),this.__isPointerDown=!1,O.__activeAxis="none",Ft.enableCameraController(),this.__latestTargetEntity===this.__target&&(this.__targetPointBackup=this.__target.getTransform().localPosition)}static castRay2(t){let o=t.target.getBoundingClientRect(),r=t.target.clientWidth,i=t.target.clientHeight,a=t.clientX-o.left,s=o.height-(t.clientY-o.top),l=q.fromCopy4(0,0,r,i),c=J.getComponent(re,re.current);return O.__groupEntity.getSceneGraph().castRayFromScreen(a,s,c,l,0,[])}static castRay(t){let o=t.target.getBoundingClientRect(),r=t.target.clientWidth,i=t.target.clientHeight,a=t.clientX-o.left,s=o.height-(t.clientY-o.top),l=q.fromCopy4(0,0,r,i),c=J.getComponent(re,re.current),u=O.__xCubeEntity.getMesh().castRayFromScreenInWorld(a,s,c,l,0),_=O.__yCubeEntity.getMesh().castRayFromScreenInWorld(a,s,c,l,0),d=O.__zCubeEntity.getMesh().castRayFromScreenInWorld(a,s,c,l,0);return{xResult:u,yResult:_,zResult:d}}_destroy(){A.exist(this.__topEntity)&&this.__topEntity._destroy()}};h(O,"TranslationGizmo"),f(O,"__groupEntity"),f(O,"__xCubeEntity"),f(O,"__yCubeEntity"),f(O,"__zCubeEntity"),f(O,"__xCubeMesh"),f(O,"__yCubeMesh"),f(O,"__zCubeMesh"),f(O,"__xCubePrimitive"),f(O,"__yCubePrimitive"),f(O,"__zCubePrimitive"),f(O,"__xCubeMaterial"),f(O,"__yCubeMaterial"),f(O,"__zCubeMaterial"),f(O,"__xyPlaneEntity"),f(O,"__yzPlaneEntity"),f(O,"__zxPlaneEntity"),f(O,"__xyPlaneMesh"),f(O,"__yzPlaneMesh"),f(O,"__zxPlaneMesh"),f(O,"__xyPlanePrimitive"),f(O,"__yzPlanePrimitive"),f(O,"__zxPlanePrimitive"),f(O,"__xyPlaneMaterial"),f(O,"__yzPlaneMaterial"),f(O,"__zxPlaneMaterial"),f(O,"__originalX",0),f(O,"__originalY",0),f(O,"__activeAxis","none"),f(O,"__space","world"),f(O,"__length",1);jc=O});var M,Yc,Ep=C(()=>{"use strict";$t();si();dr();St();tt();ni();Nn();Xt();ai();_o();Hc();qc();_r();nn();ji();yo();or();Bo();ye();It();ge();me();Vn();$a();Ia();M=class M extends $o{constructor(t){super(t);f(this,"__pickStatedPoint",S.zero());f(this,"__deltaPoint",S.one());f(this,"__targetScaleBackup",S.one());f(this,"__isPointerDown",!1);f(this,"__onPointerDownFunc",this.__onPointerDown.bind(this));f(this,"__onPointerMoveFunc",this.__onPointerMove.bind(this));f(this,"__onPointerUpFunc",this.__onPointerUp.bind(this))}get isSetup(){return this.__topEntity!=null}set length(t){M.__length=t}get length(){return M.__length}set isVisible(t){if(this.__isVisible===!1&&t===!0){let o=window;if(A.exist(F.eventTargetDom)&&(o=F.eventTargetDom),Ft.register(gr,[{eventName:Kr("start"),handler:this.__onPointerDownFunc,options:{},classInstance:this,eventTargetDom:o},{eventName:Kr("move"),handler:this.__onPointerMoveFunc,options:{},classInstance:this,eventTargetDom:o},{eventName:Kr("end"),handler:this.__onPointerUpFunc,options:{},classInstance:this,eventTargetDom:o},{eventName:"pointerleave",handler:this.__onPointerUpFunc,options:{},classInstance:this,eventTargetDom:o}]),this.__topEntity.getSceneGraph().addChild(M.__groupEntity.getSceneGraph()),M.__latestTargetEntity=this.__target,M.__space==="local"){let r=this.__target.getSceneGraph(),i=H.identity();A.exist(r)&&(i=r.getQuaternionRecursively()),M.__groupEntity.getTransform().localRotation=i}else M.__space==="world"&&(M.__groupEntity.getTransform().localRotation=H.fromCopy4(0,0,0,1))}this.__isVisible===!0&&t===!1&&(Ft.unregister(gr),this.__deltaPoint=this.__target.getTransform().localScale,this.__pickStatedPoint=S.zero(),this.__isPointerDown=!1,this.__targetScaleBackup=this.__target.getTransform().localScale,M.__activeAxis="none"),Ft.setActive(gr,t),this.__setVisible(t),M.__xyPlaneEntity.getSceneGraph().isVisible=!1,M.__yzPlaneEntity.getSceneGraph().isVisible=!1,M.__zxPlaneEntity.getSceneGraph().isVisible=!1}setSpace(t){M.__space=t,this.__isVisible&&(this.isVisible=!1,this.isVisible=!0)}get isVisible(){return this.__isVisible}_setup(){this.__toSkipSetup()||(this.__topEntity=en(),this.__topEntity.tryToSetUniqueName(`ScaleGizmo_of_${this.__target.uniqueName}`,!0),this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix=!0,this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph()),A.not.exist(M.__xCubeEntity)&&(this.xMesh(),this.xEdgeMesh()),A.not.exist(M.__yCubeEntity)&&(this.yMesh(),this.yEdgeMesh()),A.not.exist(M.__zCubeEntity)&&(this.zMesh(),this.zEdgeMesh()),A.not.exist(M.__xyPlaneEntity)&&this.xyPlane(),A.not.exist(M.__yzPlaneEntity)&&this.yzPlane(),A.not.exist(M.__zxPlaneEntity)&&this.zxPlane(),A.not.exist(M.__groupEntity)&&(M.__groupEntity=en()),this.__topEntity.getSceneGraph().addChild(M.__groupEntity.getSceneGraph()),M.__groupEntity.getSceneGraph().addChild(M.__xCubeEntity.getSceneGraph()),M.__groupEntity.getSceneGraph().addChild(M.__yCubeEntity.getSceneGraph()),M.__groupEntity.getSceneGraph().addChild(M.__zCubeEntity.getSceneGraph()),M.__groupEntity.getSceneGraph().addChild(M.__xyPlaneEntity.getSceneGraph()),M.__groupEntity.getSceneGraph().addChild(M.__yzPlaneEntity.getSceneGraph()),M.__groupEntity.getSceneGraph().addChild(M.__zxPlaneEntity.getSceneGraph()),M.__latestTargetEntity=this.__target,this.setGizmoTag())}zxPlane(){M.__zxPlaneEntity=Ct(),M.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_zxPlane",!0),M.__zxPlaneEntity.getSceneGraph().isVisible=!1,M.__zxPlaneMaterial=Oe.createClassicUberMaterial(),M.__zxPlaneMaterial.setParameter("diffuseColorFactor",q.fromCopyArray4([0,.5,0,0])),M.__zxPlaneMaterial.alphaMode=Tt.Blend,M.__zxPlaneMesh=new _t,M.__zxPlanePrimitive=new er,M.__zxPlanePrimitive.generate({width:1e5,height:1e5,uSpan:1,vSpan:1,isUVRepeat:!0,flipTextureCoordinateY:!1,material:M.__zxPlaneMaterial}),M.__zxPlaneMesh.addPrimitive(M.__zxPlanePrimitive),M.__zxPlaneEntity.getMesh().setMesh(M.__zxPlaneMesh)}yzPlane(){M.__yzPlaneEntity=Ct(),M.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_yzPlane",!0),M.__yzPlaneEntity.getSceneGraph().isVisible=!1,M.__yzPlaneEntity.getTransform().localEulerAngles=S.fromCopy3(0,0,Y.degreeToRadian(90)),M.__yzPlaneMaterial=Oe.createClassicUberMaterial(),M.__yzPlaneMaterial.alphaMode=Tt.Blend,M.__yzPlaneMaterial.setParameter("diffuseColorFactor",q.fromCopyArray4([.5,0,0,0])),M.__yzPlaneMesh=new _t,M.__yzPlanePrimitive=new er,M.__yzPlanePrimitive.generate({width:1e5,height:1e5,uSpan:1,vSpan:1,isUVRepeat:!0,flipTextureCoordinateY:!1,material:M.__yzPlaneMaterial}),M.__yzPlaneMesh.addPrimitive(M.__yzPlanePrimitive),M.__yzPlaneEntity.getMesh().setMesh(M.__yzPlaneMesh)}xyPlane(){M.__xyPlaneEntity=Ct(),M.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_xyPlane",!0),M.__xyPlaneEntity.getSceneGraph().isVisible=!1,M.__xyPlaneEntity.getTransform().localEulerAngles=S.fromCopy3(Y.degreeToRadian(90),0,0),M.__xyPlaneMaterial=Oe.createClassicUberMaterial(),M.__xyPlaneMaterial.alphaMode=Tt.Blend,M.__xyPlaneMaterial.setParameter("diffuseColorFactor",q.fromCopyArray4([0,0,.5,0])),M.__xyPlaneMesh=new _t,M.__xyPlanePrimitive=new er,M.__xyPlanePrimitive.generate({width:1e5,height:1e5,uSpan:1,vSpan:1,isUVRepeat:!0,flipTextureCoordinateY:!1,material:M.__xyPlaneMaterial}),M.__xyPlaneMesh.addPrimitive(M.__xyPlanePrimitive),M.__xyPlaneEntity.getMesh().setMesh(M.__xyPlaneMesh)}zMesh(){M.__zCubeEntity=Ct(),M.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_zCube",!0),M.__zCubeEntity.getTransform().localPosition=S.fromCopy3(0,0,1),M.__zCubeMesh=new _t,M.__zCubeMaterial=Oe.createClassicUberMaterial(),M.__zCubeMaterial.setParameter("diffuseColorFactor",q.fromCopyArray4([0,0,1,1])),M.__zCubePrimitive=new io,M.__zCubePrimitive.generate({widthVector:S.fromCopy3(.05,.05,1),material:M.__zCubeMaterial}),M.__zCubeMesh.addPrimitive(M.__zCubePrimitive),M.__zCubeEntity.getMesh().setMesh(M.__zCubeMesh)}yMesh(){M.__yCubeEntity=Ct(),M.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_yCube",!0),M.__yCubeEntity.getTransform().localPosition=S.fromCopy3(0,1,0),M.__yCubeMesh=new _t,M.__yCubeMaterial=Oe.createClassicUberMaterial(),M.__yCubeMaterial.setParameter("diffuseColorFactor",q.fromCopyArray4([0,1,0,1])),M.__yCubePrimitive=new io,M.__yCubePrimitive.generate({widthVector:S.fromCopy3(.05,1,.05),material:M.__yCubeMaterial}),M.__yCubeMesh.addPrimitive(M.__yCubePrimitive),M.__yCubeEntity.getMesh().setMesh(M.__yCubeMesh)}xMesh(){M.__xCubeEntity=Ct(),M.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_xCube",!0),M.__xCubeEntity.getTransform().localPosition=S.fromCopy3(1,0,0),M.__xCubeMesh=new _t,M.__xCubeMaterial=Oe.createClassicUberMaterial(),M.__xCubeMaterial.setParameter("diffuseColorFactor",q.fromCopyArray4([1,0,0,1])),M.__xCubePrimitive=new io,M.__xCubePrimitive.generate({widthVector:S.fromCopy3(1,.05,.05),material:M.__xCubeMaterial}),M.__xCubeMesh.addPrimitive(M.__xCubePrimitive),M.__xCubeEntity.getMesh().setMesh(M.__xCubeMesh)}xEdgeMesh(){M.__xEdgeCubeEntity=Ct(),M.__xEdgeCubeEntity.tryToSetUniqueName("ScaleGizmo_xEdgeCube",!0),M.__xEdgeCubeEntity.getTransform().localPosition=S.fromCopy3(1,0,0),M.__xEdgeCubeMesh=new _t,M.__xEdgeCubePrimitive=new io,M.__xEdgeCubePrimitive.generate({widthVector:S.fromCopy3(.1,.1,.1),material:M.__xCubeMaterial}),M.__xEdgeCubeMesh.addPrimitive(M.__xEdgeCubePrimitive),M.__xEdgeCubeEntity.getMesh().setMesh(M.__xEdgeCubeMesh),M.__xCubeEntity.addChild(M.__xEdgeCubeEntity.getSceneGraph())}yEdgeMesh(){M.__yEdgeCubeEntity=Ct(),M.__yEdgeCubeEntity.tryToSetUniqueName("ScaleGizmo_yEdgeCube",!0),M.__yEdgeCubeEntity.getTransform().localPosition=S.fromCopy3(0,1,0),M.__yEdgeCubeMesh=new _t,M.__yEdgeCubePrimitive=new io,M.__yEdgeCubePrimitive.generate({widthVector:S.fromCopy3(.1,.1,.1),material:M.__yCubeMaterial}),M.__yEdgeCubeMesh.addPrimitive(M.__yEdgeCubePrimitive),M.__yEdgeCubeEntity.getMesh().setMesh(M.__yEdgeCubeMesh),M.__yCubeEntity.addChild(M.__yEdgeCubeEntity.getSceneGraph())}zEdgeMesh(){M.__zEdgeCubeEntity=Ct(),M.__zEdgeCubeEntity.tryToSetUniqueName("ScaleGizmo_zEdgeCube",!0),M.__zEdgeCubeEntity.getTransform().localPosition=S.fromCopy3(0,0,1),M.__zEdgeCubeMesh=new _t,M.__zEdgeCubePrimitive=new io,M.__zEdgeCubePrimitive.generate({widthVector:S.fromCopy3(.1,.1,.1),material:M.__zCubeMaterial}),M.__zEdgeCubeMesh.addPrimitive(M.__zEdgeCubePrimitive),M.__zEdgeCubeEntity.getMesh().setMesh(M.__zEdgeCubeMesh),M.__zCubeEntity.addChild(M.__zEdgeCubeEntity.getSceneGraph())}_update(){if(this.__topEntity==null)return;let t=this.__target.getSceneGraph(),o=t.worldMergedAABBWithSkeletal;o.isVanilla()?this.__topEntity.getTransform().localPosition=t.position:this.__topEntity.getTransform().localPosition=o.centerPoint;let r=Math.max(o.sizeX,o.sizeY,o.sizeZ);this.__topEntity.getTransform().localScale=S.fromCopyArray([Math.min(1,o.isVanilla()?1:r/2),Math.min(1,o.isVanilla()?1:r/2),Math.min(1,o.isVanilla()?1:r/2)]),this.__isPointerDown&&M.__latestTargetEntity===this.__target&&(this.__target.getTransform().localScale=this.__deltaPoint.clone())}static __generatePrimitive(){let t=new Float32Array([0,0,0,this.__length,0,0,0,0,0,0,this.__length,0,0,0,0,0,0,this.__length]),o=new Float32Array([1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1]);return $e.createPrimitive({attributeSemantics:[ee.Position.XYZ,ee.Color0.XYZ],attributes:[t,o],primitiveMode:Re.Lines})}__onPointerDown(t){t.preventDefault(),this.__isPointerDown=!0,M.__originalX=t.clientX,M.__originalY=t.clientY;let o=this.__target.getSceneGraph().matrix.getRotate(),r=S.one(),i=Ut.fromCopy9RowMajor(r.x*o.m00,r.x*o.m01,r.x*o.m02,r.y*o.m10,r.y*o.m11,r.y*o.m12,r.z*o.m20,r.z*o.m21,r.z*o.m22);M.__space==="local"?i=Ut.transpose(i):M.__space==="world"&&(i=We.identity());let{xResult:a,yResult:s,zResult:l}=M.castRay(t);a.result&&(jn(a.data),this.__pickStatedPoint=i.multiplyVector(a.data.position.clone()),N.debug("Down:"+this.__pickStatedPoint.toStringApproximately()),M.__activeAxis="x"),s.result&&(jn(s.data),this.__pickStatedPoint=i.multiplyVector(s.data.position.clone()),N.debug("Down:"+this.__pickStatedPoint.toStringApproximately()),M.__activeAxis="y"),l.result&&(jn(l.data),this.__pickStatedPoint=i.multiplyVector(l.data.position.clone()),N.debug("Down:"+this.__pickStatedPoint.toStringApproximately()),M.__activeAxis="z"),M.__latestTargetEntity===this.__target&&(this.__targetScaleBackup=this.__target.getTransform().localScale)}__onPointerMove(t){if(t.preventDefault(),A.false(this.__isPointerDown))return;let o=t.target.getBoundingClientRect(),r=t.target.clientWidth,i=t.target.clientHeight,a=t.clientX-o.left,s=o.height-(t.clientY-o.top),l=q.fromCopy4(0,0,r,i),c=J.getComponent(re,re.current),u=this.__target.getSceneGraph().matrix.getRotate(),_=S.one(),d=Ut.fromCopy9RowMajor(_.x*u.m00,_.x*u.m01,_.x*u.m02,_.y*u.m10,_.y*u.m11,_.y*u.m12,_.z*u.m20,_.z*u.m21,_.z*u.m22);M.__space==="local"?d=Ut.transpose(d):M.__space==="world"&&(d=We.identity());let p=this.__pickStatedPoint.clone();if(M.__activeAxis==="x"){let g=M.__xyPlaneEntity.getMesh().castRayFromScreenInWorld(a,s,c,l,0);if(g.result){jn(g.data);let E=d.multiplyVector(g.data.position);p=S.fromCopy3(E.x,p.y,p.z),N.debug("Move:"+g.data.position.toStringApproximately())}Ft.disableCameraController()}if(M.__activeAxis==="y"){let g=M.__xyPlaneEntity.getMesh().castRayFromScreenInWorld(a,s,c,l,0);if(g.result){jn(g.data);let E=d.multiplyVector(g.data.position);p=S.fromCopy3(p.x,E.y,p.z),N.debug("Move:"+g.data.position.toStringApproximately())}Ft.disableCameraController()}if(M.__activeAxis==="z"){let g=M.__yzPlaneEntity.getMesh().castRayFromScreenInWorld(a,s,c,l,0);if(g.result){jn(g.data);let E=d.multiplyVector(g.data.position);p=S.fromCopy3(p.x,p.y,E.z),N.debug("Move:"+g.data.position.toStringApproximately())}Ft.disableCameraController()}let v=this.__target.getSceneGraph().worldMergedAABBWithSkeletal,y=S.multiply(S.subtract(p,this.__pickStatedPoint),1/v.lengthCenterToCorner);if(N.debug(`${this.__target.uniqueName}: `+y.toStringApproximately()),M.__space==="local")this.__deltaPoint=S.add(this.__targetScaleBackup,y),this.__deltaPoint=S.fromCopy3(Math.max(this.__deltaPoint.x,.01),Math.max(this.__deltaPoint.y,.01),Math.max(this.__deltaPoint.z,.01));else if(M.__space==="world"){let g=Se.fromCopyQuaternion(this.__target.getSceneGraph().getQuaternionRecursively()),E=Se.multiply(g,Se.scale(this.__targetScaleBackup)).getScale(),w=q.add(y,E);w=q.fromCopy4(Math.max(w.x,.01),Math.max(w.y,.01),Math.max(w.z,.01),Math.max(w.w,.01)),this.__deltaPoint=Se.multiply(Se.invert(g),Se.scale(w)).getScale(),this.__deltaPoint=S.fromCopy3(Math.max(this.__deltaPoint.x,.01),Math.max(this.__deltaPoint.y,.01),Math.max(this.__deltaPoint.z,.01))}}__onPointerUp(t){t.preventDefault(),this.__isPointerDown=!1,M.__activeAxis="none",Ft.enableCameraController(),M.__latestTargetEntity===this.__target&&(this.__targetScaleBackup=this.__target.getTransform().localScale)}static castRay2(t){let o=t.target.getBoundingClientRect(),r=t.target.clientWidth,i=t.target.clientHeight,a=t.clientX-o.left,s=o.height-(t.clientY-o.top),l=q.fromCopy4(0,0,r,i),c=J.getComponent(re,re.current);return M.__groupEntity.getSceneGraph().castRayFromScreen(a,s,c,l,0,[])}static castRay(t){let o=t.target.getBoundingClientRect(),r=t.target.clientWidth,i=t.target.clientHeight,a=t.clientX-o.left,s=o.height-(t.clientY-o.top),l=q.fromCopy4(0,0,r,i),c=J.getComponent(re,re.current),u=M.__xCubeEntity.getSceneGraph().castRayFromScreen(a,s,c,l,0),_=M.__yCubeEntity.getSceneGraph().castRayFromScreen(a,s,c,l,0),d=M.__zCubeEntity.getSceneGraph().castRayFromScreen(a,s,c,l,0);return{xResult:u,yResult:_,zResult:d}}_destroy(){A.exist(this.__topEntity)&&this.__topEntity._destroy()}};h(M,"ScaleGizmo"),f(M,"__groupEntity"),f(M,"__xCubeEntity"),f(M,"__yCubeEntity"),f(M,"__zCubeEntity"),f(M,"__xCubeMesh"),f(M,"__yCubeMesh"),f(M,"__zCubeMesh"),f(M,"__xCubePrimitive"),f(M,"__yCubePrimitive"),f(M,"__zCubePrimitive"),f(M,"__xEdgeCubeEntity"),f(M,"__yEdgeCubeEntity"),f(M,"__zEdgeCubeEntity"),f(M,"__xEdgeCubeMesh"),f(M,"__yEdgeCubeMesh"),f(M,"__zEdgeCubeMesh"),f(M,"__xEdgeCubePrimitive"),f(M,"__yEdgeCubePrimitive"),f(M,"__zEdgeCubePrimitive"),f(M,"__xCubeMaterial"),f(M,"__yCubeMaterial"),f(M,"__zCubeMaterial"),f(M,"__xyPlaneEntity"),f(M,"__yzPlaneEntity"),f(M,"__zxPlaneEntity"),f(M,"__xyPlaneMesh"),f(M,"__yzPlaneMesh"),f(M,"__zxPlaneMesh"),f(M,"__xyPlanePrimitive"),f(M,"__yzPlanePrimitive"),f(M,"__zxPlanePrimitive"),f(M,"__xyPlaneMaterial"),f(M,"__yzPlaneMaterial"),f(M,"__zxPlaneMaterial"),f(M,"__originalX",0),f(M,"__originalY",0),f(M,"__activeAxis","none"),f(M,"__space","world"),f(M,"__latestTargetEntity"),f(M,"__length",1);Yc=M});var ao,Ro,Kc=C(()=>{"use strict";Or();ye();ge();ao=class ao{constructor(){f(this,"__body");f(this,"__entity");f(this,"__property");f(this,"__localScale",S.one());if(A.not.exist(ao.__world)){let n=new OIMO.World({timestep:.016666666666666666,iterations:8,broadphase:2,worldscale:1,random:ao.__worldProperty.random,info:!1,gravity:[ao.__worldProperty.gravity.x,ao.__worldProperty.gravity.y,ao.__worldProperty.gravity.z]});ao.__world=n}}setShape(n,t){let o=ao.__world;this.__localScale=n.size,this.__property={type:n.type.str.toLowerCase(),size:[n.size.x,n.size.y,n.size.z],pos:[n.position.x,n.position.y,n.position.z],rot:[n.rotation.x,n.rotation.y,n.rotation.z],move:n.move,density:n.density,friction:n.friction,restitution:n.restitution},this.__body=o.add(this.__property),this.__entity=t}update(){if(this.__entity===void 0)return;let n=this.__body.getPosition(),t=this.__body.getQuaternion();this.__entity.getSceneGraph().setPositionWithoutPhysics(S.fromCopy3(n.x,n.y,n.z)),this.__entity.getSceneGraph().setRotationWithoutPhysics(H.fromCopy4(t.x,t.y,t.z,t.w))}setPosition(n){let t=ao.__world;if(this.__entity===void 0)return;this.__body.remove();let o=this.__property;this.__property={type:o.type,size:[o.size[0],o.size[1],o.size[2]],pos:[n.x,n.y,n.z],rot:[this.__entity.eulerAngles.x,this.__entity.eulerAngles.y,this.__entity.eulerAngles.z],move:o.move,density:o.density,friction:o.friction,restitution:o.restitution},this.__body=t.add(this.__property)}setEulerAngle(n){let t=ao.__world;if(this.__entity===void 0)return;let o=this.__body.getPosition();this.__body.remove();let r=this.__property;this.__property={type:r.type,size:[r.size[0],r.size[1],r.size[2]],pos:[o.x,o.y,o.z],rot:[Y.radianToDegree(n.x),Y.radianToDegree(n.y),Y.radianToDegree(n.z)],move:r.move,density:r.density,friction:r.friction,restitution:r.restitution},this.__body=t.add(this.__property)}setScale(n){let t=ao.__world;if(this.__entity===void 0)return;let o=this.__body.getPosition();this.__body.remove();let r=this.__property;this.__property={type:r.type,size:[this.__localScale.x*n.x,this.__localScale.y*n.y,this.__localScale.z*n.z],pos:[o.x,o.y,o.z],rot:[this.__entity.eulerAngles.x,this.__entity.eulerAngles.y,this.__entity.eulerAngles.z],move:r.move,density:r.density,friction:r.friction,restitution:r.restitution},this.__body=t.add(this.__property)}static update(){A.exist(ao.__world)&&ao.__world.step()}};h(ao,"OimoPhysicsStrategy"),f(ao,"__worldProperty",{gravity:S.fromCopy3(0,-9.8,0),random:!0}),f(ao,"__world");Ro=ao});var Le,Wt,Li=C(()=>{"use strict";dn();yo();at();xe();it();cr();Cn();Yt();or();ye();pi();Ot();yp();bp();ge();Tp();Ep();Kc();Wr();Wc();gi();br();Bo();Le=class Le extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"__parent");f(this,"__children",[]);f(this,"__gizmoChildren",[]);f(this,"_worldMatrix",$.dummy());f(this,"_worldMatrixRest",$.identity());f(this,"_normalMatrix",We.dummy());f(this,"__isWorldMatrixUpToDate",!1);f(this,"__isWorldMatrixRestUpToDate",!1);f(this,"__isNormalMatrixUpToDate",!1);f(this,"__worldMergedAABBWithSkeletal",new jt);f(this,"__worldMergedAABB",new jt);f(this,"__isWorldAABBDirty",!0);f(this,"_isVisible",ut.dummy());f(this,"_isBillboard",ut.dummy());f(this,"__aabbGizmo");f(this,"__locatorGizmo");f(this,"__translationGizmo");f(this,"__scaleGizmo");f(this,"__transformGizmoSpace","world");f(this,"__latestPrimitivePositionAccessorVersion",0);f(this,"toMakeWorldMatrixTheSameAsLocalMatrix",!1);f(this,"isRootJoint",!1);f(this,"jointIndex",-1);f(this,"_isCulled",!1);f(this,"__lastTransformComponentsUpdateCount",-1);Le.__sceneGraphs.push(new WeakRef(this)),this.registerMember(Ce.GPUInstanceData,"worldMatrix",$,I.Float,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.registerMember(Ce.GPUInstanceData,"normalMatrix",We,I.Float,[1,0,0,0,1,0,0,0,1]),this.registerMember(Ce.GPUInstanceData,"isVisible",ut,I.Float,[1]),this.registerMember(Ce.GPUInstanceData,"isBillboard",ut,I.Float,[0]),this.submitToAllocation(this.maxNumberOfComponent,i)}set isVisible(t){this._isVisible.setValue(t?1:0),Le.__updateCount++}get isVisible(){return this._isVisible.getValue()===1}static get updateCount(){return Le.__updateCount}setVisibilityRecursively(t){this.isVisible=t;for(let o of this.__children)o.setVisibilityRecursively(t)}set isBillboard(t){this._isBillboard.setValue(t?1:0)}get isBillboard(){return this._isBillboard.getValue()===1}setIsBillboardRecursively(t){this._isBillboard.setValue(t?1:0);for(let o of this.__children)o.isBillboard=t}set isAABBGizmoVisible(t){t?(A.not.defined(this.__aabbGizmo)&&(this.__aabbGizmo=new Qc(this.entity),this.__aabbGizmo._setup()),this.__aabbGizmo.isVisible=!0):A.exist(this.__aabbGizmo)&&(this.__aabbGizmo.isVisible=!1)}get isAABBGizmoVisible(){return A.exist(this.__aabbGizmo)?this.__aabbGizmo.isVisible:!1}set isLocatorGizmoVisible(t){t?(A.not.defined(this.__locatorGizmo)&&(this.__locatorGizmo=new Xc(this.entity),this.__locatorGizmo._setup()),this.__locatorGizmo.isVisible=!0):A.exist(this.__locatorGizmo)&&(this.__locatorGizmo.isVisible=!1)}get isLocatorGizmoVisible(){return A.exist(this.__locatorGizmo)?this.__locatorGizmo.isVisible:!1}set isTranslationGizmoVisible(t){t?(A.not.defined(this.__translationGizmo)&&(this.__translationGizmo=new jc(this.entity),this.__translationGizmo._setup()),this.__translationGizmo.isVisible=!0):A.exist(this.__translationGizmo)&&(this.__translationGizmo.isVisible=!1)}get isTranslationGizmoVisible(){return A.exist(this.__translationGizmo)?this.__translationGizmo.isVisible:!1}set isScaleGizmoVisible(t){t?(A.not.defined(this.__scaleGizmo)&&(this.__scaleGizmo=new Yc(this.entity),this.__scaleGizmo._setup()),this.__scaleGizmo.isVisible=!0):A.exist(this.__scaleGizmo)&&(this.__scaleGizmo.isVisible=!1)}get isScaleGizmoVisible(){return A.exist(this.__scaleGizmo)?this.__scaleGizmo.isVisible:!1}static getTopLevelComponents(){return Le.__sceneGraphs.map(t=>t.deref()).filter(t=>t!==void 0?t.isTopLevel:!1).filter(t=>t!==void 0)}isJoint(){return this.jointIndex>=0}static get componentTID(){return Q.SceneGraphComponentTID}get componentTID(){return Q.SceneGraphComponentTID}setWorldMatrixRestDirty(){this.matrixRestInner,this.setWorldMatrixRestDirtyRecursively()}setWorldMatrixRestDirtyRecursively(){this.__isWorldMatrixRestUpToDate=!1,this.children.forEach(t=>{t.setWorldMatrixRestDirtyRecursively()})}setWorldMatrixDirty(){var t;this.setWorldMatrixDirtyRecursively(),(t=this.parent)==null||t.setWorldAABBDirtyParentRecursively()}setWorldMatrixDirtyRecursively(){this.__isWorldMatrixUpToDate=!1,this.__isNormalMatrixUpToDate=!1,this.__isWorldAABBDirty=!0,this.children.forEach(t=>{t.setWorldMatrixDirtyRecursively()})}setWorldAABBDirtyParentRecursively(){var t;this.__isWorldAABBDirty=!0,(t=this.parent)==null||t.setWorldAABBDirtyParentRecursively()}addChild(t){A.exist(t.__parent)&&t.__parent.removeChild(t),t.__parent=this,this.__children.push(t)}removeChild(t){let o=this.__children.indexOf(t);o>=0&&this.__children.splice(o,1),t.__parent=void 0}_addGizmoChild(t){t.__parent=this,this.__gizmoChildren.push(t)}get isTopLevel(){return this.__parent==null}get children(){return this.__children}get parent(){return this.__parent}get matrixInner(){return this.__isWorldMatrixUpToDate||(this._worldMatrix.copyComponents(this.__calcWorldMatrixRecursively()),this.__isWorldMatrixUpToDate=!0),this._worldMatrix}get matrix(){return this.matrixInner.clone()}get matrixRestInner(){return this.__isWorldMatrixRestUpToDate||(this._worldMatrixRest.copyComponents(this.__calcWorldMatrixRestRecursively()),this.__isWorldMatrixRestUpToDate=!0),this._worldMatrixRest}get matrixRest(){return this.matrixRestInner.clone()}get normalMatrixInner(){return this.__isNormalMatrixUpToDate||(Se.invertTo(this.matrixInner,Le.invertedMatrix44),this._normalMatrix.copyComponents(Le.invertedMatrix44.transpose()),this.__isNormalMatrixUpToDate=!0),this._normalMatrix}get entityWorldWithSkeletalMatrix(){return this.entityWorldMatrixWithSkeletalInner.clone()}get entityWorldMatrixWithSkeletalInner(){let t=this.entity.tryToGetSkeletal();return A.exist(t)&&t.isWorldMatrixUpdated?t.worldMatrixInner:this.entity.getSceneGraph().matrixInner}get normalMatrix(){return this.normalMatrixInner.clone()}isWorldMatrixUpToDateRecursively(){return this.__isWorldMatrixUpToDate?this.__parent?this.__parent.isWorldMatrixUpToDateRecursively():!0:!1}__calcWorldMatrixRecursively(){if(this.__isWorldMatrixUpToDate)return this._worldMatrix;let t=this.entity.getTransform();if(this.__parent==null||this.toMakeWorldMatrixTheSameAsLocalMatrix)return t.getLocalMatrixInnerTo(Le.__tmp_mat4_2),Le.__tmp_mat4_2;let o=this.__parent.__calcWorldMatrixRecursively();return t.getLocalMatrixInnerTo(Le.__tmp_mat4_3),$.multiplyTo(o,Le.__tmp_mat4_3,Le.__tmp_mat4)}__calcWorldMatrixRestRecursively(){if(this.__isWorldMatrixRestUpToDate)return this._worldMatrixRest;let t=this.entity.getTransform();if(this.__parent==null||this.toMakeWorldMatrixTheSameAsLocalMatrix)return t.getLocalMatrixInnerTo(Le.__tmp_mat4_2),Le.__tmp_mat4_2;let o=this.__parent.__calcWorldMatrixRestRecursively();return t.getLocalMatrixInnerTo(Le.__tmp_mat4_3),$.multiplyTo(o,Le.__tmp_mat4_3,Le.__tmp_mat4)}getQuaternionRecursively(){if(A.not.exist(this.parent))return this.entity.getTransform().localRotation;let t=this.parent.getQuaternionRecursively();return H.multiply(t,this.entity.getTransform().localRotation)}get worldPosition(){let t=Le.__originVector3;return this.matrixInner.multiplyVector3To(t,Le.returnVector3),Le.returnVector3}getWorldPositionOf(t){return this.matrixInner.multiplyVector3(t)}getWorldPositionOfTo(t,o){return this.matrixInner.multiplyVector3To(t,o)}getLocalPositionOf(t){return Se.invert(this.matrixInner).multiplyVector3(t)}getLocalPositionOfTo(t,o){return Se.invertTo(this.matrixInner,Le.__tmp_mat4).multiplyVector3To(t,o)}getWorldAABB(){let t=new jt,o=this.entity.tryToGetMesh();return A.exist(o)&&A.exist(o.mesh)?(t.mergeAABB(o.mesh.AABB),jt.multiplyMatrixTo(this.entity.getSceneGraph().matrixInner,t,Le.__tmpAABB)):Le.__tmpAABB.initialize(),Le.__tmpAABB}calcWorldMergedAABB(){let t=this.getWorldAABB().clone();for(let o of this.children){let r=o.calcWorldMergedAABB();t.mergeAABB(r)}return this.__worldMergedAABB=t,t}get worldMergedAABB(){return this.__isWorldAABBDirty&&(this.calcWorldMergedAABB(),this.__isWorldAABBDirty=!1),this.__worldMergedAABB}getWorldAABBWithSkeletal(){let t=new jt,o=this.entity.tryToGetMesh();return A.exist(o)&&A.exist(o.mesh)?(t.mergeAABB(o.mesh.AABB),jt.multiplyMatrixTo(this.entity.getSceneGraph().entityWorldMatrixWithSkeletalInner,t,Le.__tmpAABB)):Le.__tmpAABB.initialize(),Le.__tmpAABB}calcWorldMergedAABBWithSkeletal(){let t=this.getWorldAABBWithSkeletal().clone();for(let o of this.children){let r=o.calcWorldMergedAABBWithSkeletal();t.mergeAABB(r)}return this.__worldMergedAABBWithSkeletal=t,t}get worldMergedAABBWithSkeletal(){return this.__isWorldAABBDirty&&(this.calcWorldMergedAABBWithSkeletal(),this.__isWorldAABBDirty=!1),this.__worldMergedAABBWithSkeletal}castRay(t,o,r=0,i=[]){let a=ii(this,!1),s=[];for(let p of a){let x=p.entity.tryToGetMesh();x&&s.push(x)}let l=Number.MAX_VALUE,c,u,_=0,d=0;for(let p of s){if(!p.entity.getSceneGraph().isVisible||!p.isPickable||i.indexOf(p)!==-1)continue;let x=p.castRay(t,o,r);A.defined(x.data)&&x.data.t<l&&(l=x.data.t,c=x.data.position,u=p,_=x.data.u,d=x.data.v)}return A.exist(u)&&A.exist(c)?{result:!0,data:{t:l,u:_,v:d,position:c,selectedMeshComponent:u}}:{result:!1}}castRayFromScreen(t,o,r,i,a=0,s=[]){let l=ii(this,!1),c=[];for(let v of l){let y=v.entity.tryToGetMesh();y&&c.push(y)}let u=Number.MAX_VALUE,_,d,p=0,x=0;for(let v of c){if(!v.entity.getSceneGraph().isVisible||!v.isPickable||s.indexOf(v)!==-1)continue;let y=v.castRayFromScreenInWorld(t,o,r,i,a);A.defined(y.data)&&y.data.t<u&&(u=y.data.t,_=y.data.position,d=v,p=y.data.u,x=y.data.v)}return A.exist(d)&&A.exist(_)?{result:!0,data:{t:u,u:p,v:x,position:_,selectedMeshComponent:d}}:{result:!1}}$load(){this.moveStageTo(Ne.Logic)}$logic(){this.__lastTransformComponentsUpdateCount!==Et.updateCount&&(this.matrixInner,this.normalMatrixInner,this.__updateGizmos(),this.__lastTransformComponentsUpdateCount=Et.updateCount)}__updateGizmos(){A.exist(this.__aabbGizmo)&&this.__aabbGizmo.isSetup&&this.__aabbGizmo.isVisible&&this.__aabbGizmo._update(),A.exist(this.__locatorGizmo)&&this.__locatorGizmo.isSetup&&this.__locatorGizmo.isVisible&&this.__locatorGizmo._update(),A.exist(this.__translationGizmo)&&this.__translationGizmo.isSetup&&this.__translationGizmo.isVisible&&this.__translationGizmo._update(),A.exist(this.__scaleGizmo)&&this.__scaleGizmo.isSetup&&this.__scaleGizmo.isVisible&&this.__scaleGizmo._update()}setPositionWithoutPhysics(t){A.not.exist(this.__parent)?this.entity.getTransform().localPosition=t:($.invertTo(this.__parent.entity.getSceneGraph().matrixInner,Le.__tmp_mat4),this.entity.getTransform().localPosition=Le.__tmp_mat4.multiplyVector3(t))}set position(t){this.setPositionWithoutPhysics(t);let o=this.entity.tryToGetPhysics();o!==void 0&&o.strategy!==void 0&&o.strategy instanceof Ro&&this.entity.tryToGetSceneGraph()!==void 0&&o.strategy.setPosition(t)}get position(){return this.matrixInner.getTranslate()}getPositionTo(t){return this.matrixInner.getTranslateTo(t)}get positionRest(){return this.matrixRestInner.getTranslate()}getPositionRestTo(t){return this.matrixRestInner.getTranslateTo(t)}set eulerAngles(t){if(A.not.exist(this.__parent))this.entity.getTransform().localEulerAngles=t;else{let r=H.fromMatrix(this.__parent.entity.getSceneGraph().matrixInner),i=H.invert(r),a=H.fromMatrix(Se.rotate(t)),s=H.multiply(a,i);this.entity.getTransform().localEulerAngles=s.toEulerAngles()}let o=this.entity.tryToGetPhysics();o!==void 0&&o.strategy!==void 0&&o.strategy instanceof Ro&&this.entity.tryToGetSceneGraph()!==void 0&&o.strategy.setEulerAngle(t)}get eulerAngles(){return this.matrixInner.toEulerAngles()}setRotationWithoutPhysics(t){if(A.not.exist(this.__parent))this.entity.getTransform().localRotation=t;else{let o=this.__parent.entity.getSceneGraph().rotation,r=H.invert(o);this.entity.getTransform().localRotation=H.multiply(t,r)}}set rotation(t){this.setRotationWithoutPhysics(t);let o=this.entity.tryToGetPhysics();o!==void 0&&o.strategy!==void 0&&o.strategy instanceof Ro&&this.entity.tryToGetSceneGraph()!==void 0&&o.strategy.setEulerAngle(t.toEulerAngles())}get rotation(){let t=this.parent;return t!=null?H.multiply(t.rotation,this.entity.getTransform().localRotationInner):this.entity.getTransform().localRotationInner}getRotationTo(t){let o=this.parent;if(o!=null)return H.multiplyTo(o.getRotationTo(Le.__tmp_quat_0),this.entity.getTransform().localRotationInner,t);let r=this.entity.getTransform().localRotationInner;return t.setComponents(r._v[0],r._v[1],r._v[2],r._v[3]),t}get rotationRest(){let t=this.parent;return t!=null?H.multiply(t.rotationRest,this.entity.getTransform().localRotationRestInner):this.entity.getTransform().localRotationRestInner}getRotationRest(t){let o=this.parent,r=t(this);return o!=null&&!r?H.multiply(o.getRotationRest(t),this.entity.getTransform().localRotationRestInner):this.entity.getTransform().localRotationRestInner}set scale(t){if(A.not.exist(this.__parent))this.entity.getTransform().localScale=t;else{let r=this.__parent.entity.getSceneGraph().matrix;r._v[12]=0,r._v[13]=0,r._v[14]=0;let i=$.invert(r);this.entity.getTransform().localScale=i.multiplyVector3(t)}let o=this.entity.tryToGetPhysics();o!==void 0&&o.strategy!==void 0&&o.strategy instanceof Ro&&this.entity.tryToGetSceneGraph()!==void 0&&o.strategy.setScale(t)}get scale(){return this.matrixInner.getScale()}__copyChild(t){let o=ne._shallowCopyEntityInner(t.entity);return o.getSceneGraph().__parent=this,o}_shallowCopyFrom(t){let o=t;this.__parent=o.__parent,this.__children=[];for(let r=0;r<o.__children.length;r++){let i=this.__copyChild(o.__children[r]).getSceneGraph();this.__children.push(i)}this.__gizmoChildren=o.__gizmoChildren.concat(),this._worldMatrix.copyComponents(o._worldMatrix),this._worldMatrixRest.copyComponents(o._worldMatrixRest),this._normalMatrix.copyComponents(o._normalMatrix),this.__isWorldMatrixUpToDate=!1,this.__isWorldMatrixRestUpToDate=!1,this.__isNormalMatrixUpToDate=!1,this.__worldMergedAABBWithSkeletal=o.__worldMergedAABBWithSkeletal.clone(),this.__isWorldAABBDirty=!0,this._isVisible.copyComponents(o._isVisible),this._isBillboard.copyComponents(o._isBillboard),this.__transformGizmoSpace=o.__transformGizmoSpace,this.__latestPrimitivePositionAccessorVersion=o.__latestPrimitivePositionAccessorVersion,this.toMakeWorldMatrixTheSameAsLocalMatrix=o.toMakeWorldMatrixTheSameAsLocalMatrix,this.isRootJoint=o.isRootJoint,this.jointIndex=o.jointIndex}get entity(){return ne.getEntity(this.__entityUid)}setTransformGizmoSpace(t){var o,r;this.__transformGizmoSpace=t,(o=this.__translationGizmo)==null||o.setSpace(t),(r=this.__scaleGizmo)==null||r.setSpace(t)}_destroy(){var t,o,r,i,a;super._destroy(),(t=this.__aabbGizmo)==null||t._destroy(),(o=this.__locatorGizmo)==null||o._destroy(),(r=this.__translationGizmo)==null||r._destroy(),(i=this.__scaleGizmo)==null||i._destroy(),(a=this.parent)==null||a.removeChild(this),this.children.forEach(s=>{var l;return(l=s.parent)==null?void 0:l.removeChild(s)})}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(l,c,u){super(l,c,u);f(this,"__sceneGraphcomponent")}getSceneGraph(){return this.__sceneGraphComponent===void 0&&(this.__sceneGraphComponent=this.getComponentByComponentTID(Q.SceneGraphComponentTID)),this.__sceneGraphComponent}get parent(){return this.getSceneGraph().parent}get matrix(){return this.getSceneGraph().matrix}get matrixInner(){return this.getSceneGraph().matrixInner}get position(){return this.getSceneGraph().position}set position(l){let c=this.getSceneGraph();c.position=l}get positionRest(){return this.getSceneGraph().positionRest}get scale(){return this.getSceneGraph().scale}set scale(l){let c=this.getSceneGraph();c.scale=l}get eulerAngles(){return this.getSceneGraph().eulerAngles}set eulerAngles(l){let c=this.getSceneGraph();c.eulerAngles=l}get rotation(){return this.getSceneGraph().rotation}set rotation(l){let c=this.getSceneGraph();c.rotation=l}get rotationRest(){return this.getSceneGraph().rotationRest}addChild(l){this.getSceneGraph().addChild(l)}get children(){return this.getSceneGraph().children}removeChild(l){this.getSceneGraph().removeChild(l)}},h(i,"SceneGraphEntity"),i);return vt(t,r),t}};h(Le,"SceneGraphComponent"),f(Le,"__originVector3",S.zero()),f(Le,"returnVector3",L.zero()),f(Le,"__sceneGraphs",[]),f(Le,"isJointAABBShouldBeCalculated",!1),f(Le,"invertedMatrix44",$.fromCopyArray16ColumnMajor([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])),f(Le,"__tmp_mat4",$.identity()),f(Le,"__tmp_mat4_2",$.identity()),f(Le,"__tmp_mat4_3",$.identity()),f(Le,"__tmp_quat_0",Ye.identity()),f(Le,"__tmp_quat_1",Ye.identity()),f(Le,"__updateCount",-1),f(Le,"__tmpAABB",new jt);Wt=Le});var Cp,No,Zc=C(()=>{"use strict";bi();Ke();pn();ft();Ze();Sr();Cp=class Cp extends mn{constructor(){super();f(this,"__fbo");f(this,"hdriFormat",wt.HDR_LINEAR);f(this,"_textureViewAsRenderTargetResourceUid",-1)}create({width:t,height:o,mipLevelCount:r,format:i}){this.__width=t,this.__height=o,this.__mipLevelCount=r!=null?r:Math.floor(Math.log2(Math.max(t,o)))+1;let{format:a,type:s}=oe.getPixelFormatAndComponentTypeFromTextureFormat(i);this.__internalFormat=i,this.__format=a,this.__type=s,this.__createRenderTargetTexture()}__createRenderTargetTexture(){let t=G.getCgApiResourceRepository(),o=t.createRenderTargetTextureCube({width:this.__width,height:this.__height,mipLevelCount:this.__mipLevelCount,format:this.__internalFormat});this._textureResourceUid=o,K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=t.createTextureViewCube(this._textureResourceUid),this._textureViewAsRenderTargetResourceUid=t.createCubeTextureViewAsRenderTarget(this._textureResourceUid,0,0))}generateMipmaps(){G.getCgApiResourceRepository().generateMipmapsCube(this._textureResourceUid,this.width,this.height)}resize(t,o){this.destroy3DAPIResources(),this.__width=t,this.__height=o,this.__createRenderTargetTexture()}destroy3DAPIResources(){return G.getCgApiResourceRepository().deleteTexture(this._textureResourceUid),this._textureResourceUid=G.InvalidCGAPIResourceUid,!0}createCubeTextureViewAsRenderTarget(t,o){if(K.currentProcessApproach===Z.WebGPU){let r=G.getWebGpuResourceRepository();this._textureViewAsRenderTargetResourceUid=r.createCubeTextureViewAsRenderTarget(this._textureResourceUid,t,o)}}set _fbo(t){this.__fbo=t}get fbo(){return this.__fbo}get mipmapLevelNumber(){return this.__mipLevelCount}setIsTextureReady(){this.__isTextureReady=!0}};h(Cp,"RenderTargetTextureCube");No=Cp});var sn,In,Vi=C(()=>{"use strict";St();dn();Ke();Cn();at();it();$t();Qn();kc();Wr();Bi();Li();Ze();Zc();sn=class sn extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"__diffuseCubeMap");f(this,"__specularCubeMap");f(this,"__sheenCubeMap");f(this,"__diffuseCubeMapContribution",1);f(this,"__specularCubeMapContribution",1);f(this,"__rotationOfCubeMap",0);f(this,"__updateCount",0)}static get componentTID(){return Q.MeshRendererComponentTID}get componentTID(){return Q.MeshRendererComponentTID}get diffuseCubeMap(){return this.__diffuseCubeMap}get specularCubeMap(){return this.__specularCubeMap}get sheenCubeMap(){return this.__sheenCubeMap}get updateCount(){return this.__updateCount}static get updateCount(){return sn.__updateCount}get diffuseCubeMapContribution(){return this.__diffuseCubeMapContribution}set diffuseCubeMapContribution(t){this.__diffuseCubeMapContribution=t,sn.__updateCount++}get specularCubeMapContribution(){return this.__specularCubeMapContribution}set specularCubeMapContribution(t){this.__specularCubeMapContribution=t,sn.__updateCount++}get rotationOfCubeMap(){return this.__rotationOfCubeMap}set rotationOfCubeMap(t){this.__rotationOfCubeMap=t,sn.__updateCount++}setIBLCubeMap(t,o,r){if(t==null||o==null)return;this.__diffuseCubeMap=t,this.__specularCubeMap=o,this.__sheenCubeMap=r;let i=[];return t instanceof No?i.push(new Promise(a=>{t.setIsTextureReady(),a()})):i.push(new Promise(a=>{t.startedToLoad?t.isTextureReady?a():t.registerOnTextureLoaded(()=>{a()}):t.loadTextureImagesAsync().then(()=>{a()})})),o instanceof No?i.push(new Promise(a=>{o.setIsTextureReady(),a()})):i.push(new Promise(a=>{o.startedToLoad?o.isTextureReady?a():o.registerOnTextureLoaded(()=>{a()}):o.loadTextureImagesAsync().then(()=>{a()})})),r!=null&&(r instanceof No?i.push(new Promise(a=>{r.setIsTextureReady(),a()})):i.push(new Promise(a=>{r.startedToLoad?r.isTextureReady?a():r.registerOnTextureLoaded(()=>{a()}):r.loadTextureImagesAsync().then(()=>{a()})}))),Promise.all(i).then(()=>{this.__updateCount++,sn.__updateCount++})}static common_$load({processApproach:t}){let o=Pe.getInstance();if(t===Z.WebGPU){let i=o.getModule("webgpu");sn.__cgApiRenderingStrategy=i.WebGpuStrategyBasic.getInstance(),sn.__cgApiRenderingStrategy.common_$load()}else{let i=o.getModule("webgl");sn.__cgApiRenderingStrategy=i.getRenderingStrategy(t)}}$load(){sn.__cgApiRenderingStrategy.$load(this.entity.tryToGetMesh())&&this.moveStageTo(Ne.Unknown)}static sort_$render(t){if(Et.updateCount===t._lastTransformComponentsUpdateCount&&an.updateCount===t._lastCameraControllerComponentsUpdateCount&&Wt.updateCount===t._lastSceneGraphComponentsUpdateCount)return t._lastPrimitiveUids;let o=t.cameraComponent;if(o==null&&(o=J.getComponent(re,re.current)),o==null&&(o=J.getComponentsWithType(re).find(p=>p!=null&&p._isAlive),re.current=o.componentSID),t.isVrRendering){let d=Pe.getInstance().getModule("xr");if(d!=null){let p=d.WebXRSystem.getInstance();p.isWebXRMode&&(o=p._getCameraComponentAt(0))}}let r=[],i=t._optimizedMeshComponents;r=sn.__cullingWithViewFrustum(o,i),r=Array.from(new Set(r)),r.sort((d,p)=>{let x=d._sortkey-p._sortkey;return x!==0?x:d._viewDepth-p._viewDepth});let a=r.map(d=>d.primitiveUid);a.push(-1);let s=r.length-1,l=r.length-1,c=r.length-1,u=r.length-1;for(let d=0;d<r.length;d++){let p=r[d];if(Uc(p)){s=d-1;break}if(nl(p)){s=d-1;break}if(Aa(p)){s=d-1;break}}for(let d=s+1;d<r.length;d++){let p=r[d];if(nl(p)){l=d-1;break}if(Aa(p)){l=d-1;break}}for(let d=l+1;d<r.length;d++){let p=r[d];if(Aa(p)){c=d-1;break}}let _=!1;if(s!=t._lastOpaqueIndex&&(t._lastOpaqueIndex=s,_||(_=!0)),l!=t._lastTranslucentIndex&&(t._lastTranslucentIndex=l,_||(_=!0)),c!=t._lastBlendWithZWriteIndex&&(t._lastBlendWithZWriteIndex=c,_||(_=!0)),u!=t._lastBlendWithoutZWriteIndex&&(t._lastBlendWithoutZWriteIndex=u,_||(_=!0)),a.length!==t._lastPrimitiveUids.length)_||(_=!0);else for(let d=l+1;d<a.length;d++)if(a[d]!==t._lastPrimitiveUids[d]){_||(_=!0);break}return t._isChangedSortRenderResult=_,t._lastPrimitiveUids=a,t._lastTransformComponentsUpdateCount=Et.updateCount,t._lastCameraControllerComponentsUpdateCount=an.updateCount,t._lastSceneGraphComponentsUpdateCount=Wt.updateCount,_&&(t._renderedSomethingBefore=!0),a}static __cullingWithViewFrustum(t,o){let r=[];if(t&&sn._isFrustumCullingEnabled){t.updateFrustum();let a=t.frustum,s=h((l,c)=>{if(l.entity.getTagValue("type")==="background-assets"?!0:a.culling(l)){c.push(l),l.entity.getSceneGraph()._isCulled=!1;let _=l.entity.tryToGetSkeletal();_!==void 0&&(_._isCulled=!1)}else{l.entity.getSceneGraph()._isCulled=!0;let _=l.entity.tryToGetSkeletal();_!==void 0&&(_._isCulled=!0)}},"frustumCulling");for(let l of o)l._isAlive&&l.entity.getSceneGraph().isVisible&&s(l,r)}else r=o.filter(a=>a._isAlive&&a.entity.getSceneGraph().isVisible);let i=[];for(let a=0;a<r.length;a++){let s=r[a],l=s.mesh;if(l!==void 0){let c=l.primitives,u=!1;for(let _=0;_<c.length;_++){let d=c[_];i.push(d),hp(d)&&(u=!0)}if(u){let _=s.calcViewDepth(t);for(let d=0;d<c.length;d++){let p=c[d];p._viewDepth=_}}}}return i}static common_$prerender(){if(sn.__cgApiRenderingStrategy==null){let t=K.currentProcessApproach;this.common_$load({processApproach:t})}sn.__cgApiRenderingStrategy.prerender()}static common_$render({renderPass:t,processStage:o,renderPassTickCount:r,primitiveUids:i}){return sn.__cgApiRenderingStrategy.common_$render(i,t,r)}$render({i:t,renderPass:o,renderPassTickCount:r}){}_shallowCopyFrom(t){let o=t;this.__diffuseCubeMap=o.__diffuseCubeMap,this.__specularCubeMap=o.__specularCubeMap,this.diffuseCubeMapContribution=o.diffuseCubeMapContribution,this.specularCubeMapContribution=o.specularCubeMapContribution,this.rotationOfCubeMap=o.rotationOfCubeMap}_destroy(){super._destroy(),this.__diffuseCubeMap=void 0,this.__specularCubeMap=void 0}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(s,l,c){super(s,l,c)}getMeshRenderer(){return this.getComponentByComponentTID(Q.MeshRendererComponentTID)}},h(i,"MeshRendererEntity"),i);return vt(t,r),t}};h(sn,"MeshRendererComponent"),f(sn,"__cgApiRenderingStrategy"),f(sn,"isDepthMaskTrueForBlendPrimitives",!1),f(sn,"__shaderProgramHandleOfPrimitiveObjectUids",new Map),f(sn,"__updateCount",0),f(sn,"_isFrustumCullingEnabled",!0);In=sn});var Rr,Po,Jc=C(()=>{"use strict";co();se();xe();Lo();Vo();Xt();_o();el();ge();ft();Pn();tt();bi();mo();So();Vi();ni();Vn();dm();$t();at();Ze();Gu();pn();Zc();me();Ac();Mh();kh();Rr=class Rr extends G{constructor(){super();f(this,"__webGpuResources",new Map);f(this,"__resourceCounter",G.InvalidCGAPIResourceUid);f(this,"__webGpuDeviceWrapper");f(this,"__storageBuffer");f(this,"__storageBlendShapeBuffer");f(this,"__bindGroupStorageBuffer");f(this,"__bindGroupLayoutStorageBuffer");f(this,"__webGpuRenderPipelineMap",new Map);f(this,"__materialStateVersionMap",new Map);f(this,"__bindGroupTextureMap",new Map);f(this,"__bindGroupLayoutTextureMap",new Map);f(this,"__bindGroupSamplerMap",new Map);f(this,"__bindGroupLayoutSamplerMap",new Map);f(this,"__bindGroupsUniformDrawParameters",new Map);f(this,"__bindGroupLayoutUniformDrawParameters");f(this,"__uniformDrawParametersBuffers",new Map);f(this,"__commandEncoder");f(this,"__renderBundles",new Map);f(this,"__renderBundleEncoder");f(this,"__systemDepthTexture");f(this,"__systemDepthTextureView");f(this,"__uniformMorphOffsetsBuffer");f(this,"__uniformMorphWeightsBuffer");f(this,"__renderPassEncoder");f(this,"__generateMipmapsShaderModule");f(this,"__generateMipmapsPipeline");f(this,"__generateMipmapsFormat");f(this,"__generateMipmapsSampler");f(this,"__generateMipmapsBindGroupLayout");f(this,"__contextCurrentTextureView");f(this,"__lastMaterialsUpdateCount",-1);f(this,"__lastCurrentCameraComponentSid",-1);f(this,"__lastEntityRepositoryUpdateCount",-1);f(this,"__lastPrimitivesMaterialVariantUpdateCount",-1);f(this,"__lastMeshRendererComponentsUpdateCount",-1);f(this,"__srcTextureViewsForGeneratingMipmaps",new Map);f(this,"__dstTextureViewsForGeneratingMipmaps",new Map);f(this,"__bindGroupsForGeneratingMipmaps",new Map)}clearCache(){this.__webGpuRenderPipelineMap.clear(),this.__materialStateVersionMap.clear(),this.__bindGroupTextureMap.clear(),this.__bindGroupLayoutTextureMap.clear(),this.__bindGroupSamplerMap.clear(),this.__bindGroupLayoutSamplerMap.clear(),this.__renderBundles.clear()}addWebGpuDeviceWrapper(t){this.__webGpuDeviceWrapper=t,this.__commandEncoder=this.__webGpuDeviceWrapper.gpuDevice.createCommandEncoder()}getWebGpuDeviceWrapper(){return this.__webGpuDeviceWrapper}static getInstance(){return this.__instance||(this.__instance=new Rr),this.__instance}getResourceNumber(){return++this.__resourceCounter}__registerResource(t){let o=this.getResourceNumber();return t._resourceUid=o,this.__webGpuResources.set(o,t),o}getCanvasSize(){let t=this.__webGpuDeviceWrapper.canvas;return[t.width,t.height]}createTextureFromImageBitmapData(t,{level:o,internalFormat:r,width:i,height:a,border:s,format:l,type:c,generateMipmap:u}){return this.__createTextureInner(i,a,r,u,t)}async createTextureFromDataUri(t,{level:o,internalFormat:r,border:i,format:a,type:s,generateMipmap:l}){return new Promise(c=>{let u=new Image;t.match(/^data:/)||(u.crossOrigin="Anonymous"),u.onload=async()=>{let _=u.width,d=u.height,p=await this.createTextureFromHTMLImageElement(u,{level:o,internalFormat:r,width:_,height:d,border:i,format:a,type:s,generateMipmap:l});c(p)},u.src=t})}generateMipmaps2d(t,o,r){let i=this.__webGpuResources.get(t),a={size:[o,r,1],format:i.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:Math.floor(Math.log2(Math.max(o,r)))+1};this.generateMipmaps(i,a)}generateMipmapsCube(t,o,r){let i=this.__webGpuResources.get(t),a={size:[o,r,6],format:i.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:Math.floor(Math.log2(Math.max(o,r)))+1};this.generateMipmaps(i,a)}async getTexturePixelData(t,o,r,i,a){let s=this.__webGpuResources.get(t),l=new Uint8Array(o*r*4),c=this.__webGpuDeviceWrapper.gpuDevice,u=c.createCommandEncoder(),_=c.createBuffer({size:o*r*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});u.copyTextureToBuffer({texture:s},{buffer:_,bytesPerRow:o*4},{width:o,height:r,depthOrArrayLayers:1}),c.queue.submit([u.finish()]),await _.mapAsync(GPUMapMode.READ);let d=_.getMappedRange();return l.set(new Uint8Array(d)),_.unmap(),l}generateMipmaps(t,o){let r=this.__webGpuDeviceWrapper.gpuDevice;if(this.__generateMipmapsShaderModule==null&&(this.__generateMipmapsShaderModule=r.createShaderModule({code:`
          var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
            vec2f(-1, 1), vec2f(1, 1),
            vec2f(-1, -1), vec2f(1, -1));

          struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) texCoord : vec2f,
          };

          @vertex
          fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);
            output.position = vec4f(pos[vertexIndex], 0, 1);
            return output;
          }

          @group(0) @binding(0) var imgSampler : sampler;
          @group(0) @binding(1) var img : texture_2d<f32>;

          @fragment
          fn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {
            return textureSample(img, imgSampler, texCoord);
          }
        `})),this.__generateMipmapsPipeline!=null&&o.format!=this.__generateMipmapsFormat&&(this.__generateMipmapsPipeline=void 0),this.__generateMipmapsPipeline==null){this.__generateMipmapsBindGroupLayout=r.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"2d"}}]});let s=r.createPipelineLayout({bindGroupLayouts:[this.__generateMipmapsBindGroupLayout]});this.__generateMipmapsPipeline=r.createRenderPipeline({layout:s,vertex:{module:this.__generateMipmapsShaderModule,entryPoint:"vertexMain"},fragment:{module:this.__generateMipmapsShaderModule,entryPoint:"fragmentMain",targets:[{format:o.format}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint32"}}),this.__generateMipmapsFormat=o.format}this.__generateMipmapsSampler==null&&(this.__generateMipmapsSampler=r.createSampler({minFilter:"linear"})),this.__renderPassEncoder!=null&&(this.__renderBundleEncoder!=null&&this.__renderPassEncoder.executeBundles([this.__renderBundleEncoder.finish()]),this.__renderPassEncoder.end(),this.__renderPassEncoder=void 0);let a=t.dimension==="2d"&&t.depthOrArrayLayers===6?6:1;for(let s=0;s<a;++s){let l=this.__srcTextureViewsForGeneratingMipmaps.get(t);if(l==null||l[s]==null){let u=t.createView({dimension:"2d",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:s,arrayLayerCount:1});l==null&&this.__srcTextureViewsForGeneratingMipmaps.set(t,[]),this.__srcTextureViewsForGeneratingMipmaps.get(t)[s]=u}let c=this.__srcTextureViewsForGeneratingMipmaps.get(t)[s];for(let u=1;u<o.mipLevelCount;++u){let _=this.__dstTextureViewsForGeneratingMipmaps.get(t);if(_==null||_[s]==null||_[s][u]==null){let y=t.createView({dimension:"2d",baseMipLevel:u,mipLevelCount:1,baseArrayLayer:s,arrayLayerCount:1});_==null&&this.__dstTextureViewsForGeneratingMipmaps.set(t,[]),this.__dstTextureViewsForGeneratingMipmaps.get(t)[s]==null&&(this.__dstTextureViewsForGeneratingMipmaps.get(t)[s]=[]),this.__dstTextureViewsForGeneratingMipmaps.get(t)[s][u]=y}let d=this.__dstTextureViewsForGeneratingMipmaps.get(t)[s][u],p=this.__commandEncoder.beginRenderPass({colorAttachments:[{view:d,loadOp:"load",storeOp:"store"}]}),x=this.__bindGroupsForGeneratingMipmaps.get(t);if(x==null||x[s]==null||x[s][u]==null){let y=r.createBindGroup({layout:this.__generateMipmapsBindGroupLayout,entries:[{binding:0,resource:this.__generateMipmapsSampler},{binding:1,resource:c}]});x==null&&this.__bindGroupsForGeneratingMipmaps.set(t,[]),this.__bindGroupsForGeneratingMipmaps.get(t)[s]==null&&(this.__bindGroupsForGeneratingMipmaps.get(t)[s]=[]),this.__bindGroupsForGeneratingMipmaps.get(t)[s][u]=y}let v=this.__bindGroupsForGeneratingMipmaps.get(t)[s][u];p.setPipeline(this.__generateMipmapsPipeline),p.setBindGroup(0,v),p.draw(4),p.end(),c=d}}}createTextureSampler({magFilter:t,minFilter:o,wrapS:r,wrapT:i,wrapR:a,anisotropy:s,isPremultipliedAlpha:l,shadowCompareMode:c}){let u=this.__webGpuDeviceWrapper.gpuDevice,_=s?4:1,d={magFilter:t.webgpu,minFilter:o.webgpu,mipmapFilter:o===U.LinearMipmapLinear||o===U.NearestMipmapLinear?"linear":"nearest",addressModeU:r.webgpu,addressModeV:i.webgpu,addressModeW:a.webgpu,maxAnisotropy:_};(d.magFilter==="nearest"||d.minFilter==="nearest"||d.mipmapFilter==="nearest")&&(d.maxAnisotropy=1);let p=u.createSampler(d);return this.__registerResource(p)}createVertexBuffer(t){let r=this.__webGpuDeviceWrapper.gpuDevice.createBuffer({size:t.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Uint8Array(r.getMappedRange()).set(t.getUint8Array()),r.unmap(),this.__registerResource(r)}createVertexBufferFromTypedArray(t){let r=this.__webGpuDeviceWrapper.gpuDevice.createBuffer({size:t.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Uint8Array(r.getMappedRange()).set(new Uint8Array(t.buffer)),r.unmap(),this.__registerResource(r)}createIndexBuffer(t){let o=this.__webGpuDeviceWrapper.gpuDevice,r=t.getUint8Array();if(t.componentType===I.UnsignedByte){let l=new Uint16Array(t.byteLength),c=t.getTypedArray();for(let u=0;u<c.length;u++)l[u]=c[u];r=new Uint8Array(l.buffer)}let i=ie.addPaddingBytes(r.byteLength,4),a=o.createBuffer({size:i,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0});return new Uint8Array(a.getMappedRange()).set(r),a.unmap(),this.__registerResource(a)}updateVertexBuffer(t,o){let r=this.__webGpuResources.get(o);if(A.not.exist(r))throw new Error("Not found VBO.");r.mapAsync(GPUMapMode.WRITE).then(()=>{new Uint8Array(r.getMappedRange()).set(t.bufferView.getUint8Array()),r.unmap()})}updateIndexBuffer(t,o){let r=this.__webGpuResources.get(o);if(A.not.exist(r))throw new Error("Not found IBO.");r.mapAsync(GPUMapMode.WRITE).then(()=>{let i=t.getUint8Array();if(t.componentType===I.UnsignedByte){let a=new Uint16Array(t.byteLength),s=t.getTypedArray();for(let l=0;l<s.length;l++)a[l]=s[l];i=new Uint8Array(a.buffer)}new Uint8Array(r.getMappedRange()).set(i),r.unmap()})}deleteVertexBuffer(t){let o=this.__webGpuResources.get(t);if(A.not.exist(o))throw new Error("Not found VBO.");o.destroy(),this.__webGpuResources.delete(t)}createVertexBufferAndIndexBuffer(t){let o;t.hasIndices()&&(o=this.createIndexBuffer(t.indicesAccessor));let r=[];for(let a=0;a<ee.AttributeTypeNumber;a++)r[a]=!1;let i=[];return t.attributeAccessors.forEach((a,s)=>{let l=this.createVertexBuffer(a),c=ee.toAttributeSlotFromJoinedString(t.attributeSemantics[s]);r[c]=!0,i.push(l)}),{vaoHandle:-1,iboHandle:o,vboHandles:i,attributesFlags:r,setComplete:!1}}updateVertexBufferAndIndexBuffer(t,o){o.iboHandle&&this.updateIndexBuffer(t.indicesAccessor,o.iboHandle);let r=t.attributeAccessors;for(let i=0;i<r.length;i++)this.updateVertexBuffer(r[i],o.vboHandles[i])}deleteVertexDataResources(t){if(A.exist(t.iboHandle)){let o=this.__webGpuResources.get(t.iboHandle);A.exist(o)&&o.destroy()}for(let o of t.vboHandles){let r=this.__webGpuResources.get(o);A.exist(r)&&r.destroy()}}setVertexDataToPipeline({vaoHandle:t,iboHandle:o,vboHandles:r},i,a=G.InvalidCGAPIResourceUid){let s=[],l=[];for(let u=0;u<r.length;u++){let _=ee.toAttributeSlotFromJoinedString(i.attributeSemantics[u]),d=i.attributeAccessors[u].componentType.webgpu+i.attributeAccessors[u].compositionType.webgpu;l.push({shaderLocation:_,offset:i.attributeAccessors[u].byteOffsetInBufferView,format:d})}s[0]={stepMode:"vertex",attributes:l,arrayStride:i.attributeAccessors[0].byteStride};let c=this.__webGpuResources.get(a);s[1]={stepMode:"instance",attributes:[{shaderLocation:ee.Instance.getAttributeSlot(),offset:0,format:"float32x4"}],arrayStride:4*4}}__checkShaderCompileStatus(t,o,r){N.info("MaterialTypeName: "+t);let i=on.addLineNumberToCode(o);N.info(i);for(let a=0;a<r.messages.length;a++)return N.info(r.messages[a].message),!1;return!0}createShaderProgram({material:t,primitive:o,vertexShaderStr:r,fragmentShaderStr:i,attributeNames:a,attributeSemantics:s,onError:l}){let c=this.__webGpuDeviceWrapper.gpuDevice,u=c.createShaderModule({code:r,label:t.materialTypeName+" vertex shader"});F.cgApiDebugConsoleOutput&&u.getCompilationInfo().then(x=>{x.messages.length>0&&this.__checkShaderCompileStatus(t.materialTypeName,r,x)});let _=c.createShaderModule({code:i,label:t.materialTypeName+" fragment shader"});F.cgApiDebugConsoleOutput&&_.getCompilationInfo().then(x=>{x.messages.length>0&&this.__checkShaderCompileStatus(t.materialTypeName,i,x)});let d={vsModule:u,fsModule:_};return this.__registerResource(d)}clearFrameBuffer(t){if(t.entities.length>0||!t.toClearColorBuffer&&!t.toClearDepthBuffer)return;let o=this.__webGpuDeviceWrapper.gpuDevice,r=this.__webGpuDeviceWrapper.context,i=[],a;if(t.toClearColorBuffer){let c=t.getFramebuffer();if(c!=null)for(let u of c.colorAttachments){let _=this.__webGpuResources.get(u._textureViewAsRenderTargetResourceUid);i.push({view:_,clearValue:{r:t.clearColor.x,g:t.clearColor.y,b:t.clearColor.z,a:t.clearColor.w},loadOp:"clear",storeOp:"store"})}else this.__contextCurrentTextureView==null&&(this.__contextCurrentTextureView=r.getCurrentTexture().createView()),i.push({view:this.__contextCurrentTextureView,clearValue:{r:t.clearColor.x,g:t.clearColor.y,b:t.clearColor.z,a:t.clearColor.w},loadOp:"clear",storeOp:"store"})}if(t.toClearDepthBuffer){let c=t.getFramebuffer();c!=null&&c.depthAttachment!=null?a={view:this.__webGpuResources.get(c.depthAttachment._textureViewAsRenderTargetResourceUid),depthClearValue:t.clearDepth,depthLoadOp:"clear",depthStoreOp:"store"}:a={view:this.__systemDepthTextureView,depthClearValue:t.clearDepth,depthLoadOp:"clear",depthStoreOp:"store"}}let s={colorAttachments:i,depthStencilAttachment:a,label:t.uniqueName};this.__commandEncoder.beginRenderPass(s).end()}draw(t,o,r,i,a){let s=r.isBufferLessRenderingMode(),l=t._vertexHandles;if(!s&&l==null)return;let c=-1,u=-1,_,d,p;if(!s){let w=t.mesh.meshEntitiesInner[0],T=w.getMeshRenderer();o._setInternalSettingParametersToGpuWebGpu({material:o,args:{cameraComponentSid:i,entity:w,specularCube:T.specularCubeMap}}),c=T.componentSID,u=T.updateCount,_=T.diffuseCubeMap,d=T.specularCubeMap,p=T.sheenCubeMap}let x=`${t._getFingerPrint()} ${o.materialUID} ${r.renderPassUID} ${c} ${u} ${a} `,[v,y]=this.getOrCreateRenderPipeline(x,t,o,r,a,_,d,p);this.createRenderBundleEncoder(r);let g=this.__renderBundleEncoder;if(g.setBindGroup(0,this.__bindGroupStorageBuffer),g.setPipeline(v),g.setBindGroup(1,this.__bindGroupTextureMap.get(x)),g.setBindGroup(2,this.__bindGroupSamplerMap.get(x)),g.setBindGroup(3,this.__bindGroupsUniformDrawParameters.get(`${r.renderPassUID}-${t.primitiveUid}`)),s)g.draw(r._drawVertexNumberForBufferLessRendering);else{let E=t.mesh,w=this.__webGpuResources.get(E._variationVBOUid);if(g.setVertexBuffer(0,w),l.vboHandles.forEach((T,R)=>{let P=this.__webGpuResources.get(T);g.setVertexBuffer(R+1,P)}),t.hasIndices()){let T=this.__webGpuResources.get(l.iboHandle),R=t.getIndexBitSize();g.setIndexBuffer(T,R);let P=t.indicesAccessor;g.drawIndexed(P.elementCount,E.meshEntitiesInner.length)}else{let T=t.attributeAccessors[0].elementCount;g.draw(T,E.meshEntitiesInner.length)}}this.createRenderPassEncoder(r)}createRenderBundleEncoder(t){if(this.__renderBundleEncoder==null){let o=this.__webGpuDeviceWrapper.gpuDevice,r=t.getFramebuffer(),i=[navigator.gpu.getPreferredCanvasFormat()],a=this.__systemDepthTexture.format;if(r!=null){i=[];for(let c of r.colorAttachments){let u=this.__webGpuResources.get(c._textureResourceUid);i.push(u.format)}r.depthAttachment!=null?a=this.__webGpuResources.get(r.depthAttachment._textureResourceUid).format:a=void 0}let s={colorFormats:i,depthStencilFormat:a,sampleCount:t.getResolveFramebuffer()!=null?t.getFramebuffer().colorAttachments[0].sampleCount:1},l=o.createRenderBundleEncoder(s);this.__renderBundleEncoder=l}}createRenderPassEncoder(t){if(this.__renderPassEncoder==null){let o=t.getFramebuffer(),r=t.getResolveFramebuffer(),i=t.toClearColorBuffer?{r:t.clearColor.x,g:t.clearColor.y,b:t.clearColor.z,a:t.clearColor.w}:void 0,a=t.toClearDepthBuffer?t.clearDepth:void 0;if(r!=null&&o!=null){let s=this.__systemDepthTextureView;o.depthAttachment!=null&&this.__webGpuResources.get(o.depthAttachment._textureResourceUid)!=null&&(s=this.__webGpuResources.get(o.depthAttachment._textureViewResourceUid));let l={colorAttachments:[],depthStencilAttachment:{view:s,depthClearValue:a,depthLoadOp:t.toClearDepthBuffer?"clear":"load",depthStoreOp:"store"},label:t.uniqueName},c=[];for(let u=0;u<r.colorAttachments.length;u++){let _=o.colorAttachments[u],d=r.colorAttachments[u],p=this.__webGpuResources.get(_._textureViewAsRenderTargetResourceUid),x=this.__webGpuResources.get(d._textureViewAsRenderTargetResourceUid);c.push({view:p,resolveTarget:x,clearValue:i,loadOp:t.toClearColorBuffer?"clear":"load",storeOp:"store"})}l.colorAttachments=c,this.__renderPassEncoder=this.__commandEncoder.beginRenderPass(l)}else if(o!=null){let s;o.depthAttachment!=null&&this.__webGpuResources.get(o.depthAttachment._textureResourceUid)!=null&&(s=this.__webGpuResources.get(o.depthAttachment._textureViewAsRenderTargetResourceUid));let l;s!=null&&(l={view:s,depthClearValue:a,depthLoadOp:t.toClearDepthBuffer?"clear":"load",depthStoreOp:"store"});let c={colorAttachments:[],depthStencilAttachment:l,label:t.uniqueName},u=[];for(let _ of o.colorAttachments){let d=this.__webGpuResources.get(_._textureViewAsRenderTargetResourceUid);u.push({view:d,clearValue:i,loadOp:t.toClearColorBuffer?"clear":"load",storeOp:"store"})}c.colorAttachments=u,this.__renderPassEncoder=this.__commandEncoder.beginRenderPass(c)}else{if(this.__contextCurrentTextureView==null){let l=this.__webGpuDeviceWrapper.context;this.__contextCurrentTextureView=l.getCurrentTexture().createView()}let s={colorAttachments:[{view:this.__contextCurrentTextureView,clearValue:i,loadOp:t.toClearColorBuffer?"clear":"load",storeOp:"store"}],depthStencilAttachment:{view:this.__systemDepthTextureView,depthClearValue:a,depthLoadOp:t.toClearDepthBuffer?"clear":"load",depthStoreOp:"store"},label:t.uniqueName};this.__renderPassEncoder=this.__commandEncoder.beginRenderPass(s)}}}__toClearRenderBundles(){(oo.stateVersion!==this.__lastMaterialsUpdateCount||re.current!==this.__lastCurrentCameraComponentSid||ne.updateCount!==this.__lastEntityRepositoryUpdateCount||$e.variantUpdateCount!==this.__lastPrimitivesMaterialVariantUpdateCount||In.updateCount!==this.__lastMeshRendererComponentsUpdateCount)&&(this.__renderBundles.clear(),K.webgpuRenderBundleMode=!1,this.__lastCurrentCameraComponentSid=re.current,this.__lastMaterialsUpdateCount=oo.stateVersion,this.__lastEntityRepositoryUpdateCount=ne.updateCount,this.__lastPrimitivesMaterialVariantUpdateCount=$e.variantUpdateCount,this.__lastMeshRendererComponentsUpdateCount=In.updateCount)}executeRenderBundle(t){this.__toClearRenderBundles(),(t._isChangedSortRenderResult||!F.cacheWebGpuRenderBundles)&&this.__renderBundles.clear();let o=this.__renderBundles.get(t.renderPassUID);return o!=null&&(this.createRenderPassEncoder(t),this.__renderPassEncoder!=null)?(this.__renderPassEncoder.executeBundles([o]),this.__renderPassEncoder.end(),this.__renderPassEncoder=void 0,!0):!1}finishRenderBundleEncoder(t){if(this.__renderPassEncoder!=null&&this.__renderBundleEncoder!=null){let o=this.__renderBundleEncoder.finish();F.cacheWebGpuRenderBundles?this.__renderBundles.set(t.renderPassUID,o):this.__renderBundles.clear(),this.__renderPassEncoder.executeBundles([o]),this.__renderPassEncoder.end(),this.__renderBundleEncoder=void 0,this.__renderPassEncoder=void 0}}getOrCreateRenderPipeline(t,o,r,i,a,s,l,c){if(this.__webGpuRenderPipelineMap.has(t)&&this.__materialStateVersionMap.get(t)===r.stateVersion)return[this.__webGpuRenderPipelineMap.get(t),!1];this.__webGpuRenderPipelineMap.delete(t),this.__materialStateVersionMap.delete(t),this.__bindGroupTextureMap.delete(t),this.__bindGroupLayoutTextureMap.delete(t),this.__bindGroupSamplerMap.delete(t),this.__bindGroupLayoutSamplerMap.delete(t),this.__createBindGroup(t,r,s,l,c);let u=this.__webGpuDeviceWrapper.gpuDevice,_=navigator.gpu.getPreferredCanvasFormat(),d=this.__webGpuResources.get(r.getShaderProgramUid(o));d!=null&&new Error("Shader Modules is not found");let p=[];i.isBufferLessRenderingMode()||p.push({stepMode:"instance",attributes:[{shaderLocation:ee.Instance.getAttributeSlot(),offset:0,format:"float32x4"}],arrayStride:4*4}),o.attributeAccessors.forEach((z,k)=>{let X={shaderLocation:ee.toAttributeSlotFromJoinedString(o.attributeSemantics[k]),offset:0,format:z.componentType.webgpu+z.compositionType.webgpu};p.push({stepMode:"vertex",arrayStride:o.attributeAccessors[k].actualByteStride,attributes:[X]})});let x=u.createPipelineLayout({bindGroupLayouts:[this.__bindGroupLayoutStorageBuffer,this.__bindGroupLayoutTextureMap.get(t),this.__bindGroupLayoutSamplerMap.get(t),this.__bindGroupLayoutUniformDrawParameters]}),v;r.isBlend()&&r.alphaMode===Tt.Blend&&(v={color:{srcFactor:r.blendFuncSrcFactor.webgpu,dstFactor:r.blendFuncDstFactor.webgpu,operation:r.blendEquationMode.webgpu},alpha:{srcFactor:r.blendFuncAlphaSrcFactor.webgpu,dstFactor:r.blendFuncAlphaDstFactor.webgpu,operation:r.blendEquationModeAlpha.webgpu}});let g=(i.isBufferLessRenderingMode()?i._primitiveModeForBufferLessRendering:o.primitiveMode).getWebGPUTypeStr(),E;(g==="triangle-strip"||g==="line-strip")&&(E=o.getIndexBitSize());let w=$e.getPrimitiveIdxHasMorph(o.primitiveUid),T=i.getFramebuffer(),R=[{format:_,blend:v}],P="depth24plus";if(T!=null){R=[];for(let z of T.colorAttachments){let k=this.__webGpuResources.get(z._textureResourceUid);R.push({format:k.format,blend:v,writeMask:this.setColorWriteMask(r)})}T.depthAttachment!=null?P=this.__webGpuResources.get(T.depthAttachment._textureResourceUid).format:P=void 0}let V=u.createRenderPipeline({layout:x,vertex:{module:d.vsModule,entryPoint:"main",buffers:p},fragment:{module:d.fsModule,entryPoint:"main",targets:R},primitive:{topology:g,stripIndexFormat:E,frontFace:r.cullFrontFaceCCW?"ccw":"cw",cullMode:r.cullFace?r.cullFaceBack?"back":"front":"none"},depthStencil:P==null?void 0:{depthWriteEnabled:a,depthCompare:i.isDepthTest?"less":"always",format:P},multisample:{count:i.getResolveFramebuffer()!=null?i.getFramebuffer().colorAttachments[0].sampleCount:1}});return this.__webGpuRenderPipelineMap.set(t,V),this.__materialStateVersionMap.set(t,r.stateVersion),[V,!0]}flush(){let t=this.__webGpuDeviceWrapper.gpuDevice;t.queue.submit([this.__commandEncoder.finish()]),this.__commandEncoder=t.createCommandEncoder(),this.__contextCurrentTextureView!=null&&(this.__contextCurrentTextureView=void 0)}setColorWriteMask(t){let o=0;return t.colorWriteMask[0]&&(o|=1),t.colorWriteMask[1]&&(o|=2),t.colorWriteMask[2]&&(o|=4),t.colorWriteMask[3]&&(o|=8),o}async createCubeTextureFromFiles(t,o,r,i){let a=[],s=0,l=0;for(let c=0;c<o;c++){let u=h(()=>new Promise((x,v)=>{let y=0,g=[],E=".jpg";i===wt.HDR_LINEAR?E=".hdr":i===wt.RGBE_PNG&&(E=".RGBE.PNG");let w="_right_",T="_left_",R="_top_",P="_bottom_",V="_front_",z="_back_";r&&(w="_posx_",T="_negx_",R="_posy_",P="_negy_",V="_posz_",z="_negz_");let k=[[t+w+c+E,"posX"],[t+T+c+E,"negX"],[t+R+c+E,"posY"],[t+P+c+E,"negY"],[t+V+c+E,"posZ"],[t+z+c+E,"negZ"]];for(let W=0;W<k.length;W++){let X=k[W][1],j;i===wt.HDR_LINEAR||i===wt.RGB9_E5_PNG?j=new fm:j=new Image,j.hdriFormat=i,j.side=X,j.uri=k[W][0],j.crossOrigin="Anonymous",j.onload=()=>{y++,g.push(j),y===6&&x(g)},j.onerror=()=>{v(j.uri)},j.src=k[W][0]}}),"loadOneLevel"),_;try{_=await u()}catch{try{_=await u()}catch(v){N.error(`failed to load ${v}`)}}let d=[];for(let x of _)if(x.hdriFormat===wt.HDR_LINEAR)d.push(x);else{await x.decode();let v=await createImageBitmap(x);d.push(v),v.side=x.side}let p={};for(let x of d){switch(x.side){case"posX":p.posX=x;break;case"posY":p.posY=x;break;case"posZ":p.posZ=x;break;case"negX":p.negX=x;break;case"negY":p.negY=x;break;case"negZ":p.negZ=x;break}c===0&&(s=x.width,l=x.height)}a.push(p)}return this.createCubeTexture(o,a,s,l)}createCubeTexture(t,o,r,i){let a=[];for(let v=0;v<t;v++){let y=[];(o[v].posX instanceof ImageBitmap||o[0].posX instanceof HTMLCanvasElement)&&(y.push(o[v].posX),y.push(o[v].negX),y.push(o[v].posY),y.push(o[v].negY),y.push(o[v].posZ),y.push(o[v].negZ)),a.push(y)}let s=this.__webGpuDeviceWrapper.gpuDevice,l=s.createTexture({dimension:"2d",size:[r,i,6],format:a[0][0].hdriFormat===wt.HDR_LINEAR?"rgba32float":"rgba8unorm",mipLevelCount:t,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});for(let v=0;v<t;v++)for(let y=0;y<a[v].length;y++){let g=a[v][y];if(g.hdriFormat===wt.HDR_LINEAR){let E=new Float32Array(g.width*g.height*4),w=g.dataFloat,T=g.width*g.height;for(let j=0;j<T;j++)E[j*4]=w[j*3],E[j*4+1]=w[j*3+1],E[j*4+2]=w[j*3+2],E[j*4+3]=1;let R=g.width*4*Float32Array.BYTES_PER_ELEMENT,P=Math.ceil(R/256)*256,V=P/Float32Array.BYTES_PER_ELEMENT,z=new Float32Array(V*g.height);for(let j=0;j<g.height;j++){let ae=j*g.width*4,le=ae+g.width*4,ze=j*V;z.set(E.subarray(ae,le),ze)}let k=s.createBuffer({size:z.byteLength,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Float32Array(k.getMappedRange()).set(z),k.unmap();let W=s.createCommandEncoder();W.copyBufferToTexture({buffer:k,bytesPerRow:P,rowsPerImage:g.height},{texture:l,origin:[0,0,y],mipLevel:v},[g.width,g.height,1]);let X=W.finish();s.queue.submit([X])}else s.queue.copyExternalImageToTexture({source:g},{texture:l,origin:[0,0,y],mipLevel:v},[g.width,g.height,1])}let c=this.__registerResource(l),u=U.Repeat,_=U.Repeat,d=t===1?U.Linear:U.LinearMipmapLinear,p=U.Linear,x=new Ge({wrapS:u,wrapT:_,minFilter:d,magFilter:p,anisotropy:!1});return x.create(),[c,x]}createTextureArray(t,o,r,i,a,s,l,c){let u=this.__webGpuDeviceWrapper.gpuDevice,_={size:[t,o,r],format:a.webgpu,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:i},d=u.createTexture(_),p=new ImageData(new Uint8ClampedArray(c.buffer),t,o);for(let v=0;v<r;v++)u.queue.copyExternalImageToTexture({source:p},{texture:d,origin:[0,0,v]},[t,o]);return this.__registerResource(d)}createStorageBuffer(t){let o=this.__webGpuDeviceWrapper.gpuDevice,r=o.createBuffer({size:t.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE});return o.queue.writeBuffer(r,0,t),this.__storageBuffer=r,this.__registerResource(r)}updateStorageBuffer(t,o,r){let i=this.__webGpuDeviceWrapper.gpuDevice,a=this.__webGpuResources.get(t);i.queue.writeBuffer(a,0,o,0,r)}updateStorageBufferPartially(t,o,r,i,a){let s=this.__webGpuDeviceWrapper.gpuDevice,l=this.__webGpuResources.get(t);s.queue.writeBuffer(l,r,o,i,a)}createStorageBlendShapeBuffer(t){let o=this.__webGpuDeviceWrapper.gpuDevice,r=o.createBuffer({size:t.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE});return o.queue.writeBuffer(r,0,t),this.__storageBlendShapeBuffer=r,this.__registerResource(r)}updateStorageBlendShapeBuffer(t,o,r){let i=this.__webGpuDeviceWrapper.gpuDevice,a=this.__webGpuResources.get(t);i.queue.writeBuffer(a,0,o,0,r)}createBindGroupLayoutForDrawParameters(){let t=this.__webGpuDeviceWrapper.gpuDevice;{let o={entries:[{binding:0,buffer:{type:"uniform"},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}]},r=t.createBindGroupLayout(o);this.__bindGroupLayoutUniformDrawParameters=r}}updateUniformBufferForDrawParameters(t,o,r,i,a){let s=this.__webGpuDeviceWrapper.gpuDevice,l=this.__uniformDrawParametersBuffers.get(t);if(l==null){l=s.createBuffer({size:4*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.__uniformDrawParametersBuffers.set(t,l);let c=s.createBindGroup({layout:this.__bindGroupLayoutUniformDrawParameters,entries:[{binding:0,resource:{buffer:l}}]});this.__bindGroupsUniformDrawParameters.set(t,c)}Rr.__drawParametersUint32Array[0]=o,Rr.__drawParametersUint32Array[1]=r,Rr.__drawParametersUint32Array[2]=i,Rr.__drawParametersUint32Array[3]=a,s.queue.writeBuffer(l,0,Rr.__drawParametersUint32Array)}createUniformMorphOffsetsBuffer(){let t=this.__webGpuDeviceWrapper.gpuDevice,o=new Uint32Array(Math.ceil(F.maxVertexPrimitiveNumberInShader*F.maxVertexMorphNumberInShader/4)*4),r=t.createBuffer({size:o.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM});return t.queue.writeBuffer(r,0,o),this.__uniformMorphOffsetsBuffer=r,this.__registerResource(r)}updateUniformMorphOffsetsBuffer(t,o){let r=this.__webGpuDeviceWrapper.gpuDevice;if(this.__uniformMorphOffsetsBuffer==null)throw new Error("Not found uniform morph buffer.");r.queue.writeBuffer(this.__uniformMorphOffsetsBuffer,0,t,0,o)}createUniformMorphWeightsBuffer(){let t=this.__webGpuDeviceWrapper.gpuDevice,o=new Float32Array(Math.ceil(F.maxVertexPrimitiveNumberInShader*F.maxVertexMorphNumberInShader/4)*4),r=t.createBuffer({size:o.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM});return t.queue.writeBuffer(r,0,o),this.__uniformMorphWeightsBuffer=r,this.__registerResource(r)}updateUniformMorphWeightsBuffer(t,o){let r=this.__webGpuDeviceWrapper.gpuDevice;if(this.__uniformMorphWeightsBuffer==null)throw new Error("Not found uniform morph buffer.");r.queue.writeBuffer(this.__uniformMorphWeightsBuffer,0,t,0,o)}__createBindGroup(t,o,r,i,a){let s=this.__webGpuDeviceWrapper.gpuDevice;{let l=[],c=[];if(this.__storageBuffer!=null&&(l.push({binding:0,resource:{buffer:this.__storageBuffer}}),c.push({binding:0,buffer:{type:"read-only-storage"},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT})),this.__storageBlendShapeBuffer!=null)l.push({binding:1,resource:{buffer:this.__storageBlendShapeBuffer}}),c.push({binding:1,buffer:{type:"read-only-storage"},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT});else{let p=s.createBuffer({size:16,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE});l.push({binding:1,resource:{buffer:p}}),c.push({binding:1,buffer:{type:"read-only-storage"},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT})}this.__uniformMorphOffsetsBuffer!=null&&(l.push({binding:2,resource:{buffer:this.__uniformMorphOffsetsBuffer}}),c.push({binding:2,buffer:{type:"uniform"},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT})),this.__uniformMorphWeightsBuffer!=null&&(l.push({binding:3,resource:{buffer:this.__uniformMorphWeightsBuffer}}),c.push({binding:3,buffer:{type:"uniform"},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}));let u={entries:c},_=s.createBindGroupLayout(u),d=s.createBindGroup({layout:_,entries:l});this.__bindGroupStorageBuffer=d,this.__bindGroupLayoutStorageBuffer=_}{let l=[],c=[],u=[],_=[];o._autoFieldVariablesOnly.forEach(R=>{let P=R.info;if(!(P.semantic==="diffuseEnvTexture"||P.semantic==="specularEnvTexture"||P.semantic==="sheenEnvTexture")&&b.isTexture(P.compositionType)){let V=R.value[0],z=R.value[1],k=R.value[2],W="2d";z instanceof Ri||z instanceof No?W="cube":(z instanceof xa||z instanceof eo)&&(W="2d-array");let X=this.__webGpuResources.get(z._textureViewResourceUid);X==null&&(z instanceof Ri||z instanceof No?X=this.__webGpuResources.get(qt._textureResourceUid).createView({dimension:"cube"}):z instanceof xa||z instanceof eo?X=this.__webGpuResources.get(ct._textureResourceUid).createView({dimension:"2d-array"}):X=this.__webGpuResources.get(ct._textureResourceUid).createView()),l.push({binding:V,resource:X}),c.push({binding:V,texture:{viewDimension:W},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}),k.created||k.create();let j=this.__webGpuResources.get(k._samplerResourceUid);u.push({binding:V,resource:j}),_.push({binding:V,sampler:{type:"filtering"},visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT})}});let d=o.getTextureParameter(Xe.DiffuseEnvTexture.str);if(A.exist(d)){let R=d[0],P=this.__webGpuResources.get(A.exist(r)?r._textureViewResourceUid:-1);if(A.exist(P))l.push({binding:R,resource:P});else{let z=this.__webGpuResources.get(qt._textureViewResourceUid);l.push({binding:R,resource:z})}c.push({binding:R,texture:{viewDimension:"cube"},visibility:GPUShaderStage.FRAGMENT});let V=this.__webGpuResources.get(A.exist(r)?r._samplerResourceUid:-1);if(A.exist(V))u.push({binding:R,resource:V});else{let z=this.__webGpuResources.get(qt._samplerResourceUid);u.push({binding:R,resource:z})}_.push({binding:R,sampler:{type:"filtering"},visibility:GPUShaderStage.FRAGMENT})}let p=o.getTextureParameter(Xe.SpecularEnvTexture.str);if(A.exist(p)){let R=p[0],P=this.__webGpuResources.get(A.exist(i)?i._textureViewResourceUid:-1);if(A.exist(P))l.push({binding:R,resource:P});else{let z=this.__webGpuResources.get(qt._textureViewResourceUid);l.push({binding:R,resource:z})}c.push({binding:R,texture:{viewDimension:"cube"},visibility:GPUShaderStage.FRAGMENT});let V=this.__webGpuResources.get(A.exist(i)?i._samplerResourceUid:-1);if(A.exist(V))u.push({binding:R,resource:V});else{let z=this.__webGpuResources.get(qt._samplerResourceUid);u.push({binding:R,resource:z})}_.push({binding:R,sampler:{type:"filtering"},visibility:GPUShaderStage.FRAGMENT})}let x=o.getTextureParameter(Xe.SheenEnvTexture.str);if(A.exist(x)){let R=x[0],P;if(A.exist(a)?P=this.__webGpuResources.get(a._textureViewResourceUid):A.exist(i)&&(P=this.__webGpuResources.get(i._textureViewResourceUid)),A.exist(P))l.push({binding:R,resource:P});else{let z=this.__webGpuResources.get(qt._textureViewResourceUid);l.push({binding:R,resource:z})}c.push({binding:R,texture:{viewDimension:"cube"},visibility:GPUShaderStage.FRAGMENT});let V;if(A.exist(a)?V=this.__webGpuResources.get(a._samplerResourceUid):A.exist(i)&&(V=this.__webGpuResources.get(i._samplerResourceUid)),A.exist(V))u.push({binding:R,resource:V});else{let z=this.__webGpuResources.get(qt._samplerResourceUid);u.push({binding:R,resource:z})}_.push({binding:R,sampler:{type:"filtering"},visibility:GPUShaderStage.FRAGMENT})}let v={entries:c},y=s.createBindGroupLayout(v),g=s.createBindGroup({layout:y,entries:l});this.__bindGroupTextureMap.set(t,g),this.__bindGroupLayoutTextureMap.set(t,y);let E={entries:_},w=s.createBindGroupLayout(E),T=s.createBindGroup({layout:w,entries:u});this.__bindGroupSamplerMap.set(t,T),this.__bindGroupLayoutSamplerMap.set(t,w)}}async createTextureFromHTMLImageElement(t,{level:o,internalFormat:r,width:i,height:a,border:s,format:l,type:c,generateMipmap:u}){return t.crossOrigin="Anonymous",this.__createTextureInner(i,a,r,u,t)}createCompressedTextureFromBasis(t,{border:o,format:r,type:i}){let a,s,l=t.getNumLevels(0),c=t.getImageWidth(0,0),u=t.getImageHeight(0,0),_=this.__webGpuDeviceWrapper.gpuDevice,d=this.__webGpuDeviceWrapper.gpuAdapter;d.features.has("texture-compression-bc")&&(a=On.BC3,s="bc3-rgba-unorm"),d.features.has("texture-compression-etc2")&&(a=On.ETC2,s="etc2-rgba8unorm"),d.features.has("texture-compression-astc")&&(a=On.ASTC,s="astc-4x4-unorm");let y={size:[c,u,1],format:s,mipLevelCount:l,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},g=_.createTexture(y);for(let w=0;w<l;w++){let T=t.getImageWidth(0,w),R=t.getImageHeight(0,w),P=this.decodeBasisImage(t,a,0,w),V=new ImageData(new Uint8ClampedArray(P),T,R);_.queue.copyExternalImageToTexture({source:V},{texture:g,mipLevel:w},[T,R,1])}return this.__registerResource(g)}decodeBasisImage(t,o,r,i){let a=t.getImageTranscodedSizeInBytes(r,i,o.index),s=new Uint8Array(a);return t.transcodeImage(s,r,i,o.index,0,0)||N.error("failed to transcode the image."),s}createCompressedTexture(t,o){let r=this.__webGpuDeviceWrapper.gpuDevice,i=o.blockInfo||{byteSize:4,width:1,height:1},a=t[0],s={size:[Math.ceil(a.width/i.width)*i.width,Math.ceil(a.height/i.height)*i.height,1],format:o.webgpu,mipLevelCount:t.length,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},l=r.createTexture(s);for(let u=0;u<t.length;u++){let _=t[u],d=_.width,p=_.height,x=Math.ceil(d/i.width)*i.byteSize,v=new Uint8Array(_.buffer.buffer);r.queue.writeTexture({texture:l,mipLevel:u},v,{offset:0,bytesPerRow:x},{width:Math.ceil(d/i.width)*i.width,height:Math.ceil(p/i.height)*i.height})}return this.__registerResource(l)}allocateTexture({format:t,width:o,height:r,mipLevelCount:i}){let a=this.__webGpuDeviceWrapper.gpuDevice,s={size:[o,r,1],mipLevelCount:i,format:t.webgpu,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT},l=a.createTexture(s);return this.__registerResource(l)}async loadImageToMipLevelOfTexture2D({mipLevel:t,textureUid:o,format:r,type:i,xOffset:a,yOffset:s,width:l,height:c,rowSizeByPixel:u,data:_}){let d=this.__webGpuDeviceWrapper.gpuDevice,p=this.__webGpuResources.get(o),x=oe.getPixelFormatFromTextureFormat(r),v=ue.getCompositionNumFromPixelFormat(x),y=u*v*i.getSizeInBytes(),g=Math.ceil(y/256)*256,E=new Uint8Array(g*c);for(let P=0;P<c;P++){let V=P*y,z=P*g;E.set(new Uint8Array(_.buffer,V,y),z)}let w=d.createBuffer({size:E.byteLength,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Uint8Array(w.getMappedRange()).set(E),w.unmap();let T=d.createCommandEncoder();T.copyBufferToTexture({buffer:w,offset:0,bytesPerRow:g,rowsPerImage:c},{texture:p,mipLevel:t,origin:{x:a,y:s,z:0}},{width:l,height:c,depthOrArrayLayers:1});let R=T.finish();d.queue.submit([R]);try{await d.queue.onSubmittedWorkDone()}catch(P){N.error(P)}}__createTextureInner(t,o,r,i,a){let s=this.__webGpuDeviceWrapper.gpuDevice,l={size:[t,o,1],format:r.webgpu,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT};i&&(l.mipLevelCount=Math.floor(Math.log2(Math.max(t,o)))+1);let c=s.createTexture(l);return s.queue.copyExternalImageToTexture({source:a},{texture:c},[t,o]),i&&this.generateMipmaps(c,l),this.__registerResource(c)}createRenderTargetTexture({width:t,height:o,mipLevelCount:r,format:i}){let a=this.__webGpuDeviceWrapper.gpuDevice,s={size:[t,o,1],format:i.webgpu,mipLevelCount:r,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT},l=a.createTexture(s);return this.__registerResource(l)}createRenderTargetTextureArray({width:t,height:o,level:r,internalFormat:i,format:a,type:s,arrayLength:l}){let c=this.__webGpuDeviceWrapper.gpuDevice,u={dimension:"2d",size:[t,o,l],format:i.webgpu,mipLevelCount:1,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT},_=c.createTexture(u);return this.__registerResource(_)}createRenderTargetTextureCube({width:t,height:o,mipLevelCount:r,format:i}){let a=this.__webGpuDeviceWrapper.gpuDevice,s={dimension:"2d",size:[t,o,6],format:i.webgpu,mipLevelCount:r,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT},l=a.createTexture(s);return this.__registerResource(l)}createRenderBuffer(t,o,r,i,a){let s=this.__webGpuDeviceWrapper.gpuDevice,l={size:[t,o,1],format:r.webgpu,sampleCount:i?a:1,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT},c=s.createTexture(l);return this.__registerResource(c)}deleteRenderBuffer(t){this.flush(),this.clearCache();let o=this.__webGpuResources.get(t);o!=null&&(o.destroy(),this.__webGpuResources.delete(t))}copyTextureData(t,o){let r=this.__webGpuDeviceWrapper.gpuDevice,i=this.__webGpuResources.get(t),a=this.__webGpuResources.get(o);this.__renderPassEncoder!=null&&(this.__renderBundleEncoder!=null&&this.__renderPassEncoder.executeBundles([this.__renderBundleEncoder.finish()]),this.__renderPassEncoder.end(),this.__renderPassEncoder=void 0),this.__commandEncoder.copyTextureToTexture({texture:i},{texture:a},[a.width,a.height,1])}isMippmappedTexture(t){let o=this.__webGpuDeviceWrapper.gpuDevice;return this.__webGpuResources.get(t).mipLevelCount>1}duplicateTextureAsMipmapped(t){let o=this.__webGpuDeviceWrapper.gpuDevice,r=this.__webGpuResources.get(t),i={size:{width:r.width,height:r.height,depthOrArrayLayers:r.depthOrArrayLayers},mipLevelCount:Math.floor(Math.log2(Math.max(r.width,r.height)))+1,format:r.format,usage:r.usage},a=o.createTexture(i);this.__renderPassEncoder!=null&&(this.__renderBundleEncoder!=null&&this.__renderPassEncoder.executeBundles([this.__renderBundleEncoder.finish()]),this.__renderPassEncoder.end(),this.__renderPassEncoder=void 0),this.__commandEncoder.copyTextureToTexture({texture:r},{texture:a},{width:r.width,height:r.height,depthOrArrayLayers:1});let s=this.__registerResource(a),l=this.__registerResource(a.createView());return[s,l]}attachDepthBufferToFrameBufferObject(t,o){}attachStencilBufferToFrameBufferObject(t,o){}attachDepthStencilBufferToFrameBufferObject(t,o){}createFrameBufferObject(){return-1}deleteFrameBufferObject(t){}attachColorBufferToFrameBufferObject(t,o,r){}attachColorBufferLayerToFrameBufferObject(t,o,r,i,a){}attachColorBufferCubeToFrameBufferObject(t,o,r,i,a){}createTextureView2d(t){let r=this.__webGpuResources.get(t).createView();return this.__registerResource(r)}createTextureViewAsRenderTarget(t){let r=this.__webGpuResources.get(t).createView({baseMipLevel:0,mipLevelCount:1,arrayLayerCount:1});return this.__registerResource(r)}createTextureViewCube(t){let r=this.__webGpuResources.get(t).createView({dimension:"cube"});return this.__registerResource(r)}createTextureView2dArray(t,o){let i=this.__webGpuResources.get(t).createView({dimension:"2d-array",baseArrayLayer:0,arrayLayerCount:o});return this.__registerResource(i)}createTextureView2dArrayAsRenderTarget(t,o,r){let a=this.__webGpuResources.get(t).createView({dimension:"2d",arrayLayerCount:1,baseArrayLayer:o,baseMipLevel:r,mipLevelCount:1,aspect:"all"});return this.__registerResource(a)}createCubeTextureViewAsRenderTarget(t,o,r){let a=this.__webGpuResources.get(t).createView({dimension:"2d",arrayLayerCount:1,baseArrayLayer:o,baseMipLevel:r,mipLevelCount:1,aspect:"all"});return this.__registerResource(a)}deleteTexture(t){this.flush(),this.clearCache();let o=this.__webGpuResources.get(t);o!=null&&(this.__srcTextureViewsForGeneratingMipmaps.delete(o),this.__dstTextureViewsForGeneratingMipmaps.delete(o),this.__bindGroupsForGeneratingMipmaps.delete(o),o.destroy(),this.__webGpuResources.delete(t))}recreateSystemDepthTexture(){let t=this.__webGpuDeviceWrapper.gpuDevice,o=this.__webGpuDeviceWrapper.canvas;this.__systemDepthTexture!=null&&this.__systemDepthTexture.destroy(),this.__systemDepthTexture=t.createTexture({size:[o.width,o.height],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),this.__systemDepthTextureView=this.__systemDepthTexture.createView()}resizeCanvas(t,o){let r=this.__webGpuDeviceWrapper.canvas;r.width=t,r.height=o,this.recreateSystemDepthTexture()}setViewport(t){}isSupportMultiViewVRRendering(){return!1}};h(Rr,"WebGpuResourceRepository"),f(Rr,"__instance"),f(Rr,"__drawParametersUint32Array",new Uint32Array(4));Po=Rr});var ho,Nr,rl=C(()=>{"use strict";dn();at();it();Cn();ye();It();yo();Yt();ra();Ot();ge();Vn();me();ho=class ho extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"__viewDepth",-Number.MAX_VALUE);f(this,"__mesh");f(this,"isPickable",!0)}static get componentTID(){return Q.MeshComponentTID}get componentTID(){return Q.MeshComponentTID}setMesh(t){this.__mesh=t,t._belongToMeshComponent(this)}unsetMesh(){return this.__mesh==null?!1:(this.__mesh=void 0,!0)}get mesh(){return this.__mesh}calcViewDepth(t){if(A.not.exist(this.__mesh))return Number.MAX_VALUE;let o=this.__mesh.AABB.centerPoint,r=this.entity.tryToGetSkeletal();A.exist(r)&&A.exist(r._bindShapeMatrix)&&r._bindShapeMatrix.multiplyVector3To(this.__mesh.AABB.centerPoint,o);let a=this.entity.getSceneGraph().matrixInner.multiplyVector3To(o,ho.__tmpVector3_0),l=t.viewMatrix.multiplyVector3To(a,ho.__tmpVector3_1);return this.__viewDepth=l.z,this.__viewDepth}get viewDepth(){return this.__viewDepth}static alertNoMeshSet(t){N.debug("No mesh is set on this MeshComponent:"+t.componentSID)}castRay(t,o,r=0){if(this.__mesh){let i=t,a=o,s=this.entity.tryToGetSceneGraph();if(s!=null){let l=Se.invert(s.matrixInner);i=S.fromCopyVector4(l.multiplyVector(q.fromCopyVector3(t)));let c=S.add(t,o),u=S.fromCopyVector4(l.multiplyVector(q.fromCopyVector3(c)));a=S.normalize(S.subtract(u,i));let _=this.__mesh.castRay(i,a,r),d=null;if(A.defined(_.data)&&_.data.t>=0)return d=S.fromCopyVector4(s.matrixInner.multiplyVector(q.fromCopyVector3(_.data.position))),{result:!0,data:{t:_.data.t,u:_.data.u,v:_.data.v,position:d}}}}return{result:!1}}castRayFromScreenInLocal(t,o,r,i,a=0){if(this.__mesh){let s=this.entity.tryToGetSceneGraph();if(s!=null){let l=$.multiplyTo(r.projectionMatrix,r.viewMatrix,ho.__tmpMatrix44_0).multiply(s.matrixInner).invert(),c=En.unProjectTo(t,o,0,l,i,ho.__tmpVector3_0),u=En.unProjectTo(t,o,1,l,i,ho.__tmpVector3_1),_=L.subtractTo(u,c,ho.__tmpVector3_2).normalize(),d=this.__mesh.castRay(c,_,a);if(A.defined(d.data)&&d.data.t>=0)return{result:!0,data:{t:d.data.t,u:d.data.u,v:d.data.v,position:d.data.position}}}}return{result:!1}}castRayFromScreenInWorld(t,o,r,i,a=0){let s=this.castRayFromScreenInLocal(t,o,r,i,a),l=this.entity.tryToGetSceneGraph();if(this.__mesh&&l!=null&&s.result){jn(s.data);let c=l.matrixInner.multiplyVector3To(s.data.position,ho.__returnVector3);return{result:!0,data:{t:s.data.t,u:s.data.u,v:s.data.v,position:c}}}else return s}$load(){if(this.__mesh==null)return;this.__mesh._calcTangents(),this.__mesh._calcFaceNormalsIfNonNormal();let t=this.entity.tryToGetBlendShape();t!=null&&t.weights.length>0&&this.__mesh._calcBaryCentricCoord(),this.moveStageTo(Ne.Logic)}$logic(){}_shallowCopyFrom(t){let o=t;this.__viewDepth=o.__viewDepth,A.exist(o.__mesh)&&this.setMesh(o.__mesh),this.isPickable=o.isPickable}_destroy(){super._destroy(),this.__mesh&&(this.__mesh=void 0)}get entity(){return ne.getEntity(this.__entityUid)}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(s,l,c){super(s,l,c)}getMesh(){return this.getComponentByComponentTID(Q.MeshComponentTID)}},h(i,"MeshEntity"),i);return vt(t,r),t}};h(ho,"MeshComponent"),f(ho,"__tmpVector3_0",L.zero()),f(ho,"__tmpVector3_1",L.zero()),f(ho,"__tmpVector3_2",L.zero()),f(ho,"__returnVector3",L.zero()),f(ho,"__tmpMatrix44_0",$.zero()),f(ho,"__latestPrimitivePositionAccessorVersion",0);Nr=ho});function Sa(m,n){return m.getShaderProgramUid(n)===-1}function Ta(m){let n=m.getPrimitiveNumber();for(let t=0;t<n;t++){let o=m.getPrimitiveAt(t);A.exist(o.vertexHandles)?o.update3DAPIVertexData():o.create3DAPIVertexData()}m.updateVariationVBO(),K.currentProcessApproach!==Z.WebGPU&&m.updateVAO()}var $c=C(()=>{"use strict";Ke();ge();Ze();h(Sa,"isSkipDrawing");h(Ta,"updateVBOAndVAO")});var Qr,Ea,Tm=C(()=>{"use strict";rl();Vi();jo();cr();_o();el();ft();$c();Jc();dn();Li();Er();tl();se();xe();Qn();St();$t();tt();Xt();dc();Bi();Wr();Co();me();Qr=class Qr{constructor(){f(this,"__storageBufferUid",G.InvalidCGAPIResourceUid);f(this,"__storageBlendShapeBufferUid",G.InvalidCGAPIResourceUid);f(this,"__uniformMorphOffsetsTypedArray");f(this,"__uniformMorphWeightsTypedArray");f(this,"__lastMaterialsUpdateCount",-1);f(this,"__lastTransformComponentsUpdateCount",-1);f(this,"__lastSceneGraphComponentsUpdateCount",-1);f(this,"__lastCameraComponentsUpdateCount",-1);f(this,"__lastCameraControllerComponentsUpdateCount",-1);f(this,"__lastBlendShapeComponentsUpdateCountForWeights",-1);f(this,"__lastBlendShapeComponentsUpdateCountForBlendData",-1)}static getInstance(){return this.__instance||(this.__instance=new Qr),this.__instance}static getVertexShaderMethodDefinitions_storageBuffer(){return`
fn get_worldMatrix(instanceId: u32) -> mat4x4<f32>
{
  let index: u32 = ${De.getLocationOffsetOfMemberOfComponent(Wt,"worldMatrix")}u + 4u * instanceId;
  let matrix = fetchMat4(index);

  return matrix;
}

fn get_normalMatrix(instanceId: u32) -> mat3x3<f32> {
  let index: u32 = ${De.getLocationOffsetOfMemberOfComponent(Wt,"normalMatrix")}u * 4 + 9 * instanceId;
  let matrix = fetchMat3No16BytesAligned(index);

  return matrix;
}

fn get_isVisible(instanceId: u32) -> bool {
  let index: u32 = ${De.getLocationOffsetOfMemberOfComponent(Wt,"isVisible")}u * 4u + instanceId;
  let visibility = fetchScalarNo16BytesAligned(index);
  if (visibility > 0.5) {
    return true;
  } else {
    return false;
  }
}

#ifdef RN_IS_VERTEX_SHADER
  #ifdef RN_IS_MORPHING
  fn get_position(vertexId: u32, basePosition: vec3<f32>, blendShapeComponentSID: u32) -> vec3<f32> {
    var position = basePosition;
    let scalar_idx = 3u * vertexId;
    for (var i=0u; i<uniformDrawParameters.morphTargetNumber; i++) {
      let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
      let idx = ${F.maxVertexMorphNumberInShader}u * currentPrimitiveIdx + i;
      let offsets = uniformMorphOffsets.data[ idx / 4u];
      let offsetPosition = offsets[idx % 4u];

      let basePosIn4bytes = offsetPosition * 4u + scalar_idx;
      let addPos = fetchVec3No16BytesAlignedFromBlendShapeBuffer(basePosIn4bytes);

      let idx2 = ${F.maxVertexMorphNumberInShader}u * blendShapeComponentSID + i;
      let morphWeights: vec4f = uniformMorphWeights.data[ idx2 / 4u];
      let morphWeight: f32 = morphWeights[idx2 % 4u];
      position += addPos * morphWeight;
    }

    return position;
  }
  #endif
#endif

`}static __getShaderProperty(n,t,o){var x,v;let r=t.compositionType.toWGSLType(t.componentType),i=t.semantic.replace(".","_");if(b.isTexture(t.compositionType)){let y="texture_2d<f32>";t.compositionType===b.TextureCube?y="texture_cube<f32>":t.compositionType===b.Texture2DArray&&(y="texture_2d_array<f32>");let g=i.replace("Texture","Sampler");return`
@group(1) @binding(${t.initialValue[0]}) var ${i}: ${y};
@group(2) @binding(${t.initialValue[0]}) var ${g}: sampler;
`}let s=t.compositionType.getVec4SizeOfProperty(),l=t.compositionType.getNumberOfComponents(),c=Qr.getOffsetOfPropertyInShader(o,t.semantic,n);c===-1&&N.error("Could not get the location offset of the property.");let u,_=s;if(u=`  let vec4_idx: u32 = ${c}u + ${_}u * instanceId;
`,b.isArray(t.compositionType)){_=s*((x=t.arrayLength)!=null?x:1);let g=Math.ceil(l/4)*4*((v=t.arrayLength)!=null?v:1);u=`  let vec4_idx: u32 = ${c}u + ${_} * instanceId + ${s}u * idxOfArray;
`,u+=`  let scalar_idx: u32 = ${c*4} + ${g} * instanceId + ${l}u * idxOfArray;
`}let p=`${`
fn get_${i}(instanceId: u32, idxOfArray: u32) -> ${r} {
${u}
`}`;switch(t.compositionType){case b.Vec4:case b.Vec4Array:p+=`  let val = fetchElement(vec4_idx);
`;break;case b.Vec3:p+=`  let col0 = fetchElement(vec4_idx);
`,p+=`  let val = ${r}(col0.xyz);`;break;case b.Vec3Array:p+=`  let val = fetchVec3No16BytesAligned(scalar_idx);
`;break;case b.Vec2:p+=`  let col0 = fetchElement(vec4_idx);
`,p+=`  let val = ${r}(col0.xy);`;break;case b.Vec2Array:p+=`  let val = fetchVec2No16BytesAligned(scalar_idx);
`;break;case b.Scalar:p+=`  let col0 = fetchElement(vec4_idx);
`,t.componentType===I.Int?p+="  let val = i32(col0.x);":t.componentType===I.UnsignedInt?p+="  let val = u32(col0.x);":t.componentType===I.Bool?p+="  let val = col0.x >= 0.5;":p+="  let val = col0.x;";break;case b.ScalarArray:p+=`  let col0 = fetchScalarNo16BytesAligned(scalar_idx);
`,t.componentType===I.Int?p+="  let val = i32(col0);":t.componentType===I.UnsignedInt?p+="  let val = u32(col0);":t.componentType===I.Bool?p+="  let val = col0 >= 0.5;":p+="  let val = col0;";break;case b.Mat4:p+=`  let val = fetchMat4(vec4_idx);
`;break;case b.Mat4Array:p+=`  let val = fetchMat4(vec4_idx);
`;break;case b.Mat3:p+=`  let val = fetchMat3(vec4_idx);
`;break;case b.Mat3Array:p+=`  let val = fetchMat3No16BytesAligned(scalar_idx);
`;break;case b.Mat2:p+=`  let val = fetchMat2(vec4_idx);
`;break;case b.Mat2Array:p+=`  let val = fetchMat2No16BytesAligned(scalar_idx);
`;break;case b.Mat4x3Array:p+=`  let val = fetchMat4x3(vec4_idx);
`;break;default:p+=""}return p+=`
  return val;
}
`,p}static getOffsetOfPropertyInShader(n,t,o){return n?gt.getInstance().getLocationOffsetOfProperty(t):Mn.getLocationOffsetOfMemberOfMaterial(o,t)}$load(n){let t=n.mesh;return t==null?!1:(t.isSetUpDone()||Ta(t),!0)}common_$load(){this.__uniformMorphOffsetsTypedArray==null&&(this.__uniformMorphOffsetsTypedArray=new Uint32Array(Math.ceil(F.maxVertexPrimitiveNumberInShader*F.maxVertexMorphNumberInShader/4)*4)),this.__uniformMorphWeightsTypedArray==null&&(this.__uniformMorphWeightsTypedArray=new Float32Array(Math.ceil(F.maxVertexPrimitiveNumberInShader*F.maxVertexMorphNumberInShader/4)*4)),Zo.updateCount!==this.__lastBlendShapeComponentsUpdateCountForBlendData&&(this.__createOrUpdateStorageBlendShapeBuffer(),this.__lastBlendShapeComponentsUpdateCountForBlendData=Zo.updateCount)}__setupShaderProgramForMeshComponent(n){if(n.mesh==null){Nr.alertNoMeshSet(n);return}let t=n.mesh.getPrimitiveNumber();for(let o=0;o<t;o++){let r=n.mesh.getPrimitiveAt(o),i=r.material;this._setupShaderProgram(i,r)}}_setupShaderProgram(n,t){if(n!=null&&!n.isShaderProgramReady(t))try{this.setupShaderForMaterial(n,t,Qr.getVertexShaderMethodDefinitions_storageBuffer(),Qr.__getShaderProperty),t._backupMaterial()}catch(o){N.error(o),t._restoreMaterial(),this.setupShaderForMaterial(t.material,t,Qr.getVertexShaderMethodDefinitions_storageBuffer(),Qr.__getShaderProperty)}}setupShaderForMaterial(n,t,o,r){n._createProgramWebGpu(t,o,r)}renderWithRenderBundle(n){return Po.getInstance().executeRenderBundle(n)}prerender(){ot.isAnimating||Et.updateCount!==this.__lastTransformComponentsUpdateCount||Wt.updateCount!==this.__lastSceneGraphComponentsUpdateCount||oo.stateVersion!==this.__lastMaterialsUpdateCount?(this.__createAndUpdateStorageBuffer(),this.__lastTransformComponentsUpdateCount=Et.updateCount,this.__lastSceneGraphComponentsUpdateCount=Wt.updateCount,this.__lastMaterialsUpdateCount=oo.stateVersion):(re.currentCameraUpdateCount!==this.__lastCameraComponentsUpdateCount||an.updateCount!==this.__lastCameraControllerComponentsUpdateCount)&&(this.__createAndUpdateStorageBufferForCameraOnly(),this.__lastCameraComponentsUpdateCount=re.currentCameraUpdateCount,this.__lastCameraControllerComponentsUpdateCount=an.updateCount),Zo.updateCount!==this.__lastBlendShapeComponentsUpdateCountForWeights&&(this.__updateUniformMorph(),this.__lastBlendShapeComponentsUpdateCountForWeights=Zo.updateCount)}common_$render(n,t,o){if(t.isBufferLessRenderingMode())return this.__renderWithoutBuffers(t),!0;let r=!1,i=t.isDepthTest&&t.depthWriteMask,a=t.isDepthTest&&t.depthWriteMask&&In.isDepthMaskTrueForBlendPrimitives;if(t._toRenderOpaquePrimitives)for(let s=0;s<=t._lastOpaqueIndex;s++){let l=n[s],c=this.renderInner(l,t,i);r||(r=c)}if(t._toRenderTranslucentPrimitives)for(let s=t._lastOpaqueIndex+1;s<=t._lastTranslucentIndex;s++){let l=n[s],c=this.renderInner(l,t,i);r||(r=c)}if(t._toRenderBlendWithZWritePrimitives)for(let s=t._lastTranslucentIndex+1;s<=t._lastBlendWithZWriteIndex;s++){let l=n[s],c=this.renderInner(l,t,i);r||(r=c)}if(t._toRenderBlendWithoutZWritePrimitives)for(let s=t._lastBlendWithZWriteIndex+1;s<=t._lastBlendWithoutZWriteIndex;s++){let l=n[s],c=this.renderInner(l,t,a);r||(r=c)}return r}__renderWithoutBuffers(n){let t=n.material,o=n._dummyPrimitiveForBufferLessRendering;this._setupShaderProgram(t,o);let r=Po.getInstance();r.updateUniformBufferForDrawParameters(`${n.renderPassUID}-${o.primitiveUid}`,t.materialSID,0,0,0),r.draw(o,t,n,0,!0)}renderInner(n,t,o){var c;if(n===-1)return!1;let r=$e.getPrimitive(n);if(r==null)return!1;let i=t.getAppropriateMaterial(r);if(this._setupShaderProgram(i,r),Sa(i,r))return!1;let a=Po.getInstance(),s=this.__getAppropriateCameraComponentSID(t,0,!1),l=(c=$e.getPrimitiveIdxHasMorph(r.primitiveUid))!=null?c:0;return a.updateUniformBufferForDrawParameters(`${t.renderPassUID}-${r.primitiveUid}`,i.materialSID,s,l,r.targets.length),a.draw(r,i,t,s,o),!0}__createAndUpdateStorageBuffer(){let t=we.getInstance().getBuffer(Ce.GPUInstanceData),o=Po.getInstance(),r=new Float32Array(t.getArrayBuffer());if(this.__storageBufferUid!==G.InvalidCGAPIResourceUid){let i=t.takenSizeInByte/4;o.updateStorageBuffer(this.__storageBufferUid,r,i)}else this.__storageBufferUid=o.createStorageBuffer(r)}__createAndUpdateStorageBufferForCameraOnly(){let t=we.getInstance().getBuffer(Ce.GPUInstanceData),o=Po.getInstance(),r=gt.getInstance(),i=new Float32Array(t.getArrayBuffer());if(this.__storageBufferUid!==G.InvalidCGAPIResourceUid){let a=r.getLocationOffsetOfProperty("viewMatrix")*16,s=a/4,l=r.getLocationOffsetOfProperty("boneMatrix")*16/4;o.updateStorageBufferPartially(this.__storageBufferUid,i,a,s,l-s)}else this.__storageBufferUid=o.createStorageBuffer(i)}__createOrUpdateStorageBlendShapeBuffer(){let t=we.getInstance().getBuffer(Ce.GPUVertexData);if(t==null)return;let o=Po.getInstance(),r=new Float32Array(t.getArrayBuffer());if(this.__storageBlendShapeBufferUid!==G.InvalidCGAPIResourceUid){let s=t.takenSizeInByte/4;o.updateStorageBlendShapeBuffer(this.__storageBlendShapeBufferUid,r,s)}else this.__storageBlendShapeBufferUid=o.createStorageBlendShapeBuffer(r);let i=0;for(;i<F.maxVertexPrimitiveNumberInShader;i++){let s=$e.getPrimitiveHasMorph(i);if(s!=null)for(let l=0;l<s.targets.length;l++){let u=s.targets[l].get(ee.Position.XYZ);this.__uniformMorphOffsetsTypedArray[F.maxVertexMorphNumberInShader*i+l]=u.byteOffsetInBuffer/4/4}else break}let a=F.maxVertexMorphNumberInShader*i;o.updateUniformMorphOffsetsBuffer(this.__uniformMorphOffsetsTypedArray,a)}__updateUniformMorph(){if(we.getInstance().getBuffer(Ce.GPUVertexData)==null)return;let o=Po.getInstance(),r=J.getComponentsWithType(Zo);for(let i=0;i<r.length;i++){let a=r[i],s=a.weights;for(let l=0;l<s.length;l++)this.__uniformMorphWeightsTypedArray[F.maxVertexMorphNumberInShader*a.componentSID+l]=s[l]}if(r.length>0){let i=F.maxVertexMorphNumberInShader*r.length;o.updateUniformMorphWeightsBuffer(this.__uniformMorphWeightsTypedArray,i)}}__getAppropriateCameraComponentSID(n,t,o){if(o){let i=Pe.getInstance().getModule("xr").WebXRSystem.getInstance(),a=-1;return i.isWebXRMode&&(i.isMultiView()?a=i._getCameraComponentSIDAt(0):a=i._getCameraComponentSIDAt(t)),a}else{let r=n.cameraComponent;return r==null&&(r=J.getComponent(re,re.current)),r?r.componentSID:-1}}};h(Qr,"WebGpuStrategyBasic"),f(Qr,"__instance");Ea=Qr});var qT,HT=C(()=>{qT={version:"v0.15.0-48-g67909d649-dirty",branch:"main"}});var il,Em=C(()=>{"use strict";HT();il=qT});function hr(){let m=en();return ne.tryToAddComponentToEntityByTID(Q.CameraComponentTID,m)}var Ca=C(()=>{"use strict";at();dr();it();h(hr,"createCameraEntity")});var Gt,po,ef=C(()=>{"use strict";Cn();St();Ke();Qn();ft();dn();Ci();at();jo();Er();ye();ql();Eu();Ze();Vn();ge();tt();mm();It();kr();it();mo();Jc();Tm();$t();Co();Bi();Vi();Wr();_o();Em();Ca();me();Gt=class Gt{constructor(){}static startRenderLoop(n,...t){this.__renderLoopFunc=n,this.__args=t;let o=this.__getAnimationFrameObject();this.__rnXRModule===void 0&&(this.__rnXRModule=Pe.getInstance().getModule("xr")),this.__animationFrameId=o.requestAnimationFrame((r,i)=>{if(this.__rnXRModule!==void 0){let a=this.__rnXRModule.WebXRSystem.getInstance(),s=this.__rnXRModule.WebARSystem.getInstance();a.isReadyForWebXR?(a._preRender(r,i),n.apply(n,[r,...t]),a._postRender()):s.isReadyForWebAR?(s._preRender(r,i),n.apply(n,[r,...t]),s._preRender(r,i)):n.apply(n,[r,...t])}else n.apply(n,[r,...t]);this.startRenderLoop(n,...t)})}static __getAnimationFrameObject(){let n=window,t=Pe.getInstance().getModule("xr");if(A.exist(t)){let o=t.WebXRSystem.getInstance(),r=t.WebARSystem.getInstance();if(o.requestedToEnterWebXR?n=o.xrSession:r.requestedToEnterWebAR&&(n=r.arSession),A.not.exist(n))return window}return n}static stopRenderLoop(){this.__getAnimationFrameObject().cancelAnimationFrame(this.__animationFrameId),this.__animationFrameId=-1}static restartRenderLoop(){this.__renderLoopFunc!=null&&this.startRenderLoop(this.__renderLoopFunc,0,this.__args)}static processAuto(n=q.fromCopy4(0,0,0,1)){if(A.not.exist(Gt.__expressionForProcessAuto)){let o=new gn,r=new Dt;r.toClearColorBuffer=!0,r.toClearDepthBuffer=!0,r.clearColor=n;let i=new Dt;o.addRenderPasses([r,i]),Gt.__expressionForProcessAuto=o,Gt.__renderPassForProcessAuto=i}Gt.__renderPassForProcessAuto.clearEntities();let t=ne._getEntities();Gt.__renderPassForProcessAuto.addEntities(t),this.process([Gt.__expressionForProcessAuto])}static process(n){var r;Ho._processBegin();let t=n;n instanceof ha&&(t=n.expressions),re.current===De.InvalidObjectUID&&Gt.createCamera();let o=gt.getInstance().getValue("time",0);if(o._v[0]=Ho.timeFromSystemStart,this.processApproach===Z.WebGPU){let i=J.getComponentTIDs(),a=Po.getInstance();for(let s of De._processStages){let c="common_"+s.methodName;if(s===Ne.Render){let u=Ea.getInstance();In.common_$prerender();for(let _ of t)for(let d of _.renderPasses){d.doPreRender(),this.__cgApiResourceRepository.clearFrameBuffer(d),d._isChangedSortRenderResult=!1;let p=In.sort_$render(d),x=d._renderedSomethingBefore;if(x&&(x=!u.renderWithRenderBundle(d),(r=K).webgpuRenderBundleMode||(r.webgpuRenderBundleMode=x)),x){let v=In.common_$render({renderPass:d,processStage:s,renderPassTickCount:this.__renderPassTickCount,primitiveUids:p});d._renderedSomethingBefore=v,v&&a.finishRenderBundleEncoder(d)}d._copyResolve1ToResolve2WebGpu(),d.doPostRender(),this.__renderPassTickCount++}a.flush()}else if(!K.webgpuRenderBundleMode||ot.isAnimating||Et.updateCount!==this.__lastTransformComponentsUpdateCount||re.currentCameraUpdateCount!==this.__lastCameraComponentsUpdateCount||an.updateCount!==this.__lastCameraControllerComponentsUpdateCount||$e.getPrimitiveCount()!==this.__lastPrimitiveCount)for(let u of i){let _=J.getComponentClass(u),d=_[c];d&&d({processApproach:this.__processApproach,renderPass:void 0,processStage:s,renderPassTickCount:this.__renderPassTickCount}),_.process(_,s)}}this.__lastCameraComponentsUpdateCount=re.currentCameraUpdateCount,this.__lastCameraControllerComponentsUpdateCount=an.updateCount,this.__lastTransformComponentsUpdateCount=Et.updateCount,this.__lastPrimitiveCount=$e.getPrimitiveCount()}else{let i=G.getWebGLResourceRepository(),a=Pe.getInstance().getModule("xr"),s=J.getComponentTIDs(),l=J.getRenderingComponentTIDs();for(let c of De._processStages){let _="common_"+c.methodName;if(c===Ne.Render){In.common_$prerender();for(let d of t)for(let p of l){let x=J.getComponentClass(p);for(let v of d.renderPasses){typeof spector!="undefined"&&spector.setMarker(`| ${d.uniqueName}: ${v.uniqueName}#`),v.doPreRender(),i.switchDepthTest(v.isDepthTest),p===Q.MeshRendererComponentTID&&(Gt.bindFramebufferWebGL(v,a),Gt.setViewportForNormalRendering(v,a)),p===Q.MeshRendererComponentTID&&this.__cgApiResourceRepository.clearFrameBuffer(v),v._isChangedSortRenderResult=!1;let y=In.sort_$render(v);if(v._renderedSomethingBefore){let E=x[_];if(E){let w=E({processApproach:this.__processApproach,renderPass:v,processStage:c,renderPassTickCount:this.__renderPassTickCount,primitiveUids:y});v._renderedSomethingBefore=w}p!==Q.MeshRendererComponentTID&&x.process(x,c)}this.__renderPassTickCount++,v._copyFramebufferToResolveFramebuffersWebGL(),v.doPostRender()}}}else if(ot.isAnimating||Et.updateCount!==this.__lastTransformComponentsUpdateCount||re.currentCameraUpdateCount!==this.__lastCameraComponentsUpdateCount||an.updateCount!==this.__lastCameraControllerComponentsUpdateCount||$e.getPrimitiveCount()!==this.__lastPrimitiveCount)for(let d of s){let p=J.getComponentClass(d),x=p[_];x&&x({processApproach:this.__processApproach,renderPass:void 0,processStage:c,renderPassTickCount:this.__renderPassTickCount}),p.process(p,c)}}this.__lastCameraComponentsUpdateCount=re.currentCameraUpdateCount,this.__lastCameraControllerComponentsUpdateCount=an.updateCount,this.__lastTransformComponentsUpdateCount=Et.updateCount,this.__lastPrimitiveCount=$e.getPrimitiveCount()}Ho._processEnd()}static get processTime(){return Ho.lastTimeTimeIntervalInMilliseconds}static get timeAtProcessBegin(){return Ho.timeAtProcessBeginMilliseconds}static get timeAtProcessEnd(){return Ho.timeAtProcessEndMilliseconds}static createCamera(){let n=hr();n.getTransform().localPosition=S.fromCopyArray([0,0,1]),n.getCamera().type=wn.Orthographic,n.getCamera().zNear=.1,n.getCamera().zFar=1e4;let t=G.getCgApiResourceRepository(),[o,r]=t.getCanvasSize();n.getCamera().xMag=o/r,n.getCamera().yMag=1}static setViewportForNormalRendering(n,t){let o=t==null?void 0:t.WebXRSystem.getInstance(),r=t==null?void 0:t.WebARSystem.getInstance();(!(o!=null&&o.isWebXRMode)||!n.isVrRendering)&&!(r!=null&&r.isWebARMode)&&this.__cgApiResourceRepository.setViewport(n.getViewport())}static bindFramebufferWebGL(n,t){let o=t==null?void 0:t.WebXRSystem.getInstance(),r=t==null?void 0:t.WebARSystem.getInstance();if(o!=null&&o.isWebXRMode&&n.isOutputForVr){let a=this.__cgApiResourceRepository.currentWebGLContextWrapper.getRawContext();a.bindFramebuffer(a.FRAMEBUFFER,o.framebuffer)}else if(r!=null&&r.isWebARMode){let a=this.__cgApiResourceRepository.currentWebGLContextWrapper.getRawContext();a.bindFramebuffer(a.FRAMEBUFFER,r.framebuffer)}else this.__cgApiResourceRepository.bindFramebuffer(n.getFramebuffer()),this.__cgApiResourceRepository.setDrawTargets(n)}static __displayRnInfo(){console.log(`%cRhodonite%cWeb3D Library%c %cversion%c${il.version}%c %cbranch%c${il.branch}%c %cmode%c${this.__processApproach.str}`,"font-weight: bold; padding: 4px 8px; border-radius: 6px 0px 0px 6px; background: linear-gradient(to right, #ff0084 0%,#ff0022 100%);","padding: 4px; border-radius: 0px 6px 6px 0px; background: linear-gradient(to right, #8400ff 0%,#4400ff 100%);","","background: #666; padding: 4px; border-radius: 6px 0px 0px 6px","background: firebrick; padding: 4px; border-radius: 0px 6px 6px 0px","","background: #666; padding: 4px; border-radius: 6px 0px 0px 6px","background: green; padding: 4px; border-radius: 0px 6px 6px 0px","","background: #666; padding: 4px; border-radius: 6px 0px 0px 6px","background: blue; padding: 4px; border-radius: 0px 6px 6px 0px")}static async init(n){if(this.__processApproach=n.approach,K.currentProcessApproach=n.approach,n.notToDisplayRnInfoAtInit!==!0&&this.__displayRnInfo(),await Pe.getInstance().loadModule("webgl"),await Pe.getInstance().loadModule("webgpu"),await Pe.getInstance().loadModule("pbr"),await Pe.getInstance().loadModule("xr"),F.eventTargetDom=n.canvas,we.createInstanceIfNotCreated({cpuGeneric:A.exist(n.memoryUsageOrder)?n.memoryUsageOrder.cpuGeneric:.1,gpuInstanceData:A.exist(n.memoryUsageOrder)?n.memoryUsageOrder.gpuInstanceData:.5,gpuVertexData:A.exist(n.memoryUsageOrder)?n.memoryUsageOrder.gpuVertexData:.5}),Gt.__cgApiResourceRepository=G.getCgApiResourceRepository(),n.approach===Z.WebGPU){let p=function(y){c.features.has(y)&&d.push(y)};var o=p;h(p,"addFeature");let i=we.getInstance().getMemorySize(),a=G.getCgApiResourceRepository(),l=Pe.getInstance().getModule("webgpu").WebGpuDeviceWrapper,c=await navigator.gpu.requestAdapter(),{maxBufferSize:u,maxStorageBufferBindingSize:_}=c.limits;if(u<i||_<i)throw new Error("The required buffer size is too large for this device.");let d=[];p("float32-filterable"),p("rg11b10ufloat-renderable"),p("texture-compression-bc"),p("texture-compression-etc2"),p("texture-compression-astc");let x=await c.requestDevice({requiredFeatures:d,requiredLimits:{maxStorageBufferBindingSize:_,maxBufferSize:u}}),v=new l(n.canvas,c,x);a.addWebGpuDeviceWrapper(v),a.recreateSystemDepthTexture(),a.createUniformMorphOffsetsBuffer(),a.createUniformMorphWeightsBuffer(),a.createBindGroupLayoutForDrawParameters()}else{let r=G.getWebGLResourceRepository();r.generateWebGLContext(n.canvas,!0,n.webglOption),r.switchDepthTest(!0)}gt.getInstance().initialize(n.approach),on.isMobile()&&Z.isUniformApproach(n.approach)&&N.warn("The number of Uniform variables available on mobile devices is limited and may interfere with rendering. Use the DataTexture ProcessApproach for this device."),n.canvas.addEventListener("webglcontextlost",(r=>{r.preventDefault(),this.stopRenderLoop(),N.error("WebGL context lost occurred.")}).bind(this)),n.canvas.addEventListener("webglcontextrestored",()=>{N.error("WebGL context restored."),this.restartRenderLoop()}),await Wh(),K.viewportAspectRatio=n.canvas.width/n.canvas.height}static get processApproach(){return this.__processApproach}static resizeCanvas(n,t){G.getCgApiResourceRepository().resizeCanvas(n,t),K.viewportAspectRatio=n/t}static getCanvasSize(){return G.getCgApiResourceRepository().getCanvasSize()}static getCurrentWebGLContextWrapper(){return this.__cgApiResourceRepository.currentWebGLContextWrapper}};h(Gt,"System"),f(Gt,"__expressionForProcessAuto"),f(Gt,"__renderPassForProcessAuto"),f(Gt,"__processApproach",Z.None),f(Gt,"__cgApiResourceRepository"),f(Gt,"__renderPassTickCount",0),f(Gt,"__animationFrameId",-1),f(Gt,"__renderLoopFunc"),f(Gt,"__args",[]),f(Gt,"__rnXRModule"),f(Gt,"__lastCameraComponentsUpdateCount",-1),f(Gt,"__lastCameraControllerComponentsUpdateCount",-1),f(Gt,"__lastTransformComponentsUpdateCount",-1),f(Gt,"__lastPrimitiveCount",-1);po=Gt});var Cm=C(()=>{"use strict";md();$a();Qn();ef();Ze()});var ci,ce,dt=C(()=>{"use strict";zn();Zt();Cm();un();ci=class ci extends nt{constructor(t,o){super();f(this,"__shaderFunctionName");f(this,"__inputs",[]);f(this,"__outputs",[]);f(this,"__inputConnections",[]);f(this,"__shaderNodeUid");f(this,"__codeGLSL");f(this,"__codeWGSL");f(this,"__commonPart");f(this,"_shaderStage","Neutral");this.__shaderFunctionName=t,this.__codeGLSL=o.codeGLSL,this.__codeWGSL=o.codeWGSL,this.__shaderNodeUid=++ci.__invalidShaderNodeCount,ci._shaderNodes[ci.__invalidShaderNodeCount]=this,this.__commonPart=o.commonPart}setShaderStage(t){this._shaderStage=t}getShaderStage(){return this._shaderStage}static getShaderNodeByUid(t){return ci._shaderNodes[t]}addInputConnection(t,o,r){let i=-1;for(let a=0;a<this.__inputs.length;a++)if(this.__inputs[a].name===r.name){i=a;break}this.__inputConnections[i]={shaderNodeUid:t.shaderNodeUid,outputNameOfPrev:o.name,inputNameOfThis:r.name}}get shaderFunctionName(){return this.__shaderFunctionName}getShaderFunctionNameDerivative(){return this.__shaderFunctionName}getShaderCode(t){return this.__commonPart!=null?t===D.VertexShader?this.__commonPart.vertexShaderDefinitions:this.__commonPart.pixelShaderDefinitions:K.currentProcessApproach===Z.WebGPU?this.__codeWGSL:this.__codeGLSL}get shaderNodeUid(){return this.__shaderNodeUid}getInput(t){for(let o of this.__inputs)if(o.name===t)return o}getInputs(){return this.__inputs}getOutput(t){for(let o of this.__outputs)if(o.name===t)return o}getOutputs(){return this.__outputs}get inputConnections(){return this.__inputConnections}makeCallStatement(t,o,r,i,a){let s="",l=i[t].concat(a[t]);if(o.getInputs().length===i[t].length&&o.getOutputs().length===a[t].length){let c="";if(l.length>0){c+=`${r}(`;for(let u=0;u<l.length;u++)l[u]!=null&&(u!==0&&(c+=", "),K.currentProcessApproach===Z.WebGPU&&u>=i[t].length&&(c+="&"),c+=l[u]);c+=`);
`}s+=c}return s}};h(ci,"AbstractShaderNode"),f(ci,"_shaderNodes",[]),f(ci,"__invalidShaderNodeCount",-1);ce=ci});var al,ht,tr=C(()=>{"use strict";Ke();Xt();Ei();Ze();x2();v2();y2();b2();I2();dt();al=class al{constructor(){f(this,"__webglResourceRepository",to.getInstance())}static getMainBegin(n){return K.currentProcessApproach===Z.WebGPU?n?`
var<private> output : VertexOutput;
@vertex
fn main(
${g2.code}
) -> VertexOutput {
#ifdef RN_USE_INSTANCE
a_instanceIds = instance_ids;
#endif

#ifdef RN_USE_POSITION
a_position = vec3<f32>(position);
#else
a_position = vec3<f32>(0.0, 0.0, 0.0);
#endif

#ifdef RN_USE_NORMAL
a_normal = normal;
#endif

#ifdef RN_USE_TEXCOORD_0
a_texcoord_0 = texcoord_0;
#endif

#ifdef RN_USE_COLOR_0
a_color_0 = vec4<f32>(color_0);
#else
a_color_0 = vec4<f32>(0.0, 0.0, 0.0, 1.0);
#endif
`:`
var<private> rt0: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 1.0);
@fragment
fn main(
  input: VertexOutput,
  @builtin(front_facing) isFront: bool,
) -> @location(0) vec4<f32> {
`:`
void main() {
`}static getMainEnd(n){return K.currentProcessApproach===Z.WebGPU?n?`
  return output;
}
`:`
  return rt0;
}
`:`
}
    `}static getVertexPrerequisites(n){if(K.currentProcessApproach===Z.WebGPU){let t=al.__makeVaryingVariablesWGSL(n),o="";return o+=`
/* shaderity: @{definitions} */
#define RN_IS_NODE_SHADER

#ifdef RN_USE_INSTANCE
var<private> a_instanceIds: vec4<f32>;
#endif

var<private> a_position: vec3<f32>;

var<private> a_normal: vec3<f32>;

var<private> a_texcoord_0: vec2<f32>;

var<private> a_color_0: vec4<f32>;

struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  ${t}
}

${Fh.code}
/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */
`,o}else{let t="";return t+=`
#version 300 es
precision highp float;
precision highp int;
${Bh.code}

in vec4 a_instanceInfo;
`,t+=`
uniform bool u_vertexAttributesExistenceArray[${ee.AttributeTypeNumber}];
`,t+="/* shaderity: @{matricesGetters} */",t+="/* shaderity: @{getters} */",t}}static __makeVaryingVariablesWGSL(n){let t=[];for(let r=0;r<n.length;r++){let i=n[r];for(let a=0;a<i.inputConnections.length;a++){let s=i.inputConnections[a];if(s==null)continue;let l=i.getInputs()[a],c=ce.getShaderNodeByUid(s.shaderNodeUid);if(c.getShaderStage()==="Vertex"&&i.getShaderStage()==="Fragment"){let u=l.compositionType.toWGSLType(l.componentType);t.push({type:u,name:`${c.shaderFunctionName}_${c.shaderNodeUid}`})}}}t.sort((r,i)=>r.name<i.name?-1:1);let o="";for(let r=0;r<t.length;r++)o+=`@location(${r}) ${t[r].name}: ${t[r].type},
`;return o}static getPixelPrerequisites(n){if(K.currentProcessApproach===Z.WebGPU){let t=al.__makeVaryingVariablesWGSL(n),o="";return o+=`
/* shaderity: @{definitions} */
#define RN_IS_NODE_SHADER

struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  ${t}
}

${Fh.code}
/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */
`,o}else{let t="";return t+=`
      #version 300 es
      precision highp float;
      precision highp int;
      ${Bh.code}
      `,t+="/* shaderity: @{getters} */",t+="layout(location = 0) out vec4 rt0;",t}}static getMainPrerequisites(){return K.currentProcessApproach===Z.WebGPU?S2.code:A2.code}static getAssignmentStatement(n,t){if(K.currentProcessApproach===Z.WebGPU){let o=t.compositionType.toWGSLType(t.componentType),r=t.compositionType.getWgslInitialValue(t.componentType);return`var ${n}: ${o} = ${r};
`}else{let o=t.compositionType.getGlslStr(t.componentType),r=t.compositionType.getGlslInitialValue(t.componentType);return`${o} ${n} = ${r};
`}}static getAssignmentVaryingStatementInPixelShader(n,t,o){if(K.currentProcessApproach===Z.WebGPU){let r=t.compositionType.toWGSLType(t.componentType);return`var ${n}: ${r} = input.${o.shaderFunctionName}_${o.shaderNodeUid};
`}else return`${t.compositionType.getGlslStr(t.componentType)} ${n} = v_${o.shaderFunctionName}_${o.shaderNodeUid};
`}static getAssignmentVaryingStatementInVertexShader(n,t,o){return K.currentProcessApproach===Z.WebGPU?`output.${n.shaderFunctionName}_${n.shaderNodeUid} = ${t[o]};
`:`v_${n.shaderFunctionName}_${n.shaderNodeUid} = ${t[o]};
`}};h(al,"CommonShaderPart"),f(al,"__instance");ht=al});var fi,tf,wp=C(()=>{"use strict";si();Nn();Xt();ai();_o();ye();ge();Ia();fi=class fi extends $o{constructor(n){super(n)}get isSetup(){return this.__topEntity!=null}_setup(){if(this.__toSkipSetup())return;this.__topEntity=Ct(),this.__topEntity.tryToSetUniqueName(`LightGizmo_of_${this.__target.uniqueName}`,!0),this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix=!0,this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph());let n=this.__topEntity.tryToGetMesh();fi.__mesh=new _t,fi.__mesh.addPrimitive(fi.__generatePrimitive()),n.setMesh(fi.__mesh),this.setGizmoTag()}_update(){if(this.__topEntity==null)return;let n=this.__target.getSceneGraph(),t=n.worldMergedAABBWithSkeletal;t.isVanilla()?this.__topEntity.getTransform().localPosition=n.position:this.__topEntity.getTransform().localPosition=t.centerPoint,this.__topEntity.getTransform().localRotation=n.rotation,this.__topEntity.getTransform().localScale=S.fromCopyArray([Math.max(1,t.isVanilla()?1:t.sizeX/2),Math.max(1,t.isVanilla()?1:t.sizeY/2),Math.max(1,t.isVanilla()?1:t.sizeZ/2)])}_destroy(){A.exist(this.__topEntity)&&this.__topEntity._destroy()}static __generatePrimitive(){let n=new Float32Array([0,0,0,0,0,-this.__length,0,0,-this.__length,-.1,0,-this.__length+.2,-.1,0,-this.__length+.2,0,0,-this.__length+.2]);return $e.createPrimitive({attributeSemantics:[ee.Position.XYZ],attributes:[n],primitiveMode:Re.Lines})}};h(fi,"LightGizmo"),f(fi,"__mesh"),f(fi,"__length",1);tf=fi});var jT=C(()=>{"use strict"});var Rp=C(()=>{"use strict";jT();Wr();gp()});var et,Mo,wa=C(()=>{"use strict";St();dn();at();it();Cs();ye();Cn();tt();Er();fo();Ao();wp();ge();Tn();Rp();et=class et extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"type",Fo.Point);f(this,"__color",S.fromCopyArray([1,1,1]));f(this,"__intensity",1);f(this,"__initialDirection",S.fromCopyArray([0,0,-1]));f(this,"__direction",S.fromCopyArray([0,0,-1]));f(this,"innerConeAngle",0);f(this,"outerConeAngle",Math.PI/4);f(this,"range",-1);f(this,"enable",!0);f(this,"shadowAreaSizeForDirectionalLight",10);f(this,"castShadow",!1);f(this,"__lightGizmo");f(this,"__updateCount",0);f(this,"__lastUpdateCount",-1);f(this,"__lastTransformUpdateCount",-1);this._setMaxNumberOfComponent(Math.max(10,Math.floor(F.maxEntityNumber/100)))}static get componentTID(){return Q.LightComponentTID}get componentTID(){return Q.LightComponentTID}get updateCount(){return this.__updateCount}get direction(){return this.__direction}set intensity(t){this.__intensity=t,this.__updateCount++}get intensity(){return this.__intensity}set color(t){this.__color=t,this.__updateCount++}get color(){return this.__color}get _up(){return S.fromCopy3(0,1,0)}set isLightGizmoVisible(t){t?(A.not.defined(this.__lightGizmo)&&(this.__lightGizmo=new tf(this.entity),this.__lightGizmo._setup()),this.__lightGizmo.isVisible=!0):A.defined(this.__lightGizmo)&&(this.__lightGizmo.isVisible=!1),this.__updateCount++}get isLightGizmoVisible(){return A.defined(this.__lightGizmo)?this.__lightGizmo.isVisible:!1}$load(){et.__lightPositions=et.__globalDataRepository.getValue("lightPosition",0),et.__lightDirections=et.__globalDataRepository.getValue("lightDirection",0),et.__lightIntensities=et.__globalDataRepository.getValue("lightIntensity",0),et.__lightProperties=et.__globalDataRepository.getValue("lightProperty",0),et.__lightNumber=et.__globalDataRepository.getValue("lightNumber",0),this.moveStageTo(Ne.Logic)}__updateGizmo(){A.defined(this.__lightGizmo)&&this.__lightGizmo.isSetup&&this.isLightGizmoVisible&&this.__lightGizmo._update()}static common_$logic(){let t=J.getComponentsWithType(et);et.__lightNumber._v[0]=t.length}$logic(){if(Et.updateCount===this.__lastTransformUpdateCount&&this.__lastUpdateCount===this.__updateCount)return;let t=this.entity.getSceneGraph();this.__direction=t.normalMatrixInner.multiplyVector(this.__initialDirection);let o=Math.cos(this.innerConeAngle),r=Math.cos(this.outerConeAngle);et.__lightDirections._v[3*this.componentSID+0]=this.__direction.x,et.__lightDirections._v[3*this.componentSID+1]=this.__direction.y,et.__lightDirections._v[3*this.componentSID+2]=this.__direction.z;let i=t.worldPosition;et.__lightPositions._v[3*this.componentSID+0]=i.x,et.__lightPositions._v[3*this.componentSID+1]=i.y,et.__lightPositions._v[3*this.componentSID+2]=i.z,et.__lightIntensities._v[3*this.componentSID+0]=this.__color.x*this.__intensity,et.__lightIntensities._v[3*this.componentSID+1]=this.__color.y*this.__intensity,et.__lightIntensities._v[3*this.componentSID+2]=this.__color.z*this.__intensity,et.__lightProperties._v[4*this.componentSID+0]=this.enable?this.type.index:-1,et.__lightProperties._v[4*this.componentSID+1]=this.range,et.__lightProperties._v[4*this.componentSID+2]=o,et.__lightProperties._v[4*this.componentSID+3]=r,this.__updateGizmo(),this.__lastTransformUpdateCount=Et.updateCount,this.__lastUpdateCount=this.__updateCount}_destroy(){super._destroy(),et.__lightIntensities._v[3*this.componentSID+0]=0,et.__lightIntensities._v[3*this.componentSID+1]=0,et.__lightIntensities._v[3*this.componentSID+2]=0}get entity(){return ne.getEntity(this.__entityUid)}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(s,l,c){super(s,l,c)}getLight(){return this.getComponentByComponentTID(Q.LightComponentTID)}},h(i,"LightEntity"),i);return vt(t,r),t}};h(et,"LightComponent"),f(et,"__globalDataRepository",gt.getInstance()),f(et,"__tmp_vec4",pe.zero()),f(et,"__lightPositions",new ve(new Float32Array(0))),f(et,"__lightDirections",new ve(new Float32Array(0))),f(et,"__lightIntensities",new ve(new Float32Array(0))),f(et,"__lightProperties",new ve(new Float32Array(0))),f(et,"__lightNumber",te.zero());Mo=et});function W8(m,n){Q8(m,n),X8(m,n),K8(m,n),Z8(m,n)}function Q8(m,n){let t=m.cullFace,o=m.cullFrontFaceCCW,r=m.cullFaceBack;KT!==t&&(t?n.enable(n.CULL_FACE):n.disable(n.CULL_FACE),KT=t),t===!0&&ZT!==o&&(o?n.frontFace(n.CCW):n.frontFace(n.CW),ZT=o),r!==JT&&(r?n.cullFace(n.BACK):n.cullFace(n.FRONT),JT=r)}function X8(m,n){let t=m.isBlend();YT!==t&&(t?n.enable(n.BLEND):n.disable(n.BLEND),YT=t),m.alphaMode===Tt.Blend&&(H8(m.blendEquationMode.index,m.blendEquationModeAlpha.index,n),j8(m.blendFuncSrcFactor.index,m.blendFuncDstFactor.index,m.blendFuncAlphaSrcFactor.index,m.blendFuncAlphaDstFactor.index,n))}function H8(m,n,t){q8(m,n)&&(t.blendEquationSeparate(m,n),eE=m,tE=n)}function q8(m,n){return eE!==m||tE!==n}function j8(m,n,t,o,r){Y8(m,n,t,o)&&(r.blendFuncSeparate(m,n,t,o),nE=m,oE=n,rE=t,iE=o)}function Y8(m,n,t,o){return nE!==m||oE!==n||rE!==t||iE!==o}function K8(m,n){let t=m.alphaToCoverage;t!==$T&&(t?n.enable(n.SAMPLE_ALPHA_TO_COVERAGE):n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),$T=t)}function Z8(m,n){let t=m.colorWriteMask;(t[0]!==nf[0]||t[1]!==nf[1]||t[2]!==nf[2]||t[3]!==nf[3])&&(n.colorMask(t[0],t[1],t[2],t[3]),nf=t)}function J8(m,n){let t=to.getInstance(),r=Pe.getInstance().getModule("xr").WebXRSystem.getInstance();r.isWebXRMode&&t.setViewport(r._getViewportAt(n))}function $8(m,n){return n.isWebXRMode?n.isMultiView()?1:m?2:1:1}function eX(m){let n=Pe.getInstance().getModule("xr");return(n==null?void 0:n.WebXRSystem.getInstance().isWebXRMode)&&m.isVrRendering}function tX(){return[{semantic:"pointSize",compositionType:b.Scalar,componentType:I.Float,stage:D.PixelShader,initialValue:te.fromCopyNumber(30),min:0,max:Number.MAX_VALUE,isInternalSetting:!1},{semantic:"pointDistanceAttenuation",compositionType:b.Vec3,componentType:I.Float,stage:D.PixelShader,initialValue:S.fromCopyArray([0,.1,.01]),min:0,max:1,isInternalSetting:!1}]}function Ra(m,n,t){if(m!=null&&!m.isShaderProgramReady(n))try{n==null||n._backupMaterial(),t.setupShaderForMaterial(m,n)}catch(o){console.log(o),n==null||n._restoreMaterial(),t.setupShaderForMaterial(m,n)}}var YT,eE,tE,nE,oE,rE,iE,KT,ZT,JT,$T,nf,qn,wm=C(()=>{"use strict";ni();Qn();Ei();se();xe();Zt();Tn();ye();KT=!1,ZT=!0,JT=!0,$T=!1,nf=[!0,!0,!0,!0];h(W8,"setWebGLParameters");h(Q8,"setCull");h(X8,"setBlendSettings");h(H8,"setBlendEquationMode");h(q8,"differentWithLastBlendEquation");h(j8,"setBlendFuncSrcFactor");h(Y8,"differentWithLastBlendFuncFactor");h(K8,"setAlphaToCoverage");h(Z8,"setColorWriteMask");h(J8,"setVRViewport");h($8,"getDisplayCount");h(eX,"isVrMainPass");h(tX,"getPointSpriteShaderSemanticsInfoArray");h(Ra,"setupShaderProgram");qn=Object.freeze({setWebGLParameters:W8,setVRViewport:J8,getDisplayCount:$8,isVrMainPass:eX,getPointSpriteShaderSemanticsInfoArray:tX})});var xo,of,Np=C(()=>{"use strict";Ei();_o();ft();So();St();wa();tt();Lo();xe();Vi();se();jo();Zt();cr();Er();Vn();wm();ge();$c();Qn();Co();pn();me();xo=class xo{constructor(){f(this,"__webglResourceRepository",to.getInstance());f(this,"__dataTextureUid",G.InvalidCGAPIResourceUid);f(this,"__lastShader",-1);f(this,"__lastMaterial");f(this,"__lastRenderPassTickCount",-1);f(this,"__lightComponents")}setupShaderForMaterial(n,t){let r=to.getInstance().currentWebGLContextWrapper,[i,a]=n._createProgramWebGL(xo.__vertexShaderMethodDefinitions_uniform,Xe.getShaderProperty,t,r.isWebGL2);if(a){n._setupBasicUniformsLocations(t),n._setUniformLocationsOfMaterialNodes(!0,t);let s=xo.componentMatrices,l=qn.getPointSpriteShaderSemanticsInfoArray();n._setupAdditionalUniformLocations(s.concat(l),!0,t),xo.__globalDataRepository._setUniformLocationsForUniformModeOnly(n.getShaderProgramUid(t))}return i}_reSetupShaderForMaterialBySpector(n,t,o,r){let[i,a]=n._createProgramByUpdatedSources(o,t,r);if(i===G.InvalidCGAPIResourceUid)return i;if(a){n._setupBasicUniformsLocations(t),n._setUniformLocationsOfMaterialNodes(!0,t);let s=xo.componentMatrices,l=qn.getPointSpriteShaderSemanticsInfoArray();n._setupAdditionalUniformLocations(s.concat(l),!0,t)}return xo.__globalDataRepository._setUniformLocationsForUniformModeOnly(n.getShaderProgramUid(t)),i}$load(n){let t=n.mesh;return A.exist(t)?(t.isSetUpDone()||Ta(t),!0):!1}prerender(){if(this.__lightComponents=J.getComponentsWithType(Mo),this.__dataTextureUid===G.InvalidCGAPIResourceUid){let t=we.getInstance().getBuffer(Ce.GPUVertexData);if(t==null)return;t.takenSizeInByte/we.bufferWidthLength/4>we.bufferHeightLength&&N.warn("The buffer size exceeds the size of the data texture.");let o=we.bufferWidthLength*we.bufferHeightLength*4*4,r=on.concatArrayBuffers2({finalSize:o,srcs:[t.getArrayBuffer()],srcsCopySize:[t.takenSizeInByte],srcsOffset:[0]}),i=new Float32Array(r);this.__dataTextureUid=this.__webglResourceRepository.createTextureFromTypedArray(i,{level:0,internalFormat:oe.RGBA32F,width:we.bufferWidthLength,height:we.bufferHeightLength,border:0,format:ue.RGBA,type:I.Float,generateMipmap:!1})}}attachGPUData(n){}attachVertexData(n,t,o,r){}attachVertexDataInner(n,t,o,r,i){let a=t.vertexHandles,s=this.__webglResourceRepository.getWebGLResource(n.getVaoUidsByPrimitiveUid(o)),l=r.getRawContext();if(s!=null)r.bindVertexArray(s);else{this.__webglResourceRepository.setVertexDataToPipeline(a,t,i);let c=this.__webglResourceRepository.getWebGLResource(a.iboHandle);l.bindBuffer(l.ELEMENT_ARRAY_BUFFER,c)}}dettachVertexData(n){let t=n.getRawContext();n.bindVertexArray&&n.bindVertexArray(null),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.bindBuffer(t.ARRAY_BUFFER,null)}static getInstance(){if(!this.__instance){this.__instance=new xo;let t=Pe.getInstance().getModule("xr").WebXRSystem.getInstance();xo.__webxrSystem=t}return this.__instance}common_$render(n,t,o){typeof spector!="undefined"&&spector.setMarker("|  |  Uniform:$render#");let r=this.__webglResourceRepository.currentWebGLContextWrapper,i=r.getRawContextAsWebGL2();if(t.isBufferLessRenderingMode())return this.__renderWithoutBuffers(i,t),!0;let a=!1;if(t._toRenderOpaquePrimitives){t.depthWriteMask||i.depthMask(!1);for(let s=0;s<=t._lastOpaqueIndex;s++){let l=n[s],c=this.renderInner(l,r,t,o);a||(a=c)}}if(t._toRenderTranslucentPrimitives)for(let s=t._lastOpaqueIndex+1;s<=t._lastTranslucentIndex;s++){let l=n[s],c=this.renderInner(l,r,t,o);a||(a=c)}if(t._toRenderBlendWithZWritePrimitives)for(let s=t._lastTranslucentIndex+1;s<=t._lastBlendWithZWriteIndex;s++){let l=n[s],c=this.renderInner(l,r,t,o);a||(a=c)}if(t._toRenderBlendWithoutZWritePrimitives){In.isDepthMaskTrueForBlendPrimitives||i.depthMask(!1);for(let s=t._lastBlendWithZWriteIndex+1;s<=t._lastBlendWithoutZWriteIndex;s++){let l=n[s],c=this.renderInner(l,r,t,o);a||(a=c)}}return i.depthMask(!0),this.__webglResourceRepository.unbindTextureSamplers(),a}__renderWithoutBuffers(n,t){let o=t.material,r=t._dummyPrimitiveForBufferLessRendering;Ra(o,r,this);let i=o.getShaderProgramUid(r),a=this.__webglResourceRepository.getWebGLResource(i);n.useProgram(a),this.__lastShader=i,this.bindDataTexture(n,a),qn.setWebGLParameters(o,n),o._setParametersToGpuWebGLWithOutInternalSetting({shaderProgram:a,firstTime:!0,isUniformMode:!0});let s=qn.isVrMainPass(t);if(a.vrState!=null&&s){let l=gt.getInstance().getValue("vrState",0);l._v[0]=s?1:0,l._v[1]=0,a._gl.uniform2iv(a.vrState,l._v)}t.depthWriteMask?n.depthMask(!0):n.depthMask(!1),this.__webglResourceRepository.setViewport(t.getViewport()),n.drawArrays(t._primitiveModeForBufferLessRendering.index,0,t._drawVertexNumberForBufferLessRendering)}renderInner(n,t,o,r){var p,x,v,y;let i=t.getRawContext(),a=$e.getPrimitive(n);if(a==null)return!1;let s=o.getAppropriateMaterial(a);Ra(s,a,this);let c=a.mesh.meshEntitiesInner,u=!1,_=qn.isVrMainPass(o),d=qn.getDisplayCount(_,xo.__webxrSystem);for(let g of c){if(g.getSceneGraph()._isCulled)continue;let E=g.getMesh();this.attachVertexDataInner(E.mesh,a,n,t,G.InvalidCGAPIResourceUid);let w=s.getShaderProgramUid(a),T=this.__webglResourceRepository.getWebGLResource(w),R=!0;if(w!==this.__lastShader||i.__changedProgram){if(Sa(s,a))return!1;if(R=!0,i.__changedProgram=!1,i.useProgram(T),this.bindDataTexture(i,T),ot.isAnimating){let P=gt.getInstance().getValue("time",0);T._gl.uniform1f(T.time,P._v[0])}this.__lastShader=w}((p=this.__lastMaterial)==null?void 0:p.deref())!==s&&(R=!0,this.__lastMaterial=new WeakRef(s));for(let P=0;P<d;P++){_&&qn.setVRViewport(o,P);let V={setUniform:!0,glw:t,entity:g,primitive:a,worldMatrix:g.getSceneGraph().matrix,normalMatrix:g.getSceneGraph().normalMatrix,isBillboard:g.getSceneGraph().isBillboard,lightComponents:this.__lightComponents,renderPass:o,diffuseCube:(x=g.tryToGetMeshRenderer())==null?void 0:x.diffuseCubeMap,specularCube:(v=g.tryToGetMeshRenderer())==null?void 0:v.specularCubeMap,sheenCube:(y=g.tryToGetMeshRenderer())==null?void 0:y.sheenCubeMap,isVr:_,displayIdx:P};if(R&&(qn.setWebGLParameters(s,i),s._setParametersToGpuWebGL({material:s,shaderProgram:T,firstTime:R,args:V})),s._setParametersToGpuWebGLPerPrimitive({material:s,shaderProgram:T,firstTime:R,args:V}),T.vrState!=null&&_){let z=gt.getInstance().getValue("vrState",0);z._v[0]=_?1:0,z._v[1]=P,T._gl.uniform2iv(T.vrState,z._v)}a.indicesAccessor?i.drawElements(a.primitiveMode.index,a.indicesAccessor.elementCount,a.indicesAccessor.componentType.index,0):i.drawArrays(a.primitiveMode.index,0,a.getVertexCountAsVerticesBased())}u=!0}return u}bindDataTexture(n,t){n.uniform1i(t.dataTexture,7),this.__webglResourceRepository.bindTexture2D(7,this.__dataTextureUid);let o=this.__webglResourceRepository.createOrGetTextureSamplerRepeatNearest();this.__webglResourceRepository.bindTextureSampler(7,o)}};h(xo,"WebGLStrategyUniform"),f(xo,"__instance"),f(xo,"__globalDataRepository",gt.getInstance()),f(xo,"__webxrSystem"),f(xo,"componentMatrices",[{semantic:"vertexAttributesExistenceArray",compositionType:b.ScalarArray,componentType:I.Int,stage:D.VertexShader,min:0,max:1,isInternalSetting:!0},{semantic:"worldMatrix",compositionType:b.Mat4,componentType:I.Float,stage:D.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0},{semantic:"normalMatrix",compositionType:b.Mat3,componentType:I.Float,stage:D.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0},{semantic:"isBillboard",compositionType:b.Scalar,componentType:I.Bool,stage:D.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0}]),f(xo,"__vertexShaderMethodDefinitions_uniform",`uniform mat4 u_worldMatrix;
uniform mat3 u_normalMatrix;
uniform bool u_isBillboard;

mat4 get_worldMatrix(float instanceId) {
  return u_worldMatrix;
}

mat3 get_normalMatrix(float instanceId) {
  return u_normalMatrix;
}

bool get_isVisible(float instanceId) {
  return true; // visibility is handled in CPU side in WebGLStrategyUniform, so this is dummy value.
}

bool get_isBillboard(float instanceId) {
  return u_isBillboard;
}

#ifdef RN_IS_VERTEX_SHADER
# ifdef RN_IS_MORPHING
  vec3 get_position(float vertexId, vec3 basePosition) {
    vec3 position = basePosition;
    int scalar_idx = 3 * int(vertexId);
    #ifdef GLSL_ES3
      int posIn4bytes = scalar_idx % 4;
    #else
      int posIn4bytes = int(mod(float(scalar_idx), 4.0));
    #endif
    for (int i=0; i<${F.maxVertexMorphNumberInShader}; i++) {

      int basePosIn16bytes = u_dataTextureMorphOffsetPosition[i] + (scalar_idx - posIn4bytes)/4;

      vec3 addPos = vec3(0.0);
      if (posIn4bytes == 0) {
        vec4 val = fetchElement(basePosIn16bytes);
        addPos = val.xyz;
      } else if (posIn4bytes == 1) {
        vec4 val0 = fetchElement(basePosIn16bytes);
        addPos = vec3(val0.yzw);
      } else if (posIn4bytes == 2) {
        vec4 val0 = fetchElement(basePosIn16bytes);
        vec4 val1 = fetchElement(basePosIn16bytes+1);
        addPos = vec3(val0.zw, val1.x);
      } else if (posIn4bytes == 3) {
        vec4 val0 = fetchElement(basePosIn16bytes);
        vec4 val1 = fetchElement(basePosIn16bytes+1);
        addPos = vec3(val0.w, val1.xy);
      }

      // int index = u_dataTextureMorphOffsetPosition[i] + 1 * int(vertexId);
      // vec3 addPos = fetchElement(u_dataTexture, index, widthOfDataTexture, heightOfDataTexture).xyz;

      position += addPos * u_morphWeights[i];
      if (i == u_morphTargetNumber-1) {
        break;
      }
    }

    return position;
  }
# endif
#endif
  `);of=xo});var qe,rf,Pp=C(()=>{"use strict";Ei();jo();Lo();xe();cr();rl();_o();ft();el();se();dn();Li();Vi();St();tt();$t();Er();it();Vn();wm();Qn();ge();wa();tl();$c();Bi();Wr();Co();pn();me();qe=class qe{constructor(){f(this,"__webglResourceRepository",to.getInstance());f(this,"__dataTextureUid",G.InvalidCGAPIResourceUid);f(this,"__dataUBOUid",G.InvalidCGAPIResourceUid);f(this,"__lastShader",G.InvalidCGAPIResourceUid);f(this,"__lastMaterial");f(this,"__lastMaterialStateVersion",-1);f(this,"__lastRenderPassTickCount",-1);f(this,"__lightComponents");f(this,"_totalSizeOfGPUShaderDataStorageExceptMorphData",0);f(this,"__lastMaterialsUpdateCount",-1);f(this,"__lastTransformComponentsUpdateCount",-1);f(this,"__lastSceneGraphComponentsUpdateCount",-1);f(this,"__lastCameraComponentsUpdateCount",-1);f(this,"__lastCameraControllerComponentsUpdateCount",-1)}static dumpDataTextureBuffer(){this.__isDebugOperationToDataTextureBufferDone=!1}static getVertexShaderMethodDefinitions_dataTexture(){return`

  mat4 get_worldMatrix(float instanceId)
  {
    int index = ${De.getLocationOffsetOfMemberOfComponent(Wt,"worldMatrix")} + 4 * int(instanceId);
    mat4 matrix = fetchMat4(index);

    return matrix;
  }


  mat3 get_normalMatrix(float instanceId) {
    int index = ${De.getLocationOffsetOfMemberOfComponent(Wt,"normalMatrix")} * 4 + 9 * int(instanceId);
    mat3 matrix = fetchMat3No16BytesAligned(index);
    return matrix;
  }

  bool get_isVisible(float instanceId) {
    int index = ${De.getLocationOffsetOfMemberOfComponent(Wt,"isVisible")} * 4 + int(instanceId);
    float visibility = fetchScalarNo16BytesAligned(index);
    return (visibility > 0.5) ? true : false;
  }

  bool get_isBillboard(float instanceId) {
    int index = ${De.getLocationOffsetOfMemberOfComponent(Wt,"isBillboard")} * 4 + int(instanceId);
    float isBillboard = fetchScalarNo16BytesAligned(index);
    return (isBillboard > 0.5) ? true : false;
  }

#ifdef RN_IS_VERTEX_SHADER
  #ifdef RN_IS_MORPHING
  vec3 get_position(float vertexId, vec3 basePosition) {
    vec3 position = basePosition;
    int scalar_idx = 3 * int(vertexId);
    for (int i=0; i<${F.maxVertexMorphNumberInShader}; i++) {

      int basePosIn4bytes = u_dataTextureMorphOffsetPosition[i] * 4 + scalar_idx;
      vec3 addPos = fetchVec3No16BytesAligned(basePosIn4bytes);

      position += addPos * u_morphWeights[i];
      if (i == u_morphTargetNumber-1) {
        break;
      }
    }

    return position;
  }
  #endif
#endif
`}setupShaderForMaterial(n,t){let r=to.getInstance().currentWebGLContextWrapper,[i,a]=n._createProgramWebGL(qe.getVertexShaderMethodDefinitions_dataTexture(),qe.__getShaderProperty,t,r.isWebGL2);return a&&(n._setupBasicUniformsLocations(t),n._setUniformLocationsOfMaterialNodes(!1,t),n._setupAdditionalUniformLocations(qn.getPointSpriteShaderSemanticsInfoArray(),!1,t),qe.__globalDataRepository._setUniformLocationsForDataTextureModeOnly(n.getShaderProgramUid(t))),i}_reSetupShaderForMaterialBySpector(n,t,o,r){let[i,a]=n._createProgramByUpdatedSources(o,t,r);return i===G.InvalidCGAPIResourceUid||(a&&(n._setupBasicUniformsLocations(t),n._setUniformLocationsOfMaterialNodes(!1,t),n._setupAdditionalUniformLocations(qn.getPointSpriteShaderSemanticsInfoArray(),!1,t)),qe.__globalDataRepository._setUniformLocationsForDataTextureModeOnly(n.getShaderProgramUid(t))),i}static __getShaderProperty(n,t,o,r){var E,w;let i=t.compositionType.getGlslStr(t.componentType),a,s=b.isTexture(t.compositionType),l=t.semantic.replace(".","_"),c="",u=t.compositionType.getGlslStr(t.componentType),_="";t.arrayLength&&(_=`[${t.arrayLength}]`),(t.needUniformInDataTextureMode||s)&&(c=`  uniform ${u} u_${l}${_};
`);let d=t.compositionType.getVec4SizeOfProperty(),p=t.compositionType.getNumberOfComponents(),x=qe.getOffsetOfPropertyInShader(o,t.semantic,n);x===-1&&N.error("Could not get the location offset of the property.");let v=d;if(a=`int vec4_idx = ${x} + ${v} * instanceId;
`,b.isArray(t.compositionType)){v=d*((E=t.arrayLength)!=null?E:1);let R=Math.ceil(p/4)*4*((w=t.arrayLength)!=null?w:1);a=`int vec4_idx = ${x} + ${v} * instanceId + ${d} * idxOfArray;
`,a+=`int scalar_idx = ${x*4} + ${R} * instanceId + ${p} * idxOfArray;
`}let y="";t.componentType===I.Int&&t.compositionType!==b.Scalar&&(y="i");let g="";if(!s&&!t.needUniformInDataTextureMode){g+=`
${i} get_${l}(highp float _instanceId, const int idxOfArray) {
  int instanceId = int(_instanceId);
  ${a}
  `;let T=`${c}
${g}`;switch(t.compositionType){case b.Vec4:case b.Vec4Array:T+=`        highp vec4 val = fetchElement(vec4_idx);
`;break;case b.Vec3:T+=`        vec4 col0 = fetchElement(vec4_idx);
`,T+=`        highp ${y}vec3 val = ${y}vec3(col0.xyz);`;break;case b.Vec3Array:T+=`        vec3 val = fetchVec3No16BytesAligned(scalar_idx);
`;break;case b.Vec2:T+=`        highp vec4 col0 = fetchElement(vec4_idx);
`,T+=`        highp ${y}vec2 val = ${y}vec2(col0.xy);`;break;case b.Vec2Array:T+=`        highp vec2 val = fetchVec2No16BytesAligned(scalar_idx);
`;break;case b.Scalar:T+=`        vec4 col0 = fetchElement(vec4_idx);
`,t.componentType===I.Int?T+="        int val = int(col0.x);":t.componentType===I.Bool?T+="        bool val = bool(col0.x);":T+="       float val = col0.x;";break;case b.ScalarArray:T+=`        float col0 = fetchScalarNo16BytesAligned(scalar_idx);
`,t.componentType===I.Int?T+="        int val = int(col0);":t.componentType===I.Bool?T+="        bool val = bool(col0);":T+="       float val = col0;";break;case b.Mat4:T+=`        mat4 val = fetchMat4(vec4_idx);
`;break;case b.Mat4Array:T+=`        mat4 val = fetchMat4(vec4_idx);
`;break;case b.Mat3:T+=`        mat3 val = fetchMat3(vec4_idx);
`;break;case b.Mat3Array:T+=`        mat3 val = fetchMat3No16BytesAligned(scalar_idx);
`;break;case b.Mat2:T+=`        mat2 val = fetchMat2(vec4_idx);
`;break;case b.Mat2Array:T+=`        mat2 val = fetchMat2No16BytesAligned(scalar_idx);
`;break;case b.Mat4x3Array:T+=`        mat4x3 val = fetchMat4x3(vec4_idx);
`;break;default:T+=""}return T+=`
  return val;
}
`,T}else if(!s&&t.needUniformInDataTextureMode){if(!r&&t.arrayLength)return`
${c}
`;{let T="";return t.arrayLength&&(T="[idxOfArray]"),`${c}
${i} get_${l}(highp float _instanceId, const int idxOfArray) {
  return u_${l}${T};
}
`}}else return c}static getOffsetOfPropertyInShader(n,t,o){return n?gt.getInstance().getLocationOffsetOfProperty(t):Mn.getLocationOffsetOfMemberOfMaterial(o,t)}$load(n){let t=n.mesh;return t==null?(Nr.alertNoMeshSet(n),!1):(qe.__currentComponentSIDs=qe.__globalDataRepository.getValue("currentComponentSIDs",0),t.isSetUpDone()||(this.deleteDataTexture(),Ta(t)),!0)}__createAndUpdateDataTexture(){this.__createAndUpdateDataTextureInner()}__createAndUpdateDataTextureForCameraOnly(){let t=gt.getInstance().getLocationOffsetOfProperty("boneMatrix")*16;this.__createAndUpdateDataTextureInner(t)}__createAndUpdateDataTextureInner(n){let t=we.getInstance(),o=t.getBuffer(Ce.GPUInstanceData),i=this.__webglResourceRepository.currentWebGLContextWrapper.getAlignedMaxUniformBlockSize(),a=this.__isUboUse()?i:0;if(o==null)return;let s=we.bufferWidthLength*we.bufferHeightLength*4*4;if(this.__dataTextureUid!==G.InvalidCGAPIResourceUid){let c=(n!=null?n:o.takenSizeInByte)-a,u=Math.min(Math.ceil(c/we.bufferWidthLength/4/4),we.bufferHeightLength),_=we.bufferWidthLength*u*4*4;c>s&&N.warn("The buffer size exceeds the size of the data texture.");let d=new Float32Array(o.getArrayBuffer(),a,_/4);this.__webglResourceRepository.updateTexture(this.__dataTextureUid,d,{level:0,xoffset:0,yoffset:0,width:we.bufferWidthLength,height:u,format:ue.RGBA,type:I.Float}),qe.__isDebugOperationToDataTextureBufferDone||(on.downloadTypedArray("Rhodonite_dataTextureBuffer.bin",d),qe.__isDebugOperationToDataTextureBufferDone=!0)}else{let l=t.getBuffer(Ce.GPUVertexData),c=0,u=new ArrayBuffer(0);A.exist(l)&&(c=l.takenSizeInByte,u=l.getArrayBuffer());let _;{let d=t.getBuffer(Ce.GPUVertexData),p=0;A.exist(d)&&(p=d.takenSizeInByte);let x=new ArrayBuffer(0);A.exist(d)&&(x=d.getArrayBuffer());let v=o.takenSizeInByte-a,g=(we.bufferWidthLength-v/4/4%we.bufferWidthLength)*4*4,E=on.concatArrayBuffers2({finalSize:s,srcs:[o.getArrayBuffer(),x],srcsCopySize:[v+g,p],srcsOffset:[a,0]});v+g+p>s&&N.warn("The buffer size exceeds the size of the data texture."),_=new Float32Array(E),F.totalSizeOfGPUShaderDataStorageExceptMorphData=o.takenSizeInByte+g}this.__dataTextureUid=this.__webglResourceRepository.createTextureFromTypedArray(_,{level:0,internalFormat:oe.RGBA32F,width:we.bufferWidthLength,height:we.bufferHeightLength,border:0,format:ue.RGBA,type:I.Float,generateMipmap:!1})}}deleteDataTexture(){this.__dataTextureUid!=null&&(this.__webglResourceRepository.deleteTexture(this.__dataTextureUid),this.__dataTextureUid=G.InvalidCGAPIResourceUid)}prerender(){ot.isAnimating||Et.updateCount!==this.__lastTransformComponentsUpdateCount||Wt.updateCount!==this.__lastSceneGraphComponentsUpdateCount||oo.stateVersion!==this.__lastMaterialsUpdateCount?(this.__createAndUpdateDataTexture(),this.__createAndUpdateUBO(),this.__lastTransformComponentsUpdateCount=Et.updateCount,this.__lastSceneGraphComponentsUpdateCount=Wt.updateCount,this.__lastMaterialsUpdateCount=oo.stateVersion):(re.currentCameraUpdateCount!==this.__lastCameraComponentsUpdateCount||an.updateCount!==this.__lastCameraControllerComponentsUpdateCount)&&(this.__createAndUpdateDataTextureForCameraOnly(),this.__lastCameraComponentsUpdateCount=re.currentCameraUpdateCount,this.__lastCameraControllerComponentsUpdateCount=an.updateCount),this.__lightComponents=J.getComponentsWithType(Mo)}__isUboUse(){return this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2&&F.isUboEnabled}__createAndUpdateUBO(){if(this.__isUboUse()){let n=this.__webglResourceRepository.currentWebGLContextWrapper,t=n.getAlignedMaxUniformBlockSize(),o=n.getMaxConventionUniformBlocks(),i=we.getInstance().getBuffer(Ce.GPUInstanceData);if(this.__dataUBOUid===G.InvalidCGAPIResourceUid)this.__dataUBOUid=this.__webglResourceRepository.setupUniformBufferDataArea(new Float32Array(i.getArrayBuffer()));else{let a=new Float32Array(i.getArrayBuffer());this.__webglResourceRepository.updateUniformBuffer(this.__dataUBOUid,a,0,t*o/4)}}}attachGPUData(n){}attachGPUDataInner(n,t){}attachVertexData(n,t,o,r){}attachVertexDataInner(n,t,o,r,i){let a=t.vertexHandles,s=r.getRawContext(),l=this.__webglResourceRepository.getWebGLResource(n.getVaoUids(o));if(l!=null)r.bindVertexArray(l);else{this.__webglResourceRepository.setVertexDataToPipeline(a,t,n._variationVBOUid);let c=this.__webglResourceRepository.getWebGLResource(a.iboHandle);s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,c)}}static getInstance(){if(!this.__instance){this.__instance=new qe;let t=Pe.getInstance().getModule("xr").WebXRSystem.getInstance();qe.__webxrSystem=t}return this.__instance}__setCurrentComponentSIDsForEachDisplayIdx(n,t,o){if(o){let r=-1,i=qe.__webxrSystem;i.isWebXRMode&&(i.isMultiView()?r=i._getCameraComponentSIDAt(0):r=i._getCameraComponentSIDAt(t)),qe.__currentComponentSIDs._v[Q.CameraComponentTID]=r}else{let r=n.cameraComponent;r==null&&(r=J.getComponent(re,re.current)),r?qe.__currentComponentSIDs._v[Q.CameraComponentTID]=r.componentSID:qe.__currentComponentSIDs._v[Q.CameraComponentTID]=-1}}__setCurrentComponentSIDsForEachPrimitive(n,t,o){qe.__currentComponentSIDs==null&&(qe.__currentComponentSIDs=qe.__globalDataRepository.getValue("currentComponentSIDs",0)),qe.__currentComponentSIDs._v[0]=t.materialSID}common_$render(n,t,o){typeof spector!="undefined"&&spector.setMarker("|  |  DataTexture:common_$render#");let r=this.__webglResourceRepository.currentWebGLContextWrapper,i=r.getRawContextAsWebGL2();if(t.isBufferLessRenderingMode())return this.__renderWithoutBuffers(i,t),!0;let a=!1;if(t._toRenderOpaquePrimitives){t.depthWriteMask||i.depthMask(!1);for(let s=0;s<=t._lastOpaqueIndex;s++){let l=n[s],c=this.__renderInner(l,r,t);a||(a=c)}}if(t._toRenderTranslucentPrimitives)for(let s=t._lastOpaqueIndex+1;s<=t._lastTranslucentIndex;s++){let l=n[s],c=this.__renderInner(l,r,t);a||(a=c)}if(t._toRenderBlendWithZWritePrimitives)for(let s=t._lastTranslucentIndex+1;s<=t._lastBlendWithZWriteIndex;s++){let l=n[s],c=this.__renderInner(l,r,t);a||(a=c)}if(t._toRenderBlendWithoutZWritePrimitives){In.isDepthMaskTrueForBlendPrimitives||i.depthMask(!1);for(let s=t._lastBlendWithZWriteIndex+1;s<=t._lastBlendWithoutZWriteIndex;s++){let l=n[s],c=this.__renderInner(l,r,t);a||(a=c)}}return i.depthMask(!0),this.__lastRenderPassTickCount=o,a}__renderWithoutBuffers(n,t){let o=t.material,r=t._dummyPrimitiveForBufferLessRendering;Ra(o,r,this);let i=o.getShaderProgramUid(r),a=this.__webglResourceRepository.getWebGLResource(i);n.useProgram(a),this.__lastShader=i,this.bindDataTexture(n,a),this.__setCurrentComponentSIDsForEachPrimitive(n,o,a),n.uniform1fv(a.currentComponentSIDs,qe.__currentComponentSIDs._v);let s=qn.isVrMainPass(t);if(a.vrState!=null&&s){let l=gt.getInstance().getValue("vrState",0);l._v[0]=s?1:0,l._v[1]=0,a._gl.uniform2iv(a.vrState,l._v)}qn.setWebGLParameters(o,n),o._setParametersToGpuWebGLWithOutInternalSetting({shaderProgram:a,firstTime:!0,isUniformMode:!1}),t.depthWriteMask?n.depthMask(!0):n.depthMask(!1),this.__webglResourceRepository.setViewport(t.getViewport()),n.drawArrays(t._primitiveModeForBufferLessRendering.index,0,t._drawVertexNumberForBufferLessRendering)}__renderInner(n,t,o){var y;let r=t.getRawContextAsWebGL2(),i=$e.getPrimitive(n);if(i==null)return!1;let a=i.mesh,s=a.meshEntitiesInner[0],l=o.getAppropriateMaterial(i);Ra(l,i,this);let c=s.getMeshRenderer(),u=a.getPrimitiveIndexInMesh(i);this.attachVertexDataInner(a,i,u,t,a._variationVBOUid);let _=!1,d=l.getShaderProgramUid(i);if(d!==this.__lastShader||r.__changedProgram){if(Sa(l,i))return!1;let g=this.__webglResourceRepository.getWebGLResource(d);r.useProgram(g),r.__changedProgram=!1,this.bindDataTexture(r,g),qe.__shaderProgram=g,_=!0}((y=this.__lastMaterial)==null?void 0:y.deref())!==l&&(_=!0,this.__lastMaterial=new WeakRef(l)),this.__lastMaterialStateVersion!==l.stateVersion&&(_=!0,this.__lastMaterialStateVersion=l.stateVersion);let p=qn.isVrMainPass(o),x={glw:t,entity:s,worldMatrix:s.getSceneGraph().matrixInner,normalMatrix:s.getSceneGraph().normalMatrixInner,isBillboard:s.getSceneGraph().isBillboard,lightComponents:this.__lightComponents,renderPass:o,primitive:i,diffuseCube:c.diffuseCubeMap,specularCube:c.specularCubeMap,sheenCube:c.sheenCubeMap,setUniform:!1,isVr:p,displayIdx:-1};_&&(this.__setCurrentComponentSIDsForEachPrimitive(r,l,qe.__shaderProgram),qn.setWebGLParameters(l,r),l._setParametersToGpuWebGL({material:l,shaderProgram:qe.__shaderProgram,firstTime:_,args:x})),l._setParametersToGpuWebGLPerPrimitive({material:l,shaderProgram:qe.__shaderProgram,firstTime:_,args:x});let v=qn.getDisplayCount(p,qe.__webxrSystem);for(let g=0;g<v;g++){if(p&&qn.setVRViewport(o,g),this.__setCurrentComponentSIDsForEachDisplayIdx(o,g,p),r.uniform1fv(qe.__shaderProgram.currentComponentSIDs,qe.__currentComponentSIDs._v),qe.__shaderProgram.vrState!=null&&p&&v>1){let E=gt.getInstance().getValue("vrState",0);E._v[0]=p?1:0,E._v[1]=g,qe.__shaderProgram._gl.uniform2iv(qe.__shaderProgram.vrState,E._v)}i.indicesAccessor?r.drawElementsInstanced(i.primitiveMode.index,i.indicesAccessor.elementCount,i.indicesAccessor.componentType.index,0,a.meshEntitiesInner.length):r.drawArraysInstanced(i.primitiveMode.index,0,i.getVertexCountAsVerticesBased(),a.meshEntitiesInner.length)}return this.__lastShader=d,!0}bindDataTexture(n,t){n.uniform1i(t.dataTexture,7),this.__webglResourceRepository.bindTexture2D(7,this.__dataTextureUid);let o=this.__webglResourceRepository.createOrGetTextureSamplerRepeatNearest();this.__webglResourceRepository.bindTextureSampler(7,o)}};h(qe,"WebGLStrategyDataTexture"),f(qe,"__instance"),f(qe,"__shaderProgram"),f(qe,"__globalDataRepository",gt.getInstance()),f(qe,"__currentComponentSIDs"),f(qe,"__isDebugOperationToDataTextureBufferDone",!0),f(qe,"__webxrSystem");rf=qe});var sE={};Qa(sE,{default:()=>nX});var aE,nX,oX,lE=C(()=>{"use strict";im();tr();cm();Ei();Np();Pp();aE=Object.freeze({getRenderingStrategy:rm,CommonShaderPart:ht,WebGLContextWrapper:ma,WebGLResourceRepository:to,WebGLStrategyUniform:of,WebGLStrategyDataTexture:rf}),nX=aE,oX=typeof global!="undefined"?global:typeof window!="undefined"?window:void 0;oX.RnWebGL=aE});var Mp,af,Dp=C(()=>{"use strict";Mp=class Mp{constructor(n,t,o){f(this,"__canvas");f(this,"__gpuAdapter");f(this,"__gpuDevice");f(this,"__context");this.__canvas=n,this.__context=n.getContext("webgpu"),this.__gpuAdapter=t,this.__gpuDevice=o;let r=navigator.gpu.getPreferredCanvasFormat();this.__context.configure({device:this.__gpuDevice,format:r,alphaMode:"premultiplied"})}get canvas(){return this.__canvas}get gpuAdapter(){return this.__gpuAdapter}get gpuDevice(){return this.__gpuDevice}get context(){return this.__context}};h(Mp,"WebGpuDeviceWrapper");af=Mp});var fE={};Qa(fE,{default:()=>rX});var cE,rX,iX,uE=C(()=>{"use strict";Dp();Jc();Tm();cE=Object.freeze({WebGpuDeviceWrapper:af,WebGpuResourceRepository:Po,WebGpuStrategyBasic:Ea}),rX=cE,iX=typeof global!="undefined"?global:typeof window!="undefined"?window:void 0;iX.RnWebGpu=cE});var Dn,Xr,sf=C(()=>{"use strict";dn();at();Cn();$t();St();it();ft();Yt();ge();me();Dn=class Dn extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"uri");f(this,"arrayBuffer");f(this,"type","efk");f(this,"playJustAfterLoaded",!1);f(this,"isLoop",!1);f(this,"isPause",!1);f(this,"randomSeed",-1);f(this,"isImageLoadWithCredential",!1);f(this,"__effect");f(this,"__context");f(this,"__handle");f(this,"__speed",1);f(this,"__timer");f(this,"__isInitialized",!1);f(this,"isLoadEffect",!1)}static get componentTID(){return Q.EffekseerComponentTID}cancelLoop(){clearInterval(this.__timer)}isPlay(){return A.exist(this.__handle)&&this.__handle.exists?!this.isPause:!1}play(){return A.not.exist(this.__context)?(N.warn("No Effekseer context yet"),!1):A.not.exist(this.__effect)?(N.warn("No Effekseer effect yet"),!1):(this.stop(),this.isPause=!1,this.__handle=this.__context.play(this.__effect,0,0,0),A.exist(this.__handle)&&A.exist(this.__handle.setRandomSeed)&&this.randomSeed>0&&this.__handle.setRandomSeed(this.randomSeed),!0)}continue(){this.isPause=!1}pause(){A.exist(this.__handle)&&(this.isPause=!0,clearInterval(this.__timer))}stop(){A.exist(this.__handle)&&(this.__handle.stop(),this.isPause=!0,clearInterval(this.__timer))}set playSpeed(t){this.__handle&&this.__handle.setSpeed(t),this.__speed=t}get playSpeed(){return this.__speed}setTime(t){if(!this.play()||A.not.exist(this.__context))return!1;let o=0,r=.0166;for(o=r;o<=t;)if(this.__context.update(o/r),o+=r,t<o){let i=t-o,a=r-i;this.__context.update(a/r);break}return this.pause(),!0}set translate(t){this.__handle&&this.__handle.setLocation(t.x,t.y,t.z),this.entity.tryToGetTransform().localPosition=t}get translate(){return this.entity.tryToGetTransform().localPosition}set rotate(t){this.__handle&&this.__handle.setRotation(t.x,t.y,t.z),this.entity.tryToGetTransform().localEulerAngles=t}get rotate(){return this.entity.tryToGetTransform().localEulerAngles}set scale(t){this.__handle&&this.__handle.setScale(t.x,t.y,t.z),this.entity.tryToGetTransform().localScale=t}get scale(){return this.entity.tryToGetTransform().localScale}__createEffekseerContext(){if(A.not.exist(this.uri)&&A.not.exist(this.arrayBuffer))return!1;if(effekseer.setImageCrossOrigin(this.isImageLoadWithCredential?"use-credentials":""),this.__context=effekseer.createContext(),A.not.exist(this.__context))return N.error("Effekseer context creation fails"),!1;let o=G.getWebGLResourceRepository().currentWebGLContextWrapper;this.__isInitialized=!0;let r=o.getRawContext(),i=A.exist(this.uri)?this.uri:this.arrayBuffer;this.__context.init(r,{enablePremultipliedAlpha:!0});let a=h(()=>{this.playJustAfterLoaded&&(this.play(),this.moveStageTo(Ne.Logic))},"onLoad"),s=h((l,c)=>{N.error(l+", "+c)},"onError");if(this.type==="efkpkg"){if(A.not.exist(Dn.Unzip))return N.error("Please Set an Unzip object to EffekseerComponent.Unzip"),!1;this.__effect=this.__context.loadEffectPackage(i,Dn.Unzip,1,a.bind(this),s.bind(this))}else this.__effect=this.__context.loadEffect(i,1,a.bind(this),s.bind(this));return!0}$load(){this.__isInitialized||A.not.exist(this.__context)&&A.not.exist(this.__effect)&&(A.exist(Dn.wasmModuleUri)?effekseer.initRuntime(Dn.wasmModuleUri,()=>{this.__createEffekseerContext()&&this.moveStageTo(Ne.Logic)},()=>{N.error("Failed to initialize Effekseer")}):this.__createEffekseerContext()&&this.moveStageTo(Ne.Logic))}$logic(){if(this.isPause||A.exist(this.__context)&&A.false(this.isPause)&&this.__context.update(),this.__handle!=null){let t=Dn.__tmp_identityMatrix_0.copyComponents(this.entity.tryToGetSceneGraph().matrixInner);this.__handle.setMatrix(t._v),this.__handle.setSpeed(this.__speed)}if(this.isPause){this.moveStageTo(Ne.Render);return}this.isLoop&&(this.isPlay()||this.play()),this.moveStageTo(Ne.Render)}_destroy(){super._destroy(),A.exist(this.__context)&&(this.__context.releaseEffect(!this.__effect),effekseer.releaseContext(this.__context),this.__context=void 0),A.exist(this.__handle)&&(this.__handle=void 0),this.__effect=void 0}$render(){if(A.not.exist(this.__effect)){this.moveStageTo(Ne.Load);return}let t=J.getComponent(re,re.current),o=Dn.__tmp_identityMatrix_0,r=Dn.__tmp_identityMatrix_1;t?(o.copyComponents(t.viewMatrix),r.copyComponents(t.projectionMatrix)):(o.identity(),r.identity()),A.exist(this.__context)&&(this.__context.setProjectionMatrix(r._v),this.__context.setCameraMatrix(o._v),this.__context.draw()),this.moveStageTo(Ne.Logic)}static sort_$render(t){return A.false(t.toRenderEffekseerEffects)?[]:J.getComponentsWithType(Dn).map(r=>r.componentSID)}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(s,l,c){super(s,l,c)}getEffekseer(){return this.getComponentByComponentTID(Dn.componentTID)}},h(i,"EffekseerEntity"),i);return vt(t,r),t}};h(Dn,"EffekseerComponent"),f(Dn,"ANIMATION_EVENT_PLAY",0),f(Dn,"ANIMATION_EVENT_PAUSE",1),f(Dn,"ANIMATION_EVENT_END",2),f(Dn,"Unzip"),f(Dn,"wasmModuleUri"),f(Dn,"__tmp_identityMatrix_0",$.identity()),f(Dn,"__tmp_identityMatrix_1",$.identity());Xr=Dn});var _E={};Qa(_E,{Effekseer:()=>mE});var aX,mE,Bp=C(()=>{"use strict";sf();at();Wr();Li();aX=h(function(){let m=ne.createEntity(),n=ne.addComponentToEntity(Et,m),t=ne.addComponentToEntity(Wt,n);return ne.addComponentToEntity(Xr,t)},"createEffekseerEntity"),mE=Object.freeze({EffekseerComponent:Xr,createEffekseerEntity:aX})});var dE={};Qa(dE,{default:()=>cX});var sX,lX,cX,hE=C(()=>{"use strict";sX="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAIAAADTED8xAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGkmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4yLWMwMDAgNzkuNTY2ZWJjNWI0LCAyMDIyLzA1LzA5LTA4OjI1OjU1ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjMuNCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjItMDctMTFUMDA6MDg6NDArMDk6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTA3LTExVDEyOjU4OjE0KzA5OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIyLTA3LTExVDEyOjU4OjE0KzA5OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpkZjBkNDUyYS00ZTNjLTRlMDQtOGUwOC0zZTA4YzBhZmY5NWYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6YjMzNWYzNGYtOWZlNy00MWU3LWEyZWEtNWZlYzVmZmY3NDlmIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YjMzNWYzNGYtOWZlNy00MWU3LWEyZWEtNWZlYzVmZmY3NDlmIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiMzM1ZjM0Zi05ZmU3LTQxZTctYTJlYS01ZmVjNWZmZjc0OWYiIHN0RXZ0OndoZW49IjIwMjItMDctMTFUMDA6MDg6NDArMDk6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMy40IChNYWNpbnRvc2gpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpjYzQyMmE0NC1mM2QxLTRhZTEtYWMyNS02NGE3NGZkZGI0MTciIHN0RXZ0OndoZW49IjIwMjItMDctMTFUMTA6NTY6MjArMDk6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMy40IChNYWNpbnRvc2gpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpkZjBkNDUyYS00ZTNjLTRlMDQtOGUwOC0zZTA4YzBhZmY5NWYiIHN0RXZ0OndoZW49IjIwMjItMDctMTFUMTI6NTg6MTQrMDk6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMy40IChNYWNpbnRvc2gpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pi6E66IAAKbnSURBVHiclf1Lr3XLtiUGtR5z7X3OzXuvMm2wxSNBcgHJYFdApkqJX+CKK1iU+WdI1Ki4BAYkpEQpJJBlOS2nLTtJnHnT13lf556zz/6+OTqF6K311mOMtfZh7rXnN+YY8Y7Wn9EjRvxX//N/iN//R/j5H1y//7/nz/8xfo/rZ+TvkW9cwBtI4G0XF/AdeAPfgQuV5j0vdpq0+5f9TKY5rjFTJp/qO+f1m7mu2yNPDCs8n8pRsuT3Y2m4FQ7Li1lOst6Y6T2xWn5U7Re4te34PhLn52n0NH6pEDU7Pqk3vizqXi9uiXFLnLebccu+f8ZsyRe1xK3wuBUV/+T/kPgXyD9D/hnwL/5R/tl/mH/2H1x/9n/J3/zNZYC+DMrvp79HSnjPvCAK/abQfIAbkwwE5csw4QkwqcXhi1sCzAQOXKcZx/c1i8rbn8+l37zfeUyPL4vCjZZwu9b39XTzMeUjUnURt/bgy/Se6+tkuzsX8Xp9Qh4HUX1GEsfnkcaOxKpu5etv8AJewAeu17+Zr/8dXv9HfPwX+Pjf4/W/xfofxdqUMoq7bJQfKw672H/r1iDMm/fmHlN+QME/d64Q9odZ1GN2WOFH+3/xE9Zgz3XPG3Ms77MSn6fP2cJHSsinZuCTqcFTSn/6ddswG+A3vx60uCWL2R0v8xeL+oJmMIv1SdHNj/gr5G8QPyG/IRJYuH4Efv3fzfe/h+vfw/WXuP7PeP8Hmf834B8jr517ifvmwOtjV9UOb8r7qblHyus2BC687hR4jMhBNirqmnNw3ebvnst51Rcfz7XYxyOB6r0ze9wG5D5u958gOj9jSXdF5dAE7ln8c1ck7g3wxJ8V8vjJW4IvOvtYkWd0ZvdY7L3BH/g91XlgvTb6gT9GBPI78P3v4f3v4vu/u/Kfvq//EPl/yvyHyH+G/O3CtyuvCETO0cyuz+dPLP87f15PDd2y4rL+fCHm7qPgCQ5i+IxlHrU86prK8hlo7rz5s8Sffe713h/d6z0uvkh8CNWjui+yfMZi7yzc7/8hpHVv7dfD9XV/74SKyRcOkOxkH3gjEhnAB/IH4FfAHwE/IwP4BnwDvgPfke+/j+vfx/W/wfX/jPy/XvkPMv8x8l9m/g3y94lvme+w4QoA2YN+qChi7ZIkR3OPQfkME59Jg6PGOy9/pK6Dc3xW4xcIO34efbmLr5gD8vj5mh4eCzza8Mh9057+IqEecgN24aU9yrQv+qW2fUH8RxuUF1/OxT1XPMEAwMcFrCgbAD8gf4X4NfIbAOAb8HORQZZtG3H9O5n/zrr+aV7/D+Q/iOsfIf8M+ZfAb5C/Q/6M+I4sH08idyMyu2JvnM+f4HVoDo+ze2T8rNsiv+uG/kMm4P8fEBwfZ/ye/tA07ljP2ap7+Z/x6Tv+/MJ/rskCD0B8jbz85OkX4ugPF3pOmXfWfnTw3n4lcMaEz7WGo+NLEiACWIgX8gP4AfEjrl8B34AEXsBCvoAX1hvvN/BGvhEXcP19XH8/rv91Xv/vzH+I/EfIf4b8c+RfI3+D/An5c8S3yO+JKzIRmaSH7k+ezfrs87Us/gNvPnKpOybu7NbzflEL/gCgPN45aOCxnXhK8FjUF7B+vD6kxNcU+NiF4/NYez4h9Q7iz4p6rOX+81HWHTN49OIjArmAF+KF/AH5A+JXyO+IxLUQC/ECXkg5/+XafCOuv4vrfxXX/xL5n+D6fyH/U+R/nfnnyL/A9ZvE30b+hPwZ8Q35PXAFLuBKZGQmgMhqXP7CsD4OzaPm8AjTA2G4jcLjlH9d+53ZY7bnM8Tc2d5x89BMHPT3NuSXc/+LPAWfNNIbcwAoPmnS0Z6jli8kJz5P87VAeGz2I+3BRulgHx/VxYX8AD4QP+D6sXSeCFxRY5Av4DuwEG/gQr4pXN/A9UfI/0Vc/zbyP4vrP0L+Y1z/DPHnyL+4SiD8LuKnxM/brA68r14HS2RGUUJ6kx9Bee/Vff4Owe36zxeYy0+Y0NcfV35Uixd7PU3eoZffefwjsz9kxTGvjzLkszbfxSBuI/mFfnIf9kcB8kgMd73lLoRxG7Ff7M5R432i740BcAEfGcDi3wfwA/AD8OPUHBfWd7wXYiG3FrSAF7AvLuBCXj/i+rdy/U/i+s+x/hNc/yXyn6/rz6/8i8RfZf4G+C3yJ+D3tBO+A++0ReEry2hcUWZAbNvhJh/uHY7bZPgcPzKYiyR8wPQgg0chfn96pFFL7vPxi8zsC9rGzJs3xBx57wzvgNofrth4Lm/JF+Tx+PSxzY808Iufz0TKUdTXYvADgLQgvJC0huNtOUkkuUoOlChY5ceJaxsGiPwR1/8U17+B+C+Q/xni/5P5L5B/DvwF8q8zfwP8LfJ3yN8jfs78WXEVmdeK612cNJEZyHIjxdnfbTzo9zXHN29oOBjzMYJ3tnHMQdym7TBkcZtFbwyeJvjrWfki42ddeGz5ZyR0dByzd1+0LWeux5T3ocMN9J74s349solfbN5dtMYnPd2fjwwEJUC8gA/ERxnEACJxAQgkdaFYiO9FDPnGtqFz60VbFAQQv0b8zyL/xxn/JfI/j/znkf9N5n8b+EvkXyP/Bvlb4HeRP2X+HvEz8hvie2bFVSRNhcI5iSHZqYz6yjkY97kXWMMUj69Z+NcFPg5iPMH6oJPPqriXKZA9Lmw5Vu7dOWo5VCPcru99ufPs+8/PupA3leYXO3tXRDHv4/M79wY/8qD4kgY+VgwGX+6gD+RmxFfhLkgDuS82wSxci4rQG3EhKQrywnX9yRX/NvJ/gPyvkP8k819k/nnkX2T+JfKvA79B/hb5W+RPGT9H/j7jG/Ib8M4ytxN4Z14ZmxJKQSr7eXcpcNkgHG4l3ODyGV+/s+ecP+/Zj899IeIuJY4En4Eyn74fC/lCbYjbBW4AvV/chedjy++N8YxfK3iPeVXsLzL4oyXHhN4/n/EIzexH/SKmWwu6pm4hjXanlEDYVHHV9/7DGxGIwFq4rn8181/J/O9F/pMoV+l/i/zLzL9C/jXyb5G/jfzdFT9F/rSlQeAb4tvK9xvfgcvshGtbzBcS2ISQMbsVW2TYgMUnUQlKskv4bCnqF6U8noD4COhj6B+z3NnYZyrEPf2d+A/ueGhxd3Ac/Pho4WP3j9rV3z/QKP8iwWe0h6fR82Y/VnQIgYso/thMtMwA0oDC41bizYFMIKOQvZnwFZQMFxA0A951vQUCAshA/vcz/1Xkv35d/xT53yD/JfJfZv5V5F8hf4P8DfA75O+QP2X8FPnzhZ9zr0LH98h34h14R14ZF3AFtu/oItYd89bN2D9x8QE+Ga+8zRZI/muGLeUno3yA6QtdK2/3/xB2+5kQe5QkdwI7mP3XUHscDTyN1WdyTC2/0/999A5hlU/Xnv2zpuKXsjzK1Y9EcfEWAvT948JFOeAsJIOiIIok8EYG8GaiC9e79aVIIBH5q7z+DcS/gvz/Iv858u8i/+K6/hL5V8i/CfzmvaUBfsr8KfL3Gb/P/AaUyyjxHXEh34k38rriym0nZJUO7LW2QKbJgUgJLqSYE/Jh7I6J/II27rnuE3Ont3uWQw27a1x/SEWfPfKbzvjxBDVYGx5LCPv+Qzp1NOkLED9mv/frs6G401Lebj7KmaTj0/SZVXIg97qYO+utsmDBEgUQ+q8mgzQnaWyTNoD8e5l/guvvIf/ryD+N+NPMP900gPwb5N8Cf3vl75A/BX6K/H3mz4mfI74hv134DrwD72S0ReQbkWplZAKZkQASGUja0S0ZdrevSoNNN59NzxeM/BjfLySvVrWOOfhM6H9BlvfsX/Dgg+kePXqE2l1cPJZzr/SzTt1J2i++4D45Bw3WBWccnxXyxf2jzR/FFQJYtG4VAbHVmAR2/PNmtdiqRX0WkG+yWEmAN8nDljT3dSTi+kD8D5F/ktc/Q/4J8o+Rf4z868g/zvwb5G8Qv838bebvED9p6SDjmxYQEt+j/EXvKCMhkW9E7oC8CxmZ72rusd5ckoFjnbSkOTrTkr4H6jyiVt9fjPt9NfoPAboSezPuYXZHwM/ByD8jDNwq8oY9NiAnFv/wz0FyX4iaL8B95+J3crr36JFN7LwfkCErFUj2wKt8QbiAV1GCD0Gzk0MLQus/JVuyEJdceYr8uxF/lPnHuP4I+Xcy/w7yj+oPf4v828jfIn+b8VPkT1f8HnSYJn6uCFW8s5ynW+6sRGa5YxORa0udLNVoSwaNXALyrnJiEhhmNS2Mhxn6xbF+5Nme5i6vvVhMWPtk3znuga2jQJ9vPBV4/zz26w/8xFONd1GQtybdBQ7m9Z0qjuz3PqoZjz2KrQKl34jyb+bqi3ghgUhEWgVajQrgjdhMFYBZCG1dJK4wrO013utH5N9H/BrXryN/nflr5K+BXyN/Df5c+dt3/C7yp4zfI38Cfo74cccXZRYZBL4nGK2KzPquBbWMJJFmZi+u9Ygk2I8wJp1A6XgSII9s6VAqrtv0HxC/c69HleNxyj37Z/rJHdaOyEf0HEg9isW8fqSEx/SPWUTb3v3HvJ8B2guPp6o/m6CDMvf9WgmGa/Or//JVpmUm8BLjBBJ43SZMvJ9FaengSkTgsqDkvLZ9HLj+NcSPyB8zf4X81ZW/Qv4q8ldX/oj9h19l/i7zd4gfkb/P/H3ED1d+i/iW+Q3xDfkBfM/eh1yWxxYIu6qSX3Et4CKvL4QHrj04yX9Qo2Lrx4mwnvIf52q/KLsxnzoU7il9YB+J5ED8UekviqZ7S47a/fog1OP+Y5rj8xlYD3rA50N3J4aDgF3I3Kv2ipYN4EclkkNztRDQalcZBol8lUvH0b/5fbBFW4WIKQFWrRAjrnab4pJf5u9mfiB/QH6s/OEt6OePyB8jf7zix8gfM3+H+AH5A/LniN9f+XPiA/jIrRHF9+0j2pSwnUUZZSGEbd7MEgvN60OGkOE7ScgX+8f+cilOM8GFurtE/uwnnvjxsT3lkaMfgHtke5+hELeiPkv2KGc+g+YXJTy2/J7ygPKdW3/dgEN84Wk04vZzp/nQ3ctpYEc6KP5n1XbhTQOqI22/RQ+ZyCDYJlsrSFrGcVEm5P75x5Erc2W+kB+o74/MHzI/gI/ID+QH8oeIHzN/Qn4EfmAYRcWZ5taI4nvmO/ECTeQoSkggMhF13S7U3QRfY5b7NIFacxtD2uO8gHeMuxqLO0DvoM85u9cNDcf0Hz9zTrBHpD4KlgP9nzH1Ozs/qjgac8fr16LgfvPxexdy8AX/HDe/YP+PJA0RgHPr/Rdr6kJZQgDUJpCUBt4g54so3gtj/1XRRQ0jEBeuzVevP0L+a8hAriu3+vVCFvSvHaK0qSJemR+5f8bPyA/EN+S3iG/I94VX4h34jnhtE5lryW/k2iSw0R/cphOZF3LMTJIQOGZbWMytC6QQQEoVLH2go5UcK3ePzYG/x8+aNjEmmDTTR7GPyAZGX/3p3b90IOyLFuLWF+X64vOo+dyb+hm4P6v9KPyRLKPXAXzy+JeBFbgkASgEaFVaqMRGR8yBc6K6KsG+kD2wLryDbpuigf8OEivjnYFckevKFflKbLHwyqxojYyijYyfka+IV+YL8T1yId7IV5ZZ/AbeF67AyiKGiNKCapEv49qKTTZxg/rSZNLRvZmkMJUqS9+8/0YMjjncEBMmEO7IPmDxGdo+Y5x3WjpKu8PlCyo98PpFG77g2Z8B/Xj6GQ0fzP6RFI9acq8E9xM5LrkmcC3EZVaDLlRrjnn1eUoX6HtJ2MlgSwaUZ+mSSL7+TuS1XZeZsXfLZL6Q2yf1gXxFfa+MVfSw0Y+PxDdgb975fuGN+J75ynjvgNXAW7vSgCuxkFfEbsV2EW2gZuPbZRrRXaHaxTg6LtWpBw1+4tVPDZhy5KCEY7aU44Dp46TePzHz3kXBZ7jPT1Iq/WONn+Fbd/4QenCyP6pTq47yP5MYeSvNR/VDkr54NqiuLPrsF5B04GwzgA25q0AJ44yBFXhH+1PKKXQZO4xeGUj2LK8/QV7E4WbKq8NQd9xSrsxX5ivwyljIFXhl/By5Ml7Ibxkv5PfE3l2zEivxvkoI7IjrIE1XmF1G2cp76YAKTkZGmuGbhfnqcdF1bKrAXGw4AFy/ZXAH4zI0MY6w+/dn6scjSfyBUDtu3pWEI2XM68+o6Kjia7adT4X7I2esnuwLafNZy48GfDSV8/neCSlRsPX1WHQksrFSFnYNwXqOAe2+UQKUckFnqPKEfJWB9/WnyO+ReWXGdt8XPUSyZRHbaF7IlbFthr1m8a1+xivyVYtlpRpdke/kbs4oV2n1sxh0ZkZ786MIo9Sh6lf09CkMLwVqsYhJDByqPNEZStODeWfYuK2LfcZrD0wcgL5/HDGf0ZInuBPPnXofS7jX+4V4eYQ75rVfHHTySJAHQ4qhAqEUFenuuRAXakE1u/cV3LZqHTUwtmgd4maR4V2XzbfhfmtEQUsgxWzzT5HfFWMdRQXkxlpnjvJYZbyw/UhRPyNXctNaYGWdWbqCEUtXmQQLuMoyLrs9siRdraNVzbErHsQQOza19J3J5sJIQOlNSIgYBiyUG+OZLaKMibfZexYUj/i78+xHjHZLZj8+q+KAZn5yfZT2+LmLpqM9MVMe5HEnzoNm9vfHax9NFQC3wGvvC+xCT3MHSiTRTWkQnLD0RolpGVdrasn+2eW0VPkh848j35nfk1ZB5KWFuUzRK7atDKzYCtKmASzEylyI78iVeC98v2oTZ2SuwDuRRhUXiPIOAzRv6V7GqObS6G2Mh01TlmuVI54ZPPFOYoTEkDckdJEedmV6G26QPQCtBA4dB3resnyBRf8cGssj17/z8vvTO0bv5evnXX97YBw3kvASjp9K+fGG9lXNuj3cn+pQsfw0d9AqSth8Uqfdyl2YMBsAJQoAsnw2tpapJGqwy/+jzJ+R35DvLQeybIMr8gqXSyLcjA36KPRHYCXWhe8RKzOaNsj7UcKhdb7S8uXtojs3FdC3B4jrB1SIojtNf3Bt2+nYO8RNLETxB5Yyp7DBdOOcj1j8TAFQvgMBx0dCxmvHLOSzjI9c9k4Md1mx5k/Ma9zyftaAz9p5f6RaPjDvOu+P7QOlF2hl2QZbApRqhJ6MvkBPaZDnpd3flt/lT/VtBHDlQv4d5LfIN/Kd+T3yyktuHFJMIjNWxhXYNBBYGdWHLShWrHd+SyxgW8Yb9CviO3KhNj/vv+j9+HWqVwB55ZXx2lFGteOg2X0AeQ0M1/qHUwL5sVQgC0nqwvrpnVMeU5rMIE5/0EPc7uN2cdd/nJYOeOB254B4kpHcaUwV3Vv1iNovxMhBXd6YR4lxNMPL//AHQS+QB3ImyTOJ/kje1AoxkIlYNp2rK8urHu2Y6jRqSc2z5IDtZFmJK3+F/KO4vl/4Htuzud6RVwW25aXWXyYKLooCtCj4HgjEd96PiJX5JvSDQURvG0Np3UlJtsOKIkKu0gQiolxZqPAJuXx36bs/tUSe0vo4DGegUd5nfNjNB0D7TKXbnN9h/RkvVIJHqviCKz8y6TsE70R1kPdnBPOLutmdDPAHdFCfJgB5gdxJB/Ri1kZOJN6b91MOFFtb7EaaIqTCpRxciIU3gAuxbNoSAFeqLq495xYWv7rW7yO/Xfk98zvyuzQiUsy1fUMXuxjAFYGMpGqUCLMHAoisrY7bEkA7vGofUHMTLhFcyZiiRn+ZyDvYWppOmI28WT536aDs6EJs0UGYFDQjuJfa2oN053k9u5w1uVbxORBxA98XKPca72Uen9GkWVrYyOLWsMd6XVY8qm2HiPiibY8d/xiFBi6U5xy0enU4XIGS10EJkM74t8S4130hVus8ceP9sBkuvSiR5YP6AfmrzG+R31eRwXsf0BW0Cmgi03+fiNKIULcithAoLT5W5FaTrjIeYp93F8CbJn01dntLt3S88tJyAeclow5ATYoAM1456jv87iosl8+UHqQjvM6Jp70IvCHZ+ZWOAQZy9zjf0HBHqj+9p79fO9n8IuvF7fter9+5X9w/j1rQZ8nuj+J0g9IbEh7FgK1W1N+17QGZyAuRdBCtT6sJqu0JwhrFqnENf6tMDrRZHMgfkT9c+cOVP+LaulAfLBe955LcuWgAAMoYyI37iIwrvknemfn7TjY2oLWCFgUpU3iyf15gbUEXRb+HyI+sQFi7k70uUgF5expPM0Bg72Jv1HLHYo+/uZKuHDk9y6NAwK00/9wfHRIGT1U4HB8VmHtRj9XdwXbH3j3NUUhvidwP9iRfthoQ0yQAV8rKKRTAKu+eyOaylFtcVNGLNGXQB3j8VlIvSkTibdfID1w/1Jl16wfkj5nvzHfkmxfcGKn1go2WgLz3m1lHRGQkvmdEnezFyNWohmh3s/W59vPsfQ2ZbRjU30JeO3Rjj3m1W+sJ21kUAB2kKPuYtwh+uDl8+Juwe9T4aDFAI+SXmPchmpTlkYV/hubj0We5cpZ/VOT38fT0/nkkiXt1n+V9LMSMYBOa/QakCX3BupGdFTOXq90oHreYKJ0e4DMUv99iQfflCNpyYC3atReAF9YPkT9Efsv8Afk98nuWSfCDmQRX5ub2e/14K+M7nKjwn9KUM4C147K3syhpHtTBRrlff7O3c8ZVw3O1bCr2f2UjPgN55XbvBNG+sRpIQywieXoFPUVpek1RLwcxKHnm9Pc2hd7irGE/pv/Ed4zUXyD7EZR/iFhwoeR3/PtRBHk5d1kU05A4+viZTDjK1/XHmZwsv9g/AJrFyadlBEex/73+M7Qm2wtWriGFEu0IiNWaz7UIp4smtV9AGhHDoa+9CeYj8MPeEnnhh9oOFlfkdaXiilI+wg1IKkVXgTvq0VUOsEh8L88ptoOoBqU2tGVE7PVjUkJTRXF15BVBuxngVmhSnK0ZR5SnyCMsKsyoYy3KpbrH+KoG3bT6k1QqjePvroH0spp4AhvzyFPvoI9bFV8TzP0bM72X81hXHN39ZBjutd9r2Z+PvAWad/tICTumDbwjOrm0gUZjt279v+g8Res8pQ659n+Vi+mi5lNpFCB0vRIv4CNXb5dB/kBF6AfkPjXoAnbUwv4ACq3YnvjYnPiiDhHpOjJwHm7BnwR9+YqdBiKJ3byukFc4Gc1n7HYuICClowGISEdkNQ4iA0rpTUIC6kB2u1Nb10n258DBwsBEGjoCJ5E9IjtvF5/dfCwnnpIdFYmoPqvoUW48NhIT+vvnR9z6Cc5BKMfk68CpF2mJoBi82Q+b8ScNAJg6lLwvrG/N552tFCUjiHJVuFvk68qPdb3efoTd3gkZe4ngjfy4zCSIWrsq8Cd+QHzbe9syvnMgIzOo+bxz9Pxd4f4RV17NImu1eLt2Ng9ZdBD1gG6BAOyYui3t9n/UyBkQxI2aAi24whBkzCw5+I8h/fxYmju1eCoHWZOEaCk7GSY0j9rcDjkKjCe8HhLGxqyb/1maI/FR4B/Swf3pUyFa7kSf71DcKOy+qUmwnzBPUUb7hQDgwmvhfXEN6qrQiTJ5N++XtlNA2lzfFgQycL2AV2IFXrlemxKQH5HftX0s8a6TTeMDeUV+ZPlmKooocGVBMnTha7/Anvw3tZYdyVGLYps/Zv+8gFXmQZ0k3A4ibrspMaQgh0SpRiVKgvSUJSa5albSIiE3UQefFkRit0fwfvqQEuiBpdJmgHjUW3owRDke0zXxdPDpA+hHc7yEL5r8WUb/+YsSwB+Jq+1k1+EGlQx13k/+SAmAJgNBXxr/vqh9ZCBP4NaCWLiuEhThxDB9oKEV3m1ka67WilzIV+bKS+y/VKPAO+Md+ZH5ztzHW7+ShgEDETaIvsveVDAHwxKk/KAuCnqB4v3q1XZcbScwUc71AcqBS4GlUbQRGdRnDAWlpTHaNJMNa/u4dKFaj0DsNeYGU51tgUNOOES2F5Y4PkMtPqOBcXPqIp+lP3DmaL5zdBcd90/cMoqjPzTvS7K8dzBKAnDh54q+6MIUJUrCkDXsZOA+0L2PLKn/rItuU6r+8Cijiycoon6WKEhuGdMunFx5rcAC1taIojbRv6K3Sr4SH4HrwgvxEZnIHYidgeuKjOSO+OBJ6+GYebsg0HfQF5RtDEDrVLvAHe9XwUKolTjqOsB2+5hj05w8WxTt673ywYkjSredIJNg10SNKptDg+0CvFf6WM+qfGU8wOqC4kBVMQorMebTPwTQsBpnYX19R7+37Z7l/jNujT+uP+6t96ZvTNcJyZPrw3i/s39BXGVl4JIQQClC62oayMsQv2rvFtDSoDnaWrmtjUux/n6eNTfB5CvyI3MfoPsBZMa1Mb83v3PxCheN42jfitixvEBgkEPYcO1lgW1x2xpZKiDiCi6O8XuPPvWtPR7JKLrScfr+bkbuL1JAjQMVngAy6AM915NJL+ioCkdD7IARdvpRAhzYSMsuTaHF3w1CX5f5GZFgVqQs8ZTmKPn+6LrdTIMnF8KsyvSQOBb8CPrj59Z89hFAJSWWcYNoezcP3r8YO7aa6yeVn9D2g2uLmZVYsVZk1H75fCU3SVIIvBJX4hWh9YHrwhV4rch35g5r286ijcnLtKLQmfDGVC8gQT/kYI4XV9BQ0XIlFhbpITG0IHmBtoVeF8UsQJdPxc753JrUoIhoNxdcX3KExYVS/w/ICFKUgzOz8dpHleOgDai9eaaElXM04Hh60MZn6b+gnHsufVTmeTDWIVxgjSjlfg4BBA4Pwo9SnK6oP+F++zqD0qDYLa8HVaAMg2oAr2tcFivbGtXWhaDrV+BVYiFekW/kK3PHTl/AFXHRM7rjgxiGE738ylCe2Vvzk1IOhNhfVrdAe+DKfahqb6x5no4QnssOLhGyB+oCpBqlMB6si0tjO2NRR1MrGyb9a7d2OITOXrKGkhvReUfiQ4bACpFMoEQaHXa58cjR9fRg/2rAUcjRhccCcavr6PWHDYjVQ2quqZ4SoHuw6YkLAoyvIVCn2iOWH1R+pPrHDkAyX9BhB0cDKYDItU+L4PFd+z2rtT94mwRXYh+LsoBXxBv5ulLr1C/EFbnp5wWRdyTP/Tro3aVBOKazqN6Xj8JXw5PnCFQEtd5wU5rSBen/cyG4Bg2g+4fgqGR0ThJoZP8yCQT7nO2L7EKfuWUAFx4MiV9k4Xe+weqfie2x6vujIans+qzul4qNp58f51QD4C7aCHxnJrH8468ciAR9xcrQkco4tKYN/070kvC68AY9QjDJAGD/W0ZC0SON0f23gFfiO6/bNsjY4aKvxBV4AVdGrswrX4oTRWbghchro3/6R5zzNRkEtOa6bWIjAPsW7qkvcUHgIrg3srlasRlwSYbcOA29B20vYxBWUYQFUoNwWrco5UsFUpIokbPFDbMZCCa2GMEEGiCW9uDKx6cxZzrGnXP7z8ebWrDjgH+qAh0SyVtyNonpPx7zyCp4Ad8ny+8uedBEC4t6WowxgG0JakkByG1VC/SBAN7mCKr7YDDcRStcg8GFhkAkFqXUurD3di3Eitw+U9nKG/2vWgamprTRn5FpvH/EGiiOyCagBimWPPBXc+PkEC6ZBNH2wB6eRct4ocRIQV6WMDed5fZ4brZ9oVa+xO+N+7co2uRZv00W3CAcnifIrTXD/muh3ioC0rGX5GwCGMM1K+TPSW/z4bhzMGjdeSSDz2jjaImn+XhIzbGQsDftg9Yt3d3CffkFw+7bnZov34g7na0t8UEvqhpEBxE7EECE7AH726eLRh2dsvc9lp4TFXGx77w2243MUlHwKijsk+BBbWNE1HCTV7Orvc/mfeXamh1HuFpaClKudHugfPp74Sx6aQDYawABXLVmXGSxvaKl2FuIA/X1Ru5UpyD+zYHjYoQpVDeod+sbEhQm1XEuZShTjmEZo3QUctRyZ9c5r+N25yjg8XNH/J0a95TQDcq1zcpv/BvB6H8b1Wb8tHpX4nu0A6O8ikFVp4tGGPQDc/WXAfK5HPEAOkBov5WY0mi3YlH5CbOJ6y9iIePKtV1DgYV4vfPaxJBYtUiMBF45BqeFVhmeWBMVteUmuM6bAMVLjV+qqLwiln62KzQRseAhQ702vBcTSIigMBCrAP1HI/AH7QB1xtuOIHMJDYcqrNkK07ijq0tI8cobtWBizvE6nn6mtXyC/jtdPdZ4CI3nPmwVCCP4oLi+ghv1b1VAUgoVsMV54Ht0WGgy5U4m+dzN2TOy6oQIyOJa4pLDBmixRaWInQwP2gmSwW5HUibsXfCbHq5YmVf5Ukv5ca/oK4GszZoA3fHQbKWm4eIIibtrL1xWVgBcEnZBVqw3lnMGk4JmMRR0ZwxEywKFccCpoqqd7F9kQOYtoXOsasW4ejISmMLAG0UGOWHqiHQI5CjPoi1utfjnUap40z4TPrBWHcV+ZNaBM0rnVNs/yd3rgcgjuuDND0L80LD+SAD7IsBlMksQpIG4jvHKoo0cmhml86a/hdzH/iwayuUwTb76Jsj7V8mB3DrSnsGF11UIVqeT3Jl8u+GOLQqucumsLGZfoI99COk2lFPnDJdYQGn1Fseww4R4oUmjJaCp3gLBQyq6vSsisUMAKyxp5wpxD+I/m1YPMVD9HVIEw+EFQmAXAsXRPAmEZ1ly4DK6ivsnbz8PrAsqBwXmDXe6Y69IslL8Zjn4hYKOqu+2XwZ9GO8Hpg1gNwFLY02r8Dg11ORA9JJxbr9QJrb2X8vDGSvjDSRWtDoUIgyeFfdKXBHryosWQjlAL2h94MrgJp2yFgSFzHwFLh+3RAYWoyGQ2/oMGdyFgR0ogdZiZBwvB72WuYqpoJYYWNk2giMzV+mTCpXgYFeUR82cfPsFDrH/aAZuWpxA4J7MOYN54o9qgUkXg/JMeX5Onm049UdDUH2Wd36cDO7oh68EK3zBG1o6/S7FoJ9UeHYG5/o7ZP4SYwlmAVb2vgKwTEHjof/7o8hQats7yQxTUbkRbQwUDQSPyuoTgfrO1n/Ku7RwZYX9vECSEySyNYKL96V3wdcEstbEueOhurH1n1orRw2SFIebwpcbubGdy5uuzGJmMCsZb/acy1tq4gPAWD6rQS/py8gixUSETDVzsx5koKHPcyLIK6YhoZSfMe/z58GM56+nhw9C4EjsIM9HL5Dyy8xNcXfWENab4njbJRnI5InQKB+21FHxMA+yUAO7xRQC3o0sJSK9/2mUACKevL8Yf2yNqOmhtBRayZlxRa5aftAhwBt9RRg7pGcFcPUwyIkJGb5ZHGBF32RId8gmlhmw39ZBwNFZ1Gy4MN87dkIiIVv/MaCQoBBcIeAPGhM1+kyxa7FTXCidLUiO94Jmxw1xaoZNJoGDgMTds0B4/DwIhLzd/7youN25f3aacTCWk86ehwV8BxBj2js12f8mlSuap5FfAbjpPwl4gB2GCqSUDvRq0kpcJQQSPUO9StADVYsUQeiLKnLrQljAdYEb0gqXQrwUIfBiRWyVetVExJpi66LwgRnEioe7NuIjrqs3zUiKGBk3y57vdUWrQ9Amm7qX4JKZSCIaNAkEF8JMoINLCkCpSlpD0B0GRFQGhl1knmyo5DxHn/eD7W5+d5ABmtqP+W8mDaOivmW/vhYmR0qvOrYRfM+pi8vkQNB117p+s68+TQhqaxTX9YiXrlxjgyr8GAAfArYxY2VeqRquwSxBubW9JuL6KEWIf3vfpdhz6GfwZKHxtwicBN2gHIBtQrgOsO1doGVChnmYE4vLWTBbPrLtntgrTqXN1xAl5YMIIbloQP2kGH5e3N7DxduNWOM9Fc8tpV14pNHdCuVwp7qU2FJIaGl4PThPmxbjvPEAXweIfh7lfS1MHss8UqoJvSEmyWvlA3USPIUA59yZ/cbC9+w0aehXnWJkLQceO20tXsCbiKz9NACMtcitXtECZUYGlWce+B/Y6tB+tGJdeW3FDbXVPUhFyxz8C8gLi2xu63ons+Bnw31bpyuq2MWVw6u8bmT8fFQdishUYsNtCuulAkU7dkz7p4KEyqaZaF4MbS4rPYdrZ73Oa+iulGUkTyRRymSes9fT57RkaKo5q/yDhB6J4QaiQUXHLHw2NUch+84HKDRxC1w0iUgmFjXiwj1M7Umjjbg1XLJyX1wS2SC13PtNPHLsKuSYZ/YDtCZSUjLPIpoMIpDbrRp8X1igYvAiXPuvxQEZNZlY3JZTZDCpZdPYljN7rMoA2AJBJq+JnUykHF5BabBdiR0Q2jNWNL4VeqMHWgMwl2a5kkIDXk4pOnui/GeNdA8CxZ7ALWU49Em2vzVFG+IRPepzDtDB3xTiRNkT5WXCsj/euZPB3SX1SAPePN2hG/SJChdPRNgguh6oGAmswLfbi+B3s0QGwVogLuqID30Vg9VTRRfQnM4oIdDQF6EephjcGbpP/iFkk/QQdej1sJLJwneJFcokNQkZMnm9BwvYRLVKU9oOJaAWWhY9p6GRuHoDxO7m6k5p9GpyyOUZAJFMUaxnD2rtOqNTYk+dynIruX7e1JmSFewWgclFbFZp/RcZbJlyx+4wTliIEorAg1zt+OTgg09Af8r7uYgeaWolWODLeeHX4qiYzH73UBKgohdpHgTaO5hEv1MCyP67uUak1g3tNcnos8hdSjUhiKHQpwnpQs71MXGf1HzYaaIaa7PTC6kwB2CtcgSV0qJv04I2t6sXVIr9awUcPXg8Sn3wRrKKWiIA5CETebTaE4CrTLxo0GZq978JmuP8ohrsWlbgFxmk1CS4sGi+6U3hlNynteoJwUQpte7gTH1ZOcdHcA1M0WPgeSBIu/mB7AqcaIC9XbBn5EKbvGGzRe0bW5v+hmKqLQrk8Sb7hfXzMvYfRifeVsKoLdSKqvcZsCyoTZc84aec7SH37L6WOhSRmZc1MKT/oNJIw9mtXlrf9RC/GGrPxZHYbH5rLQtxZa6IvKrrsgGCdkjHS5csNEAjesh5X/y+BUK5Phu1hX6jE26rL3dqCr4AtCBXeJB2JV4GDWqDUejYpQvHNi+Q8I8uBL6GIT67waC5FT3E/GkgYeE3UYABkNGkXgnWsam+wBSz+EamUQLEOzgzopMegqjpbYFl6Pd2ne6gLj6DNLAPPeREIJA0pnNmbA8WphwAgidxyVBeVWAdHqrYqOLxqDUtx2v7WNGiYEM/LomCBCLkD5UutImBFtQmCXmcVrCbSbivxFtOSGkmZrnVaIcNPeRO3c7+6KfFr4MnAwSFQQBYdJsW7ZYqTyz1DJoyNIGWJhLunsYWCBQt7j36hFSGdDxgEn7TWnIQyf3z4Y0W9K9Hg9h7YD9d4CqwPcnc3vL59HKmLSaoYy4WAJze/b29PTNz0QgW6LOcJNXl2bqkLh98JJkwTQI6THUz4GQQFi64SJPLg/dQm6LL6lh1lGIpP9pPPDlJn4CqQTi5Wq5VO5eLhkA2HMNVih2EhBYCZTAXsw8AbTrLfzqgX2k21hk1zQXjJBm0FVtQ25fbp8S21YTDFp4HoizrfhTJ6BZPu0nloCIQpQ7GOe8HgfWQHp/zeHQVdMN5dXHPhFylpZInd70wM/0SNRwLeJvbS9Dvjs2J7+sauasO6dcx/Ng0kO9d7eZum3vNoAKnNaIThvuC9lVaUwbiTRpwMijPKdZVlk69tK4S7IOmERIC11wP3uKIYkGOVygWsXnVzk9+cd0GjT0rVhJiOc19ssUxuOcAQUHdq2eUAPKtNucGuPRbk0hQqcwSv26EED5kiC4apN87sJwMIscN5/oiLZMwg+unR1w5gMmrjsT6fOB2605V4q5VNCdWpYPQF6370rs7qvdPcXcN/iHdQipZDe3FpVOtfe3ZT7pRYAX01UVizPnNSlTb0ipfGiWgz81dXAi7RBjR5RQRcet/UP8O6E5BP80dtMDXLdRRQnP+fJ7Dhqu7KYmRW+eWD1Te0dB7jukLKmGZlYo2QNkM9Fy4pZzY6UMkAQpRaI2tyaDtWnMpuQexPVLHp8mm+K2PQRpfV1kHsn32ezzdtLml/Ig6TraZcc6C/I6EAD0X1bNAHY92ig/qPzXhwVPXWaI7Q08p2Y+urOO28l3SIIHkuWhcdy6N+fJSFqvrZfzd9tQUlhwgr6q/1SaybOIgqOP6xG26xcJCvGvHvwRFrTcHVrI1CESujCsTiFWGb55jIv4u3reP3HKJkYXUCwqQ1tIVVZxo92gVHdMCJgkB4GETLQEqloLDSNcRih1mNw6tXJEHR8vi6Mk/BYZx2yYDX+scOGQX+nMQ1Mnso9OrqPRYIHnc9Se3T5ir1Ll+UVV7JfqFW6JyCY00iEsIuGRQq5OYKs6EK+p9YMMRtOlBbICMMJigxyUoIhWabMZreXhWnUS6cQ87MH2Rr2481HnwXLpaNgbaOdcKUnU3N9YqMvSqF/E4HpFgaDMpFmTwIgOQg9vPYpcrMyumOhGMnd0CrxxARV1NDkTqXvWqCFKpTzUd5PjR/D57TQ3+U+bXphMmJmoKEuLLxUkbFbfEu0geJDtYu4J0Dn7tZJDH/RvJBfDhDPMwfL0UodypR+QRWqYSiI0MAJd/1foKEc6KIHIqn0R/Bd7i+ncayIrQJNlmV3ovU65Pjl4td62MHWEPIDKuINxls24mXYxsxT4oNBbjfErv31wVe49j2QO1HEbQRrDSqAG4jL+Et3ngvqcp/CYZUmp25TnBXC1WlbYsJiOhGtjrxGYabxlyte9URwZFSs6UQMVNONDNBG+9OZQG3BuannjjbN0mtFMTXfFEBufPIUroBXJaOUQB7J1BaUUQL0OfubS5zCz3ZA9NFFprANiq80B/5vadZlzZBoCIYf9d0dtmsk6MjfSqNmIyuvwgj29Do3/G1mEOFT/rkHQtEbxLfcqIIh5pRP1S98jY2pCWDvRW8gJ9RoZWTngcgORCDwV1jbDxK5QD9PWv2O/hM9VdZ0LL6UnfDIky3aadilAzM8WflqFA9r8JgTXggiJPiUXpYIYrR7b3kwVPlBbOcAM2B8eZh32cZnAUyB8fuj5en3bWgUfBWI/FgIT7QB95ojvh5D6ZnOSaNy/iAt6BC3ktvmVviwWIjY9TaYsf0g/Y8ZY1eqY6L1nqTQbB5pQGv9n5po11GgPbs7V3uwQQ0ZSAQFyEfqO3Vmm2uhCrGlng56pB0XIqNcUjiTxWXn0sCihNyBW7X1uXkc5U7L3GSZZxND0cDlDzbGAczqsFBmKFsqFQ2BnoD4UiTef8osUTvLCmnyEp2KQD0E1NvHuXA6YFVOLd/I93dilpPPu65S86MTkweL/XbesXongJFnXvJV+Qs7tR47VwvaleMdhCpWbkBa4K52wXfX89HEFNg/Bo9/+e+JLxVNx5yG+AyDv+gv5NsMBoHyjJs8TFVSioTTBXAx0I84SKWsbMcfZC/ksm5NpLht8EXKUXBZQbh1Qx0NZqUmpqWQLFB6VEryWAjFc2q8kMEpIhRtzugQycoz5z/GDqsXVBowS1rnnrZ99ieB8H7rtZvEiSbrD0hhQTZTfwRpgbeTn6svWAw+SIWfu2FHj6/kUrYx/CkhcLKEEPMlYfNNK7q0RXdMuom5cE4H71oJkJW9XKpDSQWNh3fEGgKtnvotxbIssZyfcTq0Vk3KU0R1BMrIzMjhK9CfHczqYyedNWxzxN44SVFJUTXPO06aCE3E2R65Daj0F/j7fWxfiGcFB6wMiAdTdVICg6pE0QPNVkeJfZJcfuBdfHHj6HRnTgUd/7foVCKNE1bYDLMotby9eYJA+y1Yfq1RM5Yd7Wrpgr+fPzDrzp/t/ILHcQyvydMoGubbYkK7aBaA9Ws8mPo9wrA5mcOrMHmvThj0AfEYBYGVfIAGiK0gXqiOtmQJHIWDwF0fa7dxiqsG7qnbNscK0ixS+T7hxQVEQil5ygZTwVfSxKiaQjNlvTkXYExlCwQTBxURjs37sVTCeq2HRE4oQK6Vm3ROmj0ZPEO+KrcsceEG92fPOTNltnko/yxgGYWHQ5cKhDYvyV2OjbErGQyfuvmUtVNL6qAVvpv2hXX9sSoAV8JfakXCLDnY9A6TojOeTYPrXitQHEfu9i6BT3vW8matqMGJxxZNkDmyXulxkEYb2BtxMA9VbJTPlDtQ4whkE6jnh1a/UanO1V5YPUAnN2N6vY1dGH2kRPdZ7jE1KMhhmAoKszinj2OwSKz7dpDS2NJVl177tcMHTbygB/guzbnFc9Ig94atdWJWdcipkWN81jWAWwKVQhuRfCOuSGYHVauYxPt6xgvV3F7EmK2d8dGkx2Y/n+uRC1+hu4qPAk7+x5So2Y7GOUI7z6U0pRnck8+q9ONb+quGcXacROzWK0S6O0oGKii6tj0VrQLjv0ihxkXK04S3buqCGBvd4/LiNYRBDeZgJ3k1NHAZAK2Axkx/5sbBeNakuNsJVEvxbHtl0sk6EIB7kCF+HeFgexq4Orl7lAqXoRKYUS3r2vBhxOfhYyGL5uW+Sp8/gwzN3Btp9+iCUrtMjrGJYrxs0tmE6fqdnzvnLhVbLjvLanvH4H3shm/4vO0B0TkTyPvSCeGcC7Aif3hGUrphQJK4oTZwGl1BJzPclXsyd1K79BbcddQH0RiKtws+87Y6a+lIFQuBEX0JudMz601ZmWsj0s5aopwtASWiAvMvF2YnbPuZuhVSN3ko5MSLlBJRZQnk/iP+aywob44tsOxJUpImOhd8kED4mfU05HF1k/u1zE5ay2gIeDhxYzGQYqMRnMciopALQS7IqQ7qRYDmlIEkA04IUK7nsCtTFkSACj8jBZVsdB1/xcsoDlBQLqkMw9+/utRGlksHJ7haxFZJyQ2AlrJ5kfj0ZBJSm7u9KuXjuj7I7yil5GEuTrcRFVoCgAX49K7WtXoXVf8zVykBz9nI4C/HhUxBCrjlcJdXMrBeY02mKqjSLpQnu2mGr/2FGliX53QXt+aHvaCnEvFGAfOFPckQsFA8clJGQv1z9i7hpKgq0XHmxW290RPs9mXiex1xzW/PgawzKCnZf7t//BpqRlcdfbH+M+JzmKK/tnQBZX4C3G/8bm2gqGy+0F2sNFX0QZxCjehUCWwuBxvjb9BTLyWwAr4x1cGN4Eh3L47JQr5DmtAeY6UcD0oqAQoGc9arm3de32JSVJDtR2tmEq4ZBRNuvKsjsyOg9ncVNaMfrKnVTUBdYaGoKJThd5RaWXZcTq/TEkZNaZiEUnaTmTqvsbl8HV4YN/S4j08HMgEW1RFxmQp9dkcWobUcKekgnb4QtTkwbuUuIjb6LBXZZOCSdY3Y/pTJ60e91yiTBi3gdXlTa+gQt4Q8pP7nerXnVu4eGIyiuQK/rFGtRNhfY03KdUk516G3miAdqFAcb6MHlsi3YhkrESwo8IowRCZkTtINvQL8zvBiD6X9oKHEWfOKWrVQLzyEVFzreRkIu9EEppNg8nKZoLUIuqpmdTrBxACpLLhmhb2zSDUQIA7VxtH+u4xp6e7H6Ql6nDgValRA18ZgxemzPkgxkiwWhCwFMNYcu+HzvxHlx3zOdxzYjknE/zllhjHUfFM5lrQVQXALwvvFGn5eYV6RZwIJE0hUMO0D2Xe+Sy2ygZBER5M6wlm93upa4EQn2XqhPcXFJ83QenLNIMRGyOuJcXrgpGKGKgTRoS/uKjNkgaoiEjrhICax9cl3FtDs8lgiowegpoqKZ0mxhV7iEuO6CMpyqzrf8et+CeyiNyTt7HxfBSEo2zeTOHSTyEXb/DACVH+yez9mIZBVwNfJ6La5zkaBpoWSbyNASKuvaDekVSKODHHEFpefzziOOY9COdx6v3Yj0Zy3wjyudTrs+8Ovot2hGUbg/ExVHalJ/bQ75Qb8cuL4fRQLVE2jAgtWePzcYezx+iCC+FPlAKBuhmDGz/Jl+iwJSQtUaMSGxXeFDEQl7atOgjvHrgxR8S+/VmBPf2QcmdP9icbwGDZJXpW0XpshOKGbuhTBmXRQ7k0KbABGKvt5i10BilNURS4JEyIW9/mxQWNNc0qgFpbacZfdyEx05DgScaopQ7QBtA4iOHZ20AV4+SprDMC5+qYIJTaEz1a8T5mERmmgQu5Juu/Qt4R+j6isyUUygyuSJGd4aRW24aQDW5jcLSonfdOrJQnFGDQM4Tm51Hb4vZWB/GQK0WS8+hsZpTCHCsIoDttAmOX8fCodg/9kJvXs1U22VEUjMKKXXFovuz3rpRciG9ujo9rrIQvMUtArA7wymUvXYmJ5Tio8s+dm0+HdhMsJvbpRRJADdRINPCIZ4sAJAWCf+4/IjCWkP3CI+L0JZIblk9YN0S1QpyWLuUuBOZqpqNVBOtb1vpDzk9rwt55RYI2yzcUZ/5Rnk5F/IqFXf7P9MkZT3d7K5MfFtHScFhB2MWKLWo1IMbk0LEXhRBzYWtCBqomwctBx4itx+2qqMPhq6XrUHXsYmj8iGBxZ46/IH6OU1yzQUBnVUJtmEg45ZuXdkDhJUt3fZyBb2cEaq4+HEVDgwPKdQEMDyUtFHXANA11b8iCUl0i7GD5HkvIGD4dsBSq0/9sK4EaX0+9oiKLC48GK/7W67PA9AHuDVJ/ljkERb5TMMXwHvhfeGdeSXN38C1TduF65LqT/ZfrvCtCIn9N+41ftn9MygtsTDCo7hNQbl1Gzp52hhAGcFJNYG8u7K0NVmWg6Lr27VDz02GAuV2uxaupEsGZPySYrrvy8lNy0SmZDzD8opOpMcsko2dMFcMvVVG64hrQuAeYzN4pdO0muTQl9G8OFvCbHRi1CC7qijwU91Rn10UcDgn/w1Z3mSLNB5EKtCm+AHxCeuB5k8+Dvq0O/enwFgFW7kP/ex4h4jM2it2cS0sI64+FSuvIoBa+UofQfQSDFkbOLtoGriQsNh83t+7CqswLYFvBX1nAbfAZClFWV2KQMGiyYr4ljrUdmc3inoGzPuicjnpJbpNIKzg+1+ydaQmEZa3IngkEUXA1Wr+7rLp9NogjJQEE7HJey9lC0O8YECfBWbz16ol7HqnZTZQa0LjPflF4iB1lyjgDEsstcIi7UyKkg/uvuwXZNzRrL/7Uwc6bhdp6pNArzC47Sd/k2kH3tv8pa5fWN+unpJJuV9dIe5+xY7xKk8RgB0ZsUd3W8AQrsjq9r9NgXtmZf4mrcS0mXVigBQHshc6gjZUNP7luwm97ZJuRTDEmoyuWrwPHpVqtI8NaqesXsAssG2OG8rUYp9qkfrgxxMBWhFPgMsOAisVpBYOlFs1WLuHq1cZQLW/SWhf0H9a1AC6icSoVZxkAQ3j7UygXC3JcFCDuLrJEBbTFNfjMhQf/9VbIocQ2FgiBQSxe9eO/DO2+e47ccZ+el0IyOW/cq/4XsB7xXXtMDhqPhnbAi5dn84fsf9L/m4wCAJKzCER2wg7sVbsLbk9ka7uogqe1slIh9ahK9AtMlZrOO0kiTY/xXdiEbu0uckkA3TsAMHzD23E7oyGT7e00+Z6hbsxYxvH1bg9SiENH3T9kKc7GbAFsocDZhwz7CpkQTOCKIN5yLYZuGQrA9kpQf2pZi80ES77SPi7ex0BFZbSR81UplaueKeRMMY3W+6KkY+3YdmUKCh6fzraLIBov8psUj2N2NrEm3bHFXFVRJnu4Iq4Fh2gRZSR0YsAGaV0ZNT19rXlimQtyRrJa1pPUfsiKjEWb271PoCI2g5c5SB2vH8lim3/xqosEby/KuGmEMSueOdHFwXdDOyUiFgok8NyPHwrDSIi1goWxKaxgO7Pbk81yKoAGx9RCdRKRLEMVDb7YoP1rxAQdhGdkSWy35wUdH8aSLFFdFjt4MDnTMlyOS3OKtgQGA53YWszyn1E0wH0mLB2KO+Ei/cVOMSu1SMXL8F+GofaTs8r40qqQBUIVLGVWxnJtV9wF9cySlhRBlUI7iVoUiJzRYrXCuIacYybDewlYDb09rHo8er5sUSIRYT5J5lqj/4i1PaGmdW4IBywNg2sSlCwLoO64FqFZliTDcNqBtT+aqTmwBrfDUYUDUdPFTYZk26spw5w7IxdSYM7DLXRXyyzGQjHSkTU8G1kh2ZpDxYx2iwrlIdTZND1FLq/XPOJGfZ8GABHyrttIFwL9Muakta4RALvjPfm+gH7KyGQ+2fGlQXo0oXCfm6sU6HYaE7QSUYbACu4NBNAcWFRoziP2qlpRuyyOLp7HWcVa98vH66L1KwTCE5AgXqzfdjjfh42qwcv3dzEMLwoapaxeqOAWGzDatmwFkmTQkntQlePvmuE1lQtzC8hqUmSeG4eLy4vhoIuo4GNM4sRjCU1Eva8zE5cicM1wTT8SQN+Yx34FrgPAsg8bWXPtapNs8SdIGCtYsvijXgvXBdVoMS1t1VFnYF1Rf3MCoomYZQviIrQ1nwQ7QwlU8+yS6PpIUgbJS6KFWmywdlCOaQdylSzAnTvR1+QTRo3N4ASHDVRVFSIfhRHFDEILy/j4feLmDkkuKjhEFDRLZwNs6Z1W7q1ejr71hJgU35ELW5Yw2FVBJEgeaCGIGizhKU0pi+x0CXtB2m0FIPZh5RYJUY/LRoYBBAGepjHA55nXktQiCLxuHmgSdM1uXe0lp9rR0CUUfsGEtsYKKK7InJFKUJS9NHQl1KEWp9FMhYhjUMkqN+TyxtYm5+AJKSJ5NAHAnhxYWAnWJpCput/m7XqbuXaPrFuhFBM0hLfte8GoW4tdMVinpvoVdkaCTZeibaRq1mxoMyfIPLVlqaKRca9RzDVJAcaaSl5QaqD9U0d39QC4ySwgnTdRNW2r5JB17BbgqTxO2RtvA3Dru9lcb+NfqrwvNV0oB+wwmOX/c7a5H4hriTXB94RGXF18HPIE5okDHmmtisv2ZmWBlHQT6E2KRacr+9RPoYDlaxHc9NMFjxCo8vCIwtkYlCiAUNbceUiC+kh4rWJVl1yMHZYMqjtzN74WV183140ktBVlzFjhFqt3OS0MKpZZbGIQXTvF6liGZs4GX9Jnm5/j5NBfxVx1k1Cky03Lq55aI5sRCXccwyaBbNKwL6Sx3gQVzd87+vDVerwbh2Jyo+xUsDMgI1+LfQmtX85gqL9Pxlb9efOry0Eot0+pRqV+atFg+qUdJsmCQ15tWX7i6w0kEXu+V49i8HSaBjQGAiKfpSJXZSQhGpjoSZtC40Al5U1dUopzV5lIOLV0sRpo0sWqW9aUgkAPVFiqOT6TpxRvRDhlJYfRHCysaK9puCmCmA0p9M4hFWjkAqNgUik2IdYUnNvYxsN5CY3TjIdmUbL9lQ0sGQEC8UWL3Ni/RH3/eZEfP6p0W/0I97RIQ+l84ShP5AL10JGO0a354dx0Uhya+o5NAAKx8T0zugiYoXkRjUvyVs29O2CZpWLCJQ5G0YDwZnMYqXNnAw0la41fqJjGTGskuyNtN1cmp4sxbKj77fOIwJjXYKjKGiToidiNwTyRrCaX9RJEmpZJON4kHZsqLFsdBGiwNSAoyWGUUQTVRNN09S8S5SLVDBAr5ykgZjunVpOSFsEEI5tBU5wd69R3bmRxBYtPOH5vT2em4UrAG5bt1sFCgjxvRFMuv5eR0KbvOUtLby6PVBPixAoqcVIGtYrUEs2hKxUqEfutcTCyYqqEKpMq9j55qBFGD1xzYgLQlmGwWDzjcgmIPFcEhih5Ombx7bvFejuRNTShCFcMDaki2yaFuc4EKvBjs/COHQmf/rCstcF/YTiEQPgTg8iLArqusdVRyMD3pAzJidJrLzBOkUGN1/n4RUVyqeeMz+bWeAdKKfnwrt0obgi9sG3mxLK6q2V3bgYnWDoJy+n9sJzQkUSgx56IMTj1cIV6W3eyRZHJ9pi1oxSt9G8cDqdKYtBuu8vTH3aRbVtSma8VanVLiabQiZexKQx+KYOt4nZ/cHLQ4yxxE73Tvhmeb0kJ66+f/K+cNxdJkpZQ3NhtgUSj+ORlVNPtSxAi3zQSv0J7D3X/Y80KE278ZAGw4JtghEeDtzfge1kpJ/tEmV9m7Cxo32oArWBa3t8o1YDdig79Xs0xMu3wwXglNVCxIfh03rZLiMwjHQP6F6VF85cC6o7NmTgYGmqlr6J2qJ1Mn5jeroUg6QK3rCD/2jO70x7QK4pzunPiDMinOpYABB0W4mrOxdtmoeXfsqLZY1TJ4PIitnWRqtdZNdcKAkOg9PMvk6HOCeXbTEaCPW+O3SjFTGxZnOl+ivgZ4M4jTDc/3MZwAZ58JbFV2QHO3B3S8CjG+jj56Og7Su1J4zxUyCYL6jkYO+JMUUoReuC9UYpoR/SkZaEJfkyFwSKuUYYbw4ATTP0XVYuhUU04gaDJCMOPS+QWfhDp7FlYLZN4iVgN+sjqzeVxKre/9C15QmY33DO3jK7kZoI2ogC3TXikHThdNLYnoSvqRIuRVBYKtWuheemgSYRq58lh8BJEQEebF86jyijNSKTBUFKOEgCnn5Ig+TR/u8VV1AOIOq8k70CgNrscgF18k/FulHtSdP+bQUAThJGGzCC6Wb5kJGJbPqJ1Y9KhtjqL0zi474CCoJeyYBekBJJHFkG/w2CWkxO6RER8UKQTAezJ8uvkprWh4hAUwJJRZgZEUFss7d2dSFRAGn00wPdXRPzBdTEqugQKSU52cs7l0CPkybRr1kTX2SrvGRzzfp500sDUO5gLHH0hu3k7gPu+fBIFYgMEmBY/xV4b8RXGDNPPE/4CsBWimgZG+J1M8wq2DqSa/wgwwpropbMtGiwRBhBMijR0UKT5FFz7MTQF0QRo0qdkSJIkWEDr2CEls5NJIjGS+Mm+Q3EmvKBjK4h4/5Tw2QgJMoquxatmxCtU9UxEpUjWUFBi00SnZlUACQAWUUatbREUt8bvvOCBNUgdplQNFk4Vhb+GIlZUdNbgT2wLoLebV9fDBbE74aBaMNxw3vvOuDNQzt7w1lDn4EPe6HXA4EK/a7VSJUvfFdoQ8IU/RYRbNi20SuiE5CVjB5ZYVpwrMFdHG6fDLJJIKSeFuPHdpJy9pmFSFMp4uANm+ZepAV9g5ivNjcWWQGXr/UBsVhXjFxq5U/Y9aqsEUXJS5Rq+Alb/345FSidUOkQ1yiQhMUj/I6NVN22uWs23pekcI1Pj7RujPsdx7kE4Q5cM3tgP00JkfnxO7ZYlhHvwDt2LEO8ecbtW0tdQUXIN77kRH9EC41t+C6uXi0CHY140Jcs12e5hopmyisKrmFVP6X6O8HUGHFJOEh8RU4RSf0hqtIiGJHK4gLZ4kRlA5s0RrwI88bgi4/KnEgSkRFP43azZxoe6AeQqAhVv5rtW2+FXParm4s2cgy2LYnkABCV7NZSxzA5AkpLWAMa7bC2EomxQWUyoelLbSgGB0j4yAuk/RFNTl4tBcjxdsWp6sTcCmOpWpqQfi7gu/t8QH9/xJV4S8nhvqt9X55+3wFTC7RawOLiRKs9CCyuANAfum/LaIbmek9lzjt09TQxOBcxTo9FT39K9eQEZ4kLjiwrkA69qIcYHBszBmUH0nAo7YdZpbEYa4OQk124KApF+c3aRSSWqInT2nUrSsShMDL9t4j+KJoPjrBIxgIxWJhYhuQF7NEqpnMAl4zDfNOklhDcezaYoHGjoWuN/xP93j/x9NNu1pkOW6dfuOBu/qKE2v0YlAN70Vfn3e698AS9VCCMPTFGBkmX6Gb5kg+u7cgwCLr/o1w3yQtyWaUMZ5A9iGE0sJ/mNOk0l6iSQ4gBqXlCVqCHkYNoopjzqm+V09D1gB/pOfs5WxKByDM7xY9hUXKjhURjFYZajYWExBQcqMaI/ESvXZFx8n1Bardb44LzMAgc0VFJCG8kobmncEntiW5ADZEzfl/3bSePqGYivi0HgBr/xvfb1P2LBm4FeNY+d6J/J1sd1KmFAr4KIDJ3WMRQ8XNNeohAvTXDhMBCB/koKCgjNUAa3NVDY98MClJEJMpPUkNofhKgxIKDaa/vlojZ6Fwmto0T99Q2pdGUCZrUxVkFHyEwAtxAA00wSS6KYTe97esUoxeJ01Z2QSTQ5/zZcoHAZKNK7RGnV6UN8RjlNGthCVBKUqPXYm0sziVKg+WN7hb5nz5FOVhJI/j4vn8ORxAnEYvuzovMPvm3aAGb6p+FfgyVRuiHfD58uvg+mLEUUB4A6TnVujAzgP1MDdNu/bZ7CG7tj2G/Y9CGaACm679ocmVRVE1ARUZJgmsfzAaQZj9ClNCMyvWCnrcA49s4r/EyBEp8KXZSwXZsfOWlph7BtQX3cjbv5COjLQmLSplNIV2mEwxYuEArPPZPeP5iCE04qq7pghg2mSAaYAX1tbyWJofe/qG7ZQTLgzng/4lHaO4au7TQu+xUZ3o83fnTjxZDgOj0lIJEiPMiuPnL9wBIU+K0FuXWXmFKAHBH2GZ2tBGTrLDOvtx3yt4diAQlBjkNeTxoMCyGDJAhOl+nnLDptEmrWU3bGylUhRUY7YxqKeEcVt/7d5LAdrWkBDbDhEPzUsFY2DPubtQ3iMHYfuMyvN0mR0jT7dvtMg3UYta67MKMBlRajwhHLGrumcEYGWRVM+YFsmSWyYHwayA24slS0/Z8NbJrnevyTe76035fHvxWBu4yoJtpOy4E+jwfFdkmdSG6/EHKKXDX8i3lhmSCCwdByvGnYTWHac191ncVbTZxBE3nIMk6JxNzVfXmlSJIOXXCMcq0FcrFLptihV1jlQ78TjBh6URqYyH0eYpGP6nJaEfNGJTMArOZhBfCMQ7Eua9APRQ5ishIfmT2q2dLY9lYNbLR0DdTX7CzTPZNmQGb98aUAFGJM3Z8Wzl8aqkr5n6Xfr2XGccWAdoXXNu65BI9QL/M6t3gWWYJhIGbJq/IQFsFfIboIDKmC/N1Om3gZiFoOV1sXjQg3MseKPqLAHUPgWEZlNVCNxLQiRkgaW0wIHUhYR9h3TYQkyyMoNmjIWFoppeJSWJqvEYRv9NOrRt0XLTotQmJA2xYF6g1MvaLqeej6NvVDKF8V8KNkc0OmIJI3qMKHY0ylZ8YiY9PCtyb65ejs0Kda5FLbzid6E9/AQyhkvbiyYvC4Tr8/eL99HjSAmfsvrEfOUDl2yIxGNcseg5sdWjZfY70YLHN9A1AOmJIvHw5hTBujMY0dR6WrAKltLQ4EBONiLlTbDWTJBkXdTUf75yNuMAIdpAMkfM0lE0lFKN1cBlJGNmMjCO3ySxx+qYCyYYuCAqVEwPnuDh5KBdV0+ZKoiCERbtYr4yX6XNNbw8oDcKoI1FRPWE04PxeAT9c/OqQHu7h0onndd5bVLxDPSLckcilkAczAJQAgIwEo5Pd86YWysFk+o3FfSHTGTpRa/KfGsQmKScJujUFJlKY8/4edNJqu0FzUoIXbqzTWaSmcUPKqcWx2Oy894YSpAgjg2bGxbkVCG2oJuqU2uA+03m+xngXwBw9IDaqKu6ltPo3OHk9NGyPxlBDp/JtJn0YRA8L9HJCQaDof8Iu9lkmim7IEenwjrZ3qcMcak//bd/ORTYvObBfFCeuv81ogKZCIbjIALINAuJf03ggy89I+YATwJAVtqmNP/cILhKD8RubDF7Kl9JMi/PqPxl6KVDWfPReYQRsV8DBTwk5fdU9Sh6x14n1hnUlYR/3LmSjCVYhA8bgWv9SYfP9ontIJ+XNfC3DOG5oBh+B1hXVvKh9drw/LwqsvOhuNzHyiRHDfqLFcpu+IgKCwIzdLNwXJ1753vp95rvPtJr+/u2fkT6TVIfM2FXoGzUiwr0DIgzEMEU/fTEYHRREtp0c4RZXwZWvthyMMbiF1Iu+hfTsQeJI1ZCJ99ck1zTYPtoqRmf4oL93eMbebA5BM5XLuCa9q8G72GhWU6Psb7FKpRGAxScP3l3AHavXzUIbRtGaUkc9kZaN9yPCwksbfayyR9M4vUDPkemxE3mzK2IDKrmJYUqV7jSjnjilTTwDA8Xy02ZfnwQI9Hcf4Hwu7l459Z813EGbfzMgtML9bZsLcvHnMmc/lQsS0p5vsn9mhDbLb0xmC4eGXUuDgBQhI5Vyg5L9+H6Gvgkv0CIjdFdLvGOfntkAbSRwhrX319AiHCNGG5y2xOkbD5IhBHRjF5Ygas+x2POAeFj5YYsYsAQSTGGXO0daSnQV3S49lQIGQ3JYwOmu9ThRwh52Fk1QetsHyYjrD+jv/5dr9/UvuWpkQiHNHdvzJpO+Ii+Zv7a2Vb5O1A6v8vasUuj1qrGLi7UXLQQq+mT/FcBM0aElMNR9wOzg6fFEnYBys3odxM3ygEUGBKpD95S6GbfB7WkActIAaPtq/gRxYnEvneq4lAiqKJIA4qqTtzb/FZVmODR1HdadAje4CkhwC8kdvG3rD8b90YY++ljIqjIdlE0QeLER0yjyE7ugUDntKAoHPmyoJ1UkOk1TGuA5lXhJF9ozJZIQT0bFLLzrHXU5lrTk/s9TBXq7GbCQioCQ86fIIKQO7Rdft+7eu+CRyzyhpNGktsPr1pFAlyi24etWbx0eYaLAzQNjtG0TO/p7BD3ziBiN0E3ZnaIoYr15VkTwPlhRtSGOkgc1tuJA1s0sAVN+SByFe2kv0SiMUJBZV1CN0zAFg9uo7zE7dwvsTHYeRPWDewasXFRKP0Sjya69Q5ud1/igk7CbJHUxtUC8Tllx0oAnTmYPrQS7J3Rhv5nizXCGt8Cd048pZSZbq5ERnDBiEP/O1ogEYtFDUULucAbZvmbyRgG6qIJLftJq2vBFJwbq9WyO/sLc8OiLE1CfMdGZPg3Rj4pfigaO2RKnN/ppTry4wmV8msVQILj3k0/G9Dd6iqJUgj+NvtuAV0GEJnl2sEwQ/VWCk6AVJvmgJ8Op4KykSWvgEhyuCg5lk27yi7TklfagN12RJ9SwaMQ0NCV7d1l0d158SXWhH+mq/BXZEkBrXsB7cRUsJnnAjGD0ShmN42gy2M7QRZNA+FbUNIzrbyVHfswUQIFA/QS/gy8nNIybEAjmclgbSRw3UbFGgg3Hl+Bz8iBcxCg7mkhNctrArIva0bjPa7J9gjgJvaC9caOE5nvRBmsVJakVbKzwEn1CRPP5yVnlzNVqrsmKcxTECEIFshs2CsC8YJmkohs18MvwrdlVLKPPmsIcAWC/nOvClXlxI287MSemzdlP0MMCgcjRdaRPu4Cmq7RuLiFeLN8uFO6GEfcPoHG/ID/PDvcviSGgp1Qdjslwt/NnhQwFqsahnziv0uDXk95nbTPgeDX8nbOcNxrQtZTsVnt68bjJzE/4UV3cvytQtHQxlhoNC0Kc/F6otVZZu5XXKCTmFx85+o1qLcSfTxzcodq7kCZYklYPj0iaiZYVie4cDspZyAt4v3hqVbv26311jPBJ13koECze083f6HOvpMH3oi9k+FLDScYFbeJpk6BKAKICQmUDVERnl19mcdAYoKTdPc+9zsUx3dmF59RqrjgdzEI9mHrYUBLEQaarQQ9Mz0/Tm+kx+5p72Aqa+5vrBjq9p1tsXLAgZGvY4tmFCZ2rg35PB0SKxcWrkCA0twkunERwdcxPQW2C48+FmWe2VQZxDnozcWFEKyo32mg4k4X3WPtefjERZdX0NVWjzIy1UXtR27Fzm9/T6n37heghGcUg1Jq4EO77zlD9O8F2XxaCLQIClBtSbMT+Ff+zF7nK0kUAFRDK1S66g9jzJAvoiQA9A2gWAm6n1BSfTFqPJCjSdl2A8QVOP1LUVOYyOtF9sxNqFIQwkwZqhiDknLeSZBAEg32rSZZFGKo2ROfpYlUTMI8QBQOBNOJqpdC/C1rePoOq7XSTsiSOXa5blxoxEgjZwaE2Yuj5gxYHdjEL2K+nttCG0oKI5mxDVqtUc4k3kdeae95hcoC+Qe1ruRTc74qQuXcA0382plkmbKGgWTsCFiS30yOpr9MKqjS1DYBrvUIvp7ntXXDcRBiOftHDnpvsqWzEhw4eIpkV9+K3p59Yh6SBvr1S/g4nxcGeC4ItRihkhsEQxE6Yrr8eTnMR8Fqm5Li5OwuJEcNlf/eBc3zWsVLVESdrgKcNHCqNX0QMzqLH3UH0OBmlI4A1AphTzs3UT0bwp9Jkq/tpq1pXgic7DH//JphtJ6Ted10R0TRtTe2pteHa3kU0L+P0u4+N+zIk2iyO4qySIXtocpk9IFiHjZ0ArSdBON6WsdpTtEtbnLOcpSlUYXENuAq27yyYNta1q4YE5oQnHakZOTovfPLlfkXbKucbNJyWbD9NiL03xNVrICJeLhAoieA8frbcOcjqepudWHesUB9Nb1QTyYhmdcmmfclCfNPyJvUg1l3hiXb+1Msb8wzvafcOYz9TflIF+lPtUWSouH45fMzr3wsCq87GglvG9SqzKLKhENg/Ic8PJQNkPBDctTb8KosZaTcx9FItlKRDMO16z4xTEedI/PROA8AndoWvBrj7HyOl04zLgYc7++YR7tYUzUpJNLCbQZLe3HpTC5Y1ILqXjbmmSz4pInR1yFojUEK2QQsFlFiwnxqE3Y9l9x3QfG5CMlRpdxOWcpk230IAyO3iXLb+tTKbQvA25T6J/uRNoZ8rAMK6xfNwIzygsH5ZvdKO4lrg2VV7uJhgu2s0jPvplsw5Ih0oBIojgEPRJrLxpvKHpi0M4y4BTtw3/kBuuub9I5ofI/0hhWrW3DL2WgiFvi+ATkE/rF4dvrAz8kUYDsqWACh9poEm3cbRL0hHpR/ctdmEaMBArQ60lT/74KAXR9+/uyL/hxfUpkQNsAJF85zWQ/8xN38uoZyPZL/Ko2+LxLk6TePeT3xo81fhzSYWVjvvdUIEYntvihjKH5p0jG6cdNQDYb4NAzFyYitbGmL7T40MOA3HqpbkZvpWuIBNZTHUA6MtUICwhaEn+dCBDzmiD4Y04OyLrYmi+g4aSWGiJmZi2gD24srBSod2EaH0BSOH6R5WJ4YmCWfi6NxNcsDI6N3E/FeCYhIDxYxd2DB5saLKps5gPOK18jLFvQCd+43t2aBXglqvJcrd3++GslZq6eIcPv5JEuP+JgOqPSMlXZkdLCQi2SiNQrn8/ZVA5BSKDw2QcsQSmutHB4lDN9GQEqnw4BpDOZoear5g5/Gj5IPfHzwJVr5ZyX4ueeN+GdCTgkHJ0pA2qaKOi0reJGyg0qUj2aOQo3O2tvrWwcbGzo142Gh1wFQmRhBVa/1cCdSsqfMi6W6naCA6CVs+iMr4Uo0qrstwv26iYKox5vvPgv7L7N0wA8DiJlLLApbgWNwFtSY0ndRbjCDCYF6Q/YMRpujz/tsgTkpDqfjbGVVTDI0FKQQkkgPrMEntNq7wur9/cX0X89upBW2wttlqNNMyBA6Vpr3GigSFAL0smFlIVbyNb5ikkkAujoapeLhSNpEcX8b8W/FpBNPjaYUvGqxhHYGVbxTUYw5KqmqMEYkFuUiYB6eSSNkSgEpOIgvKFsc/LYTN780Y2HfWpBOu+Dbzvrn/y70z4z03tIYZ0InpEo1SirDK6QTa07uTxd2b1nkkBIulq54XMBv0EAVOAypWKN+NI4Nt4gnWkrzwBGsm9pvUSQI9Z+05HTgqOgkwmqhN1RAmmsmx2SGSi042RATRLwAO9EJRcfzP0jds/Zg3w2SzA7bB+cLUjliCXHguOVSKt5YUxYfdi67FYhxrhNf2/yzGPN82sBcEt5r0amUpTekvz4/rQrr24Gfc/vpgCIb0ELJNEkkvJ2rcZOnCsoDKGCh/kPaGgxze/RT737w13QvEIVsQxAGi2SEbPZqgIjAISU+ZhtMQR96Cvuri+UKiuoDeScGMy7QvkxjGGicXF1E1u2+YFIwMbR3X5Ce/86ejG6qgGbbgedAKE2bECzUT3QYjSFHesqAJk0JaJ4EK4CmfjXyn27AuhKRIYB3ruKXlZyk520JYzbYL2TnA3ULjrtDv4x5WCQp3XzZJZMsc2gBQsFpBn3WBhUOGMq0L2MkofQQiDQbNV2kclAMpQIOCwphOwUuRDmk4VhpKYPGvEP5MgMMmUeisbzd22bzgi8aMbZNzCTKLxNNeJsO98K5rEDQuAQQUe++Layh211SRzttCUrlgHR/FjUJHOaKNIvtB7mIvJAE5o9MYvJQc9h/qr+RJokd7T+sOgKvvsAWBNZSfvikcC+hT/9Gd5v11ZNWDHLjk8/EQaOIbpUFFR8JV0EQ8E4O0fxDfKb9+Sw8heBsPaPJoTB/8W5ZD0cPBy01ut9KCZlSnZrJLVpm6PxlnN2AVkYm7it32HUKx2++UsK+r5QP9TlcszB6Jm4uQinc2zIb2MshNWwK60vpOK8v484ZpFTw2KE+J5C1Pb60GLuzioHl7scMi5+4ot2XwjVInTtVFNq42ecUkhmXoT5VAm9UK3ChO87qc1fkiMSCBgOBSQA50Jo3F1JJwmgokwhCRpFRwWhf6bObBFWVAZgMf5UwMWFKjorQdNjkpxNAfwQXgYUyztpiJbaahuJ3aFQBJoSYMr4W8M5R3EIzA29Bt2vTtLOCCLrqopsSD75vDYIjIlIuT95c9Fco1o4QzzDEKq92C0g9epp8tTrEseGEo8av1HPcF9YXoJMoAKJ/PF75OqT2L2A0denUzDMTdV1MFvGSUXsSuGqYnMncVBlPT+E3PxrE7TN+ctgcVKGb6ZttGEnCPxDS4xYc8u6rWQpg2H28kZWvGBU2zyyP6ZAccIgJ93eLIBN0GmQGosa2yqs/0XA3TqosyKdFjZWQT0bUvfUs9ndXCuq9iV7G2liASNSYQIqwwL231RV7km1ekDIDMvAIZmYFcmUBm+iKu+H1a+IOWBaTeEO5GLfILNW14gEMgywGKihQqRq6nNVM2+ONkODOLMVz7Ozpo2rtkxlWjGIMj447+GMHPZ0yb8WkDtBEGyVTTVDNntFFcL4sSKr1x1Uo2IEUEk/l7YvF9jIetkKgZwWY/MHM1dSd4sQ/H28S6Y0WfEcD0cnZDjpp68I20wCg6Q7NGxFurforqghN9vLlQLW+u35oMj2k4968s5MryhJrCk8obE/3uA91M+rCbpfFnsXOnq1aKpCCZuKgs2tXPBiiw2S2B/nlgkaSIKLXq/lFd/TQknnabJs04+oXO7PuxQD0EmwmxiZPvkskNejCv/zh7VOpBbWtsEMREpxSSJj3QxmiYcwFLoOc4mj6+lXUBlDelFMXoe1Cm9X+OfnSppdPb7fp/LBoa4SQ6tWRLCySnHNEAfy1B33bx9mruRfJYPO3QDz2/8pJ8iCae+na4p32Lcg4diRho29fvH2lYxQa13EEFJFeNNkQFWeMgW/mUHvK4eUWuJFc5iE7C1wkjeNUDHkJ1ZAMGMMOAeUsdNzv7XCreCctnxdVoXZuPsgMkxdHZfgFbEqCS7mQM1W64LKoN4tVNqCSbJPoNdcYSnB3XMRkT/QZbpxCaBBwib6sN7kkxzkqckvs5p2Dh2gtbK68ga0dqn3uv5rrSYvGeee0LU5CWCRM3BsIO+5dff2r/uiNs6Sdjp5vX1v4BAtd8XI2/0o5SstLcRCSY4qw5F61g6ybuKYo4adGqQzMXZ/OGeKE/mJ1IFB3VoxbX/R12DRq7o4RoKIQvEbDSxoqndGQbsCaUjXgMic1uG88TncKobTOQBDC2MkgxEHQHRWyCzLCam/A2TsbIxGw27H53f4Nhrl61vbuV/o1s82AOjcjwLRf+WB8I8/2LbMxldKFVF5EBcbWdRQSx0OEpOdQtASBom5KSpCWtGRsVIYjLm3kqvatx2YRxw70hNQhzm1rCGqY7LehoRMDIbOcTjfpJicUMEGDYoxhqdo/61XpCRpPdQHX4OKAYuThH08ruUnYHjZIn+sPeBOMKk4NPI8LmVffUGI21aIBV3dHcJ10eRIkSXKMtywchaiW4tPZl6HwZ1lF6jjxFyW0ovnS1lxGGln+4gJJwFzq1xFt6P3f3oonkUIEIbytHtyqNBU2ggLULN4gMfl0XDvc05UdQdmbvsKYWVKwHQJjXFc3mD61JiYt40ughZGc3bppgfKmYj3WoidApDb3YvejT4CEGXp3UQgE6dtrAJYB1gU09wXFPipUkNbKvzc5XN8Ex3q2RMtauISamMIJHs8ZoSI9qU48Ros6c26ffdSzQLWahGP+1Xf6UBiYKRqS0+zRvqwebSGBQtmSBaMuhEq1O1kgFIyOyh2UvGGvXr0O8rWQ9uvNvA7c8s6Mo6dzE1vCHpjEYlIrlbGiENoAwDVYhUeWcdYOJ63ZM2Qeg1sEnOwsNmMFwWeYAOrqKeqDnrluoAWyMCDaiufKgs33Llr0QwKs77khvPdXsCgF3yA6Yi0m8fFKv91HQ94rgvfZZ22WO/SsLtcE3zc8TptZvqzemRXsYuyuTkWoHMSBwhQVIQ9ilner6UtYdxEgs1bnJA6351K9QmT1G0kC6SWH2jMSL6CFtsO5UBJsS3++SPdxNQuCWSPFvyfqwtINvje32Ica2M/vqwSI5d4QMxYXipWcj2wBwsXBAjwy4Ikm557O3VjqkdplanNqaRhLBSVGi0nem7EEu9jPIgSsJLQQH5xquKvVI89T9Ouvd01GjtF3+Y7NLUiMiCFsg3HUbGNc/7gth0U+R9R4CaFvMlBV7+LQ9siN5ZBPTmAYTN0XFXC5YrW8AbZAQzcYJTIBu4SPa499NYqAoJhg2R4NzgnszxTUrDbOkHbLY0pDzJZ27l9KIj9V9DCuzfaPi6Es8u4qyLb8GDkGv2bDgHRHM5Xg1RnzoJ/WPvKurM0JKy8Ao+bGgzs5qJIuK1LUIvGZr/Z8YjfJJMUpSoECi1rxgZzV3FBDJwC1mpb9DP28ywc3cBXBJGFLxY5JKssVZgBzMHtJ/aC6DbkoSP6QjdQN69DnKTAwrWgnEfff3WEu2MBXOWYrZ7M/y1JT5a5YQjjRV1ATa2KUEiyC99VR2IxkUzWd0JRkieGFoONEP6jmwoMvsULkuUdRiBAevpk9DKWbkGUOcmIA2saJf8EPsutvVwYlydTKYlIPz0OCqPRm3wy2OMnCbu9umlhYFR+ynePmh/IRt7OqUgWjt/DLckBrt0BSCacoWvgJjYNcL2WdpuVfUPi0WOF6HS14XdubUSTyKSgJ6RUhlSvFIwx5GCYU+VZE9UZuGQ0taSRxkKEvYjNbsJrk1adjrZR6CxTUiZ97ONRWbpC5Mrd34ajWsH3a0nFLe/lMVORBcxOPNUYCQWs6fHSDkNQR/Fqs6+EWvG2Zm+38Y1JC2s9FEhLv/i7PmSLZutoFYOzom4pASGAoSjzNRMpbJkew5rV01vugmTi9eK+qqGT3QPOnHZqoThLP/G46XBWhhhkhERKu1o/1if05sxyFw0aUBThjGKpVSeTnbDaVSe0qcsjHNzNkRp1IlPHAT5Lth1aUOyBj74ttn2t+1DbdqNZWmiW1jd8me5pfieJeD3siqeM2g6h737VDXvko2GDQpGfQ/1rDyitbFL5im5KqL8/uhyqdQeKoutmTWIkJKP9We0uCTJej9i2pAK/Q2c2ksfD6ihTC1qRiwc75e+WRG6w4p5+BwnTEmZExoa4Ko4BWim0iOpOZPFfpbDiyKEQnEwchZVHotBo4gG7XkEVJRjFm6az8GTQ7PKQzuPWr8TkBGeUghNOm0OYMzKZWtLDKsg4zEGJYJp35qZGwToGOoDbXc5iuQpRkAtptRMKqVLGSzdjLZ4R51ESFwt9dlo7mmJa12SoZgGkOJCQWAjktX1XSQ+vDw9GS1A0qCgaOk1WUk9aVjVrIV+ggrdpfgO3QHpCctGQK68OBzIw8rFqRSMkIUPYy3Jx1An3F7py5k9HbYuA33gewY/TFZMahd4soxmmZXSAyJ3lrCeek9CLXxtwHthLgt2tnOoyT0WkoN79qcXsgGUotZjaQnXd+C/gc7D4CbZhrcrkqhPY/wODnqRQQTQFYndjzqWjEqTdN/OPNwEh/cmoKisU+CicqdmLl8ZQDtrxiHh7qmlOhj2QPFqic6C2bJxgQx3Si32AFYXPT2FFlK04cIBZQuYQKh8EZOWH1vBhkxFr8aPhNVa6z1ariNGGKUKw6/AZkHKo8spKVdha+X6cqK7Vr3tyK7pK0RCt357JLpBSKqbBuXrQOYj6j3xZORd3aGoO00yGlJF1/XG+9mTDVuxJY0ANijobQYlojIGpP+AyEu+CpLdvTYSBlEVyB4zLqVIzR7xZO0yMJTjr9gB2At5JSI0fYtedlbjwBirB5Q46+JpFIb3p5W+qvLVKjM6wIec+Iiq3W36NyNOXVJmFQ3DrDiiEA2GhjyZA5CkG3LmTvymmLjUHATKPqhS5gxyEyH1Sd75kkDrpcTxzhUmpzRPqQQxE1uWJaOCFhUcdP2LnqXTOna0zTcSiWLYpANGKstp/LhwSRz7Zs3j2dyznMiuz6O7LByjEio6faNmoPJK/smOVY30mZfUwdMmRCN7FZ5jgzsVOyepqOOupDOUdzJ3TY1zUTY6oyjnGhiCB8+ZlzoIhAtYHs8TPtp4FoobiW0xOFtraeNcrF9X6LuyQOWVnzlBvXdvSsb1vtpWESnL5MFctXLKOBuIoHeRERz+n0/eJKPI1vqCWqBUzy02bmDzKHsRFsVldtUChhLaHw0CSTA1TdHtTMj/Q1k12GaJRsFYqKqkT0sBOOIVf7iwhmRDTKDsDZ7Ib2uaXjQG9LDzvUfXNmKEZ6MDgy7IhrPwBZWvSymny61kfLHszqRGdUNGlAzYW8rmxgeDdtmkgWGVCUpAjZCCsSqvVppDJVAt/fb4c7ObT0r6ZGsY61iSAZQBSrD14t6lBIlASfWhXIYmxQQx6oT06TdVDnU/BKQEVwfF6pRTd1wHEpXgMqDgRijEMbhWHqjnI7idKyhUzYzc6vXVPBiaVThQiPm3J1oa+4u9gM7VYG4NLCwDDXGVSnXLuz8H6P1CWVy6E4ZbD/oFY1uXnj+QYRNouHNcykBFctBdZWpGYe1el0H+MaWXCi2566jkxOJ2V8GPPe6jAA4XyQ250y1TZ4cuJyZbwcrv03kZ7Qk/5KUFv9uvOsOeLSoEQnnovQLDPWGLTYnrMGoSB02lcHsxhBhSSC2BPL4oOAW6Qn9SSdGGrEJJeBN46bwKLrCroPAiY4Zs0HWwmGU2vQZPdph1XCAorMYtRiC9+fVHekLptUs+orYpBPjKTfQAwBfciO/diSwFoPbgIyp0uCG+yA9uM4dKVAN2nDlR+iPjvH06YZUJiZj4SOYp5Yt/LOlgXShop9iW01jrupItoCQknD24xgaozvjtBxs2AvfM0SssyezG8J7OufNAo3a1oI7KPfMtglEAi8hkDdBzAUaoWuKkZwsf+C6uHuTnvNNlxX7mxLSjycZhVMtmXRi+I4iaWfqxDKrWcdCocFdxxlZa6v8Xpk20IvqImK5K6Z2vWT6xoAmCYsI2svG5i21IOracPIgKwqdhb8qaln0hBhGp5uiSRZCWynmJRUuo6rQSPVSdDpTGSiXIte1SggEwReaQmbcP19WGjigDe/of5qjmXKv2ZZnswiSsCB0IiZ3X6R4xsbVzZ1EiFzWDue7Qhpp75l4HI0uK0DKFOmrcCkklGPj3XsO7VA4kD01raw1FpGTsXx1w4d0K5mja05T/nNp0+O6BbdtzM1IOD3dpbimLfsY4wS4FDEIGIegaAQfQUQrlAvk641vB9v0pZJZgvxSHyq0XmlzlBvK45YGrZ/cbwpzvWggs2+Xz+22o0ib+PKDOS6XaUScboDbHYMaEdA+TZUuTSylFWgcnVdaCEN3nL7RaJY5UOkKktqcGkADa9gUJgkDaGR7EAQmUx8kY/8VnWCmYX9FA6aYnUl3Z5f8/WfY5hkI3QefACm7eU21/olUxPg9QX0UXJRjl7B1xCIjDvrh4XBTNwB2U+u9Acwpti26DfCkdVUXsGb0GEmBqiGbxCOaYY8EwQhyCkFSqiFICbXaNScvZ+FqUnbhlTwtOj9n4JAfD2Eh0xGWhlIFy9DPBpC7k06mXTH4K6xYp24VCGDFNtx7pw7TmGQElh0U2WM7fzadRC/JOVlWAy1/ROfizwgq1QbNw+9Z0NSBVnujbGv24Lqvfhr6d6IOegPhJYXE0S8X/iEHmtSFAwb6m2o0cCksEuvjI05MhtWTUQsdm31Gp2/kWQmckTElnsZ5qhR3IUJ0LAbp2O3OmiZjGIYDjXwRowLqRS5PIE4KiEMPHkDOG9VNK83A6uBXsVsE6bWEWjAWgYH6WFPN7MAuYXkPqVZBQsxlA8nSBkcF9wAZLxDxUlmS+Xt432NEgAJFGSSDYSQAVHXSAGehoAUsfleaZEqhn08PtJXpbARZPzStXrWjMAup2czYqEGcBiZGwinNmdCAYzVb2MWkBG//npCUc8nWdNfkauGNKya1iw2l6TWQ8RawKqfj4ydIhdMwWSEEimeOn4ah/g+wH+H9zeHThHaEGYfmrA2dZSg2Ga2PLZJfK/2n36mj6w4y9wZHG0shkk46FdZ954r0H+Prez+AlgWuQBOGFDzCFDBaOk6CMP3HVaP6Gf1oHIAV0mTEpCe7D/5j3qo9DSwRoOe0GV4heMuxSXI8karLT+PlabxHsB7oFVpsVlRg8E9Gp2UDQS/YqhWDEoTZYOHg4gDCctdVLwscHlLqJ+ymuZ4c8q26GEv2nyKt6O5vJarKD8Srt4Y1NJucBoLlrOSA8Jut3sW6V6eZvvsSNM4a6GXUtRzu2aHOHRY6ICSdhBZCDGSXRkToM1tbAhs6R/QEGDfWhTibXhPT1QcyHREV0axU5dXJJhv1nwhrWFml0YWQmRXrVRqnFsFaCQ5FqF0rPVWmdPHnQifDyOIzqwtSQkM22P0Ki2fYsMpvtcE0GSuU2BXo1fjkOIAsmYpH8161M6YuHsXn+qwOSYk7tWMU2N2eLqIuOUkhINHutTkXOypmqZOasq0CeciamPcqzph8UUAG9muR2pFP56nsYPQ7jhJmMcPUp0a58OaxCS8gLBKujrUqEDvJ1U0iMimC0AyAYJ5KUUuhyovxIezOFyjpSnTS5FElN1XVHRKGJtelGQjZrY2IaRkJYOKzvWl6ynFs0IqP+oavTSFpHlLHmHJ5nKZAY5Dtt4D5Ohqb4JRdlSzD7dyeVl2GVg8ARTKrddp9ljjqG2LHaq+23ItqGkOpUhscC4mr1R5QI0iBOzaHJg6i4dvceiFfZQ3rvjQcSKUxeQKXEjDyGNy34FIUMpWeliqG4JtqRKUIxIR1pIzprEKyRfBsA24ywdPAxMdkXxZDEYX7TQMMGSJ3JBeUL2jiBFZMa0Rij3ZqSJiiVU/lykzago6D5pQoFGqxiWf7CLiBmtQBu7Sf0sc4+H1qA4WW0oQRXv3n/hyQkXESvXyTgMwbRmyapgCPDmjZUUMt+lmmnzT7l9ve3TVCs/7usdD0jULuF9epON1Sn+BFGVMbbJ6wUBZHZ2+YFNONSWkcjuELioCcpNEOn4Of1uYEK8SfN+jLtXUjjGChmqmwdqaXYdl2YlvudSqSgnvM5dAlmue1HtK9F1aAUiJXeKbCiqCj4RONqXQ1d2oyEXaGim52O0QYje/CindHWcAB6Wke7Mb5S0sS70hYUzXI1IKa/UvbuQKZedX2lKQo6MgIgoyen0xQF5pIMu4bZPOYMT+Gq6EaJXn/cNMNy6E73w7NG+IN914Oc3HsgIfUazJyB7enzd7H3DOqj0yOR7IBTzjci76208Dk94CPWSO7n1V4nxBIsRvsZoDsf9FyCu67HXlNPYLg243oDf4b3GsmBosK5zckV4edOjIJ9ND0RT+9VBx21ArsRAk+Fe+YZjHpuoMpmGlxBmXvtupim83rfloUtOBox/7gEBQ5+L18kZIGwMiyh6sRLzPa8u6ZA07CgDt5yLnL7pK1wLg3D/UhQYZqH1avmihr0itlaT6qXaYYpWkOGGBhWb1kW/RzAKgTK+fGYnC+yQ6Ot8p5NZCC5Au3iy5ask9V1LnDFgTItBy4Q9uxFY9KpJBV5QmSYg+Grd12fnussZiWdHhFGikNbHA8x3oZuvgVKA7u/hzhVar51jRety3wCvGP9l0Ch+tG6k1NcdGSaV8QLVExyBUKOhIKJ6nEeafKIXhsYbh5Q3AZQYQBtpLLqC6/2hR2kn0UAmAhWy2m/hBk/wWbsFzBjXlCsz7LZ45lalbJ0RwnDfqccj/IH4VjTcwWOMeacdo5Vlavi6TBy7l6pUm5Q1NYrDXm7JKDGG18CLg+1JMFtOE0uLyaZzqg5ulGTsULrsb6tIOl/xhgBHdMPacv6MNRPMzQ9SUffNOws/ODtS8NlylOMSgK06e0f6Qgyyx6BK0ru0EcPabUyoydo+Rh19o43hiqNEhG7xjn7XkroPNpkt6IjI4hk/69i6L86Vep2jw2FFiFnhbce7BEKg7MVr3GjmQFUCzD/rLEMe0NK8r5uIasEOit5fh2JKmMBzSRt9CYpsURsw3MkmMm1lOjzFhgsBrnXnBMcmVI7dl0kUzJ06EhZEtixFDoVdr4SHFanWyYB5o41SjtakiPwKE4CfQNEFq0TQYaiyJa6waHUmqPwKrhBYWDWribuJw5le7TSIiaNeqp6AJZS9zrMpD1iXQGwp52V5D8mM7meKTAMFPYKcbKZJufgMs9Cadmdup2xo8PaC6GPHBBylW9UqgavmjlR7BGd2GL3LvixNkZCpsdpMVlTZhmf7B8zuLUjgC9mnGYBC4NxNpltKU5iGB+oWbN4xpKo/FcJxXRMKhhYF7y8gIN+aLUm2bzNUDwctzKDDTT7b4YOukpr/sujnzSNY6Gj04VDz8P7tsAHfNs6lOxtChwNzQAhyCl01FIXWk3Jhsc7Fd5n9DQbDteiOz235yVMAoJQ3meVGwDQi5C3tE3MRP7XgLXwaQMLTnWWgBGBpbp4kP/EbLRlgBEAJzkhvhOH3tlIYlaWzC+E0lwOhJYbT+MNGbvJtS+2/symkgIM2k7hAjawIW4pOiB1F6jWW+uDxVo9VldwnTvZFiGpJiu/eamGKXdDrjsFDElUgw4gRTC/jYZdxs4RsSBovMrV1AHE0R3ya5SY4f0mOLU5wthHpHi/XBYN7VRR1IvjpWH6c6f/3nJXUigTnOh0hujRhjcYcsvtRrD7e2Ns8N+3fO7in+X/coF3UpxBMlpOUy6jSKXt8fUtgsDN+gTYVKrOOiTKjT3BdlGjsi1Zj8oAy8qQnrabkcTAvIR9RhyvRZ2fwGvztqOatm1y342ajknQUVIAmcJDdRSTHNt/sgqjWMy16hjZGC6mo9y++y2rUmX4fsnQauGI7vMkA2OD0moG+WHuAi5SuxwlurSAbbUWNI7ylkUbURTcsfPuTJ241zUo5qQsIB8IfvFR9l+T9h2rYogmKFvZr+6Ct0rU9MMEMI6vRLkhH7xhkK2SgPkwwF8CSyiHtmUt5KjzwKCdj2qJY17Z6vZyOejiSr1dv9UyEDXxTcs1dvjcGYPuaFoPYel92TWPPelOliYCwDd/E44c0Nm6zzSatDJLLs9LUbbT43FGreWMGknj3Vkljmf0y8k9WBPaxiZ+do5G1BJKXhdGTvlELqoDsjTOkDNaQLlzUypOrJ6beppMBw6PXqqGuWM15euxUKG5V345iyWGU2ONgwD114UJXGCfrMMjA+zAOS1Gwmu0bG0hGn2KtapRdDsunsu0QZiC4cxMypT05k0o+OwkqdJByn0Vju974WvZoFtOpz7bJQDIxmspFPDTq4hPGk3CMkHe3/Z+Mf0mZ15WSOIdVLaTe2JVhcfXKiqKrzPTOzuI5u47bKzzV9+Nm2Q62tB4NgDkPXVBzFolWCZzSD0EyCmi7dWI8do9pFsBeJ+gZLmqH2XDaEqx7Flc+MvUCqUJ6EsNlDKTGXunWsDOpr6utwTI49tF6g+nk5rkZMtYDGjYjl7RambWkLDZlvzbF3uoAwD6qLi3tVJtvSrSAslrK4oSCu+ymsHRI8mGA2wlTeu7Llyqvjkyk0D1q5qyUkX9hRsmG3mFI1yhCS1YlNsJlULowSqCTSOM4BIMWxos4vxTqx6ZSopxzAtxUms2sSF+9cdch4qR6ybnycnPaA/abmGUFJFWvOC6Wm+9LvmUu5BEiyw/lkwW4LMvq6NvTF5z0q2IOKn75Nh27ELn5Qj9hml1CI0IkJY7mGz7DidCXQmOql0zU0Sx3no5M09DSIYUpSD3iAISJVXR3wNZDXNE99D6rocqMtjOZmihkMUNZsaJcYCNUbBg82k2MA8LVoz1vySVNJ3Nro+IzjWfnnXuDi2ojcR2NCIPF56+vvTSILShtO9bum9RmEoAIT8m641hV2LWQ7m6zTTQw5oIveYb5ZJqmtlY7YBMdV3EB+SBt6qw3Xord4FLnnurV5DLcIUrbSXb0fzUTVS7sTWvZwPd7+n8z78rniz3dCUGFNoO4ev52hN6tCgxiQ1V7DxFOXRdtczSemCdZYy3LjfYF6N45YP060JcXQ5lNgoeYQGoI15D9VI8mG1sSu3ZhqbL+Gj9I6kVMlzaGw6z+8QGak0Mh6Rk+6ollpe0H2xSavWAZqDK9vcmbhY0qYai90ZZ37Mp/stSpxp+/0Ug0eBo9bddkWG6WUVSH1JAnRz2TRBGgUpgzVZtQ7s3s+knkksnDQyUR4VHhzi2bAtBNPONR8pb2mO0ByhaSB4uMbYuLhVe/PwAOXHbCkXhn6p41wn4mpAAaV+ml+1j07JamWX4PIhTrZ9igJjwC5MhMIhajjxwresC+gCzSK2l0nkZN+G4+NjjKpmV4TuJNqlTXkSIunqSU2WH62ukuElt4HbKb0vJhZ2yyNMc1vUnUCSk/Ktk8IEuOWtdVVj6icisMUB6W5Okggr3FrtdN7vCDS0940u5en+rJOzMDRGILX5nY6aRK5WRtKwnuT3EgWdy9WeZYYEZ7cdneLThtGB17RkopY0e1rVye9OhFV2Wwrom2k3BSQWux/oojmxZakLN3PXmJsuN5kgmOWAwpyaAFdn7sJKs6pluWa2PqNoFpdd0dCWrMAeg4SkQRhfr5tBtYRMkSdeeTuHyUDHy2i9KPHo9E2NYQKqkU1VY8CJ5glr/9kmimq2KFSoisKubYNsHDv0o5SiZmNUbI6UwLCPU4zfFR42tZn6oTvpqYoS0BdTi0+/0A7N4ALwfONJdXhWLeIcGjNutXshmrCkghQkwugCXHEvEuTRCVWGHiYGCMrVCHamWj64e7cz5m9e9K4XFTShKvdrdIib1rxOfp/stnY2kvmZv7Jy9bAK7CShRp7ECG6Uo3zJbxiLz9t5WFJ+cJR+/9UOonqw8SBbtjm6n4640jFN9o9ELaK13q8tlOgCOcp1H9S13Df6oPkYsEQVkK6SfWFwt7gjy9J5XSag5LUGwxagWq61+cWi3OVKZGjwrb4YnCbmOJxZjDg7ZXYHmcv25lPtVgmjBab72quTDKOiBZFldjdpAe83eBpuV1vkBT8DtwmNM15/dFkFGrs2hX5WZ2XIcakQDw5t+I9RGsjyNYNqag1UTtUlpMzQ6Rk1za7MtA6cxu9Xo7/xgXaMwiqCiwiTFbuVbTQ3VfT+3U4WT1hfwDWeuoQRk9anpUraXRmjMVUpY6NMQBVCoXjuGmKTioHGRLwYF2+Mf8R9q74iHtsGBeRxXr4Ey9QxLNyIhGLLuhyo8IqauRpuYNHOfrhDklnY6aI9vuLQOVEuTM/KK3vCgGssyZHk6dGNJGUOZ1Q7eUMrFWGWnjFyuwP4z+zVKIUPgTw7L2AxHm5rO0USXGowXWtA02I801EetwtXqdm2PQSna9XRbOQ3yNK59eOi732nwTISWhwax1qQc2MuSPFiFzKUXicJ2FLXFv0HObmYUpuj8d7/S4EOmrzDBQlIGdv/9dZNedBC3RGQAO3PmCqQOu4hPUGV6VCBRmenc6Z584TvsRlg0S8UtJqKE3ERuuejx20kDg5vIx5y85Mq5Nas3fE0foPdt8AhuWh25iKmuEkAornH0MpUApFf3zFwO7xP3Wk/7dUAx1pNmSsS3YFwv1ObE+L0TGwFCr5SOVhCU1FX3r8a8Q7oUz8hOS36UuS1ZIetQMcOtbu5yhZr1qWhaH5hqvOaabVYDiOqbSSYX6g1dTVJLMq61tg8/JhWoXsCyqEkzpKkDPlzj40yqsXNg1DxHN9SDguRpvNk4a9gTcju7w58ILNu4lFwtdrJotqDGQ3xRrxVAfhBudwBDEvjFCVeAooY3TTe3OR0U4Fa/ggHuwSKqSKqCWXMLhSRqA9Tsjd3xBALo/H6cNAGoJ0aGzbVAAecvuBfwfEJqkxcc9hcoQ1p0SGK0aqR0Y9H51RFww4GfWtN6Uj64SOZowGDVNwrJbVLfnrcsvcIkaIkfFqviy681wFMpSkEe2iQ8ewKEKI7H9FRdEKx5MPQpvQ06mfTmON7rpSNC9GVywoidSQ+1hC8CpGlJl4Kg5icz/P9AkwcjQF4gWLPYU3XNOXw3raeDc0SuyokoDTv0Z1o2ohZRyHbZ15e3SxvT8FAS9QgOLLLCC9jWWfvNmt2E/ZpK0OH2U/kGdvmk+wZf/E16P/RipsaAHq3FC8UQX+Xtf8+WbvoZgZs/sJm/ilwJOV/LuDy+OdCDg5wU/do/X4rS6QQTw+3TTXLUNVPgiJnyjB9KTtyYRgPEL5vSstQEPs2WCmUK+ajz1LizKJzShriMRYBDnargsJLDDtP16sWlaRJA6OfYQwcBMVzDrXneGccLH2SU9cV7dUN0WoTXWG6tY41u0Myqct48mb2DxaYByOXb9eY1P5fbwGMFmguMgZNeLMX9ZmkKpLGrccRV0rgs+KHppDBt8qUk+WvLtlvNqBdswpLoA+J1+FrQDdo2jB1hAVvp0ccnIXfbxFtyzQZn4OcMArVO6BZ5cgy0ZaDx2ZARnaB71nPiZkpGqIHDcCBBUBnl+fIYq+uKBZTP5MO0wZxS5gDVo11kBiEcpczZEaNaU18lztVxzye3XQnWMB2DIqaNMYiFll+QZ/Y3K8CgEDPTX8F6173dbHQpmNTheswmZjh1v3USGWnHr8OkgggW7wc/lbEiHEcFwfEs7Wg5Fj3xVGj+39GS2czVrcwRJY2O12/pp8aP5MNtapVaLlc0XecCaoSldawS5j9YCUESRHOVoiUJJJUC0e4tfmDvD0cSAq3dBj3b8SpJQ4VSN0JA6sLigPcnl7lR4zmsf39HxQLJM3Yz8fdoLxMRSlAUF8K83gyDdw7JH+RHCNZlKZkUo00PnKSAl0yFhTc1umTxKD5cwtEIF4uBEjHfpKhf6TA2KD5fTtCdCYy7nVjS8B9TVpSRZXd7Ydj0V3k1AY3ZxF2dIpISTXW0T0E+nCHCygC3EatOdAURuZdZoPtBAcdAS2+QCzC5FhoccpaOzShWy9sPuq+Ly8Yo6DaYw1LKy1ne0JH+tX61zh2BOiozFaKQO1fEHSsSwtaBPoWHTkZ/xAR6ffHUy0XCBjO7NXWI+M5YjWF4/6xb+b+KG8rA1PvOmsBkSoyJc0Hrw+qiRjKT3ghy24bzytIxbkvsXSw7FlXiTGaytJkA/gWmTGelvKoTnr2soYZxE9bcxkqpSve/E421HrSJTt1nB2b8UKaKVNy9AY0i/hQfdoPALL85vdk7b7mBd0/1oaF1OXgNmkQz8pPa/92k+m2uqxfTG+f4WmF2dCoyWg5M0mluK9pQSpdkFX/x2dAvyeDnqgBR2xuLkbb/a/srf8MhofmZt23CDjCjI+qLTS7iT6H0jQb1mC94Cy4phag7lRlaoFs12IAVXu51bi/Z6U98pgZnUhOdk51y1WgZem5HNF+Y/VAdG7z1YIuow9j9Sg3IXvjr09xWx0iigUwnDkBuPTo7eD2jekz7facAKuoil4K4MWaucIgjhZBILt6DmZWgcGWRet+vYaVLVuSylJvMGAUsRfbH4LJGX+3YePM9SjnoIBPoyGRrToKxMySo7TozJ7vvAPBOGnow1ipGqkLvdQRpsnsLH2ccC+QVUC/am9nkSBtnSbGuyPoHqn553tUiYOmJdT7EDYZdxTtoHH215i9IXjzYNOqnZ0Dn2r//TGNqukq7VsJJyW0NylGjVWOQ1ns5MVbazJ7W3dLH1O0Tz2HgauQnjh9UN6MlgwaVfUhSI1MHWTeo89GD16yinRtidIcXmIab5My43xXSWOy//3vcQpdWkCo6yHZOTqXOht2wQCKQvzOmGft3Ok7iQqC/kB6M/4Y/1XbpKYmZa/K6RGci19NLVtulKaRrorMBSZDtTk9B4/f1+SaDnu5Vn2Ch9ZEVQSwnxphZ+FoHt/7V7Yao0UAFcXucCwwWhBNhFhtn3ZdgZEhoNltwMUUAjH/jpbDxLG3R5xDUxsTE+E9fzYGCsd5621Yl9V2oYsXo1+aWhWwpKexSco3AhD8YB8z7qMvwutNy+js3Bp1+nmcNoqGyeARyGGx9K6GY9Zq0lm2JN4GRAbAN6WeywKwtbDk3CkZodAkcVBCohVxsV601p4cOM+rET8qNWBZURrxAsTOZVgOT3yjCiOwUbR8LE5RefvuKeupFZca1ZB0AyT+g5Bypo2z6jiK2pdllVpPp1ZVDzwkTixcDFKNF52wkc2SuUjHeARrh1vAC35QbpnOLY5qtrje19jt9nd/lPyGaSlLJYJutLFM6YKW0pixjkdHaybjTLVm/fWP3DtnNCiezN/j+8VrXz4IEsZ4xwQrdZVB3N1jHFzjMjT0pJCMrRs2fGqMwUXc/cyVM6+YcasBRy3UMRhBMPQKNjHEEUFsHbW41sEMmtAGsT/Kh0cFaYeUAuuV2IIdBkxd2TgavNiYBJcOWgUi/Ku6npiJ7A1ZqGf5JBa0Kie9P3ocusWYgjRN6VLdui9JRU5PqK92ccrf/7ClK5mrnUK35bD9vUs7kL1MJhxZHL6YelGP2/5J6y1YkcGlKTiAuKn14nA91yzEP+Z7cbrtkt1xaf7TBEHDvpAPGZOrKh5wyRuBa/87XX7oVrVn0zhlCAeYF2L/jpVSBUejLNSEnFtvJtVrOGDABZEklmy1mCFhq8J3mzgoKAzZldJs2aYszJS6XwefdGO8v1VR7wfglEuZbCZVbNtSRfkfWzLA8N0o5ogGfKst5D5yVUpPhXKXCdlMRzpDEYbmSFhMQ6Q7NK2ovme7pVqLllkc5FvKNZxR5KdcNxhe2lKRLdfjGvWeT2sVciYK62av/lIzCTXPTG3hW828i0oe5FjfztoJQZhBXOSXlJDiUgpUrhgElFgg5gvxbGSnTOMOrakaud6Fm3MiwX6d96u9uw0uN9iP6gWM96VBvw6RXXUmilooll9svioebNuGpSF1XxMYkxE3+eBgTS1O9XAcDHqEJ+0yGWcquh9SRcOX6B6OAoxE9lNfYbDnUyAOVqhhba3DgiZMWTdV3fixEgkao/Wbv66mPTWD2vZtTJrxedEchzAt2bSXBhls9UA8G1KBeH8TUhJeiwA9mDQR31bBk0u0m9p45wOJiDzvU/m5HeS4Jm3AuBsHD4npg5eKs+84u9UdhYJevLkatfWdnf2kip5Wy06OLhv9aAA8OygitugT303L24CzcqSKDPWUjzDh+Hg8hIwwo4rwQoLtVhXe57SiOBM0T8EfzkuNKXZrm8nVE50ybUhlppmLpVcjrYqGoBuXcdO1RC0EXw3GsebqyNaJV9a1uu8LzBBTGAZMfWWnHLQBG7AjJqXZM0enFYTj+E7GxWW0a3IyO6ZXAF08CQRXdoN/PusT2Q1oy1LyYWo1R0otGpjyE4NIOMelKQ2Si1b6aeWPZqi3nWuS7NlmdUYKMXVAEwLN9CaU68mXNVghxdv2VWcTmvsfp5X56GDDMTmN9Lds2XIYFEJbo5MSe9BYH4zFwjU9MS/6ZVPo+qSliPUoy/nz+I8NndSC1bjPDaD0iHzwme1c8Y0BQHNouVBxMGYwrz06rzUoxwa0g0F6q2Lie9ZYfUHn6nKULOyC6pyxAXcAq8wW9t1msITGnH3cPj56HvYgrCW6TS5Y5RwcOi2NStC9TXJusVjbopNNItTDDZAsXBR5+EZ4mFu9e/RJC2mPNsGkMXXXprpdTCrVCOLZnyhF0pnAEXOq72ZZpQsbKLXxRXpNRistGVkKBsfnWItNPJmzftOxng8Q75RUoupDfjnMa3D9S8l289RI21BGYO0xt8ZRKy3BIkSGQWpZypgFwpmZ9ac/9g5aZQyaxU05XUg9GoNrqZItmSoHX1QBcTixQMhOcOUYR7280Q3Xnh4arDAbUQjjMboNKS4pss0HjjH/Z7FhpXkoh7dTKd2GCYOyuhCDBrwJo2SOki2E8dNLAQ70KQ0AglJBE25l1vSlbg4lRHPpOPM1BFef5v73ypI3sHls88ERRTmHX8jNcWKFdfdwjp9C3uFZkpAZ3HG2uZLxNKpDv2nyMxa7MDvDxq5JbGOhjcmuacgCHZvhDFVwEGZrdj5nmXlHs1WxmH2nsZMpupE7zzZPDyayRqsCW+PyVltrHVgxVb5ge8IoUDSj3pX/wI9A3HWKqQf2CYcgLh+PjhsXAaTxdQPlUH6SyeZxnzaP/WnaCAxHvkDrGkXGjgtyU7tLWcA+C3pWUY/y5lBylX1nueza1ZWcZbp+EvKNMMnmlHpq0OgrV94EkT13Ftk/Mo70KuerBQFUM7sNfsL4nWUO2LfyNKHWmxLbpyQS8xLrjvYnqDRtrJGrd9/3ZezB/p+UJVFFNBqaqEoFyvvq79CB5dQ/FGNIdKy2dF3DkYOlsW5bH+sjd5OpWL3cJhtaM2qc7wj7yfs1jDn5Z7DtmSAmcEeXDWRdTvEt4buBwoo0J/w+C2+S8Amb8LzrV/VPR0QTCO5Qn1XXApZ3JmD9iVsPCRe3bgU3aUNVONt5p+c4Om7QL6go5WnIMpeJFIyJa+INxf3D7umL1YXGs8Qs90hta/iy3fG799J/9jRJqdCdvuDiAHqJt8lnydU4H6W0W4MRbqXbrwLewXHlOfVBVjJp/DYvo67Nhow+WQtTtwDhINo49DGxMRatOsGkCrbwNvFO1UoYYz5PjiBfUIZluJXv2gKLcqr0h4Ny1vyZY42ioM+nZP/Gtjco86be7DT7ToqyLI0HuoXdjxH5PMgjrAYfxLNwjmU5msied29zGpel8WySUOxo3WwHaEMz509rSfv1FQcB3vHtNQJ6zpS3jxdSH2ksNgiDbDBxE67GPH3GYJr3Jm8phMjL9FH60TvBmKFuc4g8ZFJTLe68ju1jmv0XW1JagTJOnm3lO5+E/hGkITs1+Czte6FzBW1u6VH7qRsDIqSYDCnGm99n4+0+puXNJp4Qj3Ff9UpaYLMtrQSjVff6UAhw3rNgmuyzYsV6YyR0P09Pkbj7jcNpdntZStet/hdq95bcQ/WF/RxGCG5ShbjsR8blmQeawr5zprHj5brsIUP6s4gxFdV5R2daX4r5tANsutImJS27CiLurvW+C5fy4Qhz1olRx2E5OGS5w6spy50YxHevWKHaNl5kJKDvKg41MuzFBWO47/R/GAZGG0afVjhDyBIGaxRPbf2nIUENXi8JvppIZGu69Kj7x7lXfsAEzFyGoTaMqOQgcjWJfe6G9buSjM3oE4Y0b15TeQ9p283VZdNPwr4bWGY5BTHXGvUgEQRcVZ2NHHjiDlrrlEbHuh8API6NpHL3GA5d1p2/LJadNgYM5beinIT0LMzluqwc0YBUmWU0cOwYVnkaooQrPGPDZJhNbIOhTgza8Lve7tUDkXkZ3C0OFNi7IvVkT3CO0QMDQnVnDdtacye5UdOw7Pr4HDjTzawmAW2jd8X6K9Te8A3C9K4vQWcmw44Hte8RJ2j8Nbr9G5HdAK99K0TqVJrx8JSyLsL06YO0DztShDq7PHygVZQh7+jj+EyOHrNh2U3tUP5RUFR7joP3wAITp9AIiq+DzaX9uFOmltXSemM0bObTJGZf5WiICO4XcM03EYk1JhUheXKURnOf477zyFNRub2eta6vuWpm1yc6fcx9+CSIvIeY1bCJZxR03K7CRZBhLqyJTn6Y7d7MTKLKhZJa+IBC8YjJ0o6Uhq0QtqQ45b2KAdNTW5j0Nr9Jk2uy9gDyExEhsHotIkKddtjuJmJ012faP5nLzaz3EAl14bEBTqi1ELbsbCwYIMSuMg0nyKw9uJV4mawACQPCWCKpCyn7Mf6OPFdyjtUrcDrvjvzoQTgD74RI19qdSJbOdKjujLrOWgz3HMz2IDFZaHxxiJrwBngQcniTYMtJbk5NvticDNwRJqtuEaMgRpVGrWijaxBDdSzswtPch0UfLaymlSA61NCFEaHIMr0GoxaNr2uPMPUpeSqE6LCm42zJoIo9/osKQzr/C778674kXK1l+IQAJ8wFWjERIUVV0VjXmVnojIPN+xAfFIJBSDV6nsAV3DRqOQgvifjLMBHRtH7E9ngzxH6UcTBzw7ff1HAEObSo6T73I+zsfkC5l3rjgj5SzvDyvKDm7d+Gkpx3XERoC/z+bXr4LG3jrNtFQBsriMZm3dMquKjFM8C0r3iKDgp2zSMjRGksJLB1MwtngNQhFwJT6YCGmgSG6KgHeHaRB+ynsmPcH1p1jqLSnqenca/RWVSc7C1nRXiwAarweCw29otnxqPBCOlVWDZkqj5vWbxtHvXgCWyYbAHreOXt0aNBE6GO+QoGJnf0igddmQWFmxzoYwGMiA+1RNrMIQS8v91xa7nOFypGIMq42cphjNO7Hkpkaw7Lit2ktWyuakGgFNV+GQz1GOgXt813gpMzigzCfKZKRsyl7TJz66iNyAOIsDR+LX6gOwfWlcyMxSx/LZqdqenxdC2KSqMu1e5GPF3a7VCigB4QOUbtbkQ6Nbozqp/WZNvbI0kSAndwwXhB/YxqUjWWVU5HkBqVFhYq0kqcpufBcXO+E+k4he44WHf3Ihq7bKUd6M0ux9Hl1nqsQPiHvzw6aD9YFMXHO3dd5U+iBPTx96wdtGFZdr3DbL0lA8zPk7QlKkGc7F+hFpv25AW6vG3mUXUvKoOIxvoAiO+c8B3405TY6Ljz2NWkFUcZoY4wb4t74bUjz5ywOXCu1YQxcjUGRiHKKyayZoGb9coaOQoBn3pTkqW10PAib8XKh+PnOZ99Id2CiIxx+vSGKGnPHFbOKQ41CUZUQTbfQG9laQ6I9wdIc27Cdj8egQa5vF+MnjjQvwxnIHzRLPNENggpjbLP7uN6bZRbID3vYenmU67PvsViDyGQnnOT3JN/5KjG1aC64hFEi2IkR3SdmXE3Z8gG0HXfuv5Qd3O5NC3/zsLFnqPrtSm72Y4wneQ+hDoVQumPLZRS1sWrN3bTquuqWB3szF0/0dEjvfc/h5kEmsJHL0bUHbFb9Emeke6wTx4ZFF3+nsVeDCabbLWoemUGcfCnsDGWk9Ap1/DkDBZ1WLTixE4haWkOeDjW7+V4sutkFn0dR8mzjphNFX8yWNfP7pczIbu5RhvKhWdCoOF1ApotDNP6xjZwNZVPqYMO/UdNs+COjm5QimRR6nuzj/CCegycTiIG5URjtMuUPInhtm+yHOxDIXEtVdS5yrETLJNRO236RirwVUgcULfuBssXU99kcCwOkKNbXf20Q0T332uOIG5nMO545qYxr4l3JA0O5s3xP6/Drncr1+1+M5XPl7oaDQTNqf/NPAdczgTqjqXUnqEDcGqAnh5UfbF56qCenqMUD92ZfSzklXgRNZK5uk0iEtCIxWykX5gtyzoDMdeGd03L1K3DfCqUEOjiEcE2C4jLZsjvD1cGwZ1Hyn0tizaI8otZhKg5p3ncdI0o+UYCh9dlnF53SDC+d95XFXMA1yu+UcuBwgO1dyUKxoqOOuJWnWvt8VSdWhyW3os95JvJk+cGWMrh2ZQRXKyRu1L0FG6iEH+uTVkzq66HxYqbC6jppn+QN6sCV8PMSxPGd9Q9GU5bBUqy+XDQz2bwIoB+xSoCfPEp0R4NR7+TarIzdVh8hKNHf04GMdCpz2A94uj5lD7MwT91J2W5Y73lhsPuDkHMEtSeZzbPGte8qbHIWyPHp7nUQLM6iHlz/0oxQoeyzXULCXE7I+apipya5OjYvPQsnmxS3NDvjzgL/Rs3qvAZ58/2OOnQzx4pFlVMzshjmNTG7EHS8mbTj3eaxal4T2uh829HUt5vclM8cIZ/SjvaPw7O1Rr/IzSPNTKM8fJkw2eSBqmY2W3VYk65z6pYGlrzPtIfK2WukqnwO5PWr7CzBMMm2zWjfo+QSXxOuXXmKH8i1WVIMEt2hwthJQROZ+IkUlGXDZZPx6HSuA3qxYYt5c47RSetL221R7C+DdGynvucxkmB9sUCVmx3zXk+3MbySQl65tfGI9sUTrtjn9bapdYrOx8NbDtjUq3K+xBLM6MnDm2n+U30DZckx4WampZXOddRqZ8h19hoDDmfdjfK2efZiJjX3cjoO/ebkl13dzsMTGmWsfo4ZHR0yT4IPj1hPpmIM9pC/y675cUS8SPqU2Ok1ufMVVMTwIiubSaiY+KnCmTDgNhTNk502Fi3k1H2JwPI6e5MyKWzfzboienjOC3pTiOuaIroAUdGW3zK4Pjduy7RzTiVIgE0us0APU5xtuqs8bjv0P+c8/bVQx+eilWCw5mrSq1c4XVP5Ei7Jo01K53tc2CF3QTZ6uGrWbwzn46Wuw2QXVWl8Def8uTQE6luTjhV7DYYKQdzdwPUrGjh2eZBtkSoxIdgZzAcNSEPjxOI1TzjW8k5O3l/3oRAGAs3obHb8LhwBtXjKwaOqoMRQo6jOIsQd7Re98djAQfzQPc/vB23a+yoxk/6cFSG28IWzM7pGW2Q9Hd2oBvTz6IOTMCkloxg6FqFNwcd9XmbgTka3UA2luDWWeRprWp6Nma/697Gg7z7JDYl9jbU4kDO7D5UdhGX1ZVsJOxw3HPKog+IJk08e4HQ+rQxX6aYpyyaguXTdmxFs+E9179Eh/f7d8AR6wc+xeG6AYdj9FGzitmYmI/uVXuZDRNMfmhFdV98nk1HzzPBLPvwzrB3TURjUYm8QER4A+jZxNNcP5jxmf1QPLQhODvHQzfEXILJBOvsQlunOuKR/D0A7R5g4psuxOPRj7bETRcYJqPYbvHKodgosT4XEDwzlBFBTVSDH0yNnNlbd3DcXI3sblvcCMayjK0zmvuYyb5g2+qqq1iffb4gGy/QBst0X9AJOBO398ORyQg8lgEhNVWoZUlCQdpgotX3oEL14FAygHrt1TxmyWlmjGbx0i5K4IzEKCbtNoOxf4d11Wh31JjNg0bibGLtoKNj/bTYfBw3E4tQTg5iwk/XOZz60GTtCpY9XSe/T/sfN5jx5mCC96ZXsN2dUidtjO0BZyMmcEE66cabihx23UzL2KFAA6bvDgyWSWPUn4Q1wyqSDpMTo+MIBpWL8xNljRgXp+MFHJP4PLs/OxQntXMIk2kDaJP+1kAOUyGt0sGa5oFzYYMDkxUqE9xyicnmrLpB2x7WVcNAEOwdkiDHTckBGc5XIcbBavwxb3f4WeyFU9pdnfAQPSc8T/YUIzSEhvE5gSnvzN4TH5Of3eaHLHgip4fWWC7mnZx1CqVmIV6dHTL1pEYYp2RnlRzN3auuw2dl2BUTLwq51+ZLsNbIxpgfnKjGuMIpjT+A+zHRrlY1ZTKZWcChZqAvuv0OdA+vUEu616pxhFpgG8Q5k6XiZC7xfvJwTdycwSba8N9OVPZzKmF1M0Z8TqfEs+YzuO0BlLSWPICPLGA03aqDZcFkMGdlwhZnZCP4sm4c5ceYC8CUYM20t+rQ4K0jJz91clWbgwtPh8rkY+UNErjkY5EtS6fNAw7kOzrJ9kxWSQvdJFoRsRGD8jTQoyure6bin4lThwc3Foelq7Ydqo6L2ZP3O27QWD/JwCmK0sZHJddZOGArayprvnNpMOlU+1mQE8k6Jmk0pn+CmAuGY7gmc+hqhxxIm7Cr74Qa0BXFuJasa2NtUoXujPZHQGrGKHF0R3gKslLxiR7bGOVPHnKWndbs3Yxd8gismCi3BhXEY1rJrreYC6hkxeYgh8YIVpTTXDYDeoz2fqv2elCBBm+uUGeOPjUHbiBO49wcnns5bGUHXajMYW/EdOHfhyuclh6U1GFaOKnAfPwHVT3cGI2GoaLLDGJUffE3Fx1t9llyi+KQ8rotJQc98mNkp1oBWRHd8clhiw6NnEZpgrJ5nIA+y03E0NOhBpg/J87IylNYreGJN2NprgMuipfNLxRU16xB/ZDHlm4DzBhVkMhVJowg94/VlGRbw3zWs0SD682doLwxefB+2N6ygWrxAoP40DRycvrjIOg1S7BkZ2kq86CTmL/jNNDvdNUp0dwIwV0BzyUbXDQ9d9dtt0GsC2NXzdhtYw0JPwVpNiCtqaKR4OjfTKaOhHN240WZxHeibir0lhi461KEJGbBTpWpEJ2hoelk7Bo/KMTS5kIhcZN9mH9WvrKbE4kKZO7R7rh/I4nGuvcXM2J04viO9WTHNFyt9uQOx3BuNJ3ddkKj48a0tTOaYJQWs2p0CZ1+qzfXI83MbquiZYXkGKKZd8LoKRw6jvS6Dn9hgjwbwOUEFqOnQp5KO8ybGA7BupVGIcfqUrNTJ3JrcjRyBxNIyzKOdVBpGOcFOcXuqzAKlq6lZEGRUmqFiKcb7KPiB3AIoLEuC4Bz+U74DgUA0PuQNoLbkW99bkrwVuzP1ckeXDp5FjjYXNw8RbtJDjLS/qjxAH7aHVGO0Hy02S/uaoN306SzTSKqiffw1ZPMfMSNnm06+76ojkz6xvMsMXpmm3cm+65HGybHAvCEnZo5aMxHhrjxLWatR0mn12LfRYKkDYB0ig0rlMnUQpWGoVa1T9b6eKpqehHtAiokepJM+pu/OBSOTl/VdTo55QCmlFiWzHB5O2XOZvc2vA2CmFliFAJpU1M3GDSWRiHehrRc989Y2Oe1Q9xFgUPkaCE9MP1odb8CVIjvS2mB2hwohthdOAgLjQr9FtkYmo34J9gd7qMPdh3G3Y+WGAeplqRo4kZdMBeQ7sCYi/LO0szeEN3o3QJ2lhbT9Jlfa1EmUQ/JA3DpCM7xj4X0jPsAVh8A2KFN6atp7Z4Z4+mkeEylGhHWynO6p4Pl4E93oGPAK8MXVo+GTdZ4L/Ca6TF1j4M37//3rDTlMPbLmX76CGIzrSKb53AdQo3+cq8QMCVEuIlRix0zOkswGupugacqCcf9gsru9nBZLN1q/+koOzliRipxQTZ3fxLwMNLjqEkPhlufEMwC0rWgKrd/pwB39ZN6MFUUowouk42Wqj4bzclkJz2YjBHnNt7fUuKoJn2qmHHAL86baowD+qCWg3lblbWuXh0cYBhZHtB4pml/jocqedu9g07bKwY7x5yb/aVmLCo/tOMHHQVsn1d1ZloF3sPhHRpw9wSsZA+9ua1aDrQONs9rqXw1IKOKUMnJ9EmKCnakhtcctSqh3LWPrg/FgQqyrxnBUOp7rRz3o4tIXTRtRSpuNLtdG+O7R2YLn3jAgTdyuHGSEgaW61FWGC2NO1Z4j7sVfnL04NP96NhKn3ZnbCw6IdJzuT/X0eIIPIWONqosfc42NNncXJlxUBQp52oMjQQIL3xo3nPwWhWRfZLN1EfAn6JcZM1fvShRi3Ri3t6l0HozR2FWUYVLo/KV4Ko3sO5MdB8DqnlFQeoM4Fm9VXdoQcZHz/C4A4giDOlF6ga4sdjmtBj/nNrRgONR2EXONQeraCgSnmD0aksMsxqPQnSxgAx33bSGExO6tyrqW+xjkthIyWTh5Ac2ABNhBz+GbUPDLZV7RV0Ep66iMxwyWvkxhIWove5V7UZGXngymOfgCNmlh3oBRbZGUwI7WAmz2H/gFCAAuCk+kWL5cdpzydp0s4Z3GcqPTwxK0Ke12Yd1WQD9rvmKF9LUOjtXiOi96mjVq9O4GpNjah8a3960eT9vNx36h59n3TKCRNzRgU8AAgkyyaL6+bjuG9Hpmyn6HHvnvD0gvxd3HD3qGk8z2qve/6YVjseErKupwmhJIT0ti4C0wH29imaO2IjwETFgbg9yR6rCRsbREn6Q/0aEMHSPR3AHzpUjWA1c/dJGAvWaeTuM2Tm32xXnisxNbnRT5n15VIVIPEx2HqN8UJd+HdB8wJJBYv/rHl7PHbbIlTPZwZqzuU/4BHpx3DTcgiu7tDhqf2iruVPoIem2GcNujfzozmxWwc/jkSRGBHebkRYzPvi7wuwlsx7Z6DZH19dMoJNpZ1xg6AnRNNAOKMUILY2gQ1a0lIwWcgHA4db78HYd/dScgC09urRjuG+C5Vj9dS9qqxmssdHs/KyNyKaKUaZxze4YRgmzDZ3xiDjy9DG//KMpH5oHr41iW7I7rar4EUSkhjmkJsH0b6tLOBoj4CdFswHDIfZkBHNkPAJnVNinnnibx8oZycqCNI8yUhTpLbAbvnRwvJfAQ/Ro0rTwKdIt/j2D4Xq8TDvi97GRzHMlbjqAsdVKuMxCmBF5M999Qi1WwgmPeR4ignIUe8d39imWrDhv9cZMcNzPYxVsfmQ8eEZYmSLaSUvKflABMx6zqOdxL6Ofx3HHFnvdyGG/YpRoRbZ1G4C4ksDMtjVuMLYxXDPqWBIp7dhdDZ3cUGlwH72aYsf7GhbRfTimww/HbVoe3314OrstzHfLmw3z3Xhv4HraI+ZCxOfHkHF6LW9Jxq14csDfhdXx9CCJHE9bmByFPrRmsvu8PRIIJiRbV3HnZX5mFdzqvZoFjxFI2X+ipbnM5M1rjmj3FcXpx7EY1Q0j2GsZXTm7YL3XGi1/77rWbHYAvkNtFtE0K6qwkW/279QlDynoHdr3V+JXuCGArLqBEnV/TK7vmOGQ1s9tV7gzO4FlRrAii8hub0TCX8f0N8Rjt6HM5XhKJm8G26+mjv4eT/3RvUn5lCBmbNw9/RApN5DcZQ7vxJFlT2EPbMv3Z4sZMLYMt+riWJOpKCBa8/f9MU7eYSU7QvOWy9tftCoI2vKz/DNmgYy4aG/GqRuYdyiIusvMGLeDVWwiMtZH4K+BX0WqYw8qRAAepSMRsEzd51nk5dOEqSgiCfQ0V2kXCyHxVIj1ZYDWijKoOMXYK9yHaiUTGGWmqjY2J5mWcmQFky0r+ZpZ9s1dpTqyy7mAV+tmu/yEeXgjkrn8+JbMMeYZgb1VOoGMZG2jzfY9NuWlHaK66HKgJ60SvKozCSAjX8mfgSvzxUev6pFGsrLXyAeQGqihke7ar8jMKkS6rrqjohJAZM6iXuyz4LoLuTjLiJ2ph8Jxlcz7smRgr3vSIyMReP//AMbcfwmNPZQ4AAAAAElFTkSuQmCC",lX=Object.freeze({sheen_E_and_DGTerm:sX}),cX=lX});var yt,Rm=C(()=>{"use strict";yt={Handedness:Object.freeze({NONE:"none",LEFT:"left",RIGHT:"right"}),ComponentState:Object.freeze({DEFAULT:"default",TOUCHED:"touched",PRESSED:"pressed"}),ComponentProperty:Object.freeze({BUTTON:"button",X_AXIS:"xAxis",Y_AXIS:"yAxis",STATE:"state"}),ComponentType:Object.freeze({TRIGGER:"trigger",SQUEEZE:"squeeze",TOUCHPAD:"touchpad",THUMBSTICK:"thumbstick",BUTTON:"button"}),ButtonTouchThreshold:.05,AxisTouchThreshold:.1,VisualResponseProperty:Object.freeze({TRANSFORM:"transform",VISIBILITY:"visibility"})}});function uX(m=0,n=0){let t=m,o=n;if(Math.sqrt(m*m+n*n)>1){let a=Math.atan2(n,m);t=Math.cos(a),o=Math.sin(a)}return{normalizedXAxis:t*.5+.5,normalizedYAxis:o*.5+.5}}var fX,sl,pE,xE=C(()=>{"use strict";Rm();fX={xAxis:0,yAxis:0,button:0,state:yt.ComponentState.DEFAULT};h(uX,"normalizeAxes");pE=(sl=class{constructor(n){this.componentProperty=n.componentProperty,this.states=n.states,this.valueNodeName=n.valueNodeName,this.valueNodeProperty=n.valueNodeProperty,this.valueNodeProperty===yt.VisualResponseProperty.TRANSFORM&&(this.minNodeName=n.minNodeName,this.maxNodeName=n.maxNodeName),this.value=0,this.updateFromComponent(fX)}updateFromComponent({xAxis:n,yAxis:t,button:o,state:r}){let{normalizedXAxis:i,normalizedYAxis:a}=uX(n,t);switch(this.componentProperty){case yt.ComponentProperty.X_AXIS:this.value=this.states.includes(r)?i:.5;break;case yt.ComponentProperty.Y_AXIS:this.value=this.states.includes(r)?a:.5;break;case yt.ComponentProperty.BUTTON:this.value=this.states.includes(r)?o:0;break;case yt.ComponentProperty.STATE:this.valueNodeProperty===yt.VisualResponseProperty.VISIBILITY?this.value=this.states.includes(r):this.value=this.states.includes(r)?1:0;break;default:throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`)}}},h(sl,"VisualResponse"),sl)});var ll,vE,gE=C(()=>{"use strict";Rm();xE();vE=(ll=class{constructor(n,t){if(!n||!t||!t.visualResponses||!t.gamepadIndices||Object.keys(t.gamepadIndices).length===0)throw new Error("Invalid arguments supplied");this.id=n,this.type=t.type,this.rootNodeName=t.rootNodeName,this.touchPointNodeName=t.touchPointNodeName,this.visualResponses={},Object.keys(t.visualResponses).forEach(o=>{let r=new pE(t.visualResponses[o]);this.visualResponses[o]=r}),this.gamepadIndices=Object.assign({},t.gamepadIndices),this.values={state:yt.ComponentState.DEFAULT,button:this.gamepadIndices.button!==void 0?0:void 0,xAxis:this.gamepadIndices.xAxis!==void 0?0:void 0,yAxis:this.gamepadIndices.yAxis!==void 0?0:void 0}}get data(){return{id:this.id,...this.values}}updateFromGamepad(n){if(this.values.state=yt.ComponentState.DEFAULT,this.gamepadIndices.button!==void 0&&n.buttons.length>this.gamepadIndices.button){let t=n.buttons[this.gamepadIndices.button];this.values.button=t.value,this.values.button=this.values.button<0?0:this.values.button,this.values.button=this.values.button>1?1:this.values.button,t.pressed||this.values.button===1?this.values.state=yt.ComponentState.PRESSED:(t.touched||this.values.button>yt.ButtonTouchThreshold)&&(this.values.state=yt.ComponentState.TOUCHED)}this.gamepadIndices.xAxis!==void 0&&n.axes.length>this.gamepadIndices.xAxis&&(this.values.xAxis=n.axes[this.gamepadIndices.xAxis],this.values.xAxis=this.values.xAxis<-1?-1:this.values.xAxis,this.values.xAxis=this.values.xAxis>1?1:this.values.xAxis,this.values.state===yt.ComponentState.DEFAULT&&Math.abs(this.values.xAxis)>yt.AxisTouchThreshold&&(this.values.state=yt.ComponentState.TOUCHED)),this.gamepadIndices.yAxis!==void 0&&n.axes.length>this.gamepadIndices.yAxis&&(this.values.yAxis=n.axes[this.gamepadIndices.yAxis],this.values.yAxis=this.values.yAxis<-1?-1:this.values.yAxis,this.values.yAxis=this.values.yAxis>1?1:this.values.yAxis,this.values.state===yt.ComponentState.DEFAULT&&Math.abs(this.values.yAxis)>yt.AxisTouchThreshold&&(this.values.state=yt.ComponentState.TOUCHED)),Object.values(this.visualResponses).forEach(t=>{t.updateFromComponent(this.values)})}},h(ll,"Component"),ll)});var cl,yE,bE=C(()=>{"use strict";gE();yE=(cl=class{constructor(n,t,o){if(!n)throw new Error("No xrInputSource supplied");if(!t)throw new Error("No profile supplied");this.xrInputSource=n,this.assetUrl=o,this.id=t.profileId,this.layoutDescription=t.layouts[n.handedness],this.components={},Object.keys(this.layoutDescription.components).forEach(r=>{let i=this.layoutDescription.components[r];this.components[r]=new vE(r,i)}),this.updateFromGamepad()}get gripSpace(){return this.xrInputSource.gripSpace}get targetRaySpace(){return this.xrInputSource.targetRaySpace}get data(){let n=[];return Object.values(this.components).forEach(t=>{n.push(t.data)}),n}updateFromGamepad(){Object.values(this.components).forEach(n=>{n.updateFromGamepad(this.xrInputSource.gamepad)})}},h(cl,"MotionController"),cl)});async function AE(m){let n=await fetch(m);if(n.ok)return n.json();throw new Error(n.statusText)}async function mX(m){if(!m)throw new Error("No basePath supplied");return await AE(`${m}/profilesList.json`)}async function IE(m,n,t=null,o=!0){if(!m)throw new Error("No xrInputSource supplied");if(!n)throw new Error("No basePath supplied");let r=await mX(n),i;if(m.profiles.some(l=>{let c=r[l];return c&&(i={profileId:l,profilePath:`${n}/${c.path}`,deprecated:!!c.deprecated}),!!i}),!i){if(!t)throw new Error("No matching profile name found");let l=r[t];if(!l)throw new Error(`No matching profile name found and default profile "${t}" missing.`);i={profileId:t,profilePath:`${n}/${l.path}`,deprecated:!!l.deprecated}}let a=await AE(i.profilePath),s;if(o){let l;if(m.handedness==="any"?l=a.layouts[Object.keys(a.layouts)[0]]:l=a.layouts[m.handedness],!l)throw new Error(`No matching handedness, ${m.handedness}, in profile ${i.profileId}`);l.assetPath&&(s=i.profilePath.replace("profile.json",l.assetPath))}return{profile:a,assetPath:s}}var SE=C(()=>{"use strict";h(AE,"fetchJsonFile");h(mX,"fetchProfilesList");h(IE,"fetchProfile")});var Fp,so,Na=C(()=>{"use strict";co();Fl();ge();Vn();ir();me();Fp=class Fp{constructor(){}static async importFromUri(n,t){var i;let o=await ie.fetchArrayBuffer(n);return o.isErr()?new Ue({message:"fetchArrayBuffer error",error:void 0}):await this._importGltfOrGlbFromArrayBuffers(o.get(),(i=t==null?void 0:t.files)!=null?i:{},t,n)}static async importFromArrayBuffers(n,t){for(let o in n){let r=ie.getExtension(o);if(r==="gltf"||r==="glb")return await this._importGltfOrGlbFromArrayBuffers(n[o],n,t)}return new Ue({message:"no gltf or glb file found",error:void 0})}static async _importGltfOrGlbFromArrayBuffers(n,t,o,r){if(new DataView(n,0,20).getUint32(0,!0)!==1179937895){let s=ie.arrayBufferToString(n),l=JSON.parse(s);try{let c=await this._importGltf(l,t,o,r);return new je(c)}catch{return new Ue({message:"this.__importGltf error",error:void 0})}}else try{let s=await this._importGlb(n,t,o);return new je(s)}catch{return new Ue({message:"this.importGlb error",error:void 0})}}static _getOptions(n,t,o){var r,i;if(((i=(r=t.asset)==null?void 0:r.extras)==null?void 0:i.rnLoaderOptions)!=null)for(let a in t.asset.extras.rnLoaderOptions)n[a]=t.asset.extras.rnLoaderOptions[a];for(let a in o)n[a]=o[a];return o&&o.loaderExtensionName&&typeof o.loaderExtensionName=="string"&&(Rn[o.loaderExtensionName]!=null?n.loaderExtension=Rn[o.loaderExtensionName].getInstance():(N.error(`${o.loaderExtensionName} not found!`),n.loaderExtension=void 0)),n}static async _importGlb(n,t,o){let r=new DataView(n,0,20);if(r.getUint32(4,!0)!==2)throw new Error("invalid version field in this binary glTF file.");let a=r.getUint32(12,!0);if(r.getUint32(16,!0)!==1313821514)throw new Error("invalid chunkType of chunk0 in this binary glTF file.");let l=new Uint8Array(n,20,a),c=ie.uint8ArrayToString(l),u=JSON.parse(c),_=ie.createDefaultGltfOptions();o=this._getOptions(_,u,o);let d=new Uint8Array(n,20+a+8);u.asset.extras===void 0&&(u.asset.extras={fileType:"glTF",version:"2"}),this._mergeExtendedJson(u,o.extendedJson),u.asset.extras.rnLoaderOptions=o;try{await this._loadInner(u,t,o,d)}catch(p){N.info("this._loadInner error in _loadAsBinaryJson: "+p)}return u}static async _importGltf(n,t,o,r,i){let a=(r==null?void 0:r.substring(0,r==null?void 0:r.lastIndexOf("/")))+"/";n.asset.extras===void 0&&(n.asset.extras={fileType:"glTF",version:"2"});let s=ie.createDefaultGltfOptions();o=this._getOptions(s,n,o),this._mergeExtendedJson(n,o.extendedJson),n.asset.extras.rnLoaderOptions=o;try{await this._loadInner(n,t,o,void 0,a,i)}catch(l){N.error("this._loadInner error in _loadAsTextJson: "+l)}return n}static _loadInner(n,t,o,r,i,a){let s=[];return s.push(this._loadResources(r,n,t,o,i,a)),s.push(new Kt(l=>{this._loadJsonContent(n),l()})),Kt.all(s)}static _loadJsonContent(n){this._loadDependenciesOfScenes(n),this._loadDependenciesOfNodes(n),this._loadDependenciesOfMeshes(n),this._loadDependenciesOfMaterials(n),this._loadDependenciesOfTextures(n),this._loadDependenciesOfJoints(n),this._loadDependenciesOfAnimations(n),this._loadDependenciesOfAccessors(n),this._loadDependenciesOfBufferViews(n),n.asset.extras===void 0&&(n.asset.extras={})}static _loadDependenciesOfScenes(n){for(let t of n.scenes){A.undefined(t.nodesObjects)&&(t.nodesObjects=[]);for(let o of t.nodes)t.nodesObjects[o]=n.nodes[t.nodes[o]]}}static _loadDependenciesOfNodes(n){var t,o;for(let r in n.nodes){let i=n.nodes[r];if(i.childrenObjects=(t=i.childrenObjects)!=null?t:[],i.children)for(let a of i.children)i.childrenObjects[a]=n.nodes[a],n.nodes[a].parent=parseInt(r),n.nodes[a].parentObject=i;i.mesh!==void 0&&n.meshes!==void 0&&(i.meshObject=n.meshes[i.mesh]),i.skin!==void 0&&n.skins!==void 0&&(i.skinObject=n.skins[i.skin],A.exist(i.skinObject)&&(A.not.exist((o=i.meshObject)==null?void 0:o.extras)&&(i.meshObject.extras={}),i.meshObject.extras._skin=i.skin)),i.camera!==void 0&&n.cameras!==void 0&&(i.cameraObject=n.cameras[i.camera]),i.extensions!==void 0&&i.extensions.KHR_lights_punctual!==void 0&&n.extensions!==void 0&&n.extensions.KHR_lights_punctual!==void 0&&(i.extensions.KHR_lights_punctual.lightIndex=i.extensions.KHR_lights_punctual.light,i.extensions.KHR_lights_punctual.light=n.extensions.KHR_lights_punctual.lights[i.extensions.KHR_lights_punctual.lightIndex])}}static _loadDependenciesOfMeshes(n){var t;if(!A.not.exist(n.meshes))for(let o of n.meshes)for(let r of o.primitives){if(r.material!==void 0&&(r.materialObject=n.materials[r.material]),((t=r.extensions)==null?void 0:t.KHR_materials_variants)!=null){r.materialVariants=[];let i=r.extensions.KHR_materials_variants.mappings,a=n.extensions.KHR_materials_variants.variants;for(let s of i){let l=s.variants.map(u=>a[u].name),c={materialObject:n.materials[s.material],material:s.material,variants:l};r.materialVariants.push(c)}}r.attributesObjects={};for(let i in r.attributes){let a=r.attributes[i],s=n.accessors[a];s.extras={},r.attributesObjects[i]=s}if(r.indices!=null&&(r.indicesObject=n.accessors[r.indices]),r.targets!=null){r.targetsObjects=[];for(let i of r.targets){let a={};for(let s in i){let l=i[s];if(l>=0){let c=n.accessors[l];c.extras={},a[s]=c}}r.targetsObjects.push(a)}}}}static _checkRnGltfLoaderOptionsExist(n){return!!(n.asset.extras&&n.asset.extras.rnLoaderOptions)}static _loadDependenciesOfMaterials(n){if(n.textures||(n.textures=[]),n.materials)for(let t of n.materials){if(t.pbrMetallicRoughness){let a=t.pbrMetallicRoughness.baseColorTexture;a!==void 0&&(a.texture=n.textures[a.index]);let s=t.pbrMetallicRoughness.metallicRoughnessTexture;s!==void 0&&(s.texture=n.textures[s.index])}let o=t.normalTexture;o!==void 0&&(o.texture=n.textures[o.index]);let r=t.occlusionTexture;r!==void 0&&(r.texture=n.textures[r.index]);let i=t.emissiveTexture;if(i!==void 0&&(i.texture=n.textures[i.index]),this._checkRnGltfLoaderOptionsExist(n)&&n.asset.extras.rnLoaderOptions.loaderExtension&&n.asset.extras.rnLoaderOptions.loaderExtension.setTextures&&n.asset.extras.rnLoaderOptions.loaderExtension.setTextures(n,t),A.exist(t.extensions)){let a=t.extensions;if(A.exist(a.KHR_materials_clearcoat)){let s=a.KHR_materials_clearcoat.clearcoatTexture;s!==void 0&&(s.texture=n.textures[s.index]);let l=a.KHR_materials_clearcoat.clearcoatRoughnessTexture;l!==void 0&&(l.texture=n.textures[l.index]);let c=a.KHR_materials_clearcoat.clearcoatNormalTexture;c!==void 0&&(c.texture=n.textures[c.index])}if(A.exist(a.KHR_materials_transmission)){let s=a.KHR_materials_transmission.transmissionTexture;s!==void 0&&(s.texture=n.textures[s.index])}if(A.exist(a.KHR_materials_volume)){let s=a.KHR_materials_volume.thicknessTexture;s!==void 0&&(s.texture=n.textures[s.index])}if(A.exist(a.KHR_materials_sheen)){let s=a.KHR_materials_sheen.sheenColorTexture;s!==void 0&&(s.texture=n.textures[s.index]);let l=a.KHR_materials_sheen.sheenRoughnessTexture;l!==void 0&&(l.texture=n.textures[l.index])}if(A.exist(a.KHR_materials_specular)){let s=a.KHR_materials_specular.specularTexture;s!==void 0&&(s.texture=n.textures[s.index]);let l=a.KHR_materials_specular.specularColorTexture;l!==void 0&&(l.texture=n.textures[l.index])}if(A.exist(a.KHR_materials_iridescence)){let s=a.KHR_materials_iridescence.iridescenceTexture;s!==void 0&&(s.texture=n.textures[s.index]);let l=a.KHR_materials_iridescence.iridescenceThicknessTexture;l!==void 0&&(l.texture=n.textures[l.index])}if(A.exist(a.KHR_materials_anisotropy)){let s=a.KHR_materials_anisotropy.anisotropyTexture;s!==void 0&&(s.texture=n.textures[s.index])}if(A.exist(a.KHR_materials_diffuse_transmission)){let s=a.KHR_materials_diffuse_transmission.diffuseTransmissionTexture;s!==void 0&&(s.texture=n.textures[s.index]);let l=a.KHR_materials_diffuse_transmission.diffuseTransmissionColorTexture;l!==void 0&&(l.texture=n.textures[l.index])}if(A.exist(a.VRMC_materials_mtoon)){let s=a.VRMC_materials_mtoon,l=s.shadeMultiplyTexture;l!=null&&(l.texture=n.textures[l.index]);let c=s.shadingShiftTexture;c!=null&&(c.texture=n.textures[c.index]);let u=s.matcapTexture;u!=null&&(u.texture=n.textures[u.index]);let _=s.rimMultiplyTexture;_!=null&&(_.texture=n.textures[_.index]);let d=s.outlineWidthMultiplyTexture;d!=null&&(d.texture=n.textures[d.index]);let p=s.uvAnimationMaskTexture;p!=null&&(p.texture=n.textures[p.index])}}}}static _loadDependenciesOfTextures(n){var t,o;if(n.textures)for(let r of n.textures)os(i=>r.samplerObject=n.samplers[i],r.sampler),((o=(t=r.extensions)==null?void 0:t.KHR_texture_basisu)==null?void 0:o.source)!=null?(r.extensions.KHR_texture_basisu.fallbackSourceIndex=r.source,r.source=r.extensions.KHR_texture_basisu.source,r.image=n.images[r.source]):r.source!==void 0&&(r.image=n.images[r.source])}static _loadDependenciesOfJoints(n){if(n.skins)for(let t of n.skins){t.skeletonObject=n.nodes[t.skeleton],t.inverseBindMatricesObject=n.accessors[t.inverseBindMatrices],A.not.exist(t.skeleton)&&(t.skeleton=t.joints[0],t.skeletonObject=n.nodes[t.skeleton]),t.jointsObjects=[];for(let o of t.joints)t.jointsObjects.push(n.nodes[o])}}static _loadDependenciesOfAnimations(n){if(n.animations){for(let t of n.animations)for(let o of t.channels)if(A.exist(o.sampler)){if(o.samplerObject=t.samplers[o.sampler],o.target.nodeObject=n.nodes[o.target.node],o.samplerObject.inputObject=n.accessors[o.samplerObject.input],o.samplerObject.outputObject=n.accessors[o.samplerObject.output],A.undefined(o.samplerObject.outputObject.extras)&&(o.samplerObject.outputObject.extras={}),o.target.path==="weights"){let r=o.samplerObject.outputObject.count/o.samplerObject.inputObject.count;o.samplerObject.interpolation==="CUBICSPLINE"&&(r=o.samplerObject.outputObject.count/o.samplerObject.inputObject.count/3),o.samplerObject.outputObject.extras.weightsArrayLength=r}o.target.path==="rotation"&&(o.samplerObject.outputObject.extras.quaternionIfVec4=!0)}}}static _loadDependenciesOfAccessors(n){for(let t of n.accessors)if(t.bufferView!=null&&(t.bufferViewObject=n.bufferViews[t.bufferView]),A.exist(t.sparse)){let o=t.sparse;A.exist(o)&&A.exist(o.indices)&&A.exist(o.values)&&(o.indices.bufferViewObject=n.bufferViews[o.indices.bufferView],o.values.bufferViewObject=n.bufferViews[o.values.bufferView])}}static _loadDependenciesOfBufferViews(n){for(let t of n.bufferViews)t.buffer!==void 0&&(t.bufferObject=n.buffers[t.buffer])}static _mergeExtendedJson(n,t){let o=null;if(t instanceof ArrayBuffer){let r=ie.arrayBufferToString(t);o=JSON.parse(r)}else typeof t=="string"?o=JSON.parse(t):typeof t=="object"&&(o=t);Object.assign(n,o)}static _loadResources(n,t,o,r,i,a){var c;let s=[],l;for(let u of t.buffers){let _="";if(u.uri){let d=u.uri.split("/");_=d[d.length-1]}typeof u.uri=="undefined"?l=new Kt(d=>{u.buffer=n,d(n)}):u.uri.match(/^data:application\/(.*);base64,/)?l=new Kt(d=>{let p=ie.dataUriToArrayBuffer(u.uri);u.buffer=new Uint8Array(p),d(p)}):o&&this.__containsFileName(o,_)?l=new Kt(d=>{let p=this.__getFullPathOfFileName(o,_),x=o[p];u.buffer=new Uint8Array(x),d(x)}):l=new Kt(ie.loadResourceAsync(i+u.uri,!0,(d,p)=>{u.buffer=new Uint8Array(p),d(p)},(d,p)=>{d("HTTP Error Status:"+p)})),u.bufferPromise=l,s.push(l)}for(let u of(c=t.images)!=null?c:[])if(u.uri==null)if(A.exist(n)){let _=ie.createUint8ArrayFromBufferViewInfo(t,u.bufferView,n),d=ie.createBlobImageUriFromUint8Array(_,u.mimeType);s.push(this.__loadImageUri(d,u,o))}else{let d=t.bufferViews[u.bufferView].bufferObject;if(A.not.exist(d)){N.error("gltf2BufferView.bufferObject not found");continue}let p=d.bufferPromise,x=new Kt(y=>{p.then(g=>{let E=ie.createUint8ArrayFromBufferViewInfo(t,u.bufferView,g),w=ie.createBlobImageUriFromUint8Array(E,u.mimeType);this.__loadImageUri(w,u,o).then(()=>{y(g)})})}),v=s.indexOf(p);s[v]=x,d.bufferPromise=x}else{let _=u.uri,d=_.split("/"),p=d[d.length-1],x;if(o&&this.__containsFileName(o,p)){let v=this.__getFullPathOfFileName(o,p),y=o[v];x=ie.createBlobImageUriFromUint8Array(new Uint8Array(y),u.mimeType)}else _.match(/^data:/)?x=_:x=i+_;s.push(this.__loadImageUri(x,u,o))}return Kt.all(s,a).catch(u=>{N.error("Promise.all error: "+u)})}static __containsFileName(n,t){for(let o in n){let r=o.split("/");if(r[r.length-1]===t)return!0}return!1}static __getFullPathOfFileName(n,t){for(let o in n){let r=o.split("/");if(r[r.length-1]===t)return o}}static __loadImageUri(n,t,o){var i,a;let r;return n.match(/basis$/)?r=new Kt(s=>{fetch(n,{mode:"cors"}).then(l=>{l.arrayBuffer().then(c=>{let u=new Uint8Array(c);t.basis=u,s(t)})})}):(i=t.uri)!=null&&i.match(/basis$/)?r=new Kt(s=>{t.basis=new Uint8Array(o[t.uri]),s(t)}):n.match(/\.ktx2$/)||n.match(/^data:image\/ktx2/)||t.bufferView!=null&&t.mimeType==="image/ktx2"?r=new Kt(s=>{fetch(n,{mode:"cors"}).then(l=>{l.arrayBuffer().then(c=>{let u=new Uint8Array(c);t.ktx2=u,s(t)})})}):(a=t.uri)!=null&&a.match(/ktx2$/)?r=new Kt(s=>{t.ktx2=new Uint8Array(o[t.uri]),s(t)}):r=ie.createImageFromUri(n,t.mimeType).then(s=>(s.crossOrigin="Anonymous",t.image=s,t)),r}};h(Fp,"Gltf2Importer");so=Fp});var bt,Pa,Nm=C(()=>{"use strict";dn();at();it();yo();Cn();Ot();br();nn();fo();Yt();Er();tt();Zi();yr();me();bt=class bt extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"_jointIndices",[]);f(this,"__joints",[]);f(this,"__inverseBindMatricesAccessor");f(this,"_bindShapeMatrix");f(this,"__jointMatrices");f(this,"topOfJointsHierarchy");f(this,"isSkinning",!0);f(this,"__qArray",new Float32Array(0));f(this,"__tsArray",new Float32Array(0));f(this,"__tqArray",new Float32Array(0));f(this,"__sqArray",new Float32Array(0));f(this,"__qtsArray",new Float32Array(0));f(this,"__qtsInfo",pe.dummy());f(this,"__matArray",new Float32Array(0));f(this,"__worldMatrix",$.identity());f(this,"__isWorldMatrixVanilla",!0);f(this,"_isCulled",!1);this.moveStageTo(Ne.Logic),!i&&(bt.__tookGlobalDataNum<F.maxSkeletonNumber?(F.boneDataType===ke.Mat43x1?bt.__globalDataRepository.takeOne("boneMatrix"):F.boneDataType===ke.Vec4x2?(bt.__globalDataRepository.takeOne("boneTranslatePackedQuat"),bt.__globalDataRepository.takeOne("boneScalePackedQuat")):F.boneDataType===ke.Vec4x2Old?(bt.__globalDataRepository.takeOne("boneQuaternion"),bt.__globalDataRepository.takeOne("boneTranslateScale")):F.boneDataType===ke.Vec4x1&&(bt.__globalDataRepository.takeOne("boneTranslateScale"),bt.__globalDataRepository.takeOne("boneCompressedChunk")),bt.__tookGlobalDataNum++):N.warn("The actual number of Skeleton generated exceeds Config.maxSkeletonNumber."))}static get componentTID(){return Q.SkeletalComponentTID}get componentTID(){return Q.SkeletalComponentTID}setInverseBindMatricesAccessor(t){this.__inverseBindMatricesAccessor=t}setJoints(t){this.__joints=t;let o=0;this.componentSID<F.maxSkeletonNumber&&(o=this.componentSID),F.boneDataType===ke.Mat43x1?this.__matArray=bt.__globalDataRepository.getValue("boneMatrix",o)._v:F.boneDataType===ke.Vec4x2?(this.__tqArray=bt.__globalDataRepository.getValue("boneTranslatePackedQuat",o)._v,this.__sqArray=bt.__globalDataRepository.getValue("boneScalePackedQuat",o)._v):F.boneDataType===ke.Vec4x2Old?(this.__qArray=bt.__globalDataRepository.getValue("boneQuaternion",o)._v,this.__tsArray=bt.__globalDataRepository.getValue("boneTranslateScale",o)._v):F.boneDataType===ke.Vec4x1&&(this.__tsArray=bt.__globalDataRepository.getValue("boneTranslateScale",o)._v,this.__qtsArray=bt.__globalDataRepository.getValue("boneCompressedChunk",o)._v,this.__qtsInfo=bt.__globalDataRepository.getValue("boneCompressedInfo",0))}getJoints(){return this.__joints.concat()}get rootJointWorldMatrixInner(){var t;return(t=this.topOfJointsHierarchy)==null?void 0:t.matrixInner}get jointMatrices(){return this.__jointMatrices}get jointQuaternionArray(){return this.__qArray}get jointTranslateScaleArray(){return this.__tsArray}get jointTranslatePackedQuat(){return this.__tqArray}get jointScalePackedQuat(){return this.__sqArray}get jointMatricesArray(){return this.__matArray}get jointCompressedChunk(){return this.__qtsArray}get jointCompressedInfo(){return this.__qtsInfo}get worldMatrix(){return this.__worldMatrix.clone()}get worldMatrixInner(){return this.__worldMatrix}get isWorldMatrixUpdated(){return!this.__isWorldMatrixVanilla}$logic(){if(!(!this.isSkinning||this._isCulled)){for(let t=0;t<this.__joints.length;t++){let o=this.__joints[t],r=o.isVisible?o.matrixInner:o.matrixRestInner;$.multiplyTypedArrayTo(r,this.__inverseBindMatricesAccessor.getTypedArray(),bt.__tmp_mat4,t),this._bindShapeMatrix&&bt.__tmp_mat4.multiply(this._bindShapeMatrix);let i=bt.__tmp_mat4;if(t===0&&o.entity.tryToGetAnimation()!=null&&this.__worldMatrix.copyComponents(i),t===1&&this.__joints[0].entity.tryToGetAnimation()==null&&this.__worldMatrix.copyComponents(i),this.__isWorldMatrixVanilla=!1,(F.boneDataType===ke.Mat43x1||F.boneDataType===ke.Vec4x1)&&this.__copyToMatArray(i,t),F.boneDataType!==ke.Mat43x1){let a=bt.__tmpVec3_0.setComponents(Math.hypot(i._v[0],i._v[1],i._v[2]),Math.hypot(i._v[4],i._v[5],i._v[6]),Math.hypot(i._v[8],i._v[9],i._v[10]));i.m00/=a.x,i.m01/=a.x,i.m02/=a.x,i.m10/=a.y,i.m11/=a.y,i.m12/=a.y,i.m20/=a.z,i.m21/=a.z,i.m22/=a.z;let s=bt.__tmp_q.fromMatrix(i);if(F.boneDataType===ke.Vec4x2Old||F.boneDataType===ke.Vec4x1){let l=1;Math.abs(a.x)>Math.abs(a.y)?Math.abs(a.x)>Math.abs(a.z)?l=a.x:l=a.z:Math.abs(a.y)>Math.abs(a.z)?l=a.y:l=a.z,this.__tsArray[t*4+3]=l}if(F.boneDataType===ke.Vec4x2){let l=Y.packNormalizedVec4ToVec2(s.x,s.y,s.z,s.w,Math.pow(2,12));this.__tqArray[t*4+0]=i.m03,this.__tqArray[t*4+1]=i.m13,this.__tqArray[t*4+2]=i.m23,this.__sqArray[t*4+0]=a.x,this.__sqArray[t*4+1]=a.y,this.__sqArray[t*4+2]=a.z,this.__tqArray[t*4+3]=l[0],this.__sqArray[t*4+3]=l[1]}else F.boneDataType===ke.Vec4x2Old&&(this.__tsArray[t*4+0]=i.m03,this.__tsArray[t*4+1]=i.m13,this.__tsArray[t*4+2]=i.m23,this.__qArray[t*4+0]=s.x,this.__qArray[t*4+1]=s.y,this.__qArray[t*4+2]=s.z,this.__qArray[t*4+3]=s.w);if(F.boneDataType===ke.Vec4x1){this.__tsArray[t*4+0]=i.m03,this.__tsArray[t*4+1]=i.m13,this.__tsArray[t*4+2]=i.m23;let l=Y.packNormalizedVec4ToVec2(s.x,s.y,s.z,s.w,Math.pow(2,12));this.__qtsArray[t*4+0]=l[0],this.__qtsArray[t*4+1]=l[1]}}}if(F.boneDataType===ke.Vec4x1){let t=1,o=1,r=1;for(let i=0;i<this.__joints.length;i++){let a=Math.abs(this.__tsArray[i*4+0]);a>t&&(t=a);let s=Math.abs(this.__tsArray[i*4+1]);s>o&&(o=s);let l=Math.abs(this.__tsArray[i*4+2]);l>r&&(r=l)}this.__qtsInfo.x=t,this.__qtsInfo.y=o,this.__qtsInfo.z=r,this.__qtsInfo.w=1;for(let i=0;i<this.__joints.length;i++){let a=this.__tsArray[i*4+0],s=this.__tsArray[i*4+1],l=this.__tsArray[i*4+2],c=this.__tsArray[i*4+3],u=a/t,_=s/o,d=l/r,p=c,x=Y.packNormalizedVec4ToVec2(u,_,d,p,Math.pow(2,12));this.__qtsArray[i*4+2]=x[0],this.__qtsArray[i*4+3]=x[1]}}}}__copyToMatArray(t,o){this.__matArray[o*12+0]=t._v[0],this.__matArray[o*12+1]=t._v[1],this.__matArray[o*12+2]=t._v[2],this.__matArray[o*12+3]=t._v[4],this.__matArray[o*12+4]=t._v[5],this.__matArray[o*12+5]=t._v[6],this.__matArray[o*12+6]=t._v[8],this.__matArray[o*12+7]=t._v[9],this.__matArray[o*12+8]=t._v[10],this.__matArray[o*12+9]=t._v[12],this.__matArray[o*12+10]=t._v[13],this.__matArray[o*12+11]=t._v[14]}getInverseBindMatricesAccessor(){return this.__inverseBindMatricesAccessor}_shallowCopyFrom(t){let o=t;this._jointIndices=o._jointIndices.concat(),this.setJoints(o.__joints.concat()),this.setJoints([]),this.__inverseBindMatricesAccessor=o.__inverseBindMatricesAccessor,A.exist(o._bindShapeMatrix)&&(this._bindShapeMatrix=o._bindShapeMatrix.clone()),A.exist(o.__jointMatrices)&&(this.__jointMatrices=o.__jointMatrices.concat()),this.topOfJointsHierarchy=o.topOfJointsHierarchy,this.isSkinning=o.isSkinning,this.__qArray.set(o.__qArray),this.__tsArray.set(o.__tsArray),this.__tqArray.set(o.__tqArray),this.__sqArray.set(o.__sqArray),this.__qtsArray.set(o.__qtsArray),this.__qtsInfo.copyComponents(o.__qtsInfo),this.__matArray.set(o.__matArray),this.__worldMatrix.copyComponents(o.__worldMatrix),this.__isWorldMatrixVanilla=o.__isWorldMatrixVanilla}get entity(){return ne.getEntity(this.__entityUid)}_destroy(){super._destroy()}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(s,l,c){super(s,l,c)}getSkeletal(){return this.getComponentByComponentTID(Q.SkeletalComponentTID)}},h(i,"SkeletalEntity"),i);return vt(t,r),t}_getInverseBindMatrices(t){let o=this.__joints.indexOf(t),r=this.__inverseBindMatricesAccessor.getTypedArray();return new Se(r.slice(o*16,o*16+16))}};h(bt,"SkeletalComponent"),f(bt,"__globalDataRepository",gt.getInstance()),f(bt,"__tookGlobalDataNum",0),f(bt,"__tmpVec3_0",L.zero()),f(bt,"__tmp_mat4",$.identity()),f(bt,"__tmp_q",Ye.fromCopy4(0,0,0,1)),f(bt,"__identityMat",$.identity());Pa=bt});function _X(m,n){let t=m.getComponentByComponentTID(Q.EffekseerComponentTID);if(A.exist(t)&&(t.playJustAfterLoaded=!0,t.isLoop=!0,A.exist(n.timelines))){let o=n.timelines;for(let r of o){let i=r.values,a=r.name,s=i.map(p=>({input:p.input,event:p.event})),l=m.tryToGetAnimation(),c;A.not.exist(l)&&(c=ne.addComponentToEntity(ot,m)),l=c.getAnimation();let u=new Map,_=A.exist(a)?a:"Default";u.set(_,{input:new Float32Array(s.map(p=>p.input)),output:new Float32Array(s.map(p=>p.event==="play"?1:0)),outputComponentN:1,interpolationMethod:Gn.Step});let d=new ur(u,_);l.setAnimation("effekseer",d)}}}var Pm,fl,Lp=C(()=>{"use strict";sf();ul();at();un();_c();co();ge();me();Pm=class Pm{static importBillboard(n,t){let o="RHODONITE_billboard";if(!(A.not.exist(n.extensionsUsed)||n.extensionsUsed.findIndex(r=>o===r)===-1))for(let r in n.nodes){let i=t[r],a=n.nodes[r],s=i.getSceneGraph();a.extensions!==void 0&&a.extensions.RHODONITE_billboard!==void 0&&a.extensions.RHODONITE_billboard.isBillboard===!0&&(s.isBillboard=!0)}}static importEffect(n,t){let o="RHODONITE_effekseer";if(A.not.exist(n.extensions)||A.not.exist(n.extensions.RHODONITE_effekseer)||n.extensionsUsed.findIndex(a=>o===a)===-1)return;let r=t.getTagValue("rnEntities"),i=n.extensions.RHODONITE_effekseer.effects;for(let a of i){let s=r[a.node],l=ne.addComponentToEntity(Xr,s),c=l.getEffekseer();c.playJustAfterLoaded=!0,c.isLoop=!0,A.exist(a.bufferView)?n.buffers[0].bufferPromise.then(_=>{let d=ie.createUint8ArrayFromBufferViewInfo(n,a.bufferView,_);c.arrayBuffer=d.buffer.slice(d.byteOffset,d.byteOffset+d.byteLength),c.type="efkpkg"}):A.exist(a.uri)?(c.uri=a.uri,c.type="efk"):N.error("No real effect data."),_X(l,a)}}};h(Pm,"RhodoniteImportExtension"),f(Pm,"__instance");fl=Pm;h(_X,"createEffekseerAnimation")});var Vp,ui,Mm=C(()=>{"use strict";dn();at();Cn();it();Vp=class Vp extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"__activeAnimationTrack","");f(this,"__interpolationStartTime",performance.now());f(this,"__blendingDuration",1);f(this,"__isBlending",!1);f(this,"__blendingRatio",0);this.moveStageTo(Ne.Logic)}static get componentTID(){return Q.AnimationStateComponentTID}get componentTID(){return Q.AnimationStateComponentTID}get isBlending(){return this.__isBlending}get blendingRatio(){return this.__blendingRatio}$logic(){if(!this.__isBlending)return;let o=(performance.now()-this.__interpolationStartTime)/1e3/this.__blendingDuration;o>=1&&(this.__isBlending=!1);let r=Math.min(o,1);this.setAnimationBlendingRatio(r),this.__blendingRatio=r}setFirstActiveAnimationTrack(t){this.__activeAnimationTrack=t,this.setActiveAnimationTrack(t),this.setAnimationBlendingRatio(0),this.__isBlending=!1}forceTransitionTo(t,o){let r=this.__activeAnimationTrack;this.setActiveAnimationTrack(r),this.setSecondActiveAnimationTrack(t),this.__interpolationStartTime=performance.now(),this.__blendingDuration=o,this.__activeAnimationTrack=t,this.__isBlending=!0}setActiveAnimationTrack(t){function o(r){let i=r.tryToGetAnimation();i!=null&&i.setActiveAnimationTrack(t);for(let a of r.children)o(a.entity)}h(o,"processRecursively"),o(this.entity)}setSecondActiveAnimationTrack(t){function o(r){let i=r.tryToGetAnimation();i!=null&&i.setSecondActiveAnimationTrack(t);for(let a of r.children)o(a.entity)}h(o,"processRecursively"),o(this.entity)}setUseGlobalTime(t){function o(r){let i=r.tryToGetAnimation();i!=null&&(i.useGlobalTime=t);for(let a of r.children)o(a.entity)}h(o,"processRecursively"),o(this.entity)}setIsLoop(t){function o(r){let i=r.tryToGetAnimation();i!=null&&(i.isLoop=t);for(let a of r.children)o(a.entity)}h(o,"processRecursively"),o(this.entity)}setTime(t){function o(r){let i=r.tryToGetAnimation();i!=null&&(i.time=t);for(let a of r.children)o(a.entity)}h(o,"processRecursively"),o(this.entity)}setAnimationBlendingRatio(t){function o(r){let i=r.tryToGetAnimation();i!=null&&(i.animationBlendingRatio=t);for(let a of r.children)o(a.entity)}h(o,"processRecursively"),o(this.entity)}_destroy(){super._destroy()}get entity(){return ne.getEntity(this.__entityUid)}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(s,l,c){super(s,l,c)}getAnimationState(){return this.getComponentByComponentTID(Q.AnimationStateComponentTID)}},h(i,"BlendShapeEntity"),i);return vt(t,r),t}};h(Vp,"AnimationStateComponent");ui=Vp});function zp(){let m=en();return ne.tryToAddComponentToEntityByTID(Q.LightComponentTID,m)}var Gp=C(()=>{"use strict";at();dr();it();h(zp,"createLightEntity")});function dX(m,n,t,o,r){let i=t.extensions.VRMC_materials_mtoon;{let a=i.shadeColorFactor;m.setParameter("shadeColorFactor",S.fromCopyArray3(a))}{let a=i.shadeMultiplyTexture;if(a!=null){let s=o[a.texture.source],l=r[a.texture.sampler];m.setTextureParameter("shadeMultiplyTexture",s,l),a.texCoord!=null&&m.setParameter("shadeMultiplyTexcoordIndex",a.texCoord)}}{let a=i.shadingShiftFactor;a!=null&&m.setParameter("shadingShiftFactor",a)}{let a=i.shadingShiftTexture;if(a!=null){let s=o[a.texture.source],l=r[a.texture.sampler];m.setTextureParameter("shadingShiftTexture",s,l),a.texCoord!=null&&m.setParameter("shadingShiftTexcoordIndex",a.texCoord);let c=a.scale;c!=null&&m.setParameter("shadingShiftTextureScale",c)}}{let a=i.shadingToonyFactor;a!=null&&m.setParameter("shadingToonyFactor",a)}{let a=i.giEqualizationFactor;a!=null&&m.setParameter("giEqualizationFactor",a)}{let a=i.matcapTexture;if(a!=null){let s=o[a.texture.source],l=r[a.texture.sampler];m.setTextureParameter("matcapTexture",s,l),a.texCoord!=null&&m.setParameter("matcapTexcoordIndex",a.texCoord)}}{let a=i.matcapFactor;a!=null&&m.setParameter("matcapFactor",S.fromCopyArray3(a))}{let a=i.parametricRimColorFactor;a!=null&&m.setParameter("parametricRimColorFactor",S.fromCopyArray3(a))}{let a=i.parametricRimFresnelPowerFactor;a!=null&&m.setParameter("parametricRimFresnelPowerFactor",a)}{let a=i.parametricRimLiftFactor;a!=null&&m.setParameter("parametricRimLiftFactor",a)}{let a=i.rimMultiplyTexture;if(a!=null){let s=o[a.texture.source],l=r[a.texture.sampler];m.setTextureParameter("rimMultiplyTexture",s,l),a.texCoord!=null&&m.setParameter("rimMultiplyTexcoordIndex",a.texCoord)}}{let a=i.rimLightingMixFactor;a!=null&&m.setParameter("rimLightingMixFactor",a)}{let a=i.outlineWidthMode;a!=null&&(a==="none"?m.setParameter("outlineWidthMode",0):a==="worldCoordinates"?m.setParameter("outlineWidthMode",1):a==="screenCoordinates"&&m.setParameter("outlineWidthMode",2))}{let a=i.outlineWidthFactor;a!=null&&m.setParameter("outlineWidthFactor",a)}{let a=i.outlineWidthMultiplyTexture;if(a!=null){let s=o[a.texture.source],l=r[a.texture.sampler];m.setTextureParameter("outlineWidthMultiplyTexture",s,l)}}{let a=i.outlineColorFactor;a!=null&&m.setParameter("outlineColorFactor",S.fromCopyArray3(a))}{let a=i.outlineLightingMixFactor;a!=null&&m.setParameter("outlineLightingMixFactor",a)}{let a=i.uvAnimationMaskTexture;if(a!=null){let s=o[a.texture.source],l=r[a.texture.sampler];m.setTextureParameter("uvAnimationMaskTexture",s,l),a.texCoord!=null&&m.setParameter("uvAnimationMaskTexcoordIndex",a.texCoord)}}{let a=i.uvAnimationScrollXSpeedFactor;a!=null&&m.setParameter("uvAnimationScrollXSpeedFactor",a)}{let a=i.uvAnimationScrollYSpeedFactor;a!=null&&m.setParameter("uvAnimationScrollYSpeedFactor",a)}{let a=i.uvAnimationRotationSpeedFactor;a!=null&&m.setParameter("uvAnimationRotationSpeedFactor",a)}}function hX(m,n,t,o,r,i,a){var v;let s=((v=r.extensions)==null?void 0:v.KHR_materials_unlit)!=null,l=m.baseColorFactor;l!=null&&n.setParameter("baseColorFactor",q.fromCopyArray4(l));let c=m.baseColorTexture;if(c!=null){let y=i[c.texture.source],g=a[c.texture.sampler];n.setTextureParameter("baseColorTexture",y,g),c.texCoord!=null&&n.setParameter("baseColorTexcoordIndex",c.texCoord),Ve._setupTextureTransform(c,n,"baseColorTextureTransformScale","baseColorTextureTransformOffset","baseColorTextureTransformRotation")}let u=r.occlusionTexture;if(u!=null&&A.falsy(s)){let y=i[u.texture.source],g=a[u.texture.sampler];n.setTextureParameter("occlusionTexture",y,g),u.texCoord!=null&&n.setParameter("occlusionTexcoordIndex",u.texCoord),u.strength!=null&&n.setParameter("occlusionStrength",u.strength),Ve._setupTextureTransform(u,n,"occlusionTextureTransformScale","occlusionTextureTransformOffset","occlusionTextureTransformRotation")}let _=m.metallicFactor;_=s?0:_!=null?_:1;let d=m.roughnessFactor;d=s?1:d!=null?d:1,n.setParameter("metallicFactor",_),n.setParameter("roughnessFactor",d);let p=m.metallicRoughnessTexture;if(p!=null&&A.falsy(s)){let y=i[p.texture.source],g=a[p.texture.sampler];n.setTextureParameter("metallicRoughnessTexture",y,g),p.texCoord!=null&&n.setParameter("metallicRoughnessTexcoordIndex",p.texCoord),Ve._setupTextureTransform(p,n,"metallicRoughnessTextureTransformScale","metallicRoughnessTextureTransformOffset","metallicRoughnessTextureTransformRotation")}xX(r,n,t,i,a);let x=pX(r,n,t,i,a);o.transmission||(o.transmission=x),vX(r,n,t,i,a),gX(r,n,t,i,a),yX(r,n,t,i,a),bX(r,n,t),AX(r,n,t,i,a),IX(r,n,t,i,a),SX(r,n,t),TX(r,n,t),EX(r,n,t,i,a)}function pX(m,n,t,o,r){var a;let i=(a=m.extensions)==null?void 0:a.KHR_materials_transmission;if(A.exist(i)){let s=A.exist(i.transmissionFactor)?i.transmissionFactor:0;n.setParameter("transmissionFactor",s);let l=i.transmissionTexture;if(A.exist(l)){let c=o[l.texture.source],u=r[l.texture.sampler];n.setTextureParameter("transmissionTexture",c,u),l.texCoord!=null&&n.setParameter("transmissionTexcoordIndex",l.texCoord),Ve._setupTextureTransform(l,n,"transmissionTextureTransformScale","transmissionTextureTransformOffset","transmissionTextureTransformRotation")}return!0}return!1}function xX(m,n,t,o,r){var a;let i=(a=m==null?void 0:m.extensions)==null?void 0:a.KHR_materials_clearcoat;if(A.exist(i)){let s=A.exist(i.clearcoatFactor)?i.clearcoatFactor:0;n.setParameter("clearcoatFactor",s);let l=i.clearcoatTexture;if(l!=null){let d=o[l.texture.source],p=r[l.texture.sampler];n.setTextureParameter("clearcoatTexture",d,p),l.texCoord!=null&&n.setParameter("clearcoatTexcoordIndex",l.texCoord),Ve._setupTextureTransform(l,n,"clearcoatTextureTransformScale","clearcoatTextureTransformOffset","clearcoatTextureTransformRotation")}let c=A.exist(i.clearcoatRoughnessFactor)?i.clearcoatRoughnessFactor:0;n.setParameter("clearcoatRoughnessFactor",c);let u=i.clearcoatRoughnessTexture;if(u!=null){let d=o[u.texture.source],p=r[u.texture.sampler];n.setTextureParameter("clearcoatRoughnessTexture",d,p),u.texCoord!=null&&n.setParameter("clearcoatRoughnessTexcoordIndex",u.texCoord),Ve._setupTextureTransform(u,n,"clearcoatRoughnessTextureTransformScale","clearcoatRoughnessTextureTransformOffset","clearcoatRoughnessTextureTransformRotation")}let _=i.clearcoatNormalTexture;if(_!=null){let d=o[_.texture.source],p=r[_.texture.sampler];n.setTextureParameter("clearcoatNormalTexture",d,p),_.texCoord!=null&&n.setParameter("clearcoatNormalTexcoordIndex",_.texCoord),Ve._setupTextureTransform(_,n,"clearcoatNormalTextureTransformScale","clearcoatNormalTextureTransformOffset","clearcoatNormalTextureTransformRotation")}}}function vX(m,n,t,o,r){var a;let i=(a=m==null?void 0:m.extensions)==null?void 0:a.KHR_materials_volume;if(A.exist(i)){let s=i.thicknessFactor?i.thicknessFactor:0;s!=null&&n.setParameter("thicknessFactor",s);let l=i.thicknessTexture;if(l!=null){let _=o[l.texture.source],d=r[l.texture.sampler];n.setTextureParameter("thicknessTexture",_,d),l.texCoord!=null&&n.setParameter("thicknessTexcoordIndex",l.texCoord),Ve._setupTextureTransform(l,n,"thicknessTextureTransformScale","thicknessTextureTransformOffset","thicknessTextureTransformRotation")}let c=i.attenuationDistance?i.attenuationDistance:0;c!=null&&n.setParameter("attenuationDistance",c);let u=i.attenuationColor?S.fromCopyArray3(i.attenuationColor):S.fromCopy3(1,1,1);u!=null&&n.setParameter("attenuationColor",u)}}function gX(m,n,t,o,r){var a;let i=(a=m==null?void 0:m.extensions)==null?void 0:a.KHR_materials_sheen;if(A.exist(i)){let s=A.exist(i.sheenColorFactor)?i.sheenColorFactor:[0,0,0];n.setParameter("sheenColorFactor",S.fromCopyArray3(s));let l=i.sheenColorTexture;if(l!=null){let _=o[l.texture.source],d=r[l.texture.sampler];n.setTextureParameter("sheenColorTexture",_,d),l.texCoord!=null&&n.setParameter("sheenColorTexcoordIndex",l.texCoord),Ve._setupTextureTransform(l,n,"sheenColorTextureTransformScale","sheenColorTextureTransformOffset","sheenColorTextureTransformRotation")}let c=A.exist(i.sheenRoughnessFactor)?i.sheenRoughnessFactor:0;n.setParameter("sheenRoughnessFactor",c);let u=i.sheenRoughnessTexture;if(u!=null){let _=o[u.texture.source],d=r[u.texture.sampler];n.setTextureParameter("sheenRoughnessTexture",_,d),u.texCoord!=null&&n.setParameter("sheenRoughnessTexcoordIndex",u.texCoord),Ve._setupTextureTransform(u,n,"sheenRoughnessTextureTransformScale","sheenRoughnessTextureTransformOffset","sheenRoughnessTextureTransformRotation")}}}function yX(m,n,t,o,r){var a;let i=(a=m==null?void 0:m.extensions)==null?void 0:a.KHR_materials_specular;if(A.exist(i)){let s=A.exist(i.specularFactor)?i.specularFactor:1;n.setParameter("specularFactor",s);let l=i.specularTexture;if(l!=null){let _=o[l.texture.source],d=r[l.texture.sampler];n.setTextureParameter("specularTexture",_,d),l.texCoord!=null&&n.setParameter("specularTexcoordIndex",l.texCoord),Ve._setupTextureTransform(l,n,"specularTextureTransformScale","specularTextureTransformOffset","specularTextureTransformRotation")}let c=A.exist(i.specularColorFactor)?i.specularColorFactor:[1,1,1];n.setParameter("specularColorFactor",S.fromCopyArray3(c));let u=i.specularColorTexture;if(u!=null){let _=o[u.texture.source],d=r[u.texture.sampler];n.setTextureParameter("specularColorTexture",_,d),u.texCoord!=null&&n.setParameter("specularColorTexcoordIndex",u.texCoord),Ve._setupTextureTransform(u,n,"specularColorTextureTransformScale","specularColorTextureTransformOffset","specularColorTextureTransformRotation")}}}function bX(m,n,t){var r;let o=(r=m==null?void 0:m.extensions)==null?void 0:r.KHR_materials_ior;if(A.exist(o)){let i=A.exist(o.ior)?o.ior:1.5;n.setParameter("ior",i)}}function AX(m,n,t,o,r){var a;let i=(a=m==null?void 0:m.extensions)==null?void 0:a.KHR_materials_iridescence;if(A.exist(i)){let s=A.exist(i.iridescenceFactor)?i.iridescenceFactor:0;n.setParameter("iridescenceFactor",s);let l=i.iridescenceTexture;if(l!=null){let p=o[l.texture.source],x=r[l.texture.sampler];n.setTextureParameter("iridescenceTexture",p,x),l.texCoord!=null&&n.setParameter("iridescenceTexcoordIndex",l.texCoord),Ve._setupTextureTransform(l,n,"iridescenceTextureTransformScale","iridescenceTextureTransformOffset","iridescenceTextureTransformRotation")}let c=A.exist(i.iridescenceIor)?i.iridescenceIor:1.3;n.setParameter("iridescenceIor",c);let u=A.exist(i.iridescenceThicknessMinimum)?i.iridescenceThicknessMinimum:100;n.setParameter("iridescenceThicknessMinimum",u);let _=A.exist(i.iridescenceThicknessMaximum)?i.iridescenceThicknessMaximum:400;n.setParameter("iridescenceThicknessMaximum",_);let d=i.iridescenceThicknessTexture;if(d!=null){let p=o[d.texture.source],x=r[d.texture.sampler];n.setTextureParameter("iridescenceThicknessTexture",p,x),d.texCoord!=null&&n.setParameter("iridescenceThicknessTexcoordIndex",d.texCoord),Ve._setupTextureTransform(d,n,"iridescenceThicknessTextureTransformScale","iridescenceThicknessTextureTransformOffset","iridescenceThicknessTextureTransformRotation")}}}function IX(m,n,t,o,r){var a;let i=(a=m==null?void 0:m.extensions)==null?void 0:a.KHR_materials_anisotropy;if(A.exist(i)){let s=A.exist(i.anisotropyStrength)?i.anisotropyStrength:0;n.setParameter("anisotropyStrength",s);let l=A.exist(i.anisotropyRotation)?i.anisotropyRotation:0;n.setParameter("anisotropyRotation",Ee.fromCopy2(Math.cos(l),Math.sin(l)));let c=i.anisotropyTexture;if(c!=null){let u=o[c.texture.source],_=r[c.texture.sampler];n.setTextureParameter("anisotropyTexture",u,_),c.texCoord!=null&&n.setParameter("anisotropyTexcoordIndex",c.texCoord),Ve._setupTextureTransform(c,n,"anisotropyTextureTransformScale","anisotropyTextureTransformOffset","anisotropyTextureTransformRotation")}}}function SX(m,n,t){var r;let o=(r=m==null?void 0:m.extensions)==null?void 0:r.KHR_materials_emissive_strength;if(A.exist(o)){let i=A.exist(o.emissiveStrength)?o.emissiveStrength:1;n.setParameter("emissiveStrength",i)}}function TX(m,n,t){var r;let o=(r=m==null?void 0:m.extensions)==null?void 0:r.KHR_materials_dispersion;if(A.exist(o)){let i=A.exist(o.dispersion)?o.dispersion:0;n.setParameter("dispersion",i)}}function EX(m,n,t,o,r){var a;let i=(a=m==null?void 0:m.extensions)==null?void 0:a.KHR_materials_diffuse_transmission;if(A.exist(i)){let s=A.exist(i.diffuseTransmissionFactor)?i.diffuseTransmissionFactor:0;n.setParameter("diffuseTransmissionFactor",s);let l=i.diffuseTransmissionTexture;if(l!=null){let _=o[l.texture.source],d=r[l.texture.sampler];n.setTextureParameter("diffuseTransmissionTexture",_,d),l.texCoord!=null&&n.setParameter("diffuseTransmissionTexcoordIndex",l.texCoord),Ve._setupTextureTransform(l,n,"diffuseTransmissionTextureTransformScale","diffuseTransmissionTextureTransformOffset","diffuseTransmissionTextureTransformRotation")}let c=A.exist(i.diffuseTransmissionColorFactor)?i.diffuseTransmissionColorFactor:[1,1,1];n.setParameter("diffuseTransmissionColorFactor",S.fromCopyArray3(c));let u=i.diffuseTransmissionColorTexture;if(u!=null){let _=o[u.texture.source],d=r[u.texture.sampler];n.setTextureParameter("diffuseTransmissionColorTexture",_,d),u.texCoord!=null&&n.setParameter("diffuseTransmissionColorTexcoordIndex",u.texCoord),Ve._setupTextureTransform(u,n,"diffuseTransmissionColorTextureTransformScale","diffuseTransmissionColorTextureTransformOffset","diffuseTransmissionColorTextureTransformRotation")}}}var vo,Ve,Ma=C(()=>{"use strict";at();rl();ye();Bo();yo();_o();Lu();Nn();se();xe();Xt();ql();Ni();It();Co();Hl();nn();Nm();ni();_r();Xo();Jl();ai();Cs();tt();cr();jo();Tn();Vo();ge();co();Xu();dc();wa();Lp();Pn();Mm();dr();si();Gp();Ca();me();ks();Ws();_c();nm();tm();sr();om();vo=class vo{constructor(){}static __generateGroupEntity(n){let t=en();return this.addTags(t,n),t}static addTags(n,t){n.tryToSetTag({tag:"SourceType",value:t.asset.extras.fileType}),n.tryToSetTag({tag:"SourceTypeVersion",value:t.asset.extras.version})}static __generateMeshEntity(n){let t=Ct();return this.addTags(t,n),t}static __generateCameraEntity(n){let t=hr();return this.addTags(t,n),t}static __generateLightEntity(n){let t=zp();return this.addTags(t,n),t}static __setupMaterials(n,t,o){let r=[];if(n.materials!=null)for(let i of n.materials){let a=this.__setupMaterial(n,t,o,i);r.push(a)}return r}static __setupTextures(n){let t=[];if(n.images!=null)for(let o of n.images){let r=this._createTexture(o,n);t.push(r)}return t}static __createSamplers(n){let t=[];if(n.samplers!=null)for(let o of n.samplers){let r=this._createSampler(o);t.push(r)}return t}static convertToRhodoniteObject(n){var c;n.asset.extras.rnMeshesAtGltMeshIdx=[];let t=this.__createRnBuffer(n);n.asset.extras.rnMaterials={};let o=this.__setupTextures(n),r=this.__createSamplers(n),i=this.__setupMaterials(n,o,r),{rnEntities:a,rnEntitiesByNames:s}=this.__setupObjects(n,t,i,o,r);n.asset.extras.rnEntities=a,this._setupTransform(n,a);let l=this.__generateGroupEntity(n);if(this._setupAnimation(n,a,t,l,i),this._setupSkeleton(n,a,t),this._setupHierarchy(n,a),l.tryToSetUniqueName("FileRoot",!0),l.tryToSetTag({tag:"ObjectType",value:"top"}),n.scenes[0].nodes)for(let u of n.scenes[0].nodes){let _=a[u].getSceneGraph();l.getSceneGraph().addChild(_)}if(n.asset.extras&&n.asset.extras.rnLoaderOptions){let u=n.asset.extras.rnLoaderOptions;u&&u.loaderExtension&&((c=u==null?void 0:u.loaderExtension)!=null&&c.loadExtensionInfoAndSetToRootGroup)&&u.loaderExtension.loadExtensionInfoAndSetToRootGroup(l,n),u&&u.expression&&u.expression.tryToSetTag({tag:"gltfModel",value:n})}return l.tryToSetTag({tag:"rnEntities",value:a}),l.tryToSetTag({tag:"rnEntitiesByNames",value:s}),l.tryToSetTag({tag:"gltfModel",value:n}),A.not.exist(n.extras)&&(n.extras={}),n.extras.rnEntities=a,n.extras.rnEntitiesByNames=s,fl.importEffect(n,l),fl.importBillboard(n,a),A.exist(n.extensionsUsed)&&n.extensionsUsed.indexOf("VRMC_vrm")>0,l}static __createRnBuffer(n){let t=[];for(let o of n.buffers){let r=new ei({byteLength:o.byteLength,buffer:o.buffer,name:`gltf2Buffer_0_(${o.uri})`,byteAlign:4});t.push(r)}return t}static _setupTransform(n,t){for(let o in n.nodes){let r=t[o],i=n.nodes[o],a=r.getTransform();i.translation&&(a.localPosition=S.fromCopyArray([i.translation[0],i.translation[1],i.translation[2]])),i.scale&&(a.localScale=S.fromCopyArray([i.scale[0],i.scale[1],i.scale[2]])),i.rotation&&(a.localRotation=H.fromCopy4(i.rotation[0],i.rotation[1],i.rotation[2],i.rotation[3])),i.matrix&&(a.localMatrix=Se.fromCopyArrayColumnMajor(i.matrix))}}static _setupHierarchy(n,t){let o=t.map(r=>r.getSceneGraph());for(let r in n.nodes){let i=parseInt(r),a=n.nodes[i];if(A.exist(a.children)){let s=o[i];for(let l of a.children){let c=o[l];s.addChild(c)}}}}static _setupAnimation(n,t,o,r,i){var s;if(n.animations==null||n.animations.length===0)return;let a=ne.addComponentToEntity(ui,r);for(let l of n.animations)for(let c of l.samplers)this._readBinaryFromAccessorAndSetItToAccessorExtras(c.inputObject,o),this._readBinaryFromAccessorAndSetItToAccessorExtras(c.outputObject,o);for(let l of n.animations)for(let c of l.channels)if(A.exist(c.samplerObject)){let u=c.samplerObject,_=u.inputObject.extras.typedDataArray,d=u.outputObject.extras.typedDataArray,p=(s=u.interpolation)!=null?s:"LINEAR",x="undefined";c.target.path==="translation"?x="translate":c.target.path==="rotation"?x="quaternion":c.target.path==="pointer"?x="material/":x=c.target.path,c.target.path==="pointer"?vo.__setPointerAnimation(t,c,u,l,_,d,p,x,i,n):vo.__setNormalAnimation(t,c,u,l,_,d,p,x)}}static __setPointerAnimation(n,t,o,r,i,a,s,l,c,u){let _=t.target.extensions.KHR_animation_pointer.pointer,d=_.match(/^\/nodes\/([0-9]+)\//),p=_.match(/^\/materials\/([0-9]+)\//),x=_.match(/^\/extensions\/KHR_lights_punctual\/lights\/([0-9]+)\//),v=_.match(/^\/cameras\/([0-9]+)\//);p?vo.__setPointerAnimationMaterials(p,c,_,o,r,i,a,s,l):d?vo.__setPointerAnimationNodes(d,n,_,o,r,i,a,s,l):x?vo.__setPointerAnimationLights(x,n,_,o,r,i,a,s,l,u):v?vo.__setPointerAnimationCameras(v,n,_,o,r,i,a,s,l,u):N.info("Not Supported Animation Pointer Type")}static __setPointerAnimationCameras(n,t,o,r,i,a,s,l,c,u){let _=parseInt(n[1]),d=u.nodes;for(let p=0;p<d.length;p++)if(d[p].camera===_){let v=t[p],y=v.tryToGetCamera();if(A.not.exist(y))throw new Error(`CameraComponent not found: ${o}`);let g=r.outputObject.extras.componentN,E=new Map,w=A.exist(i.name)?i.name:"Untitled_Animation",T={input:a,output:s,outputComponentN:g,interpolationMethod:Gn.fromString(l)};E.set(w,T);let R;if(g===1)R=new ur(E,w);else if(g===2)R=new zr(E,w);else if(g===3)R=new $n(E,w);else if(g===4)R=new Gr(E,w);else throw new Error(`Unsupported component number: ${g}`);let P=v.tryToGetAnimation();A.not.exist(P)&&(P=ne.addComponentToEntity(ot,v).getAnimation()),o.includes("znear")?P.setAnimation("camera_znear",R):o.includes("zfar")?P.setAnimation("camera_zfar",R):o.includes("yfov")?P.setAnimation("camera_fovy",R):o.includes("xmag")?P.setAnimation("camera_xmag",R):o.includes("ymag")&&P.setAnimation("camera_ymag",R)}}static __setPointerAnimationLights(n,t,o,r,i,a,s,l,c,u){var p;let _=parseInt(n[1]),d=u.nodes;for(let x=0;x<d.length;x++){let v=d[x];if((p=v.extensions)!=null&&p.KHR_lights_punctual&&v.extensions.KHR_lights_punctual.lightIndex===_){let g=t[x],E=g.tryToGetLight();if(A.not.exist(E))throw new Error(`LightComponent not found: ${o}`);let w=r.outputObject.extras.componentN,T=new Map,R=A.exist(i.name)?i.name:"Untitled_Animation",P={input:a,output:s,outputComponentN:w,interpolationMethod:Gn.fromString(l)};T.set(R,P);let V;if(w===1)V=new ur(T,R);else if(w===2)V=new zr(T,R);else if(w===3)V=new $n(T,R);else if(w===4)V=new Gr(T,R);else throw new Error(`Unsupported component number: ${w}`);let z=g.tryToGetAnimation();A.not.exist(z)&&(z=ne.addComponentToEntity(ot,g).getAnimation()),o.includes("color")?z.setAnimation("light_color",V):o.includes("intensity")?z.setAnimation("light_intensity",V):o.includes("range")?z.setAnimation("light_range",V):o.includes("spot/innerConeAngle")?z.setAnimation("light_spot_innerConeAngle",V):o.includes("spot/outerConeAngle")&&z.setAnimation("light_spot_outerConeAngle",V)}}}static __setPointerAnimationNodes(n,t,o,r,i,a,s,l,c){let u=parseInt(n[1]),_=t[u];if(A.not.exist(_))throw new Error(`Node not found: ${o}`);let d=r.outputObject.extras.componentN;if(o.includes("weights")){let E=_.tryToGetBlendShape();if(A.exist(E))d=E.weights.length;else throw new Error(`BlendShapeComponent not found: ${o}`)}let p=new Map,x=A.exist(i.name)?i.name:"Untitled_Animation",v={input:a,output:s,outputComponentN:d,interpolationMethod:Gn.fromString(l)};p.set(x,v);let y;if(o.includes("weights"))y=new Si(p,x);else if(d===1)y=new ur(p,x);else if(d===2)y=new zr(p,x);else if(d===3)y=new $n(p,x);else if(d===4)y=new Gr(p,x);else throw new Error(`Unsupported component number: ${d}`);let g=_.tryToGetAnimation();A.not.exist(g)&&(g=ne.addComponentToEntity(ot,_).getAnimation()),o.includes("rotation")?g.setAnimation("quaternion",y):o.includes("translation")?g.setAnimation("translate",y):o.includes("scale")?g.setAnimation("scale",y):o.includes("weights")&&g.setAnimation("weights",y)}static __setPointerAnimationMaterials(n,t,o,r,i,a,s,l,c){let u=parseInt(n[1]),_=t[u];if(A.not.exist(_))throw new Error(`Material not found: ${o}`);let d=r.outputObject.extras.componentN,p=new Map,x=A.exist(i.name)?i.name:"Untitled_Animation",v={input:a,output:s,outputComponentN:d,interpolationMethod:Gn.fromString(l)};p.set(x,v);let y;if(d===1)y=new ur(p,x);else if(d===2)y=new zr(p,x);else if(d===3)y=new $n(p,x);else if(d===4)y=new Gr(p,x);else throw new Error(`Unsupported component number: ${d}`);let g="";if(o.includes("KHR_texture_transform")){let w=o.split("/"),T=w[w.length-4],R=w[w.length-1],P=R.charAt(0).toUpperCase()+R.slice(1);g=`${T}Transform${P}`}else o.includes("normalTexture/scale")?g="normalScale":o.includes("occlusionTexture/strength")?g="occlusionStrength":g=o.split("/").pop();_.setParameter(g,y);let E=_.getBelongPrimitives();for(let w of E.values())if(A.exist(w.mesh)){let R=w.mesh.meshEntitiesInner;for(let P of R){let V=P.tryToGetAnimation();A.not.exist(V)&&(V=ne.addComponentToEntity(ot,P).getAnimation()),V.setAnimation(`material/${g}`,y)}}}static __setNormalAnimation(n,t,o,r,i,a,s,l){let c=n[t.target.node];if(A.exist(c)){let u=c.tryToGetAnimation();if(A.not.exist(u)&&(u=ne.addComponentToEntity(ot,c).getAnimation()),A.exist(u)){let _=o.outputObject.extras.componentN,d=new Map,p=A.exist(r.name)?r.name:"Untitled_Animation",x={input:i,output:a,outputComponentN:_,interpolationMethod:Gn.fromString(s)};if(d.set(p,x),l==="translate"){let v=new $n(d,p);u.setAnimation(l,v)}else if(l==="quaternion"){let v=new Ir(d,p);u.setAnimation(l,v)}else if(l==="scale"){let v=new $n(d,p);u.setAnimation(l,v)}else{let v=new Si(d,p);u.setAnimation(l,v)}}}}static _setupSkeleton(n,t,o){if(n.skins!=null)for(let r in n.nodes){let i=n.nodes[r],a=t[r].getSceneGraph(),s;if(A.exist(i.skinObject)){let l=t[r];if(s=ne.addComponentToEntity(Pa,l).getSkeletal(),A.exist(i.skinObject.bindShapeMatrix)&&(s._bindShapeMatrix=Se.fromCopyArrayColumnMajor(i.skinObject.bindShapeMatrix)),A.exist(i.skinObject.skeleton)&&(a.isRootJoint=!0,A.exist(i.mesh))){let _=[];for(let d of i.skinObject.joints)_.push(t[d].getSceneGraph());s.setJoints(_),A.exist(i.skinObject.skeleton)?s.topOfJointsHierarchy=t[i.skinObject.skeleton].getSceneGraph():s.topOfJointsHierarchy=_[0]}for(let _ of i.skinObject.joints){let d=t[_].getSceneGraph();d.jointIndex=_}let u=i.skinObject.inverseBindMatricesObject;if(A.exist(u)){let _=this.__getRnBufferViewAndRnAccessor(u,o);s.setInverseBindMatricesAccessor(_)}}}}static __setupObjects(n,t,o,r,i){var l,c,u,_,d;let a=[],s=new Map;for(let p in n.nodes){let x=n.nodes[parseInt(p)],v;if(x.mesh!=null){let y=x.mesh,g=this.__setupMesh(x.meshObject,y,t,n,o,r,i);x.name&&g.tryToSetUniqueName(x.name,!0),(l=x.meshObject)!=null&&l.name&&g.getComponent(Nr).tryToSetUniqueName(x.meshObject.name,!0),v=g}else if(x.cameraObject!=null){let y=this.__setupCamera(x.cameraObject,n);x.name&&y.tryToSetUniqueName(x.name,!0),v=y}else if((c=x.extensions)!=null&&c.KHR_lights_punctual)v=this.__setupLight(x.extensions.KHR_lights_punctual.light,n);else{let y=this.__generateGroupEntity(n);x.name&&y.tryToSetUniqueName(x.name,!0),v=y}if(this.__isMorphing(x,n)){let y=[];if(x.weights)y=x.weights;else if((u=x.meshObject)!=null&&u.weights)y=x.meshObject.weights;else{let E=0;for(let w of x.meshObject.primitives)A.exist(w.targets)&&w.targets.length>E&&(E=w.targets.length);y=new Array(E).fill(0)}v=ne.addComponentToEntity(Zo,v);let g=v.getBlendShape();g.weights=y,(d=(_=x.meshObject)==null?void 0:_.primitives[0].extras)!=null&&d.targetNames&&(g.targetNames=x.meshObject.primitives[0].extras.targetNames)}v.tryToSetTag({tag:Ld,value:p}),a.push(v),s.set(x.name,v)}return{rnEntities:a,rnEntitiesByNames:s}}static __isMorphing(n,t){var r,i,a;let o=(i=(r=t.asset.extras)==null?void 0:r.rnLoaderOptions)==null?void 0:i.defaultMaterialHelperArgumentArray[0];return(o==null?void 0:o.isMorphing)===!1?!1:((a=n.meshObject)==null?void 0:a.primitives[0].targets)!=null}static __setupLight(n,t){var i,a;let o=this.__generateLightEntity(t),r=o.getComponent(Mo);if(n.name!=null){r.tryToSetUniqueName(n.name,!0),r.type=Fo.fromString(n.type);let s=S.fromCopyArray3([1,1,1]),l=1;n.color!=null&&(s=S.fromCopyArray3(n.color)),n.intensity!=null&&(l=n.intensity),r.color=s,r.intensity=l,n.range!=null&&(r.range=n.range),n.type==="spot"&&(((i=n.spot)==null?void 0:i.innerConeAngle)!=null&&(r.innerConeAngle=n.spot.innerConeAngle),((a=n.spot)==null?void 0:a.outerConeAngle)!=null&&(r.outerConeAngle=n.spot.outerConeAngle))}return o}static __setupCamera(n,t){let o=this.__generateCameraEntity(t),r=o.getCamera();return r.direction=S.fromCopyArray([0,0,-1]),t.asset&&t.asset.LastSaved_ApplicationVendor&&(r.direction=S.fromCopyArray([1,0,0]),r.directionInner=S.fromCopyArray([1,0,0])),r.up=S.fromCopyArray([0,1,0]),r.type=wn.fromString(n.type),r.type===wn.Perspective?(r.aspect=n.perspective.aspectRatio?n.perspective.aspectRatio:1,r.setFovyAndChangeFocalLength(Y.radianToDegree(n.perspective.yfov)),r.zNear=n.perspective.znear,r.zFar=n.perspective.zfar?n.perspective.zfar:1e5,r.tryToSetTag({tag:"OriginalFovY",value:r.fovy})):r.type===wn.Orthographic&&(r.xMag=n.orthographic.xmag,r.yMag=n.orthographic.ymag,r.zNear=n.orthographic.znear,r.zFar=n.orthographic.zfar,r.tryToSetTag({tag:"OriginalXMag",value:r.xMag}),r.tryToSetTag({tag:"OriginalYMag",value:r.yMag})),r.tryToSetTag({tag:"OriginalAspect",value:r.aspect}),o}static __setupMesh(n,t,o,r,i,a,s){var d,p,x,v,y;let l=this.__generateMeshEntity(r),c=(d=r.asset.extras.rnMeshesAtGltMeshIdx[t])==null?void 0:d.deref(),u=Re.Triangles,_=l.getMesh();if(c!=null)_.setMesh(c);else{let g=new _t,E=r.asset.extras.rnLoaderOptions;(E==null?void 0:E.tangentCalculationMode)!=null&&(g.tangentCalculationMode=E.tangentCalculationMode);let w=h((T,R)=>{let P=R.materialVariants;if(!A.not.exist(P))for(let V of P){let z=i[V.material];for(let k of V.variants)T.setMaterialVariant(k,z)}},"setupMaterialVariants");for(let T in n.primitives){let R=n.primitives[T];R.mode!=null&&(u=Re.from(R.mode));let P=new $e,V=R.material!=null?i[R.material]:this.__setupMaterial(r,a,s);if(w(P,R),V.materialTypeName.indexOf("MToon")!==-1){let W=r.extensions.VRM;if((W==null?void 0:W.rnExtension)!=null){let j=W.rnExtension.renderPassOutline,ae=(v=(x=(p=R.materialObject)==null?void 0:p.extras)==null?void 0:x.outlineMaterial)==null?void 0:v.deref();ae!=null&&(j.setMaterialForPrimitive(ae,P),P.setMaterialVariant("outline",ae))}}let z,k=new Map;if((y=R.extensions)!=null&&y.KHR_draco_mesh_compression){if(z=this.__decodeDraco(R,o,r,k),A.not.exist(z))break}else{A.exist(R.indices)&&(z=this.__getRnBufferViewAndRnAccessor(R.indicesObject,o));let W=new Map;for(let X in R.attributesObjects){let j=R.attributesObjects[X],ae=o[j.bufferViewObject.buffer],le;A.exist(j.bufferView)?(le=W.get(j.bufferView),A.not.exist(le)&&(le=this.__getRnBufferView(j.bufferViewObject,ae),W.set(j.bufferView,le))):le=ae.takeBufferView({byteLengthToNeed:0,byteStride:0}).unwrapForce();let ze=this.__getRnAccessor(j,le),At=ee.toVertexAttributeSemanticJoinedStringAsGltfStyle(ee.fromString(X));k.set(At,ze)}}if(P.setData(k,u,V,z),R.targets!=null){let W=F.maxMorphTargetNumber;(E==null?void 0:E.maxMorphTargetNumber)!=null&&(W=E.maxMorphTargetNumber);let X=[];for(let j=0;j<R.targetsObjects.length&&!(j>=W);j++){let ae=R.targetsObjects[j],le=new Map;for(let ze in ae){let At=ae[ze],Be=this.__getRnBufferViewAndRnAccessor(At,o),Fn=this.__copyRnAccessorAndBufferView(Be),Sn=ee.fromString(ze),cn=ee.toVertexAttributeSemanticJoinedStringAsGltfStyle(Sn);le.set(cn,Fn)}X.push(le)}P.setBlendShapeTargets(X)}g.addPrimitive(P)}_.setMesh(g),r.asset.extras.rnMeshesAtGltMeshIdx[t]=new WeakRef(g)}return l}static setSparseAccessor(n,t){var P,V,z,k;let o=n.sparse.count,r=n.sparse.indices,i=r.bufferViewObject,a=r.bufferViewObject.bufferObject.buffer,s=((P=i.byteOffset)!=null?P:0)+((V=r.byteOffset)!=null?V:0),l=this._checkBytesPerComponent(r),c=l*o,u=new DataView(a.buffer,s+a.byteOffset,c),_=this._checkDataViewMethod(r),d=n.sparse.values,p=d.bufferViewObject;a=d.bufferViewObject.bufferObject.buffer;let x=((z=p.byteOffset)!=null?z:0)+((k=d.byteOffset)!=null?k:0),v=this._checkBytesPerComponent(n),y=this._checkComponentNumber(n),g=v*y*o,E=new DataView(a.buffer,x+a.byteOffset,g),w=this._checkDataViewMethod(n),T=t.getTypedArray(),R=!0;for(let W=0;W<o;W++){let X=u[_](l*W,R);for(let j=0;j<y;j++){let ae=E[w](v*y*W+v*j,R);T[X*y+j]=ae}}}static __setVRM1Material(n,t,o){var a;let r=n.extensions.VRM,i=(a=t.extensions)==null?void 0:a.VRMC_materials_mtoon;if(i!=null){let s=o.defaultMaterialHelperArgumentArray[0],l=s.additionalName,c=!0,u=!0,_=this.__isLighting(n,t),d=!0,p=s.textures,x=s.samplers,v=s.debugMode,y=s.maxInstancesNumber,g=this.__makeOutputSrgb(n),E;if(A.exist(r==null?void 0:r.rnExtension)&&(E=r.rnExtension.renderPassOutline,E.isVrRendering=!0,E.tryToSetUniqueName("VRM Outline RenderPass",!0)),E!=null){let T;i.outlineWidthMode!=="none"&&(T=Oe.createMToon1Material({additionalName:l,isMorphing:c,isSkinning:u,isLighting:_,useTangentAttribute:d,isOutline:!0,materialJson:t,textures:p,samplers:x,debugMode:v,maxInstancesNumber:y,makeOutputSrgb:g})),A.exist(T)&&(t.extras.outlineMaterial=new WeakRef(T))}let w=Oe.createMToon1Material({additionalName:l,isMorphing:c,isSkinning:u,isLighting:_,useTangentAttribute:d,isOutline:!1,materialJson:t,textures:p,samplers:x,debugMode:v,maxInstancesNumber:y,makeOutputSrgb:g});return t.extensions.KHR_materials_unlit=void 0,w}}static setMToonTextures(n,t,o,r){let i=n[t.textureProperties._MainTex];i!=null&&o.setTextureParameter("litColorTexture",i,r[t.textureProperties._MainTex]);let a=n[t.textureProperties._ShadeTexture];a!=null&&o.setTextureParameter("shadeColorTexture",a,r[t.textureProperties._ShadeTexture]);let s=n[t.textureProperties._ReceiveShadowTexture];s!=null&&o.setTextureParameter("receiveShadowTexture",s,r[t.textureProperties._ReceiveShadowTexture]);let l=n[t.textureProperties._ShadingGradeTexture];l!=null&&o.setTextureParameter("shadingGradeTexture",l,r[t.textureProperties._ShadingGradeTexture]);let c=n[t.textureProperties._RimTexture];c!=null&&o.setTextureParameter("rimTexture",c,r[t.textureProperties._RimTexture]);let u=n[t.textureProperties._SphereAdd];u!=null&&o.setTextureParameter("matCapTexture",u,r[t.textureProperties._SphereAdd]);let _=n[t.textureProperties._EmissionMap];_!=null&&o.setTextureParameter("emissionTexture",_,r[t.textureProperties._EmissionMap]);let d=n[t.textureProperties._BumpMap];d!=null&&o.setTextureParameter("normalTexture",d,r[t.textureProperties._BumpMap]);let p=n[t.textureProperties._OutlineWidthTexture];p!=null&&o.setTextureParameter("outlineWidthTexture",p,r[t.textureProperties._OutlineWidthTexture]);let x=n[t.textureProperties._UvAnimMaskTexture];x!=null&&o.setTextureParameter("uvAnimationMaskTexture",x,r[t.textureProperties._UvAnimMaskTexture])}static __setVRM0xMaterial(n,t,o){let r=n.extensions.VRM,i=t.extras.vrm0xMaterialProperty;if(i.shader==="VRM/MToon"){let s=o.defaultMaterialHelperArgumentArray[0],l=s.additionalName,c=!0,u=!0,_=this.__isLighting(n,t),d=!0,p=s.textures,x=s.samplers,v=s.debugMode,y=s.maxInstancesNumber,g=this.__makeOutputSrgb(n),E;if(A.exist(r==null?void 0:r.rnExtension)&&(E=r.rnExtension.renderPassOutline,E.isVrRendering=!0,E.tryToSetUniqueName("VRM Outline RenderPass",!0)),E!=null){let T;i.floatProperties._OutlineWidthMode!==0&&(T=Oe.createMToon0xMaterial({additionalName:l,isMorphing:c,isSkinning:u,isLighting:_,useTangentAttribute:d,isOutline:!0,materialProperties:i,textures:p,samplers:x,debugMode:v,maxInstancesNumber:y,makeOutputSrgb:g})),A.exist(T)&&(vo.setMToonTextures(p,i,T,x),t.extras.outlineMaterial=new WeakRef(T))}let w=Oe.createMToon0xMaterial({additionalName:l,isMorphing:c,isSkinning:u,isLighting:_,useTangentAttribute:d,isOutline:!1,materialProperties:i,textures:p,samplers:x,debugMode:v,maxInstancesNumber:y,makeOutputSrgb:g});return vo.setMToonTextures(p,i,w,x),w}}static __generateAppropriateMaterial(n,t){var c,u,_,d,p,x,v,y,g,E,w,T,R,P,V,z,k,W,X;let o=A.exist((c=t==null?void 0:t.extensions)==null?void 0:c.KHR_materials_transmission);if(((u=n.asset.extras)==null?void 0:u.rnLoaderOptions)!=null){let j=n.asset.extras.rnLoaderOptions;if(((_=j.loaderExtension)==null?void 0:_.isNeededToUseThisMaterial)!=null&&j.loaderExtension.isNeededToUseThisMaterial(n)){let le=(p=(d=n.asset.extras)==null?void 0:d.rnLoaderOptions)==null?void 0:p.loaderExtension;if((le==null?void 0:le.generateMaterial)!=null)return le.generateMaterial(t)}if(j.__isImportVRM0x){let le=this.__setVRM0xMaterial(n,t,j);if(A.exist(le))return le.isTranslucent=o,le}let ae=j.defaultMaterialHelperName;if(ae!=null)return Oe[ae](...j.defaultMaterialHelperArgumentArray)}let r=!0,i=!0,a=this.__isLighting(n,t),s="";if(A.exist(t)&&((x=t.extensions)==null?void 0:x.VRMC_materials_mtoon)!=null){let j=n.asset.extras.rnLoaderOptions,ae=this.__setVRM1Material(n,t,j);if(A.exist(ae))return ae.isTranslucent=o,ae}let l=F.maxMaterialInstanceForEachType;if(parseFloat((v=n.asset)==null?void 0:v.version)>=2){let j=(g=(y=n.asset.extras)==null?void 0:y.rnLoaderOptions)!=null?g:{},ae=!0,le=this.__useNormalTexture(n),ze=Oe.createPbrUberMaterial({isMorphing:r,isSkinning:i,isLighting:a,isClearCoat:A.exist((E=t==null?void 0:t.extensions)==null?void 0:E.KHR_materials_clearcoat),isTransmission:A.exist((w=t==null?void 0:t.extensions)==null?void 0:w.KHR_materials_transmission),isVolume:A.exist((T=t==null?void 0:t.extensions)==null?void 0:T.KHR_materials_volume),isSheen:A.exist((R=t==null?void 0:t.extensions)==null?void 0:R.KHR_materials_sheen),isSpecular:A.exist((P=t==null?void 0:t.extensions)==null?void 0:P.KHR_materials_specular),isIridescence:A.exist((V=t==null?void 0:t.extensions)==null?void 0:V.KHR_materials_iridescence),isAnisotropy:A.exist((z=t==null?void 0:t.extensions)==null?void 0:z.KHR_materials_anisotropy),isDispersion:A.exist((k=t==null?void 0:t.extensions)==null?void 0:k.KHR_materials_dispersion),isEmissiveStrength:A.exist((W=t==null?void 0:t.extensions)==null?void 0:W.KHR_materials_emissive_strength),isDiffuseTransmission:A.exist((X=t==null?void 0:t.extensions)==null?void 0:X.KHR_materials_diffuse_transmission),isShadow:!!j.shadow,useTangentAttribute:ae,useNormalTexture:le,additionalName:s,maxInstancesNumber:l}),At=this.__makeOutputSrgb(n);return A.exist(At)&&ze.setParameter("makeOutputSrgb",At),ze.isTranslucent=o,ze}else{let j=Oe.createClassicUberMaterial({isSkinning:i,isLighting:a,additionalName:s,maxInstancesNumber:l});return j.isTranslucent=o,j}}static __isLighting(n,t){var r,i,a,s;let o=(a=(i=(r=n==null?void 0:n.asset)==null?void 0:r.extras)==null?void 0:i.rnLoaderOptions)==null?void 0:a.defaultMaterialHelperArgumentArray[0];return(o==null?void 0:o.isLighting)!=null?o.isLighting:((s=t==null?void 0:t.extensions)==null?void 0:s.KHR_materials_unlit)==null}static __useTangentAttribute(n,t){var r,i,a;switch((a=(i=(r=n==null?void 0:n.asset)==null?void 0:r.extras)==null?void 0:i.rnLoaderOptions)==null?void 0:a.tangentCalculationMode){case 0:return!1;case 1:break;case 2:return!0;case 3:return!1;case 4:return!0;default:}for(let s in t.attributes)if(s==="TANGENT")return!0;return!1}static __useNormalTexture(n){var o,r,i,a,s,l;let t=(i=(r=(o=n==null?void 0:n.asset)==null?void 0:o.extras)==null?void 0:r.rnLoaderOptions)==null?void 0:i.defaultMaterialHelperArgumentArray[0];return(t==null?void 0:t.useNormalTexture)===!1?!1:((l=(s=(a=n==null?void 0:n.asset)==null?void 0:a.extras)==null?void 0:s.rnLoaderOptions)==null?void 0:l.tangentCalculationMode)!==0}static __makeOutputSrgb(n){var o,r,i;let t=(i=(r=(o=n==null?void 0:n.asset)==null?void 0:o.extras)==null?void 0:r.rnLoaderOptions)==null?void 0:i.defaultMaterialHelperArgumentArray[0];return t==null?void 0:t.makeOutputSrgb}static __setupMaterial(n,t,o,r){var a;let i=this.__generateAppropriateMaterial(n,r);return r==null||(vo.setParametersToMaterial(r,n,i,t,o,!1),((a=r.extras)==null?void 0:a.outlineMaterial)!=null&&vo.setParametersToMaterial(r,n,r.extras.outlineMaterial.deref(),t,o,!0)),i}static setParametersToMaterial(n,t,o,r,i,a){var v,y,g,E,w,T,R,P,V,z,k;let s=((v=n.extensions)==null?void 0:v.KHR_materials_unlit)!=null,l=t.asset.extras.rnLoaderOptions,c=n.pbrMetallicRoughness;if(c!=null)hX(c,o,t,l,n,r,i);else{let W=To.Phong.index;if((y=n==null?void 0:n.extras)!=null&&y.technique){switch(n.extras.technique){case To.Constant.str:W=To.Constant.index;break;case To.Lambert.str:W=To.Lambert.index;break;case To.BlinnPhong.str:W=To.BlinnPhong.index;break;case To.Phong.str:W=To.Phong.index;break}o.setParameter("shadingModel",te.fromCopyNumber(W))}}let u=s?[0,0,0]:n.emissiveFactor;u!=null&&o.setParameter("emissiveFactor",S.fromCopyArray3(u));let _=n.emissiveTexture;if(_!=null&&A.falsy(s)){let W=r[_.texture.source],X=i[_.texture.sampler];o.setTextureParameter("emissiveTexture",W,X),parseFloat((g=t.asset)==null?void 0:g.version)>=2&&_.texCoord!=null&&o.setParameter("emissiveTexcoordIndex",_.texCoord),vo._setupTextureTransform(_,o,"emissiveTextureTransformScale","emissiveTextureTransformOffset","emissiveTextureTransformRotation")}let d=n.alphaMode;l!=null&&l.alphaMode&&(d=l.alphaMode),d!=null&&(o.alphaMode=Tt.fromGlTFString(d),o.alphaMode===Tt.Mask&&!((w=(E=t.asset.extras)==null?void 0:E.rnLoaderOptions)!=null&&w.__isImportVRM0x)&&o.setParameter("alphaCutoff",te.fromCopyNumber((T=n.alphaCutoff)!=null?T:.5))),o.isTranslucent=A.exist((R=n.extensions)==null?void 0:R.KHR_materials_transmission);let p=n.doubleSided;p!=null&&!a&&(o.cullFace=!p);let x=n.normalTexture;if(x!=null&&A.falsy(s)){let W=r[x.texture.source],X=i[x.texture.sampler];o.setTextureParameter("normalTexture",W,X),parseFloat((P=t.asset)==null?void 0:P.version)>=2&&(x.texCoord!=null&&o.setParameter("normalTexcoordIndex",x.texCoord),x.scale!=null&&o.setParameter("normalScale",x.scale))}if(vo._setupTextureTransform(x,o,"normalTextureTransformScale","normalTextureTransformOffset","normalTextureTransformRotation"),this._checkRnGltfLoaderOptionsExist(t)){let W=(z=(V=t.asset.extras)==null?void 0:V.rnLoaderOptions)==null?void 0:z.loaderExtension;(W==null?void 0:W.setupMaterial)!=null&&W.setupMaterial(t,n,o)}((k=n.extensions)==null?void 0:k.VRMC_materials_mtoon)!=null&&dX(o,t,n,r,i)}static _createSampler(n){let t=new Ge({magFilter:A.exist(n.magFilter)?U.from(n.magFilter):U.Linear,minFilter:A.exist(n.minFilter)?U.from(n.minFilter):U.Linear,wrapS:A.exist(n.wrapS)?U.from(n.wrapS):U.Repeat,wrapT:A.exist(n.wrapT)?U.from(n.wrapT):U.Repeat});return t.create(),t}static _createTexture(n,t,{autoDetectTransparency:o=!1}={}){var a,s,l;let r=(a=t.asset.extras)==null?void 0:a.rnLoaderOptions,i=new Jt;if(i.autoDetectTransparency=o,i.autoResize=(r==null?void 0:r.autoResizeTexture)===!0,n.image){let c=n.image;i.generateTextureFromImage(c),i.loadFromImgLazy()}else n.basis?i.generateTextureFromBasis(n.basis,{}):n.ktx2&&i.generateTextureFromKTX2(n.ktx2);if(n.uri)i.name=n.uri;else{let c=(s=n.mimeType)==null?void 0:s.split("/")[1];i.name=(l=n.name)!=null?l:`Untitled.${c}`}return i.tryToSetUniqueName(i.name,!0),i}static __needResizeToPowerOfTwoOnWebGl1(n){return n.wrapS!==U.ClampToEdge||n.wrapT!==U.ClampToEdge||n.minFilter!==U.Linear&&n.minFilter!==U.Nearest}static __sizeIsPowerOfTwo(n){let t=n.width,o=n.height;return(t&t-1)===0&&(o&o-1)===0}static __needParameterInitialization(n,t){return n!=null}static _checkRnGltfLoaderOptionsExist(n){var t;return!!((t=n.asset.extras)!=null&&t.rnLoaderOptions)}static __rewrapWithTypedArray(n,t,o,r){return new n(t.buffer,o+t.byteOffset,r)}static _checkBytesPerComponent(n){let t=0;switch(n.componentType){case 5120:t=1;break;case 5121:t=1;break;case 5122:t=2;break;case 5123:t=2;break;case 5124:t=4;break;case 5125:t=4;break;case 5126:t=4;break;default:break}return t}static _checkComponentNumber(n){let t=0;switch(n.type){case"SCALAR":t=1;break;case"VEC2":t=2;break;case"VEC3":t=3;break;case"VEC4":t=4;break;case"MAT4":t=16;break}return t}static _checkDataViewMethod(n){let t="";switch(n.componentType){case 5120:t="getInt8";break;case 5121:t="getUint8";break;case 5122:t="getInt16";break;case 5123:t="getUint16";break;case 5124:t="getInt32";break;case 5125:t="getUint32";break;case 5126:t="getFloat32";break;default:break}return t}static _isSystemLittleEndian(){return!!new Uint8Array(new Uint16Array([255]).buffer)[0]}static _readBinaryFromAccessorAndSetItToAccessorExtras(n,t){var p,x,v;let o=n.bufferViewObject,r=((p=o.byteOffset)!=null?p:0)+((x=n.byteOffset)!=null?x:0),a=o.bufferObject.buffer,s=this._checkComponentNumber(n),l=this._checkBytesPerComponent(n),c=this._checkDataViewMethod(n);A.not.exist(n.extras)&&(n.extras={typedDataArray:new Float32Array,componentN:0,componentBytes:4,dataViewMethod:""}),n.extras.componentN=A.exist((v=n.extras)==null?void 0:v.weightsArrayLength)?n.extras.weightsArrayLength:s,n.extras.componentBytes=l,n.extras.dataViewMethod=c;let u=l*s*n.count;if(A.exist(t)){let y=t[n.bufferViewObject.buffer],g=this.__getRnBufferView(o,y);a=this.__getRnAccessor(n,g).getUint8Array(),r=0}let _=new Float32Array,d=[];if(vo._isSystemLittleEndian()){let y=new Float32Array;c==="getFloat32"?y=this.__rewrapWithTypedArray(Float32Array,a,r,u/l):c==="getInt8"?y=new Int8Array(a,r,u/l):c==="getUint8"?y=new Uint8Array(a,r,u/l):c==="getInt16"?y=this.__rewrapWithTypedArray(Int16Array,a,r,u/l):c==="getUint16"?y=this.__rewrapWithTypedArray(Uint16Array,a,r,u/l):c==="getInt32"?y=this.__rewrapWithTypedArray(Int32Array,a,r,u/l):c==="getUint32"&&(y=this.__rewrapWithTypedArray(Uint32Array,a,r,u/l)),_=this.__normalizeTypedArrayToFloat32Array(c,y)}else{let y=new DataView(a.buffer,r+a.byteOffset,u),g=l*s,E=!0;for(let w=0;w<u;w+=g)switch(n.type){case"SCALAR":d.push(y[c](w,E));break;case"VEC2":d.push(y[c](w,E)),d.push(y[c](w+l,E));break;case"VEC3":d.push(y[c](w,E)),d.push(y[c](w+l,E)),d.push(y[c](w+l*2,E));break;case"VEC4":for(let T=0;T<4;T++)d.push(y[c](w+l*T,E));break;case"MAT4":for(let T=0;T<16;T++)d.push(y[c](w+l*T,E));break}_=this.__normalizeTypedArrayToFloat32Array(c,d)}return n.extras.typedDataArray=_,_}static __normalizeTypedArrayToFloat32Array(n,t){return n==="getInt8"?ie.normalizedInt8ArrayToFloat32Array(t):n==="getUint8"?ie.normalizedUint8ArrayToFloat32Array(t):n==="getInt16"?ie.normalizedInt16ArrayToFloat32Array(t):n==="getUint16"?ie.normalizedUint16ArrayToFloat32Array(t):n==="getInt32"?(N.error("Not considered"),new Float32Array):n==="getUint32"?(N.error("Not considered"),new Float32Array):n==="getFloat32"?new Float32Array(t):(N.error("Not considered"),new Float32Array)}static __addOffsetToIndices(n){let t=n.mesh.getPrimitiveNumber(),o=0;for(let r=0;r<t;r++){let a=n.mesh.getPrimitiveAt(r).indicesAccessor;if(a){let s=a.elementCount;for(let l=0;l<s;l++){let c=a.getScalar(l,{});a.setScalar(l,c+o,{})}o+=s}}}static __getRnAccessor(n,t){var r;let o;if(t!=null)o=t.takeAccessorWithByteOffset({compositionType:b.fromString(n.type),componentType:I.from(n.componentType),count:n.count,byteOffsetInBufferView:(r=n.byteOffset)!=null?r:0,byteStride:n.byteStride,max:n.max,min:n.min,normalized:n.normalized}).unwrapForce();else{let i=we.getInstance().createOrGetBuffer(Ce.GPUVertexData),a=b.fromString(n.type),s=I.from(n.componentType);o=i.takeBufferView({byteLengthToNeed:n.count*a.getNumberOfComponents()*s.getSizeInBytes(),byteStride:a.getNumberOfComponents()*s.getSizeInBytes()}).unwrapForce().takeAccessor({compositionType:a,componentType:s,count:n.count,max:n.max,min:n.min,normalized:n.normalized}).unwrapForce()}return A.exist(n.sparse)&&this.setSparseAccessor(n,o),o}static __getRnBufferViewAndRnAccessor(n,t){let o=n.bufferViewObject,r;if(o!=null){let a=t[o.buffer];r=this.__getRnBufferView(o,a)}return this.__getRnAccessor(n,r)}static __copyRnAccessorAndBufferView(n){let t=n.elementCount*3*4,i=we.getInstance().createOrGetBuffer(Ce.GPUVertexData).takeBufferView({byteLengthToNeed:t,byteStride:3*4}).unwrapForce().takeAccessor({compositionType:b.Vec3,componentType:I.Float,count:n.elementCount,max:n.max,min:n.min,normalized:n.normalized}).unwrapForce();return i.copyBuffer(n),i}static __takeRnBufferViewAndRnAccessorForDraco(n,t,o){let r=o.takeBufferView({byteLengthToNeed:n.count*t*4,byteStride:0}).unwrapForce();return this.__getRnAccessor(n,r)}static __getRnBufferView(n,t){var r,i;return t.takeBufferViewWithByteOffset({byteLengthToNeed:n.byteLength,byteStride:(r=n.byteStride)!=null?r:0,byteOffset:(i=n.byteOffset)!=null?i:0}).unwrapForce()}static __getGeometryFromDracoBuffer(n,t,o){let r=new n.DecoderBuffer;r.Init(new Int8Array(o),o.byteLength);let i=t.GetEncodedGeometryType(r),a,s;if(i===n.TRIANGULAR_MESH?(a=new n.Mesh,s=t.DecodeBufferToMesh(r,a)):i===n.POINT_CLOUD?(a=new n.PointCloud,s=t.DecodeBufferToPointCloud(r,a)):N.error("Unknown geometry type."),a.geometryType=i,!s.ok()||a.ptr===0){let l="Decoding failed: ";l+=s.error_msg(),N.error(l),n.destroy(t),n.destroy(a);return}return n.destroy(r),a}static __getIndicesFromDraco(n,t,o,r){if(o.geometryType!==n.TRIANGULAR_MESH)return;let a;if(r){let s=new n.DracoInt32Array;t.GetTriangleStripsFromMesh(o,s),a=new Uint32Array(s.size());for(let l=0;l<s.size();++l)a[l]=s.GetValue(l);n.destroy(s)}else{let s=o.num_faces(),l=s*3;a=new Uint32Array(l);let c=new n.DracoInt32Array;for(let u=0;u<s;++u){t.GetFaceFromMesh(o,u,c);let _=u*3;a[_]=c.GetValue(0),a[_+1]=c.GetValue(1),a[_+2]=c.GetValue(2)}n.destroy(c)}return a}static __decodeDraco(n,t,o,r){let i=o.bufferViews[n.extensions.KHR_draco_mesh_compression.bufferView],a=this.__getRnBufferView(i,t[i.buffer]),s=new Uint8Array(a.getUint8Array()).buffer,l=new DracoDecoderModule,c=new l.Decoder,u=this.__getGeometryFromDracoBuffer(l,c,s);if(u==null){l.destroy(u),l.destroy(c);return}let _=u.num_points(),d=this.__createBufferForDecompressedData(n,_),p=Re.from(n.mode),x=!1;p===Re.TriangleStrip&&(x=!0);let v=this.__getIndicesFromDraco(l,c,u,x),y=this.__takeRnBufferViewAndRnAccessorForDraco(n.indicesObject,1,d);for(let g=0;g<v.length;g++)y.setScalar(g,v[g],{});for(let g in n.attributes){let E=n.extensions.KHR_draco_mesh_compression.attributes[g],w=n.attributesObjects[g],T;if(A.not.exist(E))T=this.__getRnBufferViewAndRnAccessor(w,t);else{let P=b.fromString(w.type).getNumberOfComponents();T=this.__takeRnBufferViewAndRnAccessorForDraco(w,P,d);let V=c.GetAttributeByUniqueId(u,E),z=new l.DracoFloat32Array;c.GetAttributeFloatForAllPoints(u,V,z);for(let k=0;k<_;k++)P===1?T.setScalar(k,z.GetValue(k*P),{}):P===2?T.setVec2(k,z.GetValue(k*P),z.GetValue(k*P+1),{}):P===3?T.setVec3(k,z.GetValue(k*P),z.GetValue(k*P+1),z.GetValue(k*P+2),{}):P===4&&T.setVec4(k,z.GetValue(k*P),z.GetValue(k*P+1),z.GetValue(k*P+2),z.GetValue(k*P+3),{});l.destroy(z)}A.exist(w.sparse)&&this.setSparseAccessor(w,T);let R=ee.toVertexAttributeSemanticJoinedStringAsGltfStyle(ee.fromString(g));r.set(R,T)}return l.destroy(u),l.destroy(c),y}static _setupTextureTransform(n,t,o,r,i){var a;if((a=n==null?void 0:n.extensions)!=null&&a.KHR_texture_transform){let s=pt.fromCopyArray([1,1]),l=pt.fromCopyArray([0,0]),c=0,u=n.extensions.KHR_texture_transform;u.scale!=null&&(s.x=u.scale[0],s.y=u.scale[1]),u.offset!=null&&(l.x=u.offset[0],l.y=u.offset[1]),u.rotation!=null&&(c=u.rotation),t.setParameter(o,s),t.setParameter(r,l),t.setParameter(i,c)}}static __createBufferForDecompressedData(n,t){let o=0;if(A.exist(n.indices)){let i=n.indicesObject.count;o+=i*4}let r=n.extensions.KHR_draco_mesh_compression.attributes;for(let i in n.attributes){if(r[i]==null)continue;let a=n.attributesObjects[i],s=b.fromString(a.type).getNumberOfComponents(),l=t*s*4;o+=l}return new ei({byteLength:o,buffer:new ArrayBuffer(o),name:"Draco",byteAlign:4})}};h(vo,"ModelConverter");Ve=vo;h(dX,"setupMToon1");h(hX,"setupPbrMetallicRoughness");h(pX,"setup_KHR_materials_transmission");h(xX,"setup_KHR_materials_clearcoat");h(vX,"setup_KHR_materials_volume");h(gX,"setup_KHR_materials_sheen");h(yX,"setup_KHR_materials_specular");h(bX,"setup_KHR_materials_ior");h(AX,"setup_KHR_materials_iridescence");h(IX,"setup_KHR_materials_anisotropy");h(SX,"setup_KHR_materials_emissive_strength");h(TX,"setup_KHR_materials_dispersion");h(EX,"setup_KHR_materials_diffuse_transmission")});async function kp(m,n,t){let{profile:o,assetPath:r}=await IE(m,n),i=new yE(m,o,r);Up.set(m,i);let a=await CX(i);if(a.isOk())return Ve.convertToRhodoniteObject(a.get())}async function CX(m){let n=await so.importFromUri(m.assetUrl);return BX(m,n),n}function Wp(m,n,t){Array.from(Up.values()).forEach(o=>{o.updateFromGamepad(),Object.keys(o.components).forEach(r=>{let i=o.components[r];wX(i,o.xrInputSource.handedness,t,m)})})}function wX(m,n,t,o){let r=Bn.get(m.rootNodeName);if(A.not.exist(r))return;if(Op===0){Op=o;return}let i=(o-Op)*1e-6;switch(r){case ln.TRIGGER:RX(m,n,t,i);break;case ln.THUMBSTICK:PX(m,n,t,i);break;case ln.SQUEEZE:NX(m,n,t,i);break;case ln.BUTTON_1:case ln.BUTTON_2:case ln.BUTTON_3:case ln.BUTTON_SPECIAL:MX(m,n,t,i);break;case ln.TOUCHPAD:DX(m,n,t,i);break;default:}}function RX(m,n,t,o){let r=0,i=.1,a=Bn.get(m.rootNodeName);m.values.state===yt.ComponentState.PRESSED?(N.info(a+", "+m.values.button+", "+n),r=vi({value:m.values.button,defaultValue:0})*o):m.values.state===yt.ComponentState.TOUCHED&&(N.info(a+", "+m.values.button+", "+n),r=vi({value:m.values.button,defaultValue:0})*o),n==="right"&&(r*=-1),go.x-=r*i,go.y-=r*i,go.z-=r*i,go.x=Math.max(go.x,.05),go.y=Math.max(go.y,.05),go.z=Math.max(go.z,.05),go.x=Math.min(go.x,3),go.y=Math.min(go.y,3),go.z=Math.min(go.z,3),t.viewerScale.copyComponents(go)}function NX(m,n,t,o){let r=Bn.get(m.rootNodeName);m.values.state===yt.ComponentState.PRESSED?N.info(r+", "+m.values.button+", "+n):m.values.state===yt.ComponentState.TOUCHED&&N.info(r+", "+m.values.button+", "+n)}function PX(m,n,t,o){let r=Bn.get(m.rootNodeName),i=0,a=0,s=.25,l=.1,c=.15;m.values.state===yt.ComponentState.PRESSED?(N.info(r+", "+m.values.button+", "+m.values.state+", "+n),i=vi({value:m.values.xAxis,defaultValue:0})*o,a=vi({value:m.values.yAxis,defaultValue:0})*o):m.values.state===yt.ComponentState.TOUCHED&&(i=vi({value:m.values.xAxis,defaultValue:0})*o,a=vi({value:m.values.yAxis,defaultValue:0})*o),i=Math.min(i,1),a=Math.min(a,1);let u=L.zero();n==="right"?(t.viewerAzimuthAngle.x-=i*c,u.y-=a*l*t.viewerScale.x):(u.x+=i*s*t.viewerScale.x,u.z+=a*s*t.viewerScale.x),We.fromCopyQuaternion(t.viewerOrientation).multiply(We.rotateY(t.viewerAzimuthAngle.x)).multiplyVectorTo(u,u),t.viewerTranslate.add(u)}function MX(m,n,t,o){let r=Bn.get(m.rootNodeName);m.values.state===yt.ComponentState.PRESSED?N.info(r+", "+m.values.button+", "+m.values.state+", "+n):m.values.state===yt.ComponentState.TOUCHED&&N.info(r+", "+m.values.button+", "+m.values.state+", "+n)}function DX(m,n,t,o){if(m.values.state!==yt.ComponentState.PRESSED){if(m.values.state===yt.ComponentState.TOUCHED&&m.values.yAxis!==0){let r=m.values.yAxis}}}function BX(m,n){Object.values(m.components).forEach(t=>{if(t.touchPointNodeName){let o=n.getChildByName(t.touchPointNodeName,!0)}})}function Qp(m,n){let t=m.getTagValue("rnEntitiesByNames");Object.values(n.components).forEach(o=>{for(let r in o.visualResponses){let i=o.visualResponses[r],a=t.get(i.valueNodeName);if(A.not.exist(a)){N.warn("The entity of the controller doesn't exist");continue}if(i.valueNodeProperty==="visibility")a.getSceneGraph().isVisible=!!i.value;else if(i.valueNodeProperty==="transform"){let s=t.get(i.minNodeName),l=t.get(i.maxNodeName);if(A.not.exist(s)||A.not.exist(l)){N.warn("The min/max Node of the component of the controller doesn't exist");continue}let c=s.getTransform(),u=l.getTransform();a.getTransform().quaternion=H.qlerp(c.localRotationInner,u.localRotationInner,i.value),a.getTransform().localPosition=S.lerp(c.localPositionInner,u.localPositionInner,i.value)}}})}function Xp(m){return Up.get(m)}var Up,ln,Bn,Op,go,Hp=C(()=>{"use strict";bE();SE();Rm();Na();Ma();ge();Bo();ye();Vn();Ot();or();me();Up=new Map,ln=Object.freeze({TRIGGER:"trigger",SQUEEZE:"squeeze",TOUCHPAD:"touchpad",THUMBSTICK:"thumbstick",BUTTON_1:"button_1",BUTTON_2:"button_2",BUTTON_3:"button_3",BUTTON_SPECIAL:"button_special"}),Bn=new Map;Bn.set("a_button",ln.BUTTON_1);Bn.set("b_button",ln.BUTTON_2);Bn.set("x_button",ln.BUTTON_1);Bn.set("y_button",ln.BUTTON_2);Bn.set("thumbrest",ln.BUTTON_3);Bn.set("menu",ln.BUTTON_SPECIAL);Bn.set("xr_standard_trigger",ln.TRIGGER);Bn.set("xr_standard_squeeze",ln.SQUEEZE);Bn.set("xr_standard_thumbstick",ln.THUMBSTICK);Bn.set("xr_standard_touchpad",ln.TOUCHPAD);Bn.set("trigger",ln.TRIGGER);Bn.set("squeeze",ln.SQUEEZE);Bn.set("thumbstick",ln.THUMBSTICK);Bn.set("touchpad",ln.TOUCHPAD);h(kp,"createMotionController");h(CX,"addMotionControllerToScene");h(Wp,"updateGamePad");Op=0;h(wX,"processInput");go=L.one();h(RX,"processTriggerInput");h(NX,"processSqueezeInput");h(PX,"processThumbstickInput");h(MX,"processButtonInput");h(DX,"processTouchpadInput");h(BX,"addTouchPointDots");h(Qp,"updateMotionControllerModel");h(Xp,"getMotionController")});var qp,lf,cf,jp=C(()=>{"use strict";ft();ye();Yt();It();ef();Qn();Hp();ge();Ot();br();gi();tl();dr();Ca();me();qp=S.fromCopyArray([0,1.1,0]),lf=class lf{constructor(){f(this,"__xrSession");f(this,"__xrReferenceSpace");f(this,"__webglLayer");f(this,"__glw");f(this,"__xrViewerPose");f(this,"__isWebXRMode",!1);f(this,"__spaceType","local");f(this,"__requestedToEnterWebXR",!1);f(this,"__isReadyForWebXR",!1);f(this,"__defaultPositionInLocalSpaceMode",qp);f(this,"__canvasWidthForVR",0);f(this,"__canvasHeightForVR",0);f(this,"__viewerEntity");f(this,"__leftCameraEntity");f(this,"__rightCameraEntity");f(this,"__basePath");f(this,"__controllerEntities",[]);f(this,"__xrInputSources",[]);f(this,"__viewerTranslate",L.zero());f(this,"__viewerAzimuthAngle",ut.zero());f(this,"__viewerOrientation",Ye.identity());f(this,"__viewerScale",L.one());f(this,"__multiviewFramebufferHandle",-1);f(this,"__multiviewColorTextureHandle",-1);f(this,"__webglStereoUtil");this.__viewerEntity=en(),this.__viewerEntity.tryToSetUniqueName("WebXR Viewer",!0),this.__viewerEntity.tryToSetTag({tag:"type",value:"background-assets"}),this.__leftCameraEntity=hr(),this.__leftCameraEntity.tryToSetUniqueName("WebXR Left Camera",!0),this.__leftCameraEntity.tryToSetTag({tag:"type",value:"background-assets"}),this.__leftCameraEntity.getCamera()._xrLeft=!0,this.__rightCameraEntity=hr(),this.__rightCameraEntity.tryToSetUniqueName("WebXR Right Camera",!0),this.__rightCameraEntity.tryToSetTag({tag:"type",value:"background-assets"}),this.__rightCameraEntity.getCamera()._xrRight=!0,this.__viewerEntity.getSceneGraph().addChild(this.__leftCameraEntity.getSceneGraph()),this.__viewerEntity.getSceneGraph().addChild(this.__rightCameraEntity.getSceneGraph())}async readyForWebXR(n,t){if(typeof window=="undefined")throw new Error("This method works in Browser environment");this.__basePath=t,await Pe.getInstance().loadModule("xr");let o=G.getWebGLResourceRepository().currentWebGLContextWrapper;if(o==null)return N.error("WebGL Context is not ready yet."),[];if(this.__glw=o,await navigator.xr.isSessionSupported("immersive-vr")){if(n)n.style.display="block";else{let i=document.createElement("p"),a=document.createElement("a");a.setAttribute("id","enter-vr");let s=document.createTextNode("Enter VR");a.appendChild(s),i.appendChild(a);let l=o.canvas;l.parentNode.insertBefore(i,l),window.addEventListener("click",this.enterWebXR.bind(this))}this.__isReadyForWebXR=!0}else throw new Error("WebXR is not supported in this environment.");return[]}async enterWebXR({initialUserPosition:n,callbackOnXrSessionStart:t=h(()=>{},"callbackOnXrSessionStart"),callbackOnXrSessionEnd:o=h(()=>{},"callbackOnXrSessionEnd"),profilePriorities:r=[]}){let a=G.getWebGLResourceRepository().currentWebGLContextWrapper;if(a!=null&&this.__isReadyForWebXR){let s,l=await navigator.xr.requestSession("immersive-vr");this.__xrSession=l,l.addEventListener("end",()=>{a.__gl.bindFramebuffer(a.__gl.FRAMEBUFFER,null),this.__xrSession=void 0,this.__webglLayer=void 0,this.__xrViewerPose=void 0,this.__xrReferenceSpace=void 0,this.__spaceType="local",this.__isReadyForWebXR=!1,this.__requestedToEnterWebXR=!1,this.__xrInputSources.length=0,this.__setWebXRMode(!1),Mn._makeShaderInvalidateToAllMaterials(),this.__defaultPositionInLocalSpaceMode=qp,N.info("XRSession ends."),po.stopRenderLoop(),po.restartRenderLoop(),o()});let c=h(_=>{l.addEventListener("inputsourceschange",d=>{this.__onInputSourcesChange(d,_,r)})},"promiseFn"),u=new Promise(c);return s=await l.requestReferenceSpace("local"),this.__spaceType="local",this.__defaultPositionInLocalSpaceMode=n!=null?n:qp,this.__xrReferenceSpace=s,po.stopRenderLoop(),await this.__setupWebGLLayer(l,t),this.__requestedToEnterWebXR=!0,po.restartRenderLoop(),N.warn("End of enterWebXR."),u}else{N.error("WebGL context or WebXRSession is not ready yet.");return}}async exitWebXR(){this.__xrSession!=null&&await this.__xrSession.end()}getCanvasWidthForVr(){return this.__canvasWidthForVR}getCanvasHeightForVr(){return this.__canvasHeightForVR}getControllerEntities(){return this.__controllerEntities}get leftViewMatrix(){return this.__leftCameraEntity.getCamera().viewMatrix}get rightViewMatrix(){return this.__rightCameraEntity.getCamera().viewMatrix}get leftProjectionMatrix(){var t;let n=(t=this.__xrViewerPose)==null?void 0:t.views[0];return $.fromCopyFloat32ArrayColumnMajor(A.exist(n)?n.projectionMatrix:$.identity()._v)}get rightProjectionMatrix(){var t;let n=(t=this.__xrViewerPose)==null?void 0:t.views[1];return $.fromCopyFloat32ArrayColumnMajor(A.exist(n)?n.projectionMatrix:$.identity()._v)}get framebuffer(){var n,t;return(t=(n=this.__xrSession)==null?void 0:n.renderState.baseLayer)==null?void 0:t.framebuffer}isMultiView(){return G.getWebGLResourceRepository().isSupportMultiViewVRRendering()}get requestedToEnterWebXR(){return this.__requestedToEnterWebXR}get xrSession(){return this.__xrSession}get requestedToEnterWebVR(){return this.__requestedToEnterWebXR}get isWebXRMode(){return this.__isWebXRMode}__setWebXRMode(n){this.__isWebXRMode=n,this.__glw._isWebXRMode=n}get isReadyForWebXR(){return this.__isReadyForWebXR}static getInstance(){return this.__instance||(this.__instance=new lf),this.__instance}_getViewMatrixAt(n){return n===0?this.leftViewMatrix:this.rightViewMatrix}_getProjectMatrixAt(n){return n===0?this.leftProjectionMatrix:this.rightProjectionMatrix}_getViewportAt(n){return n===0?this._getLeftViewport():this._getRightViewport()}_getLeftViewport(){return q.fromCopyArray([0,0,this.__canvasWidthForVR/2,this.__canvasHeightForVR])}_getRightViewport(){return this.isMultiView()?q.fromCopyArray([0,0,this.__canvasWidthForVR/2,this.__canvasHeightForVR]):q.fromCopyArray([this.__canvasWidthForVR/2,0,this.__canvasWidthForVR/2,this.__canvasHeightForVR])}_setValuesToGlobalDataRepository(){this.__leftCameraEntity.getCamera().projectionMatrix=this.leftProjectionMatrix,this.__rightCameraEntity.getCamera().projectionMatrix=this.rightProjectionMatrix,this.__leftCameraEntity.getCamera().setValuesToGlobalDataRepository(),this.__rightCameraEntity.getCamera().setValuesToGlobalDataRepository()}_getCameraWorldPositionAt(n){var o;let t=(o=this.__xrViewerPose)==null?void 0:o.views[n];if(A.exist(t)){let r=t.transform.position,i=this.__defaultPositionInLocalSpaceMode,a=this.__viewerTranslate,s=S.add(S.fromCopyArray([r.x,r.y,r.z]),i);return S.fromCopyArray([(s.x+a.x)*this.__viewerScale.x,(s.y+a.y)*this.__viewerScale.y,(s.z+a.z)*this.__viewerScale.z])}else return this.__defaultPositionInLocalSpaceMode}_getCameraComponentSIDAt(n){return n===0?this.__leftCameraEntity.getCamera().componentSID:this.__rightCameraEntity.getCamera().componentSID}_getCameraComponentAt(n){return n===0?this.__leftCameraEntity.getCamera():this.__rightCameraEntity.getCamera()}_preRender(n,t){this.isWebXRMode&&this.__requestedToEnterWebXR&&t!=null&&(this.__updateView(t),this.__updateInputSources(t),Wp(n,t,{viewerTranslate:this.__viewerTranslate,viewerScale:this.__viewerScale,viewerOrientation:this.__viewerOrientation,viewerAzimuthAngle:this.__viewerAzimuthAngle}))}resetViewerTransform(){this.__viewerTranslate=L.zero(),this.__viewerAzimuthAngle=ut.zero(),this.__viewerOrientation=Ye.identity(),this.__viewerScale=L.one()}_postRender(){this.__isWebXRMode}async __onInputSourcesChange(n,t,o){this.__xrInputSources.length=0;for(let r of n.added){this.__xrInputSources.push(r);let i=await kp(r,this.__basePath,o);A.exist(i)&&(this.__controllerEntities.push(i),this.__viewerEntity.getSceneGraph().addChild(i.getSceneGraph()))}t(this.__controllerEntities)}__setCameraInfoFromXRViews(n){if(A.not.exist(n)){N.warn("xrViewerPose not exist");return}let t=n.views[0],o=n.views[1];if(A.not.exist(t)||A.not.exist(o))return;let r=n.transform.orientation;this.__viewerOrientation.x=r.x,this.__viewerOrientation.y=r.y,this.__viewerOrientation.z=r.z,this.__viewerOrientation.w=r.w;let i=$.fromCopyFloat32ArrayColumnMajor(t==null?void 0:t.transform.matrix),a=$.fromCopyFloat32ArrayColumnMajor(o==null?void 0:o.transform.matrix),s=i,l=a,c=this.__viewerScale.x,u=t.transform.position,_=L.add(this.__defaultPositionInLocalSpaceMode,this.__viewerTranslate),d=L.add(this.__defaultPositionInLocalSpaceMode,this.__viewerTranslate),p=S.fromCopyArray([u.x,u.y,u.z]),x=S.fromCopyArray([u.x,u.y,u.z]),v=L.add(this.__defaultPositionInLocalSpaceMode,this.__viewerTranslate).add(p),y=L.add(this.__defaultPositionInLocalSpaceMode,this.__viewerTranslate).add(x),g=(_.x+d.x)/2,E=(_.z+d.z)/2,w=(v.x+y.x)/2,T=(v.z+y.z)/2,R=this.__viewerEntity.getTransform();R.localPosition=S.fromCopyArray([g,0,E]),R.localScale=S.fromCopyArray([c,c,c]),R.localEulerAngles=S.fromCopyArray([0,this.__viewerAzimuthAngle.x,0]),s.translateY=v.y,s.translateX=v.x-w,s.translateZ=v.z-T,s.translateY+=p.y,s.translateX+=p.x,s.translateZ+=p.z,l.translateY=y.y,l.translateX=y.x-w,l.translateZ=y.z-T,l.translateY+=x.y,l.translateX+=x.x,l.translateZ+=x.z,this.__leftCameraEntity.getTransform().localMatrix=s,this.__rightCameraEntity.getTransform().localMatrix=l}async __setupWebGLLayer(n,t){var r;let o=(r=this.__glw)==null?void 0:r.getRawContextAsWebGL2();if(o!=null){if(await o.makeXRCompatible(),typeof window=="undefined")throw new Error("This method works in Browser environment");this.__webglLayer=new window.XRWebGLLayer(n,o);let i=this.__webglLayer;n.updateRenderState({baseLayer:i,depthNear:.01,depthFar:1e3});let a=G.getWebGLResourceRepository();this.__canvasWidthForVR=i.framebufferWidth,this.__canvasHeightForVR=i.framebufferHeight,N.info(this.__canvasWidthForVR.toString()),N.info(this.__canvasHeightForVR.toString()),Mn._makeShaderInvalidateToAllMaterials(),a.resizeCanvas(this.__canvasWidthForVR,this.__canvasHeightForVR),this.__setWebXRMode(!0),t()}else N.error("WebGL context is not ready for WebXR.")}__updateView(n){this.__xrViewerPose=n.getViewerPose(this.__xrReferenceSpace),this.__setCameraInfoFromXRViews(this.__xrViewerPose)}__updateInputSources(n){this.__xrInputSources.forEach((t,o)=>{if(A.exist(t.gripSpace)){let r=n.getPose(t.gripSpace,this.__xrReferenceSpace);if(A.exist(r)){let i=this.__controllerEntities[o];if(A.exist(i)){let a=$.fromCopyFloat32ArrayColumnMajor(r.transform.matrix),s=$.fromCopyMatrix44(a);s.translateY+=this.__defaultPositionInLocalSpaceMode.y,s.translateY+=this.__viewerTranslate.y,i.getTransform().localMatrix=s;let l=Xp(t);A.exist(l)?Qp(i,l):N.warn("motionController not found")}}}})}};h(lf,"WebXRSystem"),f(lf,"__instance");cf=lf});var Yp,ff,Dm,TE=C(()=>{"use strict";Ca();Yt();br();gi();Ot();ye();ge();me();zl();ft();Qn();ef();Yp=S.fromCopyArray([0,1.1,0]),ff=class ff{constructor(){f(this,"__oGlw",new be);f(this,"__isReadyForWebAR",!1);f(this,"__oArSession",new be);f(this,"__oWebglLayer",new be);f(this,"__spaceType","local");f(this,"__isWebARMode",!1);f(this,"__requestedToEnterWebAR",!1);f(this,"__oArViewerPose",new be);f(this,"__oArReferenceSpace",new be);f(this,"__defaultPositionInLocalSpaceMode",Yp);f(this,"__canvasWidthForAR",0);f(this,"__canvasHeightForAR",0);f(this,"_cameraEntity",hr());f(this,"__viewerTranslate",L.zero());f(this,"__viewerAzimuthAngle",ut.zero());f(this,"__viewerOrientation",Ye.identity());f(this,"__viewerScale",L.one());this._cameraEntity.tryToSetUniqueName("WebAR Viewer",!0),this._cameraEntity.tryToSetTag({tag:"type",value:"background-assets"})}static getInstance(){return this.__instance||(this.__instance=new ff),this.__instance}async readyForWebAR(n){if(typeof window=="undefined")throw new Error("This method works in Browser environment");await Pe.getInstance().loadModule("xr");let t=G.getWebGLResourceRepository().currentWebGLContextWrapper;if(t==null)throw new Error("WebGL Context is not ready yet.");if(this.__oGlw=new lt(t),await navigator.xr.isSessionSupported("immersive-ar")){if(N.info("WebAR is supported."),n)n.style.display="block";else{let r=document.createElement("p"),i=document.createElement("a");i.setAttribute("id","enter-ar");let a=document.createTextNode("Enter AR");i.appendChild(a),r.appendChild(i);let s=t.canvas;s.parentNode.insertBefore(r,s),window.addEventListener("click",this.enterWebAR.bind(this))}this.__isReadyForWebAR=!0}else throw new Error("WebAR is not supported in this environment.");return[]}async enterWebAR({initialUserPosition:n,callbackOnXrSessionStart:t=h(()=>{},"callbackOnXrSessionStart"),callbackOnXrSessionEnd:o=h(()=>{},"callbackOnXrSessionEnd")}){let i=G.getWebGLResourceRepository().currentWebGLContextWrapper;if(i!=null&&this.__isReadyForWebAR){let a=await navigator.xr.requestSession("immersive-vr");this.__oArSession=new lt(a),a.addEventListener("end",()=>{i.__gl.bindFramebuffer(i.__gl.FRAMEBUFFER,null),this.__oArSession=new be,this.__oWebglLayer=new be,this.__oArViewerPose=new be,this.__oArReferenceSpace=new be,this.__spaceType="local",this.__isReadyForWebAR=!1,this.__requestedToEnterWebAR=!1,this.__isWebARMode=!1,this.__defaultPositionInLocalSpaceMode=Yp,N.info("XRSession ends."),po.stopRenderLoop(),po.restartRenderLoop(),o()});let s=await a.requestReferenceSpace("local");this.__spaceType="local",this.__defaultPositionInLocalSpaceMode=n!=null?n:Yp,this.__oArReferenceSpace=new lt(s),po.stopRenderLoop(),await this.__setupWebGLLayer(a,t),this.__requestedToEnterWebAR=!0,po.restartRenderLoop(),N.warn("End of enterWebXR.");return}else{N.error("WebGL context or WebXRSession is not ready yet.");return}}async __setupWebGLLayer(n,t){let o=this.__oGlw.unwrapForce().getRawContext();if(o!=null){if(await o.makeXRCompatible(),typeof window=="undefined")throw new Error("This method works in Browser Environment");this.__oWebglLayer=new lt(window.XRWebGLLayer(n,o));let r=this.__oWebglLayer.unwrapForce();n.updateRenderState({baseLayer:r,depthNear:.1,depthFar:1e4});let i=G.getWebGLResourceRepository();this.__canvasWidthForAR=r.framebufferWidth,this.__canvasHeightForAR=r.framebufferHeight,N.info(this.__canvasWidthForAR.toString()),N.info(this.__canvasHeightForAR.toString()),i.resizeCanvas(this.__canvasWidthForAR,this.__canvasHeightForAR),this.__isWebARMode=!0,t()}else N.error("WebGL context is not ready for WebXR.")}async exitWebAR(){this.__oArSession.has()&&await this.__oArSession.get().end()}getCanvasWidthForVr(){return this.__canvasWidthForAR}getCanvasHeightForVr(){return this.__canvasHeightForAR}get viewMatrix(){return this._cameraEntity.getCamera().viewMatrix}__updateView(n){this.__oArViewerPose=new lt(n.getViewerPose(this.__oArReferenceSpace.unwrapForce())),this.__setCameraInfoFromXRViews(this.__oArViewerPose.unwrapForce())}__setCameraInfoFromXRViews(n){if(A.not.exist(n)){N.warn("xrViewerPose not exist");return}let t=n.views[0];if(A.not.exist(t))return;let o=n.transform.orientation;this.__viewerOrientation.x=o.x,this.__viewerOrientation.y=o.y,this.__viewerOrientation.z=o.z,this.__viewerOrientation.w=o.w;let i=$.fromCopyFloat32ArrayColumnMajor(t==null?void 0:t.transform.matrix),a=this.__viewerScale.x,s=t.transform.position,l=L.add(this.__defaultPositionInLocalSpaceMode,this.__viewerTranslate),c=S.fromCopyArray([s.x,s.y,s.z]),u=L.add(this.__defaultPositionInLocalSpaceMode,this.__viewerTranslate).add(c),_=l.x,d=l.z,p=u.x,x=u.z,v=this._cameraEntity.getTransform();v.localPosition=S.fromCopyArray([_,0,d]),v.localScale=S.fromCopyArray([a,a,a]),v.localEulerAngles=S.fromCopyArray([0,this.__viewerAzimuthAngle.x,0]),i.translateY=u.y,i.translateX=u.x-p,i.translateZ=u.z-x,i.translateY+=c.y,i.translateX+=c.x,i.translateZ+=c.z,this._cameraEntity.getTransform().localMatrix=i}get projectionMatrix(){let n=this.__oArViewerPose.unwrapForce().views[0];return $.fromCopyFloat32ArrayColumnMajor(A.exist(n)?n.projectionMatrix:$.identity()._v)}_preRender(n,t){this.isWebARMode&&this.__requestedToEnterWebAR&&t!=null&&this.__updateView(t)}_postRender(){if(this.isWebARMode){let n=this.__oGlw.unwrapForce().getRawContext()}this.requestedToEnterWebAR}get isWebARMode(){return this.__isWebARMode}get isReadyForWebAR(){return this.__isReadyForWebAR}get requestedToEnterWebAR(){return this.__requestedToEnterWebAR}get arSession(){return this.__oArSession.unwrapOrUndefined()}get framebuffer(){var n,t;return(t=(n=this.__oArSession.unwrapOrUndefined())==null?void 0:n.renderState.baseLayer)==null?void 0:t.framebuffer}};h(ff,"WebARSystem"),f(ff,"__instance");Dm=ff});var CE={};Qa(CE,{default:()=>FX});var EE,FX,LX,Kp=C(()=>{"use strict";jp();TE();EE=Object.freeze({WebXRSystem:cf,WebARSystem:Dm}),FX=EE,LX=typeof global!="undefined"?global:typeof window!="undefined"?window:void 0;LX.RnXR=EE});var uf,Pe,Qn=C(()=>{"use strict";uf=class uf{constructor(){f(this,"__modules",new Map)}async loadModule(n,t){let o;return n.toLowerCase()==="webgl"?o=await(await Promise.resolve().then(()=>(lE(),sE))).default:n.toLowerCase()==="webgpu"?o=await(await Promise.resolve().then(()=>(uE(),fE))).default:n.toLowerCase()==="effekseer"?(o=await(await Promise.resolve().then(()=>(Bp(),_E))).Effekseer,o.EffekseerComponent.wasmModuleUri=t==null?void 0:t.wasm):n.toLowerCase()==="pbr"?o=await(await Promise.resolve().then(()=>(hE(),dE))).default:n.toLowerCase()==="xr"&&(o=await(await Promise.resolve().then(()=>(Kp(),CE))).default),this.__modules.set(n,o),o}getModule(n){return this.__modules.get(n)}static getInstance(){return this.__instance||(this.__instance=new uf),this.__instance}};h(uf,"ModuleManager"),f(uf,"__instance");Pe=uf});var Bm,G,ft=C(()=>{"use strict";Qn();Ze();un();Bm=class Bm{static getCgApiResourceRepository(){let n=Z.isWebGL2Approach(K.currentProcessApproach)?"webgl":"webgpu",o=Pe.getInstance().getModule(n);return n==="webgl"?o.WebGLResourceRepository.getInstance():o==null?void 0:o.WebGpuResourceRepository.getInstance()}static getWebGLResourceRepository(){return Pe.getInstance().getModule("webgl").WebGLResourceRepository.getInstance()}static getWebGpuResourceRepository(){return Pe.getInstance().getModule("webgpu").WebGpuResourceRepository.getInstance()}};h(Bm,"CGAPIResourceRepository"),f(Bm,"InvalidCGAPIResourceUid",-1);G=Bm});var mf,gt,Er=C(()=>{"use strict";cr();jo();se();xe();ra();ft();Zt();Ao();tt();Tn();It();ye();Yt();it();Zi();Ke();Zu();Or();mf=class mf{constructor(){f(this,"__fields",new Map)}initialize(n){let t={semantic:"currentComponentSIDs",compositionType:b.ScalarArray,componentType:I.Float,arrayLength:Q.maxWellKnownTidNumber,stage:D.VertexAndPixelShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,needUniformInDataTextureMode:!0,initialValue:new ve(new Float32Array(Q.maxWellKnownTidNumber))};this.__registerProperty(t,1),this.takeOne("currentComponentSIDs");let o={semantic:"viewMatrix",compositionType:b.Mat4,componentType:I.Float,stage:D.VertexAndPixelShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:$.identity()},r={semantic:"projectionMatrix",compositionType:b.Mat4,componentType:I.Float,stage:D.VertexAndPixelShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:$.identity()},i={semantic:"viewPosition",compositionType:b.Vec3,componentType:I.Float,stage:D.VertexAndPixelShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:S.fromCopyArray([0,0,1])};this.__registerProperty(o,F.maxCameraNumber),this.__registerProperty(r,F.maxCameraNumber),this.__registerProperty(i,F.maxCameraNumber);let a=Z.isUniformApproach(n)?F.maxSkeletalBoneNumberForUniformMode:F.maxSkeletalBoneNumber,s={semantic:"boneMatrix",compositionType:b.Mat4x3Array,arrayLength:a,componentType:I.Float,stage:D.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Float32Array(0))},l={semantic:"boneQuaternion",compositionType:b.Vec4Array,arrayLength:a,componentType:I.Float,stage:D.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Float32Array(0))},c={semantic:"boneTranslateScale",compositionType:b.Vec4Array,arrayLength:a,componentType:I.Float,soloDatum:!0,stage:D.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:new ve(new Float32Array(0))},u={semantic:"boneTranslatePackedQuat",compositionType:b.Vec4Array,arrayLength:a,componentType:I.Float,stage:D.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,soloDatum:!0,initialValue:new ve(new Float32Array(0))},_={semantic:"boneScalePackedQuat",compositionType:b.Vec4Array,arrayLength:a,componentType:I.Float,soloDatum:!0,stage:D.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:new ve(new Float32Array(0))},d={semantic:"boneCompressedChunk",compositionType:b.Vec4Array,arrayLength:a,componentType:I.Float,soloDatum:!0,stage:D.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:new ve(new Float32Array(0))},p={semantic:"boneCompressedInfo",compositionType:b.Vec4,componentType:I.Float,soloDatum:!0,stage:D.VertexShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:q.zero()},x={semantic:"skinningMode",compositionType:b.Scalar,componentType:I.Int,stage:D.VertexAndPixelShader,min:0,max:1,isInternalSetting:!0,initialValue:te.fromCopyNumber(-1)};F.boneDataType===ke.Mat43x1?this.__registerProperty(s,F.maxSkeletonNumber):F.boneDataType===ke.Vec4x2?(this.__registerProperty(u,F.maxSkeletonNumber),this.__registerProperty(_,F.maxSkeletonNumber)):F.boneDataType===ke.Vec4x2Old?(this.__registerProperty(l,F.maxSkeletonNumber),this.__registerProperty(c,F.maxSkeletonNumber)):F.boneDataType===ke.Vec4x1&&(this.__registerProperty(c,F.maxSkeletonNumber),this.__registerProperty(d,F.maxSkeletonNumber),this.__registerProperty(p,1),this.takeOne("boneCompressedInfo")),this.__registerProperty(x,1),this.takeOne("skinningMode");let v={semantic:"lightPosition",compositionType:b.Vec3Array,componentType:I.Float,stage:D.VertexAndPixelShader,arrayLength:F.maxLightNumberInShader,min:-Number.MAX_VALUE,max:Number.MAX_VALUE,isInternalSetting:!0,initialValue:new ve(new Float32Array(F.maxLightNumberInShader))},y={semantic:"lightDirection",compositionType:b.Vec3Array,componentType:I.Float,stage:D.PixelShader,arrayLength:F.maxLightNumberInShader,min:-1,max:1,isInternalSetting:!0,initialValue:new ve(new Float32Array(F.maxLightNumberInShader))},g={semantic:"lightIntensity",compositionType:b.Vec3Array,componentType:I.Float,stage:D.PixelShader,arrayLength:F.maxLightNumberInShader,min:0,max:10,isInternalSetting:!0,initialValue:new ve(new Float32Array(F.maxLightNumberInShader))},E={semantic:"lightProperty",compositionType:b.Vec4Array,componentType:I.Float,stage:D.PixelShader,arrayLength:F.maxLightNumberInShader,min:0,max:10,isInternalSetting:!0,initialValue:new ve(new Float32Array(F.maxLightNumberInShader))};this.__registerProperty(v,1),this.__registerProperty(y,1),this.__registerProperty(g,1),this.__registerProperty(E,1),this.takeOne("lightDirection"),this.takeOne("lightIntensity"),this.takeOne("lightPosition"),this.takeOne("lightProperty");let w={semantic:"lightNumber",compositionType:b.Scalar,componentType:I.Int,stage:D.VertexAndPixelShader,min:0,max:Number.MAX_SAFE_INTEGER,isInternalSetting:!0,initialValue:te.fromCopyNumber(0)};this.__registerProperty(w,1),this.takeOne("lightNumber");let T={semantic:"backBufferTextureSize",compositionType:b.Vec2,componentType:I.Float,stage:D.PixelShader,min:0,max:Number.MAX_SAFE_INTEGER,isInternalSetting:!0,needUniformInDataTextureMode:!0,initialValue:Ee.fromCopy2(0,0)};this.__registerProperty(T,1),this.takeOne("backBufferTextureSize");let R={semantic:"vrState",compositionType:b.Vec2,componentType:I.Int,stage:D.PixelShader,min:0,max:Number.MAX_SAFE_INTEGER,isInternalSetting:!0,needUniformInDataTextureMode:!0,initialValue:Ee.fromCopy2(0,0)};this.__registerProperty(R,1),this.takeOne("vrState");let P={semantic:"time",compositionType:b.Scalar,componentType:I.Float,stage:D.VertexAndPixelShader,min:0,max:Number.MAX_SAFE_INTEGER,isInternalSetting:!0,initialValue:te.fromCopyNumber(0)};this.__registerProperty(P,1),this.takeOne("time")}static getInstance(){return this.__instance||(this.__instance=new mf),this.__instance}__registerProperty(n,t){let o=we.getInstance().createOrGetBuffer(Ce.GPUInstanceData),r=Kl(n),i=o.takeBufferView({byteLengthToNeed:r*t,byteStride:0}).unwrapForce(),a=n.arrayLength;b.isArray(n.compositionType)&&a==null&&(a=100);let s=i.takeAccessor({compositionType:n.compositionType,componentType:I.Float,count:t,byteStride:r,arrayLength:a}).unwrapForce(),l={shaderSemanticsInfo:n,values:[],maxCount:t,accessor:s};this.__fields.set(n.semantic,l)}takeOne(n){let t=this.__fields.get(n);if(t){let o=t.shaderSemanticsInfo,r=t.accessor.takeOne(),i=t.values.length,a=En.initWithFloat32Array(o.initialValue,o.initialValue,r,o.compositionType);return t.values[i]=a,a}}setValue(n,t,o){let r=this.__fields.get(n);if(r){let i=r.values[t];En._setForce(i,o)}}getValue(n,t){let o=this.__fields.get(n);if(o)return o.values[t]}getGlobalPropertyStruct(n){return this.__fields.get(n)}getGlobalProperties(){return Array.from(this.__fields.values())}_setUniformLocationsForUniformModeOnly(n){let t=G.getWebGLResourceRepository(),o=[];this.__fields.forEach((r,i)=>{let a=r.shaderSemanticsInfo;o.push(a)}),t.setupUniformLocations(n,o,!0)}_setUniformLocationsForDataTextureModeOnly(n){let t=G.getWebGLResourceRepository(),o=[];this.__fields.forEach((r,i)=>{let a=r.shaderSemanticsInfo;a.needUniformInDataTextureMode&&o.push(a)}),t.setupUniformLocations(n,o,!0)}setUniformValues(n){let t=G.getWebGLResourceRepository();this.__fields.forEach((o,r)=>{let i=o.shaderSemanticsInfo,a=o.values;for(let s=0;s<a.length;s++)t.setUniformValue(n,i.semantic,!0,a[s])})}getLocationOffsetOfProperty(n){let t=this.__fields.get(n);return t?t.accessor.byteOffsetInBuffer/4/4:-1}getCurrentDataNumberOfTheProperty(n){let t=this.__fields.get(n);return t?t.values.length:0}_addPropertiesStr(n,t,o,r){return this.__fields.forEach(i=>{let a=i.shaderSemanticsInfo;(a.stage===D.VertexShader||a.stage===D.VertexAndPixelShader)&&(n+=o("",a,!0,r)),(a.stage===D.PixelShader||a.stage===D.VertexAndPixelShader)&&(t+=o("",a,!0,r))}),[n,t]}};h(mf,"GlobalDataRepository"),f(mf,"__instance");gt=mf});var Fe,re,$t=C(()=>{"use strict";St();dn();at();it();ye();It();ql();yo();cr();xe();Yt();Cn();fo();Ot();wh();tt();Er();nn();Qn();ge();Cs();Ze();Ke();Wr();Bi();Fe=class Fe extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"_eyeInner",L.dummy());f(this,"_direction",L.dummy());f(this,"_directionInner",L.dummy());f(this,"_up",L.dummy());f(this,"_upInner",L.dummy());f(this,"_filmWidth",36);f(this,"_filmHeight",24);f(this,"_focalLength",20);f(this,"primitiveMode",!1);f(this,"_corner",pe.dummy());f(this,"_cornerInner",pe.dummy());f(this,"_parameters",pe.dummy());f(this,"_parametersInner",pe.dummy());f(this,"__type",wn.Perspective);f(this,"_projectionMatrix",$.dummy());f(this,"__isProjectionMatrixUpToDate",!1);f(this,"_viewMatrix",$.dummy());f(this,"__isViewMatrixUpToDate",!1);f(this,"_xrLeft",!1);f(this,"_xrRight",!1);f(this,"isSyncToLight",!1);f(this,"__frustum",new hc);f(this,"__updateCount",0);f(this,"__lastUpdateCount",-1);f(this,"__lastTransformComponentsUpdateCount",-1);f(this,"__lastLightComponentsUpdateCount",-1);f(this,"__lastCameraControllerComponentsUpdateCount",-1);if(this._setMaxNumberOfComponent(Math.max(10,Math.floor(F.maxEntityNumber/100))),this.setFovyAndChangeFocalLength(90),Fe.current===-1&&(Fe.current=o),this.registerMember(Ce.CPUGeneric,"eyeInner",L,I.Float,[0,0,0]),this.registerMember(Ce.CPUGeneric,"direction",L,I.Float,[0,0,-1]),this.registerMember(Ce.CPUGeneric,"up",L,I.Float,[0,1,0]),this.registerMember(Ce.CPUGeneric,"directionInner",L,I.Float,[0,0,-1]),this.registerMember(Ce.CPUGeneric,"upInner",L,I.Float,[0,1,0]),this.registerMember(Ce.CPUGeneric,"corner",pe,I.Float,[-1,1,1,-1]),this.registerMember(Ce.CPUGeneric,"cornerInner",pe,I.Float,[-1,1,1,-1]),this.registerMember(Ce.CPUGeneric,"parameters",pe,I.Float,[.1,1e4,90,1]),this.registerMember(Ce.CPUGeneric,"parametersInner",pe,I.Float,[.1,1e4,90,1]),this.registerMember(Ce.CPUGeneric,"projectionMatrix",$,I.Float,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.registerMember(Ce.CPUGeneric,"viewMatrix",$,I.Float,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.submitToAllocation(F.maxCameraNumber,i),i)return;let a=gt.getInstance();a.takeOne("viewMatrix"),a.takeOne("projectionMatrix"),a.takeOne("viewPosition")}static set current(t){this.__current=t}static get current(){return this.__current}get updateCount(){return this.__updateCount}static get currentCameraUpdateCount(){var o;let t=J.getComponent(Fe,Fe.current);return(o=t==null?void 0:t.updateCount)!=null?o:0}set type(t){this.__type=t,t===wn.Orthographic?(this._parameters.z=1,this._parameters.w=1,this._parametersInner.z=1,this._parametersInner.w=1):(this.setFovyAndChangeFocalLength(90),this._parameters.w=1,this._parametersInner.z=90,this._parametersInner.w=1),this.__updateCount++}get type(){return this.__type}get eye(){return Fe._eye}set eye(t){throw Error("In Rhodonite, eye is always (0,0,0). Use TransformComponent for Camera positioning.")}get eyeInner(){return this._eyeInner}set eyeInner(t){this._eyeInner.copyComponents(t),this.__updateCount++}set upInner(t){this._upInner.copyComponents(t),this.__updateCount++}set up(t){this._up.copyComponents(t),this.__updateCount++}get up(){return this._up.clone()}get upInner(){return this._upInner}set direction(t){let o=this._direction,r=t,i=this._up,s=L.crossTo(r,i,Fe.__tmpVector3_0).length()===0,l;if(s){let c=L.crossTo(o,i,Fe.__tmpVector3_1);l=L.crossTo(c,r,Fe.__tmpVector3_2)}else{let c=L.multiplyTo(r,r.dot(i),Fe.__tmpVector3_1);l=L.subtractTo(i,c,Fe.__tmpVector3_2)}this._up.copyComponents(l).normalize(),this._direction.copyComponents(r),this.__updateCount++}set directionInner(t){this._directionInner.copyComponents(t),this.__updateCount++}get direction(){return this._direction.clone()}get directionInner(){return this._directionInner}set corner(t){this._corner.copyComponents(t),this.__updateCount++}get corner(){return this._corner.clone()}set left(t){this._corner.x=t,this.__updateCount++}set leftInner(t){this._cornerInner.x=t,this.__updateCount++}get left(){return this._corner.x}set right(t){this._corner.y=t,this.__updateCount++}set rightInner(t){this._cornerInner.y=t,this.__updateCount++}get right(){return this._corner.y}set top(t){this._corner.z=t,this.__updateCount++}set topInner(t){this._cornerInner.z=t,this.__updateCount++}get top(){return this._corner.z}set bottom(t){this._corner.w=t,this.__updateCount++}set bottomInner(t){this._cornerInner.w=t,this.__updateCount++}get bottom(){return this._corner.w}set cornerInner(t){this._cornerInner.copyComponents(t),this.__updateCount++}get cornerInner(){return this._cornerInner}set parametersInner(t){this._parametersInner.copyComponents(t),this.__updateCount++}get parametersInner(){return this._parametersInner}get parameters(){return this._parameters.clone()}set zNear(t){this._parameters.x=t,this.__updateCount++}set zNearInner(t){this._parametersInner.x=t,this.__updateCount++}get zNearInner(){return this._parametersInner.x}get zNear(){return this._parameters.x}set focalLength(t){this._focalLength=t,this._parameters.z=2*Y.radianToDegree(Math.atan(this._filmHeight/(t*2))),this.__updateCount++}get focalLength(){return this._focalLength}set focalLengthInner(t){this._parametersInner.z=2*Y.radianToDegree(Math.atan(this._filmHeight/(t*2))),this.__updateCount++}get focalLengthInner(){return this._parametersInner.z}set zFar(t){this._parameters.y=t,this.__updateCount++}set zFarInner(t){this._parametersInner.y=t,this.__updateCount++}get zFarInner(){return this._parametersInner.y}get zFar(){return this._parameters.y}setFovyAndChangeFilmSize(t){this._parameters.z=t,this._filmHeight=2*this.focalLength*Math.tan(Y.degreeToRadian(t)/2),this._filmWidth=this._filmHeight*this.aspect,this.__updateCount++}setFovyAndChangeFocalLength(t){this._parameters.z=t,this._focalLength=this._filmHeight/2/Math.tan(Y.degreeToRadian(t)/2),this.__updateCount++}get fovy(){return this._parameters.z}set fovyInner(t){this._parametersInner.z=t,this.__updateCount++}set aspect(t){this._parameters.w=t,this._filmWidth=this._filmHeight*t,this.__updateCount++}set aspectInner(t){this._parametersInner.w=t,this.__updateCount++}get aspectInner(){return this._parametersInner.w}get aspect(){return this._parameters.w}set xMag(t){this._parameters.z=t,this.__updateCount++}get xMag(){return this._parameters.z}set yMag(t){this._parameters.w=t}get yMag(){return this._parameters.w}static get componentTID(){return Q.CameraComponentTID}get componentTID(){return Q.CameraComponentTID}calcProjectionMatrix(){let t=this._parametersInner.x,o=this._parametersInner.y;if(K.currentProcessApproach===Z.WebGPU)if(this.type===wn.Perspective){let r=this._parametersInner.z,i=this._parametersInner.w;i<0&&(i=K.viewportAspectRatio);let a=1/Math.tan(.5*r*Math.PI/180),s=a/i;if(this._projectionMatrix.m00=s,this._projectionMatrix.m01=0,this._projectionMatrix.m02=0,this._projectionMatrix.m03=0,this._projectionMatrix.m10=0,this._projectionMatrix.m11=a,this._projectionMatrix.m12=0,this._projectionMatrix.m13=0,this._projectionMatrix.m20=0,this._projectionMatrix.m21=0,o===1/0)this._projectionMatrix.m22=-1,this._projectionMatrix.m23=-t;else{let l=1/(t-o);this._projectionMatrix.m22=o*l,this._projectionMatrix.m23=o*t*l}this._projectionMatrix.m30=0,this._projectionMatrix.m31=0,this._projectionMatrix.m32=-1,this._projectionMatrix.m33=0}else if(this.type===wn.Orthographic){let r=this._parametersInner.z,i=this._parametersInner.w;this._projectionMatrix.setComponents(1/r,0,0,0,0,1/i,0,0,0,0,-1/(o-t),-t/(o-t),0,0,0,1)}else{let r=this._cornerInner.x,i=this._cornerInner.y,a=this._cornerInner.z,s=this._cornerInner.w,l=1/(t-o);this._projectionMatrix.setComponents(2*t/(i-r),0,(i+r)/(i-r),0,0,2*t/(a-s),(a+s)/(a-s),0,0,0,o*l,o*t*l,0,0,-1,0)}else if(this.type===wn.Perspective){let r=this._parametersInner.z,i=this._parametersInner.w;i<0&&(i=K.viewportAspectRatio);let a=1/Math.tan(.5*r*Math.PI/180),s=a/i;if(this._projectionMatrix.m00=s,this._projectionMatrix.m01=0,this._projectionMatrix.m02=0,this._projectionMatrix.m03=0,this._projectionMatrix.m10=0,this._projectionMatrix.m11=a,this._projectionMatrix.m12=0,this._projectionMatrix.m13=0,this._projectionMatrix.m20=0,this._projectionMatrix.m21=0,o===1/0)this._projectionMatrix.m22=-1,this._projectionMatrix.m23=-2*t;else{let l=1/(t-o);this._projectionMatrix.m22=(o+t)*l,this._projectionMatrix.m23=2*o*t*l}this._projectionMatrix.m30=0,this._projectionMatrix.m31=0,this._projectionMatrix.m32=-1,this._projectionMatrix.m33=0}else if(this.type===wn.Orthographic){let r=this._parametersInner.z,i=this._parametersInner.w;this._projectionMatrix.setComponents(1/r,0,0,0,0,1/i,0,0,0,0,-2/(o-t),-(o+t)/(o-t),0,0,0,1)}else{let r=this._cornerInner.x,i=this._cornerInner.y,a=this._cornerInner.z,s=this._cornerInner.w,l=1/(t-o);this._projectionMatrix.setComponents(2*t/(i-r),0,(i+r)/(i-r),0,0,2*t/(a-s),(a+s)/(a-s),0,0,0,(o+t)*l,2*o*t*l,0,0,-1,0)}return this._projectionMatrix}calcViewMatrix(){let t=this.eyeInner,o=L.subtractTo(this._directionInner,t,Fe.__tmpVector3_0).normalize(),r=L.crossTo(o,this._upInner,Fe.__tmpVector3_1).normalize(),i=L.crossTo(r,o,Fe.__tmpVector3_2);if(this._viewMatrix.setComponents(r.x,r.y,r.z,-S.dot(r,t),i.x,i.y,i.z,-S.dot(i,t),-o.x,-o.y,-o.z,S.dot(o,t),0,0,0,1),!this.primitiveMode){let a=$.invertTo(this.entity.getSceneGraph().matrixInner,Fe.__tmpMatrix44_0);this._viewMatrix.multiply(a)}return this._viewMatrix}get viewMatrix(){return this._viewMatrix}set viewMatrix(t){this._viewMatrix.copyComponents(t),this.__updateCount++}get projectionMatrix(){if(this._xrLeft||this._xrRight){let t=Pe.getInstance().getModule("xr");if(t!=null&&t.WebXRSystem.getInstance().isWebXRMode){let o=t.WebXRSystem.getInstance();if(this._xrLeft)return o.leftProjectionMatrix;if(this._xrRight)return o.rightProjectionMatrix}}return this._projectionMatrix}set projectionMatrix(t){this._projectionMatrix.copyComponents(t),this.__updateCount++}get viewProjectionMatrix(){return $.multiplyTo(this._projectionMatrix,this._viewMatrix,Fe.__tmpMatrix44_0)}get biasViewProjectionMatrix(){return $.multiplyTo(this._projectionMatrix,this._viewMatrix,Fe.__tmpMatrix44_0),K.currentProcessApproach===Z.WebGPU?$.multiplyTo(Fe.__biasMatrixWebGPU,Fe.__tmpMatrix44_0,Fe.__tmpMatrix44_1):$.multiplyTo(Fe.__biasMatrixWebGL,Fe.__tmpMatrix44_0,Fe.__tmpMatrix44_1)}setValuesToGlobalDataRepositoryOnlyMatrices(){Fe.__globalDataRepository.setValue("viewMatrix",this.componentSID,this.viewMatrix),Fe.__globalDataRepository.setValue("projectionMatrix",this.componentSID,this.projectionMatrix)}setValuesToGlobalDataRepository(){Fe.__globalDataRepository.setValue("viewMatrix",this.componentSID,this.viewMatrix),Fe.__globalDataRepository.setValue("projectionMatrix",this.componentSID,this.projectionMatrix),Fe.__globalDataRepository.setValue("viewPosition",this.componentSID,this.worldPosition)}get worldPosition(){return this.entity.getSceneGraph().matrixInner.multiplyVector3To(this.eyeInner,Fe.returnVector3),Fe.returnVector3}updateFrustum(){this.__frustum.update(this.viewMatrix,this.projectionMatrix)}get frustum(){return this.__frustum}$load(){this.moveStageTo(Ne.Logic)}$logic(){let t=this.entity.tryToGetLight(),o=t!=null?t.updateCount:-1;if(!(this.__lastUpdateCount===this.__updateCount&&this.__lastTransformComponentsUpdateCount===Et.updateCount&&this.__lastLightComponentsUpdateCount===o&&this.__lastCameraControllerComponentsUpdateCount===an.updateCount)){if(this.isSyncToLight&&A.exist(t)){if(this._eyeInner.copyComponents(Fe._eye),this._directionInner.copyComponents(this._direction),this._upInner.copyComponents(this._up),t.type===Fo.Spot)this.type=wn.Perspective,this.setFovyAndChangeFilmSize(Y.radianToDegree(t.outerConeAngle)),this._cornerInner.copyComponents(this._corner),this.aspect=1,this.zNear=.1,this.zFar=t.range!==-1?t.range:1e4,this._parametersInner.copyComponents(this._parameters);else if(t.type===Fo.Directional){this.type=wn.Orthographic;let r=t.shadowAreaSizeForDirectionalLight;this._cornerInner.copyComponents(q.fromCopy4(-r,r,r,-r)),this.aspect=1,this.zNear=.1,this.zFar=t.range!==-1?t.range:100,this._parametersInner.copyComponents(this._parameters)}}else{let r=this.entity.tryToGetCameraController();A.exist(r)?this._parametersInner.w=this._parameters.w:this.primitiveMode||(this._eyeInner.copyComponents(Fe._eye),this._directionInner.copyComponents(this._direction),this._upInner.copyComponents(this._up),this._cornerInner.copyComponents(this._corner),this._parametersInner.copyComponents(this._parameters))}this.calcViewMatrix(),!this._xrLeft&&!this._xrRight&&this.calcProjectionMatrix(),this.setValuesToGlobalDataRepository(),this.__lastUpdateCount=this.__updateCount,this.__lastTransformComponentsUpdateCount=Et.updateCount,this.__lastLightComponentsUpdateCount=o,this.__lastCameraControllerComponentsUpdateCount=an.updateCount}}static getCurrentCameraEntity(){return J.getComponent(this,this.current).entity}get entity(){return ne.getEntity(this.__entityUid)}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(s,l,c){super(s,l,c)}getCamera(){return this.getComponentByComponentTID(Q.CameraComponentTID)}},h(i,"CameraEntity"),i);return vt(t,r),t}};h(Fe,"CameraComponent"),f(Fe,"_eye",S.zero()),f(Fe,"__current",-1),f(Fe,"returnVector3",L.zero()),f(Fe,"__globalDataRepository",gt.getInstance()),f(Fe,"__tmpVector3_0",L.zero()),f(Fe,"__tmpVector3_1",L.zero()),f(Fe,"__tmpVector3_2",L.zero()),f(Fe,"__tmpMatrix44_0",$.zero()),f(Fe,"__tmpMatrix44_1",$.zero()),f(Fe,"__biasMatrixWebGL",Se.fromCopy16ColumnMajor(.5,0,0,0,0,.5,0,0,0,0,.5,0,.5,.5,.5,1)),f(Fe,"__biasMatrixWebGPU",Se.fromCopy16ColumnMajor(.5,0,0,0,0,-.5,0,0,0,0,1,0,.5,.5,0,1));re=Fe});var wE=C(()=>{"use strict"});var RE=C(()=>{"use strict";$t();wE();Ca()});var NE=C(()=>{"use strict"});function VX(){let m=hr();return ne.tryToAddComponentToEntityByTID(Q.CameraControllerComponentTID,m)}var PE=C(()=>{"use strict";at();Ca();it();h(VX,"createCameraControllerEntity")});var ME=C(()=>{"use strict";Bi();NE();PE()});var DE=C(()=>{"use strict"});var BE=C(()=>{"use strict";DE();wa();Gp()});var FE=C(()=>{"use strict"});var LE=C(()=>{"use strict";FE();rl()});var VE=C(()=>{"use strict"});var zE=C(()=>{"use strict";VE();Vi();si()});var GE=C(()=>{"use strict"});var Zp,Uo,ml=C(()=>{"use strict";dn();at();it();Cn();Kc();Zp=class Zp extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"__strategy");this.moveStageTo(Ne.Logic)}static get componentTID(){return Q.PhysicsComponentTID}get componentTID(){return Q.PhysicsComponentTID}setStrategy(t){this.__strategy=t}get strategy(){return this.__strategy}static common_$logic(){Ro.update()}$logic(){var t;(t=this.__strategy)==null||t.update()}_destroy(){super._destroy(),this.__strategy=void 0}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(s,l,c){super(s,l,c)}getPhysics(){return this.getComponentByComponentTID(Q.PhysicsComponentTID)}},h(i,"PhysicsEntity"),i);return vt(t,r),t}};h(Zp,"PhysicsComponent");Uo=Zp});function zX(){let m=en();return ne.tryToAddComponentToEntityByTID(Q.PhysicsComponentTID,m)}var OE=C(()=>{"use strict";at();dr();it();h(zX,"createPhysicsEntity")});var UE=C(()=>{"use strict";GE();ml();OE()});var kE=C(()=>{"use strict"});var WE=C(()=>{"use strict";kE();Li();dr();Wc()});var QE=C(()=>{"use strict"});var Jp,_l,XE=C(()=>{"use strict";Or();ge();Jp=class Jp{constructor(n){f(this,"__srcEntity");this.__srcEntity=n}getEntity(){return this.__srcEntity}getSrcPGRestQ(n){let t,o=n.getSceneGraph().parent;return A.exist(o)?t=o.getRotationRest(r=>{let i=r.parent;if(A.exist(i)){let a=i.entity.tryToGetVrm();return A.exist(a)}else return!0}):t=H.identity(),t}getDstPGRestQ(n){let t,o=n.getSceneGraph().parent;return A.exist(o)?t=o.getRotationRest(r=>{let i=r.parent;if(A.exist(i)){let a=i.entity.tryToGetVrm();return A.exist(a)}else return!0}):t=H.identity(),t}retargetQuaternion(n){let t=this.__srcEntity,o=t.getTransform().localRotationInner,r=t.getTransform().localRotationRestInner,i=this.getSrcPGRestQ(t),a=H.multiply(i,H.multiply(o,H.multiply(H.invert(r),H.invert(i)))),s=n.getTransform().localRotationRestInner,l=this.getDstPGRestQ(n);return H.multiply(H.invert(l),H.multiply(a,H.multiply(l,s)))}retargetTranslate(n){let t=this.__srcEntity,o=t.getTransform().localPositionInner,r=t.getTransform().localPositionRestInner,i=this.getSrcPGRestQ(t),a=S.subtract(o,r),s=i.transformVector3(a),l=n.getTransform().localPositionRestInner,c=this.getDstPGRestQ(n),u=S.add(c.transformVector3Inverse(s),l);return t.uniqueName.indexOf("hips")>=0?S.multiply(u,t.parent.scale.x):u}retargetScale(n){return this.__srcEntity.getTransform().localScaleInner}};h(Jp,"GlobalRetarget");_l=Jp});var Da,_f,$p=C(()=>{"use strict";Or();ge();Da=class Da{constructor(n){f(this,"__srcEntity");this.__srcEntity=n}getEntity(){return this.__srcEntity}getSrcPGRestQ(n){let t,o=n.getSceneGraph().parent;return A.exist(o)?t=o.getRotationRest(r=>{let i=r.parent;if(A.exist(i)){let a=i.entity.tryToGetVrm();return A.exist(a)}else return!0}):t=H.identity(),t}getDstPGRestQ(n){let t,o=n.getSceneGraph().parent;return A.exist(o)?t=o.getRotationRest(r=>{let i=r.parent;if(A.exist(i)){let a=i.entity.tryToGetVrm();return A.exist(a)}else return!0}):t=H.identity(),t}retargetQuaternion(n){let t=this.__srcEntity,o=t.getTransform().localRotationInner,r=t.getTransform().localRotationRestInner,i=this.getSrcPGRestQ(t),a=H.multiply(i,H.multiply(o,H.multiply(H.invert(r),H.invert(i)))),s=n.getTransform().localRotationRestInner,l=this.getDstPGRestQ(n),c=H.multiply(H.invert(l),H.multiply(a,H.multiply(l,s)));return H.multiply(H.multiply(Da.__rev,c),H.invert(Da.__rev))}retargetTranslate(n){let t=this.__srcEntity,o=t.getTransform().localPositionInner,r=t.getTransform().localPositionRestInner,i=this.getSrcPGRestQ(t),a=S.subtract(o,r),s=i.transformVector3(a),l=n.getTransform().localPositionRestInner,c=this.getDstPGRestQ(n),u=S.add(c.transformVector3Inverse(s),l);if(t.uniqueName.indexOf("hips")>=0){let _=S.multiply(u,t.parent.scale.x);return Da.__rev.transformVector3(_)}return u}retargetScale(n){return this.__srcEntity.getTransform().localScaleInner}};h(Da,"GlobalRetargetReverse"),f(Da,"__rev",H.fromAxisAngle(S.fromCopy3(0,1,0),Math.PI));_f=Da});var ex,df,HE=C(()=>{"use strict";ex=class ex{constructor(n){f(this,"__srcEntity");this.__srcEntity=n}getEntity(){return this.__srcEntity}retargetQuaternion(n){return this.__srcEntity.getTransform().localRotationInner}retargetTranslate(n){return this.__srcEntity.getTransform().localPositionInner}retargetScale(n){return this.__srcEntity.getTransform().localScaleInner}};h(ex,"AbsoluteAnimation");df=ex});var qE=C(()=>{"use strict";QE();XE();$p();HE()});var jE=C(()=>{"use strict"});function GX(){let m=en();return ne.tryToAddComponentToEntityByTID(Q.SkeletalComponentTID,m)}var YE=C(()=>{"use strict";at();dr();it();h(GX,"createSkeletalEntity")});var KE=C(()=>{"use strict";qE();jE();Nm();YE()});var ZE=C(()=>{"use strict"});var tx,mi,Fm=C(()=>{"use strict";dn();at();Cn();yr();it();tx=class tx extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"__expressions",new Map);f(this,"__weights",new Map);f(this,"__blendShapeComponent");f(this,"_version","");this.moveStageTo(Ne.Logic)}static get componentTID(){return Q.VrmComponentTID}get componentTID(){return Q.VrmComponentTID}setVrmExpressions(t){for(let o of t)this.__expressions.set(o.name,o),this.__weights.set(o.name,0)}setExpressionWeight(t,o){let r=this.__expressions.get(t);if(!A.not.exist(r)){this.__weights.set(t,o);for(let i of r.binds){let s=ne.getEntity(i.entityIdx).tryToGetBlendShape();A.exist(s)&&s.setWeightByIndex(i.blendShapeIdx,o)}}}getExpressionWeight(t){return this.__weights.get(t)}getExpressionNames(){return Array.from(this.__expressions.keys())}_shallowCopyFrom(t){let o=t;this.__expressions=new Map(o.__expressions),this.__weights=new Map(o.__weights),this._version=o._version}_destroy(){super._destroy()}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(l,c,u){super(l,c,u);f(this,"__vrmComponent")}getVrm(){return this.__vrmComponent===void 0&&(this.__vrmComponent=this.getComponentByComponentTID(Q.VrmComponentTID)),this.__vrmComponent}},h(i,"VrmEntity"),i);return vt(t,r),t}};h(tx,"VrmComponent");mi=tx});var JE=C(()=>{"use strict";ZE();Fm()});var $E=C(()=>{"use strict"});var nx,zi,ox=C(()=>{"use strict";dn();at();Cn();it();nx=class nx extends De{constructor(t,o,r,i){super(t,o,r,i);f(this,"__vrmConstraint");this.moveStageTo(Ne.Logic)}get entity(){return ne.getEntity(this.__entityUid)}static get componentTID(){return Q.ConstraintComponentTID}get componentTID(){return Q.ConstraintComponentTID}$logic(){this.__vrmConstraint&&this.__vrmConstraint.update()}setConstraint(t){this.__vrmConstraint=t}_destroy(){super._destroy(),this.__vrmConstraint=void 0}addThisComponentToEntity(t,o){var i;let r=(i=class extends t.constructor{constructor(s,l,c){super(s,l,c)}getConstraint(){return this.getComponentByComponentTID(Q.ConstraintComponentTID)}},h(i,"ConstraintEntity"),i);return vt(t,r),t}};h(nx,"ConstraintComponent");zi=nx});var e4=C(()=>{"use strict";sf();St();Co();Mm();dc();$t();Bi();ox();wa();rl();Vi();ml();Li();Nm();Wr();Fm();J.registerComponentClass(ui);J.registerComponentClass(ot);J.registerComponentClass(Et);J.registerComponentClass(Wt);J.registerComponentClass(Nr);J.registerComponentClass(In);J.registerComponentClass(Mo);J.registerComponentClass(an);J.registerComponentClass(re);J.registerComponentClass(Pa);J.registerComponentClass(Zo);J.registerComponentClass(Uo);J.registerComponentClass(Xr);J.registerComponentClass(mi);J.registerComponentClass(zi)});var ul=C(()=>{"use strict";_2();h2();RE();ME();BE();LE();zE();UE();WE();KE();Rp();JE();$E();it();e4()});var Bv={};Qa(Bv,{AABB:()=>jt,AABBGizmo:()=>Qc,AbsoluteAnimation:()=>df,AbstractArrayBufferBaseMathNumber:()=>uh,AbstractCameraController:()=>Xi,AbstractMaterialContent:()=>He,AbstractMatrix:()=>Wo,AbstractQuaternion:()=>Gl,AbstractShaderNode:()=>ce,AbstractTexture:()=>mn,AbstractVector:()=>pr,Accessor:()=>cs,AddShaderNode:()=>Ui,AlphaMode:()=>Tt,AnimatedQuaternion:()=>Ir,AnimatedScalar:()=>ur,AnimatedVector2:()=>zr,AnimatedVector3:()=>$n,AnimatedVector4:()=>Gr,AnimatedVectorN:()=>Si,AnimationAssigner:()=>Cx,AnimationAttribute:()=>mt,AnimationComponent:()=>ot,AnimationInterpolation:()=>Gn,AttributeColorShaderNode:()=>Gf,AttributeNormalShaderNode:()=>Of,AttributePositionShaderNode:()=>Uf,AttributeTexcoordShaderNode:()=>kf,Axis:()=>hf,BasisCompressionType:()=>On,BlendShapeComponent:()=>Zo,BlockBeginShader:()=>Kf,BlockBeginShaderNode:()=>uv,BlockEndShader:()=>Zf,BlockEndShaderNode:()=>dv,Bloom:()=>yf,BoneDataType:()=>ke,Buffer:()=>ei,BufferUse:()=>Ce,BufferView:()=>fs,CGAPIResourceRepository:()=>G,Cache:()=>S_,CameraComponent:()=>re,CameraControllerComponent:()=>an,CameraControllerType:()=>gs,CameraType:()=>wn,CapsuleCollider:()=>Nf,ClassicShadingShader:()=>Nv,ColorGradingUsingLUTsMaterialContent:()=>Fc,ColorRgb:()=>ns,ColorRgba:()=>fc,CommonShaderPart:()=>ht,ComplexVertexAttribute:()=>hx,Component:()=>De,ComponentRepository:()=>J,ComponentType:()=>I,CompositionType:()=>b,CompressionTextureType:()=>Un,Config:()=>F,ConstRgbaBlack:()=>jk,ConstRgbaWhite:()=>qk,ConstVector2_0_0:()=>rR,ConstVector2_1_1:()=>oR,ConstVector3_0_0_0:()=>WC,ConstVector3_1_1_1:()=>kC,ConstVector4_0_0_0_0:()=>HC,ConstVector4_0_0_0_1:()=>XC,ConstVector4_1_1_1_1:()=>QC,ConstantScalarVariableShaderNode:()=>Df,ConstantVariableShader:()=>Mf,ConstantVector2VariableShaderNode:()=>Bf,ConstantVector3VariableShaderNode:()=>Ff,ConstantVector4VariableShaderNode:()=>Lf,Cube:()=>io,CubeTexture:()=>Ri,CustomMaterialContent:()=>bn,DataUtil:()=>ie,DefaultTextures:()=>ga,DepthEncodeMaterialContent:()=>wc,DetectHighLuminanceMaterialContent:()=>Dc,DotProductShaderNode:()=>Ga,DrcPointCloudImporter:()=>wf,EVENT_CLICK:()=>o0,EVENT_KEY_DOWN:()=>Nw,EVENT_KEY_PRESS:()=>Mw,EVENT_KEY_UP:()=>Pw,EVENT_MOUSE_DOWN:()=>e0,EVENT_MOUSE_ENTER:()=>Cw,EVENT_MOUSE_LEAVE:()=>ww,EVENT_MOUSE_MOVE:()=>t0,EVENT_MOUSE_OVER:()=>Rw,EVENT_MOUSE_UP:()=>n0,EVENT_MOUSE_WHEEL:()=>Ew,EVENT_MSPOINTER_DOWN:()=>i0,EVENT_MSPOINTER_MOVE:()=>s0,EVENT_MSPOINTER_UP:()=>c0,EVENT_ORIENTATION_CHANGE:()=>Gw,EVENT_POINTER_CANCEL:()=>Dw,EVENT_POINTER_DOWN:()=>r0,EVENT_POINTER_ENTER:()=>Bw,EVENT_POINTER_LEAVE:()=>Fw,EVENT_POINTER_MOVE:()=>a0,EVENT_POINTER_OUT:()=>Vw,EVENT_POINTER_OVER:()=>Lw,EVENT_POINTER_UP:()=>l0,EVENT_RESIZE:()=>zw,EVENT_TOUCH_CANCEL:()=>qw,EVENT_TOUCH_DOUBLE_TAP:()=>Uw,EVENT_TOUCH_DRAG:()=>Qw,EVENT_TOUCH_END:()=>m0,EVENT_TOUCH_ENTER:()=>jw,EVENT_TOUCH_HOLD:()=>Ww,EVENT_TOUCH_LEAVE:()=>Yw,EVENT_TOUCH_LONG_TAP:()=>kw,EVENT_TOUCH_MOVE:()=>u0,EVENT_TOUCH_OUT:()=>Zw,EVENT_TOUCH_OVER:()=>Kw,EVENT_TOUCH_PINCH:()=>Hw,EVENT_TOUCH_START:()=>f0,EVENT_TOUCH_SWIPE:()=>Xw,EVENT_TOUCH_TAP:()=>Ow,Effekseer:()=>mE,EffekseerComponent:()=>Xr,EndShader:()=>Oa,Entity:()=>_s,EntityRepository:()=>ne,EntityUIDOutputMaterialContent:()=>Nc,EnumClass:()=>fe,Err:()=>Ue,EventPubSub:()=>Xl,Expression:()=>gn,FileType:()=>Yo,ForwardRenderPipeline:()=>wv,Frame:()=>ha,FrameBuffer:()=>Hr,Frustum:()=>hc,FurnaceTestMaterialContent:()=>Mc,GLTF2_EXPORT_DRACO:()=>HX,GLTF2_EXPORT_EMBEDDED:()=>qX,GLTF2_EXPORT_GLB:()=>ix,GLTF2_EXPORT_GLTF:()=>sx,GLTF2_EXPORT_NO_DOWNLOAD:()=>jX,GL_ACTIVE_ATTRIBUTES:()=>AD,GL_ACTIVE_TEXTURE:()=>qB,GL_ACTIVE_UNIFORMS:()=>ID,GL_ACTIVE_UNIFORM_BLOCKS:()=>oO,GL_ALIASED_LINE_WIDTH_RANGE:()=>vP,GL_ALIASED_POINT_SIZE_RANGE:()=>xP,GL_ALPHA:()=>aD,GL_ALPHA_BITS:()=>JP,GL_ALREADY_SIGNALED:()=>TO,GL_ALWAYS:()=>FD,GL_ANY_SAMPLES_PASSED:()=>YV,GL_ANY_SAMPLES_PASSED_CONSERVATIVE:()=>KV,GL_ARRAY_BUFFER:()=>Wu,GL_ARRAY_BUFFER_BINDING:()=>dP,GL_ATTACHED_SHADERS:()=>bD,GL_BACK:()=>NM,GL_BLEND:()=>MM,GL_BLEND_COLOR:()=>_P,GL_BLEND_DST_ALPHA:()=>uP,GL_BLEND_DST_RGB:()=>cP,GL_BLEND_EQUATION:()=>aP,GL_BLEND_EQUATION_ALPHA:()=>lP,GL_BLEND_EQUATION_RGB:()=>sP,GL_BLEND_SRC_ALPHA:()=>mP,GL_BLEND_SRC_RGB:()=>fP,GL_BLUE_BITS:()=>ZP,GL_BOOL:()=>oF,GL_BOOL_VEC2:()=>rF,GL_BOOL_VEC3:()=>iF,GL_BOOL_VEC4:()=>aF,GL_BROWSER_DEFAULT_WEBGL:()=>dM,GL_BUFFER_SIZE:()=>vM,GL_BUFFER_USAGE:()=>gM,GL_CCW:()=>qM,GL_CLAMP_TO_EDGE:()=>YB,GL_COLOR:()=>NO,GL_COLOR_ATTACHMENT0:()=>OF,GL_COLOR_ATTACHMENT0_WEBGL:()=>u6,GL_COLOR_ATTACHMENT1:()=>hz,GL_COLOR_ATTACHMENT10:()=>Sz,GL_COLOR_ATTACHMENT10_WEBGL:()=>b6,GL_COLOR_ATTACHMENT11:()=>Tz,GL_COLOR_ATTACHMENT11_WEBGL:()=>A6,GL_COLOR_ATTACHMENT12:()=>Ez,GL_COLOR_ATTACHMENT12_WEBGL:()=>I6,GL_COLOR_ATTACHMENT13:()=>Cz,GL_COLOR_ATTACHMENT13_WEBGL:()=>S6,GL_COLOR_ATTACHMENT14:()=>wz,GL_COLOR_ATTACHMENT14_WEBGL:()=>T6,GL_COLOR_ATTACHMENT15:()=>Rz,GL_COLOR_ATTACHMENT15_WEBGL:()=>E6,GL_COLOR_ATTACHMENT1_WEBGL:()=>m6,GL_COLOR_ATTACHMENT2:()=>pz,GL_COLOR_ATTACHMENT2_WEBGL:()=>_6,GL_COLOR_ATTACHMENT3:()=>xz,GL_COLOR_ATTACHMENT3_WEBGL:()=>d6,GL_COLOR_ATTACHMENT4:()=>vz,GL_COLOR_ATTACHMENT4_WEBGL:()=>h6,GL_COLOR_ATTACHMENT5:()=>gz,GL_COLOR_ATTACHMENT5_WEBGL:()=>p6,GL_COLOR_ATTACHMENT6:()=>yz,GL_COLOR_ATTACHMENT6_WEBGL:()=>x6,GL_COLOR_ATTACHMENT7:()=>bz,GL_COLOR_ATTACHMENT7_WEBGL:()=>v6,GL_COLOR_ATTACHMENT8:()=>Az,GL_COLOR_ATTACHMENT8_WEBGL:()=>g6,GL_COLOR_ATTACHMENT9:()=>Iz,GL_COLOR_ATTACHMENT9_WEBGL:()=>y6,GL_COLOR_BUFFER_BIT:()=>XN,GL_COLOR_CLEAR_VALUE:()=>kP,GL_COLOR_WRITEMASK:()=>WP,GL_COMPARE_REF_TO_TEXTURE:()=>XL,GL_COMPILE_STATUS:()=>xD,GL_COMPRESSED_R11_EAC:()=>aU,GL_COMPRESSED_RG11_EAC:()=>lU,GL_COMPRESSED_RGB8_ETC2:()=>fU,GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:()=>dU,GL_COMPRESSED_RGBA8_ETC2_EAC:()=>uU,GL_COMPRESSED_RGBA_ASTC_10X10_KHR:()=>FU,GL_COMPRESSED_RGBA_ASTC_10X5_KHR:()=>MU,GL_COMPRESSED_RGBA_ASTC_10X6_KHR:()=>DU,GL_COMPRESSED_RGBA_ASTC_10X8_KHR:()=>BU,GL_COMPRESSED_RGBA_ASTC_12X10_KHR:()=>LU,GL_COMPRESSED_RGBA_ASTC_12X12_KHR:()=>VU,GL_COMPRESSED_RGBA_ASTC_4X4_KHR:()=>SU,GL_COMPRESSED_RGBA_ASTC_5X4_KHR:()=>TU,GL_COMPRESSED_RGBA_ASTC_5X5_KHR:()=>EU,GL_COMPRESSED_RGBA_ASTC_6X5_KHR:()=>CU,GL_COMPRESSED_RGBA_ASTC_6X6_KHR:()=>wU,GL_COMPRESSED_RGBA_ASTC_8X5_KHR:()=>RU,GL_COMPRESSED_RGBA_ASTC_8X6_KHR:()=>NU,GL_COMPRESSED_RGBA_ASTC_8X8_KHR:()=>PU,GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:()=>AU,GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:()=>IU,GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:()=>gU,GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:()=>xU,GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:()=>$O,GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:()=>eU,GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:()=>tU,GL_COMPRESSED_RGB_ATC_WEBGL:()=>bU,GL_COMPRESSED_RGB_ETC1_WEBGL:()=>yU,GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG:()=>vU,GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG:()=>pU,GL_COMPRESSED_RGB_S3TC_DXT1_EXT:()=>JO,GL_COMPRESSED_SIGNED_R11_EAC:()=>sU,GL_COMPRESSED_SIGNED_RG11_EAC:()=>cU,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR:()=>YU,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR:()=>HU,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR:()=>qU,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR:()=>jU,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR:()=>KU,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR:()=>ZU,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR:()=>zU,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR:()=>GU,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR:()=>OU,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR:()=>UU,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR:()=>kU,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR:()=>WU,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR:()=>QU,GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR:()=>XU,GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:()=>_U,GL_COMPRESSED_SRGB8_ETC2:()=>mU,GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:()=>hU,GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:()=>oU,GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:()=>rU,GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:()=>iU,GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:()=>nU,GL_COMPRESSED_TEXTURE_FORMATS:()=>lM,GL_CONDITION_SATISFIED:()=>CO,GL_CONSTANT_ALPHA:()=>tP,GL_CONSTANT_COLOR:()=>$N,GL_CONTEXT_LOST_WEBGL:()=>XM,GL_COPY_READ_BUFFER:()=>Yz,GL_COPY_READ_BUFFER_BINDING:()=>Zz,GL_COPY_WRITE_BUFFER:()=>Kz,GL_COPY_WRITE_BUFFER_BINDING:()=>Jz,GL_CULL_FACE:()=>wM,GL_CULL_FACE_MODE:()=>gP,GL_CURRENT_PROGRAM:()=>DD,GL_CURRENT_QUERY:()=>HV,GL_CURRENT_QUERY_EXT:()=>q6,GL_CURRENT_VERTEX_ATTRIB:()=>yM,GL_CW:()=>HM,GL_DATA_BYTE:()=>JM,GL_DATA_FLOAT:()=>rD,GL_DATA_INT:()=>nD,GL_DATA_SHORT:()=>eD,GL_DATA_UNSIGNED_BYTE:()=>$M,GL_DATA_UNSIGNED_INT:()=>oD,GL_DATA_UNSIGNED_SHORT:()=>tD,GL_DECR:()=>XD,GL_DECR_WRAP:()=>jD,GL_DELETE_STATUS:()=>vD,GL_DEPTH:()=>PO,GL_DEPTH24_STENCIL8:()=>VG,GL_DEPTH32F_STENCIL8:()=>WO,GL_DEPTH_ATTACHMENT:()=>UF,GL_DEPTH_BITS:()=>$P,GL_DEPTH_BUFFER_BIT:()=>WN,GL_DEPTH_CLEAR_VALUE:()=>IP,GL_DEPTH_COMPONENT:()=>iD,GL_DEPTH_COMPONENT16:()=>IF,GL_DEPTH_COMPONENT24:()=>FO,GL_DEPTH_COMPONENT32F:()=>kO,GL_DEPTH_FUNC:()=>SP,GL_DEPTH_RANGE:()=>bP,GL_DEPTH_STENCIL:()=>EF,GL_DEPTH_STENCIL_ATTACHMENT:()=>WF,GL_DEPTH_TEST:()=>DM,GL_DEPTH_WRITEMASK:()=>AP,GL_DITHER:()=>BM,GL_DONT_CARE:()=>jM,GL_DRAW_BUFFER0:()=>JV,GL_DRAW_BUFFER0_WEBGL:()=>C6,GL_DRAW_BUFFER1:()=>$V,GL_DRAW_BUFFER10:()=>lz,GL_DRAW_BUFFER10_WEBGL:()=>V6,GL_DRAW_BUFFER11:()=>cz,GL_DRAW_BUFFER11_WEBGL:()=>z6,GL_DRAW_BUFFER12:()=>fz,GL_DRAW_BUFFER12_WEBGL:()=>G6,GL_DRAW_BUFFER13:()=>uz,GL_DRAW_BUFFER13_WEBGL:()=>O6,GL_DRAW_BUFFER14:()=>mz,GL_DRAW_BUFFER14_WEBGL:()=>U6,GL_DRAW_BUFFER15:()=>_z,GL_DRAW_BUFFER15_WEBGL:()=>k6,GL_DRAW_BUFFER1_WEBGL:()=>w6,GL_DRAW_BUFFER2:()=>ez,GL_DRAW_BUFFER2_WEBGL:()=>R6,GL_DRAW_BUFFER3:()=>tz,GL_DRAW_BUFFER3_WEBGL:()=>N6,GL_DRAW_BUFFER4:()=>nz,GL_DRAW_BUFFER4_WEBGL:()=>P6,GL_DRAW_BUFFER5:()=>oz,GL_DRAW_BUFFER5_WEBGL:()=>M6,GL_DRAW_BUFFER6:()=>rz,GL_DRAW_BUFFER6_WEBGL:()=>D6,GL_DRAW_BUFFER7:()=>iz,GL_DRAW_BUFFER7_WEBGL:()=>B6,GL_DRAW_BUFFER8:()=>az,GL_DRAW_BUFFER8_WEBGL:()=>F6,GL_DRAW_BUFFER9:()=>sz,GL_DRAW_BUFFER9_WEBGL:()=>L6,GL_DRAW_FRAMEBUFFER:()=>OG,GL_DRAW_FRAMEBUFFER_BINDING:()=>zG,GL_DST_ALPHA:()=>Cd,GL_DST_COLOR:()=>Rd,GL_DYNAMIC_COPY:()=>UO,GL_DYNAMIC_DRAW:()=>xM,GL_DYNAMIC_READ:()=>OO,GL_ELEMENT_ARRAY_BUFFER:()=>Md,GL_ELEMENT_ARRAY_BUFFER_BINDING:()=>hP,GL_EQUAL:()=>VD,GL_FASTEST:()=>YM,GL_FLOAT_32_UNSIGNED_INT_24_8_REV:()=>UV,GL_FLOAT_MAT2:()=>sF,GL_FLOAT_MAT2X3:()=>$z,GL_FLOAT_MAT2X4:()=>eG,GL_FLOAT_MAT3:()=>lF,GL_FLOAT_MAT3X2:()=>tG,GL_FLOAT_MAT3X4:()=>nG,GL_FLOAT_MAT4:()=>cF,GL_FLOAT_MAT4X2:()=>oG,GL_FLOAT_MAT4X3:()=>rG,GL_FLOAT_VEC2:()=>ZB,GL_FLOAT_VEC3:()=>JB,GL_FLOAT_VEC4:()=>$B,GL_FRAGMENT_SHADER:()=>hD,GL_FRAGMENT_SHADER_DERIVATIVE_HINT:()=>IL,GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES:()=>f6,GL_FRAMEBUFFER:()=>vF,GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:()=>DG,GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:()=>MG,GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:()=>wG,GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT:()=>c6,GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:()=>RG,GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT:()=>n6,GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:()=>BG,GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:()=>PG,GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:()=>VF,GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:()=>LF,GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE:()=>NG,GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:()=>FG,GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:()=>GF,GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:()=>WG,GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:()=>zF,GL_FRAMEBUFFER_BINDING:()=>KF,GL_FRAMEBUFFER_COMPLETE:()=>XF,GL_FRAMEBUFFER_DEFAULT:()=>LG,GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:()=>HF,GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS:()=>jF,GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:()=>qF,GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:()=>QG,GL_FRAMEBUFFER_UNSUPPORTED:()=>YF,GL_FRONT:()=>RM,GL_FRONT_AND_BACK:()=>PM,GL_FRONT_FACE:()=>yP,GL_FUNC_ADD:()=>oP,GL_FUNC_REVERSE_SUBTRACT:()=>iP,GL_FUNC_SUBSTRACT:()=>rP,GL_GENERATE_MIPMAP_HINT:()=>ZM,GL_GEQUAL:()=>OD,GL_GPU_DISJOINT_EXT:()=>J6,GL_GREATER:()=>GD,GL_GREEN_BITS:()=>KP,GL_HALF_FLOAT:()=>WV,GL_HALF_FLOAT_OES:()=>$U,GL_HIGH_FLOAT:()=>dF,GL_HIGH_INT:()=>xF,GL_IMPLEMENTATION_COLOR_READ_FORMAT:()=>_M,GL_IMPLEMENTATION_COLOR_READ_TYPE:()=>mM,GL_INCR:()=>QD,GL_INCR_WRAP:()=>qD,GL_INTERLEAVED_ATTRIBS:()=>yG,GL_INT_2_10_10_10_REV:()=>XV,GL_INT_SAMPLER_2D:()=>Fz,GL_INT_SAMPLER_2D_ARRAY:()=>zz,GL_INT_SAMPLER_3D:()=>Lz,GL_INT_SAMPLER_CUBE:()=>Vz,GL_INT_VEC2:()=>eF,GL_INT_VEC3:()=>tF,GL_INT_VEC4:()=>nF,GL_INVALID_ENUM:()=>UM,GL_INVALID_FRAMEBUFFER_OPERATION:()=>$F,GL_INVALID_INDEX:()=>QO,GL_INVALID_OPERATION:()=>WM,GL_INVALID_VALUE:()=>kM,GL_INVERT:()=>HD,GL_KEEP:()=>kD,GL_LEQUAL:()=>zD,GL_LESS:()=>LD,GL_LINEAR:()=>KD,GL_LINEAR_MIPMAP_LINEAR:()=>eB,GL_LINEAR_MIPMAP_NEAREST:()=>JD,GL_LINES:()=>qN,GL_LINE_LOOP:()=>jN,GL_LINE_STRIP:()=>YN,GL_LINE_WIDTH:()=>pP,GL_LINK_STATUS:()=>gD,GL_LOW_FLOAT:()=>mF,GL_LOW_INT:()=>hF,GL_LUMINANCE:()=>cD,GL_LUMINANCE_ALPHA:()=>fD,GL_MAX:()=>BO,GL_MAX_3D_TEXTURE_SIZE:()=>_L,GL_MAX_ARRAY_TEXTURE_LAYERS:()=>gL,GL_MAX_CLIENT_WAIT_TIMEOUT_WEBGL:()=>HO,GL_MAX_COLOR_ATTACHMENTS:()=>dz,GL_MAX_COLOR_ATTACHMENTS_WEBGL:()=>W6,GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:()=>tO,GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS:()=>CD,GL_MAX_COMBINED_UNIFORM_BLOCKS:()=>ZG,GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:()=>eO,GL_MAX_CUBE_MAP_TEXTURE_SIZE:()=>dB,GL_MAX_DRAW_BUFFERS:()=>ZV,GL_MAX_DRAW_BUFFERS_WEBGL:()=>Q6,GL_MAX_ELEMENTS_INDICES:()=>hL,GL_MAX_ELEMENTS_VERTICES:()=>dL,GL_MAX_ELEMENT_INDEX:()=>RL,GL_MAX_EXT:()=>i6,GL_MAX_FRAGMENT_INPUT_COMPONENTS:()=>CL,GL_MAX_FRAGMENT_UNIFORM_BLOCKS:()=>KG,GL_MAX_FRAGMENT_UNIFORM_COMPONENTS:()=>xL,GL_MAX_FRAGMENT_UNIFORM_VECTORS:()=>ND,GL_MAX_PROGRAM_TEXEL_OFFSET:()=>bL,GL_MAX_RENDERBUFFER_SIZE:()=>JF,GL_MAX_SAMPLES:()=>Wz,GL_MAX_SERVER_WAIT_TIMEOUT:()=>wL,GL_MAX_TEXTURE_IMAGE_UNITS:()=>RD,GL_MAX_TEXTURE_LOD_BIAS:()=>pL,GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:()=>KO,GL_MAX_TEXTURE_SIZE:()=>HP,GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS:()=>vG,GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS:()=>gG,GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS:()=>_G,GL_MAX_UNIFORM_BLOCK_SIZE:()=>$G,GL_MAX_UNIFORM_BUFFER_BINDINGS:()=>JG,GL_MAX_VARYING_COMPONENTS:()=>AL,GL_MAX_VARYING_VECTORS:()=>ED,GL_MAX_VERTEX_ATTRIBS:()=>SD,GL_MAX_VERTEX_OUTPUT_COMPONENTS:()=>EL,GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:()=>wD,GL_MAX_VERTEX_UNIFORM_BLOCKS:()=>YG,GL_MAX_VERTEX_UNIFORM_COMPONENTS:()=>vL,GL_MAX_VERTEX_UNIFORM_VECTORS:()=>TD,GL_MAX_VIEWPORT_DIMS:()=>qP,GL_MEDIUM_FLOAT:()=>_F,GL_MEDIUM_INT:()=>pF,GL_MIN:()=>DO,GL_MIN_EXT:()=>r6,GL_MIN_PROGRAM_TEXEL_OFFSET:()=>yL,GL_MIRRORED_REPEAT:()=>KB,GL_NEAREST:()=>YD,GL_NEAREST_MIPMAP_LINEAR:()=>$D,GL_NEAREST_MIPMAP_NEAREST:()=>ZD,GL_NEVER:()=>BD,GL_NICEST:()=>KM,GL_NONE:()=>QF,GL_NOTEQUAL:()=>UD,GL_NO_ERROR:()=>OM,GL_OBJECT_TYPE:()=>xO,GL_ONE:()=>Ad,GL_ONE_MINUS_CONSTANT_ALPHA:()=>nP,GL_ONE_MINUS_CONSTANT_COLOR:()=>eP,GL_ONE_MINUS_DST_ALPHA:()=>wd,GL_ONE_MINUS_DST_COLOR:()=>Nd,GL_ONE_MINUS_SRC_ALPHA:()=>Ed,GL_ONE_MINUS_SRC_COLOR:()=>Sd,GL_OUT_OF_MEMORY:()=>QM,GL_PACK_ALIGNMENT:()=>XP,GL_PACK_ROW_LENGTH:()=>sL,GL_PACK_SKIP_PIXELS:()=>cL,GL_PACK_SKIP_ROWS:()=>lL,GL_PIXEL_PACK_BUFFER:()=>Xz,GL_PIXEL_PACK_BUFFER_BINDING:()=>qz,GL_PIXEL_UNPACK_BUFFER:()=>Hz,GL_PIXEL_UNPACK_BUFFER_BINDING:()=>jz,GL_PIXEL_UNSIGNED_BYTE:()=>uD,GL_PIXEL_UNSIGNED_SHORT_4_4_4_4:()=>mD,GL_PIXEL_UNSIGNED_SHORT_5_5_5_1:()=>_D,GL_PIXEL_UNSIGNED_SHORT_5_6_5:()=>dD,GL_POINTS:()=>HN,GL_POLYGON_OFFSET_FACTOR:()=>nM,GL_POLYGON_OFFSET_FILL:()=>FM,GL_POLYGON_OFFSET_UNITS:()=>tM,GL_QUERY_COUNTER_BITS_EXT:()=>H6,GL_QUERY_RESULT:()=>qV,GL_QUERY_RESULT_AVAILABLE:()=>jV,GL_QUERY_RESULT_AVAILABLE_EXT:()=>Y6,GL_QUERY_RESULT_EXT:()=>j6,GL_R11F_G11F_B10F:()=>JL,GL_R16F:()=>xV,GL_R16I:()=>bV,GL_R16UI:()=>AV,GL_R32F:()=>vV,GL_R32I:()=>IV,GL_R32UI:()=>SV,GL_R8:()=>hV,GL_R8I:()=>gV,GL_R8UI:()=>yV,GL_R8_SNORM:()=>PV,GL_RASTERIZER_DISCARD:()=>SL,GL_READ_BUFFER:()=>oL,GL_READ_FRAMEBUFFER:()=>GG,GL_READ_FRAMEBUFFER_BINDING:()=>UG,GL_RED:()=>NL,GL_RED_BITS:()=>YP,GL_RED_INTEGER:()=>mV,GL_RENDERBUFFER:()=>gF,GL_RENDERBUFFER_ALPHA_SIZE:()=>DF,GL_RENDERBUFFER_BINDING:()=>ZF,GL_RENDERBUFFER_BLUE_SIZE:()=>MF,GL_RENDERBUFFER_DEPTH_SIZE:()=>BF,GL_RENDERBUFFER_GREEN_SIZE:()=>PF,GL_RENDERBUFFER_HEIGHT:()=>wF,GL_RENDERBUFFER_INTERNAL_FORMAT:()=>RF,GL_RENDERBUFFER_RED_SIZE:()=>NF,GL_RENDERBUFFER_SAMPLES:()=>kG,GL_RENDERBUFFER_STENCIL_SIZE:()=>FF,GL_RENDERBUFFER_WIDTH:()=>CF,GL_RENDERER:()=>fM,GL_REPEAT:()=>jB,GL_REPLACE:()=>WD,GL_RG:()=>Fd,GL_RG16F:()=>Dd,GL_RG16I:()=>CV,GL_RG16UI:()=>wV,GL_RG32F:()=>Bd,GL_RG32I:()=>RV,GL_RG32UI:()=>NV,GL_RG8:()=>pV,GL_RG8I:()=>TV,GL_RG8UI:()=>EV,GL_RG8_SNORM:()=>MV,GL_RGB:()=>sD,GL_RGB10_A2:()=>DL,GL_RGB10_A2UI:()=>FV,GL_RGB16F:()=>YL,GL_RGB16I:()=>cV,GL_RGB16UI:()=>oV,GL_RGB32F:()=>qL,GL_RGB32F_EXT:()=>t6,GL_RGB32I:()=>sV,GL_RGB32UI:()=>tV,GL_RGB565:()=>AF,GL_RGB5_A1:()=>bF,GL_RGB8:()=>PL,GL_RGB8I:()=>uV,GL_RGB8UI:()=>iV,GL_RGB8_SNORM:()=>DV,GL_RGB9_E5:()=>$L,GL_RGBA:()=>lD,GL_RGBA16F:()=>jL,GL_RGBA16I:()=>lV,GL_RGBA16UI:()=>nV,GL_RGBA32F:()=>HL,GL_RGBA32F_EXT:()=>e6,GL_RGBA32I:()=>aV,GL_RGBA32UI:()=>eV,GL_RGBA4:()=>yF,GL_RGBA8:()=>ML,GL_RGBA8I:()=>fV,GL_RGBA8UI:()=>rV,GL_RGBA8_SNORM:()=>BV,GL_RGBA_INTEGER:()=>dV,GL_RGB_INTEGER:()=>_V,GL_RG_INTEGER:()=>QV,GL_SAMPLER_2D:()=>fF,GL_SAMPLER_2D_ARRAY:()=>Mz,GL_SAMPLER_2D_ARRAY_SHADOW:()=>Dz,GL_SAMPLER_2D_SHADOW:()=>Pz,GL_SAMPLER_3D:()=>Nz,GL_SAMPLER_BINDING:()=>Qz,GL_SAMPLER_CUBE:()=>uF,GL_SAMPLER_CUBE_SHADOW:()=>Bz,GL_SAMPLES:()=>iM,GL_SAMPLE_ALPHA_TO_COVERAGE:()=>LM,GL_SAMPLE_BUFFERS:()=>rM,GL_SAMPLE_COVERAGE:()=>VM,GL_SAMPLE_COVERAGE_INVERT:()=>sM,GL_SAMPLE_COVERAGE_VALUE:()=>aM,GL_SCISSOR_BOX:()=>UP,GL_SCISSOR_TEST:()=>zM,GL_SEPARATE_ATTRIBS:()=>bG,GL_SHADER_TYPE:()=>PD,GL_SHADING_LANGUAGE_VERSION:()=>MD,GL_SIGNALED:()=>SO,GL_SIGNED_NORMALIZED:()=>cG,GL_SRC_ALPHA:()=>Td,GL_SRC_ALPHA_SATURATE:()=>Pd,GL_SRC_COLOR:()=>Id,GL_SRGB:()=>kL,GL_SRGB8:()=>WL,GL_SRGB8_ALPHA8:()=>QL,GL_SRGB8_ALPHA8_EXT:()=>l6,GL_SRGB_ALPHA_EXT:()=>s6,GL_SRGB_EXT:()=>a6,GL_STATIC_COPY:()=>GO,GL_STATIC_DRAW:()=>hM,GL_STATIC_READ:()=>zO,GL_STENCIL:()=>MO,GL_STENCIL_ATTACHMENT:()=>kF,GL_STENCIL_BACK_FAIL:()=>BP,GL_STENCIL_BACK_FUNC:()=>DP,GL_STENCIL_BACK_PASS_DEPTH_FAIL:()=>FP,GL_STENCIL_BACK_PASS_DEPTH_PASS:()=>LP,GL_STENCIL_BACK_REF:()=>VP,GL_STENCIL_BACK_VALUE_MASK:()=>zP,GL_STENCIL_BACK_WRITEMASK:()=>GP,GL_STENCIL_BITS:()=>eM,GL_STENCIL_BUFFER_BIT:()=>QN,GL_STENCIL_CLEAR_VALUE:()=>TP,GL_STENCIL_FAIL:()=>CP,GL_STENCIL_FUNC:()=>EP,GL_STENCIL_INDEX:()=>SF,GL_STENCIL_INDEX8:()=>TF,GL_STENCIL_PASS_DEPTH_FAIL:()=>wP,GL_STENCIL_PASS_DEPTH_PASS:()=>RP,GL_STENCIL_REF:()=>NP,GL_STENCIL_TEST:()=>GM,GL_STENCIL_VALUE_MASK:()=>PP,GL_STENCIL_WRITEMASK:()=>MP,GL_STREAM_COPY:()=>VO,GL_STREAM_DRAW:()=>pM,GL_STREAM_READ:()=>LO,GL_SUBPIXEL_BITS:()=>jP,GL_SYNC_CONDITION:()=>vO,GL_SYNC_FENCE:()=>bO,GL_SYNC_FLAGS:()=>yO,GL_SYNC_FLUSH_COMMANDS_BIT:()=>RO,GL_SYNC_GPU_COMMANDS_COMPLETE:()=>AO,GL_SYNC_STATUS:()=>gO,GL_TEXTURE:()=>iB,GL_TEXTURE0:()=>hB,GL_TEXTURE1:()=>pB,GL_TEXTURE10:()=>TB,GL_TEXTURE11:()=>EB,GL_TEXTURE12:()=>CB,GL_TEXTURE13:()=>wB,GL_TEXTURE14:()=>RB,GL_TEXTURE15:()=>NB,GL_TEXTURE16:()=>PB,GL_TEXTURE17:()=>MB,GL_TEXTURE18:()=>DB,GL_TEXTURE19:()=>BB,GL_TEXTURE2:()=>xB,GL_TEXTURE20:()=>FB,GL_TEXTURE21:()=>LB,GL_TEXTURE22:()=>VB,GL_TEXTURE23:()=>zB,GL_TEXTURE24:()=>GB,GL_TEXTURE25:()=>OB,GL_TEXTURE26:()=>UB,GL_TEXTURE27:()=>kB,GL_TEXTURE28:()=>WB,GL_TEXTURE29:()=>QB,GL_TEXTURE3:()=>vB,GL_TEXTURE30:()=>XB,GL_TEXTURE31:()=>HB,GL_TEXTURE4:()=>gB,GL_TEXTURE5:()=>yB,GL_TEXTURE6:()=>bB,GL_TEXTURE7:()=>AB,GL_TEXTURE8:()=>IB,GL_TEXTURE9:()=>SB,GL_TEXTURE_2D:()=>aa,GL_TEXTURE_2D_ARRAY:()=>KL,GL_TEXTURE_3D:()=>BL,GL_TEXTURE_BASE_LEVEL:()=>zL,GL_TEXTURE_BINDING_2D:()=>oM,GL_TEXTURE_BINDING_2D_ARRAY:()=>ZL,GL_TEXTURE_BINDING_3D:()=>fL,GL_TEXTURE_BINDING_CUBE_MAP:()=>sB,GL_TEXTURE_COMPARE_FUNC:()=>UL,GL_TEXTURE_COMPARE_MODE:()=>OL,GL_TEXTURE_CUBE_MAP:()=>aB,GL_TEXTURE_CUBE_MAP_NEGATIVE_X:()=>cB,GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:()=>uB,GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:()=>_B,GL_TEXTURE_CUBE_MAP_POSITIVE_X:()=>lB,GL_TEXTURE_CUBE_MAP_POSITIVE_Y:()=>fB,GL_TEXTURE_CUBE_MAP_POSITIVE_Z:()=>mB,GL_TEXTURE_IMMUTABLE_FORMAT:()=>LV,GL_TEXTURE_IMMUTABLE_LEVELS:()=>VV,GL_TEXTURE_MAG_FILTER:()=>tB,GL_TEXTURE_MAX_ANISOTROPY_EXT:()=>ZO,GL_TEXTURE_MAX_LEVEL:()=>GL,GL_TEXTURE_MAX_LOD:()=>VL,GL_TEXTURE_MIN_FILTER:()=>nB,GL_TEXTURE_MIN_LOD:()=>LL,GL_TEXTURE_WRAP_R:()=>FL,GL_TEXTURE_WRAP_S:()=>oB,GL_TEXTURE_WRAP_T:()=>rB,GL_TIMEOUT_EXPIRED:()=>EO,GL_TIMEOUT_IGNORED:()=>XO,GL_TIMESTAMP_EXT:()=>Z6,GL_TIME_ELAPSED_EXT:()=>K6,GL_TRANSFORM_FEEDBACK:()=>SG,GL_TRANSFORM_FEEDBACK_ACTIVE:()=>EG,GL_TRANSFORM_FEEDBACK_BINDING:()=>CG,GL_TRANSFORM_FEEDBACK_BUFFER:()=>AG,GL_TRANSFORM_FEEDBACK_BUFFER_BINDING:()=>IG,GL_TRANSFORM_FEEDBACK_BUFFER_MODE:()=>mG,GL_TRANSFORM_FEEDBACK_BUFFER_SIZE:()=>pG,GL_TRANSFORM_FEEDBACK_BUFFER_START:()=>hG,GL_TRANSFORM_FEEDBACK_PAUSED:()=>TG,GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:()=>xG,GL_TRANSFORM_FEEDBACK_VARYINGS:()=>dG,GL_TRIANGLES:()=>KN,GL_TRIANGLE_FAN:()=>JN,GL_TRIANGLE_STRIP:()=>ZN,GL_UNIFORM_ARRAY_STRIDE:()=>lO,GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS:()=>_O,GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES:()=>dO,GL_UNIFORM_BLOCK_BINDING:()=>uO,GL_UNIFORM_BLOCK_DATA_SIZE:()=>mO,GL_UNIFORM_BLOCK_INDEX:()=>aO,GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER:()=>pO,GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER:()=>hO,GL_UNIFORM_BUFFER:()=>XG,GL_UNIFORM_BUFFER_BINDING:()=>HG,GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT:()=>nO,GL_UNIFORM_BUFFER_SIZE:()=>jG,GL_UNIFORM_BUFFER_START:()=>qG,GL_UNIFORM_IS_ROW_MAJOR:()=>fO,GL_UNIFORM_MATRIX_STRIDE:()=>cO,GL_UNIFORM_OFFSET:()=>sO,GL_UNIFORM_SIZE:()=>iO,GL_UNIFORM_TYPE:()=>rO,GL_UNMASKED_RENDERER_WEBGL:()=>YO,GL_UNMASKED_VENDOR_WEBGL:()=>jO,GL_UNPACK_ALIGNMENT:()=>QP,GL_UNPACK_COLORSPACE_CONVERSION_WEBGL:()=>nL,GL_UNPACK_FLIP_Y_WEBGL:()=>eL,GL_UNPACK_IMAGE_HEIGHT:()=>mL,GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL:()=>tL,GL_UNPACK_ROW_LENGTH:()=>rL,GL_UNPACK_SKIP_IMAGES:()=>uL,GL_UNPACK_SKIP_PIXELS:()=>aL,GL_UNPACK_SKIP_ROWS:()=>iL,GL_UNSIGNALED:()=>IO,GL_UNSIGNED_INT_10F_11F_11F_REV:()=>GV,GL_UNSIGNED_INT_24_8:()=>kV,GL_UNSIGNED_INT_24_8_WEBGL:()=>JU,GL_UNSIGNED_INT_2_10_10_10_REV:()=>zV,GL_UNSIGNED_INT_5_9_9_9_REV:()=>OV,GL_UNSIGNED_INT_SAMPLER_2D:()=>Gz,GL_UNSIGNED_INT_SAMPLER_2D_ARRAY:()=>kz,GL_UNSIGNED_INT_SAMPLER_3D:()=>Oz,GL_UNSIGNED_INT_SAMPLER_CUBE:()=>Uz,GL_UNSIGNED_INT_VEC2:()=>iG,GL_UNSIGNED_INT_VEC3:()=>aG,GL_UNSIGNED_INT_VEC4:()=>sG,GL_UNSIGNED_NORMALIZED:()=>lG,GL_UNSIGNED_NORMALIZED_EXT:()=>o6,GL_VALIDATE_STATUS:()=>yD,GL_VENDOR:()=>cM,GL_VERSION:()=>uM,GL_VERTEX_ARRAY_BINDING:()=>TL,GL_VERTEX_ARRAY_BINDING_OES:()=>X6,GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:()=>CM,GL_VERTEX_ATTRIB_ARRAY_DIVISOR:()=>uG,GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE:()=>qO,GL_VERTEX_ATTRIB_ARRAY_ENABLED:()=>bM,GL_VERTEX_ATTRIB_ARRAY_INTEGER:()=>fG,GL_VERTEX_ATTRIB_ARRAY_NORMALIZED:()=>TM,GL_VERTEX_ATTRIB_ARRAY_POINTER:()=>EM,GL_VERTEX_ATTRIB_ARRAY_SIZE:()=>AM,GL_VERTEX_ATTRIB_ARRAY_STRIDE:()=>IM,GL_VERTEX_ATTRIB_ARRAY_TYPE:()=>SM,GL_VERTEX_SHADER:()=>pD,GL_VIEWPORT:()=>OP,GL_WAIT_FAILED:()=>wO,GL_ZERO:()=>ku,GaussianBlur:()=>bf,GetComponentFromEntities:()=>OX,Gizmo:()=>$o,GlobalDataRepository:()=>gt,GlobalRetarget:()=>_l,GlobalRetargetReverse:()=>_f,Gltf2Exporter:()=>ax,Gltf2Importer:()=>so,GltfImporter:()=>Fx,GreaterShaderNode:()=>qf,Grid:()=>pf,HdriFormat:()=>wt,INPUT_HANDLING_STATE_CAMERA_CONTROLLER:()=>bo,INPUT_HANDLING_STATE_GIZMO_SCALE:()=>gr,INPUT_HANDLING_STATE_GIZMO_TRANSLATION:()=>vr,INPUT_HANDLING_STATE_NONE:()=>_0,IShape:()=>ro,IdentityMatrix33:()=>El,IdentityMatrix44:()=>wl,IfStatementShader:()=>Jf,IfStatementShaderNode:()=>xv,ImageUtil:()=>pR,InputManager:()=>Ft,Is:()=>A,IsObj:()=>xi,Joint:()=>xf,KTX2TextureLoader:()=>Ec,LightComponent:()=>Mo,LightGizmo:()=>tf,LightType:()=>Fo,Line:()=>vf,LocatorGizmo:()=>Xc,LogLevel:()=>nu,LogQuaternion:()=>dh,Logger:()=>N,MToon0xMaterialContent:()=>Pc,MToon1MaterialContent:()=>Gc,MatCapMaterialContent:()=>Lc,Material:()=>oo,MaterialHelper:()=>Oe,MaterialRepository:()=>Mn,MathClassUtil:()=>En,MathUtil:()=>Y,Matrix22:()=>mc,Matrix33:()=>Ut,Matrix44:()=>Se,MemoryManager:()=>we,MergeVectorShaderNode:()=>eu,Mesh:()=>_t,MeshComponent:()=>Nr,MeshHelper:()=>N5,MeshRendererComponent:()=>In,MiscUtil:()=>on,ModelConverter:()=>Ve,ModuleManager:()=>Pe,MultiplyShaderNode:()=>Mr,MutableColorRgb:()=>ph,MutableColorRgba:()=>vh,MutableMatrix22:()=>fa,MutableMatrix33:()=>We,MutableMatrix44:()=>$,MutableQuaternion:()=>Ye,MutableScalar:()=>ut,MutableScalar_:()=>Ul,MutableScalard:()=>td,MutableVector2:()=>pt,MutableVector2_:()=>Vl,MutableVector2d:()=>B_,MutableVector3:()=>L,MutableVector3_:()=>Tl,MutableVector3d:()=>d_,MutableVector4:()=>pe,MutableVector4_:()=>Ol,MutableVector4d:()=>Z_,None:()=>be,NormalMatrixShaderNode:()=>Hf,NormalizeShaderNode:()=>za,OimoPhysicsStrategy:()=>Ro,Ok:()=>je,OrbitCameraController:()=>ea,OutColorShaderNode:()=>Yf,OutPositionShaderNode:()=>jf,PhysicsComponent:()=>Uo,PixelFormat:()=>ue,Plane:()=>er,PointShadowMap:()=>Sf,Primitive:()=>$e,PrimitiveMode:()=>Re,PrimitiveSortKey_BitLength_Depth:()=>U8,PrimitiveSortKey_BitLength_Material:()=>fp,PrimitiveSortKey_BitLength_PrimitiveType:()=>up,PrimitiveSortKey_BitLength_TranslucencyType:()=>cp,PrimitiveSortKey_BitOffset_Material:()=>_p,PrimitiveSortKey_BitOffset_PrimitiveType:()=>mp,PrimitiveSortKey_BitOffset_TranslucencyType:()=>dp,PrimitiveSortKey_BitOffset_ViewportLayer:()=>O8,ProcessApproach:()=>Z,ProcessApproachClass:()=>sa,ProcessStage:()=>Ne,ProjectionMatrixShaderNode:()=>Xf,Quaternion:()=>H,RenderBuffer:()=>pl,RenderBufferTarget:()=>la,RenderPass:()=>Dt,RenderPassHelper:()=>Pr,RenderTargetTexture:()=>Jo,RenderTargetTexture2DArray:()=>eo,RenderTargetTextureCube:()=>No,RenderableHelper:()=>tn,RhodoniteImportExtension:()=>fl,RnException:()=>rr,RnObject:()=>nt,RnPromise:()=>Kt,Sampler:()=>Ge,Scalar:()=>te,Scalar_:()=>ta,Scalard:()=>$_,ScaleGizmo:()=>Yc,SceneGraphComponent:()=>Wt,ShaderGraphResolver:()=>Cv,ShaderNode:()=>Yl,ShaderSemantics:()=>Xe,ShaderSemanticsClass:()=>B,ShaderType:()=>D,ShaderVariableType:()=>Ik,ShaderityUtilityWebGL:()=>mr,ShadingModel:()=>To,ShadowMap:()=>If,ShadowMapDecodeClassicMaterialContent:()=>Rc,ShadowMapType:()=>wk,ShadowSystem:()=>Tf,SimpleVertexAttribute:()=>xx,SkeletalComponent:()=>Pa,Some:()=>lt,Sphere:()=>hl,SphereCollider:()=>Fa,SplitVectorShaderNode:()=>$f,SymbolWeakMap:()=>Ml,SynthesizeHdrMaterialContent:()=>Bc,System:()=>po,SystemState:()=>K,TagGltf2NodeIndex:()=>Ld,Texture:()=>Jt,TextureDataFloat:()=>Jr,TextureFetchShader:()=>Pv,TextureFormat:()=>oe,TextureParameter:()=>U,Time:()=>Ho,ToneMappingType:()=>oi,Transform3D:()=>Us,TransformComponent:()=>Et,TranslationGizmo:()=>jc,UniformDataShader:()=>Vf,UniformDataShaderNode:()=>zf,VERSION:()=>il,VRMColliderGroup:()=>La,VRMSpring:()=>Va,VRMSpringBone:()=>Oi,VRMSpringBonePhysicsStrategy:()=>Ba,VarianceShadowMapDecodeClassicMaterialContent:()=>Vc,VaryingVariableShader:()=>Mv,Vector2:()=>Ee,Vector2_:()=>Ji,Vector2d:()=>P_,Vector3:()=>S,Vector3_:()=>Wi,Vector3d:()=>m_,Vector4:()=>q,Vector4_:()=>Yi,Vector4d:()=>g_,VectorN:()=>ve,VertexAttribute:()=>ee,VertexAttributeClass:()=>Zn,VideoTexture:()=>bx,ViewMatrixShaderNode:()=>Qf,Visibility:()=>Qk,Vrm0xImporter:()=>Rf,VrmComponent:()=>mi,VrmImporter:()=>Pf,VrmaImporter:()=>Vx,WalkThroughCameraController:()=>Wl,WeakNone:()=>Q_,WeakOption:()=>k_,WeakSome:()=>W_,WebGLContextWrapper:()=>ma,WebGLExtension:()=>vn,WebGLResourceRepository:()=>to,WebGLStrategyDataTexture:()=>rf,WebGLStrategyUniform:()=>of,WebGpuDeviceWrapper:()=>af,WebGpuResourceRepository:()=>Po,WebGpuStrategyBasic:()=>Ea,WebXRSystem:()=>cf,WellKnownComponentTIDs:()=>Q,WireframeMaterialNode:()=>gv,WorldMatrixShaderNode:()=>Wf,_from:()=>de,_fromString:()=>Te,_fromStringCaseSensitively:()=>jm,_getPropertyIndex2:()=>vk,add2:()=>jv,add2_offset:()=>Yv,add3:()=>Kv,add3_offset:()=>Zv,add4:()=>Jv,add4_offset:()=>$v,addLineNumberToCode:()=>T0,applyMixins:()=>vt,array2_lerp_offsetAsComposition:()=>du,array3_lerp_offsetAsComposition:()=>hu,array4_lerp_offsetAsComposition:()=>pu,arrayN_lerp_offsetAsComposition:()=>xu,assertDoesNotHave:()=>VR,assertExist:()=>jn,assertHas:()=>LR,assertIsErr:()=>E_,assertIsOk:()=>Zr,calcAlignedByteLength:()=>Kl,combineImages:()=>hR,convertHTMLImageElementToCanvas:()=>dR,createCameraControllerEntity:()=>VX,createCameraEntity:()=>hr,createEffekseer:()=>rx,createEntity:()=>pN,createGroupEntity:()=>en,createLightEntity:()=>zp,createLightWithCameraEntity:()=>f5,createMeshEntity:()=>Ct,createMotionController:()=>kp,createPhysicsEntity:()=>zX,createSkeletalEntity:()=>GX,createTransformEntity:()=>vp,deepCopyUsingJsonStringify:()=>z_,defaultAnimationTrackName:()=>Zk,defaultValue:()=>MR,detectFormatByArrayBuffers:()=>wx,detectFormatByUri:()=>P5,downloadArrayBuffer:()=>E0,downloadTypedArray:()=>C0,dummyAnisotropyTexture:()=>Js,dummyBlackCubeTexture:()=>qt,dummyBlackTexture:()=>rn,dummyBlueTexture:()=>Ur,dummyDepthMomentTextureArray:()=>va,dummySRGBGrayTexture:()=>vm,dummyWhiteTexture:()=>ct,dummyZeroTexture:()=>Tr,enhanceArray:()=>QX,flattenHierarchy:()=>ii,fromTensorToCompositionType:()=>kN,get1:()=>Qv,get1_offset:()=>ru,get1_offsetAsComposition:()=>iu,get2:()=>Xv,get2_offset:()=>au,get2_offsetAsComposition:()=>su,get3:()=>Hv,get3_offset:()=>Ka,get3_offsetAsComposition:()=>lu,get4:()=>qv,get4_offset:()=>Za,get4_offsetAsComposition:()=>cu,getEvent:()=>Kr,getMotionController:()=>Xp,getN_offset:()=>Ja,getN_offsetAsComposition:()=>fu,getWebXRSystem:()=>AH,greaterThan:()=>BR,ifDefinedThen:()=>os,ifDefinedThenWithReturn:()=>wR,ifExistsThen:()=>ER,ifExistsThenWithReturn:()=>CR,ifNotExistsThen:()=>NR,ifNotExistsThenWithReturn:()=>PR,ifUndefinedThen:()=>L_,ifUndefinedThenWithReturn:()=>RR,initDefaultTextures:()=>Wh,isBlend:()=>hp,isBlendWithZWrite:()=>nl,isBlendWithoutZWrite:()=>Aa,isOpaque:()=>pp,isSameGlTF2TextureSampler:()=>Vd,isSkipDrawing:()=>Sa,isTranslucent:()=>Uc,lessThan:()=>FR,mulArray3WithScalar_offset:()=>Rl,mulArray4WithScalar_offset:()=>Nl,mulArrayNWithScalar_offset:()=>Pl,mulThatAndThisToOutAsMat44_offsetAsComposition:()=>uu,normalizeArray4:()=>vu,nullishToEmptyArray:()=>Tu,nullishToEmptyMap:()=>DR,objectCachify:()=>tR,primitiveCachify1:()=>nR,qlerp_offsetAsComposition:()=>mu,scalar_lerp_offsetAsComposition:()=>_u,setupShaderProgram:()=>Ra,sheenLutTexture:()=>Zs,updateGamePad:()=>Wp,updateMotionControllerModel:()=>Qp,updateVBOAndVAO:()=>Ta,valueWithCompensation:()=>V_,valueWithDefault:()=>vi});ou();j_();rd();ul();dn();St();tt();fd();at();Er();jo();zn();un();var OX=Symbol(),UX="getComponentFromEntities";function kX(m){let n=this.__raw,t=[];return n.forEach(o=>{let r=o.getComponentByComponentTID(m.componentTID);r!=null&&t.push(r)}),t}h(kX,"getComponentFromEntities");var dl,t4=(dl=class{constructor(n){f(this,"__raw");this.__raw=n}},h(dl,"EnhancedArrayMethods"),dl),WX=h(()=>{Object.defineProperty(t4.prototype,UX,{enumerable:!1,writable:!1,configurable:!0,value:kX})},"enhanceInner");WX();var QX=h(()=>{Object.defineProperty(Array.prototype,"Rn",{enumerable:!1,configurable:!1,get(){return new t4(this)}})},"enhanceArray");at();ge();Xu();xe();co();Qu();se();Li();it();ge();me();co();function Lm(m,n,t){let o=m.extras.bufferViewByteLengthAccumulatedArray[n],r={buffer:n,byteLength:t.byteLength,byteOffset:o,extras:{uint8Array:t}},i=ie.addPaddingBytes(r.byteLength,4)+o;return m.bufferViews.push(r),m.extras.bufferViewByteLengthAccumulatedArray[n]=i,r}h(Lm,"createAndAddGltf2BufferView");function rx(m,n){let t=!1,o=m.extras.bufferViewByteLengthAccumulatedArray.length-1,r=[];for(let i=0;i<n.length;i++){let s=n[i].getComponentByComponentTID(Q.EffekseerComponentTID);if(A.exist(s)){t=!0;let l={node:i,name:s.uniqueName};if(A.exist(s.arrayBuffer)){let c=Lm(m,o,new Uint8Array(s.arrayBuffer));l.bufferView=m.bufferViews.indexOf(c)}else A.exist(s.uri)?l.uri=s.uri:N.error("no real effect data.");XX(s.entity,l),r.push(l)}}t&&(m.extensions.RHODONITE_effekseer={version:"1.0",effects:r},m.extensionsUsed.push("RHODONITE_effekseer"))}h(rx,"createEffekseer");function XX(m,n){let t=m.tryToGetAnimation();if(A.exist(t)){let o=t.getAnimationTrackNames(),r=[];for(let i of o)if(t.hasAnimation(i,"effekseer")){let a=t.getAnimationChannelsOfTrack();if(A.exist(a)){let s=a.values();for(let l of s)if(l.target.pathName==="effekseer"){let u=l.animatedValue;for(let _ of u.getAllTrackNames()){let d=u.getAnimationSampler(_).input,p=[];for(let v=0;v<d.length;v++){let y=d[v],g=u.getAnimationSampler(_).output[v],E={input:y,event:g>.5?"play":"pause"};p.push(E)}let x={name:_,values:p};r.push(x)}}}}n.timelines=r}}h(XX,"__createEffekseerTimeline");It();un();nn();Em();var sx="glTF",ix="glTF-Binary",HX="glTF-Draco",qX="glTF-Embedded",jX="No-Download",cx=class cx{constructor(){}static async export(n,t={entities:void 0,type:ix}){let{collectedEntities:o,topLevelEntities:r}=this.__collectEntities(t),{json:i,fileName:a}=this.__createJsonBase(n);this.__createBufferViewsAndAccessors(i,o),this.__createNodes(i,o,r),await this.__createMaterials(i,o,t),rx(i,o);let s=this.__createBinary(i);this.__deleteEmptyArrays(i);let l=YX(i,s);return t.type===ix?this.__downloadGlb(i,a,l):t.type===sx&&this.__downloadGltf(i,a,s),l}static __deleteEmptyArrays(n){n.accessors.length===0&&delete n.accessors,n.bufferViews.length===0&&delete n.bufferViews,n.materials.length===0&&delete n.materials,n.meshes.length===0&&delete n.meshes,n.skins.length===0&&delete n.skins,n.textures.length===0&&delete n.textures,n.images.length===0&&delete n.images,n.animations.length===0&&delete n.animations,A.exist(n.extensionsUsed)&&n.extensionsUsed.length===0&&delete n.extensionsUsed,n.cameras.length===0&&delete n.cameras,delete n.extras}static __collectEntities(n){let t=h(s=>{if(A.exist(n)&&A.exist(n.excludeTags)){for(let l of n.excludeTags)if(s.matchTag(l.tag,l.value))return!1;if(s.matchTag("Being","gizmo"))return!0}return!0},"checkPassOrNotWithTags"),o=h(s=>{if(A.exist(n)&&A.exist(n.excludeTags)){for(let l of n.excludeTags)if(s.matchTag(l.tag,l.value))return[]}return[s]},"excludeWithTags"),r=h((s,l)=>{let c=s.getSceneGraph();if(c.children.length>0){let u=l?[]:o(s);for(let _=0;_<c.children.length;_++){let d=c.children[_];Array.prototype.push.apply(u,r(d.entity,!1))}return u}else return l?[]:o(s)},"collectDescendants");if(A.exist(n)&&A.exist(n.entities)&&n.entities.length>0){let s=n.entities.flatMap(u=>r(u,!0)),l=[];n.entities.forEach(u=>{s.indexOf(u)===-1&&t(u)&&l.push(u)});let c=n.entities.concat();return Array.prototype.push.apply(c,s),c=[...new Set(c)],l.length===0&&(l=c),{collectedEntities:c,topLevelEntities:l}}let i=ne._getEntities();i=i.filter(s=>t(s));let a=Wt.getTopLevelComponents().flatMap(s=>s.entity);return a=a.filter(s=>t(s)),i=i.flatMap(s=>r(s,!0)),Array.prototype.push.apply(i,a),i=[...new Set(i)],{collectedEntities:i,topLevelEntities:a}}static __createJsonBase(n){let t=n||"Rhodonite_"+new Date().getTime();return{json:{asset:{version:"2.0",generator:`Rhodonite (${il.version})`},buffers:[{uri:t+".bin",byteLength:0}],bufferViews:[],accessors:[],animations:[],meshes:[],skins:[],materials:[{pbrMetallicRoughness:{baseColorFactor:[1,1,1,1]}}],textures:[],images:[],extensionsUsed:[],extensions:{},extras:{rnSkins:[],bufferViewByteLengthAccumulatedArray:[]},cameras:[],samplers:[]},fileName:t}}static __createBufferViewsAndAccessors(n,t){let o=[],r=[],i=[];ZX(n,t,o,r,i),$X(n,t),KX(n,t,o,r,i)}static __createNodes(n,t,o){n.nodes=[],n.scenes=[{nodes:[]}];let r=n.scenes[0];for(let a=0;a<t.length;a++){let s=t[a];s.gltfNodeIndex=a}let i=0;for(let a=0;a<t.length;a++){let s=t[a];n.nodes[a]={};let l=n.nodes[a];l.name=s.uniqueName;let c=s.getSceneGraph(),u=c.children;if(u.length>0){l.children=[];for(let y=0;y<u.length;y++){let g=u[y];A.exist(g.entity.gltfNodeIndex)&&l.children.push(g.entity.gltfNodeIndex)}}c.isBillboard&&(l.extensions={RHODONITE_billboard:{isBillboard:!0}},n.extensionsUsed.indexOf("RHODONITE_billboard")===-1&&n.extensionsUsed.push("RHODONITE_billboard"));let _=s.getTransform();l.rotation=[_.localRotationInner.x,_.localRotationInner.y,_.localRotationInner.z,_.localRotationInner.w],l.scale=[_.localScaleInner.x,_.localScaleInner.y,_.localScaleInner.z],l.translation=[_.localPositionInner.x,_.localPositionInner.y,_.localPositionInner.z];let d=s.tryToGetMesh();A.exist(d)&&A.exist(d.mesh)&&(l.mesh=i++);let p=s.tryToGetBlendShape();if(A.exist(p)){let y=p.weights;y.length>0&&(l.weights=y)}let x=s.tryToGetSkeletal();if(A.exist(x)){let y=n.extras.rnSkins.indexOf(x.entity);y>=0&&(l.skin=y)}let v=s.tryToGetCamera();if(A.exist(v)){let y;if(v.type===wn.Perspective){let g=v.getTagValue("OriginalAspect"),E=v.getTagValue("OriginalFovY");y={name:v.entity.uniqueName,type:"perspective",perspective:{aspectRatio:A.exist(g)?g:v.aspect,yfov:A.exist(E)?Y.degreeToRadian(E):Y.degreeToRadian(v.fovy),znear:v.zNear,zfar:v.zFar}}}else if(v.type===wn.Orthographic){let g=v.getTagValue("OriginalXMag"),E=v.getTagValue("OriginalYMag");y={name:v.entity.uniqueName,type:"orthographic",orthographic:{xmag:A.exist(g)?g:v.xMag,ymag:A.exist(E)?E:v.yMag,znear:v.zNear,zfar:v.zFar}}}n.cameras.push(y),l.camera=n.cameras.length-1}}o.forEach((a,s)=>{let l=t.indexOf(a);l>=0&&r.nodes.push(l)})}static async __createMaterials(n,t,o){let r=0,i=[];n.extras.bufferViewByteLengthAccumulatedArray.push(0);let a=n.extras.bufferViewByteLengthAccumulatedArray.length-1;for(let s=0;s<t.length;s++){let c=t[s].tryToGetMesh();if(c&&c.mesh){let u=n.meshes[r++],_=c.mesh.getPrimitiveNumber();for(let d=0;d<_;d++){let p=c.mesh.getPrimitiveAt(d),x=u.primitives[d],v=p.material,y={pbrMetallicRoughness:{metallicFactor:1,roughnessFactor:1}},g;if(A.exist(v)){A.false(v.isLighting)&&(A.not.exist(y.extensions)&&(y.extensions={}),y.extensions.KHR_materials_unlit={},n.extensionsUsed.indexOf("KHR_materials_unlit")<0&&n.extensionsUsed.push("KHR_materials_unlit")),g=v.getParameter("baseColorFactor"),A.not.exist(g)?(g=v.getParameter("diffuseColorFactor"),A.not.exist(g)&&(g=q.fromCopy4(1,1,1,1))):(y.pbrMetallicRoughness.metallicFactor=v.getParameter("metallicRoughnessFactor").x,y.pbrMetallicRoughness.roughnessFactor=v.getParameter("metallicRoughnessFactor").y),y.pbrMetallicRoughness.baseColorFactor=Array.prototype.slice.call(g._v),y.alphaMode=v.alphaMode.toGltfString();let w=[],T=h((V,z)=>{if(V&&V.width>1&&V.height>1){let k=n.images.length,W=!1;for(let le=0;le<n.images.length;le++){let ze=n.images[le];A.exist(ze.rnTextureUID)&&ze.rnTextureUID===V.textureUID&&(k=le,W=!0)}let X=-1;{let le={magFilter:z!=null?z.magFilter.index:U.Linear.index,minFilter:z!=null?z.minFilter.index:U.Linear.index,wrapS:z!=null?z.wrapS.index:U.TextureWrapS.index,wrapT:z!=null?z.wrapT.index:U.TextureWrapT.index};X=n.samplers.findIndex(ze=>Vd(le,ze)),X===-1&&(n.samplers.push(le),X=n.samplers.length-1)}if(!W){let le={uri:V.name};le.rnTextureUID=V.textureUID,w.indexOf(V.name)!==-1&&(le.uri+="_"+V.textureUID),w.push(le.uri),A.not.exist(le.uri.match(/\.(png)/))&&(le.uri+=".png");let ze=V.htmlCanvasElement;if(ze){let At=new Promise((Be,Fn)=>{ze.toBlob(Sn=>{if(A.exist(Sn))c5(n,a,Sn,o,le,Be,Fn);else throw Error("canvas to blob error!")})});i.push(At)}n.images.push(le)}let j={sampler:X,source:k};return n.textures.indexOf(j)===-1&&n.textures.push(j),n.textures.indexOf(j)}},"processTexture"),R=v.getParameter("baseColorTexture"),P;if(R!=null){let V=R[1],z=R[2];P=T(V,z),P!=null&&(y.pbrMetallicRoughness.baseColorTexture={index:P})}else if(R=v.getParameter("diffuseColorTexture"),R!=null){let V=R[1],z=R[2],k=T(V,z);k!=null&&(y.pbrMetallicRoughness.diffuseColorTexture={index:k})}if(R=v.getParameter("metallicRoughnessTexture"),R){let V=R[1],z=R[2];P=T(V,z),P!=null&&(y.pbrMetallicRoughness.metallicRoughnessTexture={index:P})}if(R=v.getParameter("normalTexture"),R){let V=R[1],z=R[2];P=T(V,z),P!=null&&(y.normalTexture={index:P})}if(R=v.getParameter("occlusionTexture"),R){let V=R[1],z=R[2];P=T(V,z),P!=null&&(y.occlusionTexture={index:P})}if(R=v.getParameter("emissiveTexture"),R){let V=R[1],z=R[2];P=T(V,z),P!=null&&(y.emissiveTexture={index:P})}}n.materials.indexOf(y)===-1&&n.materials.push(y),x.material=n.materials.indexOf(y)}}}return Promise.all(i)}static __createBinary(n){if(A.undefined(n.accessors)||A.undefined(n.bufferViews))return new ArrayBuffer(0);let t=n.extras.bufferViewByteLengthAccumulatedArray.reduce((i,a)=>i+a);if(t>0){let i=n.buffers[0];i.byteLength=t+ie.calcPaddingBytes(t,4)}let o=new ArrayBuffer(n.buffers[0].byteLength),r=0;for(let i=0;i<n.bufferViews.length;i++){let a=n.bufferViews[i],s=a.extras.uint8Array;delete a.extras;let l=r;ie.copyArrayBufferWithPadding({src:s.buffer,dist:o,srcByteOffset:s.byteOffset,copyByteLength:s.byteLength,distByteOffset:l}),r+=ie.addPaddingBytes(s.byteLength,4),a.byteOffset=l,a.buffer=0}return o}static __downloadGlb(n,t,o){{let r=document.createElement("a");r.download=t+".glb";let i=new Blob([o],{type:"octet/stream"}),a=URL.createObjectURL(i);r.href=a;let s=new MouseEvent("click");r.dispatchEvent(s)}}exportGlbAsArrayBuffer(){}static __downloadGltf(n,t,o){{let r=document.createElement("a");r.download=t+".gltf";let i=JSON.stringify(n,null,2);r.href="data:application/octet-stream,"+encodeURIComponent(i);let a=new MouseEvent("click");r.dispatchEvent(a)}{let r=document.createElement("a");r.download=t+".bin";let i=new Blob([o],{type:"octet/stream"}),a=URL.createObjectURL(i);r.href=a;let s=new MouseEvent("click");r.dispatchEvent(s)}}};h(cx,"Gltf2Exporter");var ax=cx;function YX(m,n){delete m.buffers[0].uri;let o=JSON.stringify(m,null,2),r=ie.stringToBuffer(o),i=ie.calcPaddingBytes(r.byteLength,4);if(i>0){for(let _=0;_<i;_++)o+=" ";r=ie.stringToBuffer(o)}let a=r.byteLength,s=20+a,l=s+4+4+n.byteLength,c=new ArrayBuffer(l),u=new DataView(c);return u.setUint32(0,1179937895,!0),u.setUint32(4,2,!0),u.setUint32(8,l,!0),u.setUint32(12,r.byteLength,!0),u.setUint32(16,1313821514,!0),ie.copyArrayBufferAs4Bytes({src:r,dist:c,srcByteOffset:0,copyByteLength:r.byteLength,distByteOffset:20}),ie.copyArrayBufferAs4Bytes({src:n,dist:c,srcByteOffset:0,copyByteLength:n.byteLength,distByteOffset:20+a+8}),u.setUint32(s,n.byteLength,!0),u.setUint32(s+4,5130562,!0),c}h(YX,"generateGlbArrayBuffer");function KX(m,n,t,o,r){for(let i=0;i<n.length;i++){let s=n[i].tryToGetSkeletal();if(A.not.exist(s))continue;m.extras.rnSkins.push(s.entity);let l=s.getJoints(),c=[];for(let v of l)n.forEach((y,g)=>{v.entity===y&&c.push(g)});let u=s.getInverseBindMatricesAccessor();A.exist(u)&&(lx(m,t,o,u.bufferView),zm(m,m.bufferViews.length-1,r,u));let _=s.topOfJointsHierarchy,d=s._bindShapeMatrix,p=-1;if(A.exist(_)){let v=_.entity;p=n.indexOf(v)}else p=c[0];let x={joints:c,inverseBindMatrices:m.accessors.length-1,skeleton:p>=0?p:void 0,bindShapeMatrix:d==null?void 0:d.flattenAsArray()};m.skins.push(x)}}h(KX,"__createBufferViewsAndAccessorsOfSkin");function ZX(m,n,t,o,r){for(let i=0;i<n.length;i++){let a=n[i],s=a.tryToGetMesh();if(A.exist(s)&&s.mesh){let l={primitives:[]},c=s.mesh.getPrimitiveNumber();for(let u=0;u<c;u++){let _=s.mesh.getPrimitiveAt(u),d={attributes:{},mode:_.primitiveMode.index},p=_.indicesAccessor;if(A.exist(p)){let v=p.bufferView,y=lx(m,t,o,v,34963),g=zm(m,m.bufferViews.indexOf(y),r,p),E=m.accessors.indexOf(g);d.indices=E}let x=_.attributeAccessors;for(let v=0;v<x.length;v++){let g=_.attributeSemantics[v].split(".")[0];if(g==="BARY_CENTRIC_COORD")continue;let E=x[v],w=E.bufferView,T=t5(m,t,o,w,E),R=zm(m,m.bufferViews.indexOf(T),r,E),P=m.accessors.indexOf(R);d.attributes[g]=P}JX(a,_,d,m,t,o,r),l.primitives[u]=d}m.meshes.push(l)}}}h(ZX,"__createBufferViewsAndAccessorsOfMesh");function JX(m,n,t,o,r,i,a){let s=m.tryToGetBlendShape();if(A.exist(s)){let l=n.getBlendShapeTargets();A.not.exist(t.targets)&&(t.targets=[]);for(let c of l){let u={};for(let[_,d]of c.entries()){let p=lx(o,r,i,d.bufferView,34962),x=zm(o,o.bufferViews.indexOf(p),a,d),v=o.accessors.indexOf(x),g=_.split(".")[0];u[g]=v}t.targets.push(u)}}}h(JX,"setupBlandShapeData");function $X(m,n){let t=0,o=m.extras.bufferViewByteLengthAccumulatedArray.length;for(let r=0;r<n.length;r++){let a=n[r].tryToGetAnimation();if(A.exist(a)){let s={channels:[],samplers:[]};m.animations.push(s);let l=0,u=a.getAnimationChannelsOfTrack().values();for(let _ of u){if(_.target.pathName==="effekseer")continue;let d=_.animatedValue,p=d.getAllTrackNames();for(let x of p){let{inputAccessorIdx:v,inputBufferViewByteLengthAccumulated:y}=i5(m,d.getAnimationSampler(x),o,t);t+=y;let{outputAccessorIdx:g,outputBufferViewByteLengthAccumulated:E}=a5(m,d.getAnimationSampler(x),_.target.pathName,o,t);t+=E,l=o5(_,l,s,r),r5(v,g,d.getAnimationSampler(x),s)}}}}m.extras.bufferViewByteLengthAccumulatedArray.push(t)}h($X,"__createBufferViewsAndAccessorsOfAnimation");function e5(m,n){return m.findIndex(o=>o.isSame(n))}h(e5,"calcAccessorIdxToSet");function t5(m,n,t,o,r){let i=n4(t,o);if(i===-1){let s=o4(n,o.buffer),l={buffer:s,byteLength:o.byteLength,byteOffset:o.byteOffsetInBuffer,extras:{uint8Array:o.getUint8Array()}};return l.target=34962,m.extras.bufferViewByteLengthAccumulatedArray[s]=r4(m.extras.bufferViewByteLengthAccumulatedArray,s,l),A.exist(l.target)&&(l.byteStride=r.elementSizeInBytes),t.push(o),m.bufferViews.push(l),l}return m.bufferViews[i]}h(t5,"createOrReuseGltf2BufferViewForVertexAttributeBuffer");function n4(m,n){return m.findIndex(o=>o.isSame(n))}h(n4,"findBufferViewIdx");function o4(m,n){m.length===0&&m.push(n);let t=m.findIndex(r=>r.isSame(n)),o=t===-1?m.length:t;return t===-1&&m.push(n),o}h(o4,"calcBufferIdxToSet");function r4(m,n,t){return A.exist(m[n])?m[n]+ie.addPaddingBytes(t.byteLength,4):ie.addPaddingBytes(t.byteLength,4)}h(r4,"accumulateBufferViewByteLength");function n5(m){switch(m){case"translate":return"translation";case"quaternion":return"rotation";case"scale":return"scale";case"weights":return"weights";default:throw new Error("Invalid Path Name")}}h(n5,"convertToGltfAnimationPathName");function o5(m,n,t,o){let r=m.target.pathName,i={sampler:n++,target:{path:n5(r),node:o}};return t.channels.push(i),n}h(o5,"createGltf2AnimationChannel");function r5(m,n,t,o){let r={input:m,output:n,interpolation:t.interpolationMethod.GltfString};o.samplers.push(r)}h(r5,"createGltf2AnimationSampler");function i5(m,n,t,o){let r=I.fromTypedArray(ArrayBuffer.isView(n.input)?n.input:new Float32Array(n.input)),i=n.input.length,a=a4({bufferIdx:t,bufferViewByteOffset:o,accessorByteOffset:0,accessorCount:i,bufferViewByteStride:I.Float.getSizeInBytes(),componentType:r,compositionType:b.Scalar,uint8Array:new Uint8Array(ArrayBuffer.isView(n.input)?n.input.buffer:new Float32Array(n.input).buffer)});m.bufferViews.push(a);let s=s4({bufferViewIdx:m.bufferViews.indexOf(a),accessorByteOffset:0,componentType:r,count:i,compositionType:b.Scalar,min:[n.input[0]],max:[n.input[n.input.length-1]]});return m.accessors.push(s),o=i4(o,a),{inputAccessorIdx:m.accessors.indexOf(s),inputBufferViewByteLengthAccumulated:o}}h(i5,"createGltf2BufferViewAndGltf2AccessorForInput");function a5(m,n,t,o,r){let i=I.fromTypedArray(ArrayBuffer.isView(n.output)?n.output:new Float32Array(n.output)),a=b.toGltf2AnimationAccessorCompositionType(n.outputComponentN),s=n.output.length/n.outputComponentN;t==="weights"&&(a=b.Scalar,s=n.output.length);let l=a4({bufferIdx:o,bufferViewByteOffset:r,accessorByteOffset:0,accessorCount:s,bufferViewByteStride:i.getSizeInBytes()*n.outputComponentN,componentType:i,compositionType:a,uint8Array:new Uint8Array(ArrayBuffer.isView(n.output)?n.output.buffer:new Float32Array(n.output).buffer)});m.bufferViews.push(l);let c=s4({bufferViewIdx:m.bufferViews.indexOf(l),accessorByteOffset:0,componentType:i,count:s,compositionType:a});return m.accessors.push(c),r=i4(r,l),{outputAccessorIdx:m.accessors.indexOf(c),outputBufferViewByteLengthAccumulated:r}}h(a5,"createGltf2BufferViewAndGltf2AccessorForOutput");function i4(m,n){return m=n.byteLength+ie.calcPaddingBytes(n.byteLength,4),m}h(i4,"alignBufferViewByteLength");function s5({accessorByteOffset:m,accessorCount:n,bufferViewByteStride:t,bufferViewByteOffset:o,sizeOfComponent:r,numberOfComponents:i}){let a=t===0?r*i:t;if(t%r!==0)throw Error("glTF2: When byteStride is defined, it MUST be a multiple of the size of the accessor\u2019s component type.");let s=l5(a),l=Vm(m),c=l+s*(n-1)+r*i,u=r*i,_=l+o,d=u-_%u,p=o+d,x=Vm(p);return{fixedBufferViewByteLength:c,fixedBufferViewByteOffset:x}}h(s5,"calcBufferViewByteLengthAndByteOffset");function Vm(m){return m%4===0?m:m+(4-m%4)}h(Vm,"alignAccessorByteOffsetTo4Bytes");function l5(m){return m%4===0?m:m+(4-m%4)}h(l5,"alignBufferViewByteStrideTo4Bytes");async function c5(m,n,t,o,r,i,a){if(o.type===sx)setTimeout(()=>{let s=document.createElement("a"),l=new MouseEvent("click");s.href=URL.createObjectURL(t),s.download=r.uri,s.dispatchEvent(l),URL.revokeObjectURL(s.href)},Math.random()*5e3),i();else{let s=new FileReader;s.addEventListener("load",()=>{let l=s.result,c=Lm(m,n,new Uint8ClampedArray(l));r.bufferView=m.bufferViews.indexOf(c),r.mimeType="image/png",delete r.uri,i()}),s.addEventListener("error",()=>{a(s.error)}),s.readAsArrayBuffer(t)}}h(c5,"handleTextureImage");function a4({bufferIdx:m,bufferViewByteOffset:n,accessorByteOffset:t,accessorCount:o,bufferViewByteStride:r,componentType:i,compositionType:a,uint8Array:s}){let l=Vm(t),{fixedBufferViewByteLength:c,fixedBufferViewByteOffset:u}=s5({accessorByteOffset:l,accessorCount:o,bufferViewByteStride:r,bufferViewByteOffset:n,sizeOfComponent:i.getSizeInBytes(),numberOfComponents:a.getNumberOfComponents()});return{buffer:m,byteLength:c,byteOffset:u,extras:{uint8Array:s}}}h(a4,"createGltf2BufferViewForAnimation");function s4({bufferViewIdx:m,accessorByteOffset:n,componentType:t,count:o,compositionType:r,min:i,max:a}){let s=Vm(n);return{bufferView:m,byteOffset:s,componentType:I.toGltf2AccessorComponentType(t),count:o,type:r.str,min:i,max:a,extras:{}}}h(s4,"createGltf2AccessorForAnimation");function lx(m,n,t,o,r){let i=n4(t,o);if(i===-1){let s=o4(n,o.buffer),l={buffer:s,byteLength:o.byteLength,byteOffset:o.byteOffsetInBuffer,extras:{uint8Array:o.getUint8Array()}};return A.exist(r)&&(l.target=r),m.extras.bufferViewByteLengthAccumulatedArray[s]=r4(m.extras.bufferViewByteLengthAccumulatedArray,s,l),t.push(o),m.bufferViews.push(l),l}return m.bufferViews[i]}h(lx,"createOrReuseGltf2BufferView");function zm(m,n,t,o){let r=e5(t,o);if(r===-1){let a={bufferView:n,byteOffset:o.byteOffsetInBufferView,componentType:I.toGltf2AccessorComponentType(o.componentType),count:o.elementCount,type:b.toGltf2AccessorCompositionTypeString(o.compositionType.getNumberOfComponents()),extras:{uint8Array:void 0}};return o.compositionType.getNumberOfComponents()<=4&&(a.max=o.max,a.min=o.min),t.push(o),m.accessors.push(a),a}return m.accessors[r]}h(zm,"createOrReuseGltf2Accessor");Xt();Nn();li();var fx=class fx extends ro{generate(n){var s;let t={length:(s=n.length)!=null?s:1,material:n.material},o=[0,0,0,t.length,0,0,0,0,0,0,t.length,0,0,0,0,0,0,t.length],r=[1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1],i=[new Float32Array(o),new Float32Array(r)],a=[ee.Position.XYZ,ee.Color0.XYZ];this.copyVertexData({attributes:i,attributeSemantics:a,primitiveMode:Re.Lines,material:t.material})}};h(fx,"Axis");var hf=fx;Hc();Xt();Nn();li();var ux=class ux extends ro{generate(n){var a,s,l,c,u;let t={length:(a=n.length)!=null?a:1,division:(s=n.division)!=null?s:10,isXY:(l=n.isXY)!=null?l:!0,isXZ:(c=n.isXZ)!=null?c:!0,isYZ:(u=n.isYZ)!=null?u:!0,material:n.material},o=[];for(let _=0;_<t.division*2+3;_++){let d=-t.length,p=t.length/(t.division+1);t.isXZ&&(o.push(-t.length,0,d+p*_),o.push(t.length,0,d+p*_),o.push(d+p*_,0,-t.length),o.push(d+p*_,0,t.length)),t.isXY&&(o.push(-t.length,d+p*_,0),o.push(t.length,d+p*_,0),o.push(d+p*_,-t.length,0),o.push(d+p*_,t.length,0)),t.isYZ&&(o.push(0,-t.length,d+p*_),o.push(0,t.length,d+p*_),o.push(0,d+p*_,-t.length),o.push(0,d+p*_,t.length))}let r=[new Float32Array(o)],i=[ee.Position.XYZ];this.copyVertexData({attributes:r,attributeSemantics:i,primitiveMode:Re.Lines,material:t==null?void 0:t.material})}};h(ux,"Grid");var pf=ux;li();ye();Nn();Xt();li();var mx=class mx extends ro{constructor(){super(...arguments);f(this,"__worldPositionOfThisJoint",S.fromCopyArray3([0,0,1]));f(this,"__worldPositionOfParentJoint",S.fromCopyArray3([0,0,0]));f(this,"__width",1)}generate(t){let o=S.lengthBtw(this.__worldPositionOfThisJoint,this.__worldPositionOfParentJoint),r=this.__width,i=o/7.5,a=o-i,s=S.subtract(this.__worldPositionOfParentJoint,this.__worldPositionOfThisJoint),l=S.fromCopyArray3([0,1,0]);s.isEqual(S.zero())||(l=S.normalize(S.subtract(this.__worldPositionOfParentJoint,this.__worldPositionOfThisJoint)));let c=S.add(this.__worldPositionOfThisJoint,S.multiply(l,a)),u=S.fromCopyArray3([0,1,0]),_=S.fromCopyArray3([0,-1,0]);Math.abs(S.dot(l,u))>.4&&(u=S.fromCopyArray3([1,0,0]),_=S.fromCopyArray3([-1,0,0])),Math.abs(S.dot(l,u))>.4&&(u=S.fromCopyArray3([0,0,1]),_=S.fromCopyArray3([0,0,-1]));let d=S.multiply(S.normalize(S.cross(l,u)),r),p=S.multiply(S.normalize(S.cross(l,d)),r),x=S.multiply(S.normalize(S.cross(l,_)),r),v=S.multiply(S.normalize(S.cross(l,x)),r),y=S.add(c,d),g=S.add(c,p),E=S.add(c,x),w=S.add(c,v),T=[];T.push(this.__worldPositionOfThisJoint),T.push(y),T.push(this.__worldPositionOfThisJoint),T.push(g),T.push(this.__worldPositionOfThisJoint),T.push(E),T.push(this.__worldPositionOfThisJoint),T.push(w),T.push(y),T.push(g),T.push(g),T.push(E),T.push(E),T.push(w),T.push(w),T.push(y),T.push(this.__worldPositionOfParentJoint),T.push(y),T.push(this.__worldPositionOfParentJoint),T.push(g),T.push(this.__worldPositionOfParentJoint),T.push(E),T.push(this.__worldPositionOfParentJoint),T.push(w);let R=[];T.map(z=>{Array.prototype.push.apply(R,z.flattenAsArray())});let P=[new Float32Array(R)],V=[ee.Position.XYZ];this.copyVertexData({attributes:P,attributeSemantics:V,primitiveMode:Re.Lines,material:t==null?void 0:t.material})}};h(mx,"Joint");var xf=mx;Xt();Nn();li();ye();var _x=class _x extends ro{generate(n){var a,s,l;let t={startPos:(a=n.startPos)!=null?a:S.fromCopy3(0,0,0),endPos:(s=n.endPos)!=null?s:S.fromCopy3(1,0,0),hasTerminalMark:(l=n.hasTerminalMark)!=null?l:!0,material:n.material},o=[];if(o.push(...t.startPos.flattenAsArray()),o.push(...t.endPos.flattenAsArray()),t.hasTerminalMark){let u=t.startPos.lengthTo(t.endPos)*.1;o.push(t.startPos.x-u,t.startPos.y,t.startPos.z),o.push(t.startPos.x+u,t.startPos.y,t.startPos.z),o.push(t.startPos.x,t.startPos.y,t.startPos.z-u),o.push(t.startPos.x,t.startPos.y,t.startPos.z+u),o.push(t.endPos.x-u,t.endPos.y,t.endPos.z),o.push(t.endPos.x+u,t.endPos.y,t.endPos.z),o.push(t.endPos.x,t.endPos.y,t.endPos.z-u),o.push(t.endPos.x,t.endPos.y,t.endPos.z+u)}let r=[new Float32Array(o)],i=[ee.Position.XYZ];this.copyVertexData({attributes:r,attributeSemantics:i,primitiveMode:Re.Lines,material:t.material})}};h(_x,"Line");var vf=_x;qc();Xt();Nn();ye();li();me();var dx=class dx extends ro{constructor(){super()}generate(n){var _,d,p,x;let t={radius:(_=n.radius)!=null?_:1,widthSegments:(d=n.widthSegments)!=null?d:10,heightSegments:(p=n.heightSegments)!=null?p:10,material:n.material,inverseNormal:(x=n.inverseNormal)!=null?x:!1},o=[],r=[],i=[];Math.abs(t.radius)<Number.EPSILON&&(N.warn("The argument radius is zero / nearly zero. Rn will take the radius as 0.001 for safety. Check your code."),t.radius=.001);let a=1e-5;for(let v=0;v<=t.heightSegments;v++){let y=v*Math.PI/t.heightSegments+a,g=Math.sin(y),E=Math.cos(y);for(let w=0;w<=t.widthSegments;w++){let T=w*2*Math.PI/t.widthSegments,R=Math.sin(T),P=Math.cos(T),V=t.radius*P*g,z=t.radius*E,k=t.radius*R*g,W=S.fromCopyArray([V,z,k]);o.push(V),o.push(z),o.push(k);let X=1-w/t.widthSegments,j=v/t.heightSegments;r.push(X),r.push(j);let ae=S.normalize(W);i.push(t.inverseNormal?-ae.x:ae.x),i.push(t.inverseNormal?-ae.y:ae.y),i.push(t.inverseNormal?-ae.z:ae.z)}}let s=[];for(let v=0;v<t.heightSegments;v++)for(let y=0;y<t.widthSegments;y++){let g=v*(t.widthSegments+1)+y,E=g+t.widthSegments+1;s.push(g+1),s.push(E),s.push(g),s.push(g+1),s.push(E+1),s.push(E)}let l=[ee.Position.XYZ,ee.Normal.XYZ,ee.Texcoord0.XY],c=Re.Triangles,u=[new Float32Array(o),new Float32Array(i),new Float32Array(r)];this.copyVertexData({attributes:u,attributeSemantics:l,primitiveMode:c,indices:new Uint16Array(s),material:t.material})}};h(dx,"Sphere");var hl=dx;kc();var px=class px{constructor(n,t){f(this,"__semantic");f(this,"__components",[]);f(this,"__offsets",[]);this.__semantic=n,this.__offsets=[],this.__components=[];for(let[o,r]of t){let i=o.split(",");for(let a=0;a<i.length;a++){let s=i[a];s===n.X&&(this.__offsets[0]=a,this.__components[0]=r),s===n.Y&&(this.__offsets[1]=a,this.__components[1]=r),s===n.Z&&(this.__offsets[2]=a,this.__components[2]=r),s===n.W&&(this.__offsets[3]=a,this.__components[3]=r)}}}get semantic(){return this.__semantic}getScalarAsArray(n,t){return[this.__components[0].getScalarAt(n,this.__offsets[0],t)]}getVec2AsArray(n,t){return[this.__components[0].getScalarAt(n,this.__offsets[0],t),this.__components[1].getScalarAt(n,this.__offsets[1],t)]}getVec3AsArray(n,t){return[this.__components[0].getScalarAt(n,this.__offsets[0],t),this.__components[1].getScalarAt(n,this.__offsets[1],t),this.__components[2].getScalarAt(n,this.__offsets[2],t)]}getVec4AsArray(n,t){return[this.__components[0].getScalarAt(n,this.__offsets[0],t),this.__components[1].getScalarAt(n,this.__offsets[1],t),this.__components[2].getScalarAt(n,this.__offsets[2],t),this.__components[3].getScalarAt(n,this.__offsets[3],t)]}};h(px,"ComplexVertexAttribute");var hx=px;wh();ai();_o();var vx=class vx{constructor(n,t){f(this,"__semantic");f(this,"__accessor");this.__semantic=n,this.__accessor=t}get semantic(){return this.__semantic}getScalarAsArray(n,t){return[this.__accessor.getScalar(n,t)]}getVec2AsArray(n,t){return this.__accessor.getVec2AsArray(n,t)}getVec3AsArray(n,t){return this.__accessor.getVec3AsArray(n,t)}getVec4AsArray(n,t){return this.__accessor.getVec4AsArray(n,t)}};h(vx,"SimpleVertexAttribute");var xx=vx;yp();Ia();bp();wp();Ep();Tp();at();dr();ul();function f5(){let m=en(),n=ne.tryToAddComponentToEntityByTID(Q.LightComponentTID,m),t=ne.tryToAddComponentToEntityByTID(Q.CameraComponentTID,n);return t.getCamera().isSyncToLight=!0,t}h(f5,"createLightWithCameraEntity");_r();Vo();kr();Pn();var Gm;function u5(m){let n=new Dt;return n.toClearColorBuffer=!1,n.toClearDepthBuffer=!1,n.isDepthTest=!1,n.setBufferLessFullScreenRendering(m),n}h(u5,"createScreenDrawRenderPass");function m5(m,n,t){Gm===void 0&&(Gm=new Ge({magFilter:U.Linear,minFilter:U.Linear,wrapS:U.ClampToEdge,wrapT:U.ClampToEdge}),Gm.create()),m.setTextureParameter("baseColorTexture",n,t!=null?t:Gm);let o=new Dt;return o.toClearColorBuffer=!1,o.toClearDepthBuffer=!1,o.isDepthTest=!1,o.setBufferLessFullScreenRendering(m),o}h(m5,"createScreenDrawRenderPassWithBaseColorTexture");var Pr=Object.freeze({createScreenDrawRenderPass:u5,createScreenDrawRenderPassWithBaseColorTexture:m5});zn();ft();ju();yc();Ac();Zc();Ze();Ke();var gx=class gx extends nt{constructor(){super();f(this,"__colorAttachments",[]);f(this,"__depthAttachment");f(this,"__stencilAttachment");f(this,"__depthStencilAttachment");f(this,"cgApiResourceUid",G.InvalidCGAPIResourceUid);f(this,"width",0);f(this,"height",0);f(this,"__colorAttachmentMap",new Map)}get colorAttachmentsRenderBufferTargets(){return Array.from(this.__colorAttachmentMap.keys())}get colorAttachments(){return this.__colorAttachments}get depthAttachment(){return this.__depthAttachment}get stencilAttachment(){return this.__stencilAttachment}get depthStencilAttachment(){return this.__depthStencilAttachment}getColorAttachedRenderTargetTexture(t){if(!(this.__colorAttachments[t]==null||!(this.__colorAttachments[t]instanceof Jo||this.__colorAttachments[t]instanceof eo||this.__colorAttachments[t]instanceof No)))return this.__colorAttachments[t]}getDepthAttachedRenderTargetTexture(){if(this.__depthAttachment instanceof Jo||this.__depthAttachment instanceof eo||this.__depthAttachment instanceof No)return this.__depthAttachment}create(t,o){this.width=t,this.height=o;let r=G.getCgApiResourceRepository();return this.cgApiResourceUid=r.createFrameBufferObject(),this.cgApiResourceUid}get framebufferUID(){return this.cgApiResourceUid}setColorAttachmentAt(t,o){return o.width!==this.width||o.height!==this.height?!1:(this.__colorAttachments[t]=o,G.getCgApiResourceRepository().attachColorBufferToFrameBufferObject(this,t,o),this.__colorAttachmentMap.set(la.from(t),o),!0)}setColorAttachmentLayerAt(t,o,r,i){if(o.width!==this.width||o.height!==this.height)return!1;this.__colorAttachments[t]=o;let a=G.getCgApiResourceRepository();return K.currentProcessApproach===Z.WebGPU?o instanceof eo&&o.changeRenderTargetLayerWebGPU(r):a.attachColorBufferLayerToFrameBufferObject(this,t,o,r,i),this.__colorAttachmentMap.set(la.from(t),o),!0}setColorAttachmentCubeAt(t,o,r,i){return i.width!==this.width||i.height!==this.height?!1:(this.__colorAttachments[t]=i,G.getCgApiResourceRepository().attachColorBufferCubeToFrameBufferObject(this,t,o,r,i),i.createCubeTextureViewAsRenderTarget(o,r),this.__colorAttachmentMap.set(la.from(t),i),!0)}setDepthAttachment(t){return t.width!==this.width||t.height!==this.height?!1:(this.__depthAttachment=t,G.getCgApiResourceRepository().attachDepthBufferToFrameBufferObject(this,t),!0)}setStencilAttachment(t){return t.width!==this.width||t.height!==this.height?!1:(this.__stencilAttachment=t,G.getCgApiResourceRepository().attachStencilBufferToFrameBufferObject(this,t),!0)}setDepthStencilAttachment(t){return t.width!==this.width||t.height!==this.height?!1:(this.__depthStencilAttachment=t,G.getCgApiResourceRepository().attachDepthStencilBufferToFrameBufferObject(this,t),!0)}resize(t,o){G.getCgApiResourceRepository().deleteFrameBufferObject(this.cgApiResourceUid),this.cgApiResourceUid=G.InvalidCGAPIResourceUid,this.width=0,this.height=0,this.create(t,o),this.depthAttachment&&(this.depthAttachment.resize(t,o),this.setDepthAttachment(this.depthAttachment)),this.depthStencilAttachment&&(this.depthStencilAttachment.resize(t,o),this.setDepthStencilAttachment(this.depthStencilAttachment)),this.stencilAttachment&&(this.stencilAttachment.resize(t,o),this.setStencilAttachment(this.stencilAttachment));for(let i=0;i<this.colorAttachments.length;i++)this.colorAttachments[i].resize(t,o),this.setColorAttachmentAt(i,this.colorAttachments[i])}destroy3DAPIResources(){G.getCgApiResourceRepository().deleteFrameBufferObject(this.cgApiResourceUid),this.cgApiResourceUid=G.InvalidCGAPIResourceUid,this.width=0,this.height=0,this.depthAttachment&&(this.depthAttachment.destroy3DAPIResources(),this.__depthAttachment=void 0),this.depthStencilAttachment&&(this.depthStencilAttachment.destroy3DAPIResources(),this.__depthStencilAttachment=void 0),this.stencilAttachment&&(this.stencilAttachment.destroy3DAPIResources(),this.__stencilAttachment=void 0);for(let o of this.colorAttachments)o.destroy3DAPIResources();this.__colorAttachmentMap=new Map}whichColorAttachment(t){return this.__colorAttachments.indexOf(t)}};h(gx,"FrameBuffer");var Hr=gx;yc();xe();Lo();zn();ft();Ze();Ke();pn();var yx=class yx extends nt{constructor(){super();f(this,"width",0);f(this,"height",0);f(this,"__internalFormat",oe.Depth24);f(this,"_textureResourceUid",-1);f(this,"_textureViewResourceUid",-1);f(this,"_textureViewAsRenderTargetResourceUid",-1);f(this,"__fbo");f(this,"__isMSAA",!1);f(this,"__sampleCountMSAA",4)}set _fbo(t){this.__fbo=t}get fbo(){return this.__fbo}get sampleCount(){return this.__sampleCountMSAA}create(t,o,r,{isMSAA:i=!1,sampleCountMSAA:a=this.__sampleCountMSAA}={}){this.width=t,this.height=o,this.__isMSAA=i,this.__sampleCountMSAA=a,this.__internalFormat=r;let s=G.getCgApiResourceRepository();this._textureResourceUid=s.createRenderBuffer(t,o,r,i,a),K.currentProcessApproach===Z.WebGPU&&(this._textureViewResourceUid=s.createTextureView2d(this._textureResourceUid),this._textureViewAsRenderTargetResourceUid=s.createTextureViewAsRenderTarget(this._textureResourceUid))}createCubeTextureViewAsRenderTarget(t,o){}resize(t,o){this.destroy3DAPIResources(),this.create(t,o,this.__internalFormat,{isMSAA:this.__isMSAA})}destroy3DAPIResources(){return this.width=0,this.height=0,G.getCgApiResourceRepository().deleteRenderBuffer(this._textureResourceUid),this._textureResourceUid=G.InvalidCGAPIResourceUid,!0}};h(yx,"RenderBuffer");var pl=yx;pn();Sr();dm();yc();Ac();Zc();Ni();Su();Lo();xe();Sr();ft();co();pn();var nr,gf=class gf extends mn{constructor(){super();f(this,"__imageData");f(this,"autoResize",!0);f(this,"autoDetectTransparency",!1);Yr(this,nr)}__getResizedCanvas(t,o){let r=document.createElement("canvas"),i=ie.getNearestPowerOfTwo(t.width),a=ie.getNearestPowerOfTwo(t.height),s=a/i,l=0,c=0;i>a?(l=Math.min(i,o),c=l*s):(c=Math.min(a,o),l=c/s),r.width=l,r.height=c;let u=r.getContext("2d");if(u.drawImage(t,0,0,t.width,t.height,0,0,l,c),this.autoDetectTransparency){this.__imageData=u.getImageData(0,0,l,c);for(let _=0;_<c;_++)for(let d=0;d<l;d++)if(this.__imageData.data[(d+_*l)*4+3]<1)return this.__hasTransparentPixels=!0,r;this.__hasTransparentPixels=!1}return r}generateTextureFromVideo(t,{level:o=0,internalFormat:r=oe.RGBA8,format:i=ue.RGBA,type:a=I.UnsignedByte,generateMipmap:s=!1,mutedAutoPlay:l=!0}={}){this.__startedToLoad=!0,Fr(this,nr,t),l&&(t.autoplay=!0,t.muted=!0);let c=t;this.__width=c.videoWidth,this.__height=c.videoHeight;let _=G.getCgApiResourceRepository().createTextureFromImageBitmapData(c,{level:o,internalFormat:r,width:this.__width,height:this.__height,border:0,format:i,type:a,generateMipmap:s});this._textureResourceUid=_,this.__isTextureReady=!0,this.__uri=t.src}generateTextureFromUri(t,{level:o=0,internalFormat:r=oe.RGBA8,format:i=ue.RGBA,type:a=I.UnsignedByte,generateMipmap:s=!1,mutedAutoPlay:l=!0,playButtonDomElement:c=void 0}={}){return this.__uri=t,this.__startedToLoad=!0,new Promise((u,_)=>{let d=c,p=h(()=>{this.__width=x.videoWidth,this.__height=x.videoHeight;let y=G.getCgApiResourceRepository().createTextureFromImageBitmapData(x,{level:o,internalFormat:r,width:this.__width,height:this.__height,border:0,format:i,type:a,generateMipmap:s});this._textureResourceUid=y,this.__isTextureReady=!0,u()},"setupTexture");d==null||d.addEventListener("click",()=>{p(),x.play()},!0);let x=document.createElement("video");x.crossOrigin="anonymous",x.setAttribute("playsinline","playsinline"),l&&(x.autoplay=!0,x.muted=!0),x.preload="auto",Fr(this,nr,x),x.addEventListener("canplaythrough",()=>{p(),x.play()},!0),x.addEventListener("ended",()=>{x.play()},!0),x.src=t})}updateTexture(){let t=G.getWebGLResourceRepository();this.__isTextureReady&&Do(this,nr)&&t.updateTexture(this._textureResourceUid,Do(this,nr),{level:0,xoffset:0,yoffset:0,width:this.__width,height:this.__height,format:ue.RGBA,type:I.UnsignedByte})}getCurrentFramePixelData(){let t,o=G.getWebGLResourceRepository();return this.__isTextureReady&&Do(this,nr)&&(t=o.getPixelDataFromTexture(this._textureResourceUid,0,0,this.width,this.height)),[t,this.width,this.height]}set playbackRate(t){Do(this,nr)&&(Do(this,nr).playbackRate=t)}get playbackRate(){var o;let t=(o=Do(this,nr))==null?void 0:o.playbackRate;return t!=null?t:1}play(){var t;(t=Do(this,nr))==null||t.play()}pause(){Do(this,nr).pause()}};nr=new WeakMap,h(gf,"VideoTexture"),f(gf,"__loadedBasisFunc",!1),f(gf,"__basisLoadPromise");var bx=gf;Pn();function _5(m){var t;let n=new Hr;n.create(m.width,m.height);for(let o=0;o<m.textureNum;o++){let r=new Jo;r.create({width:m.width,height:m.height,mipLevelCount:m.mipLevelCount,format:m.textureFormats[o]}),n.setColorAttachmentAt(o,r)}if(m.createDepthBuffer){let o=new Jo,r=(t=m.depthTextureFormat)!=null?t:oe.Depth32F;o.create({width:m.width,height:m.height,mipLevelCount:1,format:r}),n.setDepthAttachment(o)}return n}h(_5,"createFrameBuffer");function d5(m){let n=new Hr;n.create(m.width,m.height);for(let o=0;o<m.colorBufferNum;o++){let r=new pl;r.create(m.width,m.height,m.colorFormats[o],{isMSAA:!0,sampleCountMSAA:m.sampleCountMSAA}),n.setColorAttachmentAt(o,r)}let t=new pl;return t.create(m.width,m.height,m.depthBufferFormat,{isMSAA:!0,sampleCountMSAA:m.sampleCountMSAA}),n.setDepthAttachment(t),n}h(d5,"createFrameBufferMSAA");function h5(m){let n=new Hr;n.create(m.width,m.height);let t=new eo;return t.create({width:m.width,height:m.height,level:m.level,internalFormat:m.internalFormat,format:m.format,type:m.type,arrayLength:m.arrayLength}),n.setColorAttachmentLayerAt(0,t,0,0),[n,t]}h(h5,"createFrameBufferTextureArray");function p5(m){let n=new Hr;n.create(m.width,m.height);let t=new eo;t.create({width:m.width,height:m.height,level:m.level,internalFormat:m.internalFormat,format:m.format,type:m.type,arrayLength:m.arrayLength}),n.setColorAttachmentAt(0,t);let o=new eo;return o.create({width:m.width,height:m.height,level:m.level,internalFormat:oe.Depth32FStencil8,format:ue.DepthStencil,type:I.Float,arrayLength:m.arrayLength}),n.setDepthStencilAttachment(o),n}h(p5,"createFrameBufferTextureArrayForMultiView");function x5(m){let n=new Hr;n.create(m.width,m.height);let t=new No;return t.create({width:m.width,height:m.height,mipLevelCount:m.mipLevelCount,format:m.textureFormat}),n.setColorAttachmentCubeAt(0,0,0,t),[n,t]}h(x5,"createFrameBufferCubeMap");function v5(m,n,{level:t=0,internalFormat:o=oe.Depth32F}){let r=new Hr;r.create(m,n);let i=new Jo;return i.create({width:m,height:n,mipLevelCount:1,format:o}),r.setDepthAttachment(i),r}h(v5,"createDepthBuffer");var tn=Object.freeze({createFrameBuffer:_5,createFrameBufferMSAA:d5,createFrameBufferTextureArray:h5,createFrameBufferTextureArrayForMultiView:p5,createFrameBufferCubeMap:x5,createDepthBuffer:v5});nn();Xo();Ci();Ao();pn();var Ax=class Ax{constructor(){f(this,"__mapReducedFramebuffer",new Map);f(this,"__mapDetectHighLuminanceFramebuffer",new Map);f(this,"__mapSynthesizeFramebuffer",new Map)}createBloomExpression({textureToBloom:n,parameters:{luminanceCriterion:t=1,gaussianBlurLevelHighLuminance:o=4,gaussianKernelSize:r=10,gaussianVariance:i=10,synthesizeCoefficient:a=[1,1/o,1/o,1/o,1/o,1/o]}}){let s=this.__createRenderPassDetectHighLuminance(n,t),l=this.__createRenderPassesBlurredHighLuminance(s,o,r,i,n.width,n.height),c=this.__createRenderPassSynthesizeImage(n,l,a),u=new gn;return u.addRenderPasses([s,...l,c]),{bloomExpression:u,bloomedRenderTarget:c.getFramebuffer().colorAttachments[0]}}__createRenderPassDetectHighLuminance(n,t){let o=Oe.createDetectHighLuminanceMaterial({maxInstancesNumber:1},n);o.setParameter("luminanceCriterion",t);let r=Pr.createScreenDrawRenderPass(o);r.tryToSetUniqueName("renderPassDetectHighLuminance",!0);let i=`${n.width}_${n.height}`,a=this.__mapDetectHighLuminanceFramebuffer.get(i);return a==null&&(a=tn.createFrameBuffer({width:n.width,height:n.height,textureNum:1,textureFormats:[oe.RGBA8],createDepthBuffer:!1}),this.__mapDetectHighLuminanceFramebuffer.set(i,a)),r.setFramebuffer(a),r}__createRenderPassesBlurredHighLuminance(n,t,o,r,i,a){let s=[];for(let l=0;l<t;l++){let c=Math.max(i>>l+1,1),u=Math.max(a>>l+1,1),_;l===0?_=this.__createRenderPassGaussianBlur(n,o,r,!0,c,u):_=this.__createRenderPassGaussianBlur(s[s.length-1],o,r,!0,c,u),_.tryToSetUniqueName("renderPassBlurH_"+l,!0);let d=this.__createRenderPassGaussianBlur(_,o,r,!1,c,u);d.tryToSetUniqueName("renderPassBlurHV_"+l,!0),s.push(_,d)}return s}__createRenderPassGaussianBlur(n,t,o,r,i,a){let s=Oe.createGaussianBlurMaterial(),l=Y.computeGaussianDistributionRatioWhoseSumIsOne({kernelSize:t,variance:o});s.setParameter("gaussianKernelSize",t),s.setParameter("gaussianRatio",new ve(new Float32Array(l))),s.setParameter("framebufferSize",Ee.fromCopy2(i,a)),r===!1&&s.setParameter("isHorizontal",!1);let u=n.getFramebuffer().colorAttachments[0],_=Pr.createScreenDrawRenderPassWithBaseColorTexture(s,u),d=`${i}_${a}_${r}`,p=this.__mapReducedFramebuffer.get(d);return p==null&&(p=tn.createFrameBuffer({width:i,height:a,textureNum:1,textureFormats:[oe.RGBA8],createDepthBuffer:!1}),this.__mapReducedFramebuffer.set(d,p)),_.setFramebuffer(p),_}__createRenderPassSynthesizeImage(n,t,o){let r=[n];for(let c=1;c<t.length;c+=2)r.push(t[c].getFramebuffer().colorAttachments[0]);let i=Oe.createSynthesizeHDRMaterial({maxInstancesNumber:1},r);i.setParameter("synthesizeCoefficient",o);let a=Pr.createScreenDrawRenderPass(i);a.tryToSetUniqueName("renderPassSynthesizeGlare",!0);let s=`${n.width}_${n.height}`,l=this.__mapSynthesizeFramebuffer.get(s);return l==null&&(l=tn.createFrameBuffer({width:n.width,height:n.height,textureNum:1,textureFormats:[oe.R11F_G11F_B10F],createDepthBuffer:!1}),this.__mapSynthesizeFramebuffer.set(s,l)),a.setFramebuffer(l),a}destroy3DAPIResources(){this.__mapReducedFramebuffer.forEach(n=>{n.destroy3DAPIResources()}),this.__mapDetectHighLuminanceFramebuffer.forEach(n=>{n.destroy3DAPIResources()}),this.__mapSynthesizeFramebuffer.forEach(n=>{n.destroy3DAPIResources()}),this.__mapReducedFramebuffer.clear(),this.__mapDetectHighLuminanceFramebuffer.clear(),this.__mapSynthesizeFramebuffer.clear()}};h(Ax,"Bloom");var yf=Ax;un();nn();Xo();Ao();Ci();_r();var Ix=class Ix{constructor(){f(this,"__mapReducedFramebuffer",new Map);f(this,"__mapSynthesizeFramebuffer",new Map)}createGaussianBlurExpression({textureToBlur:n,parameters:{blurPassLevel:t=4,gaussianKernelSize:o=10,gaussianVariance:r=10,synthesizeCoefficient:i=[1,1,1,1,1,1],isReduceBuffer:a=!0,textureFormat:s=oe.RGBA16F,outputFrameBuffer:l=void 0,outputFrameBufferLayerIndex:c=0}}){let u=this.__createBlurPasses(n,t,o,r,n.width,n.height,a,s),_=this.__createRenderPassSynthesizeImage(n,u,i,s,l,c),d=new gn;return d.addRenderPasses([...u,_]),{blurExpression:d,blurredRenderTarget:_.getFramebuffer().colorAttachments[0],renderPassesBlurred:u}}__createBlurPasses(n,t,o,r,i,a,s,l){let c=[];for(let u=0;u<t;u++){let _=s?Math.max(i>>u+1,1):i,d=s?Math.max(a>>u+1,1):a,p;u===0?p=this.__createRenderPassGaussianBlur(n,o,r,!0,_,d,l):p=this.__createRenderPassGaussianBlur(c[c.length-1].getFramebuffer().getColorAttachedRenderTargetTexture(0),o,r,!0,_,d,l),p.tryToSetUniqueName("renderPassBlurH_"+u,!0);let x=this.__createRenderPassGaussianBlur(p.getFramebuffer().getColorAttachedRenderTargetTexture(0),o,r,!1,_,d,l);x.tryToSetUniqueName("renderPassBlurHV_"+u,!0),c.push(p,x)}return c}__createRenderPassSynthesizeImage(n,t,o,r,i,a){let s=[n];for(let _=1;_<t.length;_+=2)s.push(t[_].getFramebuffer().colorAttachments[0]);let l=Oe.createSynthesizeHDRMaterial({maxInstancesNumber:1},s);l.setParameter("synthesizeCoefficient",o);let c=Pr.createScreenDrawRenderPass(l);c.tryToSetUniqueName("renderPassSynthesizeBlur",!0);let u=i;if(u==null){let _=`${n.width}x${n.height}_${r.str}`;u=this.__mapSynthesizeFramebuffer.get(_),u==null&&(u=tn.createFrameBuffer({width:n.width,height:n.height,textureNum:1,textureFormats:[r],createDepthBuffer:!1}),this.__mapSynthesizeFramebuffer.set(_,u))}return c.setFramebuffer(u),i!=null&&c.setPreRenderFunction(()=>{i.setColorAttachmentLayerAt(0,u.getColorAttachedRenderTargetTexture(0),a,0)}),c}__createRenderPassGaussianBlur(n,t,o,r,i,a,s){let l=Oe.createGaussianBlurMaterial(),c=Y.computeGaussianDistributionRatioWhoseSumIsOne({kernelSize:t,variance:o});l.setParameter("gaussianKernelSize",t),l.setParameter("gaussianRatio",new ve(new Float32Array(c))),l.setParameter("framebufferSize",Ee.fromCopy2(i,a)),r===!1&&l.setParameter("isHorizontal",!1);let u=Pr.createScreenDrawRenderPassWithBaseColorTexture(l,n),_=`${i}x${a}_${s.str}_${r}`,d=this.__mapReducedFramebuffer.get(_);return d==null&&(d=tn.createFrameBuffer({width:i,height:a,textureNum:1,textureFormats:[s],createDepthBuffer:!1}),this.__mapReducedFramebuffer.set(_,d)),u.setFramebuffer(d),u}destroy3DAPIResources(){this.__mapReducedFramebuffer.forEach(n=>{n.destroy3DAPIResources()}),this.__mapSynthesizeFramebuffer.forEach(n=>{n.destroy3DAPIResources()}),this.__mapReducedFramebuffer.clear(),this.__mapSynthesizeFramebuffer.clear()}};h(Ix,"GaussianBlur");var bf=Ix;_r();qc();ai();ye();Hc();yr();ml();at();Kc();st();var xl,l4=(xl=class extends fe{constructor({index:n,str:t}){super({index:n,str:t})}},h(xl,"PhysicsShapeTypeClass"),xl),c4=new l4({index:0,str:"Sphere"}),f4=new l4({index:1,str:"Box"}),u4=[c4,f4];function g5(m){return de({typeList:u4,index:m})}h(g5,"from");function y5(m){return Te({typeList:u4,str:m})}h(y5,"fromString");var Af=Object.freeze({Sphere:c4,Box:f4,from:g5,fromString:y5});si();var b5=h((m={})=>{let n=new er;n.generate(m);let t=Gi(n);return A.not.exist(m.direction)&&(m.direction="xz"),m.direction==="xy"?t.localEulerAngles=S.fromCopy3(Math.PI/2,0,0):m.direction==="yz"&&(t.localEulerAngles=S.fromCopy3(0,0,Math.PI/2)),t},"createPlane"),A5=h((m={})=>{let n=new vf;return n.generate(m),Gi(n)},"createLine"),I5=h((m={})=>{let n=new pf;return n.generate(m),Gi(n)},"createGrid"),S5=h((m={})=>{var o;let n=new io;n.generate(m);let t=Gi(n);if(A.exist(m.physics)&&m.physics.use){let r=ne.addComponentToEntity(Uo,t),i=r.getPhysics(),a=new Ro,s={type:Af.Box,size:(o=m.widthVector)!=null?o:S.fromCopy3(1,1,1),position:S.fromCopy3(0,0,0),rotation:S.fromCopy3(0,0,0),move:m.physics.move,density:m.physics.density,friction:m.physics.friction,restitution:m.physics.restitution};a.setShape(s,r),i.setStrategy(a)}return t},"createCube"),T5=h((m,n={})=>{var i;let t=new io;t.generate(n);let o=new _t;o.addPrimitive(t);let r=[];for(let a=0;a<m;a++){let s=Ct();if(s.getMesh().setMesh(o),A.exist(n.physics)&&n.physics.use){let c=ne.addComponentToEntity(Uo,s),u=c.getPhysics(),_=new Ro,d={type:Af.Box,size:(i=n.widthVector)!=null?i:S.fromCopy3(1,1,1),position:S.fromCopy3(0,0,0),rotation:S.fromCopy3(0,0,0),move:n.physics.move,density:n.physics.density,friction:n.physics.friction,restitution:n.physics.restitution};_.setShape(d,c),u.setStrategy(_)}r.push(s)}return r},"createCubes"),E5=h((m={})=>{let n=new hl;n.generate(m);let t=Gi(n);if(A.exist(m.physics)&&m.physics.use){let o=ne.addComponentToEntity(Uo,t),r=o.getPhysics(),i=new Ro,a={type:Af.Sphere,size:A.exist(m.radius)?S.fromCopy3(m.radius,m.radius,m.radius):S.fromCopy3(1,1,1),position:S.fromCopy3(0,0,0),rotation:S.fromCopy3(0,0,0),move:m.physics.move,density:m.physics.density,friction:m.physics.friction,restitution:m.physics.restitution};i.setShape(a,o),r.setStrategy(i)}return t},"createSphere"),C5=h((m,n={})=>{let t=new hl;t.generate(n);let o=new _t;o.addPrimitive(t);let r=[];for(let i=0;i<m;i++){let a=Ct();if(a.getMesh().setMesh(o),A.exist(n.physics)&&n.physics.use){let l=ne.addComponentToEntity(Uo,a),c=l.getPhysics(),u=new Ro,_={type:Af.Sphere,size:A.exist(n.radius)?S.fromCopy3(n.radius,n.radius,n.radius):S.fromCopy3(1,1,1),position:S.fromCopy3(0,0,0),rotation:S.fromCopy3(0,0,0),move:n.physics.move,density:n.physics.density,friction:n.physics.friction,restitution:n.physics.restitution};u.setShape(_,l),c.setStrategy(u)}r.push(a)}return r},"createSpheres"),w5=h((m={})=>{let n=new xf;return n.generate(m),Gi(n)},"createJoint"),R5=h((m={})=>{let n=new hf;return n.generate(m),Gi(n)},"createAxis");function Gi(m){let n=Ct(),t=n.getMesh(),o=new _t;return o.addPrimitive(m),t.setMesh(o),n}h(Gi,"createShape");var N5=Object.freeze({createPlane:b5,createLine:A5,createGrid:I5,createCube:S5,createCubes:T5,createSphere:E5,createSpheres:C5,createJoint:w5,createAxis:R5,createShape:Gi});pn();It();kr();_r();var Sx=class Sx{constructor(){f(this,"__shadowMomentFramebuffer");f(this,"__shadowMomentMaterial");this.__shadowMomentFramebuffer=tn.createFrameBuffer({width:1024,height:1024,textureNum:1,textureFormats:[oe.RG16F],createDepthBuffer:!0,depthTextureFormat:oe.Depth32F}),this.__shadowMomentMaterial=Oe.createDepthMomentEncodeMaterial()}getRenderPasses(n,t){let o=new Dt;return o.clearColor=q.fromCopyArray([1,1,1,1]),o.toClearColorBuffer=!0,o.toClearDepthBuffer=!0,o.cameraComponent=t.getCamera(),o.addEntities(n),o.setFramebuffer(this.__shadowMomentFramebuffer),o.setMaterial(this.__shadowMomentMaterial),[o]}getShadowMomentFramebuffer(){return this.__shadowMomentFramebuffer}};h(Sx,"ShadowMap");var If=Sx;tt();pn();It();kr();_r();var Tx=class Tx{constructor(){f(this,"__shadowMomentFramebuffer");f(this,"__shadowMomentFrontMaterials",[]);f(this,"__shadowMomentBackMaterials",[]);this.__shadowMomentFramebuffer=tn.createFrameBuffer({width:1024,height:1024,textureNum:1,textureFormats:[oe.RGBA16F],createDepthBuffer:!0,depthTextureFormat:oe.Depth32F});for(let n=0;n<F.shadowMapTextureArrayLength;n++){let t=Oe.createParaboloidDepthMomentEncodeMaterial();t.colorWriteMask=[!0,!0,!1,!1],this.__shadowMomentFrontMaterials.push(t);let o=Oe.createParaboloidDepthMomentEncodeMaterial();o.colorWriteMask=[!1,!1,!0,!0],o.setParameter("frontHemisphere",!1),this.__shadowMomentBackMaterials.push(o)}}getRenderPasses(n,t){let o=t.getLight().componentSID,r=new Dt;r.clearColor=q.fromCopyArray([1,1,1,1]),r.toClearColorBuffer=!0,r.toClearDepthBuffer=!0,r.addEntities(n),r.setFramebuffer(this.__shadowMomentFramebuffer),r.setMaterial(this.__shadowMomentFrontMaterials[o]),this.__shadowMomentFrontMaterials[o].setParameter("lightIndex",o);let i=new Dt;return i.toClearColorBuffer=!1,i.toClearDepthBuffer=!0,i.addEntities(n),i.setFramebuffer(this.__shadowMomentFramebuffer),i.setMaterial(this.__shadowMomentBackMaterials[o]),this.__shadowMomentBackMaterials[o].setParameter("lightIndex",o),[r,i]}getShadowMomentFramebuffer(){return this.__shadowMomentFramebuffer}};h(Tx,"PointShadowMap");var Sf=Tx;wa();St();tt();xe();Cs();Lo();pn();Vo();Ao();Ci();Pn();var Ex=class Ex{constructor(n){f(this,"__shadowMap");f(this,"__pointShadowMap");f(this,"__gaussianBlur");f(this,"__shadowMapArrayFramebuffer");f(this,"__pointShadowMapArrayFramebuffer");f(this,"__lightTypes",[]);f(this,"__lightEnables",[]);f(this,"__lightCastShadows",[]);this.__shadowMap=new If,this.__pointShadowMap=new Sf,this.__gaussianBlur=new bf;let[t,o]=tn.createFrameBufferTextureArray({width:n,height:n,arrayLength:F.shadowMapTextureArrayLength,level:0,internalFormat:oe.RG16F,format:ue.RG,type:I.Float});this.__shadowMapArrayFramebuffer=t;let[r,i]=tn.createFrameBufferTextureArray({width:n,height:n,arrayLength:F.shadowMapTextureArrayLength,level:0,internalFormat:oe.RGBA16F,format:ue.RGBA,type:I.Float});this.__pointShadowMapArrayFramebuffer=r}getExpressions(n){let t=[],o=[],r=0,i=0,a=J.getComponentsWithType(Mo);for(let s=0;s<a.length;s++){let l=a[s];if(this.__lightTypes[s]=l.type,this.__lightEnables[s]=l.enable,this.__lightCastShadows[s]=l.castShadow,!(l.enable&&l.castShadow)){o.push(-1);continue}if(l.type===Fo.Point){let c=new gn;c.addRenderPasses(this.__pointShadowMap.getRenderPasses(n,l.entity)),t.push(c);let{blurExpression:u,blurredRenderTarget:_,renderPassesBlurred:d}=this.__gaussianBlur.createGaussianBlurExpression({textureToBlur:this.__pointShadowMap.getShadowMomentFramebuffer().getColorAttachedRenderTargetTexture(0),parameters:{blurPassLevel:4,gaussianKernelSize:5,gaussianVariance:5,synthesizeCoefficient:[1/5,1/5,1/5,1/5,1/5,1/5],isReduceBuffer:!1,textureFormat:oe.RGBA16F,outputFrameBuffer:this.__pointShadowMapArrayFramebuffer,outputFrameBufferLayerIndex:i}});this.__setParaboloidBlurredShadowMap(_,n),t.push(u),o.push(i),i++}else if(l.type===Fo.Spot||l.type===Fo.Directional){let c=new gn;c.addRenderPasses(this.__shadowMap.getRenderPasses(n,l.entity)),t.push(c);let{blurExpression:u,blurredRenderTarget:_,renderPassesBlurred:d}=this.__gaussianBlur.createGaussianBlurExpression({textureToBlur:this.__shadowMap.getShadowMomentFramebuffer().getColorAttachedRenderTargetTexture(0),parameters:{blurPassLevel:4,gaussianKernelSize:5,gaussianVariance:5,synthesizeCoefficient:[1/5,1/5,1/5,1/5,1/5,1/5],isReduceBuffer:!0,textureFormat:oe.RG16F,outputFrameBuffer:this.__shadowMapArrayFramebuffer,outputFrameBufferLayerIndex:r}});this.__setBlurredShadowMap(_,n),t.push(u),o.push(r),r++}else o.push(-1)}return this.__setDepthTextureIndexList(n,o),t}__setBlurredShadowMap(n,t){let o=new Ge({minFilter:U.Linear,magFilter:U.Linear,wrapS:U.ClampToEdge,wrapT:U.ClampToEdge});o.create();for(let r of t){let i=r.tryToGetMesh();if(i!=null&&i.mesh!=null)for(let a=0;a<i.mesh.getPrimitiveNumber();a++)i.mesh.getPrimitiveAt(a).material.setTextureParameter("depthTexture",n,o)}}__setParaboloidBlurredShadowMap(n,t){let o=new Ge({minFilter:U.Linear,magFilter:U.Linear,wrapS:U.ClampToEdge,wrapT:U.ClampToEdge});o.create();for(let r of t){let i=r.tryToGetMesh();if(i!=null&&i.mesh!=null)for(let a=0;a<i.mesh.getPrimitiveNumber();a++){let s=i.mesh.getPrimitiveAt(a);s.material.setTextureParameter("paraboloidDepthTexture",n,o),s.material.setParameter("pointLightShadowMapUvScale",.93)}}}__setDepthTextureIndexList(n,t){for(let o of n){let r=o.tryToGetMesh();if(r!=null&&r.mesh!=null)for(let i=0;i<r.mesh.getPrimitiveNumber();i++)r.mesh.getPrimitiveAt(i).material.setParameter("depthTextureIndexList",new ve(new Int32Array(t)))}}setDepthBiasPV(n){let t=new Float32Array(F.maxLightNumberInShader*16),o=J.getComponentsWithType(Mo);for(let r=0;r<o.length;r++){let i=o[r],a=i.entity;if(i.type===Fo.Directional||i.type===Fo.Spot){let s=a.tryToGetCamera();if(s!=null){let l=s.biasViewProjectionMatrix;t.set(l._v,r*16)}}}for(let r of n){let i=r.tryToGetMesh();if(i!=null&&i.mesh!=null)for(let a=0;a<i.mesh.getPrimitiveNumber();a++){let s=i.mesh.getPrimitiveAt(a);s.material.__materialTypeName.includes("Pbr")&&s.material.setParameter("depthBiasPV",new ve(t))}}}isLightChanged(){let n=J.getComponentsWithType(Mo);if(this.__lightTypes.length!==n.length)return!0;for(let t=0;t<n.length;t++){let o=n[t];if(this.__lightTypes[t]!==o.type||this.__lightEnables[t]!==o.enable||this.__lightCastShadows[t]!==o.castShadow)return!0}return!1}};h(Ex,"ShadowSystem");var Tf=Ex;Ma();at();Co();Hl();ge();ul();$p();Mm();me();Ws();ks();var Ef=class Ef{assignAnimation(n,t,o,r,i){return this.__resetAnimationAndPose(n),this.__setupAnimationForSameSkeleton(n,t,o,r,i),n}assignAnimationWithVrma(n,t,o){this.__resetAnimationAndPose(n,o);let r=new Set;return h(a=>{if(!(a.animations==null||a.animations.length===0)){ne.addComponentToEntity(ui,n);for(let s of a.animations)for(let l of s.samplers)Ve._readBinaryFromAccessorAndSetItToAccessorExtras(l.inputObject),Ve._readBinaryFromAccessorAndSetItToAccessorExtras(l.outputObject);for(let s of a.animations)for(let l of s.channels){let c=this.__getCorrespondingEntityWithVrma(n,a,l.target.node);if(c){let _=ne.addComponentToEntity(ot,c).getAnimation(),d=a.extras.rnEntities[l.target.node],x=a.extensions.VRMC_vrm_animation.humanoidBoneNameMap.get(l.target.node);d.tryToSetUniqueName(x,!0);let v;n.tryToGetVrm()._version==="0.x"?v=new _f(d):n.tryToGetVrm()._version==="1.0"&&(v=new _l(d)),_._setRetarget(v,o).forEach(g=>{r.add(g)})}}}},"setRetarget")(t),Array.from(r)}constructor(){}__resetAnimationAndPose(n,t){function o(r,i){let a=r.tryToGetAnimation();a!=null&&(i!=null?a.resetAnimationTrackByPostfix(i):a.resetAnimationTracks()),r.getTransform()._restoreTransformFromRest();for(let s of r.children)o(s.entity,i)}h(o,"resetAnimationAndPose"),o(n,t)}static getInstance(){return this.__instance||(this.__instance=new Ef),this.__instance}__getCorrespondingEntity(n,t,o,r,i,a){if(a){let s=n.getTagValue("rnEntitiesByNames"),l=t.nodes[r];return s.get(l.name)}else{if(A.exist(o.extensions.VRM)){let s=o.extensions.VRM.humanoid.humanBones,l,c=new Map,u=new Map;for(let p of s)c.set(p.node,p.bone),u.set(p.name,p.bone);i!=null&&(l=u.get(i),l==null&&(l=c.get(r)));let d=n.getTagValue("humanoid_map_name_nodeId").get(l);if(d!=null)return n.getTagValue("rnEntities")[d];N.info(`humanoidBoneName: ${l}, nodeIndex: ${r}, nodeName: ${i}`);return}else if(A.exist(o.extensions.VRMC_vrm)){let s=o.extensions.VRMC_vrm.humanoid.humanBones,l,c=new Map;for(let d in s){let p=s[d];c.set(p.node,d)}i!=null&&(l=c.get(r));let _=n.getTagValue("humanoid_map_name_nodeId").get(l);if(_!=null)return n.getTagValue("rnEntities")[_];N.info(`humanoidBoneName: ${l}, nodeIndex: ${r}, nodeName: ${i}`);return}return}}__getCorrespondingEntityWithVrma(n,t,o){let i=t.extensions.VRMC_vrm_animation.humanoidBoneNameMap.get(o),s=n.getTagValue("humanoid_map_name_nodeId").get(i);if(s!=null)return n.getTagValue("rnEntities")[s];N.info(`humanoidBoneName: ${i}, nodeIndex: ${o}`)}__isHips(n,t,o){let r=new Map;if(A.exist(t.extensions.VRM)){let s=t.extensions.VRM.humanoid.humanBones;for(let l of s)r.set(l.node,l.bone)}else if(A.exist(t.extensions.VRMC_vrm)){let s=t.extensions.VRMC_vrm.humanoid.humanBones;for(let l in s){let c=s[l];r.set(c.node,l)}}let i=n.getTagValue("humanoid_map_name_nodeId");return r.get(o)==="hips"}__setupAnimationForSameSkeleton(n,t,o,r,i){var a,s,l,c;if(!(t.animations==null||t.animations.length===0)){ne.addComponentToEntity(ui,n);for(let u of t.animations)for(let _ of u.samplers)Ve._readBinaryFromAccessorAndSetItToAccessorExtras(_.inputObject),Ve._readBinaryFromAccessorAndSetItToAccessorExtras(_.outputObject);for(let u of t.animations)for(let _ of u.channels){let d=(s=(a=_.samplerObject)==null?void 0:a.inputObject)==null?void 0:s.extras.typedDataArray,p=(c=(l=_.samplerObject)==null?void 0:l.outputObject)==null?void 0:c.extras.typedDataArray,x=_.samplerObject.interpolation!=null?_.samplerObject.interpolation:"LINEAR",v=t.nodes[_.target.node],y=this.__getCorrespondingEntity(n,t,o,_.target.node,v.name,r);if(y){let E=ne.addComponentToEntity(ot,y).getAnimation();if(i==="none"){let w="translate";if(_.target.path==="translation"?w="translate":_.target.path==="rotation"?w="quaternion":w=_.target.path,w==="quaternion"){let T=new Map,R=A.exist(u.name)?u.name:"Untitled";T.set(R,{input:d,output:p,outputComponentN:4,interpolationMethod:Gn.fromString(x)});let P=new Ir(T,R);E.setAnimation(w,P)}else if(w==="translate"&&this.__isHips(n,o,_.target.node)){let T=new Map,R=A.exist(u.name)?u.name:"Untitled";T.set(R,{input:d,output:p,outputComponentN:3,interpolationMethod:Gn.fromString(x)});let P=new $n(T,R);E.setAnimation(w,P)}}else{let w=t.extras.rnEntities[_.target.node],T;if(i==="global")T=new _l(w);else if(i==="absolute")T=new df(w);else throw new Error("unknown retarget mode");E._setRetarget(T)}}}}}};h(Ef,"AnimationAssigner"),f(Ef,"__instance");var Cx=Ef;co();_o();_r();se();Nn();Xt();Fl();ge();Vn();Vn();ir();me();var Cf=class Cf{constructor(){}async importPointCloud(n,t){let o=n.substring(0,n.lastIndexOf("/"))+"/",r=ie.createDefaultGltfOptions();if(t&&t.files){for(let s in t.files)if(ie.getExtension(s)==="drc"){let c=await this.__decodeDraco(t.files[s],r,o,t);return new je(c)}}let i=await ie.fetchArrayBuffer(n);if(i.isErr())return new Ue({message:"fetchArrayBuffer failed",error:i});let a=await this.__decodeDraco(i.get(),r,o,t);return new je(a)}importArrayBuffer(n,t,o){let r=n.substring(0,n.lastIndexOf("/"))+"/",i=ie.createDefaultGltfOptions();return this.__decodeDraco(t,i,r,o).catch(a=>{N.error("__loadFromArrayBuffer error: "+a)})}async __loadFromArrayBuffer(n,t,o,r){let i=new DataView(n,0,20),a=!0,s=i.getUint32(0,a),l;if(s!==1179937895){let c=ie.arrayBufferToString(n),u=JSON.parse(c);l=await this._loadAsTextJson(u,r,t,o).catch(_=>{N.error("this.__loadAsTextJson error: "+_)})}else l=await this._loadAsBinaryJson(i,a,n,r,t,o).catch(c=>{N.error("this.__loadAsBinaryJson error: "+c)});return l}_getOptions(n,t,o){if(t.asset&&t.asset.extras&&t.asset.extras.rnLoaderOptions)for(let r in t.asset.extras.rnLoaderOptions)n[r]=t.asset.extras.rnLoaderOptions[r];for(let r in o)n[r]=o[r];return o&&o.loaderExtensionName&&typeof o.loaderExtensionName=="string"&&(Rn[o.loaderExtensionName]!=null?n.loaderExtension=Rn[o.loaderExtensionName].getInstance():(N.error(`${o.loaderExtensionName} not found!`),n.loaderExtension=void 0)),n}async _loadAsBinaryJson(n,t,o,r,i,a){let s=n.getUint32(12,t);if(n.getUint32(16,t)!==1313821514)throw new Error("invalid chunkType of chunk0 in this binary glTF file.");let c=new Uint8Array(o,20,s),u=ie.uint8ArrayToString(c),_=JSON.parse(u);r=this._getOptions(i,_,r);let d=new Uint8Array(o,20+s+8);_.asset.extras===void 0&&(_.asset.extras={fileType:"glTF",version:"2"}),this._mergeExtendedJson(_,r.extendedJson),_.asset.extras.rnLoaderOptions=r;try{await this._loadInner(d,a,_,r)}catch(p){N.error("this._loadInner error in _loadAsBinaryJson: "+p)}return _}async _loadAsTextJson(n,t,o,r){n.asset.extras===void 0&&(n.asset.extras={fileType:"glTF",version:"2"}),t=this._getOptions(o,n,t),this._mergeExtendedJson(n,t.extendedJson),n.asset.extras.rnLoaderOptions=t;try{await this._loadInner(void 0,r,n,t)}catch(i){N.error("this._loadInner error in _loadAsTextJson: "+i)}return n}_loadInner(n,t,o,r){let i=[],a={shaders:[],buffers:[],images:[]};return i.push(this._loadResources(n,t,o,r,a)),i.push(new Promise((s,l)=>{this._loadJsonContent(o,r),s()})),Promise.all(i)}_loadJsonContent(n,t){this._loadDependenciesOfScenes(n),this._loadDependenciesOfNodes(n),this._loadDependenciesOfMeshes(n),this._loadDependenciesOfMaterials(n),this._loadDependenciesOfTextures(n),this._loadDependenciesOfJoints(n),this._loadDependenciesOfAnimations(n),this._loadDependenciesOfAccessors(n),this._loadDependenciesOfBufferViews(n),n.asset.extras===void 0&&(n.asset.extras={})}_loadDependenciesOfScenes(n){for(let t of n.scenes)for(let o in t.nodes)t.nodesObjects[o]=n.nodes[t.nodes[o]]}_loadDependenciesOfNodes(n){for(let t of n.nodes){if(t.children){A.not.exist(t.childrenObjects)&&(t.childrenObjects=[]);for(let o in t.children)t.childrenObjects[o]=n.nodes[t.children[o]]}t.mesh!==void 0&&n.meshes!==void 0&&(t.meshObject=n.meshes[t.mesh]),t.skin!==void 0&&n.skins!==void 0&&(t.skinObject=n.skins[t.skin],t.meshObject.extras===void 0&&(t.meshObject.extras={}),t.meshObject.extras._skin=t.skin),t.camera!==void 0&&n.cameras!==void 0&&(t.cameraObject=n.cameras[t.camera]),t.extensions!==void 0&&n.extensions!==void 0&&n.extensions.KHR_lights_punctual!==void 0&&(t.extensions.KHR_lights_punctual.lightIndex=t.extensions.KHR_lights_punctual.light,t.extensions.KHR_lights_punctual.light=n.extensions.KHR_lights_punctual.lights[t.extensions.KHR_lights_punctual.lightIndex])}}_loadDependenciesOfMeshes(n){for(let t of n.meshes)for(let o of t.primitives){o.material!==void 0&&(o.materialObject=n.materials[o.material]);for(let r in o.attributes){let i=o.attributes[r],a=n.accessors[i];a.extras={},o.attributesObjects[r]=a}if(o.indices!=null&&(o.indicesObject=n.accessors[o.indices]),o.targets!=null){o.targetsObjects=[];for(let r of o.targets){let i={};for(let a in r){let s=r[a];if(s>=0){let l=n.accessors[s];l.extras={},i[a]=l}}o.targetsObjects.push(i)}}}}_checkRnGltfLoaderOptionsExist(n){return!!(n.asset.extras&&n.asset.extras.rnLoaderOptions)}_loadDependenciesOfMaterials(n){if(n.textures||(n.textures=[]),n.materials)for(let t of n.materials){if(t.pbrMetallicRoughness){let a=t.pbrMetallicRoughness.baseColorTexture;a!==void 0&&(a.texture=n.textures[a.index]);let s=t.pbrMetallicRoughness.metallicRoughnessTexture;s!==void 0&&(s.texture=n.textures[s.index])}let o=t.normalTexture;o!==void 0&&(o.texture=n.textures[o.index]);let r=t.occlusionTexture;r!==void 0&&(r.texture=n.textures[r.index]);let i=t.emissiveTexture;i!==void 0&&(i.texture=n.textures[i.index]),this._checkRnGltfLoaderOptionsExist(n)&&n.asset.extras.rnLoaderOptions.loaderExtension&&n.asset.extras.rnLoaderOptions.loaderExtension.setTextures&&n.asset.extras.rnLoaderOptions.loaderExtension.setTextures(n,t)}}_loadDependenciesOfTextures(n){if(n.textures)for(let t of n.textures)os(o=>{t.samplerObject=n.samplers[o]},t.sampler),t.source!==void 0&&(t.image=n.images[t.source])}_loadDependenciesOfJoints(n){if(n.skins){for(let t of n.skins)if(A.exist(t.skeleton)){t.skeletonObject=n.nodes[t.skeleton],os(o=>t.inverseBindMatricesObject=n.accessors[o],t.inverseBindMatrices),L_(()=>t.skeletonObject=n.nodes[t.joints[0]],t.skeleton),t.jointsObjects=[];for(let o of t.joints)t.jointsObjects.push(n.nodes[o])}}}_loadDependenciesOfAnimations(n){if(n.animations)for(let t of n.animations){for(let o of t.channels)o.samplerObject=t.samplers[o.sampler],o.target.nodeObject=n.nodes[o.target.node];for(let o of t.channels)if(A.exist(o.samplerObject)&&(o.samplerObject.inputObject=n.accessors[o.samplerObject.input],o.samplerObject.outputObject=n.accessors[o.samplerObject.output],o.samplerObject.outputObject.extras===void 0&&(o.samplerObject.outputObject.extras={}),o.target.path==="rotation"&&(o.samplerObject.outputObject.extras.quaternionIfVec4=!0),o.target.path==="weights")){let r=o.samplerObject.outputObject.count/o.samplerObject.inputObject.count;o.samplerObject.outputObject.extras.weightsArrayLength=r}}}_loadDependenciesOfAccessors(n){for(let t of n.accessors)if(t.bufferView==null&&(t.bufferView=0),t.bufferViewObject=n.bufferViews[t.bufferView],t.sparse!=null){let o=t.sparse;o.indices.bufferViewObject=n.bufferViews[o.indices.bufferView],o.values.bufferViewObject=n.bufferViews[o.values.bufferView]}}_loadDependenciesOfBufferViews(n){for(let t of n.bufferViews)t.buffer!==void 0&&(t.bufferObject=n.buffers[t.buffer])}_mergeExtendedJson(n,t){let o=null;if(t instanceof ArrayBuffer){let r=ie.arrayBufferToString(t);o=JSON.parse(r)}else typeof t=="string"?o=JSON.parse(t):typeof t=="object"&&(o=t);Object.assign(n,o)}_loadResources(n,t,o,r,i){let a=[],s;for(let l in o.buffers){let c=o.buffers[l],u,_;c.uri&&(u=c.uri.split("/"),_=u[u.length-1]),typeof c.uri=="undefined"?s=new Kt((d,p)=>{i.buffers[l]=n,c.buffer=n,d(n)}):c.uri.match(/^data:application\/(.*);base64,/)?s=new Kt((d,p)=>{let x=ie.dataUriToArrayBuffer(c.uri);i.buffers[l]=new Uint8Array(x),c.buffer=new Uint8Array(x),d(x)}):r.files&&r.files[_]?s=new Kt((d,p)=>{let x=r.files[_];i.buffers[l]=new Uint8Array(x),c.buffer=new Uint8Array(x),d(x)}):s=new Kt(ie.loadResourceAsync(t+c.uri,!0,(d,p)=>{i.buffers[l]=new Uint8Array(p),c.buffer=new Uint8Array(p),d(p)},(d,p)=>{})),c.bufferPromise=s,a.push(s)}for(let l in o.images){let c=l,u=o.images[c],_;if(typeof u.uri=="undefined"){let p=n;n==null&&(p=o.bufferViews[u.bufferView].bufferObject.buffer);let x=ie.createUint8ArrayFromBufferViewInfo(o,u.bufferView,n);_=ie.createBlobImageUriFromUint8Array(x,u.mimeType)}else{let p=u.uri,x=p.split("/"),v=x[x.length-1];if(r.files&&r.files[v]){let y=r.files[v];_=ie.createBlobImageUriFromUint8Array(new Uint8Array(y),u.mimeType)}else p.match(/^data:/)?_=p:_=t+p}let d=ie.createImageFromUri(_,u.mimeType).then(p=>{p.crossOrigin="Anonymous",i.images[c]=p,u.image=p});a.push(d)}return Promise.all(a).catch(l=>{N.error("Promise.all error: "+l)})}static getInstance(){return this.__instance||(this.__instance=new Cf),this.__instance}__decodeDraco(n,t,o,r){return this.__decodeBuffer(n).then(i=>{let a=JSON.stringify(i),s=JSON.parse(a);return this._loadAsTextJson(s,r,t,o).catch(l=>{N.error("this.__loadAsTextJson error: "+l)})})}__decodeBuffer(n){let t=new DracoDecoderModule,o=new t.Decoder,r=this.__getGeometryFromDracoBuffer(t,o,n);if(r==null)throw new Error("invalid dracoGeometry.");if(r.geometryType!==t.POINT_CLOUD)throw new Error("invalid geometryType of drc file.");if(o.GetAttributeId(r,t.POSITION)===-1)throw t.destroy(o),t.destroy(r),new Error("Draco: No position attribute found.");let a=["POSITION","NORMAL","COLOR","TEX_COORD","GENERIC"],s=r.num_points(),l=[],c=[],u=0;for(let d=0;d<a.length;d++){let p=o.GetAttributeId(r,t[a[d]]);if(p===-1){a.splice(d,1),d--;continue}let x=o.GetAttribute(r,p),v=new t.DracoFloat32Array;o.GetAttributeFloatForAllPoints(r,x,v),l[d]=v;let y=x.num_components();c[d]=y,a[d]==="COLOR"?u+=s*4:u+=s*y}let _=new Float32Array(u);for(let d=0,p=0;d<a.length;d++){if(a[d]==="COLOR"&&c[d]===3)for(let x=0;x<s;p+=4,x+=3)_[p]=l[d].GetValue(x),_[p+1]=l[d].GetValue(x+1),_[p+2]=l[d].GetValue(x+2),_[p+3]=1;else if(a[d]==="TEX_COORD")for(let x=0;x<s;p+=2,x++)_[p]=l[d].GetValue(2*x),_[p+1]=1-l[d].GetValue(2*x+1);else for(let x=0;x<s*c[d];p++,x++)_[p]=l[d].GetValue(x);t.destroy(l[d])}return t.destroy(o),t.destroy(r),this.__decodedBufferToJSON(_,s,a,c)}async __decodedBufferToJSON(n,t,o,r){let i={asset:{version:"2.0"},extensionsUsed:["KHR_materials_unlit"],extensionsRequired:["KHR_materials_unlit"],nodes:[{name:"Node",mesh:0}],scenes:[{nodes:[0]}],materials:[{name:"point-cloud_material",pbrMetallicRoughness:{baseColorFactor:[1,1,1,1]},extensions:{KHR_materials_unlit:{}}}]};return await this.__setBuffersToJSON(n,i),this.__setAccessorsAndBufferViewsToJSON(t,o,r,i),this.__setMeshesToJSON(o,i),new Promise((a,s)=>{a(i)})}__setBuffersToJSON(n,t){return this.__convertBufferToURI(n.buffer).then(o=>{t.buffers=[{name:"input",byteLength:n.byteLength,uri:o}]}).catch(o=>{N.error("this.__convertBufferToURI error: "+o)})}__convertBufferToURI(n){return new Promise((t,o)=>{let r=new Blob([n],{type:"application/octet-stream"}),i=new FileReader;i.onload=()=>{t(i.result)},i.onerror=()=>{o(i.error)},i.readAsDataURL(r)})}__setAccessorsAndBufferViewsToJSON(n,t,o,r){let i=[],a=[],s=0;for(let l=0,c=0;l<t.length;c++){let u=o[l],_;u===1?_="SCALAR":_="VEC"+u;let d=0,p=t[l];for(;l<t.length&&(i.push({name:"point-cloud_"+p+"_"+l,componentType:5126,count:n,type:_,bufferView:c,byteOffset:d}),t[l]==="COLOR"?d+=n*4*4:d+=n*u*4,l++,p==t[l]););a[c]={name:"bufferView_"+p,buffer:0,byteLength:d,byteOffset:s,byteStride:u*4,target:34962},s+=d}r.accessors=i,r.bufferViews=a}__setMeshesToJSON(n,t){let o={};for(let i=0;i<n.length;i++)n[i]==="TEX_COORD"?o.TEXCOORD_0=i:n[i]==="GENERIC"?o.TANGENT=i:o[n[i]]=i;let r={name:"Node-Mesh",primitives:[{mode:0,material:0,attributes:o}]};t.meshes=[r]}async importPointCloudToPrimitive(n){let t=await ie.fetchArrayBuffer(n);return this.__decodeDracoToPrimitive(t.unwrapForce())}__decodeDracoToPrimitive(n){let t=new DracoDecoderModule,o=new t.Decoder,r=this.__getGeometryFromDracoBuffer(t,o,n);if(r==null)throw new Error("invalid dracoGeometry.");if(r.geometryType!==t.POINT_CLOUD)throw new Error("invalid geometryType of drc file.");let i=[],a=[],s=[];this.__getPositions(t,o,r,i,a,s),this.__getColors(t,o,r,i,a,s),this.__getNormals(t,o,r,i,a,s),this.__getTextureCoords(t,o,r,i,a,s);let l=$e.createPrimitive({attributeSemantics:a,attributes:s,material:Oe.createClassicUberMaterial({isSkinning:!1,isLighting:!0}),primitiveMode:Re.Points});return t.destroy(o),t.destroy(r),l}__getGeometryFromDracoBuffer(n,t,o){let r=new n.DecoderBuffer;r.Init(new Int8Array(o),o.byteLength);let i=t.GetEncodedGeometryType(r),a,s;if(i===n.TRIANGULAR_MESH?(a=new n.Mesh,s=t.DecodeBufferToMesh(r,a)):i===n.POINT_CLOUD?(a=new n.PointCloud,s=t.DecodeBufferToPointCloud(r,a)):N.error("Unknown geometry type."),a.geometryType=i,!s.ok()||a.ptr==0){let l="Decoding failed: ";l+=s.error_msg(),N.error(l),n.destroy(t),n.destroy(a);return}return n.destroy(r),a}__getPositions(n,t,o,r,i,a){let s=t.GetAttributeId(o,n.POSITION);if(s===-1)throw n.destroy(t),n.destroy(o),new Error("Draco: No position attribute found.");let l=t.GetAttribute(o,s),c=new n.DracoFloat32Array;t.GetAttributeFloatForAllPoints(o,l,c);let _=o.num_points()*3,d=new Float32Array(_);for(let p=0;p<_;p+=1)d[p]=c.GetValue(p);return r.push(b.Vec3),i.push(ee.Position.XYZ),a.push(d),n.destroy(c),d}__getColors(n,t,o,r,i,a){let s=t.GetAttributeId(o,n.COLOR);if(s===-1)return null;{let l=t.GetAttribute(o,s),c=new n.DracoFloat32Array;t.GetAttributeFloatForAllPoints(o,l,c);let u=o.num_points(),_=l.num_components(),d=u*4,p=new Float32Array(d);for(let x=0;x<d;x+=_)p[x]=c.GetValue(x),p[x+1]=c.GetValue(x+1),p[x+2]=c.GetValue(x+2),_==4?p[x+3]=c.GetValue(x+3):p[x+3]=1;return r.push(b.Vec3),i.push(ee.Color0.XYZ),a.push(p),n.destroy(c),p}}__getNormals(n,t,o,r,i,a){let s=t.GetAttributeId(o,n.NORMAL);if(s===-1)return null;{let l=t.GetAttribute(o,s),c=new n.DracoFloat32Array;t.GetAttributeFloatForAllPoints(o,l,c);let _=o.num_points()*3,d=new Float32Array(_);for(let p=0;p<_;p+=1)d[p]=c.GetValue(p);return r.push(b.Vec3),i.push(ee.Normal.XYZ),a.push(d),n.destroy(c),d}}__getTextureCoords(n,t,o,r,i,a){let s=t.GetAttributeId(o,n.TEX_COORD);if(s===-1)return null;{let l=t.GetAttribute(o,s),c=new n.DracoFloat32Array;t.GetAttributeFloatForAllPoints(o,l,c);let _=o.num_points()*2,d=new Float32Array(_);for(let p=0;p<_;p+=1)d[p]=c.GetValue(p);return r.push(b.Vec2),i.push(ee.Texcoord0.XY),a.push(d),n.destroy(c),d}}};h(Cf,"DrcPointCloudImporter"),f(Cf,"__instance");var wf=Cf;co();Ou();function wx(m){for(let n in m){let t=ie.getExtension(n);if(t==="gltf")return Yo.Gltf;if(t==="glb")return Yo.GltfBinary;if(t==="vrm")return Yo.VRM;if(t==="drc")return Yo.Draco}return Yo.Unknown}h(wx,"detectFormatByArrayBuffers");function P5(m){let n=m.split("."),t=n[n.length-1];return t==="efk"?"Effekseer":t==="drc"?"Draco":t==="vrm"?"VRM":t==="gltf"?"glTF":"Unknown"}h(P5,"detectFormatByUri");Na();Na();Ma();Ci();kr();co();Ou();Na();Ma();ge();kr();Ni();at();ye();Ot();Bo();Eu();br();ge();tt();var _e=class _e{constructor(){f(this,"__spring")}getParentRotation(n){return n.parent!=null?n.parent.getRotationTo(_e.__tmp_getParentRotation_quat_0):_e.__tmp_getParentRotation_quat_1_identity}update(){let n=this.__spring;A.exist(n)&&this.updateInner(n.bones,n)}updateInner(n,t){let o=t.center,r=t.colliderGroups;for(let i of n)i.setup(o);for(let i of n)this.process(r,i,o)}process(n,t,o){t._calcWorldSpaceBoneLength();let r=t.dragForce,i=t.stiffnessForce*Ho.intervalProcessBegin*F.physicsTimeIntervalScale,a=L.multiplyTo(S.subtractTo(t.currentTail,t.prevTail,_e.__tmp_process_vec3_0),1-r,_e.__tmp_process_vec3_1),s=S.addTo(t.currentTail,a,_e.__tmp_process_vec3_2),l=o!=null?o.getWorldPositionOfTo(s,_e.__tmp_process_vec3_3):s,c=H.multiplyTo(this.getParentRotation(t.node.getSceneGraph()),t.node.localRotationRestInner,_e.__tmp_process_quat_0),u=S.multiplyTo(c.transformVector3To(t.boneAxis,_e.__tmp_process_vec3_4),i,_e.__tmp_process_vec3_5),_=S.multiplyTo(t.gravityDir,t.gravityPower*Ho.intervalProcessBegin*F.physicsTimeIntervalScale,_e.__tmp_process_vec3_6),d=S.addTo(S.addTo(l,u,_e.__tmp_process_vec3_7),_,_e.__tmp_process_vec3_8);d=this.normalizeBoneLength(d,t),d=this.collision(n,d,t.hitRadius,t),t.prevTail=t.currentTail.clone(),t.currentTail=o!=null?o.getLocalPositionOfTo(d,_e.__tmp_process_vec3_9).clone():d.clone();let p=this.applyRotation(d,t);t.node.localRotation=p,t.node.getSceneGraph().setWorldMatrixDirty()}normalizeBoneLength(n,t){let o=S.normalizeTo(S.subtractTo(n,t.node.getSceneGraph().getPositionTo(_e.__tmp_normalizeBoneLength_vec3_4),_e.__tmp_normalizeBoneLength_vec3_0),_e.__tmp_normalizeBoneLength_vec3_1);return S.addTo(t.node.getSceneGraph().getPositionTo(_e.__tmp_normalizeBoneLength_vec3_5),S.multiplyTo(o,t.boneLength,_e.__tmp_normalizeBoneLength_vec3_2),_e.__tmp_normalizeBoneLength_vec3_3)}applyRotation(n,t){let o=S.subtractTo(n,t.node.getSceneGraph().getPositionTo(_e.__tmp_applyRotation_vec3_3),_e.__tmp_applyRotation_vec3_0),r=H.invertTo(H.multiplyTo(t.node.parent.getRotationTo(_e.__tmp_applyRotation_quat_4),t.node.localRotationRestInner,_e.__tmp_applyRotation_quat_0),_e.__tmp_applyRotation_quat_1).transformVector3To(o,_e.__tmp_applyRotation_vec3_1),i=H.fromToRotationTo(t.boneAxis,S.normalizeTo(r,_e.__tmp_applyRotation_vec3_2),_e.__tmp_applyRotation_quat_2);return H.multiplyTo(t.node.localRotationRestInner,i,_e.__tmp_applyRotation_quat_3)}collision(n,t,o,r){for(let i of n){for(let a of i.sphereColliders){let{direction:s,distance:l}=a.collision(t,o);l<0&&(t=S.addTo(t,S.multiplyTo(s,-l,_e.__tmp_collision_vec3_0),_e.__tmp_collision_vec3_1),t=this.normalizeBoneLength(t,r))}for(let a of i.capsuleColliders){let{direction:s,distance:l}=a.collision(t,o);l<0&&(t=S.addTo(t,S.multiplyTo(s,-l,_e.__tmp_collision_vec3_2),_e.__tmp_collision_vec3_3),t=this.normalizeBoneLength(t,r))}}return t}setSpring(n){this.__spring=n}};h(_e,"VRMSpringBonePhysicsStrategy"),f(_e,"__tmp_process_vec3_0",L.zero()),f(_e,"__tmp_process_vec3_1",L.zero()),f(_e,"__tmp_process_vec3_2",L.zero()),f(_e,"__tmp_process_vec3_3",L.zero()),f(_e,"__tmp_process_vec3_4",L.zero()),f(_e,"__tmp_process_vec3_5",L.zero()),f(_e,"__tmp_process_vec3_6",L.zero()),f(_e,"__tmp_process_vec3_7",L.zero()),f(_e,"__tmp_process_vec3_8",L.zero()),f(_e,"__tmp_process_vec3_9",L.zero()),f(_e,"__tmp_process_quat_0",Ye.identity()),f(_e,"__tmp_normalizeBoneLength_vec3_0",L.zero()),f(_e,"__tmp_normalizeBoneLength_vec3_1",L.zero()),f(_e,"__tmp_normalizeBoneLength_vec3_2",L.zero()),f(_e,"__tmp_normalizeBoneLength_vec3_3",L.zero()),f(_e,"__tmp_normalizeBoneLength_vec3_4",L.zero()),f(_e,"__tmp_normalizeBoneLength_vec3_5",L.zero()),f(_e,"__tmp_applyRotation_vec3_0",L.zero()),f(_e,"__tmp_applyRotation_vec3_1",L.zero()),f(_e,"__tmp_applyRotation_vec3_2",L.zero()),f(_e,"__tmp_applyRotation_vec3_3",L.zero()),f(_e,"__tmp_applyRotation_quat_0",Ye.identity()),f(_e,"__tmp_applyRotation_quat_1",Ye.identity()),f(_e,"__tmp_applyRotation_quat_2",Ye.identity()),f(_e,"__tmp_applyRotation_quat_3",Ye.identity()),f(_e,"__tmp_applyRotation_quat_4",Ye.identity()),f(_e,"__tmp_getParentRotation_quat_0",Ye.identity()),f(_e,"__tmp_getParentRotation_quat_1_identity",Ye.identity()),f(_e,"__tmp_collision_vec3_0",L.zero()),f(_e,"__tmp_collision_vec3_1",L.zero()),f(_e,"__tmp_collision_vec3_2",L.zero()),f(_e,"__tmp_collision_vec3_3",L.zero());var Ba=_e;ml();Ot();ye();var _i=class _i{constructor(){f(this,"position",S.zero());f(this,"radius",0);f(this,"baseSceneGraph")}collision(n,t){let o=this.baseSceneGraph.getWorldPositionOfTo(this.position,_i.__tmp_vec3_0),r=S.subtractTo(n,o,_i.__tmp_vec3_1),i=S.normalizeTo(r,_i.__tmp_vec3_2),a=this.radius+t,s=r.length()-a;return{direction:i,distance:s}}};h(_i,"SphereCollider"),f(_i,"__tmp_vec3_0",L.zero()),f(_i,"__tmp_vec3_1",L.zero()),f(_i,"__tmp_vec3_2",L.zero());var Fa=_i;ye();var Rx=class Rx{constructor(){f(this,"sphereColliders",[]);f(this,"capsuleColliders",[])}};h(Rx,"VRMColliderGroup");var La=Rx;zn();var Nx=class Nx extends nt{constructor(t){super();f(this,"rootBone");f(this,"bones",[]);f(this,"colliderGroups",[]);f(this,"center");this.rootBone=t}};h(Nx,"VRMSpring");var Va=Nx;ir();Fm();Pn();zn();Or();ye();var di=class di extends nt{constructor(t){super();f(this,"stiffnessForce",1);f(this,"gravityPower",0);f(this,"gravityDir",S.fromCopyArray([0,-1,0]));f(this,"dragForce",.4);f(this,"hitRadius",.02);f(this,"node");f(this,"currentTail",S.zero());f(this,"prevTail",S.zero());f(this,"boneAxis",S.zero());f(this,"boneLength",0);f(this,"initialLocalChildPosition",S.zero());f(this,"initialized",!1);this.node=t}setup(t){if(!this.initialized){this.node.getTransform()._backupTransformAsRest();let o=this.node.getSceneGraph().children;o.length>0?this.initialLocalChildPosition=o[0].entity.getTransform().localPosition:this.initialLocalChildPosition=S.multiply(S.normalize(this.node.getTransform().localPosition),.07);let r=this.node.matrixInner.multiplyVector3(this.initialLocalChildPosition);this.currentTail=t!=null?t.getLocalPositionOf(r):r,this.prevTail=this.currentTail.clone(),this.boneAxis=S.normalize(this.initialLocalChildPosition),this.initialized=!0}}_getMatrixCenterToWorld(t){return t!=null?t.matrixInner:Se.identity()}_getMatrixWorldToCenter(t){return t!=null?Se.invert(t.matrixInner):Se.identity()}_calcWorldSpaceBoneLength(){let t=this.node.getSceneGraph().matrixInner.getTranslateTo(di.__tmp_vec3_0),o=di.__tmp_vec3_2_zero,r=this.node.getSceneGraph().children;r.length>0?o=r[0].matrixInner.getTranslateTo(di.__tmp_vec3_1):o=S.multiplyMatrix4(this.initialLocalChildPosition,this.node.getSceneGraph().matrixInner),this.boneLength=S.subtract(t,o).length()}};h(di,"VRMSpringBone"),f(di,"__tmp_vec3_0",L.zero()),f(di,"__tmp_vec3_1",L.zero()),f(di,"__tmp_vec3_2_zero",S.zero());var Oi=di;un();var qr=class qr{constructor(){}static async importFromUri(n,t){var _,d;t=this._getOptions(t);let o=await so.importFromUri(n,t);if(o.isErr())return new Ue({message:"Failed to import VRM file.",error:o});Zr(o);let r=o.get(),i=qr._createTextures(r),a=qr._createSamplers(r),s=(d=(_=r.asset.extras)==null?void 0:_.rnLoaderOptions)==null?void 0:d.defaultMaterialHelperArgumentArray;A.exist(s)&&(s[0].textures=i,s[0].samplers=a),qr._initializeMaterialProperties(r,i.length);let l,c=Ve.convertToRhodoniteObject(r);if(qr._existOutlineMaterial(r.extensions.VRM)){A.exist(s)&&(s[0].isOutline=!0);let p=Ve.convertToRhodoniteObject(r);l=[c,p]}else l=[c];return qr._readSpringBone(r),qr._readVRMHumanoidInfo(r,c),new je(l)}static async importJsonOfVRM(n,t){t=this._getOptions(t);let o=await so.importFromUri(n,t);if(o.isErr())return new Ue({message:"Failed to import VRM file.",error:o});Zr(o);let r=o.get();return qr._readVRMHumanoidInfo(r),new je(r)}static async __importVRM0x(n,t){var c,u,_,d,p,x;let o=(u=(c=n.asset.extras)==null?void 0:c.rnLoaderOptions)==null?void 0:u.defaultMaterialHelperArgumentArray,r=this._createTextures(n),i=this._createSamplers(n);A.exist(o)&&(o[0].textures=(_=o[0].textures)!=null?_:r,o[0].samplers=(d=o[0].samplers)!=null?d:i,o[0].isLighting=(p=o[0].isLighting)!=null?p:!0),this._initializeMaterialProperties(n,r.length);let a;if(this._existOutlineMaterial(n.extensions.VRM)){t[1]=(x=t[1])!=null?x:new Dt;let v=t[1];v.toClearColorBuffer=!1,v.toClearDepthBuffer=!1,n.extensions.VRM.rnExtension={renderPassOutline:v},a=Ve.convertToRhodoniteObject(n),v.addEntities([a])}else a=Ve.convertToRhodoniteObject(n);let l=t[0];l.tryToSetUniqueName("VRM Main RenderPass",!0),l.addEntities([a]),this._readSpringBone(n),this._readVRMHumanoidInfo(n,a),this._readBlendShapeGroup(n,a)}static _readBlendShapeGroup(n,t){let o=[],r=n.extensions.VRM.blendShapeMaster.blendShapeGroups;for(let a of r){let s={name:a.presetName,isBinary:a.isBinary,binds:a.binds.map(l=>{for(let c=0;c<n.nodes.length;c++)if(n.nodes[c].mesh===l.mesh)return{entityIdx:n.extras.rnEntities[c].entityUID,blendShapeIdx:l.index,weight:l.weight/100};throw new Error("Not Found node in blendShapeGroup Process")})};o.push(s)}let i=ne.addComponentToEntity(mi,t);i.getVrm().setVrmExpressions(o),i.getVrm()._version="0.x"}static _readVRMHumanoidInfo(n,t){let o=n.extensions.VRM.humanoid.humanBones,r=new Map;for(let i of o){r.set(i.bone,i.node);let a=n.nodes[i.node];i.name=a.name}t!=null&&t.tryToSetTag({tag:"humanoid_map_name_nodeId",value:r})}static _readSpringBone(n){let t=[];for(let r in n.extensions.VRM.secondaryAnimation.colliderGroups){let i=n.extensions.VRM.secondaryAnimation.colliderGroups[r],a=new La;t.push(a);let s=[],l=n.asset.extras.rnEntities[i.node].getSceneGraph();for(let c of i.colliders){let u=new Fa;u.baseSceneGraph=l,u.position=S.fromCopyArray([c.offset.x,c.offset.y,c.offset.z]),u.radius=c.radius,s.push(u)}a.sphereColliders=s}let o=[];for(let r of n.extensions.VRM.secondaryAnimation.boneGroups){if(r.bones.length===0)continue;let i=r.bones[0],a=n.asset.extras.rnEntities[i],s=new Va(a.getSceneGraph());s.tryToSetUniqueName(r.comment,!0),s.colliderGroups=r.colliderGroups.map(c=>t[c]);let l=[];for(let c in r.bones){let u=r.bones[c],_=n.asset.extras.rnEntities[u];this.__addSpringBoneRecursively(s,_,r,l)}r.center!=null&&r.center!==-1&&(s.center=n.asset.extras.rnEntities[r.center].getSceneGraph()),o.push(s)}for(let r of o)this.__addPhysicsComponent(r,r.rootBone)}static __addSpringBoneRecursively(n,t,o,r){let a=t.getSceneGraph().children;if(!r.includes(t)){let s=new Oi(t);s.dragForce=o.dragForce,s.stiffnessForce=o.stiffiness,s.gravityPower=o.gravityPower,s.gravityDir=S.fromCopyArray([o.gravityDir.x,o.gravityDir.y,o.gravityDir.z]),s.hitRadius=o.hitRadius,n.bones.push(s),r.push(t)}for(let s of a)this.__addSpringBoneRecursively(n,s.entity,o,r)}static __addPhysicsComponent(n,t){let o=t.entity,i=ne.addComponentToEntity(Uo,o).getPhysics(),a=new Ba;a.setSpring(n),i.setStrategy(a)}static _createTextures(n){n.textures||(n.textures=[]);let t=n.textures,o=[];for(let a=0;a<t.length;a++){let s=Ve._createTexture(t[a].image,n);o[a]=s}let r=new Jt;r.generate1x1TextureFrom(),o.push(r);let i=new Jt;return i.generate1x1TextureFrom("rgba(0, 0, 0, 1)"),o.push(i),o}static _createSamplers(n){n.textures||(n.textures=[]);let t=n.textures,o=[];for(let i=0;i<t.length;i++){let a=Ve._createSampler(t[i].samplerObject);o[i]=a}let r=new Ge({wrapS:U.ClampToEdge,wrapT:U.ClampToEdge,minFilter:U.Linear,magFilter:U.Linear});return r.create(),o.push(r),o.push(r),o}static _existOutlineMaterial(n){let t=n.materialProperties;if(t!=null){for(let o of t)if(o.floatProperties._OutlineWidthMode!==0)return!0}return!1}static _initializeMaterialProperties(n,t){let o=n.extensions.VRM.materialProperties;for(let r of o)if(r.shader==="VRM/MToon"){this.__initializeMToonMaterialProperties(n,t);break}}static __initializeMToonMaterialProperties(n,t){let o=n.extensions.VRM.materialProperties,r=t-2,i=t-1;for(let a=0;a<o.length;a++){let s=o[a].floatProperties;this.__initializeForUndefinedProperty(s,"_BlendMode",0),this.__initializeForUndefinedProperty(s,"_BumpScale",1),this.__initializeForUndefinedProperty(s,"_CullMode",2),this.__initializeForUndefinedProperty(s,"_Cutoff",.5),this.__initializeForUndefinedProperty(s,"_DebugMode",0),this.__initializeForUndefinedProperty(s,"_DstBlend",0),this.__initializeForUndefinedProperty(s,"_IndirectLightIntensity",.1),this.__initializeForUndefinedProperty(s,"_LightColorAttenuation",0),this.__initializeForUndefinedProperty(s,"_OutlineColorMode",0),this.__initializeForUndefinedProperty(s,"_OutlineCullMode",1),this.__initializeForUndefinedProperty(s,"_OutlineLightingMix",1),this.__initializeForUndefinedProperty(s,"_OutlineScaledMaxDistance",1),this.__initializeForUndefinedProperty(s,"_OutlineWidth",.5),this.__initializeForUndefinedProperty(s,"_OutlineWidthMode",0),this.__initializeForUndefinedProperty(s,"_ReceiveShadowRate",1),this.__initializeForUndefinedProperty(s,"_RimFresnelPower",1),this.__initializeForUndefinedProperty(s,"_RimLift",0),this.__initializeForUndefinedProperty(s,"_RimLightingMix",0),this.__initializeForUndefinedProperty(s,"_ShadeShift",0),this.__initializeForUndefinedProperty(s,"_ShadeToony",.9),this.__initializeForUndefinedProperty(s,"_ShadingGradeRate",1),this.__initializeForUndefinedProperty(s,"_SrcBlend",1),this.__initializeForUndefinedProperty(s,"_ZWrite",1);let l=o[a].vectorProperties;this.__initializeForUndefinedProperty(l,"_Color",[1,1,1,1]),this.__initializeForUndefinedProperty(l,"_EmissionColor",[0,0,0]),this.__initializeForUndefinedProperty(l,"_OutlineColor",[0,0,0,1]),this.__initializeForUndefinedProperty(l,"_ShadeColor",[.97,.81,.86,1]),this.__initializeForUndefinedProperty(l,"_RimColor",[0,0,0]);let c=o[a].textureProperties;this.__initializeForUndefinedProperty(c,"_BumpMap",r),this.__initializeForUndefinedProperty(c,"_EmissionMap",i),this.__initializeForUndefinedProperty(c,"_MainTex",r),this.__initializeForUndefinedProperty(c,"_OutlineWidthTexture",r),this.__initializeForUndefinedProperty(c,"_ReceiveShadowTexture",r),this.__initializeForUndefinedProperty(c,"_RimTexture",i),this.__initializeForUndefinedProperty(c,"_ShadeTexture",r),this.__initializeForUndefinedProperty(c,"_ShadingGradeTexture",r),this.__initializeForUndefinedProperty(c,"_SphereAdd",i)}for(let a=0;a<n.materials.length;a++){let s=n.materials[a];s.extras==null&&(s.extras={}),s.extras.vrm0xMaterialProperty=o[a]}}static __initializeForUndefinedProperty(n,t,o){n[t]==null&&(n[t]=o)}static _getOptions(n){if(n!=null){for(let t in n.files){let o=t.split(".vrm")[0];if(o){let r=n.files[t];n.files[o+".glb"]=r,delete n.files[t]}}n.__isImportVRM0x=!0,n.defaultMaterialHelperArgumentArray==null&&(n.defaultMaterialHelperArgumentArray=[{}]),n.defaultMaterialHelperArgumentArray[0].isMorphing||(n.maxMorphTargetNumber=0)}else n={files:{},loaderExtension:void 0,defaultMaterialHelperName:void 0,defaultMaterialHelperArgumentArray:[{isLighting:!0,isMorphing:!0,isSkinning:!0}],statesOfElements:[{targets:[],states:{enable:[],functions:{}},isTransparent:!0,opacity:1,isTextureImageToLoadPreMultipliedAlpha:!1}],__isImportVRM0x:!0,__importedType:"vrm0x"};return n}};h(qr,"Vrm0xImporter");var Rf=qr;ir();Ma();ge();kr();Ni();at();ml();ye();ir();Na();Pn();ul();ye();var Px=class Px{constructor(){f(this,"position",S.zero());f(this,"radius",0);f(this,"tail",S.zero());f(this,"baseSceneGraph")}collision(n,t){let o=this.baseSceneGraph.getWorldPositionOf(this.position),r=this.baseSceneGraph.getWorldPositionOf(this.tail);r=S.subtract(r,o);let i=r.lengthSquared(),a=S.subtract(n,o),s=r.dot(a);s<=0||(i<=s?a=S.subtract(a,r):(r=S.multiply(r,s/i),a=S.subtract(a,r)));let l=this.radius+t,c=a.length()-l;return a=S.normalize(a),{direction:a,distance:c}}};h(Px,"CapsuleCollider");var Nf=Px;ox();Bo();ye();var Mx=class Mx{constructor(n,t,o,r){f(this,"__srcEntity");f(this,"__dstEntity");f(this,"__rollAxis");f(this,"__weight");this.__srcEntity=n,this.__rollAxis=t,this.__weight=o,this.__dstEntity=r,this.__dstEntity.getTransform()._backupTransformAsRest()}getAxisVector(n){switch(n){case"X":return S.fromCopy3(1,0,0);case"Y":return S.fromCopy3(0,1,0);case"Z":return S.fromCopy3(0,0,1);default:throw new Error("Invalid roll axis")}}update(){let n=H.multiply(H.invert(this.__srcEntity.localRotationRestInner),this.__srcEntity.localRotationInner),t=H.multiply(H.multiply(this.__srcEntity.localRotationRestInner,n),H.invert(this.__srcEntity.localRotationRestInner)),o=H.multiply(H.multiply(H.invert(this.__dstEntity.localRotationRestInner),t),this.__dstEntity.localRotationRestInner),r=this.getAxisVector(this.__rollAxis),i=o.transformVector3(r),a=H.fromToRotation(r,i),s=H.lerp(this.__dstEntity.localRotationRestInner,H.multiply(H.multiply(this.__dstEntity.localRotationRestInner,H.invert(a)),o),this.__weight);this.__dstEntity.localRotation=s}};h(Mx,"VrmRollConstraint");var Om=Mx;Or();ye();ge();var Dx=class Dx{constructor(n,t,o,r){f(this,"__srcEntity");f(this,"__dstEntity");f(this,"__aimAxis");f(this,"__weight");this.__srcEntity=n,this.__aimAxis=t,this.__weight=o,this.__dstEntity=r,this.__dstEntity.getTransform()._backupTransformAsRest()}getAxisVector(n){switch(n){case"PositiveX":return S.fromCopy3(1,0,0);case"NegativeX":return S.fromCopy3(-1,0,0);case"PositiveY":return S.fromCopy3(0,1,0);case"NegativeY":return S.fromCopy3(0,-1,0);case"PositiveZ":return S.fromCopy3(0,0,1);case"NegativeZ":return S.fromCopy3(0,0,-1);default:throw new Error("Invalid roll axis")}}update(){let n=this.getAxisVector(this.__aimAxis),t=A.exist(this.__dstEntity.getSceneGraph().parent)?this.__dstEntity.getSceneGraph().parent.rotation:H.identity(),o=this.__dstEntity.localRotationRestInner,r=H.multiply(t,o).transformVector3(n),i=S.normalize(S.subtract(this.__srcEntity.position,this.__dstEntity.position)),a=H.fromToRotation(r,i),s=H.lerp(o,H.multiply(H.multiply(H.multiply(H.invert(t),a),t),o),this.__weight);this.__dstEntity.localRotation=s}};h(Dx,"VrmAimConstraint");var Um=Dx;Or();var Bx=class Bx{constructor(n,t,o){f(this,"__srcEntity");f(this,"__dstEntity");f(this,"__weight");this.__srcEntity=n,this.__weight=t,this.__dstEntity=o,this.__dstEntity.getTransform()._backupTransformAsRest()}update(){let n=H.multiply(H.invert(this.__srcEntity.localRotationRestInner),this.__srcEntity.localRotationInner),t=H.lerp(this.__dstEntity.localRotationRestInner,H.multiply(this.__dstEntity.localRotationRestInner,n),this.__weight);this.__dstEntity.localRotation=t}};h(Bx,"VrmRotationConstraint");var km=Bx;Vo();var Wm=class Wm{constructor(){}static async __importVRM(n,t){var c,u,_,d,p,x,v;let o=(u=(c=n.asset.extras)==null?void 0:c.rnLoaderOptions)==null?void 0:u.defaultMaterialHelperArgumentArray,r=this._createTextures(n),i=this._createSamplers(n);A.exist(o)&&(o[0].textures=(_=o[0].textures)!=null?_:r,o[0].samplers=(d=o[0].samplers)!=null?d:i,o[0].isLighting=(p=o[0].isLighting)!=null?p:!0);let a=this.__initializeMToonMaterialProperties(n,r.length),s;if(a){t[1]=(x=t[1])!=null?x:new Dt;let y=t[1];y.toClearColorBuffer=!1,y.toClearDepthBuffer=!1,n.extensions.VRM={},n.extensions.VRM.rnExtension={renderPassOutline:y},s=Ve.convertToRhodoniteObject(n),y.addEntities([s])}else s=Ve.convertToRhodoniteObject(n);let l=t[0];l.tryToSetUniqueName("VRM Main RenderPass",!0),l.addEntities([s]),this._readSpringBone(n),this._readVRMHumanoidInfo(n,s),this._readExpressions(n,s),this._readConstraints(n),((v=n.asset.extras)==null?void 0:v.rnLoaderOptions)!=null&&(n.asset.extras.rnLoaderOptions.defaultMaterialHelperArgumentArray=[])}static _readConstraints(n){var t,o;for(let r=0;r<n.nodes.length;r++){let a=(o=(t=n.nodes[r].extensions)==null?void 0:t.VRMC_node_constraint)==null?void 0:o.constraint;if(A.exist(a)){if(A.exist(a.roll)){let s=a.roll,l=n.extras.rnEntities[r],c=n.extras.rnEntities[s.source],u=ne.addComponentToEntity(zi,l),_=new Om(c,s.rollAxis,A.exist(s.weight)?s.weight:1,u);u.getConstraint().setConstraint(_)}else if(A.exist(a.aim)){let s=a.aim,l=n.extras.rnEntities[r],c=n.extras.rnEntities[s.source],u=ne.addComponentToEntity(zi,l),_=new Um(c,s.aimAxis,A.exist(s.weight)?s.weight:1,u);u.getConstraint().setConstraint(_)}else if(A.exist(a.rotation)){let s=a.rotation,l=n.extras.rnEntities[r],c=n.extras.rnEntities[s.source],u=ne.addComponentToEntity(zi,l),_=new km(c,A.exist(s.weight)?s.weight:1,u);u.getConstraint().setConstraint(_)}}}}static _readExpressions(n,t){var a,s;let o=[];if(A.not.exist((s=(a=n.extensions.VRMC_vrm)==null?void 0:a.expressions)==null?void 0:s.preset))return;let r=n.extensions.VRMC_vrm.expressions.preset;for(let l in r){let c=r[l],u=[];A.exist(c.morphTargetBinds)&&(u=c.morphTargetBinds.map(d=>({entityIdx:n.extras.rnEntities[d.node].entityUID,blendShapeIdx:d.index,weight:d.weight})));let _={name:l,isBinary:c.isBinary,binds:u};o.push(_)}let i=ne.addComponentToEntity(mi,t);i.getVrm().setVrmExpressions(o),i.getVrm()._version="1.0"}static _readVRMHumanoidInfo(n,t){let o=n.extensions.VRMC_vrm.humanoid.humanBones,r=new Map;for(let i in o){let a=o[i];r.set(i,a.node)}t!=null&&t.tryToSetTag({tag:"humanoid_map_name_nodeId",value:r})}static _readSpringBone(n){var r,i;let t=[];if(A.exist((r=n.extensions.VRMC_springBone)==null?void 0:r.colliderGroups))for(let a in n.extensions.VRMC_springBone.colliderGroups){let s=n.extensions.VRMC_springBone.colliderGroups[a],l=new La;t.push(l);for(let c of s.colliders){let u=n.extensions.VRMC_springBone.colliders[c],_=n.asset.extras.rnEntities[u.node].getSceneGraph();if(A.exist(u.shape.sphere)){let d=new Fa;d.baseSceneGraph=_,d.position=S.fromCopyArray([u.shape.sphere.offset[0],u.shape.sphere.offset[1],u.shape.sphere.offset[2]]),d.radius=u.shape.sphere.radius,l.sphereColliders.push(d)}else if(A.exist(u.shape.capsule)){let d=new Nf;d.baseSceneGraph=_,d.position=S.fromCopyArray([u.shape.capsule.offset[0],u.shape.capsule.offset[1],u.shape.capsule.offset[2]]),d.radius=u.shape.capsule.radius,d.tail=S.fromCopyArray([u.shape.capsule.tail[0],u.shape.capsule.tail[1],u.shape.capsule.tail[2]]),l.capsuleColliders.push(d)}}}let o=[];if(A.exist((i=n.extensions.VRMC_springBone)==null?void 0:i.springs))for(let a of n.extensions.VRMC_springBone.springs){let s=a.joints[0],l=n.asset.extras.rnEntities[s.node],c=new Va(l.getSceneGraph());c.tryToSetUniqueName(a.name,!0);let u=A.exist(a.colliderGroups)?a.colliderGroups:[];c.colliderGroups=u.map(d=>t[d]);let _=[];for(let d in a.joints){let p=a.joints[d],x=n.asset.extras.rnEntities[p.node],v=new Oi(x);v.dragForce=p.dragForce,v.stiffnessForce=p.stiffness,v.gravityPower=A.exist(p.gravityPower)?p.gravityPower:1,v.gravityDir=A.exist(p.gravityDir)?S.fromCopyArray3([p.gravityDir[0],p.gravityDir[1],p.gravityDir[2]]):S.fromCopyArray3([0,-1,0]),v.hitRadius=p.hitRadius,c.bones.push(v),_.push(x)}a.center!=null&&a.center!==-1&&(c.center=n.asset.extras.rnEntities[a.center].getSceneGraph()),this.__addSpringBoneRecursively(c,l,_),o.push(c)}for(let a of o)this.__addPhysicsComponent(a,a.rootBone)}static __addSpringBoneRecursively(n,t,o){let i=t.getSceneGraph().children;if(!o.includes(t)){let a=new Oi(t);n.bones.push(a),o.push(t)}for(let a of i)this.__addSpringBoneRecursively(n,a.entity,o)}static __addPhysicsComponent(n,t){let o=t.entity,i=ne.addComponentToEntity(Uo,o).getPhysics(),a=new Ba;a.setSpring(n),i.setStrategy(a)}static _createTextures(n){n.textures||(n.textures=[]);let t=n.textures,o=[];for(let a=0;a<t.length;a++){let s=Ve._createTexture(t[a].image,n);o[a]=s}let r=new Jt;r.generate1x1TextureFrom(),o.push(r);let i=new Jt;return i.generate1x1TextureFrom("rgba(0, 0, 0, 1)"),o.push(i),o}static _createSamplers(n){n.textures||(n.textures=[]);let t=n.textures,o=[];for(let i=0;i<t.length;i++){let a=Ve._createSampler(t[i].samplerObject);o[i]=a}let r=new Ge({wrapS:U.ClampToEdge,wrapT:U.ClampToEdge,minFilter:U.Linear,magFilter:U.Linear});return r.create(),o.push(r),o.push(r),o}static __initializeMToonMaterialProperties(n,t){var r;let o=!1;for(let i of n.materials){let a=(r=i.extensions)==null?void 0:r.VRMC_materials_mtoon;a!=null&&(A.not.exist(i.extras)&&(i.extras={}),a.outlineWidthMode!=="none"&&(o=!0))}return o}static _getOptions(n){if(n!=null){for(let t in n.files){let o=t.split(".vrm")[0];if(o){let r=n.files[t];n.files[o+".glb"]=r,delete n.files[t]}}n.__isImportVRM0x=!0,n.defaultMaterialHelperArgumentArray==null&&(n.defaultMaterialHelperArgumentArray=[{}]),n.defaultMaterialHelperArgumentArray[0].isMorphing||(n.maxMorphTargetNumber=0)}else n={files:{},loaderExtension:void 0,defaultMaterialHelperName:void 0,defaultMaterialHelperArgumentArray:[{isLighting:!0,isMorphing:!0,isSkinning:!0}],statesOfElements:[{targets:[],states:{enable:[],functions:{}},isTransparent:!0,opacity:1,isTextureImageToLoadPreMultipliedAlpha:!1}],__isImportVRM0x:!0,__importedType:"vrm1"};return n}static async importJsonOfVRM(n,t){t=this._getOptions(t);let o=await so.importFromUri(n,t);if(o.isErr())return new Ue({message:"Failed to import VRM file.",error:o});Zr(o);let r=o.get();return Wm._readVRMHumanoidInfo(r),new je(r)}};h(Wm,"VrmImporter");var Pf=Wm;var Lx=class Lx{constructor(){}static async importFromUri(n,t,o){var s;t=this.__initOptions(t);let r=((s=t.expression)==null?void 0:s.renderPasses)||[];r.length===0&&r.push(new Dt);let i=await ie.fetchArrayBuffer(n);if(i.isErr())return new Ue({message:"Failed to fetch array buffer",error:i});if(t.files[n]=i.get(),await this.__detectTheModelFileTypeAndImport(n,r,t,n,o),t&&t.cameraComponent)for(let l of r)l.cameraComponent=t.cameraComponent;let a=this.__setRenderPassesToExpression(r,t);return new je(a)}static async importFromArrayBuffers(n,t,o){var a;t=this.__initOptions(t);let r=((a=t.expression)==null?void 0:a.renderPasses)||[];r.length===0&&r.push(new Dt);for(let s in n){let l=ie.getExtension(s);this.__isValidExtension(l)&&await this.__detectTheModelFileTypeAndImport(s,r,t,s,o)}if(t&&t.cameraComponent)for(let s of r)s.cameraComponent=t.cameraComponent;let i=this.__setRenderPassesToExpression(r,t);return new je(i)}static __initOptions(n){if(n==null)n=ie.createDefaultGltfOptions();else{n.files==null&&(n.files={});for(let t in n.files){if(t.match(/.*\.vrm$/)==null)continue;let o=t.split(".vrm")[0];if(o){let r=n.files[t];n.files[o+".glb"]=r,delete n.files[t]}}Array.isArray(n.defaultMaterialHelperArgumentArray)===!1?n.defaultMaterialHelperArgumentArray=[{}]:n.defaultMaterialHelperArgumentArray[0].isMorphing===!1&&(n.maxMorphTargetNumber=0)}return n}static __setRenderPassesToExpression(n,t){var r;let o=(r=t.expression)!=null?r:new gn;return o.renderPasses!==n&&(o.clearRenderPasses(),o.addRenderPasses(n)),o}static __isValidExtension(n){return n==="gltf"||n==="glb"||n==="vrm"||n==="drc"}static __isGlb(n){let r=new DataView(n,0,20).getUint32(0,!0),i;return r===1179937895}static __getGlbVersion(n){return new DataView(n,0,20).getUint32(4,!0)}static __getGltfVersion(n){var t,o;return((o=(t=n.asset)==null?void 0:t.version)==null?void 0:o.charAt(0))==="2"?2:1}static async __detectTheModelFileTypeAndImport(n,t,o,r,i){let a=o.fileType,s=this.__getFileTypeFromFilePromise(n,o,a),l=o.files[n];o.__isImportVRM0x=!1;let c=0;switch(s){case Yo.Gltf:{let u=ie.arrayBufferToString(l),_=JSON.parse(u);c=this.__getGltfVersion(_);let p=await so._importGltf(_,o.files,o,n,i),x=Ve.convertToRhodoniteObject(p);return t[0].addEntities([x]),o.__importedType="gltf2",new je}case Yo.GltfBinary:{c=this.__getGlbVersion(l);let _=await so._importGlb(l,o.files,o),d=Ve.convertToRhodoniteObject(_);return t[0].addEntities([d]),o.__importedType="glb2",new je}case Yo.Draco:{let _=await wf.getInstance().importArrayBuffer(r,l,o);if(_==null)return new Ue({message:"importArrayBuffer error is occurred",error:void 0});{o.__importedType="draco";let d=Ve.convertToRhodoniteObject(_);return t[0].addEntities([d]),new je}}case Yo.VRM:{o.__isImportVRM0x=!0;let u=await so._importGltfOrGlbFromArrayBuffers(l,o.files,o);if(u.isOk()){let _=u.get();return _.extensionsUsed.indexOf("VRMC_vrm")>=0?(o.__isImportVRM0x=!1,_.asset.extras.rnLoaderOptions.__isImportVRM0x=!1,o.__importedType="vrm1",await Pf.__importVRM(_,t)):_.extensionsUsed.indexOf("VRM")>=0&&(o.__importedType="vrm0x",await Rf.__importVRM0x(_,t)),new je}else return E_(u),new Ue({message:u.getRnError().message,error:void 0})}default:return new Ue({message:"detect invalid format",error:void 0})}}static __getFileTypeFromFilePromise(n,t,o){return o!=null?Yo.fromString(o):wx({[n]:t.files[n]})}};h(Lx,"GltfImporter");var Fx=Lx;Ma();Lp();ge();ir();Na();var zx=class zx{static async importFromUri(n){let t={},o=await so.importFromUri(n,t);if(o.isErr())return new Ue({message:"Failed to import VRM file.",error:o});Zr(o);let r=o.get();return this.readHumanoid(r),new je(r)}static async importFromArrayBuffer(n){let t={},o=await so.importFromArrayBuffers({"data.glb":n},t);if(o.isErr())return new Ue({message:"Failed to import VRM file.",error:o});Zr(o);let r=o.get();return this.readHumanoid(r),new je(r)}static readHumanoid(n){var r;let t=(r=n.extensions.VRMC_vrm_animation.humanoid)==null?void 0:r.humanBones;if(A.not.exist(t))return;let o=new Map;n.extensions.VRMC_vrm_animation.humanoidBoneNameMap=o;for(let i in t){let a=t[i];o.set(a.node,i)}}};h(zx,"VrmaImporter");var Vx=zx;Go();dt();el();tl();dt();Zt();se();xe();tr();un();tr();xe();Ke();Ze();var Gx=class Gx extends ht{constructor(t,o,r){super();f(this,"__functionName");f(this,"__compositionType");f(this,"__componentType");f(this,"__constantValueStr");this.__functionName=t,this.__compositionType=o,this.__componentType=r,this.__constantValueStr=""}setConstantValue(t){let o="";this.__componentType.isFloatingPoint()?o=t.glslStrAsFloat:this.__componentType.isInteger()?o=t.glslStrAsInt:this.__componentType===I.Bool&&(o=t.x?"true":"false"),this.__constantValueStr=o}get vertexShaderDefinitions(){return K.currentProcessApproach===Z.WebGPU?`
      fn ${this.__functionName}(
        outValue: ptr<function, ${this.__compositionType.toWGSLType(this.__componentType)}>) {
        *outValue = ${this.__constantValueStr};
      }
      `:`
      void ${this.__functionName}(
        out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
        outValue = ${this.__constantValueStr};
      }
      `}get pixelShaderDefinitions(){return K.currentProcessApproach===Z.WebGPU?`
      fn ${this.__functionName}(
        outValue: ptr<function, ${this.__compositionType.toWGSLType(this.__componentType)}>) {
        *outValue = ${this.__constantValueStr};
      }
      `:`
      void ${this.__functionName}(
        out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
        outValue = ${this.__constantValueStr};
      }
      `}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}};h(Gx,"ConstantVariableShader");var Mf=Gx;dt();var Ox=class Ox{constructor(n,t,o){f(this,"name");f(this,"compositionType");f(this,"componentType");this.name=n,this.compositionType=t,this.componentType=o}};h(Ox,"Socket");var Pt=Ox;var Ux=class Ux extends ce{constructor(n,t,o){super(n,{}),this.__shaderFunctionName+="_"+this.__shaderNodeUid,this.__commonPart=new Mf(this.__shaderFunctionName,t,o),this.__outputs.push(new Pt("outValue",t,o))}setDefaultInputValue(n){this.__commonPart.setConstantValue(n)}getSocketOutput(){return this.__outputs[0]}};h(Ux,"ConstantVariableShaderNode");var jr=Ux;var kx=class kx extends jr{constructor(n){super("ConstantScalar",b.Scalar,n)}setDefaultInputValue(n){this.__commonPart.setConstantValue(n)}};h(kx,"ConstantScalarVariableShaderNode");var Df=kx;Tn();un();var Wx=class Wx extends jr{constructor(n){super("ConstantVector2",b.Vec2,n)}setDefaultInputValue(n){this.__commonPart.setConstantValue(n)}};h(Wx,"ConstantVector2VariableShaderNode");var Bf=Wx;Xo();un();var Qx=class Qx extends jr{constructor(n){super("ConstantVector3",b.Vec3,n)}setDefaultInputValue(n){this.__commonPart.setConstantValue(n)}};h(Qx,"ConstantVector3VariableShaderNode");var Ff=Qx;ye();It();un();var Xx=class Xx extends jr{constructor(n){super("ConstantVector4",b.Vec4,n)}setDefaultInputValue(n){this.__commonPart.setConstantValue(n)}};h(Xx,"ConstantVector4VariableShaderNode");var Lf=Xx;tr();Ke();Ze();var Hx=class Hx extends ht{constructor(t,o,r){super();f(this,"__functionName");f(this,"__compositionType");f(this,"__componentType");f(this,"__variableName");f(this,"__valueStr");this.__functionName=t,this.__compositionType=o,this.__componentType=r,this.__variableName="",this.__valueStr=""}setVariableName(t){this.__variableName=t}setDefaultValue(t){this.__valueStr=t.toString()}get vertexShaderDefinitions(){return K.currentProcessApproach===Z.WebGPU?`
// #param ${this.__variableName}: ${this.__compositionType.toWGSLType(this.__componentType)}; // initialValue=${this.__valueStr}
fn ${this.__functionName}(outValue: ptr<function, ${this.__compositionType.toWGSLType(this.__componentType)}>) {
  *outValue = get_${this.__variableName}(_materialSID, 0);
}
`:`
uniform ${this.__compositionType.getGlslStr(this.__componentType)} u_${this.__variableName}; // initialValue=${this.__valueStr}
void ${this.__functionName}(out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
  #ifdef RN_IS_DATATEXTURE_MODE
    float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID
  #else
    float materialSID = u_materialSID;
  #endif

  outValue = get_${this.__variableName}(materialSID, 0);
}
`}get pixelShaderDefinitions(){return K.currentProcessApproach===Z.WebGPU?`
// #param ${this.__variableName}: ${this.__compositionType.toWGSLType(this.__componentType)}; // initialValue=${this.__valueStr}
fn ${this.__functionName}(outValue: ptr<function, ${this.__compositionType.toWGSLType(this.__componentType)}>) {
  *outValue = get_${this.__variableName}(_materialSID, 0);
}
`:`
uniform ${this.__compositionType.getGlslStr(this.__componentType)} u_${this.__variableName}; // initialValue=${this.__valueStr}
void ${this.__functionName}(out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID
#else
  float materialSID = u_materialSID;
#endif

outValue = get_${this.__variableName}(materialSID, 0);
    }
    `}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}};h(Hx,"UniformDataShader");var Vf=Hx;dt();var qx=class qx extends ce{constructor(n,t){super("uniformData",{}),this.__shaderFunctionName+="_"+this.__shaderNodeUid,this.__commonPart=new Vf(this.__shaderFunctionName,n,t),this.__outputs.push(new Pt("outValue",n,t))}setDefaultInputValue(n,t){n==="value"&&this.__commonPart.setDefaultValue(t)}setUniformDataName(n){this.__commonPart.setVariableName(n)}};h(qx,"UniformDataShaderNode");var zf=qx;dt();se();xe();var m4={code:`
void add(in float lfs, in float rhs, out float outValue) {
  outValue = lfs + rhs;
}
void add(in int lfs, in int rhs, out int outValue) {
  outValue = lfs + rhs;
}
void add(in vec2 lfs, in vec2 rhs, out vec2 outValue) {
  outValue = lfs + rhs;
}
void add(in vec3 lfs, in vec3 rhs, out vec3 outValue) {
  outValue = lfs + rhs;
}
void add(in vec4 lfs, in vec4 rhs, out vec4 outValue) {
  outValue = lfs + rhs;
}
`,shaderStage:"fragment",isFragmentShader:!0};var _4={code:`
fn addF32F32(lfs: f32, rhs: f32, outValue: ptr<function, f32>) {
  *outValue = lfs + rhs;
}
fn addI32I32(lfs: i32, rhs: i32, outValue: ptr<function, i32>) {
  *outValue = lfs + rhs;
}
fn addVec2fVec2f(lfs: vec2<f32>, rhs: vec2<f32>, outValue: ptr<function, vec2<f32>>) {
  *outValue = lfs + rhs;
}
fn addVec3fVec3f(lfs: vec3<f32>, rhs: vec3<f32>, outValue: ptr<function, vec3<f32>>) {
  *outValue = lfs + rhs;
}
fn addVec4fVec4f(lfs: vec4<f32>, rhs: vec4<f32>, outValue: ptr<function, vec4<f32>>) {
  *outValue = lfs + rhs;
}
`,shaderStage:"fragment",isFragmentShader:!0};Ke();Ze();var jx=class jx extends ce{constructor(n,t){super("add",{codeGLSL:m4.code,codeWGSL:_4.code}),this.__inputs.push(new Pt("lhs",n,t)),this.__inputs.push(new Pt("rhs",n,t)),this.__outputs.push(new Pt("outValue",n,t))}getSocketInputLhs(){return this.__inputs[0]}getSocketInputRhs(){return this.__inputs[1]}getSocketOutput(){return this.__outputs[0]}getShaderFunctionNameDerivative(){if(K.currentProcessApproach===Z.WebGPU)if(this.__inputs[0].compositionType===b.Scalar&&this.__inputs[1].compositionType===b.Scalar){if(this.__inputs[0].componentType===I.Float&&this.__inputs[1].componentType===I.Float)return this.__shaderFunctionName+"F32F32";if(this.__inputs[0].componentType===I.Int&&this.__inputs[1].componentType===I.Int)return this.__shaderFunctionName+"I32I32";throw new Error("Not implemented")}else{if(this.__inputs[0].compositionType===b.Vec2&&this.__inputs[1].compositionType===b.Vec2)return this.__shaderFunctionName+"Vec2fVec2f";if(this.__inputs[0].compositionType===b.Vec3&&this.__inputs[1].compositionType===b.Vec3)return this.__shaderFunctionName+"Vec3fVec3f";if(this.__inputs[0].compositionType===b.Vec4&&this.__inputs[1].compositionType===b.Vec4)return this.__shaderFunctionName+"Vec4fVec4f";throw new Error("Not implemented")}else return this.__shaderFunctionName}};h(jx,"AddShaderNode");var Ui=jx;var d4={code:`
void _normalize(in vec2 value, out vec2 outValue) {
  outValue = normalize(value);
}

void _normalize(in vec3 value, out vec3 outValue) {
  outValue = normalize(value);
}

void _normalize(in vec4 value, out vec4 outValue) {
  outValue = normalize(value);
}
`,shaderStage:"fragment",isFragmentShader:!0};var h4={code:`
fn _normalizeVec2f(value: vec2<f32>, outValue: ptr<function, vec2<f32>>) {
  *outValue = normalize(value);
}

fn _normalizeVec3f(value: vec3<f32>, outValue: ptr<function, vec3<f32>>) {
  *outValue = normalize(value);
}

fn _normalizeVec4f(value: vec4<f32>, outValue: ptr<function, vec4<f32>>) {
  *outValue = normalize(value);
}
`,shaderStage:"fragment",isFragmentShader:!0};se();dt();Ze();Ke();var Yx=class Yx extends ce{constructor(n,t){super("_normalize",{codeGLSL:d4.code,codeWGSL:h4.code}),this.__inputs.push({compositionType:n,componentType:t,name:"value"}),this.__outputs.push({compositionType:n,componentType:t,name:"outValue"})}getShaderFunctionNameDerivative(){if(K.currentProcessApproach===Z.WebGPU){if(this.__inputs[0].compositionType===b.Vec2)return this.__shaderFunctionName+"Vec2f";if(this.__inputs[0].compositionType===b.Vec3)return this.__shaderFunctionName+"Vec3f";if(this.__inputs[0].compositionType===b.Vec4)return this.__shaderFunctionName+"Vec4f";throw new Error("Not supported composition type.")}else return this.__shaderFunctionName}};h(Yx,"NormalizeShaderNode");var za=Yx;var p4={code:`
void dotProduct(in vec2 lfs, in vec2 rhs, out float outValue) {
  outValue = dot(lfs, rhs);
}
void dotProduct(in vec3 lfs, in vec3 rhs, out float outValue) {
  outValue = dot(lfs, rhs);
}
void dotProduct(in vec4 lfs, in vec4 rhs, out float outValue) {
  outValue = dot(lfs, rhs);
}
`,shaderStage:"fragment",isFragmentShader:!0};var x4={code:`fn dotProductVec2f(lfs: vec2<f32>, rhs: vec2<f32>, outValue: ptr<function, f32>) {
  *outValue = dot(lfs, rhs);
}
fn dotProductVec3f(lfs: vec3<f32>, rhs: vec3<f32>, outValue: ptr<function, f32>) {
  *outValue = dot(lfs, rhs);
}
fn dotProductVec4f(lfs: vec4<f32>, rhs: vec4<f32>, outValue: ptr<function, f32>) {
  *outValue = dot(lfs, rhs);
}
`,shaderStage:"fragment",isFragmentShader:!0};dt();se();xe();Ze();Ke();var Kx=class Kx extends ce{constructor(n,t){super("dotProduct",{codeGLSL:p4.code,codeWGSL:x4.code}),this.__inputs.push({compositionType:n,componentType:t,name:"lhs"}),this.__inputs.push({compositionType:n,componentType:I.Float,name:"rhs"}),this.__outputs.push({compositionType:b.Scalar,componentType:t,name:"outValue"})}getShaderFunctionNameDerivative(){if(K.currentProcessApproach===Z.WebGPU){if(this.__inputs[0].compositionType===b.Vec2)return this.__shaderFunctionName+"Vec2f";if(this.__inputs[0].compositionType===b.Vec3)return this.__shaderFunctionName+"Vec3f";if(this.__inputs[0].compositionType===b.Vec4)return this.__shaderFunctionName+"Vec4f";throw new Error("Not supported composition type.")}else return this.__shaderFunctionName}};h(Kx,"DotProductShaderNode");var Ga=Kx;se();var v4={code:`
void multiply(in float lfs, in float rhs, out float outValue) {
  outValue = lfs * rhs;
}
void multiply(in int lfs, in int rhs, out int outValue) {
  outValue = lfs * rhs;
}
void multiply(in vec2 lfs, in vec2 rhs, out vec2 outValue) {
  outValue = lfs * rhs;
}
void multiply(in vec3 lfs, in vec3 rhs, out vec3 outValue) {
  outValue = lfs * rhs;
}
void multiply(in vec4 lfs, in vec4 rhs, out vec4 outValue) {
  outValue = lfs * rhs;
}
void multiply(in mat2 lfs, in mat2 rhs, out mat2 outValue) {
  outValue = lfs * rhs;
}
void multiply(in mat3 lfs, in mat3 rhs, out mat3 outValue) {
  outValue = lfs * rhs;
}
void multiply(in mat4 lfs, in mat4 rhs, out mat4 outValue) {
  outValue = lfs * rhs;
}
`,shaderStage:"fragment",isFragmentShader:!0};var g4={code:`fn multiplyF32F32(lfs: f32, rhs: f32, outValue: ptr<function, f32>) {
  *outValue = lfs * rhs;
}
fn multiplyI32I32(lfs: i32, rhs: i32, outValue: ptr<function, i32>) {
  *outValue = lfs * rhs;
}
fn multiplyVec2fVec2f(lfs: vec2<f32>, rhs: vec2<f32>, outValue: ptr<function, vec2<f32>>) {
  *outValue = lfs * rhs;
}
fn multiplyVec3fVec3f(lfs: vec3<f32>, rhs: vec3<f32>, outValue: ptr<function, vec3<f32>>) {
  *outValue = lfs * rhs;
}
fn multiplyVec4fVec4f(lfs: vec4<f32>, rhs: vec4<f32>, outValue: ptr<function, vec4<f32>>) {
  *outValue = lfs * rhs;
}
fn multiplyMat2x2fMat2x2f(lfs: mat2x2<f32>, rhs: mat2x2<f32>, outValue: ptr<function, mat2x2<f32>>) {
  *outValue = lfs * rhs;
}
fn multiplyMat3x3fMat3x3f(lfs: mat3x3<f32>, rhs: mat3x3<f32>, outValue: ptr<function, mat3x3<f32>>) {
  *outValue = lfs * rhs;
}
fn multiplyMat4x4fMat4x4f(lfs: mat4x4<f32>, rhs: mat4x4<f32>, outValue: ptr<function, mat4x4<f32>>) {
  *outValue = lfs * rhs;
}
`,shaderStage:"fragment",isFragmentShader:!0};xe();dt();Ze();Ke();var Zx=class Zx extends ce{constructor(n,t){super("multiply",{codeGLSL:v4.code,codeWGSL:g4.code}),this.__inputs.push({compositionType:n,componentType:t,name:"lhs"}),this.__inputs.push({compositionType:n,componentType:t,name:"rhs"}),this.__outputs.push({compositionType:n,componentType:t,name:"outValue"})}getShaderFunctionNameDerivative(){if(K.currentProcessApproach===Z.WebGPU)if(this.__inputs[0].compositionType===b.Scalar&&this.__inputs[1].compositionType===b.Scalar){if(this.__inputs[0].componentType===I.Float&&this.__inputs[1].componentType===I.Float)return this.__shaderFunctionName+"F32F32";if(this.__inputs[0].componentType===I.Int&&this.__inputs[1].componentType===I.Int)return this.__shaderFunctionName+"I32I32";throw new Error("Not implemented")}else{if(this.__inputs[0].compositionType===b.Vec2&&this.__inputs[1].compositionType===b.Vec2)return this.__shaderFunctionName+"Vec2fVec2f";if(this.__inputs[0].compositionType===b.Vec3&&this.__inputs[1].compositionType===b.Vec3)return this.__shaderFunctionName+"Vec3fVec3f";if(this.__inputs[0].compositionType===b.Vec4&&this.__inputs[1].compositionType===b.Vec4)return this.__shaderFunctionName+"Vec4fVec4f";if(this.__inputs[0].compositionType===b.Mat2&&this.__inputs[1].compositionType===b.Mat2)return this.__shaderFunctionName+"Mat2x2fMat2x2f";if(this.__inputs[0].compositionType===b.Mat3&&this.__inputs[1].compositionType===b.Mat3)return this.__shaderFunctionName+"Mat3x3fMat3x3f";if(this.__inputs[0].compositionType===b.Mat4&&this.__inputs[1].compositionType===b.Mat4)return this.__shaderFunctionName+"Mat4x4fMat4x4f";throw new Error("Not implemented")}else return this.__shaderFunctionName}};h(Zx,"MultiplyShaderNode");var Mr=Zx;se();xe();var y4={code:`
in vec4 a_color_0;

void attributeColor(out vec4 outValue) {
  outValue = a_color_0;
}
`,shaderStage:"vertex",isFragmentShader:!1};var b4={code:`fn attributeColor(outValue: ptr<function, vec4<f32>>) {
  *outValue = a_color_0;
}
`,shaderStage:"vertex",isFragmentShader:!1};dt();var Jx=class Jx extends ce{constructor(){super("attributeColor",{codeGLSL:y4.code,codeWGSL:b4.code}),this.setShaderStage("Vertex"),this.__outputs.push({compositionType:b.Vec4,componentType:I.Float,name:"outValue"})}};h(Jx,"AttributeColorShaderNode");var Gf=Jx;se();xe();var A4={code:`
in vec3 a_normal;

void attributeNormal(out vec3 outValue) {
  outValue = a_normal;
}
`,shaderStage:"vertex",isFragmentShader:!1};var I4={code:`fn attributeNormal(outValue: ptr<function, vec3<f32>>) {
  *outValue = a_normal;
}
`,shaderStage:"vertex",isFragmentShader:!1};dt();var $x=class $x extends ce{constructor(){super("attributeNormal",{codeGLSL:A4.code,codeWGSL:I4.code}),this.setShaderStage("Vertex"),this.__outputs.push({compositionType:b.Vec3,componentType:I.Float,name:"outValue"})}};h($x,"AttributeNormalShaderNode");var Of=$x;se();xe();var S4={code:`
in vec4 a_position;

void attributePosition(out vec4 outValue) {
  outValue = a_position;
}
`,shaderStage:"vertex",isFragmentShader:!1};var T4={code:`fn attributePosition(outValue: ptr<function, vec4f>) {
  *outValue = vec4f(a_position, 1.0);
}
`,shaderStage:"vertex",isFragmentShader:!1};dt();var ev=class ev extends ce{constructor(){super("attributePosition",{codeGLSL:S4.code,codeWGSL:T4.code}),this.setShaderStage("Vertex"),this.__outputs.push(new Pt("outValue",b.Vec4,I.Float))}getSocketOutput(){return this.__outputs[0]}};h(ev,"AttributePositionShaderNode");var Uf=ev;se();xe();var E4={code:`
in vec2 a_texcoord_0;

void attributeTexcoord(out vec2 outValue) {
  outValue = a_texcoord_0;
}
`,shaderStage:"vertex",isFragmentShader:!1};var C4={code:`
fn attributeTexcoord(outValue: ptr<function, vec2<f32>>) {
  *outValue = a_texcoord_0;
}
`,shaderStage:"vertex",isFragmentShader:!1};dt();var tv=class tv extends ce{constructor(){super("attributeTexcoord",{codeGLSL:E4.code,codeWGSL:C4.code}),this.setShaderStage("Vertex"),this.__outputs.push({compositionType:b.Vec3,componentType:I.Float,name:"outValue"})}};h(tv,"AttributeTexcoordShaderNode");var kf=tv;se();xe();var w4={code:`
void worldMatrix(out mat4 outValue) {
  outValue = get_worldMatrix(a_instanceInfo.x);
}
`,shaderStage:"vertex",isFragmentShader:!1};var R4={code:`
fn worldMatrix(outValue: ptr<function, mat4x4<f32>>) {
  *outValue = get_worldMatrix(u32(a_instanceIds.x));
}
`,shaderStage:"vertex",isFragmentShader:!1};dt();var nv=class nv extends ce{constructor(){super("worldMatrix",{codeGLSL:w4.code,codeWGSL:R4.code}),this.setShaderStage("Vertex"),this.__outputs.push({compositionType:b.Mat4,componentType:I.Float,name:"outValue"})}};h(nv,"WorldMatrixShaderNode");var Wf=nv;se();xe();var N4={code:`
void viewMatrix(out mat4 outValue) {
  float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID}*/];
  outValue = get_viewMatrix(cameraSID, 0);
}
`,shaderStage:"vertex",isFragmentShader:!1};var P4={code:`
fn viewMatrix(outValue: ptr<function, mat4x4<f32>>) {
  *outValue = get_viewMatrix(_cameraSID, 0);
}
`,shaderStage:"vertex",isFragmentShader:!1};dt();var ov=class ov extends ce{constructor(){super("viewMatrix",{codeGLSL:N4.code,codeWGSL:P4.code}),this.setShaderStage("Vertex"),this.__outputs.push({compositionType:b.Mat4,componentType:I.Float,name:"outValue"})}};h(ov,"ViewMatrixShaderNode");var Qf=ov;se();xe();var M4={code:`
void projectionMatrix(out mat4 outValue) {
  float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID}*/];
  outValue = get_projectionMatrix(cameraSID, 0);
}
`,shaderStage:"vertex",isFragmentShader:!1};var D4={code:`
fn projectionMatrix(outValue: ptr<function, mat4x4<f32>>) {
  *outValue = get_projectionMatrix(_cameraSID, 0);
}
`,shaderStage:"vertex",isFragmentShader:!1};dt();var rv=class rv extends ce{constructor(){super("projectionMatrix",{codeGLSL:M4.code,codeWGSL:D4.code}),this.setShaderStage("Vertex"),this.__outputs.push({compositionType:b.Mat4,componentType:I.Float,name:"outValue"})}};h(rv,"ProjectionMatrixShaderNode");var Xf=rv;se();xe();var B4={code:`
void normalMatrix(out mat3 outValue) {
  outValue = get_normalMatrix(a_instanceInfo.x);
}
`,shaderStage:"vertex",isFragmentShader:!1};var F4={code:`
fn normalMatrix(outValue: ptr<function, mat3x3<f32>>) {
  *outValue = get_normalMatrix(u32(a_instanceIds.x));
}
`,shaderStage:"vertex",isFragmentShader:!1};dt();var iv=class iv extends ce{constructor(){super("normalMatrix",{codeGLSL:B4.code,codeWGSL:F4.code}),this.setShaderStage("Vertex"),this.__outputs.push({compositionType:b.Mat3,componentType:I.Float,name:"outValue"})}};h(iv,"NormalMatrixShaderNode");var Hf=iv;dt();se();xe();var L4={code:`
void greater(in float lhs, in float rhs, out bool outValue) {
  outValue = lhs > rhs;
}

void greater(in int lhs, in int rhs, out bool outValue) {
  outValue = lhs > rhs;
}
`,shaderStage:"fragment",isFragmentShader:!0};var av=class av extends ce{constructor(n,t){super("greater",{codeGLSL:L4.code}),this.__inputs.push({compositionType:n,componentType:t,name:"lhs"}),this.__inputs.push({compositionType:n,componentType:I.Float,name:"rhs"}),this.__outputs.push({compositionType:b.Scalar,componentType:I.Bool,name:"outValue"})}};h(av,"GreaterShaderNode");var qf=av;se();xe();tr();Ku();Ke();Ze();var vl=class vl extends ht{constructor(){super()}static getInstance(){return this.__instance||(this.__instance=new vl),this.__instance}get vertexShaderDefinitions(){return K.currentProcessApproach===Z.WebGPU?`
      fn outPosition(inPosition: vec4<f32>) {
        output.position = inPosition;
      }
      `:`
      void outPosition(in vec4 inPosition) {
        gl_Position = inPosition;
      }
      `}get vertexShaderBody(){return`

    `}get pixelShaderDefinitions(){return K.currentProcessApproach===Z.WebGPU?`
      fn outColor(inColor: vec4<f32>) {
        rt0 = inColor;
      }
      `:`
      void outColor(in vec4 inColor) {
        rt0 = inColor;
      }
      `}getPixelShaderBody(){return""}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}};h(vl,"EndShader"),f(vl,"__instance"),f(vl,"materialElement",Yl.PBRShading);var Oa=vl;dt();var sv=class sv extends ce{constructor(){super("outPosition",{commonPart:Oa.getInstance()}),this.__inputs.push(new Pt("value",b.Vec4,I.Float))}getSocketInput(){return this.__inputs[0]}};h(sv,"OutPositionShaderNode");var jf=sv;se();xe();dt();var lv=class lv extends ce{constructor(){super("outColor",{commonPart:Oa.getInstance()}),this.setShaderStage("Fragment"),this.__inputs.push(new Pt("value",b.Vec4,I.Float))}getSocketInput(){return this.__inputs[0]}};h(lv,"OutColorShaderNode");var Yf=lv;Cm();Ke();se();var V4={code:`void transform(in mat2 lfs, in vec2 rhs, out vec2 outValue) {
  outValue = lfs * rhs;
}
void transform(in mat3 lfs, in vec3 rhs, out vec3 outValue) {
  outValue = lfs * rhs;
}
void transform(in mat4 lfs, in vec4 rhs, out vec4 outValue) {
  outValue = lfs * rhs;
}
`,shaderStage:"fragment",isFragmentShader:!0};var z4={code:`fn transformMat2x2fVec2f(lfs: mat2x2<f32>, rhs: vec2<f32>, outValue: ptr<function, vec2<f32>>) {
  *outValue = lfs * rhs;
}
fn transformMat3x3fVec3f(lfs: mat3x3<f32>, rhs: vec3<f32>, outValue: ptr<function, vec3<f32>>) {
  *outValue = lfs * rhs;
}
fn transformMat4x4fVec4f(lfs: mat4x4<f32>, rhs: vec4<f32>, outValue: ptr<function, vec4<f32>>) {
  *outValue = lfs * rhs;
}
`,shaderStage:"fragment",isFragmentShader:!0};dt();Ze();Ke();var cv=class cv extends ce{constructor(n,t,o,r){super("transform",{codeGLSL:V4.code,codeWGSL:z4.code});let i=b.Unknown;n===b.Mat4&&o===b.Vec4?i=b.Vec4:n===b.Mat3&&o===b.Vec3?i=b.Vec3:n===b.Mat2&&o===b.Vec2&&(i=b.Vec2),this.__inputs.push({compositionType:n,componentType:t,name:"lhs"}),this.__inputs.push({compositionType:o,componentType:r,name:"rhs"}),this.__outputs.push({compositionType:i,componentType:t,name:"outValue"})}getShaderFunctionNameDerivative(){if(K.currentProcessApproach===Z.WebGPU){if(this.__inputs[0].compositionType===b.Mat2&&this.__inputs[1].compositionType===b.Vec2)return this.__shaderFunctionName+"Mat2x2fVec2f";if(this.__inputs[0].compositionType===b.Mat3&&this.__inputs[1].compositionType===b.Vec3)return this.__shaderFunctionName+"Mat3x3fVec3f";if(this.__inputs[0].compositionType===b.Mat4&&this.__inputs[1].compositionType===b.Vec4)return this.__shaderFunctionName+"Mat4x4fVec4f";throw new Error("Not implemented")}else return this.__shaderFunctionName}};h(cv,"TransformShaderNode");var gl=cv;se();xe();tr();var fv=class fv extends ht{constructor(t,o,r){super();f(this,"__functionName");f(this,"__valueInputs");f(this,"__valueOutputs");this.__functionName=t,this.__valueInputs=o,this.__valueOutputs=r}get vertexShaderDefinitions(){let t=`void ${this.__functionName}(
in bool context,
      `;for(let o=0;o<this.__valueInputs.length;o++){let r=this.__valueInputs[o],i=r.compositionType.getGlslStr(r.componentType);t+=`
        in ${i} value${o},`}for(let o=0;o<this.__valueOutputs.length;o++){let r=this.__valueOutputs[o],i=r.compositionType.getGlslStr(r.componentType);t+=`
        out ${i} outValue${o}`+(o===this.__valueOutputs.length-1?"":",")}t+=`) {
`;for(let o=0;o<this.__valueOutputs.length;o++)t+=`
      outValue${o} = value${o};
`;return t+="}",t}get pixelShaderDefinitions(){return this.vertexShaderDefinitions}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}};h(fv,"BlockBeginShader");var Kf=fv;dt();var mv=class mv extends ce{constructor(){super("blockBegin",{});f(this,"__valueInputs",[]);f(this,"__valueOutputs",[]);this.__shaderFunctionName+="_"+this.__shaderNodeUid,this.__commonPart=new Kf(this.__shaderFunctionName,this.__valueInputs,this.__valueOutputs),this.__inputs.push({compositionType:b.Scalar,componentType:I.Bool,name:"blockStart"})}addInputAndOutput(t,o){let r={compositionType:t,componentType:o,name:`value_${this.__valueInputs.length}`},i={compositionType:t,componentType:o,name:`outValue_${this.__valueOutputs.length}`};this.__inputs.push(r),this.__outputs.push(i),this.__valueInputs.push(r),this.__valueOutputs.push(i)}};h(mv,"BlockBeginShaderNode");var uv=mv;dt();tr();var _v=class _v extends ht{constructor(t,o,r){super();f(this,"__functionName");f(this,"__valueInputs");f(this,"__valueOutputs");this.__functionName=t,this.__valueInputs=o,this.__valueOutputs=r}get vertexShaderDefinitions(){let t=`void ${this.__functionName}(`;for(let o=0;o<this.__valueInputs.length;o++){let r=this.__valueInputs[o],i=r.compositionType.getGlslStr(r.componentType);t+=`
        in ${i} value${o},`}for(let o=0;o<this.__valueOutputs.length;o++){let r=this.__valueOutputs[o],i=r.compositionType.getGlslStr(r.componentType);t+=`
        out ${i} outValue${o}`+(o===this.__valueOutputs.length-1?"":",")}t+=`) {
`;for(let o=0;o<this.__valueOutputs.length;o++)t+=`
      outValue${o} = value${o};
`;return t+="}",t}get pixelShaderDefinitions(){return this.vertexShaderDefinitions}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}};h(_v,"BlockEndShader");var Zf=_v;var hv=class hv extends ce{constructor(){super("blockEnd",{}),this.__shaderFunctionName+="_"+this.__shaderNodeUid,this.__commonPart=new Zf(this.__shaderFunctionName,this.__inputs,this.__outputs)}addInputAndOutput(n,t){let o={compositionType:n,componentType:t,name:`value_${this.__inputs.length}`},r={compositionType:n,componentType:t,name:`outValue_${this.__outputs.length}`};this.__inputs.push(o),this.__outputs.push(r)}};h(hv,"BlockEndShaderNode");var dv=hv;se();xe();tr();var pv=class pv extends ht{constructor(){super()}get vertexShaderDefinitions(){return`
    `}get pixelShaderDefinitions(){return`
    `}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}};h(pv,"IfStatementShader");var Jf=pv;dt();var vv=class vv extends ce{constructor(){super("ifStatement",{commonPart:new Jf}),this.__inputs.push({compositionType:b.Scalar,componentType:I.Bool,name:"condition"}),this.__outputs.push({compositionType:b.Unknown,componentType:I.Unknown,name:"ifStart"})}};h(vv,"IfStatementShaderNode");var xv=vv;se();xe();dt();var G4={code:`bool wireframe(
  in vec4 existingFragColor,
  in vec4 wireframeColor,
  out vec4 outColor
) {
  vec3 wireframeInfo = get_wireframe(a_instanceInfo.x);

  // Wireframe
  float threshold = 0.001;
  float wireframeWidthInner = wireframeInfo.z;
  float wireframeWidthRelativeScale = 1.0;
  if (wireframeInfo.x > 0.5 && wireframeInfo.y < 0.5) {
    outColor.a = 0.0;
  }
  vec4 wireframeResult = existingFragColor;
  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);
  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);
  // if r0.a is 0.0, it is wireframe not on shaded
  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + existingFragColor.rgb * (1.0 - edgeRatioModified);
  wireframeResult.a = max(existingFragColor.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));

  if (wireframeInfo.x > 0.5) {
    outColor = wireframeResult;
    if (wireframeInfo.y < 0.5 && existingFragColor.a == 0.0) {
      discard;
    }
  }
}
`,shaderStage:"fragment",isFragmentShader:!0};var yv=class yv extends ce{constructor(){super("wireframe",{codeGLSL:G4.code}),this.__inputs.push({compositionType:b.Vec4,componentType:I.Float,name:"existingFragColor"}),this.__inputs.push({compositionType:b.Vec4,componentType:I.Float,name:"wireframeColor"}),this.__outputs.push({compositionType:b.Vec4,componentType:I.Float,name:"outColor"})}};h(yv,"WireframeMaterialNode");var gv=yv;xe();se();dt();var O4={code:`void splitVector(in vec4 xyzw, out vec3 outXYZ, out vec2 outXY, out vec2 outZW, out float outX, out float outY, out float outZ, out float outW) {
  outX = xyzw.x;
  outY = xyzw.y;
  outZ = xyzw.z;
  outW = xyzw.w;
  outXYZ = xyzw.xyz;
  outXY = xyzw.xy;
  outZW = xyzw.zw;
}

void splitVector(in vec3 xyz, out vec3 outXYZ, out vec2 outXY, out vec2 outZW, out float outX, out float outY, out float outZ, out float outW) {
  outX = xyz.x;
  outY = xyz.y;
  outZ = xyz.z;
  outW = 0.0;
  outXYZ = xyz;
  outXY = xyz.xy;
  outZW = vec2(xyz.z, 0.0);
}

void splitVector(in vec2 xy, out vec3 outXYZ, out vec2 outXY, out vec2 outZW, out float outX, out float outY, out float outZ, out float outW) {
  outX = xy.x;
  outY = xy.y;
  outZ = 0.0;
  outW = 0.0;
  outXYZ = vec3(xy, 0.0);
  outXY = xy;
  outZW = vec2(0.0);
}
`,shaderStage:"fragment",isFragmentShader:!0};var U4={code:`fn splitVectorXYZW(xyzw: vec4<f32>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>, outX: ptr<function, f32>, outY: ptr<function, f32>, outZ: ptr<function, f32>, outW: ptr<function, f32>) {
  *outX = xyzw.x;
  *outY = xyzw.y;
  *outZ = xyzw.z;
  *outW = xyzw.w;
  *outXYZ = xyzw.xyz;
  *outXY = xyzw.xy;
  *outZW = xyzw.zw;
}

fn splitVectorXYZ(xyz: vec3<f32>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>, outX: ptr<function, f32>, outY: ptr<function, f32>, outZ: ptr<function, f32>, outW: ptr<function, f32>) {
  *outX = xyz.x;
  *outY = xyz.y;
  *outZ = xyz.z;
  *outW = 0.0;
  *outXYZ = xyz;
  *outXY = xyz.xy;
  *outZW = vec2(xyz.z, 0.0);
}

fn splitVectorXY(xy: vec2<f32>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>, outX: ptr<function, f32>, outY: ptr<function, f32>, outZ: ptr<function, f32>, outW: ptr<function, f32>) {
  *outX = xy.x;
  *outY = xy.y;
  *outZ = 0.0;
  *outW = 0.0;
  *outXYZ = vec3(xy, 0.0);
  *outXY = xy;
  *outZW = vec2(0.0);
}
`,shaderStage:"fragment",isFragmentShader:!0};Ze();Ke();var bv=class bv extends ce{constructor(){super("splitVector",{codeGLSL:O4.code,codeWGSL:U4.code}),this.__inputs.push({compositionType:b.Vec4,componentType:I.Float,name:"xyzw"}),this.__inputs.push({compositionType:b.Vec3,componentType:I.Float,name:"xyz"}),this.__inputs.push({compositionType:b.Vec2,componentType:I.Float,name:"xy"}),this.__outputs.push({compositionType:b.Vec3,componentType:I.Float,name:"xyz"}),this.__outputs.push({compositionType:b.Vec2,componentType:I.Float,name:"xy"}),this.__outputs.push({compositionType:b.Vec2,componentType:I.Float,name:"zw"}),this.__outputs.push({compositionType:b.Scalar,componentType:I.Float,name:"x"}),this.__outputs.push({compositionType:b.Scalar,componentType:I.Float,name:"y"}),this.__outputs.push({compositionType:b.Scalar,componentType:I.Float,name:"z"}),this.__outputs.push({compositionType:b.Scalar,componentType:I.Float,name:"w"})}getShaderFunctionNameDerivative(){if(K.currentProcessApproach===Z.WebGPU){for(let n of this.inputConnections)if(n!=null){if(n.inputNameOfThis==="xyzw")return this.__shaderFunctionName+"XYZW";if(n.inputNameOfThis==="xyz")return this.__shaderFunctionName+"XYZ";if(n.inputNameOfThis==="xy")return this.__shaderFunctionName+"XY"}throw new Error("Not implemented")}else return this.__shaderFunctionName}makeCallStatement(n,t,o,r,i){let a="",s="";if(r[n].length>0&&i[n].length>0){let l=K.currentProcessApproach===Z.WebGPU?[`var dummyXYZ_${n}: vec3<f32>;`,`var dummyXY_${n}: vec2<f32>;`,`var dummyZW_${n}: vec2<f32>;`,`var dummyX_${n}: f32;`,`var dummyY_${n}: f32;`,`var dummyZ_${n}: f32;`,`var dummyW_${n}: f32;`]:[`vec3 dummyXYZ_${n};`,`vec2 dummyXY_${n};`,`vec2 dummyZW_${n};`,`float dummyX_${n};`,`float dummyY_${n};`,`float dummyZ_${n};`,`float dummyW_${n};`],c=[`dummyXYZ_${n}`,`dummyXY_${n}`,`dummyZW_${n}`,`dummyX_${n}`,`dummyY_${n}`,`dummyZ_${n}`,`dummyW_${n}`];for(let _=0;_<i[n].length;_++){let d=i[n][_];d.indexOf("xyz")>=0?(l[0]="",c[0]=d):d.indexOf("xy")>=0?(l[1]="",c[1]=d):d.indexOf("zw")>=0?(l[2]="",c[2]=d):d.indexOf("x")>=0?(l[3]="",c[3]=d):d.indexOf("y")>=0?(l[4]="",c[4]=d):d.indexOf("z")>=0?(l[5]="",c[5]=d):d.indexOf("w")>=0&&(l[6]="",c[6]=d)}if(K.currentProcessApproach===Z.WebGPU)for(let _=0;_<c.length;_++)c[_]="&"+c[_];s+=l.join(`
`),s+=`${o}(`;let u=r[n][0];s+=u,s+=", "+c.join(", "),s+=`);
`}return a+=s,a}};h(bv,"SplitVectorShaderNode");var $f=bv;xe();se();dt();var k4={code:`void mergeVectorXYZ_W(in vec3 xyz, in float w, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {
  outXYZW.x = xyz.x;
  outXYZW.y = xyz.y;
  outXYZW.z = xyz.z;
  outXYZW.w = w;
  outXYZ = xyz;
  outXY = xyz.xy;
  outZW = vec2(xyz.z, w);
}

void mergeVectorXY_ZW(in vec2 xy, in vec2 zw, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {
  outXYZW.x = xy.x;
  outXYZW.y = xy.y;
  outXYZW.z = zw.x;
  outXYZW.w = zw.y;
  outXYZ = vec3(xy, zw.x);
  outXY = xy;
  outZW = zw;
}

void mergeVectorXY_Z_W(in vec2 xy, in float z, in float w, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {
  outXYZW.x = xy.x;
  outXYZW.y = xy.y;
  outXYZW.z = z;
  outXYZW.w = w;
  outXYZ = vec3(xy, z);
  outXY = xy;
  outZW = vec2(z, w);
}

void mergeVectorZW_X_Y(in vec2 zw, in float x, in float y, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {
  outXYZW.x = x;
  outXYZW.y = y;
  outXYZW.z = zw.x;
  outXYZW.w = zw.y;
  outXYZ = vec3(x, y, zw.x);
  outXY = vec2(x, y);
  outZW = zw;
}

void mergeVectorX_Y_Z_W(in float x, in float y, in float z, in float w, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {
  outXYZW.x = x;
  outXYZW.y = y;
  outXYZW.z = z;
  outXYZW.w = w;
  outXYZ = vec3(x, y, z);
  outXY = vec2(x, y);
  outZW = vec2(z, w);
}
`,shaderStage:"fragment",isFragmentShader:!0};var W4={code:`fn mergeVectorXYZ_W(xyz: vec3<f32>, w: f32, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {
  *outXYZW = vec4<f32>(xyz, w);
  *outXYZ = xyz;
  *outXY = xyz.xy;
  *outZW = vec2f(xyz.z, w);
}

fn mergeVectorXY_ZW(xy: vec2<f32>, zw: vec2<f32>, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {
  *outXYZW = vec4<f32>(xy, zw);
  *outXYZ = vec3f(xy, zw.x);
  *outXY = xy;
  *outZW = zw;
}

fn mergeVectorXY_Z_W(xy: vec2<f32>, z: f32, w: f32, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {
  *outXYZW = vec4<f32>(xy.x, xy.y, z, w);
  *outXYZ = vec3f(xy, z);
  *outXY = xy;
  *outZW = vec2f(z, w);
}

fn mergeVectorZW_X_Y(zw: vec2<f32>, x: f32, y: f32, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {
  *outXYZW = vec4<f32>(x, y, zw.x, zw.y);
  *outXYZ = vec3f(x, y, zw.x);
  *outXY = vec2f(x, y);
  *outZW = zw;
}

fn mergeVectorX_Y_Z_W(x: f32, y: f32, z: f32, w: f32, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {
  *outXYZW = vec4<f32>(x, y, z, w);
  *outXYZ = vec3f(x, y, z);
  *outXY = vec2f(x, y);
  *outZW = vec2f(z, w);
}
`,shaderStage:"fragment",isFragmentShader:!0};Ze();Ke();var Av=class Av extends ce{constructor(){super("mergeVector",{codeGLSL:k4.code,codeWGSL:W4.code}),this.__inputs.push({compositionType:b.Vec3,componentType:I.Float,name:"xyz"}),this.__inputs.push({compositionType:b.Vec2,componentType:I.Float,name:"xy"}),this.__inputs.push({compositionType:b.Vec2,componentType:I.Float,name:"zw"}),this.__inputs.push({compositionType:b.Scalar,componentType:I.Float,name:"x"}),this.__inputs.push({compositionType:b.Scalar,componentType:I.Float,name:"y"}),this.__inputs.push({compositionType:b.Scalar,componentType:I.Float,name:"z"}),this.__inputs.push({compositionType:b.Scalar,componentType:I.Float,name:"w"}),this.__outputs.push({compositionType:b.Vec4,componentType:I.Float,name:"xyzw"}),this.__outputs.push({compositionType:b.Vec3,componentType:I.Float,name:"xyz"}),this.__outputs.push({compositionType:b.Vec2,componentType:I.Float,name:"xy"}),this.__outputs.push({compositionType:b.Vec2,componentType:I.Float,name:"zw"})}getShaderFunctionNameDerivative(){if(this.inputConnections[0]!=null&&this.inputConnections[6]!=null)return this.__shaderFunctionName+"XYZ_W";if(this.inputConnections[1]!=null&&this.inputConnections[2]!=null)return this.__shaderFunctionName+"XY_ZW";if(this.inputConnections[1]!=null&&this.inputConnections[5]!=null&&this.inputConnections[6]!=null)return this.__shaderFunctionName+"XY_Z_W";if(this.inputConnections[2]!=null&&this.inputConnections[3]!=null&&this.inputConnections[4]!=null)return this.__shaderFunctionName+"ZW_X_Y";if(this.inputConnections[3]!=null&&this.inputConnections[4]!=null&&this.inputConnections[5]!=null&&this.inputConnections[6]!=null)return this.__shaderFunctionName+"X_Y_Z_W";throw new Error("Not implemented")}makeCallStatement(n,t,o,r,i){let a="",s="";if(r[n].length>0&&i[n].length>0){let l=K.currentProcessApproach===Z.WebGPU?[`var dummyXYZW_${n}: vec4<f32>;`,`var dummyXYZ_${n}: vec3<f32>;`,`var dummyXY_${n}: vec2<f32>;`,`var dummyZW_${n}: vec2<f32>;`]:[`vec4 dummyXYZW_${n};`,`vec3 dummyXYZ_${n};`,`vec2 dummyXY_${n};`,`vec2 dummyZW_${n};`],c=[`dummyXYZW_${n}`,`dummyXYZ_${n}`,`dummyXY_${n}`,`dummyZW_${n}`];for(let u=0;u<i[n].length;u++){let _=i[n][u];_.indexOf("xyzw")>=0?(l[0]="",c[0]=_):_.indexOf("xyz")>=0?(l[1]="",c[1]=_):_.indexOf("xy")>=0?(l[2]="",c[2]=_):_.indexOf("zw")>=0&&(l[3]="",c[3]=_)}if(K.currentProcessApproach===Z.WebGPU)for(let u=0;u<c.length;u++)c[u]="&"+c[u];s+=l.join(`
`),s+=`${o}(`;for(let u=0;u<r[n].length;u++){u!==0&&(s+=", ");let _=r[n][u];s+=_}s+=", "+c.join(", "),s+=`);
`}return a+=s,a}};h(Av,"MergeVectorShaderNode");var eu=Av;dt();se();var Q4={code:`void _sin(in float value, out float outValue) {
  outValue = sin(value);
}
void _sin(in vec2 value, out vec2 outValue) {
  outValue = sin(value);
}
void _sin(in vec3 value, out vec3 outValue) {
  outValue = sin(value);
}
void _sin(in vec4 value, out vec4 outValue) {
  outValue = sin(value);
}
`,shaderStage:"fragment",isFragmentShader:!0};var X4={code:`fn _sinF32(value: f32, outValue: ptr<function, f32>) {
  *outValue = sin(value);
}
fn _sinVec2f(value: vec2<f32>, outValue: ptr<function, vec2<f32>>) {
  *outValue = sin(value);
}
fn _sinVec3f(value: vec3<f32>, outValue: ptr<function, vec3<f32>>) {
  *outValue = sin(value);
}
fn _sinVec4f(value: vec4<f32>, outValue: ptr<function, vec4<f32>>) {
  *outValue = sin(value);
}
`,shaderStage:"fragment",isFragmentShader:!0};Ke();Ze();var Iv=class Iv extends ce{constructor(n,t){super("_sin",{codeGLSL:Q4.code,codeWGSL:X4.code}),this.__inputs.push(new Pt("value",n,t)),this.__outputs.push(new Pt("outValue",n,t))}getSocketInputValue(){return this.__inputs[0]}getSocketOutput(){return this.__outputs[0]}getShaderFunctionNameDerivative(){if(K.currentProcessApproach===Z.WebGPU){if(this.__inputs[0].compositionType===b.Scalar)return this.__shaderFunctionName+"F32";if(this.__inputs[0].compositionType===b.Vec2)return this.__shaderFunctionName+"Vec2f";if(this.__inputs[0].compositionType===b.Vec3)return this.__shaderFunctionName+"Vec3f";if(this.__inputs[0].compositionType===b.Vec4)return this.__shaderFunctionName+"Vec4f";throw new Error("Not implemented")}else return this.__shaderFunctionName}};h(Iv,"SinShaderNode");var Ua=Iv;dt();se();var H4={code:`void _step(in float value, in float edge, out float outValue) {
  outValue = step(edge, value);
}
void _step(in vec2 value, in vec2 edge, out vec2 outValue) {
  outValue = step(edge, value);
}
void _step(in vec3 value, in vec3 edge, out vec3 outValue) {
  outValue = step(edge, value);
}
void _step(in vec4 value, in vec4 edge, out vec4 outValue) {
  outValue = step(edge, value);
}
`,shaderStage:"fragment",isFragmentShader:!0};var q4={code:`fn _stepF32(value: f32, edge: f32, outValue: ptr<function, f32>) {
  *outValue = step(edge, value);
}
fn _stepVec2f(value: vec2<f32>, edge: vec2<f32>, outValue: ptr<function, vec2<f32>>) {
  *outValue = step(edge, value);
}
fn _stepVec3f(value: vec3<f32>, edge: vec3<f32>, outValue: ptr<function, vec3<f32>>) {
  *outValue = step(edge, value);
}
fn _stepVec4f(value: vec4<f32>, edge: vec4<f32>, outValue: ptr<function, vec4<f32>>) {
  *outValue = step(edge, value);
}
`,shaderStage:"fragment",isFragmentShader:!0};Ke();Ze();var Sv=class Sv extends ce{constructor(n,t){super("_step",{codeGLSL:H4.code,codeWGSL:q4.code}),this.__inputs.push(new Pt("value",n,t)),this.__inputs.push(new Pt("edge",n,t)),this.__outputs.push(new Pt("outValue",n,t))}getSocketInputValue(){return this.__inputs[0]}getSocketOutput(){return this.__outputs[0]}getShaderFunctionNameDerivative(){if(K.currentProcessApproach===Z.WebGPU){if(this.__inputs[0].compositionType===b.Scalar)return this.__shaderFunctionName+"F32";if(this.__inputs[0].compositionType===b.Vec2)return this.__shaderFunctionName+"Vec2f";if(this.__inputs[0].compositionType===b.Vec3)return this.__shaderFunctionName+"Vec3f";if(this.__inputs[0].compositionType===b.Vec4)return this.__shaderFunctionName+"Vec4f";throw new Error("Not implemented")}else return this.__shaderFunctionName}};h(Sv,"StepShaderNode");var ka=Sv;se();xe();var j4={code:`
void time(out float outValue) {
  outValue = get_time(0.0, 0);
}
`,shaderStage:"fragment",isFragmentShader:!0};var Y4={code:`fn time(outValue: ptr<function, f32>) {
  *outValue = get_time(0, 0);
}
`,shaderStage:"fragment",isFragmentShader:!0};dt();var Tv=class Tv extends ce{constructor(){super("time",{codeGLSL:j4.code,codeWGSL:Y4.code}),this.__outputs.push({compositionType:b.Scalar,componentType:I.Float,name:"outValue"})}};h(Tv,"TimeShaderNode");var Qm=Tv;dt();se();var K4={code:`void _smoothstep(in float value, in float edge0, in float edge1, out float outValue) {
  outValue = smoothstep(edge0, edge1, value);
}
void _smoothstep(in vec2 value, in vec2 edge0, in vec2 edge1, out vec2 outValue) {
  outValue = smoothstep(edge0, edge1, value);
}
void _smoothstep(in vec3 value, in vec3 edge0, in vec3 edge1, out vec3 outValue) {
  outValue = smoothstep(edge0, edge1, value);
}
void _smoothstep(in vec4 value, in vec4 edge0, in vec4 edge1, out vec4 outValue) {
  outValue = smoothstep(edge0, edge1, value);
}
`,shaderStage:"fragment",isFragmentShader:!0};var Z4={code:`fn _smoothstepF32(value: f32, edge0: f32, edge1: f32, outValue: ptr<function, f32>) {
  *outValue = smoothstep(edge0, edge1, value);
}
fn _smoothstepVec2f(value: vec2<f32>, edge0: vec2<f32>, edge1: vec2<f32>, outValue: ptr<function, vec2<f32>>) {
  *outValue = smoothstep(edge0, edge1, value);
}
fn _smoothstepVec3f(value: vec3<f32>, edge0: vec3<f32>, edge1: vec3<f32>, outValue: ptr<function, vec3<f32>>) {
  *outValue = smoothstep(edge0, edge1, value);
}
fn _smoothstepVec4f(value: vec4<f32>, edge0: vec4<f32>, edge1: vec4<f32>, outValue: ptr<function, vec4<f32>>) {
  *outValue = smoothstep(edge0, edge1, value);
}
`,shaderStage:"fragment",isFragmentShader:!0};Ke();Ze();var Ev=class Ev extends ce{constructor(n,t){super("_smoothstep",{codeGLSL:K4.code,codeWGSL:Z4.code}),this.__inputs.push(new Pt("value",n,t)),this.__inputs.push(new Pt("edge0",n,t)),this.__inputs.push(new Pt("edge1",n,t)),this.__outputs.push(new Pt("outValue",n,t))}getSocketInputValue(){return this.__inputs[0]}getSocketOutput(){return this.__outputs[0]}getShaderFunctionNameDerivative(){if(K.currentProcessApproach===Z.WebGPU){if(this.__inputs[0].compositionType===b.Scalar)return this.__shaderFunctionName+"F32";if(this.__inputs[0].compositionType===b.Vec2)return this.__shaderFunctionName+"Vec2f";if(this.__inputs[0].compositionType===b.Vec3)return this.__shaderFunctionName+"Vec3f";if(this.__inputs[0].compositionType===b.Vec4)return this.__shaderFunctionName+"Vec4f";throw new Error("Not implemented")}else return this.__shaderFunctionName}};h(Ev,"SmoothStepShaderNode");var Wa=Ev;me();var hi=class hi{static createVertexShaderCode(n,t,o=!0){let r=n.concat(),i=this.__sortTopologically(r),a="",s=i.concat(t);o&&(a+=ht.getVertexPrerequisites(s));let l="";l+=hi.__getFunctionDefinition(i.concat(t.filter(u=>u.getShaderStage()!=="Fragment")),D.VertexShader);try{l+=hi.__constructShaderWithNodes(s,!0,o)}catch(u){N.error(u);return}return a+l}static createPixelShaderCode(n,t=!0){let o=n.concat(),r=this.__sortTopologically(o),i="";t&&(i+=ht.getPixelPrerequisites(r));let a="";a+=hi.__getFunctionDefinition(r.filter(l=>l.getShaderStage()!=="Vertex"),D.PixelShader);try{a+=hi.__constructShaderWithNodes(r,!1,t)}catch(l){N.error(l);return}return i+a}static __validateShaderNodes(n){let t=[];for(let o=0;o<n.length;o++){let r=n[o];for(let i=0;i<r.inputConnections.length;i++)if(r.inputConnections[i]==null)return!1}return!0}static __sortTopologically(n){let t=[],o=[],r=[];for(let a=0;a<n.length;a++){let s=n[a],l=0;for(let c of s.inputConnections)c!=null&&l++;o[a]=l}let i=[];for(let a=0;a<n.length;a++){let s=n[a];for(let l of s.inputConnections){if(l==null)continue;let c=ce.getShaderNodeByUid(l.shaderNodeUid),u=n.indexOf(c);i[u]==null&&(i[u]=[]),i[u].push(s)}}for(let a=0;a<n.length;a++)i[a]==null&&(i[a]=[]);for(let a=0;a<n.length;a++)o[a]===0&&r.push(n[a]);for(;r.length>0;){let a=r.shift();t.push(a);let s=n.indexOf(a);for(let l of i[s])o[n.indexOf(l)]--,o[n.indexOf(l)]===0&&r.push(l)}return t.length!=n.length&&N.error("graph is cyclic"),t}static __getFunctionDefinition(n,t){let o="",r=[];for(let i=0;i<n.length;i++){let a=n[i];r.indexOf(a.shaderFunctionName)===-1&&(o+=a.getShaderCode(t),r.push(a.shaderFunctionName))}return o}static __constructShaderWithNodes(n,t,o){let r="";if(K.currentProcessApproach!==Z.WebGPU)for(let s=0;s<n.length;s++){let l=n[s];for(let c=0;c<l.inputConnections.length;c++){let u=l.inputConnections[c];if(u==null)continue;let _=l.getInputs()[c],d=ce.getShaderNodeByUid(u.shaderNodeUid);if(d.getShaderStage()==="Vertex"&&l.getShaderStage()==="Fragment"){let p=_.compositionType.getGlslStr(_.componentType);r+=`${t?"out":"in"} ${p} v_${d.shaderFunctionName}_${d.shaderNodeUid};
`}}}r+=ht.getMainBegin(t),o&&(r+=ht.getMainPrerequisites());let i=[],a=[];{let s=new Set,l=new Set,c=new Map;for(let u=1;u<n.length;u++){let _=n[u];i[u]==null&&(i[u]=[]),u-1>=0&&a[u-1]==null&&(a[u-1]=[]);let d=_.inputConnections;for(let p=0;p<d.length;p++){let x=d[p];if(x==null)continue;let v=ce._shaderNodes[x.shaderNodeUid],y=v.getOutput(x.outputNameOfPrev),g=_.getInput(x.inputNameOfThis),E=`${y.name}_${x.shaderNodeUid}_to_${_.shaderNodeUid}`;if(!s.has(`${v.shaderNodeUid}_${x.outputNameOfPrev}`)){let T=ht.getAssignmentStatement(E,g);t||v.getShaderStage()==="Vertex"&&_.getShaderStage()==="Fragment"&&(T=ht.getAssignmentVaryingStatementInPixelShader(E,g,v)),r+=T}let w=c.get(v.shaderNodeUid);i[u].push(w||E),s.add(`${x.shaderNodeUid}_${x.outputNameOfPrev}`)}for(let p=u;p<n.length;p++){let x=n[p],v=n[u-1],y=x.inputConnections;for(let g=0;g<y.length;g++){let E=y[g];if(E==null||(v==null?void 0:v.shaderNodeUid)!==E.shaderNodeUid)continue;let w=ce._shaderNodes[E.shaderNodeUid];if(!l.has(`${w.shaderNodeUid}_${E.outputNameOfPrev}`)){let R=`${w.getOutput(E.outputNameOfPrev).name}_${E.shaderNodeUid}_to_${x.shaderNodeUid}`;u-1>=0&&a[u-1].push(R),c.set(E.shaderNodeUid,R)}l.add(`${E.shaderNodeUid}_${E.outputNameOfPrev}`)}}}}for(let s=0;s<n.length;s++){let l=n[s],c=l.getShaderFunctionNameDerivative();i[s]==null&&(i[s]=[]),a[s]==null&&(a[s]=[]),!(t&&l.getShaderStage()==="Fragment")&&(!t&&l.getShaderStage()==="Vertex"||(r+=l.makeCallStatement(s,l,c,i,a)))}if(t)for(let s=0;s<n.length;s++){let l=n[s],c=i[s].concat(a[s]);for(let u=0;u<l.inputConnections.length;u++){let _=l.inputConnections[u];if(_==null)continue;let d=ce.getShaderNodeByUid(_.shaderNodeUid);d.getShaderStage()==="Vertex"&&l.getShaderStage()==="Fragment"&&(r+=ht.getAssignmentVaryingStatementInVertexShader(d,c,u))}}return r+=ht.getMainEnd(t),r}static generateShaderCodeFromJson(n){let t=Object.values(bH(n)),o=this.__sortTopologically(t);gH(o);let r=yH(o,"outColor"),i=J4(o,["outPosition"]),a=J4(o,["outColor"]);if(i.length===0||a.length===0)return;let s=hi.createVertexShaderCode(i,r),l=hi.createPixelShaderCode(a);if(!(s==null||l==null))return{vertexShader:s,pixelShader:l}}};h(hi,"ShaderGraphResolver");var Cv=hi;function vH(m,n){let t;for(let i=0;i<m.length;i++){let a=m[i];if(a.shaderFunctionName.toLowerCase().includes(n.toLowerCase())){t=a;break}}if(t==null)return[];let o=[t];function r(i){for(let a=0;a<i.inputConnections.length;a++){let s=i.inputConnections[a];if(s!=null){let l=ce.getShaderNodeByUid(s.shaderNodeUid);l!=null&&(o.push(l),r(l))}}}return h(r,"traverseNodes"),r(t),o}h(vH,"filterNodesInner");function J4(m,n){let t=[];for(let o=0;o<n.length;o++){let r=n[o],i=vH(m,r);t=t.concat(i)}return t=[...new Set(t)],t}h(J4,"filterNodes");function gH(m){for(let n=0;n<m.length;n++){let t=m[n];for(let o of t.inputConnections){if(o==null)continue;let r=ce.getShaderNodeByUid(o.shaderNodeUid);r.getShaderStage()==="Vertex"&&t.getShaderStage()==="Neutral"?t.setShaderStage("Vertex"):r.getShaderStage()==="Fragment"&&t.setShaderStage("Fragment")}}}h(gH,"resolveShaderStage");function yH(m,n){let t;for(let a=0;a<m.length;a++){let s=m[a];if(s.shaderFunctionName.toLowerCase().includes(n.toLowerCase())){t=s;break}}if(t==null)return[];let o=[];function r(a){for(let s=0;s<a.inputConnections.length;s++){let l=a.inputConnections[s];if(l==null)continue;let c=ce.getShaderNodeByUid(l.shaderNodeUid);o.push(c),r(c)}}h(r,"traverseNodesAll");function i(a){for(let s=0;s<a.inputConnections.length;s++){let l=a.inputConnections[s];if(l==null)continue;let c=ce.getShaderNodeByUid(l.shaderNodeUid);if(c!=null&&c.getShaderStage()==="Vertex"&&a.getShaderStage()==="Fragment"){o.push(c),a.getShaderStage()==="Fragment"&&o.unshift(a),r(c);break}i(c)}}return h(i,"traverseNodes"),i(t),o=[...new Set(o)],o.reverse()}h(yH,"filterNodesForVarying");function bH(m){let n={},t={};for(let o of m.nodes)switch(t[o.id]=o,o.name){case"ConstantScalar":{let r=new Df(I.Float);r.setDefaultInputValue(te.fromCopyNumber(o.controls.in1.value)),n[o.id]=r;break}case"ConstantVector2":{let r=new Bf(I.Float);r.setDefaultInputValue(Ee.fromCopy2(o.controls.in1.value,o.controls.in2.value)),n[o.id]=r;break}case"ConstantVector3":{let r=new Ff(I.Float);r.setDefaultInputValue(S.fromCopy3(o.controls.in1.value,o.controls.in2.value,o.controls.in3.value)),n[o.id]=r;break}case"ConstantVector4":{let r=new Lf(I.Float);r.setDefaultInputValue(q.fromCopy4(o.controls.in1.value,o.controls.in2.value,o.controls.in3.value,o.controls.in4.value)),n[o.id]=r;break}case"UniformVector4":{let r=new zf(b.Vec4,I.Float);r.setDefaultInputValue("value",q.fromCopyArray4([o.controls.initialX.value,o.controls.initialY.value,o.controls.initialZ.value,o.controls.initialW.value])),r.setUniformDataName(o.controls.name.value),n[o.id]=r;break}case"Time":{let r=new Qm;n[o.id]=r;break}case"Add":{let r=o.outputs.out1.socket.name,i;if(r==="Scalar")i=new Ui(b.Scalar,I.Float);else if(r==="Vector2")i=new Ui(b.Vec2,I.Float);else if(r==="Vector3")i=new Ui(b.Vec3,I.Float);else if(r==="Vector4")i=new Ui(b.Vec4,I.Float);else{N.error("Add node: Unknown socket name: "+r);break}i.setShaderStage(o.controls.shaderStage.value),n[o.id]=i;break}case"Sin":{let r=o.outputs.out1.socket.name,i;if(r==="Scalar")i=new Ua(b.Scalar,I.Float);else if(r==="Vector2")i=new Ua(b.Vec2,I.Float);else if(r==="Vector3")i=new Ua(b.Vec3,I.Float);else if(r==="Vector4")i=new Ua(b.Vec4,I.Float);else{N.error("Sin node: Unknown socket name: "+r);break}i.setShaderStage(o.controls.shaderStage.value),n[o.id]=i;break}case"Step":{let r=o.outputs.out1.socket.name,i;if(r==="Scalar")i=new ka(b.Scalar,I.Float);else if(r==="Vector2")i=new ka(b.Vec2,I.Float);else if(r==="Vector3")i=new ka(b.Vec3,I.Float);else if(r==="Vector4")i=new ka(b.Vec4,I.Float);else{N.error("Add node: Unknown socket name: "+r);break}i.setShaderStage(o.controls.shaderStage.value),n[o.id]=i;break}case"SmoothStep":{let r=o.outputs.out1.socket.name,i;if(r==="Scalar")i=new Wa(b.Scalar,I.Float);else if(r==="Vector2")i=new Wa(b.Vec2,I.Float);else if(r==="Vector3")i=new Wa(b.Vec3,I.Float);else if(r==="Vector4")i=new Wa(b.Vec4,I.Float);else{N.error("Add node: Unknown socket name: "+r);break}i.setShaderStage(o.controls.shaderStage.value),n[o.id]=i;break}case"Normalize":{let r=o.outputs.out1.socket.name,i;if(r==="Vector2")i=new za(b.Vec2,I.Float);else if(r==="Vector3")i=new za(b.Vec3,I.Float);else if(r==="Vector4")i=new za(b.Vec4,I.Float);else{N.error("Normalize node: Unknown socket name: "+r);break}i.setShaderStage(o.controls.shaderStage.value),n[o.id]=i;break}case"Dot":{let r=o.inputs.in1.socket.name,i;if(r==="Vector2")i=new Ga(b.Vec2,I.Float);else if(r==="Vector3")i=new Ga(b.Vec3,I.Float);else if(r==="Vector4")i=new Ga(b.Vec4,I.Float);else{N.error("Dot node: Unknown socket name: "+r);break}i.setShaderStage(o.controls.shaderStage.value),n[o.id]=i;break}case"Multiply":{let r=o.outputs.out1.socket.name,i;if(r==="Scalar")i=new Mr(b.Scalar,I.Float);else if(r==="Vector2")i=new Mr(b.Vec2,I.Float);else if(r==="Vector3")i=new Mr(b.Vec3,I.Float);else if(r==="Vector4")i=new Mr(b.Vec4,I.Float);else if(r==="Matrix2")i=new Mr(b.Mat2,I.Float);else if(r==="Matrix3")i=new Mr(b.Mat3,I.Float);else if(r==="Matrix4")i=new Mr(b.Mat4,I.Float);else{N.error("Multiply node: Unknown socket name: "+r);break}i.setShaderStage(o.controls.shaderStage.value),n[o.id]=i;break}case"Transform":{let r=o.outputs.out1.socket.name,i;if(r==="Vector2")i=new gl(b.Mat2,I.Float,b.Vec2,I.Float);else if(r==="Vector3")i=new gl(b.Mat3,I.Float,b.Vec3,I.Float);else if(r==="Vector4")i=new gl(b.Mat4,I.Float,b.Vec4,I.Float);else{N.error("Transform node: Unknown socket name: "+r);break}i.setShaderStage(o.controls.shaderStage.value),n[o.id]=i;break}case"SplitVector":{let r=new $f;r.setShaderStage(o.controls.shaderStage.value),n[o.id]=r;break}case"MergeVector":{let r=new eu;r.setShaderStage(o.controls.shaderStage.value),n[o.id]=r;break}case"AttributeColor":{let r=new Gf;n[o.id]=r;break}case"AttributeNormal":{let r=new Of;n[o.id]=r;break}case"AttributePosition":{let r=new Uf;n[o.id]=r;break}case"AttributeTexcoord":{let r=new kf;n[o.id]=r;break}case"WorldMatrix":{let r=new Wf;n[o.id]=r;break}case"ViewMatrix":{let r=new Qf;n[o.id]=r;break}case"ProjectionMatrix":{let r=new Xf;n[o.id]=r;break}case"NormalMatrix":{let r=new Hf;n[o.id]=r;break}case"Greater":{let r=new qf(b.Scalar,I.Float);n[o.id]=r;break}case"OutPosition":{let r=new jf;n[o.id]=r;break}case"OutColor":{let r=new Yf;n[o.id]=r;break}}for(let o=0;o<m.connections.length;o++){let r=m.connections[o],i=n[r.from.id],a=n[r.to.id];if(i==null||a==null){N.error("inputNodeInstance or outputNodeInstance is null");continue}let s=0;for(let _ in t[r.to.id].inputs){if(_===r.to.portName)break;s++}let l=0;for(let _ in t[r.from.id].outputs){if(_===r.from.portName)break;l++}let c=i.getOutputs()[l],u=a.getInputs()[s];a.addInputConnection(i,c,u)}return n}h(bH,"constructNodes");ym();mo();rp();ep();jh();np();Zh();tp();$h();lp();ip();Yh();op();ap();Or();ad();Lu();ld();yr();Kc();Vo();It();zl();ge();Ci();mm();kr();_r();ir();ef();zn();Qn();un();Pn();ft();pn();var Rv=class Rv extends nt{constructor(){super();f(this,"__width",0);f(this,"__height",0);f(this,"__isShadow",!1);f(this,"__isBloom",!1);f(this,"__isSimple",!1);f(this,"__shadowMapSize",1024);f(this,"__oFrame",new be);f(this,"__oFrameBufferMultiView",new be);f(this,"__oFrameBufferMultiViewBlit",new be);f(this,"__oFrameBufferMultiViewBlitBackBuffer",new be);f(this,"__oFrameBufferMsaa",new be);f(this,"__oFrameBufferResolve",new be);f(this,"__oFrameBufferResolveForReference",new be);f(this,"__oInitialExpression",new be);f(this,"__expressions",[]);f(this,"__oGenerateMipmapsExpression",new be);f(this,"__oMultiViewBlitBackBufferExpression",new be);f(this,"__oMultiViewBlitExpression",new be);f(this,"__oBloomExpression",new be);f(this,"__oToneMappingExpression",new be);f(this,"__oToneMappingMaterial",new be);f(this,"__transparentOnlyExpressions",[]);f(this,"__oWebXRSystem",new be);f(this,"__oDrawFunc",new be);f(this,"__oDiffuseCubeTexture",new be);f(this,"__oSpecularCubeTexture",new be);f(this,"__oSheenCubeTexture",new be);f(this,"__oSamplerForBackBuffer",new be);f(this,"__toneMappingType",oi.GT_ToneMap);f(this,"__bloomHelper",new yf);f(this,"__oShadowSystem",new be);f(this,"__shadowExpressions",[])}__destroyResources(){this.__oFrameBufferMultiView.has()&&(this.__oFrameBufferMultiView.get().destroy3DAPIResources(),this.__oFrameBufferMultiView=new be),this.__oFrameBufferMultiViewBlit.has()&&(this.__oFrameBufferMultiViewBlit.get().destroy3DAPIResources(),this.__oFrameBufferMultiViewBlit=new be),this.__oFrameBufferMsaa.has()&&(this.__oFrameBufferMsaa.get().destroy3DAPIResources(),this.__oFrameBufferMsaa=new be),this.__oFrameBufferResolve.has()&&(this.__oFrameBufferResolve.get().destroy3DAPIResources(),this.__oFrameBufferResolve=new be),this.__oFrameBufferResolveForReference.has()&&(this.__oFrameBufferResolveForReference.get().destroy3DAPIResources(),this.__oFrameBufferResolveForReference=new be),this.__bloomHelper.destroy3DAPIResources(),this.__oFrame=new be,this.__oGenerateMipmapsExpression=new be,this.__oMultiViewBlitExpression=new be,this.__oBloomExpression=new be,this.__oToneMappingExpression=new be}async setup(t,o,{isShadow:r=!1,isBloom:i=!1,shadowMapSize:a=1024,isSimple:s=!1}={}){if(this.__width=t,this.__height=o,this.__isBloom=i,this.__isShadow=r,this.__isSimple=s,this.__shadowMapSize=a,this.__oFrame.has())return new Ue({message:"Already setup",error:void 0});let l=new lt(new ha);if(this.__oFrame=l,!this.__isSimple){let _=new lt(new Ge({wrapS:U.Repeat,wrapT:U.Repeat,minFilter:U.LinearMipmapLinear,magFilter:U.Linear}));_.get().create(),this.__oSamplerForBackBuffer=_,this.__createRenderTargets(t,o),r&&!this.__isSimple&&(this.__oShadowSystem=new lt(new Tf(a))),this.__oFrameBufferResolveForReference.has()&&(this.__oGenerateMipmapsExpression=this.__setupGenerateMipmapsExpression(this.__oFrameBufferResolveForReference.get())),this.__oFrameBufferMultiView.has()&&(this.__oMultiViewBlitBackBufferExpression=this.__setupMultiViewBlitBackBufferExpression(this.__oFrameBufferMultiView.get()),this.__oMultiViewBlitExpression=this.__setupMultiViewBlitExpression(this.__oFrameBufferMultiView.get()));let d=this.__getMainFrameBufferResolve().unwrapForce().getColorAttachedRenderTargetTexture(0);if(i&&!this.__isSimple){let v=this.__getMainFrameBufferResolve().unwrapForce().getColorAttachedRenderTargetTexture(0),{bloomExpression:y,bloomedRenderTarget:g}=this.__bloomHelper.createBloomExpression({textureToBloom:v,parameters:{}});this.__oBloomExpression=new lt(y),d=g}let p=this.__setupToneMappingExpression(d);this.__oToneMappingExpression=new lt(p)}let c=this.__setupInitialExpression();this.__oInitialExpression=new lt(c);let u=await Pe.getInstance().getModule("xr");return A.exist(u)&&(this.__oWebXRSystem=new lt(u.WebXRSystem.getInstance())),this.__expressions.length>0&&this.setExpressions(this.__expressions),new je}__getMainFrameBufferBackBuffer(){return this.__oFrameBufferMultiView.has()?this.__oFrameBufferMultiViewBlitBackBuffer:this.__oFrameBufferResolveForReference}__getMainFrameBufferResolve(){return this.__oFrameBufferMultiView.has()?this.__oFrameBufferMultiViewBlit:this.__oFrameBufferResolve}__getMainFrameBuffer(){return this.__oFrameBufferMultiView.has()?this.__oFrameBufferMultiView:this.__oFrameBufferMsaa}setExpressions(t,o={isTransmission:!0}){let r=t.map(i=>i.clone());if(this.__setExpressionsInner(t,{isTransmission:o.isTransmission}),o.isTransmission&&this.__setTransparentExpressionsForTransmission(r),this.__oShadowSystem.has()){let i=this.__expressions.flatMap(a=>a.renderPasses.flatMap(s=>s.entities));this.__shadowExpressions=this.__oShadowSystem.get().getExpressions(i)}}startRenderLoop(t){return this.__oFrame.doesNotHave()?new Ue({message:"not initialized.",error:void 0}):(this.__oDrawFunc=new lt(t),po.startRenderLoop(()=>{if(this.__setExpressions(),this.__oShadowSystem.has()){let o=this.__expressions.flatMap(r=>r.renderPasses.flatMap(i=>i.entities));this.__oShadowSystem.get().isLightChanged()&&(this.__shadowExpressions=this.__oShadowSystem.get().getExpressions(o)),this.__oShadowSystem.get().setDepthBiasPV(o)}t(this.__oFrame.unwrapForce())}),new je)}draw(){this.__oDrawFunc.unwrapForce()(this.__oFrame.unwrapForce())}resize(t,o){if(this.__oFrame.doesNotHave())return new Ue({message:"not initialized.",error:void 0});let r=this.__oWebXRSystem.unwrapOrUndefined();return A.exist(r)&&r.isWebXRMode&&(t=r.getCanvasWidthForVr(),o=r.getCanvasHeightForVr()),po.resizeCanvas(t,o),this.__destroyResources(),this.setup(t,o,{isShadow:this.__isShadow,isBloom:this.__isBloom,shadowMapSize:this.__shadowMapSize,isSimple:this.__isSimple}),new je}async setIBLTextures(t,o,r){this.__oDiffuseCubeTexture=new lt(t),this.__oSpecularCubeTexture=new lt(o),A.exist(r)&&(this.__oSheenCubeTexture=new lt(r)),await this.__setIblInner(),await this.__setIblInnerForTransparentOnly()}getInitialExpression(){return this.__oInitialExpression.unwrapOrUndefined()}getToneMappingExpression(){return this.__oToneMappingExpression.unwrapOrUndefined()}setDiffuseIBLContribution(t){for(let o of this.__expressions)for(let r of o.renderPasses)for(let i of r.entities){let a=i.tryToGetMeshRenderer();A.exist(a)&&(a.diffuseCubeMapContribution=t)}for(let o of this.__transparentOnlyExpressions)for(let r of o.renderPasses)for(let i of r.entities){let a=i.tryToGetMeshRenderer();A.exist(a)&&(a.diffuseCubeMapContribution=t)}}setSpecularIBLContribution(t){for(let o of this.__expressions)for(let r of o.renderPasses)for(let i of r.entities){let a=i.tryToGetMeshRenderer();A.exist(a)&&(a.specularCubeMapContribution=t)}for(let o of this.__transparentOnlyExpressions)for(let r of o.renderPasses)for(let i of r.entities){let a=i.tryToGetMeshRenderer();A.exist(a)&&(a.specularCubeMapContribution=t)}}setIBLRotation(t){for(let o of this.__expressions)for(let r of o.renderPasses)for(let i of r.entities){let a=i.tryToGetMeshRenderer();A.exist(a)&&(a.rotationOfCubeMap=t)}}async __setExpressionsInner(t,o={isTransmission:!0}){for(let r of t)for(let i of r.renderPasses)if(i.setToRenderOpaquePrimitives(!0),i.setToRenderBlendWithZWritePrimitives(!0),i.setToRenderBlendWithoutZWritePrimitives(!0),o.isTransmission?i.setToRenderTranslucentPrimitives(!1):i.setToRenderTranslucentPrimitives(!0),i.toClearDepthBuffer=!1,!this.__isSimple){let a=this.__getMainFrameBuffer();a.has()&&(i.setFramebuffer(a.get()),this.__oFrameBufferMsaa.has()&&(i.setResolveFramebuffer(this.__oFrameBufferResolve.unwrapForce()),i.setResolveFramebuffer2(this.__oFrameBufferResolveForReference.unwrapForce())))}this.__expressions=t,await this.__setIblInner()}__setTransparentExpressionsForTransmission(t){for(let o of t){o.tryToSetUniqueName("modelTransparentForTransmission",!0);for(let r of o.renderPasses)if(r.setToRenderOpaquePrimitives(!1),r.setToRenderTranslucentPrimitives(!0),r.setToRenderBlendWithZWritePrimitives(!1),r.setToRenderBlendWithoutZWritePrimitives(!1),r.toClearDepthBuffer=!1,!this.__isSimple){r.setFramebuffer(this.__getMainFrameBuffer().unwrapForce()),this.__oFrameBufferResolve.has()&&r.setResolveFramebuffer(this.__oFrameBufferResolve.unwrapForce());for(let i of r.entities){let a=i.tryToGetMesh();if(A.exist(a)){let s=a.mesh;if(A.exist(s))for(let l=0;l<s.getPrimitiveNumber();l++)s.getPrimitiveAt(l).material.setTextureParameter("backBufferTexture",this.__getMainFrameBufferBackBuffer().unwrapForce().getColorAttachedRenderTargetTexture(0),this.__oSamplerForBackBuffer.unwrapForce())}}}}this.__transparentOnlyExpressions=t,this.__setIblInnerForTransparentOnly()}__setupInitialExpression(){let t=new gn;t.tryToSetUniqueName("Initial",!0);let o=new Dt;if(o.clearColor=q.fromCopyArray4([0,0,0,0]),o.toClearColorBuffer=!0,o.toClearDepthBuffer=!0,o.tryToSetUniqueName("InitialRenderPass",!0),t.addRenderPasses([o]),!this.__isSimple){let r=new Dt;r.clearColor=q.fromCopyArray4([0,0,0,0]),r.toClearColorBuffer=!0,r.toClearDepthBuffer=!0,r.setFramebuffer(this.__getMainFrameBuffer().unwrapForce()),r.tryToSetUniqueName("InitialRenderPassForFrameBuffer",!0),t.addRenderPasses([r])}return t}__createRenderTargets(t,o){let r=Pe.getInstance().getModule("xr"),i=r==null?void 0:r.WebXRSystem.getInstance(),a=G.getCgApiResourceRepository();if(A.exist(i)&&i.isWebXRMode&&a.isSupportMultiViewVRRendering()){let s=tn.createFrameBufferTextureArrayForMultiView({width:t/2,height:o,arrayLength:2,level:0,internalFormat:this.__isBloom?oe.R11F_G11F_B10F:oe.RGBA8,format:this.__isBloom?ue.RGB:ue.RGBA,type:this.__isBloom?I.Float:I.UnsignedByte});s.tryToSetUniqueName("FramebufferTargetOfToneMappingMultiView",!0);let l=tn.createFrameBuffer({width:t,height:o,textureNum:1,textureFormats:[this.__isBloom?oe.R11F_G11F_B10F:oe.RGBA8],createDepthBuffer:!1});l.tryToSetUniqueName("FramebufferTargetOfToneMappingMultiViewBlit",!0);let c=tn.createFrameBuffer({width:t,height:o,textureNum:1,textureFormats:[this.__isBloom?oe.R11F_G11F_B10F:oe.RGBA8],createDepthBuffer:!1});l.tryToSetUniqueName("FramebufferTargetOfToneMappingMultiViewBlitBackBuffer",!0),this.__oFrameBufferMultiView=new lt(s),this.__oFrameBufferMultiViewBlit=new lt(l),this.__oFrameBufferMultiViewBlitBackBuffer=new lt(c),this.__oFrameBufferMsaa=new be,this.__oFrameBufferResolve=new be,this.__oFrameBufferResolveForReference=new be}else{let s=tn.createFrameBufferMSAA({width:t,height:o,colorBufferNum:1,colorFormats:[this.__isBloom?oe.R11F_G11F_B10F:oe.RGBA8],sampleCountMSAA:4,depthBufferFormat:oe.Depth32F});s.tryToSetUniqueName("FramebufferTargetOfToneMappingMsaa",!0);let l=tn.createFrameBuffer({width:t,height:o,textureNum:1,textureFormats:[this.__isBloom?oe.R11F_G11F_B10F:oe.RGBA8],createDepthBuffer:!0,depthTextureFormat:oe.Depth32F});l.tryToSetUniqueName("FramebufferTargetOfToneMappingResolve",!0);let c=tn.createFrameBuffer({width:t,height:o,textureNum:1,textureFormats:[this.__isBloom?oe.R11F_G11F_B10F:oe.RGBA8],createDepthBuffer:!1});c.tryToSetUniqueName("FramebufferTargetOfToneMappingResolveForReference",!0),this.__oFrameBufferMultiView=new be,this.__oFrameBufferMultiViewBlit=new be,this.__oFrameBufferMultiViewBlitBackBuffer=new be,this.__oFrameBufferMsaa=new lt(s),this.__oFrameBufferResolve=new lt(l),this.__oFrameBufferResolveForReference=new lt(c)}}__setupGenerateMipmapsExpression(t){let o=new gn;o.tryToSetUniqueName("GenerateMipmaps",!0);let r=new Dt;return o.addRenderPasses([r]),r.tryToSetUniqueName("GenerateMipmaps",!0),r.toClearDepthBuffer=!1,r.setPostRenderFunction(function(){t.getColorAttachedRenderTargetTexture(0).generateMipmaps()}),new lt(o)}__setupMultiViewBlitBackBufferExpression(t){let o=new gn;o.tryToSetUniqueName("MultiViewBlitBackBuffer",!0);let r=new Dt;return o.addRenderPasses([r]),r.tryToSetUniqueName("MultiViewBlitBackBuffer",!0),r.toClearDepthBuffer=!1,r.setPostRenderFunction(()=>{if(this.__oFrameBufferMultiViewBlitBackBuffer.has()){let i=this.__oFrameBufferMultiViewBlitBackBuffer.unwrapForce().colorAttachments[0];t.colorAttachments[0].blitToTexture2dFromTexture2dArrayFake(i),i.generateMipmaps()}}),new lt(o)}__setupMultiViewBlitExpression(t){let o=new gn;o.tryToSetUniqueName("MultiViewBlit",!0);let r=new Dt;return o.addRenderPasses([r]),r.tryToSetUniqueName("MultiViewBlit",!0),r.toClearDepthBuffer=!1,r.setPostRenderFunction(()=>{if(this.__oFrameBufferMultiViewBlit.has()){let i=this.__oFrameBufferMultiViewBlit.unwrapForce().colorAttachments[0];t.colorAttachments[0].blitToTexture2dFromTexture2dArrayFake(i)}}),new lt(o)}__setupToneMappingExpression(t){let o=new gn,r=Oe.createToneMappingMaterial();this.__oToneMappingMaterial=new lt(r),this.setToneMappingType(this.__toneMappingType);let i=Pr.createScreenDrawRenderPassWithBaseColorTexture(r,t);i.tryToSetUniqueName("renderPassToneMapping",!0),i.toClearColorBuffer=!1,i.toClearDepthBuffer=!1,i.isDepthTest=!1,i.clearColor=q.fromCopyArray4([0,0,0,0]),i.isVrRendering=!1,i.isOutputForVr=!1;let a=Pr.createScreenDrawRenderPassWithBaseColorTexture(r,t);return a.tryToSetUniqueName("renderPassToneMappingVr",!0),a.toClearColorBuffer=!1,a.toClearDepthBuffer=!1,a.isDepthTest=!1,a.clearColor=q.fromCopyArray4([0,0,0,0]),a.isVrRendering=!1,a.isOutputForVr=!0,o.addRenderPasses([i,a]),o}__setupDepthMomentFramebuffer(t){return new lt(tn.createFrameBuffer({width:t,height:t,textureNum:1,textureFormats:[oe.RG32F],createDepthBuffer:!0,depthTextureFormat:oe.Depth32F}))}async __setIblInner(){for(let t of this.__expressions)for(let o of t.renderPasses)for(let r of o.entities){let i=r.tryToGetMeshRenderer();A.exist(i)&&await i.setIBLCubeMap(this.__oDiffuseCubeTexture.unwrapOrUndefined(),this.__oSpecularCubeTexture.unwrapOrUndefined(),this.__oSheenCubeTexture.unwrapOrUndefined())}}async __setIblInnerForTransparentOnly(){for(let t of this.__transparentOnlyExpressions)for(let o of t.renderPasses)for(let r of o.entities){let i=r.tryToGetMeshRenderer();A.exist(i)&&await i.setIBLCubeMap(this.__oDiffuseCubeTexture.unwrapOrUndefined(),this.__oSpecularCubeTexture.unwrapOrUndefined(),this.__oSheenCubeTexture.unwrapOrUndefined())}}setToneMappingType(t){this.__oToneMappingMaterial.has()&&(this.__toneMappingType=t,this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_KHRONOS_PBR_NEUTRAL"),this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_REINHARD"),this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_GT_TONEMAP"),this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_ACES_NARKOWICZ"),this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_ACES_HILL"),this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_ACES_HILL_EXPOSURE_BOOST"),t===oi.KhronosPbrNeutral?this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_KHRONOS_PBR_NEUTRAL"):t===oi.Reinhard?this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_REINHARD"):t===oi.GT_ToneMap?this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_GT_TONEMAP"):t===oi.ACES_Narkowicz?this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_ACES_NARKOWICZ"):t===oi.ACES_Hill?this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_ACES_HILL"):t===oi.ACES_Hill_Exposure_Boost&&this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_ACES_HILL_EXPOSURE_BOOST"))}__setExpressions(){if(this.__oFrame.doesNotHave()){console.error("Frame is not set.");return}let t=this.__oFrame.get();if(t.clearExpressions(),t.addExpression(this.getInitialExpression()),!this.__isSimple)for(let o of this.__shadowExpressions)t.addExpression(o);for(let o of this.__expressions)t.addExpression(o);!this.__isSimple&&this.__oGenerateMipmapsExpression.has()&&t.addExpression(this.__oGenerateMipmapsExpression.get()),!this.__isSimple&&this.__oMultiViewBlitBackBufferExpression.has()&&t.addExpression(this.__oMultiViewBlitBackBufferExpression.get());for(let o of this.__transparentOnlyExpressions)t.addExpression(o);!this.__isSimple&&this.__oMultiViewBlitExpression.has()&&t.addExpression(this.__oMultiViewBlitExpression.get()),!this.__isSimple&&this.__isBloom&&this.__oBloomExpression.has()&&t.addExpression(this.__oBloomExpression.get()),!this.__isSimple&&this.__oToneMappingExpression.has()&&t.addExpression(this.getToneMappingExpression())}};h(Rv,"ForwardRenderPipeline");var wv=Rv;ft();Ci();mm();kr();$c();Cm();cm();am();Ei();wm();Pp();Np();im();tr();tr();tt();Ku();var yl=class yl extends ht{constructor(){super();f(this,"vertexShaderBody",`


  `)}static getInstance(){return this.__instance||(this.__instance=new yl),this.__instance}get vertexShaderDefinitions(){return`

`}get pixelShaderDefinitions(){return`
uniform int u_shadingModel;
uniform float u_shininess;

struct Light {
  vec4 lightPosition;
  vec4 lightDirection;
  vec4 lightIntensity;
};
uniform Light u_lights[${F.maxLightNumberInShader}];
uniform int u_lightNumber;
uniform vec3 u_viewPosition;


bool classicShading(
  in vec3 diffuseColor,
  in vec3 position_inWorld,
  in vec3 normal_inWorld,
  out vec3 outColor
  )
{
  // Lighting
  outColor = vec3(0.0, 0.0, 0.0);
  if (u_shadingModel > 0) {

    vec3 diffuse = vec3(0.0, 0.0, 0.0);
    vec3 specular = vec3(0.0, 0.0, 0.0);
    for (int i = 0; i < ${F.maxLightNumberInShader}; i++) {
      if (i >= u_lightNumber) {
        break;
      }

      vec3 lightDirection = u_lights[i].lightDirection.xyz;
      float lightType = u_lights[i].lightPosition.w;
      float spotCosCutoff = u_lights[i].lightDirection.w;
      float spotExponent = u_lights[i].lightIntensity.w;

      if (0.75 < lightType) { // is pointlight or spotlight
        lightDirection = normalize(u_lights[i].lightPosition.xyz - position_inWorld.xyz);
      }
      float spotEffect = 1.0;
      if (lightType > 1.75) { // is spotlight
        spotEffect = dot(u_lights[i].lightDirection.xyz, lightDirection);
        if (spotEffect > spotCosCutoff) {
          spotEffect = pow(spotEffect, spotExponent);
        } else {
          spotEffect = 0.0;
        }
      }

      vec3 incidentLight = spotEffect * u_lights[i].lightIntensity.xyz;
//      incidentLight *= M_PI;

      normal_inWorld = normalize(normal_inWorld);

      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, lightDirection)) * incidentLight;

      if (u_shadingModel == 2) {// BLINN
        // ViewDirection
        vec3 viewDirection = normalize(u_viewPosition - position_inWorld.xyz);
        vec3 halfVector = normalize(lightDirection + viewDirection);
        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), u_shininess);
      } else if (u_shadingModel == 3) { // PHONG
        vec3 viewDirection = normalize(u_viewPosition - position_inWorld.xyz);
        vec3 R = reflect(lightDirection, normal_inWorld);
        specular += pow(max(0.0, dot(R, viewDirection)), u_shininess);
      }

    }

    outColor = diffuse + specular;
  } else {
    outColor = diffuseColor;
  }
}

    `}get pixelShaderBody(){return""}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}};h(yl,"ClassicShadingShader"),f(yl,"__instance"),f(yl,"materialElement",Yl.PBRShading);var Nv=yl;tr();var Xm=class Xm extends ht{constructor(){super();f(this,"__materialNodeUid",0);f(this,"vertexShaderBody",`
  `)}set materialNodeUid(t){this.__materialNodeUid=t}getPixelShaderBody(){return`
    `}get vertexShaderDefinitions(){return""}get pixelShaderDefinitions(){return""}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}};h(Xm,"TextureFetchShader"),f(Xm,"__instance");var Pv=Xm;tr();var Dv=class Dv extends ht{constructor(t,o,r){super();f(this,"__functionName");f(this,"__compositionType");f(this,"__componentType");f(this,"__variableName");this.__functionName=t,this.__compositionType=o,this.__componentType=r,this.__variableName=""}setVariableName(t){this.__variableName=t}get vertexShaderDefinitions(){return`
    out ${this.__compositionType.getGlslStr(this.__componentType)} ${this.__variableName};
    void ${this.__functionName}(
      in ${this.__compositionType.getGlslStr(this.__componentType)} value) {
      ${this.__variableName} = value;
    }
    `}get pixelShaderDefinitions(){return`
    in ${this.__compositionType.getGlslStr(this.__componentType)} ${this.__variableName};
    void ${this.__functionName}(
      out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
      outValue = ${this.__variableName};
    }
    `}get attributeNames(){return[]}get attributeSemantics(){return[]}get attributeCompositions(){return[]}};h(Dv,"VaryingVariableShader");var Mv=Dv;Uh();Dp();Jc();Tm();jl();Bp();sf();Hp();jp();Qn();function AH(){return Pe.getInstance().getModule("xr").WebXRSystem.getInstance()}h(AH,"getWebXRSystem");Kp();Em();var EOe=Bv;export{EOe as default};
