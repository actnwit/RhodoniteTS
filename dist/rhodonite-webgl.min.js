(window.webpackJsonp=window.webpackJsonp||[]).push([["webgl"],{50:function(e,t,r){"use strict";r.r(t);var i=r(25),n=r(33),a=r(34),o=r(23),s=r(29),l=r(4),u=r(1),c=r(3);class _ extends c.a{constructor({index:e,str:t}){super({index:e,str:t})}}const h=new _({index:1,str:"OES_vertex_array_object"}),g=new _({index:2,str:"OES_texture_float"}),d=new _({index:3,str:"OES_texture_half_float"}),m=new _({index:4,str:"OES_texture_float_linear"}),f=new _({index:5,str:"OES_texture_half_float_linear"}),x=new _({index:6,str:"ANGLE_instanced_arrays"}),b=new _({index:7,str:"EXT_texture_filter_anisotropic"}),p=new _({index:8,str:"OES_element_index_uint"}),R=new _({index:9,str:"EXT_shader_texture_lod"});const v=Object.freeze({VertexArrayObject:h,TextureFloat:g,TextureHalfFloat:d,TextureFloatLinear:m,TextureHalfFloatLinear:f,InstancedArrays:x,TextureFilterAnisotropic:b,ElementIndexUint:p,ShaderTextureLod:R});class w{constructor(e,t,r){this.__webglVersion=1,this.width=0,this.height=0,this.__extensions=new Map,this.__gl=e,this.width=t,this.height=r,"WebGL2RenderingContext"===this.__gl.constructor.name?this.__webglVersion=2:(this.webgl1ExtVAO=this.__getExtension(v.VertexArrayObject),this.webgl1ExtIA=this.__getExtension(v.InstancedArrays),this.webgl1ExtTF=this.__getExtension(v.TextureFloat),this.webgl1ExtTHF=this.__getExtension(v.TextureHalfFloat),this.webgl1ExtTFL=this.__getExtension(v.TextureFloatLinear),this.webgl1ExtTHFL=this.__getExtension(v.TextureHalfFloatLinear),this.webgl1ExtTFA=this.__getExtension(v.TextureFilterAnisotropic),this.webgl1ExtEIUI=this.__getExtension(v.ElementIndexUint),this.webgl1ExtSTL=this.__getExtension(v.ShaderTextureLod))}getRawContext(){return this.__gl}isSupportWebGL1Extension(e){return!!this.__getExtension(e)}get isWebGL2(){return 2===this.__webglVersion}createVertexArray(){return this.isWebGL2?this.__gl.createVertexArray():null!=this.webgl1ExtVAO?this.webgl1ExtVAO.createVertexArrayOES():void 0}bindVertexArray(e){this.isWebGL2?this.__gl.bindVertexArray(e):null!=this.webgl1ExtVAO&&this.webgl1ExtVAO.bindVertexArrayOES(e)}vertexAttribDivisor(e,t){this.isWebGL2?this.__gl.vertexAttribDivisor(e,t):this.webgl1ExtIA.vertexAttribDivisorANGLE(e,t)}drawElementsInstanced(e,t,r,i,n){this.isWebGL2?this.__gl.drawElementsInstanced(e,t,r,i,n):this.webgl1ExtIA.drawElementsInstancedANGLE(e,t,r,i,n)}__getExtension(e){const t=this.__gl;if(!this.__extensions.has(e)){const r=t.getExtension(e.toString());if(null==r){const t=`The library does not support this environment because the ${e.toString()} is not available`;null!=console.error?console.error(t):console.log(t)}return this.__extensions.set(e,r),r}return this.__extensions.get(e)}}var T=r(40),U=function(e,t,r,i){return new(r||(r=Promise))(function(n,a){function o(e){try{l(i.next(e))}catch(e){a(e)}}function s(e){try{l(i.throw(e))}catch(e){a(e)}}function l(e){e.done?n(e.value):new r(function(t){t(e.value)}).then(o,s)}l((i=i.apply(e,t||[])).next())})};class E extends n.a{constructor(){super(),this.__webglContexts=new Map,this.__resourceCounter=n.a.InvalidCGAPIResourceUid,this.__webglResources=new Map}static getInstance(){return this.__instance||(this.__instance=new E),this.__instance}addWebGLContext(e,t,r,i){const n=new w(e,t,r);this.__webglContexts.set("default",n),i&&(this.__glw=n)}get currentWebGLContextWrapper(){return this.__glw}getResourceNumber(){return++this.__resourceCounter}getWebGLResource(e){return this.__webglResources.get(e)}createIndexBuffer(e){const t=this.__glw.getRawContext();if(null==t)throw new Error("No WebGLRenderingContext set as Default.");const r=t.createBuffer(),i=this.getResourceNumber();return this.__webglResources.set(i,r),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,r),t.bufferData(t.ELEMENT_ARRAY_BUFFER,e.getTypedArray(),t.STATIC_DRAW),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),i}createVertexBuffer(e){const t=this.__glw.getRawContext();if(null==t)throw new Error("No WebGLRenderingContext set as Default.");const r=t.createBuffer(),i=this.getResourceNumber();return this.__webglResources.set(i,r),t.bindBuffer(t.ARRAY_BUFFER,r),t.bufferData(t.ARRAY_BUFFER,e.bufferView.getUint8Array(),t.STATIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,null),i}createVertexArray(){if(null==this.__glw)throw new Error("No WebGLRenderingContext set as Default.");const e=this.__glw.createVertexArray(),t=this.getResourceNumber();return this.__webglResources.set(t,e),t}createVertexDataResources(e){const t=this.__glw.getRawContext(),r=this.createVertexArray();let i;e.hasIndices()&&(i=this.createIndexBuffer(e.indicesAccessor));const n=[];return e.attributeAccessors.forEach(e=>{const t=this.createVertexBuffer(e);n.push(t)}),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),{vaoHandle:r,iboHandle:i,vboHandles:n,setComplete:!1}}createShaderProgram({vertexShaderStr:e,fragmentShaderStr:t,attributeNames:r,attributeSemantics:i}){const n=this.__glw.getRawContext();if(null==n)throw new Error("No WebGLRenderingContext set as Default.");const a=n.createShader(n.VERTEX_SHADER);n.shaderSource(a,e),n.compileShader(a),this.__checkShaderCompileStatus(a,e);const o=n.createProgram();let s;n.attachShader(o,a),null!=t&&(s=n.createShader(n.FRAGMENT_SHADER),n.shaderSource(s,t),n.compileShader(s),this.__checkShaderCompileStatus(s,t),n.attachShader(o,s)),r.forEach((e,t)=>{n.bindAttribLocation(o,i[t].getAttributeSlot(),e)}),n.linkProgram(o);const l=this.getResourceNumber();return this.__webglResources.set(l,o),this.__checkShaderProgramLinkStatus(o),n.deleteShader(a),null!=t&&n.deleteShader(s),l}__addLineNumber(e){let t=e.split(/\r\n|\r|\n/),r="";for(let e=0;e<t.length;e++){let i=e+1,n=" : ";i<10?n="  : ":i>=100&&(n=": "),r+=i+n+t[e]+"\n"}return r}__checkShaderCompileStatus(e,t){const r=this.__glw.getRawContext();if(!r.getShaderParameter(e,r.COMPILE_STATUS))throw console.log(this.__addLineNumber(t)),new Error("An error occurred compiling the shaders:"+r.getShaderInfoLog(e))}__checkShaderProgramLinkStatus(e){const t=this.__glw.getRawContext();if(!t.getProgramParameter(e,t.LINK_STATUS))throw new Error("Unable to initialize the shader program: "+t.getProgramInfoLog(e))}setupUniformLocations(e,t){const r=this.__glw.getRawContext(),i=this.getWebGLResource(e);for(let e of t){let t,n,a="";null!=e.prefix&&(a=e.prefix),e.semantic?(t=e.semantic.singularStr,n=e.semantic.pluralStr):(t=e.semanticStr,n=e.semanticStr);let o=t;null!=e.index&&(o+="_"+e.index),e.isPlural?i[o]=r.getUniformLocation(i,"u_"+a+n):i[o]=r.getUniformLocation(i,"u_"+a+t)}}setUniformValue(e,t,r,i,n,a,{x:o,y:s,z:l,w:u},c){const _=this.__glw.getRawContext(),h=this.getWebGLResource(e);let g="uniform";r&&(g="uniformMatrix"),g+=i,g+=n,a&&(g+="v");const d=[];let m="string"==typeof t?t:t.str;null!=c&&(m+="_"+c),d.push(h[m]),r&&d.push(!1),d.push(o),null!=s&&d.push(s),null!=l&&d.push(l),null!=u&&d.push(u),_[g].apply(_,d)}setVertexDataToPipeline({vaoHandle:e,iboHandle:t,vboHandles:r},i,o=n.a.InvalidCGAPIResourceUid){const s=this.__glw.getRawContext(),c=this.getWebGLResource(e);if(this.__glw.bindVertexArray(c),null!=t){const e=this.getWebGLResource(t);if(null==e)throw new Error("Nothing Element Array Buffer!");s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,e)}if(r.forEach((e,t)=>{const r=this.getWebGLResource(e);if(null==r)throw new Error("Nothing Element Array Buffer at index "+t);s.bindBuffer(s.ARRAY_BUFFER,r),s.enableVertexAttribArray(i.attributeSemantics[t].getAttributeSlot()),s.vertexAttribPointer(i.attributeSemantics[t].getAttributeSlot(),i.attributeCompositionTypes[t].getNumberOfComponents(),i.attributeComponentTypes[t].index,!1,i.attributeAccessors[t].byteStride,i.attributeAccessors[t].byteOffsetInBufferView)}),o!==n.a.InvalidCGAPIResourceUid){const e=this.getWebGLResource(o);if(null==e)throw new Error("Nothing Element Array Buffer at index");s.bindBuffer(s.ARRAY_BUFFER,e),s.enableVertexAttribArray(a.a.Instance.getAttributeSlot()),s.vertexAttribPointer(a.a.Instance.getAttributeSlot(),l.a.Scalar.getNumberOfComponents(),u.a.Float.index,!1,0,0),this.__glw.vertexAttribDivisor(a.a.Instance.getAttributeSlot(),1)}s.bindBuffer(s.ARRAY_BUFFER,null),this.__glw.bindVertexArray(null),s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,null)}createTexture(e,{level:t,internalFormat:r,width:i,height:n,border:a,format:o,type:s,magFilter:l,minFilter:u,wrapS:c,wrapT:_,generateMipmap:h,anisotropy:g}){const d=this.__glw.getRawContext(),m=d.createTexture(),f=this.getResourceNumber();return this.__webglResources.set(f,m),d.bindTexture(d.TEXTURE_2D,m),e instanceof HTMLImageElement||e instanceof HTMLCanvasElement?d.texImage2D(d.TEXTURE_2D,t,r.index,o.index,s.index,e):d.texImage2D(d.TEXTURE_2D,t,r.index,i,n,a,o.index,s.index,e),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,c.index),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,_.index),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,l.index),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,u.index),T.a.isPowerOfTwoTexture(i,n)&&(g&&this.__glw.webgl1ExtTFA&&d.texParameteri(d.TEXTURE_2D,this.__glw.webgl1ExtTFA.TEXTURE_MAX_ANISOTROPY_EXT,4),h&&d.generateMipmap(d.TEXTURE_2D)),f}createCubeTexture(e,t,r,i){const n=this.__glw.getRawContext(),a=n.createTexture(),o=this.getResourceNumber();this.__webglResources.set(o,a),n.bindTexture(n.TEXTURE_CUBE_MAP,a),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),e>=2?(n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MIN_FILTER,n.LINEAR_MIPMAP_LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MAG_FILTER,n.LINEAR)):(n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MAG_FILTER,n.LINEAR));const s=(e,t,a)=>{e instanceof HTMLImageElement||e instanceof HTMLCanvasElement?n.texImage2D(t,a,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e):n.texImage2D(t,a,n.RGBA,r/(a+1),i/(a+1),0,n.RGBA,n.UNSIGNED_BYTE,e)};for(let e=0;e<t.length;e++){const r=t[e];s(r.posX,n.TEXTURE_CUBE_MAP_POSITIVE_X,e),s(r.negX,n.TEXTURE_CUBE_MAP_NEGATIVE_X,e),s(r.posY,n.TEXTURE_CUBE_MAP_POSITIVE_Y,e),s(r.negY,n.TEXTURE_CUBE_MAP_NEGATIVE_Y,e),s(r.posZ,n.TEXTURE_CUBE_MAP_POSITIVE_Z,e),s(r.negZ,n.TEXTURE_CUBE_MAP_NEGATIVE_Z,e)}return o}createCubeTextureFromFiles(e,t){return U(this,void 0,void 0,function*(){const r=this.__glw.getRawContext(),i=[];let n=0,a=0;for(let o=0;o<t;o++){const t=()=>new Promise((t,i)=>{let n=0;const a=[];let s=[[e+"_right_"+o+".jpg",r.TEXTURE_CUBE_MAP_POSITIVE_X],[e+"_left_"+o+".jpg",r.TEXTURE_CUBE_MAP_NEGATIVE_X],[e+"_top_"+o+".jpg",r.TEXTURE_CUBE_MAP_POSITIVE_Y],[e+"_bottom_"+o+".jpg",r.TEXTURE_CUBE_MAP_NEGATIVE_Y],[e+"_front_"+o+".jpg",r.TEXTURE_CUBE_MAP_POSITIVE_Z],[e+"_back_"+o+".jpg",r.TEXTURE_CUBE_MAP_NEGATIVE_Z]];for(var l=0;l<s.length;l++){const e=s[l][1],r=new Image;r.side=e,r.uri=s[l][0],r.crossOrigin="Anonymous",r.onload=(()=>{n++,a.push(r),6===n&&t(a)}),r.onerror=(()=>{i(r.uri)}),r.src=s[l][0]}});let s;try{s=yield t()}catch(e){try{s=yield t()}catch(e){console.error(`failed to load ${e}`)}}const l={};for(let e of s){switch(e.side){case r.TEXTURE_CUBE_MAP_POSITIVE_X:l.posX=e;break;case r.TEXTURE_CUBE_MAP_POSITIVE_Y:l.posY=e;break;case r.TEXTURE_CUBE_MAP_POSITIVE_Z:l.posZ=e;break;case r.TEXTURE_CUBE_MAP_NEGATIVE_X:l.negX=e;break;case r.TEXTURE_CUBE_MAP_NEGATIVE_Y:l.negY=e;break;case r.TEXTURE_CUBE_MAP_NEGATIVE_Z:l.negZ=e}0===o&&(n=e.width,a=e.height)}i.push(l)}return this.createCubeTexture(t,i,n,a)})}createDummyCubeTexture(e="rgba(0,0,0,1)"){var t=document.createElement("canvas");t.width=1,t.height=1;const r=t.getContext("2d");return r.fillStyle=e,r.fillRect(0,0,1,1),this.createCubeTexture(1,[{posX:t,negX:t,posY:t,negY:t,posZ:t,negZ:t}],1,1)}createTextureFromDataUri(e,{level:t,internalFormat:r,border:i,format:n,type:a,magFilter:o,minFilter:s,wrapS:l,wrapT:u,generateMipmap:c,anisotropy:_}){return U(this,void 0,void 0,function*(){return new Promise(h=>{const g=new Image;e.match(/^data:/)||(g.crossOrigin="Anonymous"),g.onload=(()=>{const e=g.width,d=g.height;let m=this.createTexture(g,{level:t,internalFormat:r,width:e,height:d,border:i,format:n,type:a,magFilter:o,minFilter:s,wrapS:l,wrapT:u,generateMipmap:c,anisotropy:_});h(m)}),g.src=e})})}updateTexture(e,t,{level:r,width:i,height:n,format:a,type:o}){const s=this.__glw.getRawContext(),l=this.getWebGLResource(e);s.bindTexture(s.TEXTURE_2D,l),s.texSubImage2D(s.TEXTURE_2D,r,0,0,i,n,a.index,o.index,t)}deleteTexture(e){const t=this.getWebGLResource(e),r=this.__glw.getRawContext();null!=t&&(r.deleteTexture(t),this.__webglResources.delete(e))}createDummyTexture(e="rgba(255,255,255,1)"){var t=document.createElement("canvas");t.width=1,t.height=1;const r=t.getContext("2d");return r.fillStyle=e,r.fillRect(0,0,1,1),this.createTexture(t,{level:0,internalFormat:s.a.RGBA,width:1,height:1,border:0,format:s.a.RGBA,type:u.a.Float,magFilter:o.a.Nearest,minFilter:o.a.Nearest,wrapS:o.a.ClampToEdge,wrapT:o.a.ClampToEdge,generateMipmap:!1,anisotropy:!1})}createUniformBuffer(e){const t=this.__glw.getRawContext();if(null==t)throw new Error("No WebGLRenderingContext set as Default.");const r=t.createBuffer(),i=this.getResourceNumber();return this.__webglResources.set(i,r),t.bindBuffer(t.UNIFORM_BUFFER,r),t.bufferData(t.UNIFORM_BUFFER,e,t.DYNAMIC_DRAW),t.bindBuffer(t.UNIFORM_BUFFER,null),i}updateUniformBuffer(e,t){const r=this.__glw.getRawContext(),i=this.getWebGLResource(e);r.bindBuffer(r.UNIFORM_BUFFER,i),r.bufferSubData(r.UNIFORM_BUFFER,0,t,0),r.bindBuffer(r.UNIFORM_BUFFER,null)}bindUniformBlock(e,t,r){const i=this.__glw.getRawContext();if(null==i)throw new Error("No WebGLRenderingContext set as Default.");const n=this.getWebGLResource(e),a=i.getUniformBlockIndex(n,t);i.uniformBlockBinding(n,a,r)}bindUniformBufferBase(e,t){const r=this.__glw.getRawContext();if(null==r)throw new Error("No WebGLRenderingContext set as Default.");const i=this.getWebGLResource(t);r.bindBufferBase(r.UNIFORM_BUFFER,e,i)}deleteUniformBuffer(e){const t=this.__glw.getRawContext();null==t&&new Error("No WebGLRenderingContext set as Default.");const r=this.getWebGLResource(e);t.deleteBuffer(r)}createTransformFeedback(){const e=this.__glw.getRawContext();var t=e.createTransformFeedback();const r=this.getResourceNumber();return this.__webglResources.set(r,t),e.bindTransformFeedback(e.TRANSFORM_FEEDBACK,t),r}deleteTransformFeedback(e){const t=this.__glw.getRawContext(),r=this.getWebGLResource(e);t.deleteTransformFeedback(r)}}var y=r(21),L=r(10),P=r(5);class S extends c.a{constructor({index:e,singularStr:t,pluralStr:r}){super({index:e,str:t}),this.pluralStr=r}get singularStr(){return this.str}}const C=new S({index:0,singularStr:"worldMatrix",pluralStr:"worldMatrices"}),A=new S({index:1,singularStr:"viewMatrix",pluralStr:"viewMatrices"}),I=new S({index:2,singularStr:"projectionMatrix",pluralStr:"projectionMatrices"}),M=new S({index:3,singularStr:"normalMatrix",pluralStr:"normalMatrices"}),W=new S({index:4,singularStr:"boneMatrix",pluralStr:"boneMatrices"}),F=new S({index:5,singularStr:"baseColorFactor",pluralStr:"baseColorFactors"}),G=new S({index:6,singularStr:"baseColorTexture",pluralStr:"baseColorTextures"}),B=new S({index:7,singularStr:"normalTexture",pluralStr:"normalTextures"}),D=new S({index:8,singularStr:"metallicRoughnessTexture",pluralStr:"metallicRoughnessTextures"}),N=new S({index:9,singularStr:"occlusionTexture",pluralStr:"occlusionTextures"}),V=new S({index:10,singularStr:"lightNumber",pluralStr:"lightNumbers"}),H=new S({index:11,singularStr:"lightPosition",pluralStr:"lightPositions"}),O=new S({index:12,singularStr:"lightDirection",pluralStr:"lightDirections"}),X=new S({index:13,singularStr:"lightIntensity",pluralStr:"intensityOfLights"}),k=new S({index:14,singularStr:"metallicRoughnessFactor",pluralStr:"metallicRoughnessFactors"}),$=new S({index:15,singularStr:"brdfLutTexture",pluralStr:"brdfLutTexture"}),j=new S({index:16,singularStr:"diffuseEnvTexture",pluralStr:"diffuseEnvTextures"}),z=new S({index:17,singularStr:"specularEnvTexture",pluralStr:"specularEnvTextures"}),Y=new S({index:18,singularStr:"iblParameter",pluralStr:"iblParameter"});const q=Object.freeze({WorldMatrix:C,ViewMatrix:A,ProjectionMatrix:I,NormalMatrix:M,BoneMatrix:W,BaseColorFactor:F,BaseColorTexture:G,NormalTexture:B,MetallicRoughnessTexture:D,OcclusionTexture:N,LightNumber:V,LightPosition:H,LightDirection:O,LightIntensity:X,MetallicRoughnessFactor:k,BrdfLutTexture:$,DiffuseEnvTexture:j,SpecularEnvTexture:z,IBLParameter:Y});class Z{constructor(){this.__webglResourceRepository=E.getInstance()}get glsl_rt0(){return this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2?"layout(location = 0) out vec4 rt0;\n":"vec4 rt0;\n"}get glsl_fragColor(){return this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2?"":"gl_FragColor = rt0;\n"}get glsl_vertex_in(){return this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2?"in":"attribute"}get glsl_fragment_in(){return this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2?"in":"varying"}get glsl_vertex_out(){return this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2?"out":"varying"}get glsl_texture(){return this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2?"texture":"texture2D"}get glsl_versionText(){return this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2?"#version 300 es\n":""}get glsl1ShaderTextureLodExt(){return null!=E.getInstance().currentWebGLContextWrapper.webgl1ExtSTL?"#extension GL_EXT_shader_texture_lod : require\n":""}get toNormalMatrix(){return"\n    mat3 toNormalMatrix(mat4 m) {\n      float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n      float b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32;\n\n      float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n      return mat3(\n        a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n        a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n        a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n    }\n    "}get getSkinMatrix(){return"\n\n    mat4 getSkinMatrix() {\n      mat4 skinMat = a_weight.x * u_boneMatrices[int(a_joint.x)];\n      skinMat += a_weight.y * u_boneMatrices[int(a_joint.y)];\n      skinMat += a_weight.z * u_boneMatrices[int(a_joint.z)];\n      skinMat += a_weight.w * u_boneMatrices[int(a_joint.w)];\n\n      return skinMat;\n    }\n    "}get processSkinningIfNeed(){return"\n    if (length(a_weight.xyz) > 0.01) {\n      mat4 skinMat = getSkinMatrix();\n      v_position_inWorld = skinMat * vec4(a_position, 1.0);\n      normalMatrix = toNormalMatrix(skinMat);\n      v_normal_inWorld = normalize(normalMatrix * a_normal);\n      gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n    }\n    "}get pbrUniformDefinition(){let e="";e+="uniform vec2 uMetallicRoughnessFactors;\n",e+="uniform vec3 uBaseColorFactor;\n",e+="uniform vec2 uOcclusionFactors;",e+="uniform vec3 uEmissiveFactor;",e+="uniform sampler2D uMetallicRoughnessTexture;\n";e+="uniform sampler2D uOcclusionTexture;\n";e+="uniform sampler2D uEmissiveTexture;\n";return e+="uniform sampler2D u_brdfLutTexture;\n",e+="uniform samplerCube uDiffuseEnvTexture;\n",e+="uniform samplerCube uSpecularEnvTexture;\n",e+="uniform vec3 uIBLParameters;\n",e+="uniform vec4 ambient;\n"}get pbrMethodDefinition(){let e;return`\n    const float M_PI = 3.141592653589793;\n    const float c_MinRoughness = 0.04;\n\n    float angular_n_h(float NH) {\n      return acos(NH);\n    }\n\n    float sqr(float x) {\n      return x*x;\n    }\n\n    float d_phong(float NH, float c1) {\n      return pow(\n        cos(acos(NH))\n        , c1\n      );\n    }\n\n    // GGX NDF\n    float d_ggx(float NH, float alphaRoughness) {\n      float roughnessSqr = alphaRoughness * alphaRoughness;\n      float f = (roughnessSqr - 1.0) * NH * NH + 1.0;\n      return roughnessSqr / (M_PI * f * f);\n    }\n\n    float d_torrance_reiz(float NH, float c3) {\n      float CosSquared = NH*NH;\n      float TanSquared = (1.0 - CosSquared)/CosSquared;\n      //return (1.0/M_PI) * sqr(c3/(CosSquared * (c3*c3 + TanSquared)));  // gamma = 2, aka GGX\n      return (1.0/sqrt(M_PI)) * (sqr(c3)/(CosSquared * (c3*c3 + TanSquared))); // gamma = 1, D_Berry\n    }\n\n    float d_beckmann(float NH, float m) {\n      float co = 1.0 / (4.0 * m * m * NH * NH * NH * NH);\n      float expx = exp((NH * NH - 1.0) / (m * m * NH * NH));\n      return co * expx;\n    }\n\n    // the same as glTF WebGL sample\n    // https://github.com/KhronosGroup/glTF-WebGL-PBR/blob/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders/pbr-frag.glsl#L188\n    // That is, Unreal Engine based approach, but modified to use alphaRoughness (squared artist's roughness parameter),\n    // and based on 'Separable Masking and Shadowing' approximation (propesed by Christophe Schlick)\n    // https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\n    float g_shielding(float NL, float NV, float alphaRoughness) {\n      float r = alphaRoughness;\n\n      // Local Shadowing using "Schlick-Smith" Masking Function\n      float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));\n\n      // Local Masking using "Schlick-Smith" Masking Function\n      float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));\n\n      return localShadowing * localMasking;\n    }\n\n    // The Schlick Approximation to Fresnel\n    vec3 fresnel(vec3 f0, float LH) {\n      return vec3(f0) + (vec3(1.0) - f0) * pow(1.0 - LH, 5.0);\n    }\n\n    vec3 cook_torrance_specular_brdf(float NH, float NL, float NV, vec3 F, float alphaRoughness) {\n      float D = d_ggx(NH, alphaRoughness);\n      float G = g_shielding(NL, NV, alphaRoughness);\n      return vec3(D)*vec3(G)*F/vec3(4.0*NL*NV);\n    }\n\n    vec3 diffuse_brdf(vec3 albedo)\n    {\n      return albedo / M_PI;\n    }\n\n    vec3 srgbToLinear(vec3 srgbColor) {\n      return pow(srgbColor, vec3(2.2));\n    }\n\n    float srgbToLinear(float value) {\n      return pow(value, 2.2);\n    }\n\n    vec3 linearToSrgb(vec3 linearColor) {\n      return pow(linearColor, vec3(1.0/2.2));\n    }\n\n    float linearToSrgb(float value) {\n      return pow(value, 1.0/2.2);\n    }\n\n    vec3 IBLContribution(vec3 n, float NV, vec3 reflection, vec3 albedo, vec3 F0, float userRoughness)\n    {\n      float mipCount = u_iblParameter.x;\n      float lod = (userRoughness * mipCount);\n\n      vec3 brdf = srgbToLinear(texture2D(u_brdfLutTexture, vec2(NV, 1.0 - userRoughness)).rgb);\n      vec3 diffuseLight = srgbToLinear(textureCube(u_diffuseEnvTexture, n).rgb);\n      ${e=this.__webglResourceRepository.currentWebGLContextWrapper.webgl1ExtSTL?"vec3 specularLight = srgbToLinear(textureCubeLodEXT(u_specularEnvTexture, reflection, lod).rgb);":"vec3 specularLight = srgbToLinear(textureCube(u_specularEnvTexture, reflection).rgb);"}\n\n      vec3 diffuse = diffuseLight * albedo;\n      vec3 specular = specularLight * (F0 * brdf.x + brdf.y);\n\n      float IBLDiffuseContribution = u_iblParameter.y;\n      float IBLSpecularContribution = u_iblParameter.z;\n      diffuse *= IBLDiffuseContribution;\n      specular *= IBLSpecularContribution;\n      return diffuse + specular;\n    }\n    `}}var J=r(28);class K extends Z{constructor(){super(),this.vertexShaderBody=`\n\nvoid main ()\n{\n  mat4 worldMatrix = getMatrix(a_instanceID);\n  mat4 viewMatrix = getViewMatrix(a_instanceID);\n  mat4 projectionMatrix = getProjectionMatrix(a_instanceID);\n  mat3 normalMatrix = getNormalMatrix(a_instanceID);\n\n  v_position_inWorld = worldMatrix * vec4(a_position, 1.0);\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n  v_color = a_color;\n  v_normal_inWorld = normalMatrix * a_normal;\n  v_texcoord = a_texcoord;\n\n  // Skeletal\n  ${this.processSkinningIfNeed}\n\n//  v_color = vec3(u_boneMatrices[int(a_joint.x)][1].xyz);\n}\n  `}static getInstance(){return this.__instance||(this.__instance=new K),this.__instance}get vertexShaderVariableDefinitions(){const e=this.glsl_versionText,t=this.glsl_vertex_in,r=this.glsl_vertex_out;return`${e}\nprecision highp float;\n${t} vec3 a_position;\n${t} vec3 a_color;\n${t} vec3 a_normal;\n${t} float a_instanceID;\n${t} vec2 a_texcoord;\n${t} vec4 a_joint;\n${t} vec4 a_weight;\n${r} vec3 v_color;\n${r} vec3 v_normal_inWorld;\n${r} vec4 v_position_inWorld;\n${r} vec2 v_texcoord;\nuniform mat4 u_boneMatrices[100];\n\n${this.toNormalMatrix}\n\n${this.getSkinMatrix}\n\n`}get fragmentShaderSimple(){const e=this.glsl_versionText,t=this.glsl_fragment_in,r=this.glsl_rt0,i=this.glsl_fragColor,n=this.glsl_texture;return`${e}\nprecision highp float;\n\nstruct Material {\n  vec4 baseColorFactor;\n  sampler2D baseColorTexture;\n};\nuniform Material u_material;\n\nstruct Light {\n  vec4 lightPosition;\n  vec4 lightDirection;\n  vec4 lightIntensity;\n};\nuniform Light u_lights[${J.a.maxLightNumberInShader}];\nuniform int u_lightNumber;\n\n${t} vec3 v_color;\n${t} vec3 v_normal_inWorld;\n${t} vec4 v_position_inWorld;\n${t} vec2 v_texcoord;\n${r}\nvoid main ()\n{\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n\n  // baseColor\n  vec3 color = vec3(0.0, 0.0, 0.0);\n  if (v_color != color && u_material.baseColorFactor.rgb != color) {\n    color = v_color * u_material.baseColorFactor.rgb;\n  } else if (v_color == color) {\n    color = u_material.baseColorFactor.rgb;\n  } else if (u_material.baseColorFactor.rgb == color) {\n    color = v_color;\n  } else {\n    color = vec3(1.0, 1.0, 1.0);\n  }\n  //color = v_color;\n\n  // baseColorTexture\n  vec4 textureColor = ${n}(u_material.baseColorTexture, v_texcoord);\n  if (textureColor.r > 0.05) {\n    color *= textureColor.rgb;\n  }\n\n  // Lighting\n  if (length(v_normal_inWorld) > 0.02) {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < ${J.a.maxLightNumberInShader}; i++) {\n      if (i >= u_lightNumber) {\n        break;\n      }\n\n      vec3 lightDirection = u_lights[i].lightDirection.xyz;\n      float lightType = u_lights[i].lightPosition.w;\n      float spotCosCutoff = u_lights[i].lightDirection.w;\n      float spotExponent = u_lights[i].lightIntensity.w;\n\n      if (0.75 < lightType) { // is pointlight or spotlight\n        lightDirection = normalize(u_lights[i].lightPosition.xyz - v_position_inWorld.xyz);\n      }\n      float spotEffect = 1.0;\n      if (lightType > 1.75) { // is spotlight\n        spotEffect = dot(u_lights[i].lightDirection.xyz, lightDirection);\n        if (spotEffect > spotCosCutoff) {\n          spotEffect = pow(spotEffect, spotExponent);\n        } else {\n          spotEffect = 0.0;\n        }\n      }\n\n      vec3 incidentLight = spotEffect * u_lights[i].lightIntensity.xyz;\n//      incidentLight *= M_PI;\n\n      diffuse += 1.0 * max(0.0, dot(normal_inWorld, lightDirection)) * incidentLight;\n    }\n\n    color *= diffuse;\n  }\n\n  rt0 = vec4(color, 1.0);\n  //rt0 = vec4(u_lightNumber, 0.0, 0.0, 1.0);\n\n\n  ${i}\n}\n`}get fragmentShader(){return this.fragmentShaderSimple}}K.attributeNames=["a_position","a_color","a_normal","a_texcoord","a_joint","a_weight","a_instanceID"],K.attributeSemantics=[a.a.Position,a.a.Color0,a.a.Normal,a.a.Texcoord0,a.a.Joints0,a.a.Weights0,a.a.Instance];class Q{constructor(){this.__webglResourceRepository=E.getInstance(),this.__uboUid=n.a.InvalidCGAPIResourceUid,this.__shaderProgramUid=n.a.InvalidCGAPIResourceUid,this.__vertexHandles=[],this.__isVAOSet=!1,this.vertexShaderMethodDefinitions_UBO="layout (std140) uniform matrix {\n    mat4 world[1024];\n  } u_matrix;\n\n  uniform mat4 u_viewMatrix;\n  uniform mat4 u_projectionMatrix;\n  uniform mat3 u_normalMatrix;\n\n  mat4 getMatrix(float instanceId) {\n    float index = instanceId;\n    return transpose(u_matrix.world[int(index)]);\n  }\n\n  mat4 getViewMatrix(float instanceId) {\n    return u_viewMatrix;\n  }\n\n  mat4 getProjectionMatrix(float instanceId) {\n    return u_projectionMatrix;\n  }\n\n  mat3 getNormalMatrix(float instanceId) {\n    return u_normalMatrix;\n  }\n\n  "}setupShaderProgram(){if(this.__shaderProgramUid!==n.a.InvalidCGAPIResourceUid)return;const e=K.getInstance();let t=e.vertexShaderVariableDefinitions+this.vertexShaderMethodDefinitions_UBO+e.vertexShaderBody,r=e.fragmentShader;this.__shaderProgramUid=this.__webglResourceRepository.createShaderProgram({vertexShaderStr:t,fragmentShaderStr:r,attributeNames:K.attributeNames,attributeSemantics:K.attributeSemantics}),this.__webglResourceRepository.setupUniformLocations(this.__shaderProgramUid,[{semantic:q.ViewMatrix,isPlural:!1},{semantic:q.ProjectionMatrix,isPlural:!1}])}__isLoaded(e){return null!=this.__vertexHandles[e]}$load(e){if(this.__isLoaded(0))return;const t=e.getPrimitiveNumber();for(let r=0;r<t;r++){const t=e.getPrimitiveAt(r),i=this.__webglResourceRepository.createVertexDataResources(t);this.__vertexHandles[r]=i,Q.__vertexHandleOfPrimitiveObjectUids.set(t.objectUid,i)}}$prerender(e,t){if(this.__isVAOSet)return;const r=e.getPrimitiveNumber();for(let i=0;i<r;i++){const r=e.getPrimitiveAt(i);this.__vertexHandles[i]=Q.__vertexHandleOfPrimitiveObjectUids.get(r.objectUid),this.__webglResourceRepository.setVertexDataToPipeline(this.__vertexHandles[i],r,t)}this.__isVAOSet=!0}common_$prerender(){const e=y.a.getInstance().getBuffer(P.a.GPUInstanceData);new Float32Array(e.getArrayBuffer());this.__uboUid===n.a.InvalidCGAPIResourceUid?(this.__uboUid=this.__webglResourceRepository.createUniformBuffer(L.a.getAccessor("worldMatrix",L.a).dataViewOfBufferView),this.__webglResourceRepository.bindUniformBufferBase(0,this.__uboUid)):this.__webglResourceRepository.updateUniformBuffer(this.__uboUid,L.a.getAccessor("worldMatrix",L.a).dataViewOfBufferView)}attachGPUData(){this.__webglResourceRepository.bindUniformBlock(this.__shaderProgramUid,"matrix",0)}attatchShaderProgram(){const e=this.__shaderProgramUid,t=this.__webglResourceRepository.currentWebGLContextWrapper.getRawContext(),r=this.__webglResourceRepository.getWebGLResource(e);t.useProgram(r)}attachVertexData(e,t,r,i){const n=this.__vertexHandles[e],a=this.__webglResourceRepository.getWebGLResource(n.vaoHandle),o=r.getRawContext();if(null!=a)r.bindVertexArray(a);else{this.__webglResourceRepository.setVertexDataToPipeline(n,t,i);const e=this.__webglResourceRepository.getWebGLResource(n.iboHandle);o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,e)}}static getInstance(){return this.__instance||(this.__instance=new Q),this.__instance}common_$render(e,t){const r=this.__webglResourceRepository.currentWebGLContextWrapper;this.attatchShaderProgram();r.getRawContext();return this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.ViewMatrix,!0,4,"f",!0,{x:e.v}),this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.ProjectionMatrix,!0,4,"f",!0,{x:t.v}),!0}}Q.__vertexHandleOfPrimitiveObjectUids=new Map;var ee=r(24),te=r(19),re=r(35),ie=r(30);class ne{constructor(){this.__webglResourceRepository=E.getInstance(),this.__instanceDataTextureUid=n.a.InvalidCGAPIResourceUid,this.__vertexDataTextureUid=n.a.InvalidCGAPIResourceUid,this.__shaderProgramUid=n.a.InvalidCGAPIResourceUid,this.__primitiveHeaderUboUid=n.a.InvalidCGAPIResourceUid,this.__indexCountToSubtractUboUid=n.a.InvalidCGAPIResourceUid,this.__entitiesUidUboUid=n.a.InvalidCGAPIResourceUid,this.__primitiveUidUboUid=n.a.InvalidCGAPIResourceUid,this.__isVertexReady=!1}get __transformFeedbackShaderText(){K.getInstance().glsl_vertex_in,K.getInstance().glsl_texture;return`#version 300 es\n\n    layout (std140) uniform indexCountsToSubtract {\n      ivec4 counts[256];\n    } u_indexCountsToSubtract;\n    layout (std140) uniform entityUids {\n      ivec4 ids[256];\n    } u_entityData;\n    layout (std140) uniform primitiveUids {\n      ivec4 ids[256];\n    } u_primitiveData;\n    layout (std140) uniform primitiveHeader {\n      ivec4 data[256];\n    } u_primitiveHeader;\n\n    out vec4 position;\n    //out vec3 colors;\n\n    uniform sampler2D u_instanceDataTexture;\n    uniform sampler2D u_vertexDataTexture;\n\n    void main(){\n      int indexOfVertices = gl_VertexID + 3*gl_InstanceID;\n\n      int entityUidMinusOne = 0;\n      int primitiveUid = 0;\n      for (int i=0; i<=indexOfVertices; i++) {\n        for (int j=0; j<1024; j++) {\n          int value = u_indexCountsToSubtract.counts[j/4][j%4];\n          int result = int(step(float(value), float(i)));\n          if (result > 0) {\n            entityUidMinusOne = result * int(u_entityData.ids[j/4][j%4]) - 1;\n            primitiveUid = result * u_primitiveData.ids[j/4][j%4];\n          } else {\n            break;\n          }\n        }\n      }\n\n      ivec4 indicesMeta = u_primitiveHeader.data[9*primitiveUid + 0];\n      int primIndicesByteOffset = indicesMeta.x;\n      int primIndicesComponentSizeInByte = indicesMeta.y;\n      int primIndicesLength = indicesMeta.z;\n\n      int idx = gl_VertexID - primIndicesByteOffset / 4 /*byte*/;\n\n      // get Indices\n      int texelLength = ${y.a.bufferWidthLength};\n      vec4 indexVec4 = texelFetch(u_vertexDataTexture, ivec2(idx%texelLength, idx/texelLength), 0);\n      int index = int(indexVec4[idx%4]);\n\n      // get Positions\n      ivec4 indicesData = u_primitiveHeader.data[9*primitiveUid + 1];\n      int primPositionsByteOffset = indicesData.x;\n      idx = primPositionsByteOffset/4 + index;\n      vec4 posVec4 = texelFetch(u_vertexDataTexture, ivec2(idx%texelLength, idx/texelLength), 0);\n\n      position = posVec4;\n    }\n`}get __transformFeedbackFragmentShaderText(){return"#version 300 es\nprecision highp float;\n\nout vec4 outColor;\n\nvoid main(){\n    outColor = vec4(1.0);\n}\n    "}setupShaderProgram(){if(this.__shaderProgramUid!==n.a.InvalidCGAPIResourceUid)return;let e=this.__transformFeedbackShaderText,t=this.__transformFeedbackFragmentShaderText;this.__shaderProgramUid=this.__webglResourceRepository.createShaderProgram({vertexShaderStr:e,fragmentShaderStr:t,attributeNames:K.attributeNames,attributeSemantics:K.attributeSemantics}),this.__webglResourceRepository.setupUniformLocations(this.__shaderProgramUid,[{semantic:q.ViewMatrix,isPlural:!1},{semantic:q.ProjectionMatrix,isPlural:!1}])}$load(e){if(this.__isVertexReady)return;const t=y.a.getInstance().getBuffer(P.a.CPUGeneric),r=t.takeBufferView({byteLengthToNeed:12,byteStride:4,isAoS:!1}).takeAccessor({compositionType:l.a.Scalar,componentType:u.a.UnsingedInt,count:3}),i=t.takeBufferView({byteLengthToNeed:48,byteStride:16,isAoS:!1}).takeAccessor({compositionType:l.a.Vec4,componentType:u.a.Float,count:3}),n=r.getTypedArray();n[0]=0,n[1]=1,n[2]=2;const o=re.a.createPrimitive({indices:n,attributeCompositionTypes:[i.compositionType],attributeSemantics:[a.a.Position],attributes:[i.getTypedArray()],primitiveMode:ie.a.Triangles,material:void 0});this.__vertexHandle=this.__webglResourceRepository.createVertexDataResources(o),this.__isVertexReady=!0}$prerender(e,t){}__setupUBOPrimitiveHeaderData(){const e=y.a.getInstance().getBuffer(P.a.UBOGeneric),t=new Int32Array(e.getArrayBuffer());this.__primitiveHeaderUboUid===n.a.InvalidCGAPIResourceUid&&(this.__primitiveHeaderUboUid=this.__webglResourceRepository.createUniformBuffer(t),this.__webglResourceRepository.bindUniformBufferBase(3,this.__primitiveHeaderUboUid))}__setupGPUInstanceMetaData(){if(this.__primitiveUidUboUid!==n.a.InvalidCGAPIResourceUid)return;const e=ee.a.getInstance()._getEntities(),t=new Int32Array(e.length),r=new Int32Array(e.length),i=new Int32Array(e.length);let a=0;e.forEach((e,n)=>{const o=e.getComponent(te.a);if(o){r[n]=o.getPrimitiveAt(0).primitiveUid,t[n]=e.entityUID;const s=o.getPrimitiveAt(0).indicesAccessor.elementCount;i[n]=a+s,a+=s}}),this.__indexCountToSubtractUboUid=this.__webglResourceRepository.createUniformBuffer(i),this.__webglResourceRepository.bindUniformBufferBase(0,this.__indexCountToSubtractUboUid),this.__entitiesUidUboUid=this.__webglResourceRepository.createUniformBuffer(t),this.__webglResourceRepository.bindUniformBufferBase(1,this.__entitiesUidUboUid),this.__primitiveUidUboUid=this.__webglResourceRepository.createUniformBuffer(r),this.__webglResourceRepository.bindUniformBufferBase(2,this.__primitiveUidUboUid)}__setupGPUInstanceData(){let e=!1;(this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2||this.__webglResourceRepository.currentWebGLContextWrapper.isSupportWebGL1Extension(v.TextureHalfFloat))&&(e=!0);const t=y.a.getInstance().getBuffer(P.a.GPUInstanceData),r=new Float32Array(t.getArrayBuffer());let i;if(e){i=new Uint16Array(r.length);let e=t.byteSizeInUse/4;e/=2;for(let t=0;t<e;t++)i[t]=T.a.toHalfFloat(r[t])}this.__instanceDataTextureUid===n.a.InvalidCGAPIResourceUid?e?this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2?this.__instanceDataTextureUid=this.__webglResourceRepository.createTexture(r,{level:0,internalFormat:o.a.RGBA16F,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,border:0,format:s.a.RGBA,type:u.a.Float,magFilter:o.a.Nearest,minFilter:o.a.Nearest,wrapS:o.a.Repeat,wrapT:o.a.Repeat,generateMipmap:!1,anisotropy:!1}):this.__instanceDataTextureUid=this.__webglResourceRepository.createTexture(i,{level:0,internalFormat:s.a.RGBA,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,border:0,format:s.a.RGBA,type:u.a.HalfFloat,magFilter:o.a.Nearest,minFilter:o.a.Nearest,wrapS:o.a.Repeat,wrapT:o.a.Repeat,generateMipmap:!1,anisotropy:!1}):this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2?this.__instanceDataTextureUid=this.__webglResourceRepository.createTexture(r,{level:0,internalFormat:o.a.RGBA32F,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,border:0,format:s.a.RGBA,type:u.a.Float,magFilter:o.a.Nearest,minFilter:o.a.Nearest,wrapS:o.a.Repeat,wrapT:o.a.Repeat,generateMipmap:!1,anisotropy:!1}):this.__instanceDataTextureUid=this.__webglResourceRepository.createTexture(r,{level:0,internalFormat:s.a.RGBA,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,border:0,format:s.a.RGBA,type:u.a.Float,magFilter:o.a.Nearest,minFilter:o.a.Nearest,wrapS:o.a.Repeat,wrapT:o.a.Repeat,generateMipmap:!1,anisotropy:!1}):e?this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2?this.__webglResourceRepository.updateTexture(this.__instanceDataTextureUid,r,{level:0,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,format:s.a.RGBA,type:u.a.Float}):this.__webglResourceRepository.updateTexture(this.__instanceDataTextureUid,i,{level:0,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,format:s.a.RGBA,type:u.a.HalfFloat}):(this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2,this.__webglResourceRepository.updateTexture(this.__instanceDataTextureUid,r,{level:0,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,format:s.a.RGBA,type:u.a.Float}))}__setupGPUVertexData(){if(this.__vertexDataTextureUid!==n.a.InvalidCGAPIResourceUid)return;const e=y.a.getInstance().getBuffer(P.a.GPUVertexData),t=new Float32Array(e.getArrayBuffer());this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2?this.__vertexDataTextureUid=this.__webglResourceRepository.createTexture(t,{level:0,internalFormat:o.a.RGBA32F,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,border:0,format:s.a.RGBA,type:u.a.Float,magFilter:o.a.Nearest,minFilter:o.a.Nearest,wrapS:o.a.Repeat,wrapT:o.a.Repeat,generateMipmap:!1,anisotropy:!1}):this.__vertexDataTextureUid=this.__webglResourceRepository.createTexture(t,{level:0,internalFormat:s.a.RGBA,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,border:0,format:s.a.RGBA,type:u.a.Float,magFilter:o.a.Nearest,minFilter:o.a.Nearest,wrapS:o.a.Repeat,wrapT:o.a.Repeat,generateMipmap:!1,anisotropy:!1})}common_$prerender(){this.__setupUBOPrimitiveHeaderData(),this.__setupGPUInstanceMetaData(),this.__setupGPUInstanceData(),this.__setupGPUVertexData()}attachGPUData(){{const t=this.__webglResourceRepository.currentWebGLContextWrapper.getRawContext(),r=this.__webglResourceRepository.getWebGLResource(this.__instanceDataTextureUid);t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,r);const i=this.__webglResourceRepository.getWebGLResource(this.__shaderProgramUid);var e=t.getUniformLocation(i,"u_instanceDataTexture");t.uniform1i(e,0)}{const e=this.__webglResourceRepository.currentWebGLContextWrapper.getRawContext(),r=this.__webglResourceRepository.getWebGLResource(this.__vertexDataTextureUid);e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,r);const i=this.__webglResourceRepository.getWebGLResource(this.__shaderProgramUid);var t=e.getUniformLocation(i,"u_vertexDataTexture");e.uniform1i(t,1)}this.__webglResourceRepository.bindUniformBlock(this.__shaderProgramUid,"indexCountsToSubtract",0),this.__webglResourceRepository.bindUniformBlock(this.__shaderProgramUid,"entityUids",1),this.__webglResourceRepository.bindUniformBlock(this.__shaderProgramUid,"primitiveUids",2),this.__webglResourceRepository.bindUniformBlock(this.__shaderProgramUid,"primitiveHeader",3)}attatchShaderProgram(){const e=this.__shaderProgramUid,t=this.__webglResourceRepository.currentWebGLContextWrapper.getRawContext(),r=this.__webglResourceRepository.getWebGLResource(e);t.useProgram(r)}attachVertexData(e,t,r,i){}static getInstance(){return this.__instance||(this.__instance=new ne),this.__instance}common_$render(e,t){const r=this.__webglResourceRepository.currentWebGLContextWrapper;this.attatchShaderProgram();r.getRawContext();return this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.ViewMatrix,!0,4,"f",!0,{x:e.v}),this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.ProjectionMatrix,!0,4,"f",!0,{x:t.v}),!0}}class ae{constructor(){this.__webglResourceRepository=E.getInstance(),this.__dataTextureUid=n.a.InvalidCGAPIResourceUid,this.__shaderProgramUid=n.a.InvalidCGAPIResourceUid,this.__vertexHandles=[],this.__isVAOSet=!1}get vertexShaderMethodDefinitions_dataTexture(){const e=K.getInstance().glsl_texture;return`\n  uniform sampler2D u_dataTexture;\n  uniform mat4 u_viewMatrix;\n  uniform mat4 u_projectionMatrix;\n  uniform mat3 u_normalMatrix;\n\n  /*\n   * This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n   * arg = vec2(1. / size.x, 1. / size.x / size.y);\n   */\n  // vec4 fetchElement(sampler2D tex, float index, vec2 arg)\n  // {\n  //   return ${e}( tex, arg * (index + 0.5) );\n  // }\n\n  vec4 fetchElement(sampler2D tex, float index, vec2 invSize)\n  {\n    float t = (index + 0.5) * invSize.x;\n    float x = fract(t);\n    float y = (floor(t) + 0.5) * invSize.y;\n    return ${e}( tex, vec2(x, y) );\n  }\n\n  mat4 getMatrix(float instanceId)\n  {\n    float index = instanceId;\n    float powWidthVal = ${y.a.bufferWidthLength}.0;\n    float powHeightVal = ${y.a.bufferHeightLength}.0;\n    vec2 arg = vec2(1.0/powWidthVal, 1.0/powHeightVal);\n  //  vec2 arg = vec2(1.0/powWidthVal, 1.0/powWidthVal/powHeightVal);\n\n    vec4 col0 = fetchElement(u_dataTexture, index * 4.0 + 0.0, arg);\n   vec4 col1 = fetchElement(u_dataTexture, index * 4.0 + 1.0, arg);\n   vec4 col2 = fetchElement(u_dataTexture, index * 4.0 + 2.0, arg);\n\n    mat4 matrix = mat4(\n      col0.x, col1.x, col2.x, 0.0,\n      col0.y, col1.y, col2.y, 0.0,\n      col0.z, col1.z, col2.z, 0.0,\n      col0.w, col1.w, col2.w, 1.0\n      );\n\n    return matrix;\n  }\n\n  mat4 getViewMatrix(float instanceId) {\n    return u_viewMatrix;\n  }\n\n  mat4 getProjectionMatrix(float instanceId) {\n    return u_projectionMatrix;\n  }\n\n  mat3 getNormalMatrix(float instanceId) {\n    return u_normalMatrix;\n  }\n\n  `}setupShaderProgram(){if(this.__shaderProgramUid!==n.a.InvalidCGAPIResourceUid)return;const e=K.getInstance();let t=e.vertexShaderVariableDefinitions+this.vertexShaderMethodDefinitions_dataTexture+e.vertexShaderBody,r=e.fragmentShader;this.__shaderProgramUid=this.__webglResourceRepository.createShaderProgram({vertexShaderStr:t,fragmentShaderStr:r,attributeNames:K.attributeNames,attributeSemantics:K.attributeSemantics}),this.__webglResourceRepository.setupUniformLocations(this.__shaderProgramUid,[{semantic:q.ViewMatrix,isPlural:!1},{semantic:q.ProjectionMatrix,isPlural:!1}])}__isLoaded(e){return null!=this.__vertexHandles[e]}$load(e){if(this.__isLoaded(0))return;const t=e.getPrimitiveNumber();for(let r=0;r<t;r++){const t=e.getPrimitiveAt(r),i=this.__webglResourceRepository.createVertexDataResources(t);this.__vertexHandles[r]=i,ae.__vertexHandleOfPrimitiveObjectUids.set(t.objectUid,i)}}$prerender(e,t){if(this.__isVAOSet)return;const r=e.getPrimitiveNumber();for(let i=0;i<r;i++){const r=e.getPrimitiveAt(i);this.__vertexHandles[i]=ae.__vertexHandleOfPrimitiveObjectUids.get(r.objectUid),this.__webglResourceRepository.setVertexDataToPipeline(this.__vertexHandles[i],r,t)}this.__isVAOSet=!0}common_$prerender(){let e=!1;(this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2||this.__webglResourceRepository.currentWebGLContextWrapper.isSupportWebGL1Extension(v.TextureHalfFloat))&&(e=!0);const t=y.a.getInstance().getBuffer(P.a.GPUInstanceData),r=new Float32Array(t.getArrayBuffer());let i;if(e){i=new Uint16Array(r.length);let e=t.byteSizeInUse/4;e/=2;for(let t=0;t<e;t++)i[t]=T.a.toHalfFloat(r[t])}this.__dataTextureUid===n.a.InvalidCGAPIResourceUid?e?this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2?this.__dataTextureUid=this.__webglResourceRepository.createTexture(r,{level:0,internalFormat:o.a.RGBA16F,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,border:0,format:s.a.RGBA,type:u.a.Float,magFilter:o.a.Nearest,minFilter:o.a.Nearest,wrapS:o.a.Repeat,wrapT:o.a.Repeat,generateMipmap:!1,anisotropy:!1}):this.__dataTextureUid=this.__webglResourceRepository.createTexture(i,{level:0,internalFormat:s.a.RGBA,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,border:0,format:s.a.RGBA,type:u.a.HalfFloat,magFilter:o.a.Nearest,minFilter:o.a.Nearest,wrapS:o.a.Repeat,wrapT:o.a.Repeat,generateMipmap:!1,anisotropy:!1}):this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2?this.__dataTextureUid=this.__webglResourceRepository.createTexture(r,{level:0,internalFormat:o.a.RGBA32F,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,border:0,format:s.a.RGBA,type:u.a.Float,magFilter:o.a.Nearest,minFilter:o.a.Nearest,wrapS:o.a.Repeat,wrapT:o.a.Repeat,generateMipmap:!1,anisotropy:!1}):this.__dataTextureUid=this.__webglResourceRepository.createTexture(r,{level:0,internalFormat:s.a.RGBA,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,border:0,format:s.a.RGBA,type:u.a.Float,magFilter:o.a.Nearest,minFilter:o.a.Nearest,wrapS:o.a.Repeat,wrapT:o.a.Repeat,generateMipmap:!1,anisotropy:!1}):e?this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2?this.__webglResourceRepository.updateTexture(this.__dataTextureUid,r,{level:0,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,format:s.a.RGBA,type:u.a.Float}):this.__webglResourceRepository.updateTexture(this.__dataTextureUid,i,{level:0,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,format:s.a.RGBA,type:u.a.HalfFloat}):(this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2,this.__webglResourceRepository.updateTexture(this.__dataTextureUid,r,{level:0,width:y.a.bufferWidthLength,height:y.a.bufferHeightLength,format:s.a.RGBA,type:u.a.Float}))}attachGPUData(){const e=this.__webglResourceRepository.currentWebGLContextWrapper.getRawContext(),t=this.__webglResourceRepository.getWebGLResource(this.__dataTextureUid);e.bindTexture(e.TEXTURE_2D,t);const r=this.__webglResourceRepository.getWebGLResource(this.__shaderProgramUid);var i=e.getUniformLocation(r,"u_dataTexture");e.uniform1i(i,0)}attatchShaderProgram(){const e=this.__shaderProgramUid,t=this.__webglResourceRepository.currentWebGLContextWrapper.getRawContext(),r=this.__webglResourceRepository.getWebGLResource(e);t.useProgram(r)}attachVertexData(e,t,r,i){const n=this.__vertexHandles[e],a=this.__webglResourceRepository.getWebGLResource(n.vaoHandle),o=r.getRawContext();if(null!=a)r.bindVertexArray(a);else{this.__webglResourceRepository.setVertexDataToPipeline(n,t,i);const e=this.__webglResourceRepository.getWebGLResource(n.iboHandle);o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,e)}}static getInstance(){return this.__instance||(this.__instance=new ae),this.__instance}common_$render(e,t){const r=this.__webglResourceRepository.currentWebGLContextWrapper;this.attatchShaderProgram();r.getRawContext();return this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.ViewMatrix,!0,4,"f",!0,{x:e.v}),this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.ProjectionMatrix,!0,4,"f",!0,{x:t.v}),!0}}ae.__vertexHandleOfPrimitiveObjectUids=new Map;var oe=r(15),se=r(39);class le extends Z{constructor(){super(),this.vertexShaderBody=`\n\nvoid main ()\n{\n  mat4 worldMatrix = getMatrix(a_instanceID);\n  mat4 viewMatrix = getViewMatrix(a_instanceID);\n  mat4 projectionMatrix = getProjectionMatrix(a_instanceID);\n  mat3 normalMatrix = getNormalMatrix(a_instanceID);\n\n  v_position_inWorld = worldMatrix * vec4(a_position, 1.0);\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n  v_color = a_color;\n  v_normal_inWorld = normalMatrix * a_normal;\n  v_texcoord = a_texcoord;\n\n  // Light\n  vec3 lightPosition = vec3(10000.0, 100000.0, 100000.0);\n  v_lightDirection = normalize(lightPosition - v_position_inWorld.xyz);\n\n  // Skeletal\n  ${this.processSkinningIfNeed}\n\n//  v_color = vec3(u_boneMatrices[int(a_joint.x)][1].xyz);\n}\n  `}static getInstance(){return this.__instance||(this.__instance=new le),this.__instance}get vertexShaderVariableDefinitions(){const e=this.glsl_versionText,t=this.glsl_vertex_in,r=this.glsl_vertex_out;return`${e}\nprecision highp float;\n${t} vec3 a_position;\n${t} vec3 a_color;\n${t} vec3 a_normal;\n${t} float a_instanceID;\n${t} vec2 a_texcoord;\n${t} vec4 a_joint;\n${t} vec4 a_weight;\n${r} vec3 v_color;\n${r} vec3 v_normal_inWorld;\n${r} vec4 v_position_inWorld;\n${r} vec3 v_lightDirection;\n${r} vec2 v_texcoord;\nuniform mat4 u_boneMatrices[100];\n\n${this.toNormalMatrix}\n\n${this.getSkinMatrix}\n\n`}get fragmentShaderSimple(){const e=this.glsl_versionText,t=this.glsl_fragment_in,r=this.glsl_rt0,i=this.glsl_fragColor,n=this.glsl_texture;return`${e}\n${this.glsl1ShaderTextureLodExt}\nprecision highp float;\n\nstruct Material {\n  vec4 baseColorFactor;\n  sampler2D baseColorTexture;\n  vec2 metallicRoughnessFactor;\n  sampler2D metallicRoughnessTexture;\n};\nuniform Material u_material;\n\nstruct Light {\n  vec4 lightPosition;\n  vec4 lightDirection;\n  vec4 lightIntensity;\n};\nuniform Light u_lights[${J.a.maxLightNumberInShader}];\nuniform int u_lightNumber;\n\nuniform vec3 viewPosition_inWorld;\n\nuniform samplerCube u_diffuseEnvTexture;\nuniform samplerCube u_specularEnvTexture;\nuniform vec3 u_iblParameter;\n\n${t} vec3 v_color;\n${t} vec3 v_normal_inWorld;\n${t} vec4 v_position_inWorld;\n${t} vec3 v_lightDirection;\n${t} vec2 v_texcoord;\n${r}\n\n${this.pbrUniformDefinition}\n\n${this.pbrMethodDefinition}\n\nvoid main ()\n{\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n\n  // BaseColorFactor\n  vec3 baseColor = vec3(0.0, 0.0, 0.0);\n  float alpha = 1.0;\n  if (v_color != baseColor && u_material.baseColorFactor.rgb != baseColor) {\n    baseColor = v_color * u_material.baseColorFactor.rgb;\n    alpha = u_material.baseColorFactor.a;\n  } else if (v_color == baseColor) {\n    baseColor = u_material.baseColorFactor.rgb;\n    alpha = u_material.baseColorFactor.a;\n  } else if (u_material.baseColorFactor.rgb == baseColor) {\n    baseColor = v_color;\n  } else {\n    baseColor = vec3(1.0, 1.0, 1.0);\n  }\n\n\n  // BaseColor (take account for BaseColorTexture)\n  vec4 textureColor = ${n}(u_material.baseColorTexture, v_texcoord);\n  if (textureColor.r > 0.05) {\n    baseColor *= srgbToLinear(textureColor.rgb);\n    alpha *= srgbToLinear(textureColor.a);\n  }\n\n  // Metallic & Roughness\n  float userRoughness = u_material.metallicRoughnessFactor.y;\n  float metallic = u_material.metallicRoughnessFactor.x;\n\n  vec4 ormTexel = texture2D(u_material.metallicRoughnessTexture, v_texcoord);\n  userRoughness = ormTexel.g * userRoughness;\n  metallic = ormTexel.b * metallic;\n\n  userRoughness = clamp(userRoughness, c_MinRoughness, 1.0);\n  metallic = clamp(metallic, 0.0, 1.0);\n  float alphaRoughness = userRoughness * userRoughness;\n\n  // F0\n  vec3 diffuseMatAverageF0 = vec3(0.04);\n  vec3 F0 = mix(diffuseMatAverageF0, baseColor.rgb, metallic);\n\n  // Albedo\n  vec3 albedo = baseColor.rgb * (vec3(1.0) - diffuseMatAverageF0);\n  albedo.rgb *= (1.0 - metallic);\n\n  // ViewDirection\n  vec3 viewDirection = normalize(viewPosition_inWorld - v_position_inWorld.xyz);\n\n  // NV\n  float NV = clamp(dot(normal_inWorld, viewDirection), 0.001, 1.0);\n\n  rt0 = vec4(0.0, 0.0, 0.0, alpha);\n\n  // Lighting\n  if (length(v_normal_inWorld) > 0.02) {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < ${J.a.maxLightNumberInShader}; i++) {\n      if (i >= u_lightNumber) {\n        break;\n      }\n\n      // Light\n      vec3 lightDirection = u_lights[i].lightDirection.xyz;\n      float lightType = u_lights[i].lightPosition.w;\n      float spotCosCutoff = u_lights[i].lightDirection.w;\n      float spotExponent = u_lights[i].lightIntensity.w;\n\n      if (0.75 < lightType) { // is pointlight or spotlight\n        lightDirection = normalize(u_lights[i].lightPosition.xyz - v_position_inWorld.xyz);\n      }\n      float spotEffect = 1.0;\n      if (lightType > 1.75) { // is spotlight\n        spotEffect = dot(u_lights[i].lightDirection.xyz, lightDirection);\n        if (spotEffect > spotCosCutoff) {\n          spotEffect = pow(spotEffect, spotExponent);\n        } else {\n          spotEffect = 0.0;\n        }\n      }\n      //diffuse += 1.0 * max(0.0, dot(normal_inWorld, lightDirection)) * spotEffect * u_lights[i].lightIntensity.xyz;\n\n      // IncidentLight\n      vec3 incidentLight = spotEffect * u_lights[i].lightIntensity.xyz;\n      incidentLight *= M_PI;\n\n      // Fresnel\n      vec3 halfVector = normalize(lightDirection + viewDirection);\n      float LH = clamp(dot(lightDirection, halfVector), 0.0, 1.0);\n      vec3 F = fresnel(F0, LH);\n\n      // Diffuse\n      vec3 diffuseContrib = (vec3(1.0) - F) * diffuse_brdf(albedo);\n\n      // Specular\n      float NL = clamp(dot(normal_inWorld, lightDirection), 0.001, 1.0);\n      float NH = clamp(dot(normal_inWorld, halfVector), 0.0, 1.0);\n      float VH = clamp(dot(viewDirection, halfVector), 0.0, 1.0);\n      vec3 specularContrib = cook_torrance_specular_brdf(NH, NL, NV, F, alphaRoughness);\n      vec3 diffuseAndSpecular = (diffuseContrib + specularContrib) * vec3(NL) * incidentLight.rgb;\n\n      rt0.xyz += diffuseAndSpecular;\n    }\n\n    vec3 reflection = reflect(-viewDirection, normal_inWorld);\n    vec3 ibl = IBLContribution(normal_inWorld, NV, reflection, albedo, F0, userRoughness);\n\n    rt0.xyz += ibl;\n  }\n\n  ${i}\n}\n`}get fragmentShader(){return this.fragmentShaderSimple}}le.attributeNames=["a_position","a_color","a_normal","a_texcoord","a_joint","a_weight","a_instanceID"],le.attributeSemantics=[a.a.Position,a.a.Color0,a.a.Normal,a.a.Texcoord0,a.a.Joints0,a.a.Weights0,a.a.Instance];var ue=r(8),ce=r(41),_e=r(16),he=function(e,t,r,i){return new(r||(r=Promise))(function(n,a){function o(e){try{l(i.next(e))}catch(e){a(e)}}function s(e){try{l(i.throw(e))}catch(e){a(e)}}function l(e){e.done?n(e.value):new r(function(t){t(e.value)}).then(o,s)}l((i=i.apply(e,t||[])).next())})};class ge{constructor(){this.__webglResourceRepository=E.getInstance(),this.__uboUid=n.a.InvalidCGAPIResourceUid,this.__shaderProgramUid=n.a.InvalidCGAPIResourceUid,this.vertexShaderMethodDefinitions_uniform="\n  uniform mat4 u_worldMatrix;\n  uniform mat4 u_viewMatrix;\n  uniform mat4 u_projectionMatrix;\n  uniform mat3 u_normalMatrix;\n\n  mat4 getMatrix(float instanceId) {\n    return u_worldMatrix;\n  }\n\n  mat4 getViewMatrix(float instanceId) {\n    return u_viewMatrix;\n  }\n\n  mat4 getProjectionMatrix(float instanceId) {\n    return u_projectionMatrix;\n  }\n\n  mat3 getNormalMatrix(float instanceId) {\n    return u_normalMatrix;\n  }\n\n  "}setupShaderProgram(){if(this.__shaderProgramUid!==n.a.InvalidCGAPIResourceUid)return;const e=le.getInstance();let t=e.vertexShaderVariableDefinitions+this.vertexShaderMethodDefinitions_uniform+e.vertexShaderBody,r=e.fragmentShader;this.__shaderProgramUid=this.__webglResourceRepository.createShaderProgram({vertexShaderStr:t,fragmentShaderStr:r,attributeNames:le.attributeNames,attributeSemantics:le.attributeSemantics}),this.__shaderProgram=this.__webglResourceRepository.getWebGLResource(this.__shaderProgramUid);const i=[{semantic:q.WorldMatrix,isPlural:!1},{semantic:q.BaseColorFactor,isPlural:!1,prefix:"material."},{semantic:q.ViewMatrix,isPlural:!1},{semantic:q.ProjectionMatrix,isPlural:!1},{semantic:q.NormalMatrix,isPlural:!1},{semantic:q.BaseColorTexture,isPlural:!1,prefix:"material."},{semantic:q.BoneMatrix,isPlural:!0},{semantic:q.LightNumber,isPlural:!1},{semantic:q.MetallicRoughnessFactor,isPlural:!1,prefix:"material."},{semantic:q.BrdfLutTexture,isPlural:!1},{semantic:q.DiffuseEnvTexture,isPlural:!1},{semantic:q.SpecularEnvTexture,isPlural:!1},{semantic:q.IBLParameter,isPlural:!1}],a=[];for(let e=0;e<J.a.maxLightNumberInShader;e++)a.push({semanticStr:q.LightPosition,isPlural:!1,prefix:`lights[${e}].`,index:e}),a.push({semanticStr:q.LightDirection,isPlural:!1,prefix:`lights[${e}].`,index:e}),a.push({semanticStr:q.LightIntensity,isPlural:!1,prefix:`lights[${e}].`,index:e});this.__webglResourceRepository.setupUniformLocations(this.__shaderProgramUid,i.concat(a))}$load(e){return he(this,void 0,void 0,function*(){const t=e.getPrimitiveNumber();for(let r=0;r<t;r++){const t=e.getPrimitiveAt(r),i=this.__webglResourceRepository.createVertexDataResources(t);ge.__vertexHandleOfPrimitiveObjectUids.set(t.primitiveUid,i)}this.__dummyWhiteTextureUid=this.__webglResourceRepository.createDummyTexture(),this.__dummyBlackCubeTextureUid=this.__webglResourceRepository.createDummyCubeTexture();const r=_e.a.getInstance().getModule("pbr").pbrCookTorranceBrdfLutDataUrl;this.__pbrCookTorranceBrdfLutDataUrlUid=yield this.__webglResourceRepository.createTextureFromDataUri(r,{level:0,internalFormat:s.a.RGBA,border:0,format:s.a.RGBA,type:u.a.Float,magFilter:o.a.Nearest,minFilter:o.a.Nearest,wrapS:o.a.ClampToEdge,wrapT:o.a.ClampToEdge,generateMipmap:!1,anisotropy:!1})})}$prerender(e,t){const r=[],i=e.getPrimitiveNumber();for(let n=0;n<i;n++){const i=e.getPrimitiveAt(n);r[n]=ge.__vertexHandleOfPrimitiveObjectUids.get(i.primitiveUid),r[n].setComplete,this.__webglResourceRepository.setVertexDataToPipeline(r[n],i,t),r[n].setComplete=!0}}common_$prerender(){const e=ue.a.getInstance();this.__lightComponents=e.getComponentsWithType(ce.a)}attachGPUData(){}attatchShaderProgram(){this.__shaderProgramUid;this.__webglResourceRepository.currentWebGLContextWrapper.getRawContext().useProgram(this.__shaderProgram)}attachVertexData(e,t,r,i){const n=ge.__vertexHandleOfPrimitiveObjectUids.get(t.primitiveUid),a=this.__webglResourceRepository.getWebGLResource(n.vaoHandle),o=r.getRawContext();if(null!=a)r.bindVertexArray(a);else{this.__webglResourceRepository.setVertexDataToPipeline(n,t,i);const e=this.__webglResourceRepository.getWebGLResource(n.iboHandle);o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,e)}}dettachVertexData(e){const t=e.getRawContext();e.bindVertexArray&&e.bindVertexArray(null),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.bindBuffer(t.ARRAY_BUFFER,null)}static getInstance(){return this.__instance||(this.__instance=new ge),this.__instance}common_$render(e,t){const r=this.__webglResourceRepository.currentWebGLContextWrapper;this.attatchShaderProgram();r.getRawContext();return this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.ViewMatrix,!0,4,"f",!0,{x:e.v}),this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.ProjectionMatrix,!0,4,"f",!0,{x:t.v}),!1}$render(e,t,r,i,a,o,s){const l=this.__webglResourceRepository.currentWebGLContextWrapper;this.attatchShaderProgram();const u=l.getRawContext();this.attachVertexData(e,t,l,n.a.InvalidCGAPIResourceUid),this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.WorldMatrix,!0,4,"f",!0,{x:oe.a.transpose(r).v}),this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.NormalMatrix,!0,3,"f",!0,{x:i.v});const c=t.material,_=[],h=[];c?(_[0]=c.baseColor.r,_[1]=c.baseColor.g,_[2]=c.baseColor.b,_[3]=c.alpha,h[0]=c.metallicFactor,h[1]=c.roughnessFactor):(_[0]=1,_[1]=1,_[2]=1,_[3]=1,h[0]=1,h[1]=1),this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.BaseColorFactor,!1,4,"f",!0,{x:_}),this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.MetallicRoughnessFactor,!1,2,"f",!0,{x:h}),this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.LightNumber,!1,1,"i",!1,{x:this.__lightComponents.length});for(let e=0;e<this.__lightComponents.length&&!(e>=J.a.maxLightNumberInShader);e++){const t=this.__lightComponents[e],r=t.entity.getSceneGraph().worldPosition,i=t.direction,n=t.intensity;this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.LightPosition,!1,4,"f",!1,{x:r.x,y:r.y,z:r.z,w:t.type.index},e),this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.LightDirection,!1,4,"f",!1,{x:i.x,y:i.y,z:i.z,w:0},e),this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.LightIntensity,!1,4,"f",!1,{x:n.x,y:n.y,z:n.z,w:0},e)}const g=a.getComponent(se.a);if(g){const e=g.jointMatrices;this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.BoneMatrix,!0,4,"f",!0,{x:e})}if(this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.BaseColorTexture,!1,1,"i",!1,{x:0}),u.activeTexture(u.TEXTURE0),c&&c.baseColorTexture){const e=this.__webglResourceRepository.getWebGLResource(c.baseColorTexture.texture3DAPIResourseUid);u.bindTexture(u.TEXTURE_2D,e)}else{const e=this.__webglResourceRepository.getWebGLResource(this.__dummyWhiteTextureUid);u.bindTexture(u.TEXTURE_2D,e)}if(this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.MetallicRoughnessTexture,!1,1,"i",!1,{x:1}),u.activeTexture(u.TEXTURE1),c&&c.metallicRoughnessTexture){const e=this.__webglResourceRepository.getWebGLResource(c.metallicRoughnessTexture.texture3DAPIResourseUid);u.bindTexture(u.TEXTURE_2D,e)}else{const e=this.__webglResourceRepository.getWebGLResource(this.__dummyWhiteTextureUid);u.bindTexture(u.TEXTURE_2D,e)}if(this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.BrdfLutTexture,!1,1,"i",!1,{x:2}),u.activeTexture(u.TEXTURE2),null!=this.__pbrCookTorranceBrdfLutDataUrlUid){const e=this.__webglResourceRepository.getWebGLResource(this.__pbrCookTorranceBrdfLutDataUrlUid);u.bindTexture(u.TEXTURE_2D,e)}else{const e=this.__webglResourceRepository.getWebGLResource(this.__dummyWhiteTextureUid);u.bindTexture(u.TEXTURE_2D,e)}if(this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.DiffuseEnvTexture,!1,1,"i",!1,{x:3}),u.activeTexture(u.TEXTURE3),o&&o.isTextureReady){const e=this.__webglResourceRepository.getWebGLResource(o.cubeTextureUid);u.bindTexture(u.TEXTURE_CUBE_MAP,e)}else{const e=this.__webglResourceRepository.getWebGLResource(this.__dummyBlackCubeTextureUid);u.bindTexture(u.TEXTURE_CUBE_MAP,e)}if(this.__webglResourceRepository.setUniformValue(this.__shaderProgramUid,q.SpecularEnvTexture,!1,1,"i",!1,{x:4}),u.activeTexture(u.TEXTURE4),s&&s.isTextureReady){const e=this.__webglResourceRepository.getWebGLResource(s.cubeTextureUid);u.bindTexture(u.TEXTURE_CUBE_MAP,e)}else{const e=this.__webglResourceRepository.getWebGLResource(this.__dummyBlackCubeTextureUid);u.bindTexture(u.TEXTURE_CUBE_MAP,e)}u.drawElements(t.primitiveMode.index,t.indicesAccessor.elementCount,t.indicesAccessor.componentType.index,0),u.bindTexture(u.TEXTURE_2D,null),u.useProgram(null),this.dettachVertexData(l)}}ge.__vertexHandleOfPrimitiveObjectUids=new Map;var de=function(e){return e.index===i.a.UBOWebGL2.index?Q.getInstance():e.index===i.a.TransformFeedbackWebGL2.index?ne.getInstance():e.index===i.a.UniformWebGL1.index?ge.getInstance():ae.getInstance()};const me=Object.freeze({getRenderingStrategy:de,GLSLShader:Z,WebGLContextWrapper:w,WebGLResourceRepository:E,WebGLStrategyDataTexture:ae,WebGLStrategyTransformFeedback:ne,WebGLStrategyUBO:Q,WebGLStrategyUniform:ge});t.default=me}}]);
(0,eval)('this').Rn.WEBGL_VERSION='version: 0.1.1-103-g5f34-mod branch: feature/pbr';
