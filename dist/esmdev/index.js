var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a2, b) => (typeof require !== "undefined" ? require : a2)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from32, except, desc) => {
  if (from32 && typeof from32 === "object" || typeof from32 === "function") {
    for (let key of __getOwnPropNames(from32))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from32[key], enumerable: !(desc = __getOwnPropDesc(from32, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/foundation/math/MathUtil.ts
function radianToDegree(rad) {
  return rad * 180 / Math.PI;
}
function degreeToRadian(deg) {
  return deg * Math.PI / 180;
}
function isPowerOfTwo(x) {
  return (x & x - 1) == 0;
}
function isPowerOfTwoTexture(width, height) {
  return isPowerOfTwo(width) && isPowerOfTwo(height);
}
function packNormalizedVec4ToVec2(x, y, z, w, criteria) {
  x = (x + 1) / 2;
  y = (y + 1) / 2;
  z = (z + 1) / 2;
  w = (w + 1) / 2;
  const ir = Math.floor(x * (criteria - 1));
  const ig = Math.floor(y * (criteria - 1));
  const irg = ir * criteria + ig;
  const v0 = irg / criteria;
  const ib = Math.floor(z * (criteria - 1));
  const ia = Math.floor(w * (criteria - 1));
  const iba = ib * criteria + ia;
  const v1 = iba / criteria;
  return [
    v0,
    v1
  ];
}
function erf(x) {
  let sign = 1;
  if (x < 0) sign = -1;
  x = Math.abs(x);
  const t2 = 1 / (1 + 0.3275911 * x);
  const y = 1 - ((((1.061405429 * t2 + -1.453152027) * t2 + 1.421413741) * t2 + -0.284496736) * t2 + 0.254829592) * t2 * Math.exp(-x * x);
  return sign * y;
}
function invErf(x) {
  let w, p2 = 0;
  w = -Math.log((1 - x) * (1 + x));
  if (w < 5) {
    w = w - 2.5;
    p2 = 281022636e-16;
    p2 = 343273939e-15 + p2 * w;
    p2 = -35233877e-13 + p2 * w;
    p2 = -439150654e-14 + p2 * w;
    p2 = 21858087e-11 + p2 * w;
    p2 = -0.00125372503 + p2 * w;
    p2 = -0.00417768164 + p2 * w;
    p2 = 0.246640727 + p2 * w;
    p2 = 1.50140941 + p2 * w;
  } else {
    w = Math.sqrt(w) - 3;
    p2 = -200214257e-12;
    p2 = 100950558e-12 + p2 * w;
    p2 = 0.00134934322 + p2 * w;
    p2 = -0.00367342844 + p2 * w;
    p2 = 0.00573950773 + p2 * w;
    p2 = -0.0076224613 + p2 * w;
    p2 = 0.00943887047 + p2 * w;
    p2 = 1.00167406 + p2 * w;
    p2 = 2.83297682 + p2 * w;
  }
  return p2 * x;
}
function gaussianCdf(x, mu, sigma) {
  const U2 = 0.5 * (1 + erf((x - mu) / (sigma * Math.sqrt(2))));
  return U2;
}
function invGaussianCdf(U2, mu, sigma) {
  const x = sigma * Math.sqrt(2) * invErf(2 * U2 - 1) + mu;
  return x;
}
function computeEigenValuesAndVectors(A2, Q2, w) {
  const n2 = 3;
  let sd = 0;
  let so = 0;
  let s2 = 0;
  let c2 = 0;
  let t2 = 0;
  let g2 = 0;
  let h = 0;
  let z = 0;
  let theta = 0;
  let thresh = 0;
  for (let i2 = 0; i2 < n2; i2++) {
    Q2.setAt(i2, i2, 1);
    for (let j = 0; j < i2; j++) {
      Q2.setAt(i2, j, 0);
      Q2.setAt(j, i2, 0);
    }
  }
  for (let i2 = 0; i2 < n2; i2++) w.setAt(i2, A2.at(i2, i2));
  sd = 0;
  for (let i2 = 0; i2 < n2; i2++) sd += Math.abs(w.at(i2));
  sd = sd * sd;
  for (let nIter = 0; nIter < 50; nIter++) {
    so = 0;
    for (let p2 = 0; p2 < n2; p2++) {
      for (let q = p2 + 1; q < n2; q++) so += Math.abs(A2.at(p2, q));
    }
    if (so == 0) return 0;
    if (nIter < 4) thresh = 0.2 * so / (n2 * n2);
    else thresh = 0;
    for (let p2 = 0; p2 < n2; p2++) {
      for (let q = p2 + 1; q < n2; q++) {
        g2 = 100 * Math.abs(A2.at(p2, q));
        if (nIter > 4 && Math.abs(w.at(p2)) + g2 == Math.abs(w.at(p2)) && Math.abs(w.at(q)) + g2 == Math.abs(w.at(q))) {
          A2.setAt(p2, q, 0);
        } else if (Math.abs(A2.at(p2, q)) > thresh) {
          h = w.at(q) - w.at(p2);
          if (Math.abs(h) + g2 == Math.abs(h)) {
            t2 = A2.at(p2, q) / h;
          } else {
            theta = 0.5 * h / A2.at(p2, q);
            if (theta < 0) t2 = -1 / (Math.sqrt(1 + theta * theta) - theta);
            else t2 = 1 / (Math.sqrt(1 + theta * theta) + theta);
          }
          c2 = 1 / Math.sqrt(1 + t2 * t2);
          s2 = t2 * c2;
          z = t2 * A2.at(p2, q);
          A2.setAt(p2, q, 0);
          w.setAt(p2, w.at(p2) - z);
          w.setAt(q, w.at(q) + z);
          for (let r2 = 0; r2 < p2; r2++) {
            t2 = A2.at(r2, p2);
            A2.setAt(r2, p2, c2 * t2 - s2 * A2.at(r2, q));
            A2.setAt(r2, q, s2 * t2 + c2 * A2.at(r2, q));
          }
          for (let r2 = p2 + 1; r2 < q; r2++) {
            t2 = A2.at(p2, r2);
            A2.setAt(p2, r2, c2 * t2 - s2 * A2.at(r2, q));
            A2.setAt(r2, q, s2 * t2 + c2 * A2.at(r2, q));
          }
          for (let r2 = q + 1; r2 < n2; r2++) {
            t2 = A2.at(p2, r2);
            A2.setAt(p2, r2, c2 * t2 - s2 * A2.at(q, r2));
            A2.setAt(q, r2, s2 * t2 + c2 * A2.at(q, r2));
          }
          for (let r2 = 0; r2 < n2; r2++) {
            t2 = Q2.at(r2, p2);
            Q2.setAt(r2, p2, c2 * t2 - s2 * Q2.at(r2, q));
            Q2.setAt(r2, q, s2 * t2 + c2 * Q2.at(r2, q));
          }
        }
      }
    }
  }
  return -1;
}
function convertToStringAsGLSLFloat(value) {
  if (Number.isInteger(value)) {
    return `${value}.0`;
  } else {
    return "" + value;
  }
}
function nearZeroToZero(value) {
  if (Math.abs(value) < 1e-5) {
    value = 0;
  } else if (0.99999 < value && value < 1.00001) {
    value = 1;
  } else if (-1.00001 < value && value < -0.99999) {
    value = -1;
  }
  return value;
}
function financial(val) {
  const fixedStr = Number.parseFloat(val).toFixed(7);
  if (val >= 0) {
    return " " + fixedStr;
  }
  return fixedStr;
}
function roundAsFloat(value) {
  return Math.round(value * 1e7) / 1e7;
}
function lerp(a2, b, t2) {
  return a2 * (1 - t2) + b * t2;
}
function computeGaussianDistributionRatioWhoseSumIsOne({ kernelSize, variance, mean = 0, effectiveDigit = 4 }) {
  const ceiledHalfKernelSize = Math.ceil(kernelSize / 2);
  const gaussianDistributionRatio = new Array(ceiledHalfKernelSize);
  let totalSize = 0;
  for (let i2 = 0; i2 < ceiledHalfKernelSize; i2++) {
    gaussianDistributionRatio[i2] = Math.exp(-((i2 - mean) ** 2) / (2 * variance));
    totalSize += gaussianDistributionRatio[i2];
  }
  totalSize *= 2;
  if (kernelSize / 2 % 2 !== 0) {
    totalSize -= gaussianDistributionRatio[0];
  }
  const gaussianDistributionRatioWhoseSumIsOne = new Array(kernelSize);
  let totalRatio = 0;
  const changeDigitParam = Math.pow(10, effectiveDigit);
  for (let i2 = 0; i2 < ceiledHalfKernelSize - 1; i2++) {
    let ratio = gaussianDistributionRatio[ceiledHalfKernelSize - 1 - i2] / totalSize;
    ratio *= changeDigitParam;
    ratio = Math.round(ratio);
    ratio /= changeDigitParam;
    gaussianDistributionRatioWhoseSumIsOne[i2] = ratio;
    gaussianDistributionRatioWhoseSumIsOne[kernelSize - 1 - i2] = ratio;
    totalRatio += 2 * ratio;
  }
  if (kernelSize % 2 === 0) {
    const value = (1 - totalRatio) / 2;
    gaussianDistributionRatioWhoseSumIsOne[ceiledHalfKernelSize - 1] = value;
    gaussianDistributionRatioWhoseSumIsOne[ceiledHalfKernelSize] = value;
  } else {
    const value = 1 - totalRatio;
    gaussianDistributionRatioWhoseSumIsOne[ceiledHalfKernelSize - 1] = value;
  }
  return gaussianDistributionRatioWhoseSumIsOne;
}
var toHalfFloat, MathUtil;
var init_MathUtil = __esm({
  "src/foundation/math/MathUtil.ts"() {
    "use strict";
    __name(radianToDegree, "radianToDegree");
    __name(degreeToRadian, "degreeToRadian");
    toHalfFloat = /* @__PURE__ */ __name(() => {
      return /* @__PURE__ */ __name(function toHalf(val) {
        const floatView = new Float32Array(1);
        const int32View = new Int32Array(floatView.buffer);
        floatView[0] = val;
        const x = int32View[0];
        let bits = x >> 16 & 32768;
        let m = x >> 12 & 2047;
        const e3 = x >> 23 & 255;
        if (e3 < 103) {
          return bits;
        }
        if (e3 > 142) {
          bits |= 31744;
          bits |= (e3 == 255 ? 0 : 1) && x & 8388607;
          return bits;
        }
        if (e3 < 113) {
          m |= 2048;
          bits |= (m >> 114 - e3) + (m >> 113 - e3 & 1);
          return bits;
        }
        bits |= e3 - 112 << 10 | m >> 1;
        bits += m & 1;
        return bits;
      }, "toHalf");
    }, "toHalfFloat");
    __name(isPowerOfTwo, "isPowerOfTwo");
    __name(isPowerOfTwoTexture, "isPowerOfTwoTexture");
    __name(packNormalizedVec4ToVec2, "packNormalizedVec4ToVec2");
    __name(erf, "erf");
    __name(invErf, "invErf");
    __name(gaussianCdf, "gaussianCdf");
    __name(invGaussianCdf, "invGaussianCdf");
    __name(computeEigenValuesAndVectors, "computeEigenValuesAndVectors");
    __name(convertToStringAsGLSLFloat, "convertToStringAsGLSLFloat");
    __name(nearZeroToZero, "nearZeroToZero");
    __name(financial, "financial");
    __name(roundAsFloat, "roundAsFloat");
    __name(lerp, "lerp");
    __name(computeGaussianDistributionRatioWhoseSumIsOne, "computeGaussianDistributionRatioWhoseSumIsOne");
    MathUtil = Object.freeze({
      radianToDegree,
      degreeToRadian,
      toHalfFloat,
      isPowerOfTwo,
      isPowerOfTwoTexture,
      packNormalizedVec4ToVec2,
      convertToStringAsGLSLFloat,
      nearZeroToZero,
      gaussianCdf,
      invGaussianCdf,
      computeEigenValuesAndVectors,
      computeGaussianDistributionRatioWhoseSumIsOne,
      roundAsFloat,
      financial,
      lerp
    });
  }
});

// src/foundation/misc/EnumIO.ts
function _from({ typeList: typeList32, index }) {
  const match = typeList32.find((type) => type.index === index);
  if (!match) {
    return void 0;
  }
  return match;
}
function _fromString({ typeList: typeList32, str }) {
  const match = typeList32.find((type) => type.str.toLowerCase() === str.toLowerCase());
  if (!match) {
    return void 0;
  }
  return match;
}
function _fromStringCaseSensitively({ typeList: typeList32, str }) {
  const match = typeList32.find((type) => type.str === str);
  if (!match) {
    return void 0;
  }
  return match;
}
var _EnumClass, EnumClass;
var init_EnumIO = __esm({
  "src/foundation/misc/EnumIO.ts"() {
    "use strict";
    _EnumClass = class _EnumClass {
      constructor({ index, str, noCheckStrUnique }) {
        __publicField(this, "index");
        __publicField(this, "symbol");
        __publicField(this, "str");
        if (_EnumClass.__indices.get(this.constructor) == null) {
          _EnumClass.__indices.set(this.constructor, []);
        }
        if (_EnumClass.__strings.get(this.constructor) == null) {
          _EnumClass.__strings.set(this.constructor, []);
        }
        if (_EnumClass.__indices.get(this.constructor).indexOf(index) !== -1) {
          throw new Error("Dont use duplicate index.");
        }
        if (noCheckStrUnique !== true) {
          if (_EnumClass.__strings.get(this.constructor).indexOf(str) !== -1) {
            throw new Error("Dont use duplicate str.");
          }
        }
        this.index = index;
        this.str = str;
        this.symbol = Symbol(str);
        _EnumClass.__indices.get(this.constructor).push(index);
        _EnumClass.__strings.get(this.constructor).push(str);
      }
      toString() {
        return this.str;
      }
      toJSON() {
        return this.index;
      }
    };
    __name(_EnumClass, "EnumClass");
    __publicField(_EnumClass, "__indices", /* @__PURE__ */ new Map());
    __publicField(_EnumClass, "__strings", /* @__PURE__ */ new Map());
    EnumClass = _EnumClass;
    __name(_from, "_from");
    __name(_fromString, "_fromString");
    __name(_fromStringCaseSensitively, "_fromStringCaseSensitively");
  }
});

// src/foundation/misc/Logger.ts
var LogLevel, _a, Log, _Logger, Logger;
var init_Logger = __esm({
  "src/foundation/misc/Logger.ts"() {
    "use strict";
    (function(LogLevel2) {
      LogLevel2[LogLevel2["Debug"] = 0] = "Debug";
      LogLevel2[LogLevel2["Info"] = 1] = "Info";
      LogLevel2[LogLevel2["Warn"] = 2] = "Warn";
      LogLevel2[LogLevel2["Error"] = 3] = "Error";
      LogLevel2[LogLevel2["Assert"] = 4] = "Assert";
    })(LogLevel || (LogLevel = {}));
    Log = (_a = class {
      constructor() {
        __publicField(this, "message", "");
        __publicField(this, "timestamp", 0);
        __publicField(this, "logLevel", 1);
      }
    }, __name(_a, "Log"), _a);
    _Logger = class _Logger {
      static __common(message, logLevel) {
        if (!this.isAccumulateLog && !this.isRichLog) {
          return message;
        }
        const log = new Log();
        log.message = message;
        log.timestamp = Date.now();
        log.logLevel = logLevel;
        if (this.isAccumulateLog) {
          this.__messages.push(log);
        }
        return this.__formatLogs(log);
      }
      static __clearAccumulatedLog() {
        this.__messages = [];
      }
      static __formatLogs(log) {
        if (!this.isRichLog) {
          return log.message;
        }
        const yyyymmdd = new Intl.DateTimeFormat(void 0, {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        });
        const dateTime = yyyymmdd.format(log.timestamp);
        const finalMessage = `Rn[${this.__getLogLevelText(log.logLevel)}][${dateTime}]: ${log.message}`;
        return finalMessage;
      }
      static __getLogLevelText(logLevel) {
        return LogLevel[logLevel];
      }
      static error(message) {
        if (this.logLevel <= 3) {
          const formattedMessage = this.__common(message, 3);
          console.error(formattedMessage);
          return formattedMessage;
        }
        return void 0;
      }
      static warn(message) {
        if (this.logLevel <= 2) {
          const formattedMessage = this.__common(message, 2);
          console.warn(formattedMessage);
          return formattedMessage;
        }
        return void 0;
      }
      static info(message) {
        if (this.logLevel <= 1) {
          const formattedMessage = this.__common(message, 1);
          console.info(formattedMessage);
          return formattedMessage;
        }
        return void 0;
      }
      static debug(message) {
        if (this.logLevel <= 0) {
          const formattedMessage = this.__common(message, 0);
          console.debug(formattedMessage);
          return formattedMessage;
        }
        return void 0;
      }
      static assert(condition, message) {
        if (this.logLevel <= 4) {
          const formattedMessage = this.__common(message, 4);
          console.assert(condition, formattedMessage);
          return formattedMessage;
        }
        return void 0;
      }
      static getAccumulatedLog() {
        return this.__messages.map((log) => this.__formatLogs(log));
      }
    };
    __name(_Logger, "Logger");
    __publicField(_Logger, "__messages", []);
    __publicField(_Logger, "logLevel", 2);
    __publicField(_Logger, "isRichLog", false);
    __publicField(_Logger, "isAccumulateLog", false);
    Logger = _Logger;
  }
});

// src/foundation/definitions/CompositionType.ts
function from(index) {
  return _from({
    typeList,
    index
  });
}
function fromString(str) {
  return _fromString({
    typeList,
    str
  });
}
function vectorFrom(componentN) {
  let str = "";
  switch (componentN) {
    case 1:
      str = "scalar";
      break;
    case 2:
      str = "vec2";
      break;
    case 3:
      str = "vec3";
      break;
    case 4:
      str = "vec4";
      break;
    default:
      Logger.error("not found appropriate Vectors");
  }
  return _fromString({
    typeList,
    str
  });
}
function fromGlslString(str_) {
  let str = str_;
  switch (str_) {
    case "bool":
      str = "scalar";
      break;
    case "int":
      str = "scalar";
      break;
    case "float":
      str = "scalar";
      break;
    case "ivec2":
      str = "vec2";
      break;
    case "ivec3":
      str = "vec3";
      break;
    case "ivec4":
      str = "vec4";
      break;
    case "sampler2D":
      str = "TEXTURE_2D";
      break;
    case "sampler2DShadow":
      str = "TEXTURE_2D_SHADOW";
      break;
    case "sampler2DRect":
      str = "TEXTURE_2D_RECT";
      break;
    case "samplerCube":
      str = "TEXTURE_CUBE_MAP";
      break;
  }
  return _fromString({
    typeList,
    str
  });
}
function fromWgslString(str_) {
  let str = str_;
  switch (str_) {
    case "bool":
      str = "scalar";
      break;
    case "i32":
      str = "scalar";
      break;
    case "u32":
      str = "scalar";
      break;
    case "f32":
      str = "scalar";
      break;
    case "vec2<f32>":
      str = "vec2";
      break;
    case "vec3<f32>":
      str = "vec3";
      break;
    case "vec4<f32>":
      str = "vec4";
      break;
    case "mat2x2<f32>":
      str = "mat2";
      break;
    case "mat3x3<f32>":
      str = "mat3";
      break;
    case "mat4x4<f32>":
      str = "mat4";
      break;
    case "vec2<i32>":
      str = "vec2";
      break;
    case "vec3<i32>":
      str = "vec3";
      break;
    case "vec4<i32>":
      str = "vec4";
      break;
    case "mat2x2<i32>":
      str = "mat2";
      break;
    case "mat3x3<i32>":
      str = "mat3";
      break;
    case "mat4x4<i32>":
      str = "mat4";
      break;
    case "sampler_2d":
      str = "TEXTURE_2D";
      break;
    case "sampler_2d_shadow":
      str = "TEXTURE_2D_SHADOW";
      break;
    case "sampler_cube":
      str = "TEXTURE_CUBE_MAP";
      break;
  }
  return _fromString({
    typeList,
    str
  });
}
function toGltf2AccessorCompositionTypeString(componentN) {
  switch (componentN) {
    case 1:
      return "SCALAR";
    case 2:
      return "VEC2";
    case 3:
      return "VEC3";
    case 4:
      return "VEC4";
    case 9:
      return "MAT3";
    case 16:
      return "MAT4";
    default:
      throw new Error("Invalid componentN");
  }
}
function toGltf2AnimationAccessorCompositionTypeString(componentN) {
  switch (componentN) {
    case 1:
      return "SCALAR";
    case 2:
      return "VEC2";
    case 3:
      return "VEC3";
    case 4:
      return "VEC4";
    default:
      throw new Error("Invalid componentN");
  }
}
function toGltf2SquareMatrixAccessorCompositionTypeString(componentN) {
  switch (componentN) {
    case 4:
      return "VEC4";
    case 9:
      return "MAT3";
    case 16:
      return "MAT4";
    default:
      throw new Error("Invalid componentN");
  }
}
function toGltf2AnimationAccessorCompositionType(componentN) {
  switch (componentN) {
    case 1:
      return Scalar;
    case 2:
      return Vec2;
    case 3:
      return Vec3;
    case 4:
      return Vec4;
    default:
      throw new Error("Invalid componentN");
  }
}
function isArray(compositionType) {
  if (compositionType === ScalarArray || compositionType === Vec2Array || compositionType === Vec3Array || compositionType === Vec4Array || compositionType === Mat4x3Array || compositionType === Mat4Array || compositionType === Mat3Array || compositionType === Mat2Array) {
    return true;
  } else {
    return false;
  }
}
function isTexture(compositionType) {
  if (compositionType === Texture2D || compositionType === TextureCube || compositionType === Texture2DShadow || compositionType === Texture2DRect) {
    return true;
  } else {
    return false;
  }
}
var _a2, CompositionTypeClass, Unknown, Scalar, Vec2, Vec3, Vec4, Mat2, Mat3, Mat4, Texture2D, TextureCube, ScalarArray, Vec2Array, Vec3Array, Vec4Array, Mat4Array, Mat3Array, Mat2Array, Texture2DShadow, Texture2DRect, Mat4x3Array, typeList, CompositionType;
var init_CompositionType = __esm({
  "src/foundation/definitions/CompositionType.ts"() {
    "use strict";
    init_EnumIO();
    init_Logger();
    CompositionTypeClass = (_a2 = class extends EnumClass {
      constructor({ index, str, glslStr, hlslStr, wgsl, webgpu, numberOfComponents, vec4SizeOfProperty, isArray: isArray2 = false }) {
        super({
          index,
          str
        });
        __publicField(this, "__numberOfComponents");
        __publicField(this, "__glslStr");
        __publicField(this, "__hlslStr");
        __publicField(this, "__webgpuStr");
        __publicField(this, "__wgslStr");
        __publicField(this, "__isArray");
        __publicField(this, "__vec4SizeOfProperty");
        __publicField(this, "__dummyStr");
        this.__numberOfComponents = numberOfComponents;
        this.__glslStr = glslStr;
        this.__hlslStr = hlslStr;
        this.__vec4SizeOfProperty = vec4SizeOfProperty;
        this.__isArray = isArray2;
        this.__webgpuStr = webgpu;
        this.__wgslStr = wgsl;
        this.__dummyStr = str;
      }
      get webgpu() {
        return this.__webgpuStr;
      }
      get wgsl() {
        return this.__wgslStr;
      }
      getNumberOfComponents() {
        return this.__numberOfComponents;
      }
      getGlslStr(componentType) {
        if (componentType.index === 5126 || // FLOAT
        componentType.index === 5127 || // DOUBLE
        this === CompositionType.Texture2D || this === CompositionType.Texture2DShadow || this === CompositionType.Texture2DRect || this === CompositionType.TextureCube) {
          return this.__glslStr;
        } else if (componentType.index === 5120 || // BYTE
        componentType.index === 5122 || // SHORT
        componentType.index === 5124) {
          if (this === CompositionType.Scalar || this === CompositionType.ScalarArray) {
            return "int";
          } else {
            return "i" + this.__glslStr;
          }
        } else if (componentType.index === 35670) {
          return "bool";
        }
        return "unknown";
      }
      getGlslInitialValue(componentType) {
        if (componentType.index === 5126 || // FLOAT
        componentType.index === 5127) {
          if (this === CompositionType.Scalar) {
            return "0.0";
          } else {
            if (this.__numberOfComponents === 2) {
              return this.__glslStr + "(0.0, 0.0)";
            } else if (this.__numberOfComponents === 3) {
              return this.__glslStr + "(0.0, 0.0, 0.0)";
            } else if (this.__numberOfComponents === 4) {
              return this.__glslStr + "(0.0, 0.0, 0.0, 0.0)";
            } else if (this.__numberOfComponents === 9) {
              return this.__glslStr + "(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)";
            } else if (this.__numberOfComponents === 16) {
              return this.__glslStr + "(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)";
            }
          }
        } else if (componentType.index === 5120 || // BYTE
        componentType.index === 5122 || // SHORT
        componentType.index === 5124) {
          if (this === CompositionType.Scalar) {
            return "0";
          } else {
            if (this.__numberOfComponents === 2) {
              return this.__glslStr + "(0, 0)";
            } else if (this.__numberOfComponents === 3) {
              return this.__glslStr + "(0, 0, 0)";
            } else if (this.__numberOfComponents === 4) {
              return this.__glslStr + "(0, 0, 0, 0)";
            } else if (this.__numberOfComponents === 9) {
              return this.__glslStr + "(0, 0, 0, 0, 0, 0, 0, 0, 0)";
            } else if (this.__numberOfComponents === 16) {
              return this.__glslStr + "(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)";
            }
          }
        } else if (componentType.index === 35670) {
          if (this === CompositionType.Scalar) {
            return "false";
          } else {
            if (this.__numberOfComponents === 2) {
              return this.__glslStr + "(false, false)";
            } else if (this.__numberOfComponents === 3) {
              return this.__glslStr + "(false, false, false)";
            } else if (this.__numberOfComponents === 4) {
              return this.__glslStr + "(false, false, false, false)";
            }
          }
        }
        return "unknown";
      }
      getWgslInitialValue(componentType) {
        const type = this.toWGSLType(componentType);
        if (componentType.index === 5126 || // FLOAT
        componentType.index === 5127) {
          if (this === CompositionType.Scalar) {
            return "0.0";
          } else {
            if (this.__numberOfComponents === 2) {
              return type + "(0.0, 0.0)";
            } else if (this.__numberOfComponents === 3) {
              return type + "(0.0, 0.0, 0.0)";
            } else if (this.__numberOfComponents === 4) {
              return type + "(0.0, 0.0, 0.0, 0.0)";
            } else if (this.__numberOfComponents === 9) {
              return type + "(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)";
            } else if (this.__numberOfComponents === 16) {
              return type + "(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)";
            }
          }
        } else if (componentType.index === 5120 || // BYTE
        componentType.index === 5122 || // SHORT
        componentType.index === 5124) {
          if (this === CompositionType.Scalar) {
            return "0";
          } else {
            if (this.__numberOfComponents === 2) {
              return type + "(0, 0)";
            } else if (this.__numberOfComponents === 3) {
              return type + "(0, 0, 0)";
            } else if (this.__numberOfComponents === 4) {
              return type + "(0, 0, 0, 0)";
            } else if (this.__numberOfComponents === 9) {
              return type + "(0, 0, 0, 0, 0, 0, 0, 0, 0)";
            } else if (this.__numberOfComponents === 16) {
              return type + "(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)";
            }
          }
        } else if (componentType.index === 35670) {
          if (this === CompositionType.Scalar) {
            return "false";
          } else {
            if (this.__numberOfComponents === 2) {
              return type + "(false, false)";
            } else if (this.__numberOfComponents === 3) {
              return type + "(false, false, false)";
            } else if (this.__numberOfComponents === 4) {
              return type + "(false, false, false, false)";
            }
          }
        }
        return "unknown";
      }
      toWGSLType(componentType) {
        return this.__wgslStr.replace("#", componentType.wgsl);
      }
      getVec4SizeOfProperty() {
        return this.__vec4SizeOfProperty;
      }
    }, __name(_a2, "CompositionTypeClass"), _a2);
    Unknown = new CompositionTypeClass({
      index: -1,
      str: "UNKNOWN",
      glslStr: "unknown",
      hlslStr: "unknown",
      wgsl: "unknown",
      webgpu: "unknown",
      numberOfComponents: 0,
      vec4SizeOfProperty: 0
    });
    Scalar = new CompositionTypeClass({
      index: 0,
      str: "SCALAR",
      glslStr: "float",
      hlslStr: "float",
      wgsl: "#",
      webgpu: "",
      numberOfComponents: 1,
      vec4SizeOfProperty: 1
    });
    Vec2 = new CompositionTypeClass({
      index: 1,
      str: "VEC2",
      glslStr: "vec2",
      hlslStr: "float2",
      wgsl: "vec2<#>",
      webgpu: "x2",
      numberOfComponents: 2,
      vec4SizeOfProperty: 1
    });
    Vec3 = new CompositionTypeClass({
      index: 2,
      str: "VEC3",
      glslStr: "vec3",
      hlslStr: "float3",
      wgsl: "vec3<#>",
      webgpu: "x3",
      numberOfComponents: 3,
      vec4SizeOfProperty: 1
    });
    Vec4 = new CompositionTypeClass({
      index: 3,
      str: "VEC4",
      glslStr: "vec4",
      hlslStr: "float4",
      wgsl: "vec4<#>",
      webgpu: "x4",
      numberOfComponents: 4,
      vec4SizeOfProperty: 1
    });
    Mat2 = new CompositionTypeClass({
      index: 4,
      str: "MAT2",
      glslStr: "mat2",
      hlslStr: "float2x2",
      wgsl: "mat2x2<#>",
      webgpu: "unknown",
      numberOfComponents: 4,
      vec4SizeOfProperty: 2
    });
    Mat3 = new CompositionTypeClass({
      index: 5,
      str: "MAT3",
      glslStr: "mat3",
      hlslStr: "float3x3",
      wgsl: "mat3x3<#>",
      webgpu: "unknown",
      numberOfComponents: 9,
      vec4SizeOfProperty: 3
    });
    Mat4 = new CompositionTypeClass({
      index: 6,
      str: "MAT4",
      glslStr: "mat4",
      hlslStr: "float4x4",
      wgsl: "mat4x4<#>",
      webgpu: "unknown",
      numberOfComponents: 16,
      vec4SizeOfProperty: 4
    });
    Texture2D = new CompositionTypeClass({
      index: 7,
      str: "TEXTURE_2D",
      glslStr: "sampler2D",
      hlslStr: "Texture2D",
      wgsl: "texture_2d",
      webgpu: "texture_2d",
      numberOfComponents: 1,
      vec4SizeOfProperty: 1
    });
    TextureCube = new CompositionTypeClass({
      index: 8,
      str: "TEXTURE_CUBE_MAP",
      glslStr: "samplerCube",
      hlslStr: "TextureCube",
      wgsl: "texture_cube",
      webgpu: "texture_cube",
      numberOfComponents: 1,
      vec4SizeOfProperty: 1
    });
    ScalarArray = new CompositionTypeClass({
      index: 9,
      str: "SCALAR_ARRAY",
      glslStr: "float",
      hlslStr: "float",
      wgsl: "#",
      webgpu: "unknown",
      numberOfComponents: 1,
      vec4SizeOfProperty: 1,
      isArray: true
    });
    Vec2Array = new CompositionTypeClass({
      index: 10,
      str: "VEC2_ARRAY",
      glslStr: "vec2",
      hlslStr: "float2",
      wgsl: "vec2<#>",
      webgpu: "unknown",
      numberOfComponents: 2,
      vec4SizeOfProperty: 1,
      isArray: true
    });
    Vec3Array = new CompositionTypeClass({
      index: 11,
      str: "VEC3_ARRAY",
      glslStr: "vec3",
      hlslStr: "float3",
      wgsl: "vec3<#>",
      webgpu: "unknown",
      numberOfComponents: 3,
      vec4SizeOfProperty: 1,
      isArray: true
    });
    Vec4Array = new CompositionTypeClass({
      index: 12,
      str: "VEC4_ARRAY",
      glslStr: "vec4",
      hlslStr: "float4",
      wgsl: "vec4<#>",
      webgpu: "unknown",
      numberOfComponents: 4,
      vec4SizeOfProperty: 1,
      isArray: true
    });
    Mat4Array = new CompositionTypeClass({
      index: 13,
      str: "MAT4_ARRAY",
      glslStr: "mat4",
      hlslStr: "float4x4",
      wgsl: "mat4x4<#>",
      webgpu: "unknown",
      numberOfComponents: 16,
      vec4SizeOfProperty: 4,
      isArray: true
    });
    Mat3Array = new CompositionTypeClass({
      index: 14,
      str: "MAT3_ARRAY",
      glslStr: "mat3",
      hlslStr: "float3x3",
      wgsl: "mat3x3<#>",
      webgpu: "unknown",
      numberOfComponents: 9,
      vec4SizeOfProperty: 3,
      isArray: true
    });
    Mat2Array = new CompositionTypeClass({
      index: 15,
      str: "MAT2_ARRAY",
      glslStr: "mat2",
      hlslStr: "float2x2",
      wgsl: "mat2x2<#>",
      webgpu: "unknown",
      numberOfComponents: 4,
      vec4SizeOfProperty: 2,
      isArray: true
    });
    Texture2DShadow = new CompositionTypeClass({
      index: 16,
      str: "TEXTURE_2D_SHADOW",
      glslStr: "highp sampler2DShadow",
      hlslStr: "Texture2D",
      wgsl: "texture_2d",
      webgpu: "texture_2d",
      numberOfComponents: 1,
      vec4SizeOfProperty: 1
    });
    Texture2DRect = new CompositionTypeClass({
      index: 17,
      str: "TEXTURE_2D_RECT",
      glslStr: "sampler2DRect",
      hlslStr: "Texture2D",
      wgsl: "texture_2d",
      webgpu: "texture_2d",
      numberOfComponents: 1,
      vec4SizeOfProperty: 1
    });
    Mat4x3Array = new CompositionTypeClass({
      index: 18,
      str: "MAT4x3_ARRAY",
      glslStr: "mat4x3",
      hlslStr: "float4x3",
      wgsl: "mat4x3<#>",
      webgpu: "unknown",
      numberOfComponents: 12,
      vec4SizeOfProperty: 3,
      isArray: true
    });
    typeList = [
      Unknown,
      Scalar,
      Vec2,
      Vec3,
      Vec4,
      Mat2,
      Mat3,
      Mat4,
      Vec2Array,
      Vec3Array,
      Vec4Array,
      ScalarArray,
      Mat2Array,
      Mat3Array,
      Mat4Array,
      Texture2D,
      Texture2DShadow,
      Texture2DRect,
      TextureCube,
      Mat4x3Array
    ];
    __name(from, "from");
    __name(fromString, "fromString");
    __name(vectorFrom, "vectorFrom");
    __name(fromGlslString, "fromGlslString");
    __name(fromWgslString, "fromWgslString");
    __name(toGltf2AccessorCompositionTypeString, "toGltf2AccessorCompositionTypeString");
    __name(toGltf2AnimationAccessorCompositionTypeString, "toGltf2AnimationAccessorCompositionTypeString");
    __name(toGltf2SquareMatrixAccessorCompositionTypeString, "toGltf2SquareMatrixAccessorCompositionTypeString");
    __name(toGltf2AnimationAccessorCompositionType, "toGltf2AnimationAccessorCompositionType");
    __name(isArray, "isArray");
    __name(isTexture, "isTexture");
    CompositionType = Object.freeze({
      Unknown,
      Scalar,
      Vec2,
      Vec3,
      Vec4,
      Mat2,
      Mat3,
      Mat4,
      ScalarArray,
      Vec2Array,
      Vec3Array,
      Vec4Array,
      Mat2Array,
      Mat3Array,
      Mat4Array,
      Texture2D,
      Texture2DShadow,
      TextureCube,
      Texture2DRect,
      Mat4x3Array,
      from,
      fromString,
      vectorFrom,
      fromGlslString,
      fromWgslString,
      isArray,
      isTexture,
      toGltf2AnimationAccessorCompositionType,
      toGltf2AccessorCompositionTypeString,
      toGltf2AnimationAccessorCompositionTypeString,
      toGltf2SquareMatrixAccessorCompositionTypeString
    });
  }
});

// src/foundation/math/AbstractVector.ts
var _AbstractVector, AbstractVector;
var init_AbstractVector = __esm({
  "src/foundation/math/AbstractVector.ts"() {
    "use strict";
    _AbstractVector = class _AbstractVector {
      constructor() {
        __publicField(this, "_v", new Float32Array());
      }
      get x() {
        return this._v[0];
      }
      get glslStrAsFloat() {
        throw new Error("Method not implemented.");
      }
      get glslStrAsInt() {
        throw new Error("Method not implemented.");
      }
      isEqual(vec, delta) {
        throw new Error("Method not implemented.");
      }
      isStrictEqual(vec) {
        throw new Error("Method not implemented.");
      }
      length() {
        throw new Error("Method not implemented.");
      }
      lengthSquared() {
        throw new Error("Method not implemented.");
      }
      lengthTo(vec) {
        throw new Error("Method not implemented.");
      }
      dot(vec) {
        throw new Error("Method not implemented.");
      }
      at(i2) {
        return this._v[i2];
      }
      toString() {
        throw new Error("Method not implemented.");
      }
      toStringApproximately() {
        throw new Error("Method not implemented.");
      }
      flattenAsArray() {
        throw new Error("Method not implemented.");
      }
      isDummy() {
        if (this._v.length === 0) {
          return true;
        } else {
          return false;
        }
      }
      v(i2) {
        return this._v[i2];
      }
      isTheSourceSame(arrayBuffer) {
        return this._v.buffer === arrayBuffer;
      }
      get className() {
        return this.constructor.name;
      }
      get bytesPerComponent() {
        throw new Error("Method not implemented.");
      }
    };
    __name(_AbstractVector, "AbstractVector");
    AbstractVector = _AbstractVector;
  }
});

// src/foundation/math/Vector3.ts
var _Vector3_, Vector3_, _Vector3, Vector3, _Vector3d, Vector3d, ConstVector3_1_1_1, ConstVector3_0_0_0;
var init_Vector3 = __esm({
  "src/foundation/math/Vector3.ts"() {
    "use strict";
    init_MathUtil();
    init_CompositionType();
    init_AbstractVector();
    init_Logger();
    _Vector3_ = class _Vector3_ extends AbstractVector {
      constructor(v, { type }) {
        super();
        this._v = v;
      }
      get x() {
        return this._v[0];
      }
      get y() {
        return this._v[1];
      }
      get z() {
        return this._v[2];
      }
      get w() {
        return 1;
      }
      get glslStrAsFloat() {
        return `vec3(${MathUtil.convertToStringAsGLSLFloat(this._v[0])}, ${MathUtil.convertToStringAsGLSLFloat(this._v[1])}, ${MathUtil.convertToStringAsGLSLFloat(this._v[2])})`;
      }
      get glslStrAsInt() {
        return `ivec3(${Math.floor(this._v[0])}, ${Math.floor(this._v[1])}, ${Math.floor(this._v[2])})`;
      }
      static get compositionType() {
        return CompositionType.Vec3;
      }
      /**
      * to square length(static version)
      */
      static lengthSquared(vec) {
        return vec.lengthSquared();
      }
      static lengthBtw(l_vec, r_vec) {
        return l_vec.lengthTo(r_vec);
      }
      static angleOfVectors(l_vec, r_vec) {
        const multipliedLength = l_vec.length() * r_vec.length();
        if (multipliedLength === 0) {
          Logger.error("length of a vector is 0!");
        }
        const cos_sita = l_vec.dot(r_vec) / multipliedLength;
        const sita = Math.acos(cos_sita);
        return sita;
      }
      static _zero(type) {
        return this._fromCopyArray([
          0,
          0,
          0
        ], type);
      }
      static _one(type) {
        return this._fromCopyArray([
          1,
          1,
          1
        ], type);
      }
      static _dummy(type) {
        return new this(new type([]), {
          type
        });
      }
      /**
      * normalize(static version)
      */
      static _normalize(vec, type) {
        const length = vec.length();
        return this._divide(vec, length, type);
      }
      /**
      * normalize(static version)
      */
      static normalizeTo(vec, out) {
        const length = vec.length();
        this.divideTo(vec, length, out);
        return out;
      }
      /**
      * add value（static version）
      */
      static _add(l_vec, r_vec, type) {
        const x = l_vec._v[0] + r_vec._v[0];
        const y = l_vec._v[1] + r_vec._v[1];
        const z = l_vec._v[2] + r_vec._v[2];
        return this._fromCopyArray([
          x,
          y,
          z
        ], type);
      }
      /**
      * add value（static version）
      */
      static addTo(l_vec, r_vec, out) {
        out._v[0] = l_vec._v[0] + r_vec._v[0];
        out._v[1] = l_vec._v[1] + r_vec._v[1];
        out._v[2] = l_vec._v[2] + r_vec._v[2];
        return out;
      }
      /**
      * subtract(subtract)
      */
      static _subtract(l_vec, r_vec, type) {
        const x = l_vec._v[0] - r_vec._v[0];
        const y = l_vec._v[1] - r_vec._v[1];
        const z = l_vec._v[2] - r_vec._v[2];
        return this._fromCopyArray([
          x,
          y,
          z
        ], type);
      }
      /**
      * subtract(subtract)
      */
      static subtractTo(l_vec, r_vec, out) {
        out._v[0] = l_vec._v[0] - r_vec._v[0];
        out._v[1] = l_vec._v[1] - r_vec._v[1];
        out._v[2] = l_vec._v[2] - r_vec._v[2];
        return out;
      }
      /**
      * multiply(static version)
      */
      static _multiply(vec, value, type) {
        const x = vec._v[0] * value;
        const y = vec._v[1] * value;
        const z = vec._v[2] * value;
        return this._fromCopyArray([
          x,
          y,
          z
        ], type);
      }
      /**
      * multiplyTo(static version)
      */
      static multiplyTo(vec, value, out) {
        out._v[0] = vec._v[0] * value;
        out._v[1] = vec._v[1] * value;
        out._v[2] = vec._v[2] * value;
        return out;
      }
      /**
      * multiply vector(static version)
      */
      static _multiplyVector(l_vec, r_vec, type) {
        const x = l_vec._v[0] * r_vec._v[0];
        const y = l_vec._v[1] * r_vec._v[1];
        const z = l_vec._v[2] * r_vec._v[2];
        return this._fromCopyArray([
          x,
          y,
          z
        ], type);
      }
      /**
      * multiply vector(static version)
      */
      static multiplyVectorTo(l_vec, r_vec, out) {
        out._v[0] = l_vec._v[0] * r_vec._v[0];
        out._v[1] = l_vec._v[1] * r_vec._v[1];
        out._v[2] = l_vec._v[2] * r_vec._v[2];
        return out;
      }
      /**
      * multiply matrix4
      */
      static _multiplyMatrix4(vec, mat, type) {
        const x = vec._v[0];
        const y = vec._v[1];
        const z = vec._v[2];
        const w = 1 / (mat._v[3] * x + mat._v[7] * y + mat._v[11] * z + mat._v[15]);
        const resultX = (mat._v[0] * x + mat._v[4] * y + mat._v[8] * z + mat._v[12]) * w;
        const resultY = (mat._v[1] * x + mat._v[5] * y + mat._v[9] * z + mat._v[13]) * w;
        const resultZ = (mat._v[2] * x + mat._v[6] * y + mat._v[10] * z + mat._v[14]) * w;
        return this._fromCopyArray([
          resultX,
          resultY,
          resultZ
        ], type);
      }
      /**
      * divide(static version)
      */
      static _divide(vec, value, type) {
        let x;
        let y;
        let z;
        if (value !== 0) {
          x = vec._v[0] / value;
          y = vec._v[1] / value;
          z = vec._v[2] / value;
        } else {
          Logger.error("0 division occurred!");
          x = Infinity;
          y = Infinity;
          z = Infinity;
        }
        return this._fromCopyArray([
          x,
          y,
          z
        ], type);
      }
      /**
      * divide by value(static version)
      */
      static divideTo(vec, value, out) {
        if (value !== 0) {
          out._v[0] = vec._v[0] / value;
          out._v[1] = vec._v[1] / value;
          out._v[2] = vec._v[2] / value;
        } else {
          Logger.error("0 division occurred!");
          out._v[0] = Infinity;
          out._v[1] = Infinity;
          out._v[2] = Infinity;
        }
        return out;
      }
      /**
      * divide vector(static version)
      */
      static _divideVector(l_vec, r_vec, type) {
        let x;
        let y;
        let z;
        if (r_vec._v[0] !== 0 && r_vec._v[1] !== 0 && r_vec._v[2] !== 0) {
          x = l_vec._v[0] / r_vec._v[0];
          y = l_vec._v[1] / r_vec._v[1];
          z = l_vec._v[2] / r_vec._v[2];
        } else {
          Logger.error("0 division occurred!");
          x = r_vec._v[0] === 0 ? Infinity : l_vec._v[0] / r_vec._v[0];
          y = r_vec._v[1] === 0 ? Infinity : l_vec._v[1] / r_vec._v[1];
          z = r_vec._v[2] === 0 ? Infinity : l_vec._v[2] / r_vec._v[2];
        }
        return this._fromCopyArray([
          x,
          y,
          z
        ], type);
      }
      /**
      * divide by vector(static version)
      */
      static divideVectorTo(l_vec, r_vec, out) {
        if (r_vec._v[0] !== 0 && r_vec._v[1] !== 0 && r_vec._v[2] !== 0) {
          out._v[0] = l_vec._v[0] / r_vec._v[0];
          out._v[1] = l_vec._v[1] / r_vec._v[1];
          out._v[2] = l_vec._v[2] / r_vec._v[2];
        } else {
          Logger.error("0 division occurred!");
          out._v[0] = r_vec._v[0] === 0 ? Infinity : l_vec._v[0] / r_vec._v[0];
          out._v[1] = r_vec._v[1] === 0 ? Infinity : l_vec._v[1] / r_vec._v[1];
          out._v[2] = r_vec._v[2] === 0 ? Infinity : l_vec._v[2] / r_vec._v[2];
        }
        return out;
      }
      /**
      * dot product(static version)
      */
      static dot(l_vec, r_vec) {
        return l_vec.dot(r_vec);
      }
      /**
      * cross product(static version)
      */
      static _cross(l_vec, r_vec, type) {
        const x = l_vec._v[1] * r_vec._v[2] - l_vec._v[2] * r_vec._v[1];
        const y = l_vec._v[2] * r_vec._v[0] - l_vec._v[0] * r_vec._v[2];
        const z = l_vec._v[0] * r_vec._v[1] - l_vec._v[1] * r_vec._v[0];
        return this._fromCopyArray([
          x,
          y,
          z
        ], type);
      }
      /**
      * cross product(static version)
      */
      static crossTo(l_vec, r_vec, out) {
        const x = l_vec._v[1] * r_vec._v[2] - l_vec._v[2] * r_vec._v[1];
        const y = l_vec._v[2] * r_vec._v[0] - l_vec._v[0] * r_vec._v[2];
        const z = l_vec._v[0] * r_vec._v[1] - l_vec._v[1] * r_vec._v[0];
        return out.setComponents(x, y, z);
      }
      /**
      * quaternion * vector3
      */
      static _multiplyQuaternion(quat, vec, type) {
        const num = quat._v[0] * 2;
        const num2 = quat._v[1] * 2;
        const num3 = quat._v[2] * 2;
        const num4 = quat._v[0] * num;
        const num5 = quat._v[1] * num2;
        const num6 = quat._v[2] * num3;
        const num7 = quat._v[0] * num2;
        const num8 = quat._v[0] * num3;
        const num9 = quat._v[1] * num3;
        const num10 = quat._v[3] * num;
        const num11 = quat._v[3] * num2;
        const num12 = quat._v[3] * num3;
        const x = (1 - (num5 + num6)) * vec._v[0] + (num7 - num12) * vec._v[1] + (num8 + num11) * vec._v[2];
        const y = (num7 + num12) * vec._v[0] + (1 - (num4 + num6)) * vec._v[1] + (num9 - num10) * vec._v[2];
        const z = (num8 - num11) * vec._v[0] + (num9 + num10) * vec._v[1] + (1 - (num4 + num5)) * vec._v[2];
        return this._fromCopyArray([
          x,
          y,
          z
        ], type);
      }
      /**
      * quaternion * vector3
      */
      static multiplyQuaternionTo(quat, vec, out) {
        const num = quat._v[0] * 2;
        const num2 = quat._v[1] * 2;
        const num3 = quat._v[2] * 2;
        const num4 = quat._v[0] * num;
        const num5 = quat._v[1] * num2;
        const num6 = quat._v[2] * num3;
        const num7 = quat._v[0] * num2;
        const num8 = quat._v[0] * num3;
        const num9 = quat._v[1] * num3;
        const num10 = quat._v[3] * num;
        const num11 = quat._v[3] * num2;
        const num12 = quat._v[3] * num3;
        const x = (1 - (num5 + num6)) * vec._v[0] + (num7 - num12) * vec._v[1] + (num8 + num11) * vec._v[2];
        const y = (num7 + num12) * vec._v[0] + (1 - (num4 + num6)) * vec._v[1] + (num9 - num10) * vec._v[2];
        const z = (num8 - num11) * vec._v[0] + (num9 + num10) * vec._v[1] + (1 - (num4 + num5)) * vec._v[2];
        return out.setComponents(x, y, z);
      }
      /**
      * change to string
      */
      toString() {
        return "(" + this._v[0] + ", " + this._v[1] + ", " + this._v[2] + ")";
      }
      toStringApproximately() {
        return MathUtil.financial(this._v[0]) + " " + MathUtil.financial(this._v[1]) + " " + MathUtil.financial(this._v[2]) + "\n";
      }
      flattenAsArray() {
        return [
          this._v[0],
          this._v[1],
          this._v[2]
        ];
      }
      isDummy() {
        if (this._v.length === 0) {
          return true;
        } else {
          return false;
        }
      }
      isEqual(vec, delta = Number.EPSILON) {
        if (Math.abs(vec._v[0] - this._v[0]) < delta && Math.abs(vec._v[1] - this._v[1]) < delta && Math.abs(vec._v[2] - this._v[2]) < delta) {
          return true;
        } else {
          return false;
        }
      }
      isStrictEqual(vec) {
        if (this._v[0] === vec._v[0] && this._v[1] === vec._v[1] && this._v[2] === vec._v[2]) {
          return true;
        } else {
          return false;
        }
      }
      at(i2) {
        return this._v[i2];
      }
      length() {
        return Math.hypot(this._v[0], this._v[1], this._v[2]);
      }
      lengthSquared() {
        return this._v[0] ** 2 + this._v[1] ** 2 + this._v[2] ** 2;
      }
      lengthTo(vec) {
        const deltaX = this._v[0] - vec._v[0];
        const deltaY = this._v[1] - vec._v[1];
        const deltaZ = this._v[2] - vec._v[2];
        return Math.hypot(deltaX, deltaY, deltaZ);
      }
      /**
      * dot product
      */
      dot(vec) {
        return this._v[0] * vec._v[0] + this._v[1] * vec._v[1] + this._v[2] * vec._v[2];
      }
      get className() {
        return "Vector3";
      }
      clone() {
        return new this.constructor(new this._v.constructor([
          this._v[0],
          this._v[1],
          this._v[2]
        ], 0, 0));
      }
      get bytesPerComponent() {
        return this._v.BYTES_PER_ELEMENT;
      }
      static _lerp(lhs, rhs, ratio, type) {
        return new this(new type([
          lhs._v[0] * (1 - ratio) + rhs._v[0] * ratio,
          lhs._v[1] * (1 - ratio) + rhs._v[1] * ratio,
          lhs._v[2] * (1 - ratio) + rhs._v[2] * ratio
        ]), {
          type
        });
      }
      static _fromCopyArray3(array, type) {
        return new this(new type(array), {
          type
        });
      }
      static _fromCopy3(x, y, z, type) {
        return new this(new type([
          x,
          y,
          z
        ]), {
          type
        });
      }
      static _fromCopyArray(array, type) {
        return new this(new type(array.slice(0, 3)), {
          type
        });
      }
      static _fromCopyVector3(vec3, type) {
        const vec = new this(new type([
          vec3._v[0],
          vec3._v[1],
          vec3._v[2]
        ]), {
          type
        });
        return vec;
      }
      static _fromCopyVector4(vec4, type) {
        const vec = new this(new type([
          vec4._v[0],
          vec4._v[1],
          vec4._v[2]
        ]), {
          type
        });
        return vec;
      }
      static _fromVector2(vec2, type) {
        const vec = new this(new type([
          vec2._v[0],
          vec2._v[1],
          0
        ]), {
          type
        });
        return vec;
      }
    };
    __name(_Vector3_, "Vector3_");
    Vector3_ = _Vector3_;
    _Vector3 = class _Vector3 extends Vector3_ {
      constructor(v) {
        super(v, {
          type: Float32Array
        });
      }
      static fromCopyArray3(array) {
        return super._fromCopyArray3(array, Float32Array);
      }
      static fromCopy3(x, y, z) {
        return super._fromCopy3(x, y, z, Float32Array);
      }
      static fromCopy1(val) {
        return super._fromCopy3(val, val, val, Float32Array);
      }
      static fromCopyArray(array) {
        return super._fromCopyArray(array, Float32Array);
      }
      static fromCopyVector3(vec3) {
        return super._fromCopyVector3(vec3, Float32Array);
      }
      static fromCopyVector4(vec4) {
        return super._fromCopyVector4(vec4, Float32Array);
      }
      static fromArrayBuffer(arrayBuffer) {
        return new _Vector3(new Float32Array(arrayBuffer));
      }
      static fromFloat32Array(float32Array) {
        return new _Vector3(float32Array);
      }
      static fromCopyFloat32Array(float32Array) {
        return new _Vector3(float32Array.slice(0));
      }
      static zero() {
        return super._zero(Float32Array);
      }
      static one() {
        return super._one(Float32Array);
      }
      static dummy() {
        return super._dummy(Float32Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float32Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
      }
      static multiplyMatrix4(vec, mat) {
        return super._multiplyMatrix4(vec, mat, Float32Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
      }
      static cross(l_vec, r_vec) {
        return super._cross(l_vec, r_vec, Float32Array);
      }
      static multiplyQuaternion(quat, vec) {
        return super._multiplyQuaternion(quat, vec, Float32Array);
      }
      static lerp(lhs, rhs, ratio) {
        return super._lerp(lhs, rhs, ratio, Float32Array);
      }
    };
    __name(_Vector3, "Vector3");
    Vector3 = _Vector3;
    _Vector3d = class _Vector3d extends Vector3_ {
      constructor(v) {
        super(v, {
          type: Float64Array
        });
      }
      static fromCopyArray3(array) {
        return super._fromCopyArray3(array, Float64Array);
      }
      static fromCopy3(x, y, z) {
        return super._fromCopy3(x, y, z, Float64Array);
      }
      static fromCopy1(val) {
        return super._fromCopy3(val, val, val, Float64Array);
      }
      static fromCopyArray(array) {
        return super._fromCopyArray(array, Float64Array);
      }
      static fromArrayBuffer(arrayBuffer) {
        return new _Vector3d(new Float64Array(arrayBuffer));
      }
      static fromFloat64Array(float64Array) {
        return new _Vector3d(float64Array);
      }
      static zero() {
        return super._zero(Float64Array);
      }
      static one() {
        return super._one(Float64Array);
      }
      static dummy() {
        return super._dummy(Float64Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float64Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float64Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float64Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float64Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float64Array);
      }
      static multiplyMatrix4(vec, mat) {
        return super._multiplyMatrix4(vec, mat, Float64Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float64Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float64Array);
      }
      static cross(l_vec, r_vec) {
        return super._cross(l_vec, r_vec, Float64Array);
      }
      static multiplyQuaternion(quat, vec) {
        return super._multiplyQuaternion(quat, vec, Float64Array);
      }
      static lerp(lhs, rhs, ratio) {
        return super._lerp(lhs, rhs, ratio, Float64Array);
      }
    };
    __name(_Vector3d, "Vector3d");
    Vector3d = _Vector3d;
    ConstVector3_1_1_1 = Vector3.fromCopy3(1, 1, 1);
    ConstVector3_0_0_0 = Vector3.fromCopy3(0, 0, 0);
  }
});

// src/foundation/math/MutableVector3.ts
var _MutableVector3_, MutableVector3_, _MutableVector3, MutableVector3, _MutableVector3d, MutableVector3d;
var init_MutableVector3 = __esm({
  "src/foundation/math/MutableVector3.ts"() {
    "use strict";
    init_Vector3();
    init_Logger();
    _MutableVector3_ = class _MutableVector3_ extends Vector3_ {
      constructor(v, { type }) {
        super(v, {
          type
        });
      }
      set x(x) {
        this._v[0] = x;
      }
      get x() {
        return this._v[0];
      }
      set y(y) {
        this._v[1] = y;
      }
      get y() {
        return this._v[1];
      }
      set z(z) {
        this._v[2] = z;
      }
      get z() {
        return this._v[2];
      }
      get w() {
        return 1;
      }
      raw() {
        return this._v;
      }
      setAt(i2, value) {
        this._v[i2] = value;
        return this;
      }
      setComponents(x, y, z) {
        this._v[0] = x;
        this._v[1] = y;
        this._v[2] = z;
        return this;
      }
      copyComponents(vec) {
        return this.setComponents(vec._v[0], vec._v[1], vec._v[2]);
      }
      zero() {
        return this.setComponents(0, 0, 0);
      }
      one() {
        return this.setComponents(1, 1, 1);
      }
      /**
      * normalize
      */
      normalize() {
        const length = this.length();
        this.divide(length);
        return this;
      }
      /**
      * add value
      */
      add(vec) {
        this._v[0] += vec._v[0];
        this._v[1] += vec._v[1];
        this._v[2] += vec._v[2];
        return this;
      }
      /**
      * subtract
      */
      subtract(vec) {
        this._v[0] -= vec._v[0];
        this._v[1] -= vec._v[1];
        this._v[2] -= vec._v[2];
        return this;
      }
      /**
      * multiply
      */
      multiply(value) {
        this._v[0] *= value;
        this._v[1] *= value;
        this._v[2] *= value;
        return this;
      }
      /**
      * multiply vector
      */
      multiplyVector(vec) {
        this._v[0] *= vec._v[0];
        this._v[1] *= vec._v[1];
        this._v[2] *= vec._v[2];
        return this;
      }
      /**
      * divide
      */
      divide(value) {
        if (value !== 0) {
          this._v[0] /= value;
          this._v[1] /= value;
          this._v[2] /= value;
        } else {
          Logger.error("0 division occurred!");
          this._v[0] = Infinity;
          this._v[1] = Infinity;
          this._v[2] = Infinity;
        }
        return this;
      }
      /**
      * divide vector
      */
      divideVector(vec) {
        if (vec._v[0] !== 0 && vec._v[1] !== 0 && vec._v[2] !== 0) {
          this._v[0] /= vec._v[0];
          this._v[1] /= vec._v[1];
          this._v[2] /= vec._v[2];
        } else {
          Logger.error("0 division occurred!");
          this._v[0] = vec._v[0] === 0 ? Infinity : this._v[0] / vec._v[0];
          this._v[1] = vec._v[1] === 0 ? Infinity : this._v[1] / vec._v[1];
          this._v[2] = vec._v[2] === 0 ? Infinity : this._v[2] / vec._v[2];
        }
        return this;
      }
      /**
      * cross product
      */
      cross(vec) {
        const x = this._v[1] * vec._v[2] - this._v[2] * vec._v[1];
        const y = this._v[2] * vec._v[0] - this._v[0] * vec._v[2];
        const z = this._v[0] * vec._v[1] - this._v[1] * vec._v[0];
        return this.setComponents(x, y, z);
      }
      /**
      * quaternion * vector3
      */
      multiplyQuaternion(quat) {
        const num = quat._v[0] * 2;
        const num2 = quat._v[1] * 2;
        const num3 = quat._v[2] * 2;
        const num4 = quat._v[0] * num;
        const num5 = quat._v[1] * num2;
        const num6 = quat._v[2] * num3;
        const num7 = quat._v[0] * num2;
        const num8 = quat._v[0] * num3;
        const num9 = quat._v[1] * num3;
        const num10 = quat._v[3] * num;
        const num11 = quat._v[3] * num2;
        const num12 = quat._v[3] * num3;
        const x = (1 - (num5 + num6)) * this._v[0] + (num7 - num12) * this._v[1] + (num8 + num11) * this._v[2];
        const y = (num7 + num12) * this._v[0] + (1 - (num4 + num6)) * this._v[1] + (num9 - num10) * this._v[2];
        const z = (num8 - num11) * this._v[0] + (num9 + num10) * this._v[1] + (1 - (num4 + num5)) * this._v[2];
        return this.setComponents(x, y, z);
      }
      get bytesPerComponent() {
        return this._v.BYTES_PER_ELEMENT;
      }
      static _fromCopy3(x, y, z, type) {
        return new this(new type([
          x,
          y,
          z
        ]), {
          type
        });
      }
    };
    __name(_MutableVector3_, "MutableVector3_");
    MutableVector3_ = _MutableVector3_;
    _MutableVector3 = class _MutableVector3 extends MutableVector3_ {
      constructor(v) {
        super(v, {
          type: Float32Array
        });
      }
      static zero() {
        return super._zero(Float32Array);
      }
      static one() {
        return super._one(Float32Array);
      }
      static dummy() {
        return super._dummy(Float32Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float32Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
      }
      static cross(l_vec, r_vec) {
        return super._cross(l_vec, r_vec, Float32Array);
      }
      static multiplyQuaternion(quat, vec) {
        return super._multiplyQuaternion(quat, vec, Float32Array);
      }
      get className() {
        return "MutableVector3";
      }
      static fromCopy3(x, y, z) {
        return super._fromCopy3(x, y, z, Float32Array);
      }
      static fromCopy1(val) {
        return super._fromCopy3(val, val, val, Float32Array);
      }
      static fromCopyArray3(array) {
        return new _MutableVector3(new Float32Array(array));
      }
      static fromCopyArray(array) {
        return new _MutableVector3(new Float32Array(array.slice(0, 3)));
      }
      static fromFloat32Array(float32Array) {
        return new _MutableVector3(float32Array);
      }
      static fromCopyFloat32Array(float32Array) {
        return new _MutableVector3(new Float32Array(float32Array.buffer.slice(0)));
      }
      static fromCopyVector3(vec) {
        return super._fromCopyVector3(vec, Float32Array);
      }
      static fromCopyVector4(vec) {
        return super._fromCopyVector4(vec, Float32Array);
      }
      clone() {
        return super.clone();
      }
      static rotateX(vec3, radian, outVec) {
        const c2 = Math.cos(radian);
        const s2 = Math.sin(radian);
        outVec.y = vec3.y * c2 - vec3.z * s2;
        outVec.z = vec3.y * s2 + vec3.z * c2;
      }
      static rotateY(vec3, radian, outVec) {
        const c2 = Math.cos(radian);
        const s2 = Math.sin(radian);
        outVec.x = vec3.x * c2 + vec3.z * s2;
        outVec.z = -vec3.x * s2 + vec3.z * c2;
      }
      static rotateZ(vec3, radian, outVec) {
        const c2 = Math.cos(radian);
        const s2 = Math.sin(radian);
        outVec.x = vec3.x * c2 - vec3.y * s2;
        outVec.y = vec3.x * s2 + vec3.y * c2;
      }
    };
    __name(_MutableVector3, "MutableVector3");
    MutableVector3 = _MutableVector3;
    _MutableVector3d = class _MutableVector3d extends MutableVector3_ {
      constructor(x) {
        super(x, {
          type: Float64Array
        });
      }
      static zero() {
        return super._zero(Float64Array);
      }
      static one() {
        return super._one(Float64Array);
      }
      static dummy() {
        return super._dummy(Float64Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float64Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float64Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float64Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float64Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float64Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float64Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float64Array);
      }
      static cross(l_vec, r_vec) {
        return super._cross(l_vec, r_vec, Float64Array);
      }
      static multiplyQuaternion(quat, vec) {
        return super._multiplyQuaternion(quat, vec, Float64Array);
      }
      static fromCopy3(x, y, z) {
        return super._fromCopy3(x, y, z, Float64Array);
      }
      static fromCopy1(val) {
        return super._fromCopy3(val, val, val, Float64Array);
      }
      static fromCopyArray3(array) {
        return new _MutableVector3d(new Float64Array(array));
      }
      static fromCopyArray(array) {
        return new _MutableVector3d(new Float64Array(array.slice(0, 3)));
      }
      static rotateX(vec3, radian, outVec) {
        const c2 = Math.cos(radian);
        const s2 = Math.sin(radian);
        outVec.y = vec3.y * c2 - vec3.z * s2;
        outVec.z = vec3.y * s2 + vec3.z * c2;
      }
      static rotateY(vec3, radian, outVec) {
        const c2 = Math.cos(radian);
        const s2 = Math.sin(radian);
        outVec.x = vec3.x * c2 + vec3.z * s2;
        outVec.z = -vec3.x * s2 + vec3.z * c2;
      }
      static rotateZ(vec3, radian, outVec) {
        const c2 = Math.cos(radian);
        const s2 = Math.sin(radian);
        outVec.x = vec3.x * c2 - vec3.y * s2;
        outVec.y = vec3.x * s2 + vec3.y * c2;
      }
      clone() {
        return super.clone();
      }
    };
    __name(_MutableVector3d, "MutableVector3d");
    MutableVector3d = _MutableVector3d;
  }
});

// src/foundation/math/AABB.ts
var _AABB, AABB;
var init_AABB = __esm({
  "src/foundation/math/AABB.ts"() {
    "use strict";
    init_Vector3();
    init_MutableVector3();
    init_MathUtil();
    _AABB = class _AABB {
      constructor() {
        __publicField(this, "__min", MutableVector3.fromCopyArray([
          Number.MAX_VALUE,
          Number.MAX_VALUE,
          Number.MAX_VALUE
        ]));
        __publicField(this, "__max", MutableVector3.fromCopyArray([
          -Number.MAX_VALUE,
          -Number.MAX_VALUE,
          -Number.MAX_VALUE
        ]));
        __publicField(this, "__centerPoint", MutableVector3.zero());
        __publicField(this, "__lengthCenterToCorner", 0);
        __publicField(this, "__isCenterPointDirty", false);
        __publicField(this, "__isLengthCenterToCornerDirty", false);
        __publicField(this, "__isVanilla", true);
      }
      /**
      * Clone this AABB.
      * @returns a cloned AABB.
      */
      clone() {
        const instance = new _AABB();
        instance.__max = this.__max.clone();
        instance.__min = this.__min.clone();
        instance.__centerPoint = this.__centerPoint.clone();
        instance.__lengthCenterToCorner = this.__lengthCenterToCorner;
        instance.__isCenterPointDirty = this.__isCenterPointDirty;
        instance.__isLengthCenterToCornerDirty = this.__isLengthCenterToCornerDirty;
        instance.__isVanilla = this.__isVanilla;
        return instance;
      }
      /**
      * Copy inner components from another AABB.
      * @param aabb
      * @returns this
      */
      copyComponents(aabb) {
        this.__max.copyComponents(aabb.__max);
        this.__min.copyComponents(aabb.__min);
        this.__centerPoint.copyComponents(aabb.__centerPoint);
        this.__lengthCenterToCorner = aabb.__lengthCenterToCorner;
        this.__isCenterPointDirty = aabb.__isCenterPointDirty;
        this.__isLengthCenterToCornerDirty = aabb.__isLengthCenterToCornerDirty;
        this.__isVanilla = false;
        return this;
      }
      /**
      * initialize this AABB.
      */
      initialize() {
        this.__min.setComponents(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this.__max.setComponents(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        this.__centerPoint.zero();
        this.__lengthCenterToCorner = 0;
        this.__isCenterPointDirty = false;
        this.__isLengthCenterToCornerDirty = false;
        this.__isVanilla = true;
      }
      set minPoint(val) {
        this.__min.copyComponents(val);
        this.__isCenterPointDirty = true;
        this.__isLengthCenterToCornerDirty = true;
        this.__isVanilla = false;
      }
      get minPoint() {
        return this.__min;
      }
      set maxPoint(val) {
        this.__max.copyComponents(val);
        this.__isCenterPointDirty = true;
        this.__isLengthCenterToCornerDirty = true;
        this.__isVanilla = false;
      }
      get maxPoint() {
        return this.__max;
      }
      /**
      * return whether this AABB is vanilla (not initialized) or not.
      * @returns true if this AABB is vanilla.
      */
      isVanilla() {
        return this.__isVanilla;
      }
      /**
      * add a position for updating AABB.
      * @param positionVector
      * @returns given positionVector.
      */
      addPosition(positionVector) {
        this.__min.x = positionVector.x < this.__min.x ? positionVector.x : this.__min.x;
        this.__min.y = positionVector.y < this.__min.y ? positionVector.y : this.__min.y;
        this.__min.z = positionVector.z < this.__min.z ? positionVector.z : this.__min.z;
        this.__max.x = this.__max.x < positionVector.x ? positionVector.x : this.__max.x;
        this.__max.y = this.__max.y < positionVector.y ? positionVector.y : this.__max.y;
        this.__max.z = this.__max.z < positionVector.z ? positionVector.z : this.__max.z;
        this.__isCenterPointDirty = true;
        this.__isLengthCenterToCornerDirty = true;
        this.__isVanilla = false;
        return positionVector;
      }
      /**
      * add a position for updating AABB.
      * @param array a position array.
      * @param index index of the position array to adding.
      * @returns given array.
      */
      addPositionWithArray(array, index) {
        this.__min.x = array[index + 0] < this.__min.x ? array[index + 0] : this.__min.x;
        this.__min.y = array[index + 1] < this.__min.y ? array[index + 1] : this.__min.y;
        this.__min.z = array[index + 2] < this.__min.z ? array[index + 2] : this.__min.z;
        this.__max.x = this.__max.x < array[index + 0] ? array[index + 0] : this.__max.x;
        this.__max.y = this.__max.y < array[index + 1] ? array[index + 1] : this.__max.y;
        this.__max.z = this.__max.z < array[index + 2] ? array[index + 2] : this.__max.z;
        this.__isCenterPointDirty = true;
        this.__isLengthCenterToCornerDirty = true;
        this.__isVanilla = false;
        return array;
      }
      /**
      * merge with another AABB.
      * @param aabb another AABB to merge
      * @returns merge succeeded or not.
      */
      mergeAABB(aabb) {
        if (aabb.isVanilla()) {
          return false;
        }
        this.__isCenterPointDirty = true;
        this.__isLengthCenterToCornerDirty = true;
        if (this.isVanilla()) {
          this.__min.copyComponents(aabb.minPoint);
          this.__max.copyComponents(aabb.maxPoint);
          this.__isVanilla = false;
          return true;
        }
        if (aabb.minPoint.x < this.__min.x) {
          this.__min.x = aabb.minPoint.x;
        }
        if (aabb.minPoint.y < this.__min.y) {
          this.__min.y = aabb.minPoint.y;
        }
        if (aabb.minPoint.z < this.__min.z) {
          this.__min.z = aabb.minPoint.z;
        }
        if (this.__max.x < aabb.maxPoint.x) {
          this.__max.x = aabb.maxPoint.x;
        }
        if (this.__max.y < aabb.maxPoint.y) {
          this.__max.y = aabb.maxPoint.y;
        }
        if (this.__max.z < aabb.maxPoint.z) {
          this.__max.z = aabb.maxPoint.z;
        }
        return true;
      }
      /**
      * the center of this AABB.
      */
      get centerPoint() {
        if (this.__isCenterPointDirty) {
          MutableVector3.addTo(this.__min, this.__max, this.__centerPoint).divide(2);
          this.__isCenterPointDirty = false;
        }
        return this.__centerPoint;
      }
      /**
      * the length from center to corner of this AABB.
      */
      get lengthCenterToCorner() {
        if (this.__isLengthCenterToCornerDirty) {
          this.__lengthCenterToCorner = Vector3.lengthBtw(this.centerPoint, this.maxPoint);
          this.__isLengthCenterToCornerDirty = false;
        }
        return this.__lengthCenterToCorner;
      }
      /**
      * the length from min x to max x of this AABB.
      */
      get sizeX() {
        return this.__max.x - this.__min.x;
      }
      /**
      * the length from min y to max y of this AABB.
      */
      get sizeY() {
        return this.__max.y - this.__min.y;
      }
      /**
      * the length from min z to max z of this AABB.
      */
      get sizeZ() {
        return this.__max.z - this.__min.z;
      }
      /**
      * multiply this AABB with a given matrix.
      * @param matrix a matrix to convert aabb.
      * @param aabb given AABB to convert.
      * @param outAabb converted AABB by given matrix.
      * @returns converted AABB.
      */
      static multiplyMatrixTo(matrix, aabb, outAabb) {
        if (aabb.isVanilla()) {
          return outAabb.copyComponents(aabb);
        }
        outAabb.initialize();
        _AABB.__tmpVector3.x = aabb.__min.x;
        _AABB.__tmpVector3.y = aabb.__min.y;
        _AABB.__tmpVector3.z = aabb.__min.z;
        matrix.multiplyVector3To(_AABB.__tmpVector3, _AABB.__tmpVector3);
        outAabb.addPosition(_AABB.__tmpVector3);
        _AABB.__tmpVector3.x = aabb.__max.x;
        _AABB.__tmpVector3.y = aabb.__min.y;
        _AABB.__tmpVector3.z = aabb.__min.z;
        matrix.multiplyVector3To(_AABB.__tmpVector3, _AABB.__tmpVector3);
        outAabb.addPosition(_AABB.__tmpVector3);
        _AABB.__tmpVector3.x = aabb.__min.x;
        _AABB.__tmpVector3.y = aabb.__max.y;
        _AABB.__tmpVector3.z = aabb.__min.z;
        matrix.multiplyVector3To(_AABB.__tmpVector3, _AABB.__tmpVector3);
        outAabb.addPosition(_AABB.__tmpVector3);
        _AABB.__tmpVector3.x = aabb.__min.x;
        _AABB.__tmpVector3.y = aabb.__min.y;
        _AABB.__tmpVector3.z = aabb.__max.z;
        matrix.multiplyVector3To(_AABB.__tmpVector3, _AABB.__tmpVector3);
        outAabb.addPosition(_AABB.__tmpVector3);
        _AABB.__tmpVector3.x = aabb.__min.x;
        _AABB.__tmpVector3.y = aabb.__max.y;
        _AABB.__tmpVector3.z = aabb.__max.z;
        matrix.multiplyVector3To(_AABB.__tmpVector3, _AABB.__tmpVector3);
        outAabb.addPosition(_AABB.__tmpVector3);
        _AABB.__tmpVector3.x = aabb.__max.x;
        _AABB.__tmpVector3.y = aabb.__min.y;
        _AABB.__tmpVector3.z = aabb.__max.z;
        matrix.multiplyVector3To(_AABB.__tmpVector3, _AABB.__tmpVector3);
        outAabb.addPosition(_AABB.__tmpVector3);
        _AABB.__tmpVector3.x = aabb.__max.x;
        _AABB.__tmpVector3.y = aabb.__max.y;
        _AABB.__tmpVector3.z = aabb.__min.z;
        matrix.multiplyVector3To(_AABB.__tmpVector3, _AABB.__tmpVector3);
        outAabb.addPosition(_AABB.__tmpVector3);
        _AABB.__tmpVector3.x = aabb.__max.x;
        _AABB.__tmpVector3.y = aabb.__max.y;
        _AABB.__tmpVector3.z = aabb.__max.z;
        matrix.multiplyVector3To(_AABB.__tmpVector3, _AABB.__tmpVector3);
        outAabb.addPosition(_AABB.__tmpVector3);
        return outAabb;
      }
      /**
      * toString method.
      */
      toString() {
        return "AABB_min: " + this.__min + "\nAABB_max: " + this.__max + "\ncenterPoint: " + this.__centerPoint + "\nlengthCenterToCorner: " + this.__lengthCenterToCorner;
      }
      /**
      * toString method (the numbers are Approximate)
      */
      toStringApproximately() {
        return "AABB_max: " + this.__max.toStringApproximately() + "\nAABB_min: " + this.__min.toStringApproximately() + "\ncenterPoint: " + this.centerPoint.toStringApproximately() + "\nlengthCenterToCorner: " + MathUtil.financial(this.lengthCenterToCorner);
      }
    };
    __name(_AABB, "AABB");
    __publicField(_AABB, "__tmpVector3", MutableVector3.zero());
    AABB = _AABB;
  }
});

// src/foundation/cameras/AbstractCameraController.ts
var _AbstractCameraController, AbstractCameraController;
var init_AbstractCameraController = __esm({
  "src/foundation/cameras/AbstractCameraController.ts"() {
    "use strict";
    init_AABB();
    init_Vector3();
    _AbstractCameraController = class _AbstractCameraController {
      constructor() {
        __publicField(this, "zNearMax", 0.1);
        __publicField(this, "zFarScalingFactor", 1e5);
        __publicField(this, "autoCalculateZNearAndZFar", true);
      }
      _calcZNearInner(camera, eyePosition, eyeDirection) {
        if (this.autoCalculateZNearAndZFar && this.__targetEntities.length > 0) {
          const aabb = new AABB();
          for (const targetEntity of this.__targetEntities) {
            aabb.mergeAABB(targetEntity.getSceneGraph().worldMergedAABBWithSkeletal);
          }
          const targetAABB = aabb;
          const lengthOfCenterToEye = Vector3.lengthBtw(eyePosition, targetAABB.centerPoint);
          const eyeToTargetDirectionX = targetAABB.centerPoint.x - eyePosition.x;
          const eyeToTargetDirectionY = targetAABB.centerPoint.y - eyePosition.y;
          const eyeToTargetDirectionZ = targetAABB.centerPoint.z - eyePosition.z;
          const cos = (eyeToTargetDirectionX * eyeDirection.x + eyeToTargetDirectionY * eyeDirection.y + eyeToTargetDirectionZ * eyeDirection.z) / (Math.hypot(eyeToTargetDirectionX, eyeToTargetDirectionY, eyeToTargetDirectionZ) * eyeDirection.length());
          camera.zNearInner = Math.max(Math.min(lengthOfCenterToEye * cos - targetAABB.lengthCenterToCorner, this.zNearMax), 0.01);
        } else {
          camera.zNearInner = camera.zNear;
        }
      }
      _calcZFarInner(camera) {
        if (this.autoCalculateZNearAndZFar) {
          camera.zFarInner = camera.zNearInner * this.zFarScalingFactor;
        } else {
          camera.zNearInner = camera.zFar;
        }
      }
    };
    __name(_AbstractCameraController, "AbstractCameraController");
    AbstractCameraController = _AbstractCameraController;
  }
});

// src/foundation/math/AbstractMatrix.ts
var _AbstractMatrix, AbstractMatrix;
var init_AbstractMatrix = __esm({
  "src/foundation/math/AbstractMatrix.ts"() {
    "use strict";
    _AbstractMatrix = class _AbstractMatrix {
      constructor() {
        __publicField(this, "_v", new Float32Array());
      }
      at(row_i, column_i) {
        throw new Error("Method not implemented.");
      }
      toString() {
        throw new Error("Method not implemented.");
      }
      toStringApproximately() {
        throw new Error("Method not implemented.");
      }
      flattenAsArray() {
        throw new Error("Method not implemented.");
      }
      isDummy() {
        if (this._v.length === 0) {
          return true;
        } else {
          return false;
        }
      }
      v(i2) {
        return this._v[i2];
      }
      determinant() {
        throw new Error("Method not implemented.");
      }
      get className() {
        return this.constructor.name;
      }
      get isIdentityMatrixClass() {
        return false;
      }
      isTheSourceSame(arrayBuffer) {
        return this._v.buffer === arrayBuffer;
      }
    };
    __name(_AbstractMatrix, "AbstractMatrix");
    AbstractMatrix = _AbstractMatrix;
  }
});

// src/foundation/math/IdentityMatrix33.ts
var _IdentityMatrix33, IdentityMatrix33;
var init_IdentityMatrix33 = __esm({
  "src/foundation/math/IdentityMatrix33.ts"() {
    "use strict";
    init_CompositionType();
    init_AbstractMatrix();
    init_Vector3();
    _IdentityMatrix33 = class _IdentityMatrix33 extends AbstractMatrix {
      constructor() {
        super();
        this._v = _IdentityMatrix33.__v;
      }
      toString() {
        return `1 0 0
0 1 0
0 0 1
`;
      }
      toStringApproximately() {
        return this.toString();
      }
      flattenAsArray() {
        return [
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ];
      }
      isDummy() {
        return false;
      }
      isEqual(mat, delta = Number.EPSILON) {
        if (Math.abs(mat.m00 - 1) < delta && Math.abs(mat.m10) < delta && Math.abs(mat.m20) < delta && Math.abs(mat.m01) < delta && Math.abs(mat.m11 - 1) < delta && Math.abs(mat.m21) < delta && Math.abs(mat.m02) < delta && Math.abs(mat.m12) < delta && Math.abs(mat.m22 - 1) < delta) {
          return true;
        } else {
          return false;
        }
      }
      isStrictEqual(mat) {
        const v = mat._v;
        if (v[0] === 1 && v[1] === 0 && v[2] === 0 && v[3] === 0 && v[4] === 0 && v[5] === 0 && v[6] === 0 && v[7] === 0 && v[8] === 0 && v[9] === 0 && v[10] === 0 && v[11] === 0 && v[12] === 0 && v[13] === 0 && v[14] === 0 && v[15] === 0) {
          return true;
        } else {
          return false;
        }
      }
      at(row_i, column_i) {
        return row_i === column_i ? 1 : 0;
      }
      determinant() {
        return 1;
      }
      multiplyVector(vec) {
        return vec;
      }
      multiplyVectorTo(vec, outVec) {
        const v = vec._v;
        outVec._v[0] = v[0];
        outVec._v[1] = v[1];
        outVec._v[2] = v[2];
        outVec._v[3] = v[3];
        return outVec;
      }
      getScale() {
        return Vector3.fromCopyArray([
          1,
          1,
          1
        ]);
      }
      getScaleTo(outVec) {
        const v = outVec._v;
        v[0] = 1;
        v[1] = 1;
        v[2] = 1;
        return outVec;
      }
      clone() {
        return new _IdentityMatrix33();
      }
      getRotate() {
        return new _IdentityMatrix33();
      }
      get m00() {
        return 1;
      }
      get m10() {
        return 0;
      }
      get m20() {
        return 0;
      }
      get m30() {
        return 0;
      }
      get m01() {
        return 0;
      }
      get m11() {
        return 1;
      }
      get m21() {
        return 0;
      }
      get m31() {
        return 0;
      }
      get m02() {
        return 0;
      }
      get m12() {
        return 0;
      }
      get m22() {
        return 1;
      }
      get m32() {
        return 0;
      }
      get m03() {
        return 0;
      }
      get m13() {
        return 0;
      }
      get m23() {
        return 0;
      }
      get m33() {
        return 1;
      }
      get className() {
        return "IdentityMatrix33";
      }
      static get compositionType() {
        return CompositionType.Mat3;
      }
      get isIdentityMatrixClass() {
        return true;
      }
    };
    __name(_IdentityMatrix33, "IdentityMatrix33");
    __publicField(_IdentityMatrix33, "__v", new Float32Array([
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ]));
    IdentityMatrix33 = _IdentityMatrix33;
  }
});

// src/foundation/math/Matrix33.ts
var _Matrix33, Matrix33;
var init_Matrix33 = __esm({
  "src/foundation/math/Matrix33.ts"() {
    "use strict";
    init_Vector3();
    init_CompositionType();
    init_MathUtil();
    init_AbstractMatrix();
    init_IdentityMatrix33();
    init_Logger();
    _Matrix33 = class _Matrix33 extends AbstractMatrix {
      constructor(m) {
        super();
        this._v = m;
      }
      get m00() {
        return this._v[0];
      }
      get m10() {
        return this._v[1];
      }
      get m20() {
        return this._v[2];
      }
      get m01() {
        return this._v[3];
      }
      get m11() {
        return this._v[4];
      }
      get m21() {
        return this._v[5];
      }
      get m02() {
        return this._v[6];
      }
      get m12() {
        return this._v[7];
      }
      get m22() {
        return this._v[8];
      }
      get className() {
        return "Matrix33";
      }
      static get compositionType() {
        return CompositionType.Mat3;
      }
      /**
      * zero matrix(static version)
      */
      static zero() {
        return _Matrix33.fromCopy9RowMajor(0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
      /**
      * Create identity matrix
      */
      static identity() {
        return new IdentityMatrix33();
      }
      static dummy() {
        return new this(new Float32Array(0));
      }
      /**
      * Create transpose matrix
      */
      static transpose(mat) {
        if (mat.isIdentityMatrixClass) {
          return mat;
        }
        return _Matrix33.fromCopy9RowMajor(mat._v[0], mat._v[1], mat._v[2], mat._v[3], mat._v[4], mat._v[5], mat._v[6], mat._v[7], mat._v[8]);
      }
      /**
      * Create invert matrix
      */
      static invert(mat) {
        if (mat.isIdentityMatrixClass) {
          return mat;
        }
        const det = mat.determinant();
        if (det === 0) {
          Logger.error("the determinant is 0!");
        }
        const m00 = (mat._v[4] * mat._v[8] - mat._v[7] * mat._v[5]) / det;
        const m01 = (mat._v[6] * mat._v[5] - mat._v[3] * mat._v[8]) / det;
        const m02 = (mat._v[3] * mat._v[7] - mat._v[6] * mat._v[4]) / det;
        const m10 = (mat._v[7] * mat._v[2] - mat._v[1] * mat._v[8]) / det;
        const m11 = (mat._v[0] * mat._v[8] - mat._v[6] * mat._v[2]) / det;
        const m12 = (mat._v[6] * mat._v[1] - mat._v[0] * mat._v[7]) / det;
        const m20 = (mat._v[1] * mat._v[5] - mat._v[4] * mat._v[2]) / det;
        const m21 = (mat._v[3] * mat._v[2] - mat._v[0] * mat._v[5]) / det;
        const m22 = (mat._v[0] * mat._v[4] - mat._v[3] * mat._v[1]) / det;
        return _Matrix33.fromCopy9RowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22);
      }
      static invertTo(mat, outMat) {
        if (mat.isIdentityMatrixClass) {
          return outMat.copyComponents(mat);
        }
        const det = mat.determinant();
        if (det === 0) {
          Logger.error("the determinant is 0!");
        }
        const m00 = (mat._v[4] * mat._v[8] - mat._v[7] * mat._v[5]) / det;
        const m01 = (mat._v[6] * mat._v[5] - mat._v[3] * mat._v[8]) / det;
        const m02 = (mat._v[3] * mat._v[7] - mat._v[6] * mat._v[4]) / det;
        const m10 = (mat._v[7] * mat._v[2] - mat._v[1] * mat._v[8]) / det;
        const m11 = (mat._v[0] * mat._v[8] - mat._v[6] * mat._v[2]) / det;
        const m12 = (mat._v[6] * mat._v[1] - mat._v[0] * mat._v[7]) / det;
        const m20 = (mat._v[1] * mat._v[5] - mat._v[4] * mat._v[2]) / det;
        const m21 = (mat._v[3] * mat._v[2] - mat._v[0] * mat._v[5]) / det;
        const m22 = (mat._v[0] * mat._v[4] - mat._v[3] * mat._v[1]) / det;
        return outMat.setComponents(m00, m01, m02, m10, m11, m12, m20, m21, m22);
      }
      /**
      * Create X oriented Rotation Matrix
      */
      static rotateX(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return _Matrix33.fromCopy9RowMajor(1, 0, 0, 0, cos, -sin, 0, sin, cos);
      }
      /**
      * Create Y oriented Rotation Matrix
      */
      static rotateY(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return _Matrix33.fromCopy9RowMajor(cos, 0, sin, 0, 1, 0, -sin, 0, cos);
      }
      /**
      * Create Z oriented Rotation Matrix
      */
      static rotateZ(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return _Matrix33.fromCopy9RowMajor(cos, -sin, 0, sin, cos, 0, 0, 0, 1);
      }
      static rotateXYZ(x, y, z) {
        const cosX = Math.cos(x);
        const sinX = Math.sin(x);
        const cosY = Math.cos(y);
        const sinY = Math.sin(y);
        const cosZ = Math.cos(z);
        const sinZ = Math.sin(z);
        const x11 = cosX;
        const x12 = -sinX;
        const x21 = sinX;
        const x22 = cosX;
        const y00 = cosY;
        const y02 = sinY;
        const y20 = -sinY;
        const y22 = cosY;
        const z00 = cosZ;
        const z01 = -sinZ;
        const z10 = sinZ;
        const z11 = cosZ;
        const yx00 = y00;
        const yx01 = y02 * x21;
        const yx02 = y02 * x22;
        const yx11 = x11;
        const yx12 = x12;
        const yx20 = y20;
        const yx21 = y22 * x21;
        const yx22 = y22 * x22;
        const m00 = z00 * yx00;
        const m01 = z00 * yx01 + z01 * yx11;
        const m02 = z00 * yx02 + z01 * yx12;
        const m10 = z10 * yx00;
        const m11 = z10 * yx01 + z11 * yx11;
        const m12 = z10 * yx02 + z11 * yx12;
        const m20 = yx20;
        const m21 = yx21;
        const m22 = yx22;
        return _Matrix33.fromCopy9RowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22);
      }
      static rotate(vec) {
        return this.rotateXYZ(vec._v[0], vec._v[1], vec._v[2]);
      }
      /**
      * Create Scale Matrix
      */
      static scale(vec) {
        return _Matrix33.fromCopy9RowMajor(vec._v[0], 0, 0, 0, vec._v[1], 0, 0, 0, vec._v[2]);
      }
      /**
      * multiply matrixes
      */
      static multiply(l_mat, r_mat) {
        if (l_mat.isIdentityMatrixClass) {
          return r_mat;
        } else if (r_mat.isIdentityMatrixClass) {
          return l_mat;
        }
        const m00 = l_mat._v[0] * r_mat._v[0] + l_mat._v[3] * r_mat._v[1] + l_mat._v[6] * r_mat._v[2];
        const m10 = l_mat._v[1] * r_mat._v[0] + l_mat._v[4] * r_mat._v[1] + l_mat._v[7] * r_mat._v[2];
        const m20 = l_mat._v[2] * r_mat._v[0] + l_mat._v[5] * r_mat._v[1] + l_mat._v[8] * r_mat._v[2];
        const m01 = l_mat._v[0] * r_mat._v[3] + l_mat._v[3] * r_mat._v[4] + l_mat._v[6] * r_mat._v[5];
        const m11 = l_mat._v[1] * r_mat._v[3] + l_mat._v[4] * r_mat._v[4] + l_mat._v[7] * r_mat._v[5];
        const m21 = l_mat._v[2] * r_mat._v[3] + l_mat._v[5] * r_mat._v[4] + l_mat._v[8] * r_mat._v[5];
        const m02 = l_mat._v[0] * r_mat._v[6] + l_mat._v[3] * r_mat._v[7] + l_mat._v[6] * r_mat._v[8];
        const m12 = l_mat._v[1] * r_mat._v[6] + l_mat._v[4] * r_mat._v[7] + l_mat._v[7] * r_mat._v[8];
        const m22 = l_mat._v[2] * r_mat._v[6] + l_mat._v[5] * r_mat._v[7] + l_mat._v[8] * r_mat._v[8];
        return _Matrix33.fromCopy9RowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22);
      }
      /**
      * multiply matrixes
      */
      static multiplyTo(l_mat, r_mat, outMat) {
        if (l_mat.isIdentityMatrixClass) {
          return outMat.copyComponents(r_mat);
        } else if (r_mat.isIdentityMatrixClass) {
          return outMat.copyComponents(l_mat);
        }
        const m00 = l_mat._v[0] * r_mat._v[0] + l_mat._v[3] * r_mat._v[1] + l_mat._v[6] * r_mat._v[2];
        const m10 = l_mat._v[1] * r_mat._v[0] + l_mat._v[4] * r_mat._v[1] + l_mat._v[7] * r_mat._v[2];
        const m20 = l_mat._v[2] * r_mat._v[0] + l_mat._v[5] * r_mat._v[1] + l_mat._v[8] * r_mat._v[2];
        const m01 = l_mat._v[0] * r_mat._v[3] + l_mat._v[3] * r_mat._v[4] + l_mat._v[6] * r_mat._v[5];
        const m11 = l_mat._v[1] * r_mat._v[3] + l_mat._v[4] * r_mat._v[4] + l_mat._v[7] * r_mat._v[5];
        const m21 = l_mat._v[2] * r_mat._v[3] + l_mat._v[5] * r_mat._v[4] + l_mat._v[8] * r_mat._v[5];
        const m02 = l_mat._v[0] * r_mat._v[6] + l_mat._v[3] * r_mat._v[7] + l_mat._v[6] * r_mat._v[8];
        const m12 = l_mat._v[1] * r_mat._v[6] + l_mat._v[4] * r_mat._v[7] + l_mat._v[7] * r_mat._v[8];
        const m22 = l_mat._v[2] * r_mat._v[6] + l_mat._v[5] * r_mat._v[7] + l_mat._v[8] * r_mat._v[8];
        return outMat.setComponents(m00, m01, m02, m10, m11, m12, m20, m21, m22);
      }
      toString() {
        return this._v[0] + " " + this._v[3] + " " + this._v[6] + "\n" + this._v[1] + " " + this._v[4] + " " + this._v[7] + "\n" + this._v[2] + " " + this._v[5] + " " + this._v[8] + "\n";
      }
      toStringApproximately() {
        return MathUtil.financial(this._v[0]) + " " + MathUtil.financial(this._v[3]) + " " + MathUtil.financial(this._v[6]) + "\n" + MathUtil.financial(this._v[1]) + " " + MathUtil.financial(this._v[4]) + " " + MathUtil.financial(this._v[7]) + " \n" + MathUtil.financial(this._v[2]) + " " + MathUtil.financial(this._v[5]) + " " + MathUtil.financial(this._v[8]) + "\n";
      }
      flattenAsArray() {
        return [
          this._v[0],
          this._v[1],
          this._v[2],
          this._v[3],
          this._v[4],
          this._v[5],
          this._v[6],
          this._v[7],
          this._v[8]
        ];
      }
      isDummy() {
        if (this._v.length === 0) {
          return true;
        } else {
          return false;
        }
      }
      isEqual(mat, delta = Number.EPSILON) {
        if (Math.abs(mat._v[0] - this._v[0]) < delta && Math.abs(mat._v[1] - this._v[1]) < delta && Math.abs(mat._v[2] - this._v[2]) < delta && Math.abs(mat._v[3] - this._v[3]) < delta && Math.abs(mat._v[4] - this._v[4]) < delta && Math.abs(mat._v[5] - this._v[5]) < delta && Math.abs(mat._v[6] - this._v[6]) < delta && Math.abs(mat._v[7] - this._v[7]) < delta && Math.abs(mat._v[8] - this._v[8]) < delta) {
          return true;
        } else {
          return false;
        }
      }
      isStrictEqual(mat) {
        if (mat._v[0] === this._v[0] && mat._v[1] === this._v[1] && mat._v[2] === this._v[2] && mat._v[3] === this._v[3] && mat._v[4] === this._v[4] && mat._v[5] === this._v[5] && mat._v[6] === this._v[6] && mat._v[7] === this._v[7] && mat._v[8] === this._v[8]) {
          return true;
        } else {
          return false;
        }
      }
      at(row_i, column_i) {
        return this._v[row_i + column_i * 3];
      }
      v(i2) {
        return this._v[i2];
      }
      determinant() {
        return this._v[0] * this._v[4] * this._v[8] + this._v[1] * this._v[5] * this._v[6] + this._v[2] * this._v[3] * this._v[7] - this._v[0] * this._v[5] * this._v[7] - this._v[2] * this._v[4] * this._v[6] - this._v[1] * this._v[3] * this._v[8];
      }
      multiplyVector(vec) {
        const x = this._v[0] * vec._v[0] + this._v[3] * vec._v[1] + this._v[6] * vec._v[2];
        const y = this._v[1] * vec._v[0] + this._v[4] * vec._v[1] + this._v[7] * vec._v[2];
        const z = this._v[2] * vec._v[0] + this._v[5] * vec._v[1] + this._v[8] * vec._v[2];
        return new vec.constructor(new Float32Array([
          x,
          y,
          z
        ]));
      }
      multiplyVectorTo(vec, outVec) {
        const x = this._v[0] * vec._v[0] + this._v[3] * vec._v[1] + this._v[6] * vec._v[2];
        const y = this._v[1] * vec._v[0] + this._v[4] * vec._v[1] + this._v[7] * vec._v[2];
        const z = this._v[2] * vec._v[0] + this._v[5] * vec._v[1] + this._v[8] * vec._v[2];
        outVec._v[0] = x;
        outVec._v[1] = y;
        outVec._v[2] = z;
        return outVec;
      }
      getScale() {
        return Vector3.fromCopyArray([
          Math.hypot(this._v[0], this._v[1], this._v[2]),
          Math.hypot(this._v[3], this._v[4], this._v[5]),
          Math.hypot(this._v[6], this._v[7], this._v[8])
        ]);
      }
      getScaleTo(outVec) {
        outVec._v[0] = Math.hypot(this._v[0], this._v[1], this._v[2]);
        outVec._v[1] = Math.hypot(this._v[3], this._v[4], this._v[5]);
        outVec._v[2] = Math.hypot(this._v[6], this._v[7], this._v[8]);
        return outVec;
      }
      clone() {
        return this.constructor.fromCopy9RowMajor(this._v[0], this._v[3], this._v[6], this._v[1], this._v[4], this._v[7], this._v[2], this._v[5], this._v[8]);
      }
      /**
      * Set values as Row Major
      * Note that WebGL matrix keeps the values in column major.
      * If you write 9 values in 3x3 style (3 values in each row),
      *   It will becomes an intuitive handling.
      * @returns
      */
      static fromCopy9RowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        const v = new Float32Array(9);
        v[0] = m00;
        v[3] = m01;
        v[6] = m02;
        v[1] = m10;
        v[4] = m11;
        v[7] = m12;
        v[2] = m20;
        v[5] = m21;
        v[8] = m22;
        return new _Matrix33(v);
      }
      /**
      * Set values as Column Major
      * Note that WebGL matrix keeps the values in column major.
      * @returns
      */
      static fromCopy9ColumnMajor(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
        const v = new Float32Array(9);
        v[0] = m00;
        v[3] = m01;
        v[6] = m02;
        v[1] = m10;
        v[4] = m11;
        v[7] = m12;
        v[2] = m20;
        v[5] = m21;
        v[8] = m22;
        return new _Matrix33(v);
      }
      static fromCopyMatrix44(mat) {
        const v = new Float32Array(9);
        v[0] = mat._v[0];
        v[1] = mat._v[1];
        v[2] = mat._v[2];
        v[3] = mat._v[5];
        v[4] = mat._v[6];
        v[5] = mat._v[7];
        v[6] = mat._v[9];
        v[7] = mat._v[10];
        v[8] = mat._v[11];
        return new _Matrix33(v);
      }
      static fromFloat32ArrayColumnMajor(float32Array) {
        return new _Matrix33(float32Array);
      }
      static fromCopyFloat32ArrayColumnMajor(float32Array) {
        const v = new Float32Array(9);
        v.set(float32Array);
        return new _Matrix33(v);
      }
      static fromCopyFloat32ArrayRowMajor(array) {
        const v = new Float32Array(9);
        v[0] = array[0];
        v[3] = array[1];
        v[6] = array[2];
        v[1] = array[3];
        v[4] = array[4];
        v[7] = array[5];
        v[2] = array[6];
        v[5] = array[7];
        v[8] = array[8];
        return new _Matrix33(v);
      }
      static fromCopyMatrix33(mat) {
        const v = new Float32Array(9);
        v[0] = mat._v[0];
        v[3] = mat._v[3];
        v[6] = mat._v[6];
        v[1] = mat._v[1];
        v[4] = mat._v[4];
        v[7] = mat._v[7];
        v[2] = mat._v[2];
        v[5] = mat._v[5];
        v[8] = mat._v[8];
        return new _Matrix33(v);
      }
      static fromCopyArray9ColumnMajor(array) {
        const v = new Float32Array(9);
        v.set(array);
        return new _Matrix33(v);
      }
      static fromCopyArrayColumnMajor(array) {
        const v = new Float32Array(9);
        v.set(array);
        return new _Matrix33(v);
      }
      static fromCopyArray9RowMajor(array) {
        const v = new Float32Array(9);
        v[0] = array[0];
        v[3] = array[1];
        v[6] = array[2];
        v[1] = array[3];
        v[4] = array[4];
        v[7] = array[5];
        v[2] = array[6];
        v[5] = array[7];
        v[8] = array[8];
        return new _Matrix33(v);
      }
      static fromCopyArrayRowMajor(array) {
        const v = new Float32Array(9);
        v[0] = array[0];
        v[3] = array[1];
        v[6] = array[2];
        v[1] = array[3];
        v[4] = array[4];
        v[7] = array[5];
        v[2] = array[6];
        v[5] = array[7];
        v[8] = array[8];
        return new _Matrix33(v);
      }
      static fromCopyQuaternion(q) {
        const sx = q._v[0] * q._v[0];
        const sy = q._v[1] * q._v[1];
        const sz = q._v[2] * q._v[2];
        const cx = q._v[1] * q._v[2];
        const cy = q._v[0] * q._v[2];
        const cz = q._v[0] * q._v[1];
        const wx = q._v[3] * q._v[0];
        const wy = q._v[3] * q._v[1];
        const wz = q._v[3] * q._v[2];
        const v = new Float32Array(9);
        v[0] = 1 - 2 * (sy + sz);
        v[3] = 2 * (cz - wz);
        v[6] = 2 * (cy + wy);
        v[1] = 2 * (cz + wz);
        v[4] = 1 - 2 * (sx + sz);
        v[7] = 2 * (cx - wx);
        v[2] = 2 * (cy - wy);
        v[5] = 2 * (cx + wx);
        v[8] = 1 - 2 * (sx + sy);
        return new _Matrix33(v);
      }
    };
    __name(_Matrix33, "Matrix33");
    Matrix33 = _Matrix33;
  }
});

// src/foundation/math/MutableMatrix33.ts
var _MutableMatrix33, MutableMatrix33;
var init_MutableMatrix33 = __esm({
  "src/foundation/math/MutableMatrix33.ts"() {
    "use strict";
    init_Matrix33();
    init_Logger();
    _MutableMatrix33 = class _MutableMatrix33 extends Matrix33 {
      constructor(m) {
        super(m);
      }
      set m00(val) {
        this._v[0] = val;
      }
      get m00() {
        return this._v[0];
      }
      set m10(val) {
        this._v[1] = val;
      }
      get m10() {
        return this._v[1];
      }
      set m20(val) {
        this._v[2] = val;
      }
      get m20() {
        return this._v[2];
      }
      set m01(val) {
        this._v[3] = val;
      }
      get m01() {
        return this._v[3];
      }
      set m11(val) {
        this._v[4] = val;
      }
      get m11() {
        return this._v[4];
      }
      set m21(val) {
        this._v[5] = val;
      }
      get m21() {
        return this._v[5];
      }
      set m02(val) {
        this._v[6] = val;
      }
      get m02() {
        return this._v[6];
      }
      set m12(val) {
        this._v[7] = val;
      }
      get m12() {
        return this._v[7];
      }
      set m22(val) {
        this._v[8] = val;
      }
      get m22() {
        return this._v[8];
      }
      get className() {
        return "MutableMatrix33";
      }
      /**
      * zero matrix(static version)
      */
      static zero() {
        return super.zero();
      }
      /**
      * Create identity matrix
      */
      static identity() {
        return _MutableMatrix33.fromCopy9RowMajor(1, 0, 0, 0, 1, 0, 0, 0, 1);
      }
      static dummy() {
        return super.dummy();
      }
      /**
      * Create transpose matrix
      */
      static transpose(mat) {
        return super.transpose(mat);
      }
      /**
      * Create invert matrix
      */
      static invert(mat) {
        return super.invert(mat);
      }
      /**
      * Create X oriented Rotation Matrix
      */
      static rotateX(radian) {
        return super.rotateX(radian);
      }
      /**
      * Create Y oriented Rotation Matrix
      */
      static rotateY(radian) {
        return super.rotateY(radian);
      }
      /**
      * Create Z oriented Rotation Matrix
      */
      static rotateZ(radian) {
        return super.rotateZ(radian);
      }
      static rotateXYZ(x, y, z) {
        return super.rotateXYZ(x, y, z);
      }
      static rotate(vec) {
        return super.rotateXYZ(vec._v[0], vec._v[1], vec._v[2]);
      }
      /**
      * Create Scale Matrix
      */
      static scale(vec) {
        return super.scale(vec);
      }
      /**
      * multiply matrixes
      */
      static multiply(l_mat, r_mat) {
        return super.multiply(l_mat, r_mat);
      }
      clone() {
        const result = super.clone();
        return result;
      }
      raw() {
        return this._v;
      }
      setAt(row_i, column_i, value) {
        this._v[row_i + column_i * 3] = value;
        return this;
      }
      setComponents(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        this._v[0] = m00;
        this._v[3] = m01;
        this._v[6] = m02;
        this._v[1] = m10;
        this._v[4] = m11;
        this._v[7] = m12;
        this._v[2] = m20;
        this._v[5] = m21;
        this._v[8] = m22;
        return this;
      }
      copyComponents(mat) {
        this._v[0] = mat.m00;
        this._v[3] = mat.m01;
        this._v[6] = mat.m02;
        this._v[1] = mat.m10;
        this._v[4] = mat.m11;
        this._v[7] = mat.m12;
        this._v[2] = mat.m20;
        this._v[5] = mat.m21;
        this._v[8] = mat.m22;
        return this;
      }
      /**
      * zero matrix
      */
      zero() {
        return this.setComponents(0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
      identity() {
        return this.setComponents(1, 0, 0, 0, 1, 0, 0, 0, 1);
      }
      _swap(l2, r2) {
        this._v[r2] = [
          this._v[l2],
          this._v[l2] = this._v[r2]
        ][0];
      }
      /**
      * transpose
      */
      transpose() {
        this._swap(1, 3);
        this._swap(2, 6);
        this._swap(5, 8);
        return this;
      }
      invert() {
        const det = this.determinant();
        if (det === 0) {
          Logger.error("the determinant is 0!");
        }
        const m00 = (this._v[4] * this._v[8] - this._v[7] * this._v[5]) / det;
        const m01 = (this._v[6] * this._v[5] - this._v[3] * this._v[8]) / det;
        const m02 = (this._v[3] * this._v[7] - this._v[6] * this._v[4]) / det;
        const m10 = (this._v[7] * this._v[2] - this._v[1] * this._v[8]) / det;
        const m11 = (this._v[0] * this._v[8] - this._v[6] * this._v[2]) / det;
        const m12 = (this._v[6] * this._v[1] - this._v[0] * this._v[7]) / det;
        const m20 = (this._v[1] * this._v[5] - this._v[4] * this._v[2]) / det;
        const m21 = (this._v[3] * this._v[2] - this._v[0] * this._v[5]) / det;
        const m22 = (this._v[0] * this._v[4] - this._v[3] * this._v[1]) / det;
        return this.setComponents(m00, m01, m02, m10, m11, m12, m20, m21, m22);
      }
      /**
      * Create X oriented Rotation Matrix
      */
      rotateX(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return this.setComponents(1, 0, 0, 0, cos, -sin, 0, sin, cos);
      }
      /**
      * Create Y oriented Rotation Matrix
      */
      rotateY(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return this.setComponents(cos, 0, sin, 0, 1, 0, -sin, 0, cos);
      }
      /**
      * Create Z oriented Rotation Matrix
      */
      rotateZ(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return this.setComponents(cos, -sin, 0, sin, cos, 0, 0, 0, 1);
      }
      rotateXYZ(x, y, z) {
        const cosX = Math.cos(x);
        const sinX = Math.sin(x);
        const cosY = Math.cos(y);
        const sinY = Math.sin(y);
        const cosZ = Math.cos(z);
        const sinZ = Math.sin(z);
        const x11 = cosX;
        const x12 = -sinX;
        const x21 = sinX;
        const x22 = cosX;
        const y00 = cosY;
        const y02 = sinY;
        const y20 = -sinY;
        const y22 = cosY;
        const z00 = cosZ;
        const z01 = -sinZ;
        const z10 = sinZ;
        const z11 = cosZ;
        const yx00 = y00;
        const yx01 = y02 * x21;
        const yx02 = y02 * x22;
        const yx11 = x11;
        const yx12 = x12;
        const yx20 = y20;
        const yx21 = y22 * x21;
        const yx22 = y22 * x22;
        const m00 = z00 * yx00;
        const m01 = z00 * yx01 + z01 * yx11;
        const m02 = z00 * yx02 + z01 * yx12;
        const m10 = z10 * yx00;
        const m11 = z10 * yx01 + z11 * yx11;
        const m12 = z10 * yx02 + z11 * yx12;
        const m20 = yx20;
        const m21 = yx21;
        const m22 = yx22;
        return this.setComponents(m00, m01, m02, m10, m11, m12, m20, m21, m22);
      }
      rotate(vec) {
        return this.rotateXYZ(vec._v[0], vec._v[1], vec._v[2]);
      }
      scale(vec) {
        return this.setComponents(vec._v[0], 0, 0, 0, vec._v[1], 0, 0, 0, vec._v[2]);
      }
      multiplyScale(vec) {
        this._v[0] *= vec._v[0];
        this._v[3] *= vec._v[0];
        this._v[6] *= vec._v[0];
        this._v[1] *= vec._v[1];
        this._v[4] *= vec._v[1];
        this._v[7] *= vec._v[1];
        this._v[2] *= vec._v[2];
        this._v[5] *= vec._v[2];
        this._v[8] *= vec._v[2];
        return this;
      }
      /**
      * multiply the input matrix from right side
      */
      multiply(mat) {
        if (mat.isIdentityMatrixClass) {
          return this;
        }
        const m00 = this._v[0] * mat._v[0] + this._v[3] * mat._v[1] + this._v[6] * mat._v[2];
        const m01 = this._v[0] * mat._v[3] + this._v[3] * mat._v[4] + this._v[6] * mat._v[5];
        const m02 = this._v[0] * mat._v[6] + this._v[3] * mat._v[7] + this._v[6] * mat._v[8];
        const m10 = this._v[1] * mat._v[0] + this._v[4] * mat._v[1] + this._v[7] * mat._v[2];
        const m11 = this._v[1] * mat._v[3] + this._v[4] * mat._v[4] + this._v[7] * mat._v[5];
        const m12 = this._v[1] * mat._v[6] + this._v[4] * mat._v[7] + this._v[7] * mat._v[8];
        const m20 = this._v[2] * mat._v[0] + this._v[5] * mat._v[1] + this._v[8] * mat._v[2];
        const m21 = this._v[2] * mat._v[3] + this._v[5] * mat._v[4] + this._v[8] * mat._v[5];
        const m22 = this._v[2] * mat._v[6] + this._v[5] * mat._v[7] + this._v[8] * mat._v[8];
        return this.setComponents(m00, m01, m02, m10, m11, m12, m20, m21, m22);
      }
      multiplyByLeft(mat) {
        if (mat.isIdentityMatrixClass) {
          return this;
        }
        const m00 = mat._v[0] * this._v[0] + mat._v[3] * this._v[1] + mat._v[6] * this._v[2];
        const m01 = mat._v[0] * this._v[3] + mat._v[3] * this._v[4] + mat._v[6] * this._v[5];
        const m02 = mat._v[0] * this._v[6] + mat._v[3] * this._v[7] + mat._v[6] * this._v[8];
        const m10 = mat._v[1] * this._v[0] + mat._v[4] * this._v[1] + mat._v[7] * this._v[2];
        const m11 = mat._v[1] * this._v[3] + mat._v[4] * this._v[4] + mat._v[7] * this._v[5];
        const m12 = mat._v[1] * this._v[6] + mat._v[4] * this._v[7] + mat._v[7] * this._v[8];
        const m20 = mat._v[2] * this._v[0] + mat._v[5] * this._v[1] + mat._v[8] * this._v[2];
        const m21 = mat._v[2] * this._v[3] + mat._v[5] * this._v[4] + mat._v[8] * this._v[5];
        const m22 = mat._v[2] * this._v[6] + mat._v[5] * this._v[7] + mat._v[8] * this._v[8];
        return this.setComponents(m00, m01, m02, m10, m11, m12, m20, m21, m22);
      }
      /**
      * Set values as Row Major
      * Note that WebGL matrix keeps the values in column major.
      * If you write 9 values in 3x3 style (3 values in each row),
      *   It will becomes an intuitive handling.
      * @returns
      */
      static fromCopy9RowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        const v = new Float32Array(9);
        v[0] = m00;
        v[3] = m01;
        v[6] = m02;
        v[1] = m10;
        v[4] = m11;
        v[7] = m12;
        v[2] = m20;
        v[5] = m21;
        v[8] = m22;
        return new _MutableMatrix33(v);
      }
      /**
      * Set values as Column Major
      * Note that WebGL matrix keeps the values in column major.
      * @returns
      */
      static fromCopy9ColumnMajor(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
        const v = new Float32Array(9);
        v[0] = m00;
        v[3] = m01;
        v[6] = m02;
        v[1] = m10;
        v[4] = m11;
        v[7] = m12;
        v[2] = m20;
        v[5] = m21;
        v[8] = m22;
        return new _MutableMatrix33(v);
      }
      static fromCopyMatrix44(mat) {
        const v = new Float32Array(9);
        v.set(mat._v);
        return new _MutableMatrix33(v);
      }
      static fromFloat32ArrayColumnMajor(float32Array) {
        return new _MutableMatrix33(float32Array);
      }
      static fromCopyFloat32ArrayColumnMajor(float32Array) {
        const v = new Float32Array(9);
        v.set(float32Array);
        return new _MutableMatrix33(v);
      }
      static fromCopyFloat32ArrayRowMajor(array) {
        const v = new Float32Array(9);
        v[0] = array[0];
        v[3] = array[1];
        v[6] = array[2];
        v[1] = array[3];
        v[4] = array[4];
        v[7] = array[5];
        v[2] = array[6];
        v[5] = array[7];
        v[8] = array[8];
        return new _MutableMatrix33(v);
      }
      static fromCopyMatrix33(mat) {
        const v = new Float32Array(9);
        v[0] = mat._v[0];
        v[3] = mat._v[3];
        v[6] = mat._v[6];
        v[1] = mat._v[1];
        v[4] = mat._v[4];
        v[7] = mat._v[7];
        v[2] = mat._v[2];
        v[5] = mat._v[5];
        v[8] = mat._v[8];
        return new _MutableMatrix33(v);
      }
      static fromCopyArray9ColumnMajor(array) {
        const v = new Float32Array(9);
        v.set(array);
        return new _MutableMatrix33(v);
      }
      static fromCopyArrayColumnMajor(array) {
        const v = new Float32Array(9);
        v.set(array);
        return new _MutableMatrix33(v);
      }
      static fromCopyArray9RowMajor(array) {
        const v = new Float32Array(9);
        v[0] = array[0];
        v[3] = array[1];
        v[6] = array[2];
        v[1] = array[3];
        v[4] = array[4];
        v[7] = array[5];
        v[2] = array[6];
        v[5] = array[7];
        v[8] = array[8];
        return new _MutableMatrix33(v);
      }
      static fromCopyArrayRowMajor(array) {
        const v = new Float32Array(9);
        v[0] = array[0];
        v[3] = array[1];
        v[6] = array[2];
        v[1] = array[3];
        v[4] = array[4];
        v[7] = array[5];
        v[2] = array[6];
        v[5] = array[7];
        v[8] = array[8];
        return new _MutableMatrix33(v);
      }
      static fromCopyQuaternion(q) {
        const sx = q._v[0] * q._v[0];
        const sy = q._v[1] * q._v[1];
        const sz = q._v[2] * q._v[2];
        const cx = q._v[1] * q._v[2];
        const cy = q._v[0] * q._v[2];
        const cz = q._v[0] * q._v[1];
        const wx = q._v[3] * q._v[0];
        const wy = q._v[3] * q._v[1];
        const wz = q._v[3] * q._v[2];
        const v = new Float32Array(9);
        v[0] = 1 - 2 * (sy + sz);
        v[3] = 2 * (cz - wz);
        v[6] = 2 * (cy + wy);
        v[1] = 2 * (cz + wz);
        v[4] = 1 - 2 * (sx + sz);
        v[7] = 2 * (cx - wx);
        v[2] = 2 * (cy - wy);
        v[5] = 2 * (cx + wx);
        v[8] = 1 - 2 * (sx + sy);
        return new _MutableMatrix33(v);
      }
    };
    __name(_MutableMatrix33, "MutableMatrix33");
    MutableMatrix33 = _MutableMatrix33;
  }
});

// src/foundation/math/Vector4.ts
var _Vector4_, Vector4_, _Vector4, Vector4, _Vector4d, Vector4d, ConstVector4_1_1_1_1, ConstVector4_0_0_0_1, ConstVector4_0_0_0_0;
var init_Vector4 = __esm({
  "src/foundation/math/Vector4.ts"() {
    "use strict";
    init_MathUtil();
    init_CompositionType();
    init_AbstractVector();
    init_Logger();
    _Vector4_ = class _Vector4_ extends AbstractVector {
      constructor(v, { type }) {
        super();
        this._v = v;
      }
      get x() {
        return this._v[0];
      }
      get y() {
        return this._v[1];
      }
      get z() {
        return this._v[2];
      }
      get w() {
        return this._v[3];
      }
      get glslStrAsFloat() {
        return `vec4(${MathUtil.convertToStringAsGLSLFloat(this._v[0])}, ${MathUtil.convertToStringAsGLSLFloat(this._v[1])}, ${MathUtil.convertToStringAsGLSLFloat(this._v[2])}, ${MathUtil.convertToStringAsGLSLFloat(this._v[3])})`;
      }
      get glslStrAsInt() {
        return `ivec4(${Math.floor(this._v[0])}, ${Math.floor(this._v[1])}, ${Math.floor(this._v[2])}, ${Math.floor(this._v[3])})`;
      }
      static _fromCopyArray4(array, type) {
        return new this(new type(array), {
          type
        });
      }
      static _fromCopy4(x, y, z, w, type) {
        return new this(new type([
          x,
          y,
          z,
          w
        ]), {
          type
        });
      }
      static _fromCopyArray(array, type) {
        return new this(new type(array.slice(0, 4)), {
          type
        });
      }
      static _fromCopyVector4(vec4, type) {
        const vec = new this(new type([
          vec4._v[0],
          vec4._v[1],
          vec4._v[2],
          vec4._v[3]
        ]), {
          type
        });
        return vec;
      }
      static _fromCopyVector3(vec3, type) {
        const vec = new this(new type([
          vec3._v[0],
          vec3._v[1],
          vec3._v[2],
          1
        ]), {
          type
        });
        return vec;
      }
      static _fromVector2(vec2, type) {
        const vec = new this(new type([
          vec2._v[0],
          vec2._v[1],
          0,
          1
        ]), {
          type
        });
        return vec;
      }
      static get compositionType() {
        return CompositionType.Vec4;
      }
      /**
      * to square length(static version)
      */
      static lengthSquared(vec) {
        return vec.lengthSquared();
      }
      static lengthBtw(l_vec, r_vec) {
        return l_vec.lengthTo(r_vec);
      }
      /**
      * Zero Vector
      */
      static _zero(type) {
        return new this(new type([
          0,
          0,
          0,
          0
        ]), {
          type
        });
      }
      static _one(type) {
        return new this(new type([
          1,
          1,
          1,
          1
        ]), {
          type
        });
      }
      static _dummy(type) {
        return new this(new type([]), {
          type
        });
      }
      /**
      * normalize(static version)
      */
      static _normalize(vec, type) {
        const length = vec.length();
        return this._divide(vec, length, type);
      }
      /**
      * add value（static version）
      */
      static _add(l_vec, r_vec, type) {
        const x = l_vec._v[0] + r_vec._v[0];
        const y = l_vec._v[1] + r_vec._v[1];
        const z = l_vec._v[2] + r_vec._v[2];
        const w = l_vec._v[3] + r_vec._v[3];
        return new this(new type([
          x,
          y,
          z,
          w
        ]), {
          type
        });
      }
      /**
      * add value（static version）
      */
      static addTo(l_vec, r_vec, out) {
        out._v[0] = l_vec._v[0] + r_vec._v[0];
        out._v[1] = l_vec._v[1] + r_vec._v[1];
        out._v[2] = l_vec._v[2] + r_vec._v[2];
        out._v[3] = l_vec._v[3] + r_vec._v[3];
        return out;
      }
      /**
      * subtract(static version)
      */
      static _subtract(l_vec, r_vec, type) {
        const x = l_vec._v[0] - r_vec._v[0];
        const y = l_vec._v[1] - r_vec._v[1];
        const z = l_vec._v[2] - r_vec._v[2];
        const w = l_vec._v[3] - r_vec._v[3];
        return new this(new type([
          x,
          y,
          z,
          w
        ]), {
          type
        });
      }
      /**
      * subtract(static version)
      */
      static subtractTo(l_vec, r_vec, out) {
        out._v[0] = l_vec._v[0] - r_vec._v[0];
        out._v[1] = l_vec._v[1] - r_vec._v[1];
        out._v[2] = l_vec._v[2] - r_vec._v[2];
        out._v[3] = l_vec._v[3] - r_vec._v[3];
        return out;
      }
      /**
      * multiply(static version)
      */
      static _multiply(vec, value, type) {
        const x = vec._v[0] * value;
        const y = vec._v[1] * value;
        const z = vec._v[2] * value;
        const w = vec._v[3] * value;
        return new this(new type([
          x,
          y,
          z,
          w
        ]), {
          type
        });
      }
      /**
      * multiplyTo(static version)
      */
      static multiplyTo(vec, value, out) {
        out._v[0] = vec._v[0] * value;
        out._v[1] = vec._v[1] * value;
        out._v[2] = vec._v[2] * value;
        out._v[3] = vec._v[3] * value;
        return out;
      }
      /**
      * multiply vector(static version)
      */
      static _multiplyVector(l_vec, r_vec, type) {
        const x = l_vec._v[0] * r_vec._v[0];
        const y = l_vec._v[1] * r_vec._v[1];
        const z = l_vec._v[2] * r_vec._v[2];
        const w = l_vec._v[3] * r_vec._v[3];
        return new this(new type([
          x,
          y,
          z,
          w
        ]), {
          type
        });
      }
      /**
      * multiply vector(static version)
      */
      static multiplyVectorTo(l_vec, r_vec, out) {
        out._v[0] = l_vec._v[0] * r_vec._v[0];
        out._v[1] = l_vec._v[1] * r_vec._v[1];
        out._v[2] = l_vec._v[2] * r_vec._v[2];
        out._v[3] = l_vec._v[3] * r_vec._v[3];
        return out;
      }
      /**
      * divide(static version)
      */
      static _divide(vec, value, type) {
        let x;
        let y;
        let z;
        let w;
        if (value !== 0) {
          x = vec._v[0] / value;
          y = vec._v[1] / value;
          z = vec._v[2] / value;
          w = vec._v[3] / value;
        } else {
          Logger.error("0 division occurred!");
          x = Infinity;
          y = Infinity;
          z = Infinity;
          w = Infinity;
        }
        return new this(new type([
          x,
          y,
          z,
          w
        ]), {
          type
        });
      }
      /**
      * divide by value(static version)
      */
      static divideTo(vec, value, out) {
        if (value !== 0) {
          out._v[0] = vec._v[0] / value;
          out._v[1] = vec._v[1] / value;
          out._v[2] = vec._v[2] / value;
          out._v[3] = vec._v[3] / value;
        } else {
          Logger.error("0 division occurred!");
          out._v[0] = Infinity;
          out._v[1] = Infinity;
          out._v[2] = Infinity;
          out._v[3] = Infinity;
        }
        return out;
      }
      /**
      * divide vector(static version)
      */
      static _divideVector(l_vec, r_vec, type) {
        let x;
        let y;
        let z;
        let w;
        if (r_vec._v[0] !== 0 && r_vec._v[1] !== 0 && r_vec._v[2] !== 0 && r_vec._v[3] !== 0) {
          x = l_vec._v[0] / r_vec._v[0];
          y = l_vec._v[1] / r_vec._v[1];
          z = l_vec._v[2] / r_vec._v[2];
          w = l_vec._v[3] / r_vec._v[3];
        } else {
          Logger.error("0 division occurred!");
          x = r_vec._v[0] === 0 ? Infinity : l_vec._v[0] / r_vec._v[0];
          y = r_vec._v[1] === 0 ? Infinity : l_vec._v[1] / r_vec._v[1];
          z = r_vec._v[2] === 0 ? Infinity : l_vec._v[2] / r_vec._v[2];
          w = r_vec._v[3] === 0 ? Infinity : l_vec._v[3] / r_vec._v[3];
        }
        return new this(new type([
          x,
          y,
          z,
          w
        ]), {
          type
        });
      }
      /**
      * divide by vector(static version)
      */
      static divideVectorTo(l_vec, r_vec, out) {
        if (r_vec._v[0] !== 0 && r_vec._v[1] !== 0 && r_vec._v[2] !== 0 && r_vec._v[3] !== 0) {
          out._v[0] = l_vec._v[0] / r_vec._v[0];
          out._v[1] = l_vec._v[1] / r_vec._v[1];
          out._v[2] = l_vec._v[2] / r_vec._v[2];
          out._v[3] = l_vec._v[3] / r_vec._v[3];
        } else {
          Logger.error("0 division occurred!");
          out._v[0] = r_vec._v[0] === 0 ? Infinity : l_vec._v[0] / r_vec._v[0];
          out._v[1] = r_vec._v[1] === 0 ? Infinity : l_vec._v[1] / r_vec._v[1];
          out._v[2] = r_vec._v[2] === 0 ? Infinity : l_vec._v[2] / r_vec._v[2];
          out._v[3] = r_vec._v[3] === 0 ? Infinity : l_vec._v[3] / r_vec._v[3];
        }
        return out;
      }
      /**
      * dot product(static version)
      */
      static dot(l_vec, r_vec) {
        return l_vec.dot(r_vec);
      }
      toString() {
        return "(" + this._v[0] + ", " + this._v[1] + ", " + this._v[2] + ", " + this._v[3] + ")";
      }
      toStringApproximately() {
        return MathUtil.financial(this._v[0]) + " " + MathUtil.financial(this._v[1]) + " " + MathUtil.financial(this._v[2]) + " " + MathUtil.financial(this._v[3]) + "\n";
      }
      flattenAsArray() {
        return [
          this._v[0],
          this._v[1],
          this._v[2],
          this._v[3]
        ];
      }
      isDummy() {
        if (this._v.length === 0) {
          return true;
        } else {
          return false;
        }
      }
      isEqual(vec, delta = Number.EPSILON) {
        if (Math.abs(vec._v[0] - this._v[0]) < delta && Math.abs(vec._v[1] - this._v[1]) < delta && Math.abs(vec._v[2] - this._v[2]) < delta && Math.abs(vec._v[3] - this._v[3]) < delta) {
          return true;
        } else {
          return false;
        }
      }
      isStrictEqual(vec) {
        if (this._v[0] === vec._v[0] && this._v[1] === vec._v[1] && this._v[2] === vec._v[2] && this._v[3] === vec._v[3]) {
          return true;
        } else {
          return false;
        }
      }
      at(i2) {
        return this._v[i2];
      }
      length() {
        return Math.hypot(this._v[0], this._v[1], this._v[2], this._v[3]);
      }
      lengthSquared() {
        return this._v[0] ** 2 + this._v[1] ** 2 + this._v[2] ** 2 + this._v[3] ** 2;
      }
      lengthTo(vec) {
        const deltaX = this._v[0] - vec._v[0];
        const deltaY = this._v[1] - vec._v[1];
        const deltaZ = this._v[2] - vec._v[2];
        const deltaW = this._v[3] - vec._v[3];
        return Math.hypot(deltaX, deltaY, deltaZ, deltaW);
      }
      /**
      * dot product
      */
      dot(vec) {
        return this._v[0] * vec._v[0] + this._v[1] * vec._v[1] + this._v[2] * vec._v[2] + this._v[3] * vec._v[3];
      }
      get className() {
        return "Vector4";
      }
      clone() {
        return new this.constructor(new this._v.constructor([
          this._v[0],
          this._v[1],
          this._v[2],
          this._v[3]
        ]));
      }
      get bytesPerComponent() {
        return this._v.BYTES_PER_ELEMENT;
      }
    };
    __name(_Vector4_, "Vector4_");
    Vector4_ = _Vector4_;
    _Vector4 = class _Vector4 extends Vector4_ {
      constructor(x) {
        super(x, {
          type: Float32Array
        });
      }
      static fromCopyArray(array) {
        return super._fromCopyArray(array, Float32Array);
      }
      static fromCopyArray4(array) {
        return super._fromCopyArray4(array, Float32Array);
      }
      static fromCopy4(x, y, z, w) {
        return super._fromCopy4(x, y, z, w, Float32Array);
      }
      static fromCopyVector3(vec3) {
        return super._fromCopyVector3(vec3, Float32Array);
      }
      static fromCopyVector4(vec4) {
        return super._fromCopyVector4(vec4, Float32Array);
      }
      static fromArrayBuffer(arrayBuffer) {
        return new _Vector4(new Float32Array(arrayBuffer));
      }
      static fromFloat32Array(float32Array) {
        return new _Vector4(float32Array);
      }
      static fromCopyFloat32Array(float32Array) {
        return new _Vector4(float32Array.slice(0));
      }
      static zero() {
        return super._zero(Float32Array);
      }
      static one() {
        return super._one(Float32Array);
      }
      static dummy() {
        return super._dummy(Float32Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float32Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
      }
      clone() {
        return super.clone();
      }
    };
    __name(_Vector4, "Vector4");
    Vector4 = _Vector4;
    _Vector4d = class _Vector4d extends Vector4_ {
      constructor(x) {
        super(x, {
          type: Float64Array
        });
      }
      static fromCopyArray4(array) {
        return super._fromCopyArray4(array, Float64Array);
      }
      static fromCopy4(x, y, z, w) {
        return super._fromCopy4(x, y, z, w, Float64Array);
      }
      static fromCopyArray(array) {
        return super._fromCopyArray(array, Float64Array);
      }
      static fromArrayBuffer(arrayBuffer) {
        return new _Vector4d(new Float64Array(arrayBuffer));
      }
      static fromFloat64Array(float64Array) {
        return new _Vector4d(float64Array);
      }
      static zero() {
        return super._zero(Float64Array);
      }
      static one() {
        return super._one(Float64Array);
      }
      static dummy() {
        return super._dummy(Float64Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float64Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float64Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float64Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float64Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float64Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float64Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float64Array);
      }
      clone() {
        return super.clone();
      }
    };
    __name(_Vector4d, "Vector4d");
    Vector4d = _Vector4d;
    ConstVector4_1_1_1_1 = Vector4.fromCopy4(1, 1, 1, 1);
    ConstVector4_0_0_0_1 = Vector4.fromCopy4(0, 0, 0, 1);
    ConstVector4_0_0_0_0 = Vector4.fromCopy4(0, 0, 0, 0);
  }
});

// src/foundation/math/IdentityMatrix44.ts
var _IdentityMatrix44, IdentityMatrix44;
var init_IdentityMatrix44 = __esm({
  "src/foundation/math/IdentityMatrix44.ts"() {
    "use strict";
    init_CompositionType();
    init_AbstractMatrix();
    init_Vector3();
    _IdentityMatrix44 = class _IdentityMatrix44 extends AbstractMatrix {
      constructor() {
        super();
        this._v = _IdentityMatrix44.__v;
      }
      toString() {
        return `1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
`;
      }
      toStringApproximately() {
        return this.toString();
      }
      flattenAsArray() {
        return [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
      }
      isDummy() {
        return false;
      }
      isEqual(mat, delta = Number.EPSILON) {
        if (Math.abs(mat.m00 - 1) < delta && Math.abs(mat.m10) < delta && Math.abs(mat.m20) < delta && Math.abs(mat.m30) < delta && Math.abs(mat.m01) < delta && Math.abs(mat.m11 - 1) < delta && Math.abs(mat.m21) < delta && Math.abs(mat.m31) < delta && Math.abs(mat.m02) < delta && Math.abs(mat.m12) < delta && Math.abs(mat.m22 - 1) < delta && Math.abs(mat.m32) < delta && Math.abs(mat.m03) < delta && Math.abs(mat.m13) < delta && Math.abs(mat.m23) < delta && Math.abs(mat.m33 - 1) < delta) {
          return true;
        } else {
          return false;
        }
      }
      isStrictEqual(mat) {
        const v = mat._v;
        if (v[0] === 1 && v[1] === 0 && v[2] === 0 && v[3] === 0 && v[4] === 0 && v[5] === 1 && v[6] === 0 && v[7] === 0 && v[8] === 0 && v[9] === 0 && v[10] === 1 && v[11] === 0 && v[12] === 0 && v[13] === 0 && v[14] === 0 && v[15] === 1) {
          return true;
        } else {
          return false;
        }
      }
      at(row_i, column_i) {
        return row_i === column_i ? 1 : 0;
      }
      v(i2) {
        return i2 % 5 === 0 ? 1 : 0;
      }
      determinant() {
        return 1;
      }
      multiplyVector(vec) {
        return vec;
      }
      multiplyVector3(vec) {
        return vec;
      }
      multiplyVectorTo(vec, outVec) {
        const v = vec._v;
        outVec._v[0] = v[0];
        outVec._v[1] = v[1];
        outVec._v[2] = v[2];
        outVec._v[3] = v[3];
        return outVec;
      }
      getScale() {
        return Vector3.one();
      }
      getScaleTo(outVec) {
        const v = outVec._v;
        v[0] = 1;
        v[1] = 1;
        v[2] = 1;
        return outVec;
      }
      clone() {
        return new _IdentityMatrix44();
      }
      getRotate() {
        return new _IdentityMatrix44();
      }
      getTranslate() {
        return Vector3.zero();
      }
      get m00() {
        return 1;
      }
      get m10() {
        return 0;
      }
      get m20() {
        return 0;
      }
      get m30() {
        return 0;
      }
      get m01() {
        return 0;
      }
      get m11() {
        return 1;
      }
      get m21() {
        return 0;
      }
      get m31() {
        return 0;
      }
      get m02() {
        return 0;
      }
      get m12() {
        return 0;
      }
      get m22() {
        return 1;
      }
      get m32() {
        return 0;
      }
      get m03() {
        return 0;
      }
      get m13() {
        return 0;
      }
      get m23() {
        return 0;
      }
      get m33() {
        return 1;
      }
      get translateX() {
        return 0;
      }
      get translateY() {
        return 0;
      }
      get translateZ() {
        return 0;
      }
      get className() {
        return "IdentityMatrix44";
      }
      static get compositionType() {
        return CompositionType.Mat4;
      }
      get isIdentityMatrixClass() {
        return true;
      }
    };
    __name(_IdentityMatrix44, "IdentityMatrix44");
    __publicField(_IdentityMatrix44, "__v", new Float32Array([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]));
    IdentityMatrix44 = _IdentityMatrix44;
  }
});

// src/foundation/math/raw/raw_extension.ts
var get1, get1_offset, get1_offsetAsComposition, get2, get2_offset, get2_offsetAsComposition, get3, get3_offset, get3_offsetAsComposition, get4, get4_offset, get4_offsetAsComposition, getN_offset, getN_offsetAsComposition, add2, add2_offset, add3, add3_offset, add4, mulArray3WithScalar_offset, mulArray4WithScalar_offset, mulArrayNWithScalar_offset, mulThatAndThisToOutAsMat44_offsetAsComposition, add4_offset, qlerp_offsetAsComposition, scalar_lerp_offsetAsComposition, array3_lerp_offsetAsComposition, arrayN_lerp_offsetAsComposition, normalizeArray4, get1_fn, get1_offset_fn, get1_offsetAsComposition_fn, get2_fn, get2_offset_fn, get2_offsetAsComposition_fn, get3_fn, get3_offset_fn, get3_offsetAsComposition_fn, get4_fn, get4_offset_fn, get4_offsetAsComposition_fn, getN_offset_fn, getN_offsetAsComposition_fn, add2_fn, add2_offset_fn, add3_fn, add3_offset_fn, add4_fn, add4_offset_fn, mulArray3WithScalar_offset_fn, mulArray4WithScalar_offset_fn, mulArrayNWithScalar_offset_fn, mulThatAndThisToOutAsMat44_offsetAsComposition_fn, qlerp_offsetAsComposition_fn, scalar_lerp_offsetAsComposition_fn, array3_lerp_offsetAsComposition_fn, arrayN_lerp_offsetAsComposition_fn, normalizeArray4_fn, arrayTypes, operators, functions;
var init_raw_extension = __esm({
  "src/foundation/math/raw/raw_extension.ts"() {
    "use strict";
    get1 = Symbol("get1");
    get1_offset = Symbol("get1_offset");
    get1_offsetAsComposition = Symbol("get1_offsetAsComposition");
    get2 = Symbol("get2");
    get2_offset = Symbol("get2_offset");
    get2_offsetAsComposition = Symbol("get2_offsetAsComposition");
    get3 = Symbol("get3");
    get3_offset = Symbol("get3_offset");
    get3_offsetAsComposition = Symbol("get3_offsetAsComposition");
    get4 = Symbol("get4");
    get4_offset = Symbol("get4_offset");
    get4_offsetAsComposition = Symbol("get4_offsetAsComposition");
    getN_offset = Symbol("getN_offset");
    getN_offsetAsComposition = Symbol("getN_offsetAsComposition");
    add2 = Symbol("add2");
    add2_offset = Symbol("add2_offset");
    add3 = Symbol("add3");
    add3_offset = Symbol("add3_offset");
    add4 = Symbol("add4");
    mulArray3WithScalar_offset = Symbol("mulArray3WithScalar_offset");
    mulArray4WithScalar_offset = Symbol("mulArray4WithScalar_offset");
    mulArrayNWithScalar_offset = Symbol("mulArrayNWithScalar_offset");
    mulThatAndThisToOutAsMat44_offsetAsComposition = Symbol("mulThatAndThisToOutAsMat44_offsetAsComposition");
    add4_offset = Symbol("add4_offset");
    qlerp_offsetAsComposition = Symbol("qlerp_offsetAsComposition");
    scalar_lerp_offsetAsComposition = Symbol("scalar_lerp_offsetAsComposition");
    array3_lerp_offsetAsComposition = Symbol("array3_lerp_offsetAsComposition");
    arrayN_lerp_offsetAsComposition = Symbol("arrayN_lerp_offsetAsComposition");
    normalizeArray4 = Symbol("normalizeArray4");
    get1_fn = /* @__PURE__ */ __name(function() {
      return [
        this[0]
      ];
    }, "get1_fn");
    get1_offset_fn = /* @__PURE__ */ __name(function(offset) {
      return [
        this[offset]
      ];
    }, "get1_offset_fn");
    get1_offsetAsComposition_fn = /* @__PURE__ */ __name(function(offsetAsComposition) {
      return [
        this[offsetAsComposition]
      ];
    }, "get1_offsetAsComposition_fn");
    get2_fn = /* @__PURE__ */ __name(function() {
      return [
        this[0],
        this[1]
      ];
    }, "get2_fn");
    get2_offset_fn = /* @__PURE__ */ __name(function(offset) {
      return [
        this[offset],
        this[offset + 1]
      ];
    }, "get2_offset_fn");
    get2_offsetAsComposition_fn = /* @__PURE__ */ __name(function(offsetAsComposition) {
      return [
        this[offsetAsComposition * 2],
        this[offsetAsComposition * 2 + 1]
      ];
    }, "get2_offsetAsComposition_fn");
    get3_fn = /* @__PURE__ */ __name(function() {
      return [
        this[0],
        this[1],
        this[2]
      ];
    }, "get3_fn");
    get3_offset_fn = /* @__PURE__ */ __name(function(offset) {
      return [
        this[offset],
        this[offset + 1],
        this[offset + 2]
      ];
    }, "get3_offset_fn");
    get3_offsetAsComposition_fn = /* @__PURE__ */ __name(function(offsetAsComposition) {
      return [
        this[offsetAsComposition * 3],
        this[offsetAsComposition * 3 + 1],
        this[offsetAsComposition * 3 + 2]
      ];
    }, "get3_offsetAsComposition_fn");
    get4_fn = /* @__PURE__ */ __name(function() {
      return [
        this[0],
        this[1],
        this[2],
        this[3]
      ];
    }, "get4_fn");
    get4_offset_fn = /* @__PURE__ */ __name(function(offset) {
      return [
        this[offset],
        this[offset + 1],
        this[offset + 2],
        this[offset + 3]
      ];
    }, "get4_offset_fn");
    get4_offsetAsComposition_fn = /* @__PURE__ */ __name(function(offsetAsComposition) {
      return [
        this[offsetAsComposition * 4],
        this[offsetAsComposition * 4 + 1],
        this[offsetAsComposition * 4 + 2],
        this[offsetAsComposition * 4 + 3]
      ];
    }, "get4_offsetAsComposition_fn");
    getN_offset_fn = /* @__PURE__ */ __name(function(offset, componentN) {
      const array = new Array(componentN);
      for (let i2 = 0; i2 < componentN; i2++) {
        array[i2] = this[offset + i2];
      }
      return array;
    }, "getN_offset_fn");
    getN_offsetAsComposition_fn = /* @__PURE__ */ __name(function(offsetAsComposition, componentN) {
      const array = new Array(componentN);
      for (let i2 = 0; i2 < componentN; i2++) {
        array[i2] = this[offsetAsComposition * componentN + i2];
      }
      return array;
    }, "getN_offsetAsComposition_fn");
    add2_fn = /* @__PURE__ */ __name(function(array) {
      this[0] += array[0];
      this[1] += array[1];
      return this;
    }, "add2_fn");
    add2_offset_fn = /* @__PURE__ */ __name(function(array, selfOffset, argOffset) {
      this[selfOffset] += array[argOffset];
      this[selfOffset + 1] += array[argOffset + 1];
      return this;
    }, "add2_offset_fn");
    add3_fn = /* @__PURE__ */ __name(function(array) {
      this[0] += array[0];
      this[1] += array[1];
      this[2] += array[2];
      return this;
    }, "add3_fn");
    add3_offset_fn = /* @__PURE__ */ __name(function(array, selfOffset, argOffset) {
      this[selfOffset] += array[argOffset];
      this[selfOffset + 1] += array[argOffset + 1];
      this[selfOffset + 2] += array[argOffset + 2];
      return this;
    }, "add3_offset_fn");
    add4_fn = /* @__PURE__ */ __name(function(array) {
      this[0] += array[0];
      this[1] += array[1];
      this[2] += array[2];
      this[3] += array[3];
      return this;
    }, "add4_fn");
    add4_offset_fn = /* @__PURE__ */ __name(function(array, selfOffset, argOffset) {
      this[selfOffset] += array[argOffset];
      this[selfOffset + 1] += array[argOffset + 1];
      this[selfOffset + 2] += array[argOffset + 2];
      this[selfOffset + 3] += array[argOffset + 3];
      return this;
    }, "add4_offset_fn");
    mulArray3WithScalar_offset_fn = /* @__PURE__ */ __name(function(offset, value) {
      this[offset] *= value;
      this[offset + 1] *= value;
      this[offset + 2] *= value;
      return this;
    }, "mulArray3WithScalar_offset_fn");
    mulArray4WithScalar_offset_fn = /* @__PURE__ */ __name(function(offset, value) {
      this[offset] *= value;
      this[offset + 1] *= value;
      this[offset + 2] *= value;
      this[offset + 3] *= value;
      return this;
    }, "mulArray4WithScalar_offset_fn");
    mulArrayNWithScalar_offset_fn = /* @__PURE__ */ __name(function(offset, componentN, value) {
      for (let i2 = 0; i2 < componentN; i2++) {
        this[offset + i2] *= value;
      }
      return this;
    }, "mulArrayNWithScalar_offset_fn");
    mulThatAndThisToOutAsMat44_offsetAsComposition_fn = /* @__PURE__ */ __name(function(thisOffsetAsComposition, that, thatOffsetAsComposition, out) {
      const lv = that;
      const rv = this;
      const l2 = thatOffsetAsComposition * 16;
      const r2 = thisOffsetAsComposition * 16;
      out[0] = lv[l2] * rv[r2] + lv[l2 + 4] * rv[r2 + 1] + lv[l2 + 8] * rv[r2 + 2] + lv[l2 + 12] * rv[r2 + 3];
      out[1] = lv[l2 + 1] * rv[r2] + lv[l2 + 5] * rv[r2 + 1] + lv[l2 + 9] * rv[r2 + 2] + lv[l2 + 13] * rv[r2 + 3];
      out[2] = lv[l2 + 2] * rv[r2] + lv[l2 + 6] * rv[r2 + 1] + lv[l2 + 10] * rv[r2 + 2] + lv[l2 + 14] * rv[r2 + 3];
      out[3] = lv[l2 + 3] * rv[r2] + lv[l2 + 7] * rv[r2 + 1] + lv[l2 + 11] * rv[r2 + 2] + lv[l2 + 15] * rv[r2 + 3];
      out[4] = lv[l2] * rv[r2 + 4] + lv[l2 + 4] * rv[r2 + 5] + lv[l2 + 8] * rv[r2 + 6] + lv[l2 + 12] * rv[r2 + 7];
      out[5] = lv[l2 + 1] * rv[r2 + 4] + lv[l2 + 5] * rv[r2 + 5] + lv[l2 + 9] * rv[r2 + 6] + lv[l2 + 13] * rv[r2 + 7];
      out[6] = lv[l2 + 2] * rv[r2 + 4] + lv[l2 + 6] * rv[r2 + 5] + lv[l2 + 10] * rv[r2 + 6] + lv[l2 + 14] * rv[r2 + 7];
      out[7] = lv[l2 + 3] * rv[r2 + 4] + lv[l2 + 7] * rv[r2 + 5] + lv[l2 + 11] * rv[r2 + 6] + lv[l2 + 15] * rv[r2 + 7];
      out[8] = lv[l2] * rv[r2 + 8] + lv[l2 + 4] * rv[r2 + 9] + lv[l2 + 8] * rv[r2 + 10] + lv[l2 + 12] * rv[r2 + 11];
      out[9] = lv[l2 + 1] * rv[r2 + 8] + lv[l2 + 5] * rv[r2 + 9] + lv[l2 + 9] * rv[r2 + 10] + lv[l2 + 13] * rv[r2 + 11];
      out[10] = lv[l2 + 2] * rv[r2 + 8] + lv[l2 + 6] * rv[r2 + 9] + lv[l2 + 10] * rv[r2 + 10] + lv[l2 + 14] * rv[r2 + 11];
      out[11] = lv[l2 + 3] * rv[r2 + 8] + lv[l2 + 7] * rv[r2 + 9] + lv[l2 + 11] * rv[r2 + 10] + lv[l2 + 15] * rv[r2 + 11];
      out[12] = lv[l2] * rv[r2 + 12] + lv[l2 + 4] * rv[r2 + 13] + lv[l2 + 8] * rv[r2 + 14] + lv[l2 + 12] * rv[r2 + 15];
      out[13] = lv[l2 + 1] * rv[r2 + 12] + lv[l2 + 5] * rv[r2 + 13] + lv[l2 + 9] * rv[r2 + 14] + lv[l2 + 13] * rv[r2 + 15];
      out[14] = lv[l2 + 2] * rv[r2 + 12] + lv[l2 + 6] * rv[r2 + 13] + lv[l2 + 10] * rv[r2 + 14] + lv[l2 + 14] * rv[r2 + 15];
      out[15] = lv[l2 + 3] * rv[r2 + 12] + lv[l2 + 7] * rv[r2 + 13] + lv[l2 + 11] * rv[r2 + 14] + lv[l2 + 15] * rv[r2 + 15];
    }, "mulThatAndThisToOutAsMat44_offsetAsComposition_fn");
    qlerp_offsetAsComposition_fn = /* @__PURE__ */ __name(function(array, ratio, selfOffsetAsComposition, argOffsetAsComposition) {
      const out = new Array(4);
      let dotProduct = this[0 + selfOffsetAsComposition * 4] * array[0 + argOffsetAsComposition * 4] + this[1 + selfOffsetAsComposition * 4] * array[1 + argOffsetAsComposition * 4] + this[2 + selfOffsetAsComposition * 4] * array[2 + argOffsetAsComposition * 4] + this[3 + selfOffsetAsComposition * 4] * array[3 + argOffsetAsComposition * 4];
      const ss = 1 - dotProduct * dotProduct;
      if (ss === 0) {
        out[0] = this[0 + selfOffsetAsComposition * 4];
        out[1] = this[1 + selfOffsetAsComposition * 4];
        out[2] = this[2 + selfOffsetAsComposition * 4];
        out[3] = this[3 + selfOffsetAsComposition * 4];
      } else {
        if (dotProduct > 1) {
          dotProduct = 0.999;
        } else if (dotProduct < -1) {
          dotProduct = -0.999;
        }
        let theta = Math.acos(dotProduct);
        const sinTheta = Math.sin(theta);
        let s2;
        if (dotProduct < 0) {
          dotProduct *= -1;
          theta = Math.acos(dotProduct);
          s2 = -1 * Math.sin(theta * ratio) / sinTheta;
        } else {
          s2 = Math.sin(theta * ratio) / sinTheta;
        }
        const s1 = Math.sin(theta * (1 - ratio)) / sinTheta;
        out[0] = this[0 + selfOffsetAsComposition * 4] * s1 + array[0 + argOffsetAsComposition * 4] * s2;
        out[1] = this[1 + selfOffsetAsComposition * 4] * s1 + array[1 + argOffsetAsComposition * 4] * s2;
        out[2] = this[2 + selfOffsetAsComposition * 4] * s1 + array[2 + argOffsetAsComposition * 4] * s2;
        out[3] = this[3 + selfOffsetAsComposition * 4] * s1 + array[3 + argOffsetAsComposition * 4] * s2;
      }
      return out;
    }, "qlerp_offsetAsComposition_fn");
    scalar_lerp_offsetAsComposition_fn = /* @__PURE__ */ __name(function(array, ratio, selfOffset, argOffset) {
      return this[selfOffset] * (1 - ratio) + array[argOffset] * ratio;
    }, "scalar_lerp_offsetAsComposition_fn");
    array3_lerp_offsetAsComposition_fn = /* @__PURE__ */ __name(function(array, ratio, selfOffsetAsComposition, argOffsetAsComposition) {
      const ret = new Array(3);
      for (let i2 = 0; i2 < 3; i2++) {
        ret[i2] = this[selfOffsetAsComposition * 3 + i2] * (1 - ratio) + array[argOffsetAsComposition * 3 + i2] * ratio;
      }
      return ret;
    }, "array3_lerp_offsetAsComposition_fn");
    arrayN_lerp_offsetAsComposition_fn = /* @__PURE__ */ __name(function(array, componentN, ratio, selfOffsetAsComposition, argOffsetAsComposition) {
      const ret = new Array(componentN);
      for (let i2 = 0; i2 < componentN; i2++) {
        ret[i2] = this[selfOffsetAsComposition * componentN + i2] * (1 - ratio) + array[argOffsetAsComposition * componentN + i2] * ratio;
      }
      return ret;
    }, "arrayN_lerp_offsetAsComposition_fn");
    normalizeArray4_fn = /* @__PURE__ */ __name(function() {
      const length = Math.hypot(this[0], this[1], this[2], this[3]);
      this[0] /= length;
      this[1] /= length;
      this[2] /= length;
      this[3] /= length;
      return this;
    }, "normalizeArray4_fn");
    arrayTypes = [
      Array,
      Float32Array,
      Float64Array,
      Int8Array,
      Int16Array,
      Int32Array,
      Uint8Array,
      Uint16Array,
      Uint32Array
    ];
    operators = [
      get1_offsetAsComposition,
      get2_offsetAsComposition,
      get1,
      get1_offset,
      get2,
      get2_offset,
      get3,
      get3_offset,
      get3_offsetAsComposition,
      get4,
      get4_offset,
      get4_offsetAsComposition,
      getN_offset,
      getN_offsetAsComposition,
      add2,
      add2_offset,
      add3,
      add3_offset,
      add4,
      add4_offset,
      mulArray3WithScalar_offset,
      mulArray4WithScalar_offset,
      mulArrayNWithScalar_offset,
      mulThatAndThisToOutAsMat44_offsetAsComposition,
      qlerp_offsetAsComposition,
      scalar_lerp_offsetAsComposition,
      array3_lerp_offsetAsComposition,
      arrayN_lerp_offsetAsComposition,
      normalizeArray4
    ];
    functions = [
      get1_offsetAsComposition_fn,
      get2_offsetAsComposition_fn,
      get1_fn,
      get1_offset_fn,
      get2_fn,
      get2_offset_fn,
      get3_fn,
      get3_offset_fn,
      get3_offsetAsComposition_fn,
      get4_fn,
      get4_offset_fn,
      get4_offsetAsComposition_fn,
      getN_offset_fn,
      getN_offsetAsComposition_fn,
      add2_fn,
      add2_offset_fn,
      add3_fn,
      add3_offset_fn,
      add4_fn,
      add4_offset_fn,
      mulArray3WithScalar_offset_fn,
      mulArray4WithScalar_offset_fn,
      mulArrayNWithScalar_offset_fn,
      mulThatAndThisToOutAsMat44_offsetAsComposition_fn,
      qlerp_offsetAsComposition_fn,
      scalar_lerp_offsetAsComposition_fn,
      array3_lerp_offsetAsComposition_fn,
      arrayN_lerp_offsetAsComposition_fn,
      normalizeArray4_fn
    ];
    for (let i2 = 0; i2 < arrayTypes.length; i2++) {
      for (let j = 0; j < operators.length; j++) {
        arrayTypes[i2].prototype[operators[j]] = functions[j];
      }
    }
  }
});

// src/foundation/math/Matrix44.ts
var _Matrix44, Matrix44;
var init_Matrix44 = __esm({
  "src/foundation/math/Matrix44.ts"() {
    "use strict";
    init_Vector3();
    init_Vector4();
    init_CompositionType();
    init_MathUtil();
    init_IdentityMatrix44();
    init_AbstractMatrix();
    init_raw_extension();
    init_Logger();
    _Matrix44 = class _Matrix44 extends AbstractMatrix {
      constructor(m) {
        super();
        this._v = m;
      }
      get m00() {
        return this._v[0];
      }
      get m10() {
        return this._v[1];
      }
      get m20() {
        return this._v[2];
      }
      get m30() {
        return this._v[3];
      }
      get m01() {
        return this._v[4];
      }
      get m11() {
        return this._v[5];
      }
      get m21() {
        return this._v[6];
      }
      get m31() {
        return this._v[7];
      }
      get m02() {
        return this._v[8];
      }
      get m12() {
        return this._v[9];
      }
      get m22() {
        return this._v[10];
      }
      get m32() {
        return this._v[11];
      }
      get m03() {
        return this._v[12];
      }
      get m13() {
        return this._v[13];
      }
      get m23() {
        return this._v[14];
      }
      get m33() {
        return this._v[15];
      }
      get translateX() {
        return this._v[12];
      }
      get translateY() {
        return this._v[13];
      }
      get translateZ() {
        return this._v[14];
      }
      static get compositionType() {
        return CompositionType.Mat4;
      }
      /**
      * zero matrix(static version)
      */
      static zero() {
        return _Matrix44.fromCopy16RowMajor(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
      /**
      * Create identity matrix
      */
      static identity() {
        return new IdentityMatrix44();
      }
      static dummy() {
        return new this(new Float32Array(0));
      }
      /**
      * Create transpose matrix
      */
      static transpose(mat) {
        if (mat.isIdentityMatrixClass) {
          return mat;
        }
        return _Matrix44.fromCopyFloat32ArrayRowMajor(mat._v);
      }
      /**
      * Create invert matrix
      */
      static invert(mat) {
        if (mat.isIdentityMatrixClass) {
          return mat;
        }
        const n00 = mat._v[0] * mat._v[5] - mat._v[4] * mat._v[1];
        const n01 = mat._v[0] * mat._v[9] - mat._v[8] * mat._v[1];
        const n02 = mat._v[0] * mat._v[13] - mat._v[12] * mat._v[1];
        const n03 = mat._v[4] * mat._v[9] - mat._v[8] * mat._v[5];
        const n04 = mat._v[4] * mat._v[13] - mat._v[12] * mat._v[5];
        const n05 = mat._v[8] * mat._v[13] - mat._v[12] * mat._v[9];
        const n06 = mat._v[2] * mat._v[7] - mat._v[6] * mat._v[3];
        const n07 = mat._v[2] * mat._v[11] - mat._v[10] * mat._v[3];
        const n08 = mat._v[2] * mat._v[15] - mat._v[14] * mat._v[3];
        const n09 = mat._v[6] * mat._v[11] - mat._v[10] * mat._v[7];
        const n10 = mat._v[6] * mat._v[15] - mat._v[14] * mat._v[7];
        const n11 = mat._v[10] * mat._v[15] - mat._v[14] * mat._v[11];
        const det = n00 * n11 - n01 * n10 + n02 * n09 + n03 * n08 - n04 * n07 + n05 * n06;
        if (det === 0) {
          Logger.error("the determinant is 0!");
        }
        const invDet = 1 / det;
        const m00 = (mat._v[5] * n11 - mat._v[9] * n10 + mat._v[13] * n09) * invDet;
        const m01 = (mat._v[8] * n10 - mat._v[4] * n11 - mat._v[12] * n09) * invDet;
        const m02 = (mat._v[7] * n05 - mat._v[11] * n04 + mat._v[15] * n03) * invDet;
        const m03 = (mat._v[10] * n04 - mat._v[6] * n05 - mat._v[14] * n03) * invDet;
        const m10 = (mat._v[9] * n08 - mat._v[1] * n11 - mat._v[13] * n07) * invDet;
        const m11 = (mat._v[0] * n11 - mat._v[8] * n08 + mat._v[12] * n07) * invDet;
        const m12 = (mat._v[11] * n02 - mat._v[3] * n05 - mat._v[15] * n01) * invDet;
        const m13 = (mat._v[2] * n05 - mat._v[10] * n02 + mat._v[14] * n01) * invDet;
        const m20 = (mat._v[1] * n10 - mat._v[5] * n08 + mat._v[13] * n06) * invDet;
        const m21 = (mat._v[4] * n08 - mat._v[0] * n10 - mat._v[12] * n06) * invDet;
        const m22 = (mat._v[3] * n04 - mat._v[7] * n02 + mat._v[15] * n00) * invDet;
        const m23 = (mat._v[6] * n02 - mat._v[2] * n04 - mat._v[14] * n00) * invDet;
        const m30 = (mat._v[5] * n07 - mat._v[1] * n09 - mat._v[9] * n06) * invDet;
        const m31 = (mat._v[0] * n09 - mat._v[4] * n07 + mat._v[8] * n06) * invDet;
        const m32 = (mat._v[7] * n01 - mat._v[3] * n03 - mat._v[11] * n00) * invDet;
        const m33 = (mat._v[2] * n03 - mat._v[6] * n01 + mat._v[10] * n00) * invDet;
        return _Matrix44.fromCopy16RowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      }
      static invertTo(mat, outMat) {
        if (mat.isIdentityMatrixClass) {
          return outMat.copyComponents(mat);
        }
        const n00 = mat._v[0] * mat._v[5] - mat._v[4] * mat._v[1];
        const n01 = mat._v[0] * mat._v[9] - mat._v[8] * mat._v[1];
        const n02 = mat._v[0] * mat._v[13] - mat._v[12] * mat._v[1];
        const n03 = mat._v[4] * mat._v[9] - mat._v[8] * mat._v[5];
        const n04 = mat._v[4] * mat._v[13] - mat._v[12] * mat._v[5];
        const n05 = mat._v[8] * mat._v[13] - mat._v[12] * mat._v[9];
        const n06 = mat._v[2] * mat._v[7] - mat._v[6] * mat._v[3];
        const n07 = mat._v[2] * mat._v[11] - mat._v[10] * mat._v[3];
        const n08 = mat._v[2] * mat._v[15] - mat._v[14] * mat._v[3];
        const n09 = mat._v[6] * mat._v[11] - mat._v[10] * mat._v[7];
        const n10 = mat._v[6] * mat._v[15] - mat._v[14] * mat._v[7];
        const n11 = mat._v[10] * mat._v[15] - mat._v[14] * mat._v[11];
        const det = n00 * n11 - n01 * n10 + n02 * n09 + n03 * n08 - n04 * n07 + n05 * n06;
        if (det === 0) {
          Logger.error("the determinant is 0!");
        }
        const invDet = 1 / det;
        const m00 = (mat._v[5] * n11 - mat._v[9] * n10 + mat._v[13] * n09) * invDet;
        const m01 = (mat._v[8] * n10 - mat._v[4] * n11 - mat._v[12] * n09) * invDet;
        const m02 = (mat._v[7] * n05 - mat._v[11] * n04 + mat._v[15] * n03) * invDet;
        const m03 = (mat._v[10] * n04 - mat._v[6] * n05 - mat._v[14] * n03) * invDet;
        const m10 = (mat._v[9] * n08 - mat._v[1] * n11 - mat._v[13] * n07) * invDet;
        const m11 = (mat._v[0] * n11 - mat._v[8] * n08 + mat._v[12] * n07) * invDet;
        const m12 = (mat._v[11] * n02 - mat._v[3] * n05 - mat._v[15] * n01) * invDet;
        const m13 = (mat._v[2] * n05 - mat._v[10] * n02 + mat._v[14] * n01) * invDet;
        const m20 = (mat._v[1] * n10 - mat._v[5] * n08 + mat._v[13] * n06) * invDet;
        const m21 = (mat._v[4] * n08 - mat._v[0] * n10 - mat._v[12] * n06) * invDet;
        const m22 = (mat._v[3] * n04 - mat._v[7] * n02 + mat._v[15] * n00) * invDet;
        const m23 = (mat._v[6] * n02 - mat._v[2] * n04 - mat._v[14] * n00) * invDet;
        const m30 = (mat._v[5] * n07 - mat._v[1] * n09 - mat._v[9] * n06) * invDet;
        const m31 = (mat._v[0] * n09 - mat._v[4] * n07 + mat._v[8] * n06) * invDet;
        const m32 = (mat._v[7] * n01 - mat._v[3] * n03 - mat._v[11] * n00) * invDet;
        const m33 = (mat._v[2] * n03 - mat._v[6] * n01 + mat._v[10] * n00) * invDet;
        return outMat.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      }
      /**
      * Create translation Matrix
      */
      static translate(vec) {
        return _Matrix44.fromCopy16RowMajor(1, 0, 0, vec._v[0], 0, 1, 0, vec._v[1], 0, 0, 1, vec._v[2], 0, 0, 0, 1);
      }
      /**
      * Create X oriented Rotation Matrix
      */
      static rotateX(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return _Matrix44.fromCopy16RowMajor(1, 0, 0, 0, 0, cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1);
      }
      /**
      * Create Y oriented Rotation Matrix
      */
      static rotateY(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return _Matrix44.fromCopy16RowMajor(cos, 0, sin, 0, 0, 1, 0, 0, -sin, 0, cos, 0, 0, 0, 0, 1);
      }
      /**
      * Create Z oriented Rotation Matrix
      */
      static rotateZ(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return _Matrix44.fromCopy16RowMajor(cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      static rotateXYZ(x, y, z) {
        const cosX = Math.cos(x);
        const sinX = Math.sin(x);
        const cosY = Math.cos(y);
        const sinY = Math.sin(y);
        const cosZ = Math.cos(z);
        const sinZ = Math.sin(z);
        const x11 = cosX;
        const x12 = -sinX;
        const x21 = sinX;
        const x22 = cosX;
        const y00 = cosY;
        const y02 = sinY;
        const y20 = -sinY;
        const y22 = cosY;
        const z00 = cosZ;
        const z01 = -sinZ;
        const z10 = sinZ;
        const z11 = cosZ;
        const yx00 = y00;
        const yx01 = y02 * x21;
        const yx02 = y02 * x22;
        const yx11 = x11;
        const yx12 = x12;
        const yx20 = y20;
        const yx21 = y22 * x21;
        const yx22 = y22 * x22;
        const m00 = z00 * yx00;
        const m01 = z00 * yx01 + z01 * yx11;
        const m02 = z00 * yx02 + z01 * yx12;
        const m10 = z10 * yx00;
        const m11 = z10 * yx01 + z11 * yx11;
        const m12 = z10 * yx02 + z11 * yx12;
        const m20 = yx20;
        const m21 = yx21;
        const m22 = yx22;
        const m03 = 0;
        const m13 = 0;
        const m23 = 0;
        const m30 = 0;
        const m31 = 0;
        const m32 = 0;
        const m33 = 1;
        return _Matrix44.fromCopy16RowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      }
      static rotate(vec) {
        return this.rotateXYZ(vec._v[0], vec._v[1], vec._v[2]);
      }
      /**
      * Create Scale Matrix
      */
      static scale(vec) {
        return _Matrix44.fromCopy16RowMajor(vec._v[0], 0, 0, 0, 0, vec._v[1], 0, 0, 0, 0, vec._v[2], 0, 0, 0, 0, 1);
      }
      /**
      * multiply matrixes
      */
      static multiply(l_mat, r_mat) {
        if (l_mat.isIdentityMatrixClass) {
          return r_mat;
        } else if (r_mat.isIdentityMatrixClass) {
          return l_mat;
        }
        const lv = l_mat._v;
        const rv = r_mat._v;
        const m00 = lv[0] * rv[0] + lv[4] * rv[1] + lv[8] * rv[2] + lv[12] * rv[3];
        const m10 = lv[1] * rv[0] + lv[5] * rv[1] + lv[9] * rv[2] + lv[13] * rv[3];
        const m20 = lv[2] * rv[0] + lv[6] * rv[1] + lv[10] * rv[2] + lv[14] * rv[3];
        const m30 = lv[3] * rv[0] + lv[7] * rv[1] + lv[11] * rv[2] + lv[15] * rv[3];
        const m01 = lv[0] * rv[4] + lv[4] * rv[5] + lv[8] * rv[6] + lv[12] * rv[7];
        const m11 = lv[1] * rv[4] + lv[5] * rv[5] + lv[9] * rv[6] + lv[13] * rv[7];
        const m21 = lv[2] * rv[4] + lv[6] * rv[5] + lv[10] * rv[6] + lv[14] * rv[7];
        const m31 = lv[3] * rv[4] + lv[7] * rv[5] + lv[11] * rv[6] + lv[15] * rv[7];
        const m02 = lv[0] * rv[8] + lv[4] * rv[9] + lv[8] * rv[10] + lv[12] * rv[11];
        const m12 = lv[1] * rv[8] + lv[5] * rv[9] + lv[9] * rv[10] + lv[13] * rv[11];
        const m22 = lv[2] * rv[8] + lv[6] * rv[9] + lv[10] * rv[10] + lv[14] * rv[11];
        const m32 = lv[3] * rv[8] + lv[7] * rv[9] + lv[11] * rv[10] + lv[15] * rv[11];
        const m03 = lv[0] * rv[12] + lv[4] * rv[13] + lv[8] * rv[14] + lv[12] * rv[15];
        const m13 = lv[1] * rv[12] + lv[5] * rv[13] + lv[9] * rv[14] + lv[13] * rv[15];
        const m23 = lv[2] * rv[12] + lv[6] * rv[13] + lv[10] * rv[14] + lv[14] * rv[15];
        const m33 = lv[3] * rv[12] + lv[7] * rv[13] + lv[11] * rv[14] + lv[15] * rv[15];
        return _Matrix44.fromCopy16RowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      }
      /**
      * multiply matrixes
      */
      static multiplyTo(l_mat, r_mat, outMat) {
        if (l_mat.isIdentityMatrixClass) {
          return outMat.copyComponents(r_mat);
        } else if (r_mat.isIdentityMatrixClass) {
          return outMat.copyComponents(l_mat);
        }
        const lv = l_mat._v;
        const rv = r_mat._v;
        const m00 = lv[0] * rv[0] + lv[4] * rv[1] + lv[8] * rv[2] + lv[12] * rv[3];
        const m10 = lv[1] * rv[0] + lv[5] * rv[1] + lv[9] * rv[2] + lv[13] * rv[3];
        const m20 = lv[2] * rv[0] + lv[6] * rv[1] + lv[10] * rv[2] + lv[14] * rv[3];
        const m30 = lv[3] * rv[0] + lv[7] * rv[1] + lv[11] * rv[2] + lv[15] * rv[3];
        const m01 = lv[0] * rv[4] + lv[4] * rv[5] + lv[8] * rv[6] + lv[12] * rv[7];
        const m11 = lv[1] * rv[4] + lv[5] * rv[5] + lv[9] * rv[6] + lv[13] * rv[7];
        const m21 = lv[2] * rv[4] + lv[6] * rv[5] + lv[10] * rv[6] + lv[14] * rv[7];
        const m31 = lv[3] * rv[4] + lv[7] * rv[5] + lv[11] * rv[6] + lv[15] * rv[7];
        const m02 = lv[0] * rv[8] + lv[4] * rv[9] + lv[8] * rv[10] + lv[12] * rv[11];
        const m12 = lv[1] * rv[8] + lv[5] * rv[9] + lv[9] * rv[10] + lv[13] * rv[11];
        const m22 = lv[2] * rv[8] + lv[6] * rv[9] + lv[10] * rv[10] + lv[14] * rv[11];
        const m32 = lv[3] * rv[8] + lv[7] * rv[9] + lv[11] * rv[10] + lv[15] * rv[11];
        const m03 = lv[0] * rv[12] + lv[4] * rv[13] + lv[8] * rv[14] + lv[12] * rv[15];
        const m13 = lv[1] * rv[12] + lv[5] * rv[13] + lv[9] * rv[14] + lv[13] * rv[15];
        const m23 = lv[2] * rv[12] + lv[6] * rv[13] + lv[10] * rv[14] + lv[14] * rv[15];
        const m33 = lv[3] * rv[12] + lv[7] * rv[13] + lv[11] * rv[14] + lv[15] * rv[15];
        return outMat.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      }
      static multiplyTypedArrayTo(l_mat, r_array, outMat, offsetAsComposition) {
        r_array[mulThatAndThisToOutAsMat44_offsetAsComposition](offsetAsComposition, l_mat._v, 0, outMat._v);
        return outMat;
      }
      static fromQuaternionTo(quat, outMat) {
        const sx = quat._v[0] * quat._v[0];
        const sy = quat._v[1] * quat._v[1];
        const sz = quat._v[2] * quat._v[2];
        const cx = quat._v[1] * quat._v[2];
        const cy = quat._v[0] * quat._v[2];
        const cz = quat._v[0] * quat._v[1];
        const wx = quat._v[3] * quat._v[0];
        const wy = quat._v[3] * quat._v[1];
        const wz = quat._v[3] * quat._v[2];
        const m00 = 1 - 2 * (sy + sz);
        const m01 = 2 * (cz - wz);
        const m02 = 2 * (cy + wy);
        const m03 = 0;
        const m10 = 2 * (cz + wz);
        const m11 = 1 - 2 * (sx + sz);
        const m12 = 2 * (cx - wx);
        const m13 = 0;
        const m20 = 2 * (cy - wy);
        const m21 = 2 * (cx + wx);
        const m22 = 1 - 2 * (sx + sy);
        const m23 = 0;
        const m30 = 0;
        const m31 = 0;
        const m32 = 0;
        const m33 = 1;
        return outMat.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      }
      toString() {
        return this._v[0] + " " + this._v[4] + " " + this._v[8] + " " + this._v[12] + " \n" + this._v[1] + " " + this._v[5] + " " + this._v[9] + " " + this._v[13] + " \n" + this._v[2] + " " + this._v[6] + " " + this._v[10] + " " + this._v[14] + " \n" + this._v[3] + " " + this._v[7] + " " + this._v[11] + " " + this._v[15] + " \n";
      }
      toStringApproximately() {
        return MathUtil.financial(this._v[0]) + " " + MathUtil.financial(this._v[4]) + " " + MathUtil.financial(this._v[8]) + " " + MathUtil.financial(this._v[12]) + " \n" + MathUtil.financial(this._v[1]) + " " + MathUtil.financial(this._v[5]) + " " + MathUtil.financial(this._v[9]) + " " + MathUtil.financial(this._v[13]) + " \n" + MathUtil.financial(this._v[2]) + " " + MathUtil.financial(this._v[6]) + " " + MathUtil.financial(this._v[10]) + " " + MathUtil.financial(this._v[14]) + " \n" + MathUtil.financial(this._v[3]) + " " + MathUtil.financial(this._v[7]) + " " + MathUtil.financial(this._v[11]) + " " + MathUtil.financial(this._v[15]) + " \n";
      }
      flattenAsArray() {
        return [
          this._v[0],
          this._v[1],
          this._v[2],
          this._v[3],
          this._v[4],
          this._v[5],
          this._v[6],
          this._v[7],
          this._v[8],
          this._v[9],
          this._v[10],
          this._v[11],
          this._v[12],
          this._v[13],
          this._v[14],
          this._v[15]
        ];
      }
      isDummy() {
        if (this._v.length === 0) {
          return true;
        } else {
          return false;
        }
      }
      isEqual(mat, delta = Number.EPSILON) {
        const v = mat._v;
        if (Math.abs(v[0] - this._v[0]) < delta && Math.abs(v[1] - this._v[1]) < delta && Math.abs(v[2] - this._v[2]) < delta && Math.abs(v[3] - this._v[3]) < delta && Math.abs(v[4] - this._v[4]) < delta && Math.abs(v[5] - this._v[5]) < delta && Math.abs(v[6] - this._v[6]) < delta && Math.abs(v[7] - this._v[7]) < delta && Math.abs(v[8] - this._v[8]) < delta && Math.abs(v[9] - this._v[9]) < delta && Math.abs(v[10] - this._v[10]) < delta && Math.abs(v[11] - this._v[11]) < delta && Math.abs(v[12] - this._v[12]) < delta && Math.abs(v[13] - this._v[13]) < delta && Math.abs(v[14] - this._v[14]) < delta && Math.abs(v[15] - this._v[15]) < delta) {
          return true;
        } else {
          return false;
        }
      }
      isStrictEqual(mat) {
        if (mat._v[0] === this._v[0] && mat._v[1] === this._v[1] && mat._v[2] === this._v[2] && mat._v[3] === this._v[3] && mat._v[4] === this._v[4] && mat._v[5] === this._v[5] && mat._v[6] === this._v[6] && mat._v[7] === this._v[7] && mat._v[8] === this._v[8] && mat._v[9] === this._v[9] && mat._v[10] === this._v[10] && mat._v[11] === this._v[11] && mat._v[12] === this._v[12] && mat._v[13] === this._v[13] && mat._v[14] === this._v[14] && mat._v[15] === this._v[15]) {
          return true;
        } else {
          return false;
        }
      }
      at(row_i, column_i) {
        return this._v[row_i + column_i * 4];
      }
      determinant() {
        return this._v[0] * this._v[5] * this._v[10] * this._v[15] + this._v[0] * this._v[9] * this._v[14] * this._v[7] + this._v[0] * this._v[13] * this._v[6] * this._v[11] + this._v[4] * this._v[1] * this._v[14] * this._v[11] + this._v[4] * this._v[9] * this._v[2] * this._v[15] + this._v[4] * this._v[13] * this._v[10] * this._v[3] + this._v[8] * this._v[1] * this._v[6] * this._v[15] + this._v[8] * this._v[5] * this._v[14] * this._v[3] + this._v[8] * this._v[13] * this._v[2] * this._v[7] + this._v[12] * this._v[1] * this._v[10] * this._v[7] + this._v[12] * this._v[5] * this._v[2] * this._v[11] + this._v[12] * this._v[9] * this._v[6] * this._v[3] - this._v[0] * this._v[5] * this._v[14] * this._v[11] - this._v[0] * this._v[9] * this._v[6] * this._v[15] - this._v[0] * this._v[13] * this._v[10] * this._v[7] - this._v[4] * this._v[1] * this._v[10] * this._v[15] - this._v[4] * this._v[9] * this._v[14] * this._v[3] - this._v[4] * this._v[13] * this._v[2] * this._v[11] - this._v[8] * this._v[1] * this._v[14] * this._v[7] - this._v[8] * this._v[5] * this._v[2] * this._v[15] - this._v[8] * this._v[13] * this._v[6] * this._v[3] - this._v[12] * this._v[1] * this._v[6] * this._v[11] - this._v[12] * this._v[5] * this._v[10] * this._v[3] - this._v[12] * this._v[9] * this._v[2] * this._v[7];
      }
      multiplyVector(vec) {
        const x = this._v[0] * vec._v[0] + this._v[4] * vec._v[1] + this._v[8] * vec._v[2] + this._v[12] * vec._v[3];
        const y = this._v[1] * vec._v[0] + this._v[5] * vec._v[1] + this._v[9] * vec._v[2] + this._v[13] * vec._v[3];
        const z = this._v[2] * vec._v[0] + this._v[6] * vec._v[1] + this._v[10] * vec._v[2] + this._v[14] * vec._v[3];
        const w = this._v[3] * vec._v[0] + this._v[7] * vec._v[1] + this._v[11] * vec._v[2] + this._v[15] * vec._v[3];
        return Vector4.fromCopyArray([
          x,
          y,
          z,
          w
        ]);
      }
      multiplyVectorTo(vec, outVec) {
        const x = this._v[0] * vec._v[0] + this._v[4] * vec._v[1] + this._v[8] * vec._v[2] + this._v[12] * vec._v[3];
        const y = this._v[1] * vec._v[0] + this._v[5] * vec._v[1] + this._v[9] * vec._v[2] + this._v[13] * vec._v[3];
        const z = this._v[2] * vec._v[0] + this._v[6] * vec._v[1] + this._v[10] * vec._v[2] + this._v[14] * vec._v[3];
        const w = this._v[3] * vec._v[0] + this._v[7] * vec._v[1] + this._v[11] * vec._v[2] + this._v[15] * vec._v[3];
        outVec._v[0] = x;
        outVec._v[1] = y;
        outVec._v[2] = z;
        outVec._v[3] = w;
        return outVec;
      }
      multiplyVectorToVec3(vec, outVec) {
        const x = this._v[0] * vec._v[0] + this._v[4] * vec._v[1] + this._v[8] * vec._v[2] + this._v[12] * vec._v[3];
        const y = this._v[1] * vec._v[0] + this._v[5] * vec._v[1] + this._v[9] * vec._v[2] + this._v[13] * vec._v[3];
        const z = this._v[2] * vec._v[0] + this._v[6] * vec._v[1] + this._v[10] * vec._v[2] + this._v[14] * vec._v[3];
        outVec._v[0] = x;
        outVec._v[1] = y;
        outVec._v[2] = z;
        return outVec;
      }
      multiplyVector3(vec) {
        const x = this._v[0] * vec._v[0] + this._v[4] * vec._v[1] + this._v[8] * vec._v[2] + this._v[12];
        const y = this._v[1] * vec._v[0] + this._v[5] * vec._v[1] + this._v[9] * vec._v[2] + this._v[13];
        const z = this._v[2] * vec._v[0] + this._v[6] * vec._v[1] + this._v[10] * vec._v[2] + this._v[14];
        return Vector3.fromCopyArray([
          x,
          y,
          z
        ]);
      }
      multiplyVector3To(vec, outVec) {
        const x = this._v[0] * vec._v[0] + this._v[4] * vec._v[1] + this._v[8] * vec._v[2] + this._v[12];
        const y = this._v[1] * vec._v[0] + this._v[5] * vec._v[1] + this._v[9] * vec._v[2] + this._v[13];
        const z = this._v[2] * vec._v[0] + this._v[6] * vec._v[1] + this._v[10] * vec._v[2] + this._v[14];
        outVec._v[0] = x;
        outVec._v[1] = y;
        outVec._v[2] = z;
        return outVec;
      }
      getTranslate() {
        return Vector3.fromCopyArray([
          this._v[12],
          this._v[13],
          this._v[14]
        ]);
      }
      /**
      * get translate vector from this matrix
      */
      getTranslateTo(outVec) {
        outVec._v[0] = this._v[12];
        outVec._v[1] = this._v[13];
        outVec._v[2] = this._v[14];
        return outVec;
      }
      getScale() {
        return Vector3.fromCopyArray([
          Math.hypot(this._v[0], this._v[1], this._v[2]),
          Math.hypot(this._v[4], this._v[5], this._v[6]),
          Math.hypot(this._v[8], this._v[9], this._v[10])
        ]);
      }
      /**
      * get scale vector from this matrix
      */
      getScaleTo(outVec) {
        outVec._v[0] = Math.hypot(this._v[0], this._v[1], this._v[2]);
        outVec._v[1] = Math.hypot(this._v[4], this._v[5], this._v[6]);
        outVec._v[2] = Math.hypot(this._v[8], this._v[9], this._v[10]);
        return outVec;
      }
      /**
      * @return Euler Angles Rotation (x, y, z)
      */
      toEulerAngles() {
        let rotate;
        if (Math.abs(this._v[2]) !== 1) {
          const y = -Math.asin(this._v[2]);
          const x = Math.atan2(this._v[6] / Math.cos(y), this._v[10] / Math.cos(y));
          const z = Math.atan2(this._v[1] / Math.cos(y), this._v[0] / Math.cos(y));
          rotate = Vector3.fromCopyArray([
            x,
            y,
            z
          ]);
        } else if (this._v[2] === -1) {
          rotate = Vector3.fromCopyArray([
            Math.atan2(this._v[4], this._v[8]),
            Math.PI / 2,
            0
          ]);
        } else {
          rotate = Vector3.fromCopyArray([
            Math.atan2(-this._v[4], -this._v[8]),
            -Math.PI / 2,
            0
          ]);
        }
        return rotate;
      }
      toEulerAnglesTo(outVec3) {
        if (Math.abs(this._v[2]) !== 1) {
          const y = -Math.asin(this._v[2]);
          const x = Math.atan2(this._v[6] / Math.cos(y), this._v[10] / Math.cos(y));
          const z = Math.atan2(this._v[1] / Math.cos(y), this._v[0] / Math.cos(y));
          outVec3._v[0] = x;
          outVec3._v[1] = y;
          outVec3._v[2] = z;
        } else if (this._v[2] === -1) {
          outVec3._v[0] = Math.atan2(this._v[4], this._v[8]);
          outVec3._v[1] = Math.PI / 2;
          outVec3._v[2] = 0;
        } else {
          outVec3._v[0] = Math.atan2(-this._v[4], -this._v[8]);
          outVec3._v[1] = -Math.PI / 2;
          outVec3._v[2] = 0;
        }
        return outVec3;
      }
      clone() {
        return this.constructor.fromCopy16RowMajor(this._v[0], this._v[4], this._v[8], this._v[12], this._v[1], this._v[5], this._v[9], this._v[13], this._v[2], this._v[6], this._v[10], this._v[14], this._v[3], this._v[7], this._v[11], this._v[15]);
      }
      getRotate() {
        const scaleX = Math.hypot(this._v[0], this._v[1], this._v[2]);
        const scaleY = Math.hypot(this._v[4], this._v[5], this._v[6]);
        const scaleZ = Math.hypot(this._v[8], this._v[9], this._v[10]);
        const mat = _Matrix44.fromCopy16RowMajor(this._v[0] / scaleX, this._v[4], this._v[8], 0, this._v[1], this._v[5] / scaleY, this._v[9], 0, this._v[2], this._v[6], this._v[10] / scaleZ, 0, 0, 0, 0, 1);
        return mat;
      }
      /**
      * Set values as Row Major
      * Note that WebGL matrix keeps the values in column major.
      * If you write 16 values in 4x4 style (4 values in each row),
      *   It will becomes an intuitive handling.
      * @returns
      */
      static fromCopy16RowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        const v = new Float32Array(16);
        v[0] = m00;
        v[4] = m01;
        v[8] = m02;
        v[12] = m03;
        v[1] = m10;
        v[5] = m11;
        v[9] = m12;
        v[13] = m13;
        v[2] = m20;
        v[6] = m21;
        v[10] = m22;
        v[14] = m23;
        v[3] = m30;
        v[7] = m31;
        v[11] = m32;
        v[15] = m33;
        return new _Matrix44(v);
      }
      /**
      * Set values as Column Major
      * Note that WebGL matrix keeps the values in column major.
      * @returns
      */
      static fromCopy16ColumnMajor(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
        const v = new Float32Array(16);
        v[0] = m00;
        v[4] = m01;
        v[8] = m02;
        v[12] = m03;
        v[1] = m10;
        v[5] = m11;
        v[9] = m12;
        v[13] = m13;
        v[2] = m20;
        v[6] = m21;
        v[10] = m22;
        v[14] = m23;
        v[3] = m30;
        v[7] = m31;
        v[11] = m32;
        v[15] = m33;
        return new _Matrix44(v);
      }
      static fromCopyMatrix44(mat) {
        const v = new Float32Array(16);
        v.set(mat._v);
        return new _Matrix44(v);
      }
      static fromFloat32ArrayColumnMajor(float32Array) {
        return new _Matrix44(float32Array);
      }
      static fromCopyFloat32ArrayColumnMajor(float32Array) {
        const v = new Float32Array(16);
        v.set(float32Array);
        return new _Matrix44(v);
      }
      static fromCopyFloat32ArrayRowMajor(array) {
        const v = new Float32Array(16);
        v[0] = array[0];
        v[4] = array[1];
        v[8] = array[2];
        v[12] = array[3];
        v[1] = array[4];
        v[5] = array[5];
        v[9] = array[6];
        v[13] = array[7];
        v[2] = array[8];
        v[6] = array[9];
        v[10] = array[10];
        v[14] = array[11];
        v[3] = array[12];
        v[7] = array[13];
        v[11] = array[14];
        v[15] = array[15];
        return new _Matrix44(v);
      }
      static fromCopyMatrix33(mat) {
        const v = new Float32Array(16);
        v[0] = mat._v[0];
        v[4] = mat._v[3];
        v[8] = mat._v[6];
        v[12] = 0;
        v[1] = mat._v[1];
        v[5] = mat._v[4];
        v[9] = mat._v[7];
        v[13] = 0;
        v[2] = mat._v[2];
        v[6] = mat._v[5];
        v[10] = mat._v[8];
        v[14] = 0;
        v[3] = 0;
        v[7] = 0;
        v[11] = 0;
        v[15] = 1;
        return new _Matrix44(v);
      }
      static fromCopyArray16ColumnMajor(array) {
        const v = new Float32Array(16);
        v.set(array);
        return new _Matrix44(v);
      }
      static fromCopyArrayColumnMajor(array) {
        const v = new Float32Array(16);
        v.set(array);
        return new _Matrix44(v);
      }
      static fromCopyArray16RowMajor(array) {
        const v = new Float32Array(16);
        v[0] = array[0];
        v[4] = array[1];
        v[8] = array[2];
        v[12] = array[3];
        v[1] = array[4];
        v[5] = array[5];
        v[9] = array[6];
        v[13] = array[7];
        v[2] = array[8];
        v[6] = array[9];
        v[10] = array[10];
        v[14] = array[11];
        v[3] = array[12];
        v[7] = array[13];
        v[11] = array[14];
        v[15] = array[15];
        return new _Matrix44(v);
      }
      static fromCopyArrayRowMajor(array) {
        const v = new Float32Array(16);
        v[0] = array[0];
        v[4] = array[1];
        v[8] = array[2];
        v[12] = array[3];
        v[1] = array[4];
        v[5] = array[5];
        v[9] = array[6];
        v[13] = array[7];
        v[2] = array[8];
        v[6] = array[9];
        v[10] = array[10];
        v[14] = array[11];
        v[3] = array[12];
        v[7] = array[13];
        v[11] = array[14];
        v[15] = array[15];
        return new _Matrix44(v);
      }
      static fromCopyQuaternion(q) {
        const sx = q._v[0] * q._v[0];
        const sy = q._v[1] * q._v[1];
        const sz = q._v[2] * q._v[2];
        const cx = q._v[1] * q._v[2];
        const cy = q._v[0] * q._v[2];
        const cz = q._v[0] * q._v[1];
        const wx = q._v[3] * q._v[0];
        const wy = q._v[3] * q._v[1];
        const wz = q._v[3] * q._v[2];
        const v = new Float32Array(16);
        v[0] = 1 - 2 * (sy + sz);
        v[4] = 2 * (cz - wz);
        v[8] = 2 * (cy + wy);
        v[12] = 0;
        v[1] = 2 * (cz + wz);
        v[5] = 1 - 2 * (sx + sz);
        v[9] = 2 * (cx - wx);
        v[13] = 0;
        v[2] = 2 * (cy - wy);
        v[6] = 2 * (cx + wx);
        v[10] = 1 - 2 * (sx + sy);
        v[14] = 0;
        v[3] = 0;
        v[7] = 0;
        v[11] = 0;
        v[15] = 1;
        return new _Matrix44(v);
      }
    };
    __name(_Matrix44, "Matrix44");
    Matrix44 = _Matrix44;
  }
});

// src/foundation/math/MutableMatrix44.ts
var _MutableMatrix44, MutableMatrix44;
var init_MutableMatrix44 = __esm({
  "src/foundation/math/MutableMatrix44.ts"() {
    "use strict";
    init_Matrix44();
    init_Logger();
    _MutableMatrix44 = class _MutableMatrix44 extends Matrix44 {
      constructor(m) {
        super(m);
      }
      set m00(val) {
        this._v[0] = val;
      }
      get m00() {
        return this._v[0];
      }
      set m10(val) {
        this._v[1] = val;
      }
      get m10() {
        return this._v[1];
      }
      set m20(val) {
        this._v[2] = val;
      }
      get m20() {
        return this._v[2];
      }
      set m30(val) {
        this._v[3] = val;
      }
      get m30() {
        return this._v[3];
      }
      set m01(val) {
        this._v[4] = val;
      }
      get m01() {
        return this._v[4];
      }
      set m11(val) {
        this._v[5] = val;
      }
      get m11() {
        return this._v[5];
      }
      set m21(val) {
        this._v[6] = val;
      }
      get m21() {
        return this._v[6];
      }
      set m31(val) {
        this._v[7] = val;
      }
      get m31() {
        return this._v[7];
      }
      set m02(val) {
        this._v[8] = val;
      }
      get m02() {
        return this._v[8];
      }
      set m12(val) {
        this._v[9] = val;
      }
      get m12() {
        return this._v[9];
      }
      set m22(val) {
        this._v[10] = val;
      }
      get m22() {
        return this._v[10];
      }
      set m32(val) {
        this._v[11] = val;
      }
      get m32() {
        return this._v[11];
      }
      set m03(val) {
        this._v[12] = val;
      }
      get m03() {
        return this._v[12];
      }
      set m13(val) {
        this._v[13] = val;
      }
      get m13() {
        return this._v[13];
      }
      set m23(val) {
        this._v[14] = val;
      }
      get m23() {
        return this._v[14];
      }
      set m33(val) {
        this._v[15] = val;
      }
      get m33() {
        return this._v[15];
      }
      get translateX() {
        return this._v[12];
      }
      set translateX(val) {
        this._v[12] = val;
      }
      get translateY() {
        return this._v[13];
      }
      set translateY(val) {
        this._v[13] = val;
      }
      get translateZ() {
        return this._v[14];
      }
      set translateZ(val) {
        this._v[14] = val;
      }
      get className() {
        return "MutableMatrix44";
      }
      /**
      * zero matrix(static version)
      */
      static zero() {
        return _MutableMatrix44.fromCopy16RowMajor(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
      /**
      * Create identity matrix
      */
      static identity() {
        return _MutableMatrix44.fromCopy16RowMajor(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      static dummy() {
        return super.dummy();
      }
      /**
      * Create transpose matrix
      */
      static transpose(mat) {
        if (mat.isIdentityMatrixClass) {
          return mat;
        }
        return _MutableMatrix44.fromCopyFloat32ArrayRowMajor(mat._v);
      }
      /**
      * Create invert matrix
      */
      static invert(mat) {
        return super.invert(mat);
      }
      /**
      * Create translation Matrix
      */
      static translate(vec) {
        return super.translate(vec);
      }
      /**
      * Create X oriented Rotation Matrix
      */
      static rotateX(radian) {
        return super.rotateX(radian);
      }
      /**
      * Create Y oriented Rotation Matrix
      */
      static rotateY(radian) {
        return super.rotateY(radian);
      }
      /**
      * Create Z oriented Rotation Matrix
      */
      static rotateZ(radian) {
        return super.rotateZ(radian);
      }
      static rotateXYZ(x, y, z) {
        return super.rotateXYZ(x, y, z);
      }
      static rotate(vec) {
        return super.rotateXYZ(vec._v[0], vec._v[1], vec._v[2]);
      }
      /**
      * Create Scale Matrix
      */
      static scale(vec) {
        return super.scale(vec);
      }
      /**
      * multiply matrixes
      */
      static multiply(l_mat, r_mat) {
        return super.multiply(l_mat, r_mat);
      }
      clone() {
        const result = super.clone();
        return result;
      }
      getRotate() {
        const rotateMat = super.getRotate();
        return rotateMat;
      }
      getTranslate() {
        const rotateMat = super.getTranslate();
        return rotateMat;
      }
      getTranslateTo(outVec) {
        const rotateMat = super.getTranslateTo(outVec);
        return rotateMat;
      }
      getScale() {
        const rotateMat = super.getScale();
        return rotateMat;
      }
      raw() {
        return this._v;
      }
      setAt(row_i, column_i, value) {
        this._v[row_i + column_i * 4] = value;
        return this;
      }
      setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        this._v[0] = m00;
        this._v[4] = m01;
        this._v[8] = m02;
        this._v[12] = m03;
        this._v[1] = m10;
        this._v[5] = m11;
        this._v[9] = m12;
        this._v[13] = m13;
        this._v[2] = m20;
        this._v[6] = m21;
        this._v[10] = m22;
        this._v[14] = m23;
        this._v[3] = m30;
        this._v[7] = m31;
        this._v[11] = m32;
        this._v[15] = m33;
        return this;
      }
      copyComponents(mat) {
        this._v[0] = mat._v[0];
        this._v[4] = mat._v[4];
        this._v[8] = mat._v[8];
        this._v[12] = mat._v[12];
        this._v[1] = mat._v[1];
        this._v[5] = mat._v[5];
        this._v[9] = mat._v[9];
        this._v[13] = mat._v[13];
        this._v[2] = mat._v[2];
        this._v[6] = mat._v[6];
        this._v[10] = mat._v[10];
        this._v[14] = mat._v[14];
        this._v[3] = mat._v[3];
        this._v[7] = mat._v[7];
        this._v[11] = mat._v[11];
        this._v[15] = mat._v[15];
        return this;
      }
      /**
      * zero matrix
      */
      zero() {
        return this.setComponents(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
      /**
      * to the identity matrix
      */
      identity() {
        return this.setComponents(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      _swap(l2, r2) {
        this._v[r2] = [
          this._v[l2],
          this._v[l2] = this._v[r2]
        ][0];
      }
      /**
      * transpose
      */
      transpose() {
        this._swap(1, 4);
        this._swap(2, 8);
        this._swap(3, 12);
        this._swap(6, 9);
        this._swap(7, 13);
        this._swap(11, 14);
        return this;
      }
      invert() {
        const n00 = this._v[0] * this._v[5] - this._v[4] * this._v[1];
        const n01 = this._v[0] * this._v[9] - this._v[8] * this._v[1];
        const n02 = this._v[0] * this._v[13] - this._v[12] * this._v[1];
        const n03 = this._v[4] * this._v[9] - this._v[8] * this._v[5];
        const n04 = this._v[4] * this._v[13] - this._v[12] * this._v[5];
        const n05 = this._v[8] * this._v[13] - this._v[12] * this._v[9];
        const n06 = this._v[2] * this._v[7] - this._v[6] * this._v[3];
        const n07 = this._v[2] * this._v[11] - this._v[10] * this._v[3];
        const n08 = this._v[2] * this._v[15] - this._v[14] * this._v[3];
        const n09 = this._v[6] * this._v[11] - this._v[10] * this._v[7];
        const n10 = this._v[6] * this._v[15] - this._v[14] * this._v[7];
        const n11 = this._v[10] * this._v[15] - this._v[14] * this._v[11];
        const det = n00 * n11 - n01 * n10 + n02 * n09 + n03 * n08 - n04 * n07 + n05 * n06;
        if (det === 0) {
          Logger.error("the determinant is 0!");
        }
        const m00 = (this._v[5] * n11 - this._v[9] * n10 + this._v[13] * n09) / det;
        const m01 = (this._v[8] * n10 - this._v[4] * n11 - this._v[12] * n09) / det;
        const m02 = (this._v[7] * n05 - this._v[11] * n04 + this._v[15] * n03) / det;
        const m03 = (this._v[10] * n04 - this._v[6] * n05 - this._v[14] * n03) / det;
        const m10 = (this._v[9] * n08 - this._v[1] * n11 - this._v[13] * n07) / det;
        const m11 = (this._v[0] * n11 - this._v[8] * n08 + this._v[12] * n07) / det;
        const m12 = (this._v[11] * n02 - this._v[3] * n05 - this._v[15] * n01) / det;
        const m13 = (this._v[2] * n05 - this._v[10] * n02 + this._v[14] * n01) / det;
        const m20 = (this._v[1] * n10 - this._v[5] * n08 + this._v[13] * n06) / det;
        const m21 = (this._v[4] * n08 - this._v[0] * n10 - this._v[12] * n06) / det;
        const m22 = (this._v[3] * n04 - this._v[7] * n02 + this._v[15] * n00) / det;
        const m23 = (this._v[6] * n02 - this._v[2] * n04 - this._v[14] * n00) / det;
        const m30 = (this._v[5] * n07 - this._v[1] * n09 - this._v[9] * n06) / det;
        const m31 = (this._v[0] * n09 - this._v[4] * n07 + this._v[8] * n06) / det;
        const m32 = (this._v[7] * n01 - this._v[3] * n03 - this._v[11] * n00) / det;
        const m33 = (this._v[2] * n03 - this._v[6] * n01 + this._v[10] * n00) / det;
        return this.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      }
      translate(vec) {
        return this.setComponents(1, 0, 0, vec._v[0], 0, 1, 0, vec._v[1], 0, 0, 1, vec._v[2], 0, 0, 0, 1);
      }
      putTranslate(vec) {
        this._v[12] = vec._v[0];
        this._v[13] = vec._v[1];
        this._v[14] = vec._v[2];
        return this;
      }
      addTranslate(vec) {
        this._v[12] += vec._v[0];
        this._v[13] += vec._v[1];
        this._v[14] += vec._v[2];
        return this;
      }
      /**
      * Create X oriented Rotation Matrix
      */
      rotateX(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return this.setComponents(1, 0, 0, 0, 0, cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1);
      }
      /**
      * Create Y oriented Rotation Matrix
      */
      rotateY(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return this.setComponents(cos, 0, sin, 0, 0, 1, 0, 0, -sin, 0, cos, 0, 0, 0, 0, 1);
      }
      /**
      * Create Z oriented Rotation Matrix
      */
      rotateZ(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return this.setComponents(cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      rotateXYZ(x, y, z) {
        const cosX = Math.cos(x);
        const sinX = Math.sin(x);
        const cosY = Math.cos(y);
        const sinY = Math.sin(y);
        const cosZ = Math.cos(z);
        const sinZ = Math.sin(z);
        const x11 = cosX;
        const x12 = -sinX;
        const x21 = sinX;
        const x22 = cosX;
        const y00 = cosY;
        const y02 = sinY;
        const y20 = -sinY;
        const y22 = cosY;
        const z00 = cosZ;
        const z01 = -sinZ;
        const z10 = sinZ;
        const z11 = cosZ;
        const yx00 = y00;
        const yx01 = y02 * x21;
        const yx02 = y02 * x22;
        const yx11 = x11;
        const yx12 = x12;
        const yx20 = y20;
        const yx21 = y22 * x21;
        const yx22 = y22 * x22;
        const m00 = z00 * yx00;
        const m01 = z00 * yx01 + z01 * yx11;
        const m02 = z00 * yx02 + z01 * yx12;
        const m10 = z10 * yx00;
        const m11 = z10 * yx01 + z11 * yx11;
        const m12 = z10 * yx02 + z11 * yx12;
        const m20 = yx20;
        const m21 = yx21;
        const m22 = yx22;
        const m03 = 0;
        const m13 = 0;
        const m23 = 0;
        const m30 = 0;
        const m31 = 0;
        const m32 = 0;
        const m33 = 1;
        return this.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      }
      rotate(vec) {
        return this.rotateXYZ(vec._v[0], vec._v[1], vec._v[2]);
      }
      scale(vec) {
        return this.setComponents(vec._v[0], 0, 0, 0, 0, vec._v[1], 0, 0, 0, 0, vec._v[2], 0, 0, 0, 0, 1);
      }
      multiplyScale(vec) {
        this._v[0] *= vec._v[0];
        this._v[4] *= vec._v[0];
        this._v[8] *= vec._v[0];
        this._v[12] *= vec._v[0];
        this._v[1] *= vec._v[1];
        this._v[5] *= vec._v[1];
        this._v[9] *= vec._v[1];
        this._v[13] *= vec._v[1];
        this._v[2] *= vec._v[2];
        this._v[6] *= vec._v[2];
        this._v[10] *= vec._v[2];
        this._v[14] *= vec._v[2];
        return this;
      }
      /**
      * multiply the input matrix from right side
      */
      multiply(mat) {
        if (mat.isIdentityMatrixClass) {
          return this;
        }
        const m00 = this._v[0] * mat._v[0] + this._v[4] * mat._v[1] + this._v[8] * mat._v[2] + this._v[12] * mat._v[3];
        const m01 = this._v[0] * mat._v[4] + this._v[4] * mat._v[5] + this._v[8] * mat._v[6] + this._v[12] * mat._v[7];
        const m02 = this._v[0] * mat._v[8] + this._v[4] * mat._v[9] + this._v[8] * mat._v[10] + this._v[12] * mat._v[11];
        const m03 = this._v[0] * mat._v[12] + this._v[4] * mat._v[13] + this._v[8] * mat._v[14] + this._v[12] * mat._v[15];
        const m10 = this._v[1] * mat._v[0] + this._v[5] * mat._v[1] + this._v[9] * mat._v[2] + this._v[13] * mat._v[3];
        const m11 = this._v[1] * mat._v[4] + this._v[5] * mat._v[5] + this._v[9] * mat._v[6] + this._v[13] * mat._v[7];
        const m12 = this._v[1] * mat._v[8] + this._v[5] * mat._v[9] + this._v[9] * mat._v[10] + this._v[13] * mat._v[11];
        const m13 = this._v[1] * mat._v[12] + this._v[5] * mat._v[13] + this._v[9] * mat._v[14] + this._v[13] * mat._v[15];
        const m20 = this._v[2] * mat._v[0] + this._v[6] * mat._v[1] + this._v[10] * mat._v[2] + this._v[14] * mat._v[3];
        const m21 = this._v[2] * mat._v[4] + this._v[6] * mat._v[5] + this._v[10] * mat._v[6] + this._v[14] * mat._v[7];
        const m22 = this._v[2] * mat._v[8] + this._v[6] * mat._v[9] + this._v[10] * mat._v[10] + this._v[14] * mat._v[11];
        const m23 = this._v[2] * mat._v[12] + this._v[6] * mat._v[13] + this._v[10] * mat._v[14] + this._v[14] * mat._v[15];
        const m30 = this._v[3] * mat._v[0] + this._v[7] * mat._v[1] + this._v[11] * mat._v[2] + this._v[15] * mat._v[3];
        const m31 = this._v[3] * mat._v[4] + this._v[7] * mat._v[5] + this._v[11] * mat._v[6] + this._v[15] * mat._v[7];
        const m32 = this._v[3] * mat._v[8] + this._v[7] * mat._v[9] + this._v[11] * mat._v[10] + this._v[15] * mat._v[11];
        const m33 = this._v[3] * mat._v[12] + this._v[7] * mat._v[13] + this._v[11] * mat._v[14] + this._v[15] * mat._v[15];
        return this.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      }
      multiplyByLeft(mat) {
        if (mat.isIdentityMatrixClass) {
          return this;
        }
        const m00 = mat._v[0] * this._v[0] + mat._v[4] * this._v[1] + mat._v[8] * this._v[2] + mat._v[12] * this._v[3];
        const m01 = mat._v[0] * this._v[4] + mat._v[4] * this._v[5] + mat._v[8] * this._v[6] + mat._v[12] * this._v[7];
        const m02 = mat._v[0] * this._v[8] + mat._v[4] * this._v[9] + mat._v[8] * this._v[10] + mat._v[12] * this._v[11];
        const m03 = mat._v[0] * this._v[12] + mat._v[4] * this._v[13] + mat._v[8] * this._v[14] + mat._v[12] * this._v[15];
        const m10 = mat._v[1] * this._v[0] + mat._v[5] * this._v[1] + mat._v[9] * this._v[2] + mat._v[13] * this._v[3];
        const m11 = mat._v[1] * this._v[4] + mat._v[5] * this._v[5] + mat._v[9] * this._v[6] + mat._v[13] * this._v[7];
        const m12 = mat._v[1] * this._v[8] + mat._v[5] * this._v[9] + mat._v[9] * this._v[10] + mat._v[13] * this._v[11];
        const m13 = mat._v[1] * this._v[12] + mat._v[5] * this._v[13] + mat._v[9] * this._v[14] + mat._v[13] * this._v[15];
        const m20 = mat._v[2] * this._v[0] + mat._v[6] * this._v[1] + mat._v[10] * this._v[2] + mat._v[14] * this._v[3];
        const m21 = mat._v[2] * this._v[4] + mat._v[6] * this._v[5] + mat._v[10] * this._v[6] + mat._v[14] * this._v[7];
        const m22 = mat._v[2] * this._v[8] + mat._v[6] * this._v[9] + mat._v[10] * this._v[10] + mat._v[14] * this._v[11];
        const m23 = mat._v[2] * this._v[12] + mat._v[6] * this._v[13] + mat._v[10] * this._v[14] + mat._v[14] * this._v[15];
        const m30 = mat._v[3] * this._v[0] + mat._v[7] * this._v[1] + mat._v[11] * this._v[2] + mat._v[15] * this._v[3];
        const m31 = mat._v[3] * this._v[4] + mat._v[7] * this._v[5] + mat._v[11] * this._v[6] + mat._v[15] * this._v[7];
        const m32 = mat._v[3] * this._v[8] + mat._v[7] * this._v[9] + mat._v[11] * this._v[10] + mat._v[15] * this._v[11];
        const m33 = mat._v[3] * this._v[12] + mat._v[7] * this._v[13] + mat._v[11] * this._v[14] + mat._v[15] * this._v[15];
        return this.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      }
      fromQuaternion(quat) {
        const sx = quat._v[0] * quat._v[0];
        const sy = quat._v[1] * quat._v[1];
        const sz = quat._v[2] * quat._v[2];
        const cx = quat._v[1] * quat._v[2];
        const cy = quat._v[0] * quat._v[2];
        const cz = quat._v[0] * quat._v[1];
        const wx = quat._v[3] * quat._v[0];
        const wy = quat._v[3] * quat._v[1];
        const wz = quat._v[3] * quat._v[2];
        const m00 = 1 - 2 * (sy + sz);
        const m01 = 2 * (cz - wz);
        const m02 = 2 * (cy + wy);
        const m03 = 0;
        const m10 = 2 * (cz + wz);
        const m11 = 1 - 2 * (sx + sz);
        const m12 = 2 * (cx - wx);
        const m13 = 0;
        const m20 = 2 * (cy - wy);
        const m21 = 2 * (cx + wx);
        const m22 = 1 - 2 * (sx + sy);
        const m23 = 0;
        const m30 = 0;
        const m31 = 0;
        const m32 = 0;
        const m33 = 1;
        return this.setComponents(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      }
      /**
      * Set values as Row Major
      * Note that WebGL matrix keeps the values in column major.
      * If you write 16 values in 4x4 style (4 values in each row),
      *   It will becomes an intuitive handling.
      * @returns
      */
      static fromCopy16RowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        const v = new Float32Array(16);
        v[0] = m00;
        v[4] = m01;
        v[8] = m02;
        v[12] = m03;
        v[1] = m10;
        v[5] = m11;
        v[9] = m12;
        v[13] = m13;
        v[2] = m20;
        v[6] = m21;
        v[10] = m22;
        v[14] = m23;
        v[3] = m30;
        v[7] = m31;
        v[11] = m32;
        v[15] = m33;
        return new _MutableMatrix44(v);
      }
      /**
      * Set values as Column Major
      * Note that WebGL matrix keeps the values in column major.
      * @returns
      */
      static fromCopy16ColumnMajor(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
        const v = new Float32Array(16);
        v[0] = m00;
        v[4] = m01;
        v[8] = m02;
        v[12] = m03;
        v[1] = m10;
        v[5] = m11;
        v[9] = m12;
        v[13] = m13;
        v[2] = m20;
        v[6] = m21;
        v[10] = m22;
        v[14] = m23;
        v[3] = m30;
        v[7] = m31;
        v[11] = m32;
        v[15] = m33;
        return new _MutableMatrix44(v);
      }
      static fromCopyMatrix44(mat) {
        const v = new Float32Array(16);
        v.set(mat._v);
        return new _MutableMatrix44(v);
      }
      static fromFloat32ArrayColumnMajor(float32Array) {
        return new _MutableMatrix44(float32Array);
      }
      static fromCopyFloat32ArrayColumnMajor(float32Array) {
        const v = new Float32Array(16);
        v.set(float32Array);
        return new _MutableMatrix44(v);
      }
      static fromCopyFloat32ArrayRowMajor(array) {
        const v = new Float32Array(16);
        v[0] = array[0];
        v[4] = array[1];
        v[8] = array[2];
        v[12] = array[3];
        v[1] = array[4];
        v[5] = array[5];
        v[9] = array[6];
        v[13] = array[7];
        v[2] = array[8];
        v[6] = array[9];
        v[10] = array[10];
        v[14] = array[11];
        v[3] = array[12];
        v[7] = array[13];
        v[11] = array[14];
        v[15] = array[15];
        return new _MutableMatrix44(v);
      }
      static fromCopyMatrix33(mat) {
        const v = new Float32Array(16);
        v[0] = mat._v[0];
        v[4] = mat._v[3];
        v[8] = mat._v[6];
        v[12] = 0;
        v[1] = mat._v[1];
        v[5] = mat._v[4];
        v[9] = mat._v[7];
        v[13] = 0;
        v[2] = mat._v[2];
        v[6] = mat._v[5];
        v[10] = mat._v[8];
        v[14] = 0;
        v[3] = 0;
        v[7] = 0;
        v[11] = 0;
        v[15] = 1;
        return new _MutableMatrix44(v);
      }
      static fromCopyArray16ColumnMajor(array) {
        const v = new Float32Array(16);
        v.set(array);
        return new _MutableMatrix44(v);
      }
      static fromCopyArrayColumnMajor(array) {
        const v = new Float32Array(16);
        v.set(array);
        return new _MutableMatrix44(v);
      }
      static fromCopyArray16RowMajor(array) {
        const v = new Float32Array(16);
        v[0] = array[0];
        v[4] = array[1];
        v[8] = array[2];
        v[12] = array[3];
        v[1] = array[4];
        v[5] = array[5];
        v[9] = array[6];
        v[13] = array[7];
        v[2] = array[8];
        v[6] = array[9];
        v[10] = array[10];
        v[14] = array[11];
        v[3] = array[12];
        v[7] = array[13];
        v[11] = array[14];
        v[15] = array[15];
        return new _MutableMatrix44(v);
      }
      static fromCopyArrayRowMajor(array) {
        const v = new Float32Array(16);
        v[0] = array[0];
        v[4] = array[1];
        v[8] = array[2];
        v[12] = array[3];
        v[1] = array[4];
        v[5] = array[5];
        v[9] = array[6];
        v[13] = array[7];
        v[2] = array[8];
        v[6] = array[9];
        v[10] = array[10];
        v[14] = array[11];
        v[3] = array[12];
        v[7] = array[13];
        v[11] = array[14];
        v[15] = array[15];
        return new _MutableMatrix44(v);
      }
      static fromCopyQuaternion(q) {
        const sx = q._v[0] * q._v[0];
        const sy = q._v[1] * q._v[1];
        const sz = q._v[2] * q._v[2];
        const cx = q._v[1] * q._v[2];
        const cy = q._v[0] * q._v[2];
        const cz = q._v[0] * q._v[1];
        const wx = q._v[3] * q._v[0];
        const wy = q._v[3] * q._v[1];
        const wz = q._v[3] * q._v[2];
        const v = new Float32Array(16);
        v[0] = 1 - 2 * (sy + sz);
        v[4] = 2 * (cz - wz);
        v[8] = 2 * (cy + wy);
        v[12] = 0;
        v[1] = 2 * (cz + wz);
        v[5] = 1 - 2 * (sx + sz);
        v[9] = 2 * (cx - wx);
        v[13] = 0;
        v[2] = 2 * (cy - wy);
        v[6] = 2 * (cx + wx);
        v[10] = 1 - 2 * (sx + sy);
        v[14] = 0;
        v[3] = 0;
        v[7] = 0;
        v[11] = 0;
        v[15] = 1;
        return new _MutableMatrix44(v);
      }
    };
    __name(_MutableMatrix44, "MutableMatrix44");
    MutableMatrix44 = _MutableMatrix44;
  }
});

// src/foundation/misc/Is.ts
var IsObj, Derivatives, NotObj, Is;
var init_Is = __esm({
  "src/foundation/misc/Is.ts"() {
    "use strict";
    IsObj = {
      defined(val, ...args) {
        return val !== void 0;
      },
      undefined(val, ...args) {
        return val === void 0;
      },
      null(val, ...args) {
        return val === null;
      },
      // is NOT null or undefined
      exist(val, ...args) {
        return val !== null && val !== void 0;
      },
      function(val, ...args) {
        return typeof val === "function";
      },
      true(val, ...args) {
        return val === true;
      },
      truly(val, ...args) {
        return val ? true : false;
      },
      false(val, ...args) {
        return val === false;
      },
      falsy(val, ...args) {
        return !val ? true : false;
      },
      stringContaining(thisStr, queryStr) {
        return thisStr.indexOf(queryStr) !== -1;
      }
    };
    Derivatives = {
      not(fn) {
        return function() {
          return fn.apply(null, [
            ...arguments
          ]);
        };
      },
      all(fn) {
        return function() {
          if (Array.isArray(arguments[0])) {
            return arguments[0].every(fn);
          }
          return [
            ...arguments
          ].every(fn);
        };
      },
      any(fn) {
        return function() {
          if (Array.isArray(arguments[0])) {
            return arguments[0].some(fn);
          }
          return [
            ...arguments
          ].some(fn);
        };
      }
    };
    NotObj = {
      defined(val, ...args) {
        return val === void 0;
      },
      undefined(val, ...args) {
        return val !== void 0;
      },
      null(val, ...args) {
        return val !== null;
      },
      exist(val, ...args) {
        return val === null || val === void 0;
      },
      function(val, ...args) {
        return typeof val !== "function";
      },
      true(val, ...args) {
        return val !== true;
      },
      truly(val, ...args) {
        return val ? false : true;
      },
      false(val, ...args) {
        return val !== false;
      },
      falsy(val, ...args) {
        return !val ? false : true;
      }
    };
    for (const subFn in Derivatives) {
      if (Object.prototype.hasOwnProperty.call(Derivatives, subFn)) {
        IsObj[subFn] = {};
        for (const fn in IsObj) {
          if (Object.prototype.hasOwnProperty.call(IsObj, fn)) {
            if (subFn === "not") {
              IsObj[subFn][fn] = Derivatives[subFn](NotObj[fn]);
            } else {
              IsObj[subFn][fn] = Derivatives[subFn](IsObj[fn]);
            }
          }
        }
      }
    }
    Is = IsObj;
  }
});

// src/foundation/system/InputManager.ts
function getEvent(type) {
  if (typeof window === "undefined") {
    throw new Error("THis function works in Browser environment");
  }
  const deviceEvents = {
    Touch: typeof document.ontouchstart !== "undefined",
    Pointer: window.navigator.pointerEnabled,
    MSPointer: window.navigator.msPointerEnabled
  };
  const EventNames = {
    start: deviceEvents.Pointer ? EVENT_POINTER_DOWN : deviceEvents.MSPointer ? EVENT_MSPOINTER_DOWN : deviceEvents.Touch ? EVENT_TOUCH_START : EVENT_MOUSE_DOWN,
    move: deviceEvents.Pointer ? EVENT_POINTER_MOVE : deviceEvents.MSPointer ? EVENT_MSPOINTER_MOVE : deviceEvents.Touch ? EVENT_TOUCH_MOVE : EVENT_MOUSE_MOVE,
    end: deviceEvents.Pointer ? EVENT_POINTER_UP : deviceEvents.MSPointer ? EVENT_MSPOINTER_UP : deviceEvents.Touch ? EVENT_TOUCH_END : EVENT_MOUSE_UP,
    click: EVENT_CLICK
  };
  return EventNames[type];
}
var EVENT_MOUSE_DOWN, EVENT_MOUSE_MOVE, EVENT_MOUSE_UP, EVENT_MOUSE_WHEEL, EVENT_MOUSE_ENTER, EVENT_MOUSE_LEAVE, EVENT_MOUSE_OVER, EVENT_CLICK, EVENT_KEY_DOWN, EVENT_KEY_UP, EVENT_KEY_PRESS, EVENT_POINTER_DOWN, EVENT_MSPOINTER_DOWN, EVENT_POINTER_MOVE, EVENT_MSPOINTER_MOVE, EVENT_POINTER_UP, EVENT_MSPOINTER_UP, EVENT_POINTER_CANCEL, EVENT_POINTER_ENTER, EVENT_POINTER_LEAVE, EVENT_POINTER_OVER, EVENT_POINTER_OUT, EVENT_RESIZE, EVENT_ORIENTATION_CHANGE, EVENT_TOUCH_TAP, EVENT_TOUCH_DOUBLE_TAP, EVENT_TOUCH_LONG_TAP, EVENT_TOUCH_HOLD, EVENT_TOUCH_DRAG, EVENT_TOUCH_SWIPE, EVENT_TOUCH_PINCH, EVENT_TOUCH_START, EVENT_TOUCH_MOVE, EVENT_TOUCH_END, EVENT_TOUCH_CANCEL, EVENT_TOUCH_ENTER, EVENT_TOUCH_LEAVE, EVENT_TOUCH_OVER, EVENT_TOUCH_OUT, INPUT_HANDLING_STATE_NONE, INPUT_HANDLING_STATE_CAMERA_CONTROLLER, INPUT_HANDLING_STATE_GIZMO_TRANSLATION, INPUT_HANDLING_STATE_GIZMO_SCALE, _InputManager, InputManager;
var init_InputManager = __esm({
  "src/foundation/system/InputManager.ts"() {
    "use strict";
    init_Is();
    EVENT_MOUSE_DOWN = "mousedown";
    EVENT_MOUSE_MOVE = "mousemove";
    EVENT_MOUSE_UP = "mouseup";
    EVENT_MOUSE_WHEEL = "wheel";
    EVENT_MOUSE_ENTER = "mouseenter";
    EVENT_MOUSE_LEAVE = "mouseleave";
    EVENT_MOUSE_OVER = "mouseover";
    EVENT_CLICK = "click";
    EVENT_KEY_DOWN = "keydown";
    EVENT_KEY_UP = "keyup";
    EVENT_KEY_PRESS = "keypress";
    EVENT_POINTER_DOWN = "pointerdown";
    EVENT_MSPOINTER_DOWN = "MSPointerDown";
    EVENT_POINTER_MOVE = "pointermove";
    EVENT_MSPOINTER_MOVE = "MSPointerMove";
    EVENT_POINTER_UP = "pointerup";
    EVENT_MSPOINTER_UP = "MSPointerUp";
    EVENT_POINTER_CANCEL = "pointercancel";
    EVENT_POINTER_ENTER = "pointerenter";
    EVENT_POINTER_LEAVE = "pointerleave";
    EVENT_POINTER_OVER = "pointerover";
    EVENT_POINTER_OUT = "pointerout";
    EVENT_RESIZE = "resize";
    EVENT_ORIENTATION_CHANGE = "orientationchange";
    EVENT_TOUCH_TAP = "tap";
    EVENT_TOUCH_DOUBLE_TAP = "doubletap";
    EVENT_TOUCH_LONG_TAP = "longtap";
    EVENT_TOUCH_HOLD = "hold";
    EVENT_TOUCH_DRAG = "drag";
    EVENT_TOUCH_SWIPE = "swipe";
    EVENT_TOUCH_PINCH = "pinch";
    EVENT_TOUCH_START = "touchstart";
    EVENT_TOUCH_MOVE = "touchmove";
    EVENT_TOUCH_END = "touchend";
    EVENT_TOUCH_CANCEL = "touchcancel";
    EVENT_TOUCH_ENTER = "touchenter";
    EVENT_TOUCH_LEAVE = "touchleave";
    EVENT_TOUCH_OVER = "touchover";
    EVENT_TOUCH_OUT = "touchout";
    __name(getEvent, "getEvent");
    INPUT_HANDLING_STATE_NONE = "None";
    INPUT_HANDLING_STATE_CAMERA_CONTROLLER = "CameraController";
    INPUT_HANDLING_STATE_GIZMO_TRANSLATION = "GizmoTranslation";
    INPUT_HANDLING_STATE_GIZMO_SCALE = "GizmoScale";
    _InputManager = class _InputManager {
      static register(inputHandlingState, events) {
        this.__inputHandlingStateMap.set(inputHandlingState, events);
        this.__activeMap.set(inputHandlingState, true);
        this.__processEventListeners();
      }
      static unregister(inputHandlingState) {
        this.__activeMap.set(inputHandlingState, false);
        this.__inputHandlingStateMap.delete(inputHandlingState);
        this.__processEventListeners();
      }
      static setActive(inputHandlingState, active) {
        this.__activeMap.set(inputHandlingState, active);
        if (inputHandlingState === INPUT_HANDLING_STATE_GIZMO_TRANSLATION && active) {
          this.__activeMap.set(INPUT_HANDLING_STATE_GIZMO_SCALE, false);
        } else if (inputHandlingState === INPUT_HANDLING_STATE_GIZMO_SCALE && active) {
          this.__activeMap.set(INPUT_HANDLING_STATE_GIZMO_TRANSLATION, false);
        }
        this.__processEventListeners();
      }
      static __addEventListeners(inputHandlingState) {
        const infos = _InputManager.__inputHandlingStateMap.get(inputHandlingState);
        if (Is.exist(infos)) {
          for (const inputHandlerInfo of infos) {
            inputHandlerInfo.eventTargetDom.addEventListener(inputHandlerInfo.eventName, inputHandlerInfo.handler, inputHandlerInfo.options);
          }
        }
      }
      static __removeEventListeners(inputHandlingState) {
        const infos = _InputManager.__inputHandlingStateMap.get(inputHandlingState);
        if (Is.exist(infos)) {
          for (const inputHandlerInfo of infos) {
            inputHandlerInfo.eventTargetDom.removeEventListener(inputHandlerInfo.eventName, inputHandlerInfo.handler, inputHandlerInfo.options);
          }
        }
      }
      static __processEventListeners() {
        const translationGizmoActive = _InputManager.__inputHandlingStateMap.get(INPUT_HANDLING_STATE_GIZMO_TRANSLATION);
        const scaleGizmoActive = _InputManager.__inputHandlingStateMap.get(INPUT_HANDLING_STATE_GIZMO_SCALE);
        const cameraControllerActive = _InputManager.__inputHandlingStateMap.get(INPUT_HANDLING_STATE_CAMERA_CONTROLLER);
        if (cameraControllerActive) {
          this.__addEventListeners(INPUT_HANDLING_STATE_CAMERA_CONTROLLER);
          this.__currentState = INPUT_HANDLING_STATE_CAMERA_CONTROLLER;
        }
        if (translationGizmoActive) {
          this.__addEventListeners(INPUT_HANDLING_STATE_GIZMO_TRANSLATION);
          this.__removeEventListeners(INPUT_HANDLING_STATE_GIZMO_SCALE);
          this.__currentState = INPUT_HANDLING_STATE_GIZMO_TRANSLATION;
        }
        if (scaleGizmoActive) {
          this.__addEventListeners(INPUT_HANDLING_STATE_GIZMO_SCALE);
          this.__removeEventListeners(INPUT_HANDLING_STATE_GIZMO_TRANSLATION);
          this.__currentState = INPUT_HANDLING_STATE_GIZMO_SCALE;
        }
      }
      static enableCameraController() {
        this.__addEventListeners(INPUT_HANDLING_STATE_CAMERA_CONTROLLER);
        this.__activeMap.set(INPUT_HANDLING_STATE_CAMERA_CONTROLLER, true);
        this.__processEventListeners();
      }
      static disableCameraController() {
        this.__removeEventListeners(INPUT_HANDLING_STATE_CAMERA_CONTROLLER);
        this.__activeMap.set(INPUT_HANDLING_STATE_CAMERA_CONTROLLER, false);
        this.__processEventListeners();
      }
      static getCurrentState() {
        return this.__currentState;
      }
    };
    __name(_InputManager, "InputManager");
    __publicField(_InputManager, "__inputHandlingStateMap", /* @__PURE__ */ new Map());
    /**
    * This active information is set externally and does not change state internally.
    * Using this externally set active information, this class will add and remove event listeners as appropriate.
    * As a result, event handling for the entire Rhodonite works properly.
    */
    __publicField(_InputManager, "__activeMap", /* @__PURE__ */ new Map());
    __publicField(_InputManager, "__currentState", INPUT_HANDLING_STATE_NONE);
    InputManager = _InputManager;
  }
});

// src/foundation/definitions/BoneDataType.ts
function from2(index) {
  return _from({
    typeList: typeList2,
    index
  });
}
function fromString2(str) {
  return _fromString({
    typeList: typeList2,
    str
  });
}
var _a3, BoneDataTypeClass, Mat43x1, Vec4x2, Vec4x2Old, Vec4x1, typeList2, BoneDataType;
var init_BoneDataType = __esm({
  "src/foundation/definitions/BoneDataType.ts"() {
    "use strict";
    init_EnumIO();
    BoneDataTypeClass = (_a3 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a3, "BoneDataTypeClass"), _a3);
    Mat43x1 = new BoneDataTypeClass({
      index: 0,
      str: "Mat43x1"
    });
    Vec4x2 = new BoneDataTypeClass({
      index: 1,
      str: "Vec4x2"
    });
    Vec4x2Old = new BoneDataTypeClass({
      index: 2,
      str: "Vec4x2Old"
    });
    Vec4x1 = new BoneDataTypeClass({
      index: 3,
      str: "Vec4x1"
    });
    typeList2 = [
      Mat43x1,
      Vec4x2,
      Vec4x1
    ];
    __name(from2, "from");
    __name(fromString2, "fromString");
    BoneDataType = Object.freeze({
      Mat43x1,
      Vec4x2,
      Vec4x2Old,
      Vec4x1,
      from: from2,
      fromString: fromString2
    });
  }
});

// src/foundation/misc/cache/SymbolWeakMap.ts
var _SymbolWeakMap, SymbolWeakMap;
var init_SymbolWeakMap = __esm({
  "src/foundation/misc/cache/SymbolWeakMap.ts"() {
    "use strict";
    init_Is();
    _SymbolWeakMap = class _SymbolWeakMap {
      constructor() {
        __publicField(this, "__weakMap", /* @__PURE__ */ new WeakMap());
      }
      /**
      * set key and value
      * @param symbol the key for access
      * @param value the value as a cache item
      * @returns true: succeed to set value, false: not set (already exists)
      */
      set(symbol, value) {
        const isExist = this.__weakMap.has(symbol);
        if (isExist) {
          return false;
        } else {
          this.__weakMap.set(symbol, value);
          return true;
        }
      }
      /**
      * return the boolean value whether it have the key or not
      * @param symbol the key for access
      * @returns Whether it have the key or not.
      */
      has(symbol) {
        const isExist = this.__weakMap.has(symbol);
        if (isExist) {
          return true;
        } else {
          return false;
        }
      }
      /**
      * return the number of this cache items
      * @returns the number of this cache items
      */
      // public size(): number {
      //   return this.__weakMap.size;
      // }
      /**
      * return the value in the cache by the key
      * @param symbol the key for access
      * @returns the value in the cache by the key
      */
      get(symbol) {
        const keyObj = this.__weakMap.get(symbol);
        if (Is.not.exist(keyObj)) {
          return void 0;
        }
        const val = this.__weakMap.get(symbol);
        return val;
      }
      /**
      * delete the value
      * @param symbol the key for access
      * @returns the flag of the deletion was succeed or not
      */
      delete(symbol) {
        const isExist = this.__weakMap.has(symbol);
        if (!isExist) {
          return false;
        }
        this.__weakMap.delete(symbol);
        return true;
      }
    };
    __name(_SymbolWeakMap, "SymbolWeakMap");
    SymbolWeakMap = _SymbolWeakMap;
  }
});

// src/foundation/misc/cache/Cache.ts
var _Cache, Cache;
var init_Cache = __esm({
  "src/foundation/misc/cache/Cache.ts"() {
    "use strict";
    init_SymbolWeakMap();
    _Cache = class _Cache {
      constructor() {
        __publicField(this, "__symbolWeakMap", new SymbolWeakMap());
      }
      register(value) {
        this.__symbolWeakMap.set(Symbol(), value);
      }
    };
    __name(_Cache, "Cache");
    Cache = _Cache;
  }
});

// src/foundation/misc/cache/cachify.ts
var objectCachify, primitiveCachify1;
var init_cachify = __esm({
  "src/foundation/misc/cache/cachify.ts"() {
    "use strict";
    objectCachify = /* @__PURE__ */ __name((fn) => {
      const cache = /* @__PURE__ */ new WeakMap();
      return (arg) => {
        if (cache.has(arg)) {
          return cache.get(arg);
        }
        const value = fn(arg);
        cache.set(arg, value);
        return value;
      };
    }, "objectCachify");
    primitiveCachify1 = /* @__PURE__ */ __name((fn) => {
      const cache = /* @__PURE__ */ new Map();
      return (arg) => {
        if (cache.has(arg)) {
          return cache.get(arg);
        }
        const value = fn(arg);
        cache.set(arg, value);
        return value;
      };
    }, "primitiveCachify1");
  }
});

// src/foundation/misc/cache/index.ts
var init_cache = __esm({
  "src/foundation/misc/cache/index.ts"() {
    "use strict";
    init_Cache();
    init_cachify();
    init_SymbolWeakMap();
  }
});

// src/foundation/misc/RnException.ts
var _RnException, RnException;
var init_RnException = __esm({
  "src/foundation/misc/RnException.ts"() {
    "use strict";
    _RnException = class _RnException extends Error {
      constructor(err) {
        super(`
  message: ${err.message}
  error: ${typeof err.error._rnException !== "undefined" ? "see below Exception \u2193" + err.error.toString() : err.error}
`);
        __publicField(this, "err");
        this.err = err;
        this.name = _RnException._prefix;
      }
      getRnError() {
        return this.err;
      }
    };
    __name(_RnException, "RnException");
    __publicField(_RnException, "_prefix", "\nRhodonite Exception");
    RnException = _RnException;
  }
});

// src/foundation/misc/Result.ts
function assertIsOk(result) {
  if (result.isErr()) {
    throw new Error("This is Err. No Ok.");
  }
}
function assertIsErr(result) {
  if (result.isOk()) {
    throw new Error("This is Ok. No Err.");
  }
}
var _a4, CResult, _Ok, Ok, _Err, Err;
var init_Result = __esm({
  "src/foundation/misc/Result.ts"() {
    "use strict";
    init_RnException();
    CResult = (_a4 = class {
      constructor(val) {
        __publicField(this, "val");
        this.val = val;
      }
      match(obj) {
        if (this instanceof Ok) {
          return new Ok(obj.Ok(this.val));
        } else if (this instanceof Err) {
          return new Err(obj.Err(this.val));
        }
        throw new Error("This is neither Ok nor Err.");
      }
      name() {
        return this.constructor.name;
      }
    }, __name(_a4, "CResult"), _a4);
    _Ok = class _Ok extends CResult {
      constructor(val) {
        super(val);
      }
      andThen(f2) {
        return f2(this.val);
      }
      orElse(f2) {
        return this;
      }
      /**
      * This method is essentially same to the Ok::and_then() in Rust language
      * @param f
      */
      // then(f: (value: T) => void): Finalizer {
      //   f(this.val as T);
      //   return new Finalizer();
      // }
      unwrapWithCompensation(catchFn) {
        return this.val;
      }
      unwrapForce() {
        return this.val;
      }
      // catch(f: (value: RnError<ErrObj>) => void): void {}
      true() {
        return true;
      }
      isOk() {
        return true;
      }
      isErr() {
        return false;
      }
      /**
      * get the inner value safely.
      * @returns the inner value
      */
      get() {
        return this.val;
      }
    };
    __name(_Ok, "Ok");
    Ok = _Ok;
    _Err = class _Err extends CResult {
      constructor(val) {
        super(val);
        __publicField(this, "_rnException");
        this._rnException = new RnException(this.val);
      }
      andThen(f2) {
        return this;
      }
      orElse(f2) {
        return f2();
      }
      unwrapWithCompensation(catchFn) {
        return catchFn(this.val);
      }
      unwrapForce() {
        throw this._rnException;
      }
      false() {
        return false;
      }
      isOk() {
        return false;
      }
      isErr() {
        return true;
      }
      /**
      * get the RnError object.
      * @returns the RnError object
      */
      getRnError() {
        return this.val;
      }
      toString() {
        return this._rnException.stack;
      }
    };
    __name(_Err, "Err");
    Err = _Err;
    __name(assertIsOk, "assertIsOk");
    __name(assertIsErr, "assertIsErr");
  }
});

// src/foundation/misc/RnPromise.ts
var _RnPromise, RnPromise;
var init_RnPromise = __esm({
  "src/foundation/misc/RnPromise.ts"() {
    "use strict";
    _RnPromise = class _RnPromise extends Promise {
      constructor(arg) {
        super((resolve, reject) => {
        });
        __publicField(this, "__promise");
        __publicField(this, "__callback");
        __publicField(this, "name", "");
        __publicField(this, "__callbackObj", {
          promiseAllNum: 0,
          resolvedNum: 0,
          rejectedNum: 0,
          pendingNum: 0,
          processedPromises: []
        });
        if (arg instanceof Promise) {
          this.__promise = arg;
        } else {
          this.__promise = new Promise(arg);
        }
      }
      static resolve(arg) {
        if (arg instanceof Promise) {
          return new _RnPromise(arg);
        } else if (arg instanceof _RnPromise) {
          return arg;
        } else if (arg.then != null) {
          const rnPromise = new _RnPromise((resolve, reject) => {
            resolve(arg);
          });
          rnPromise.then = arg.then;
          return rnPromise;
        } else {
          return new _RnPromise((resolve, reject) => {
            resolve(arg);
          });
        }
      }
      static all(promises, callback) {
        if (callback) {
          const rnPromises = [];
          const callbackObj = {
            promiseAllNum: promises.length,
            resolvedNum: 0,
            rejectedNum: 0,
            pendingNum: promises.length,
            processedPromises: []
          };
          for (const promise of promises) {
            const rnPromise = _RnPromise.resolve(promise);
            rnPromise.__callback = callback;
            rnPromise.__callbackObj = callbackObj;
            rnPromises.push(rnPromise);
          }
          return new _RnPromise(Promise.all(rnPromises));
        } else {
          return new _RnPromise(Promise.all(promises));
        }
      }
      static race(args) {
        return new _RnPromise(Promise.race(args));
      }
      then(onfulfilled, onrejected) {
        let onFulfilledWrapper;
        if (onfulfilled) {
          onFulfilledWrapper = /* @__PURE__ */ __name((value) => {
            if (this.__callbackObj.promiseAllNum !== 0 && this.__callbackObj.processedPromises.indexOf(this) === -1) {
              this.__callbackObj.pendingNum--;
              this.__callbackObj.resolvedNum++;
              this.__callbackObj.processedPromises.push(this);
            }
            if (this.__callback) {
              this.__callback(this.__callbackObj);
            }
            return onfulfilled(value);
          }, "onFulfilledWrapper");
        }
        return this.__promise.then(onFulfilledWrapper, onrejected);
      }
      catch(onRejected) {
        return new _RnPromise(this.__promise.catch(onRejected));
      }
      finally(onFinally) {
        return this.__promise.finally(onFinally);
      }
      static reject(e3) {
        return new _RnPromise(Promise.reject(e3));
      }
    };
    __name(_RnPromise, "RnPromise");
    RnPromise = _RnPromise;
  }
});

// src/foundation/misc/DataUtil.ts
var _DataUtil, DataUtil;
var init_DataUtil = __esm({
  "src/foundation/misc/DataUtil.ts"() {
    "use strict";
    init_Result();
    init_RnPromise();
    _DataUtil = class _DataUtil {
      static isNode() {
        const isNode2 = window === void 0 && typeof process !== "undefined" && typeof __require !== "undefined";
        return isNode2;
      }
      static btoa(str) {
        const isNode2 = _DataUtil.isNode();
        if (isNode2) {
          let buffer;
          if (Buffer.isBuffer(str)) {
            buffer = str;
          } else {
            buffer = Buffer.from(str.toString(), "binary");
          }
          return buffer.toString("base64");
        } else {
          return btoa(str);
        }
      }
      static atob(str) {
        const isNode2 = _DataUtil.isNode();
        if (isNode2) {
          return Buffer.from(str, "base64").toString("binary");
        } else {
          return atob(str);
        }
      }
      static dataUriToArrayBuffer(dataUri) {
        const splitDataUri = dataUri.split(",");
        const byteString = _DataUtil.atob(splitDataUri[1]);
        const byteStringLength = byteString.length;
        const arrayBuffer = new ArrayBuffer(byteStringLength);
        const uint8Array = new Uint8Array(arrayBuffer);
        for (let i2 = 0; i2 < byteStringLength; i2++) {
          uint8Array[i2] = byteString.charCodeAt(i2);
        }
        return arrayBuffer;
      }
      static arrayBufferToString(arrayBuffer) {
        if (typeof TextDecoder !== "undefined") {
          const textDecoder = new TextDecoder();
          return textDecoder.decode(arrayBuffer);
        } else {
          const bytes = new Uint8Array(arrayBuffer);
          const result = this.uint8ArrayToStringInner(bytes);
          return result;
        }
      }
      static uint8ArrayToString(uint8Array) {
        if (typeof TextDecoder !== "undefined") {
          const textDecoder = new TextDecoder();
          return textDecoder.decode(uint8Array);
        } else {
          const result = this.uint8ArrayToStringInner(uint8Array);
          return result;
        }
      }
      static stringToBase64(str) {
        let b64 = null;
        b64 = _DataUtil.btoa(str);
        return b64;
      }
      static base64ToArrayBuffer(base64) {
        if (typeof window !== "undefined") {
          const binary_string = window.atob(base64);
          const len = binary_string.length;
          const bytes = new Uint8Array(len);
          for (let i2 = 0; i2 < len; i2++) {
            bytes[i2] = binary_string.charCodeAt(i2);
          }
          return bytes.buffer;
        } else {
          throw new Error("This function works in browser environment.");
        }
      }
      static UInt8ArrayToDataURL(uint8array, width, height) {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        const imageData = ctx.createImageData(width, height);
        for (let i2 = 0; i2 < imageData.data.length; i2 += 4) {
          imageData.data[i2 + 0] = uint8array[(height - Math.floor(i2 / (4 * width))) * (4 * width) + i2 % (4 * width) + 0];
          imageData.data[i2 + 1] = uint8array[(height - Math.floor(i2 / (4 * width))) * (4 * width) + i2 % (4 * width) + 1];
          imageData.data[i2 + 2] = uint8array[(height - Math.floor(i2 / (4 * width))) * (4 * width) + i2 % (4 * width) + 2];
          imageData.data[i2 + 3] = uint8array[(height - Math.floor(i2 / (4 * width))) * (4 * width) + i2 % (4 * width) + 3];
        }
        ctx.putImageData(imageData, 0, 0);
        canvas.remove();
        return canvas.toDataURL("image/png");
      }
      static loadResourceAsync(resourceUri, isBinary, resolveCallback, rejectCallback) {
        return new Promise((resolve, reject) => {
          const isNode2 = _DataUtil.isNode();
          if (isNode2) {
          } else {
            const xmlHttp = new XMLHttpRequest();
            if (isBinary) {
              xmlHttp.onload = (oEvent) => {
                let response = null;
                if (isBinary) {
                  response = xmlHttp.response;
                } else {
                  response = xmlHttp.responseText;
                }
                resolveCallback(resolve, response);
              };
              xmlHttp.open("GET", resourceUri, true);
              xmlHttp.responseType = "arraybuffer";
            } else {
              xmlHttp.onreadystatechange = () => {
                if (xmlHttp.readyState === 4 && (Math.floor(xmlHttp.status / 100) === 2 || xmlHttp.status === 0)) {
                  let response = null;
                  if (isBinary) {
                    response = xmlHttp.response;
                  } else {
                    response = xmlHttp.responseText;
                  }
                  resolveCallback(resolve, response);
                } else {
                  if (rejectCallback) {
                    rejectCallback(reject, xmlHttp.status);
                  }
                }
              };
              xmlHttp.open("GET", resourceUri, true);
            }
            xmlHttp.send(null);
          }
        });
      }
      static toCRC32(str) {
        let crc = 0, x = 0, y = 0;
        const table = _DataUtil.crc32table;
        crc = crc ^ -1;
        for (let i2 = 0, iTop = str.length; i2 < iTop; ++i2) {
          y = (crc ^ str.charCodeAt(i2)) & 255;
          x = "0x" + table[y];
          crc = crc >>> 8 ^ x;
        }
        return (crc ^ -1) >>> 0;
      }
      static accessBinaryAsImage(bufferViewIndex, json, buffer, mimeType) {
        const uint8BufferView = this.takeBufferViewAsUint8Array(json, bufferViewIndex, buffer);
        return this.accessArrayBufferAsImage(uint8BufferView, mimeType);
      }
      static createBlobImageUriFromUint8Array(uint8Array, mimeType) {
        const blob = new Blob([
          uint8Array
        ], {
          type: mimeType
        });
        const imageUrl = URL.createObjectURL(blob);
        return imageUrl;
      }
      static takeBufferViewAsUint8Array(json, bufferViewIndex, buffer) {
        var _a40;
        const bufferViewJson = json.bufferViews[bufferViewIndex];
        let byteOffset = (_a40 = bufferViewJson.byteOffset) != null ? _a40 : 0;
        const byteLength = bufferViewJson.byteLength;
        let arrayBuffer = buffer;
        if (buffer instanceof Uint8Array) {
          arrayBuffer = buffer.buffer;
          byteOffset += buffer.byteOffset;
        }
        const uint8BufferView = new Uint8Array(arrayBuffer, byteOffset, byteLength);
        return uint8BufferView;
      }
      static accessArrayBufferAsImage(arrayBuffer, imageType) {
        const binaryData = this.uint8ArrayToStringInner(new Uint8Array(arrayBuffer));
        const imgSrc = this.getImageType(imageType);
        const dataUrl = imgSrc + _DataUtil.btoa(binaryData);
        return dataUrl;
      }
      static uint8ArrayToStringInner(uint8) {
        const charCodeArray = new Array(uint8.byteLength);
        for (let i2 = 0; i2 < uint8.byteLength; i2++) {
          charCodeArray[i2] = uint8[i2];
        }
        const constant = 1024;
        const divisionNumber = Math.ceil(charCodeArray.length / constant);
        let binaryData = "";
        for (let i2 = 0; i2 < divisionNumber; i2++) {
          binaryData += String.fromCharCode.apply(this, charCodeArray.slice(i2 * constant, (i2 + 1) * constant));
        }
        return binaryData;
      }
      static getImageType(imageType) {
        let imgSrc = null;
        if (imageType === "image/jpeg" || imageType.toLowerCase() === "jpg" || imageType.toLowerCase() === "jpeg") {
          imgSrc = "data:image/jpeg;base64,";
        } else if (imageType === "image/png" || imageType.toLowerCase() === "png") {
          imgSrc = "data:image/png;base64,";
        } else if (imageType === "image/gif" || imageType.toLowerCase() === "gif") {
          imgSrc = "data:image/gif;base64,";
        } else if (imageType === "image/bmp" || imageType.toLowerCase() === "bmp") {
          imgSrc = "data:image/bmp;base64,";
        } else {
          imgSrc = "data:image/unknown;base64,";
        }
        return imgSrc;
      }
      static getMimeTypeFromExtension(extension) {
        let imgSrc = null;
        if (extension.toLowerCase() === "jpg" || extension.toLowerCase() === "jpeg") {
          imgSrc = "image/jpeg";
        } else if (extension.toLowerCase() === "png") {
          imgSrc = "image/png";
        } else if (extension.toLowerCase() === "gif") {
          imgSrc = "image/gif";
        } else if (extension.toLowerCase() === "bmp") {
          imgSrc = "image/bmp";
        } else {
          imgSrc = "image/unknown";
        }
        return imgSrc;
      }
      static getExtension(fileName) {
        const splitted = fileName.split(".");
        const fileExtension = splitted[splitted.length - 1];
        return fileExtension;
      }
      static createUint8ArrayFromBufferViewInfo(json, bufferViewIndex, buffer) {
        var _a40;
        const bufferViewJson = json.bufferViews[bufferViewIndex];
        let byteOffset = (_a40 = bufferViewJson.byteOffset) != null ? _a40 : 0;
        const byteLength = bufferViewJson.byteLength;
        let arrayBuffer = buffer;
        if (buffer instanceof Uint8Array) {
          arrayBuffer = buffer.buffer;
          byteOffset += buffer.byteOffset;
        }
        const uint8BufferView = new Uint8Array(arrayBuffer, byteOffset, byteLength);
        return uint8BufferView;
      }
      static createImageFromUri(uri, mimeType) {
        return new RnPromise((resolve) => {
          const img = new Image();
          img.crossOrigin = "Anonymous";
          if (uri.match(/^blob:/) || uri.match(/^data:/)) {
            img.onload = () => {
              resolve(img);
            };
            img.src = uri;
          } else {
            const load = /* @__PURE__ */ __name((img2, response) => {
              const bytes = new Uint8Array(response);
              const imageUri = _DataUtil.createBlobImageUriFromUint8Array(bytes, mimeType);
              img2.onload = () => {
                resolve(img2);
                URL.revokeObjectURL(imageUri);
              };
              img2.src = imageUri;
            }, "load");
            const loadBinaryImage = /* @__PURE__ */ __name(() => {
              const xhr = new XMLHttpRequest();
              xhr.onreadystatechange = /* @__PURE__ */ function(_img) {
                return function() {
                  if (xhr.readyState === 4 && xhr.status === 200) {
                    load(_img, xhr.response);
                  }
                };
              }(img);
              xhr.open("GET", uri);
              xhr.responseType = "arraybuffer";
              xhr.send();
            }, "loadBinaryImage");
            loadBinaryImage();
          }
        });
      }
      static createDefaultGltfOptions() {
        const defaultOptions = {
          files: {},
          loaderExtension: void 0,
          defaultMaterialHelperName: void 0,
          defaultMaterialHelperArgumentArray: [],
          statesOfElements: [
            {
              targets: [],
              states: {
                enable: [],
                functions: {}
              },
              isTransparent: true,
              opacity: 1,
              isTextureImageToLoadPreMultipliedAlpha: false
            }
          ],
          tangentCalculationMode: 1,
          extendedJson: void 0,
          __importedType: "undefined"
        };
        return defaultOptions;
      }
      static async fetchArrayBuffer(uri) {
        const response = await fetch(uri, {
          mode: "cors"
        });
        if (!response.ok) {
          return new Err({
            message: `fetchArrayBuffer failed. uri: ${uri}`,
            error: response.statusText
          });
        }
        const arraybuffer = await response.arrayBuffer();
        return new Ok(arraybuffer);
      }
      static getResizedCanvas(image, maxSize) {
        const canvas = document.createElement("canvas");
        const potWidth = this.getNearestPowerOfTwo(image.width);
        const potHeight = this.getNearestPowerOfTwo(image.height);
        const aspect = potHeight / potWidth;
        let dstWidth = 0;
        let dstHeight = 0;
        if (potWidth > potHeight) {
          dstWidth = Math.min(potWidth, maxSize);
          dstHeight = dstWidth * aspect;
        } else {
          dstHeight = Math.min(potHeight, maxSize);
          dstWidth = dstHeight / aspect;
        }
        canvas.width = dstWidth;
        canvas.height = dstHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, dstWidth, dstHeight);
        return [
          canvas,
          dstWidth,
          dstHeight
        ];
      }
      static detectTransparentPixelExistence(image, threshold = 1) {
        const dstWidth = image.width;
        const dstHeight = image.height;
        let ctx;
        let imageData;
        if (image instanceof ImageData) {
          imageData = image;
        } else if (image instanceof HTMLImageElement) {
          const canvas = document.createElement("canvas");
          ctx = canvas.getContext("2d");
          ctx.drawImage(image, 0, 0);
          imageData = ctx.getImageData(0, 0, dstWidth, dstHeight);
        } else {
          ctx = image.getContext("2d");
          ctx.drawImage(image, 0, 0);
          imageData = ctx.getImageData(0, 0, dstWidth, dstHeight);
        }
        for (let y = 0; y < dstHeight; y++) {
          for (let x = 0; x < dstWidth; x++) {
            const alpha = imageData.data[(x + y * dstWidth) * 4 + 3];
            if (alpha < threshold) {
              return true;
            }
          }
        }
        return false;
      }
      /**
      * get a value nearest power of two.
      *
      * @param x texture size.
      * @returns a value nearest power of two.
      */
      static getNearestPowerOfTwo(x) {
        return Math.pow(2, Math.round(Math.log(x) / Math.LN2));
      }
      static calcPaddingBytes(originalByteLength, byteAlign) {
        if (originalByteLength % byteAlign !== 0) {
          const sizeToPadding = byteAlign - originalByteLength % byteAlign;
          return sizeToPadding;
        }
        return 0;
      }
      static addPaddingBytes(originalByteLength, byteAlign) {
        return originalByteLength + this.calcPaddingBytes(originalByteLength, byteAlign);
      }
      static normalizedInt8ArrayToFloat32Array(from32) {
        const float32Array = new Float32Array(from32.length);
        for (let i2 = 0; i2 < from32.length; i2++) {
          float32Array[i2] = Math.max(from32[i2] / 127, -1);
        }
        return float32Array;
      }
      static normalizedUint8ArrayToFloat32Array(from32) {
        const float32Array = new Float32Array(from32.length);
        for (let i2 = 0; i2 < from32.length; i2++) {
          float32Array[i2] = from32[i2] / 255;
        }
        return float32Array;
      }
      static normalizedInt16ArrayToFloat32Array(from32) {
        const float32Array = new Float32Array(from32.length);
        for (let i2 = 0; i2 < from32.length; i2++) {
          float32Array[i2] = Math.max(from32[i2] / 32767, -1);
        }
        return float32Array;
      }
      static normalizedUint16ArrayToFloat32Array(from32) {
        const float32Array = new Float32Array(from32.length);
        for (let i2 = 0; i2 < from32.length; i2++) {
          float32Array[i2] = from32[i2] / 65535;
        }
        return float32Array;
      }
      /**
      * get a copy of the src arraybuffer
      * @param param0 copy description
      * @returns copied memory as ArrayBuffer
      */
      static getCopy({ src, srcByteOffset, copyByteLength, distByteOffset }) {
        const dst = new ArrayBuffer(src.byteLength);
        const dist = new Uint8Array(dst, distByteOffset, copyByteLength);
        dist.set(new Uint8Array(src, srcByteOffset, copyByteLength));
        return dist.buffer;
      }
      /**
      * get a copy of the src arraybuffer
      * @param param0 copy description
      * @returns copied memory as ArrayBuffer
      */
      static getCopyAs4Bytes({ src, srcByteOffset, copyByteLength, distByteOffset }) {
        if (srcByteOffset % 4 !== 0 || copyByteLength % 4 !== 0 || distByteOffset % 4 !== 0) {
          throw new Error("Invalid byte align for 4bytes unit copy operation.");
        }
        const dst = new ArrayBuffer(src.byteLength);
        const dist = new Int32Array(dst, distByteOffset, copyByteLength / 4);
        dist.set(new Int32Array(src, srcByteOffset, copyByteLength / 4));
        return dist.buffer;
      }
      /**
      * get a copy of the src arraybuffer
      * @param param0 copy description
      * @returns copied memory as ArrayBuffer
      */
      static copyArrayBuffer({ src, dist, srcByteOffset, copyByteLength, distByteOffset = 0 }) {
        const dst = new Uint8Array(dist, distByteOffset, copyByteLength);
        dst.set(new Uint8Array(src, srcByteOffset, copyByteLength));
        return dst.buffer;
      }
      /**
      * get a copy of the src arraybuffer
      * @param param0 copy description
      * @returns copied memory as ArrayBuffer
      */
      static copyArrayBufferWithPadding({ src, dist, srcByteOffset, copyByteLength, distByteOffset }) {
        const dst = new Uint8Array(dist, distByteOffset, copyByteLength);
        const byteDiff = src.byteLength - srcByteOffset - copyByteLength;
        if (byteDiff < 0) {
          dst.set(new Uint8Array(src, srcByteOffset, src.byteLength - srcByteOffset));
          const byteCount = -byteDiff;
          const paddingArrayBuffer = new Uint8Array(byteCount);
          dst.set(paddingArrayBuffer);
        } else {
          dst.set(new Uint8Array(src, srcByteOffset, copyByteLength));
        }
        return dst.buffer;
      }
      /**
      * get a copy of the src arraybuffer
      * @param param0 copy description
      * @returns copied memory as ArrayBuffer
      */
      static copyArrayBufferAs4Bytes({ src, dist, srcByteOffset, copyByteLength, distByteOffset }) {
        if (srcByteOffset % 4 !== 0 || copyByteLength % 4 !== 0 || distByteOffset % 4 !== 0) {
          throw new Error("Invalid byte align for 4bytes unit copy operation.");
        }
        const dst = new Int32Array(dist, distByteOffset, copyByteLength / 4);
        dst.set(new Int32Array(src, srcByteOffset, copyByteLength / 4));
        return dst.buffer;
      }
      /**
      * get a copy of the src arraybuffer with padding to be 4bytes aligined
      * @param param0 copy description
      * @returns copied memory as ArrayBuffer
      */
      static copyArrayBufferAs4BytesWithPadding({ src, dist, srcByteOffset, copyByteLength, distByteOffset }) {
        const dst = new Int32Array(dist, distByteOffset, copyByteLength / 4);
        const byteDiff = src.byteLength - srcByteOffset - copyByteLength;
        if (byteDiff < 0) {
          dst.set(new Int32Array(src, srcByteOffset, (src.byteLength - srcByteOffset) / 4));
          const byteCount = -byteDiff;
          const paddingArrayBuffer = new Uint8Array(byteCount);
          dst.set(paddingArrayBuffer);
        } else {
          dst.set(new Int32Array(src, srcByteOffset, copyByteLength / 4));
        }
        return dst.buffer;
      }
      static stringToBuffer(src) {
        const enc = new TextEncoder();
        return enc.encode(src).buffer;
      }
    };
    __name(_DataUtil, "DataUtil");
    __publicField(_DataUtil, "crc32table", "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D".split(" "));
    DataUtil = _DataUtil;
  }
});

// src/foundation/math/ColorRgb.ts
var _ColorRgb, ColorRgb;
var init_ColorRgb = __esm({
  "src/foundation/math/ColorRgb.ts"() {
    "use strict";
    init_Vector3();
    _ColorRgb = class _ColorRgb extends Vector3 {
      constructor(r2) {
        super(r2);
      }
      get x() {
        return this._v[0];
      }
      get y() {
        return this._v[1];
      }
      get z() {
        return this._v[2];
      }
      get w() {
        return 1;
      }
      get r() {
        return this._v[0];
      }
      get g() {
        return this._v[1];
      }
      get b() {
        return this._v[2];
      }
      get a() {
        return 1;
      }
      static zero() {
        return super._zero(Float32Array);
      }
      static one() {
        return super._one(Float32Array);
      }
      static dummy() {
        return super._dummy(Float32Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float32Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
      }
      static cross(l_vec, r_vec) {
        return super._cross(l_vec, r_vec, Float32Array);
      }
      clone() {
        return super.clone();
      }
    };
    __name(_ColorRgb, "ColorRgb");
    ColorRgb = _ColorRgb;
  }
});

// src/foundation/math/Vector2.ts
var _Vector2_, Vector2_, _Vector2, Vector2, _Vector2d, Vector2d, ConstVector2_1_1, ConstVector2_0_0;
var init_Vector2 = __esm({
  "src/foundation/math/Vector2.ts"() {
    "use strict";
    init_MathUtil();
    init_CompositionType();
    init_AbstractVector();
    init_Logger();
    _Vector2_ = class _Vector2_ extends AbstractVector {
      constructor(v, { type }) {
        super();
        this._v = v;
      }
      get x() {
        return this._v[0];
      }
      get y() {
        return this._v[1];
      }
      get glslStrAsFloat() {
        return `vec2(${MathUtil.convertToStringAsGLSLFloat(this._v[0])}, ${MathUtil.convertToStringAsGLSLFloat(this._v[1])})`;
      }
      get glslStrAsInt() {
        return `ivec2(${Math.floor(this._v[0])}, ${Math.floor(this._v[1])})`;
      }
      static get compositionType() {
        return CompositionType.Vec2;
      }
      /**
      * to square length(static version)
      */
      static lengthSquared(vec) {
        return vec.lengthSquared();
      }
      static lengthBtw(l_vec, r_vec) {
        return l_vec.lengthTo(r_vec);
      }
      static angleOfVectors(l_vec, r_vec) {
        const multipliedLength = l_vec.length() * r_vec.length();
        if (multipliedLength === 0) {
          Logger.error("length of a vector is 0!");
        }
        const cos_sita = l_vec.dot(r_vec) / multipliedLength;
        const sita = Math.acos(cos_sita);
        return sita;
      }
      static _zero(type) {
        return this._fromCopyArray2([
          0,
          0
        ], type);
      }
      static _one(type) {
        return this._fromCopyArray2([
          1,
          1
        ], type);
      }
      static _dummy(type) {
        return new this(new type(), {
          type
        });
      }
      /**
      * normalize(static version)
      */
      static _normalize(vec, type) {
        const length = vec.length();
        return this._divide(vec, length, type);
      }
      /**
      * add value（static version）
      */
      static _add(l_vec, r_vec, type) {
        const x = l_vec._v[0] + r_vec._v[0];
        const y = l_vec._v[1] + r_vec._v[1];
        return this._fromCopyArray2([
          x,
          y
        ], type);
      }
      /**
      * add value（static version）
      */
      static addTo(l_vec, r_vec, out) {
        out._v[0] = l_vec._v[0] + r_vec._v[0];
        out._v[1] = l_vec._v[1] + r_vec._v[1];
        return out;
      }
      /**
      * subtract value(static version)
      */
      static _subtract(l_vec, r_vec, type) {
        const x = l_vec._v[0] - r_vec._v[0];
        const y = l_vec._v[1] - r_vec._v[1];
        return this._fromCopyArray2([
          x,
          y
        ], type);
      }
      /**
      * subtract value(static version)
      */
      static subtractTo(l_vec, r_vec, out) {
        out._v[0] = l_vec._v[0] - r_vec._v[0];
        out._v[1] = l_vec._v[1] - r_vec._v[1];
        return out;
      }
      /**
      * multiply value(static version)
      */
      static _multiply(vec, value, type) {
        const x = vec._v[0] * value;
        const y = vec._v[1] * value;
        return this._fromCopyArray2([
          x,
          y
        ], type);
      }
      /**
      * multiply value(static version)
      */
      static multiplyTo(vec, value, out) {
        out._v[0] = vec._v[0] * value;
        out._v[1] = vec._v[1] * value;
        return out;
      }
      /**
      * multiply vector(static version)
      */
      static _multiplyVector(l_vec, r_vec, type) {
        const x = l_vec._v[0] * r_vec._v[0];
        const y = l_vec._v[1] * r_vec._v[1];
        return this._fromCopyArray2([
          x,
          y
        ], type);
      }
      /**
      * multiply vector(static version)
      */
      static multiplyVectorTo(l_vec, r_vec, out) {
        out._v[0] = l_vec._v[0] * r_vec._v[0];
        out._v[1] = l_vec._v[1] * r_vec._v[1];
        return out;
      }
      /**
      * divide by value(static version)
      */
      static _divide(vec, value, type) {
        let x;
        let y;
        if (value !== 0) {
          x = vec._v[0] / value;
          y = vec._v[1] / value;
        } else {
          Logger.error("0 division occurred!");
          x = Infinity;
          y = Infinity;
        }
        return this._fromCopyArray2([
          x,
          y
        ], type);
      }
      /**
      * divide by value(static version)
      */
      static divideTo(vec, value, out) {
        if (value !== 0) {
          out._v[0] = vec._v[0] / value;
          out._v[1] = vec._v[1] / value;
        } else {
          Logger.error("0 division occurred!");
          out._v[0] = Infinity;
          out._v[1] = Infinity;
        }
        return out;
      }
      /**
      * divide by vector(static version)
      */
      static _divideVector(l_vec, r_vec, type) {
        let x;
        let y;
        if (r_vec._v[0] !== 0 && r_vec._v[1] !== 0) {
          x = l_vec._v[0] / r_vec._v[0];
          y = l_vec._v[1] / r_vec._v[1];
        } else {
          Logger.error("0 division occurred!");
          x = r_vec._v[0] === 0 ? Infinity : l_vec._v[0] / r_vec._v[0];
          y = r_vec._v[1] === 0 ? Infinity : l_vec._v[1] / r_vec._v[1];
        }
        return this._fromCopyArray2([
          x,
          y
        ], type);
      }
      /**
      * divide by vector(static version)
      */
      static divideVectorTo(l_vec, r_vec, out) {
        if (r_vec._v[0] !== 0 && r_vec._v[1] !== 0) {
          out._v[0] = l_vec._v[0] / r_vec._v[0];
          out._v[1] = l_vec._v[1] / r_vec._v[1];
        } else {
          Logger.error("0 division occurred!");
          out._v[0] = r_vec._v[0] === 0 ? Infinity : l_vec._v[0] / r_vec._v[0];
          out._v[1] = r_vec._v[1] === 0 ? Infinity : l_vec._v[1] / r_vec._v[1];
        }
        return out;
      }
      /**
      * dot product(static version)
      */
      static dot(l_vec, r_vec) {
        return l_vec.dot(r_vec);
      }
      /**
      * change to string
      */
      toString() {
        return "(" + this._v[0] + ", " + this._v[1] + ")";
      }
      toStringApproximately() {
        return MathUtil.financial(this._v[0]) + " " + MathUtil.financial(this._v[1]) + "\n";
      }
      flattenAsArray() {
        return [
          this._v[0],
          this._v[1]
        ];
      }
      isDummy() {
        if (this._v.length === 0) {
          return true;
        } else {
          return false;
        }
      }
      isEqual(vec, delta = Number.EPSILON) {
        if (Math.abs(vec._v[0] - this._v[0]) < delta && Math.abs(vec._v[1] - this._v[1]) < delta) {
          return true;
        } else {
          return false;
        }
      }
      isStrictEqual(vec) {
        if (this._v[0] === vec._v[0] && this._v[1] === vec._v[1]) {
          return true;
        } else {
          return false;
        }
      }
      at(i2) {
        return this._v[i2];
      }
      length() {
        return Math.hypot(this._v[0], this._v[1]);
      }
      lengthSquared() {
        return this._v[0] ** 2 + this._v[1] ** 2;
      }
      lengthTo(vec) {
        const deltaX = this._v[0] - vec._v[0];
        const deltaY = this._v[1] - vec._v[1];
        return Math.hypot(deltaX, deltaY);
      }
      /**
      * dot product
      */
      dot(vec) {
        return this._v[0] * vec._v[0] + this._v[1] * vec._v[1];
      }
      clone() {
        return new this.constructor(new this._v.constructor([
          this._v[0],
          this._v[1]
        ]));
      }
      static _fromCopyArray2(array, type) {
        return new this(new type(array), {
          type
        });
      }
      static _fromCopy2(x, y, type) {
        return new this(new type([
          x,
          y
        ]), {
          type
        });
      }
      static _fromCopyArray(array, type) {
        return new this(new type(array.slice(0, 2)), {
          type
        });
      }
      static _fromVector2(vec2, type) {
        const vec = new this(new type(vec2._v), {
          type
        });
        return vec;
      }
      static _fromCopyVector2(vec2, type) {
        const vec = new this(new type([
          vec2._v[0],
          vec2._v[1]
        ]), {
          type
        });
        return vec;
      }
      static _fromCopyVector3(vec3, type) {
        const vec = new this(new type([
          vec3._v[0],
          vec3._v[1],
          vec3._v[2]
        ]), {
          type
        });
        return vec;
      }
      static _fromCopyVector4(vec4, type) {
        const vec = new this(new type([
          vec4._v[0],
          vec4._v[1],
          vec4._v[2]
        ]), {
          type
        });
        return vec;
      }
      get bytesPerComponent() {
        return this._v.BYTES_PER_ELEMENT;
      }
    };
    __name(_Vector2_, "Vector2_");
    Vector2_ = _Vector2_;
    _Vector2 = class _Vector2 extends Vector2_ {
      constructor(x) {
        super(x, {
          type: Float32Array
        });
      }
      static fromCopyArray2(array) {
        return super._fromCopyArray2(array, Float32Array);
      }
      static fromCopy2(x, y) {
        return super._fromCopy2(x, y, Float32Array);
      }
      static fromCopyArray(array) {
        return super._fromCopyArray(array, Float32Array);
      }
      static fromCopyVector2(vec2) {
        return super._fromCopyVector2(vec2, Float32Array);
      }
      static fromCopyVector4(vec4) {
        return super._fromCopyVector4(vec4, Float32Array);
      }
      static zero() {
        return super._zero(Float32Array);
      }
      static one() {
        return super._one(Float32Array);
      }
      static dummy() {
        return super._dummy(Float32Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float32Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
      }
      get className() {
        return "Vector2";
      }
      clone() {
        return super.clone();
      }
    };
    __name(_Vector2, "Vector2");
    Vector2 = _Vector2;
    _Vector2d = class _Vector2d extends Vector2_ {
      constructor(x) {
        super(x, {
          type: Float64Array
        });
      }
      static fromCopyArray2(array) {
        return super._fromCopyArray2(array, Float64Array);
      }
      static fromCopy2(x, y) {
        return super._fromCopy2(x, y, Float64Array);
      }
      static fromCopyArray(array) {
        return super._fromCopyArray(array, Float64Array);
      }
      static fromArrayBuffer(arrayBuffer) {
        return new _Vector2d(new Float64Array(arrayBuffer));
      }
      static fromFloat64Array(float64Array) {
        return new _Vector2d(float64Array);
      }
      static zero() {
        return super._zero(Float64Array);
      }
      static one() {
        return super._one(Float64Array);
      }
      static dummy() {
        return super._dummy(Float64Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float64Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float64Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float64Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float64Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float64Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float64Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float64Array);
      }
      clone() {
        return super.clone();
      }
    };
    __name(_Vector2d, "Vector2d");
    Vector2d = _Vector2d;
    ConstVector2_1_1 = Vector2.fromCopy2(1, 1);
    ConstVector2_0_0 = Vector2.fromCopy2(0, 0);
  }
});

// src/foundation/math/MutableVector2.ts
var _MutableVector2_, MutableVector2_, _MutableVector2, MutableVector2, _MutableVector2d, MutableVector2d;
var init_MutableVector2 = __esm({
  "src/foundation/math/MutableVector2.ts"() {
    "use strict";
    init_Vector2();
    init_Logger();
    _MutableVector2_ = class _MutableVector2_ extends Vector2_ {
      constructor(x, { type }) {
        super(x, {
          type
        });
      }
      set x(x) {
        this._v[0] = x;
      }
      get x() {
        return this._v[0];
      }
      set y(y) {
        this._v[1] = y;
      }
      get y() {
        return this._v[1];
      }
      get z() {
        return 0;
      }
      get w() {
        return 1;
      }
      raw() {
        return this._v;
      }
      setAt(i2, value) {
        this._v[i2] = value;
        return this;
      }
      setComponents(x, y) {
        this._v[0] = x;
        this._v[1] = y;
        return this;
      }
      copyComponents(vec) {
        return this.setComponents(vec._v[0], vec._v[1]);
      }
      zero() {
        return this.setComponents(0, 0);
      }
      one() {
        return this.setComponents(1, 1);
      }
      normalize() {
        const length = this.length();
        this.divide(length);
        return this;
      }
      /**
      * add value
      */
      add(vec) {
        this._v[0] += vec._v[0];
        this._v[1] += vec._v[1];
        return this;
      }
      /**
      * subtract
      */
      subtract(vec) {
        this._v[0] -= vec._v[0];
        this._v[1] -= vec._v[1];
        return this;
      }
      /**
      * multiply
      */
      multiply(value) {
        this._v[0] *= value;
        this._v[1] *= value;
        return this;
      }
      /**
      * multiply vector
      */
      multiplyVector(vec) {
        this._v[0] *= vec._v[0];
        this._v[1] *= vec._v[1];
        return this;
      }
      /**
      * divide
      */
      divide(value) {
        if (value !== 0) {
          this._v[0] /= value;
          this._v[1] /= value;
        } else {
          Logger.error("0 division occurred!");
          this._v[0] = Infinity;
          this._v[1] = Infinity;
        }
        return this;
      }
      /**
      * divide vector
      */
      divideVector(vec) {
        if (vec._v[0] !== 0 && vec._v[1] !== 0) {
          this._v[0] /= vec._v[0];
          this._v[1] /= vec._v[1];
        } else {
          Logger.error("0 division occurred!");
          this._v[0] = vec._v[0] === 0 ? Infinity : this._v[0] / vec._v[0];
          this._v[1] = vec._v[1] === 0 ? Infinity : this._v[1] / vec._v[1];
        }
        return this;
      }
      get bytesPerComponent() {
        return this._v.BYTES_PER_ELEMENT;
      }
    };
    __name(_MutableVector2_, "MutableVector2_");
    MutableVector2_ = _MutableVector2_;
    _MutableVector2 = class _MutableVector2 extends MutableVector2_ {
      constructor(x) {
        super(x, {
          type: Float32Array
        });
      }
      static fromCopyArray2(array) {
        return new _MutableVector2(new Float32Array(array));
      }
      static fromCopyArray(array) {
        return new _MutableVector2(new Float32Array(array.slice(0, 2)));
      }
      static fromFloat32Array(float32Array) {
        return new _MutableVector2(float32Array);
      }
      static fromCopyFloat32Array(float32Array) {
        return new _MutableVector2(new Float32Array(float32Array.buffer.slice(0)));
      }
      static zero() {
        return super._zero(Float32Array);
      }
      static one() {
        return super._one(Float32Array);
      }
      static dummy() {
        return super._dummy(Float32Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float32Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
      }
      get className() {
        return "MutableVector2";
      }
      clone() {
        return super.clone();
      }
    };
    __name(_MutableVector2, "MutableVector2");
    MutableVector2 = _MutableVector2;
    _MutableVector2d = class _MutableVector2d extends MutableVector2_ {
      constructor(x) {
        super(x, {
          type: Float64Array
        });
      }
      static fromCopyArray(array) {
        return new _MutableVector2d(new Float64Array(array));
      }
      static zero() {
        return super._zero(Float64Array);
      }
      static one() {
        return super._one(Float64Array);
      }
      static dummy() {
        return super._dummy(Float64Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float64Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float64Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float64Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float64Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float64Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float64Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float64Array);
      }
      clone() {
        return super.clone();
      }
    };
    __name(_MutableVector2d, "MutableVector2d");
    MutableVector2d = _MutableVector2d;
  }
});

// src/foundation/textures/TextureDataFloat.ts
var _TextureDataFloat, TextureDataFloat;
var init_TextureDataFloat = __esm({
  "src/foundation/textures/TextureDataFloat.ts"() {
    "use strict";
    _TextureDataFloat = class _TextureDataFloat {
      constructor(width, height, channels) {
        __publicField(this, "__data");
        __publicField(this, "__channels");
        __publicField(this, "__width");
        __publicField(this, "__height");
        this.__channels = channels;
        this.__width = width;
        this.__height = height;
        this.__data = new Float32Array(width * height * channels);
      }
      resize(width, height, channels) {
        this.__width = width;
        this.__height = height;
        this.__channels = channels;
        this.__data = new Float32Array(_TextureDataFloat.transfer(this.__data.buffer, width * height * channels * 4));
      }
      setPixelAtChannel(x, y, channelIdx, value) {
        this.__data[y * this.__width * this.__channels + x * this.__channels + channelIdx] = value;
      }
      get width() {
        return this.__width;
      }
      get height() {
        return this.__height;
      }
      get data() {
        return this.__data;
      }
      getPixel(x, y, channelIdx) {
        return this.__data[y * this.__width * this.__channels + x * this.__channels + channelIdx];
      }
      getPixelAs(x, y, channels, typeClass) {
        if (channels === 3) {
          return new typeClass(new Float32Array([
            this.__data[y * this.__width * this.__channels + x * this.__channels + 0],
            this.__data[y * this.__width * this.__channels + x * this.__channels + 1],
            this.__data[y * this.__width * this.__channels + x * this.__channels + 2]
          ]));
        } else if (channels === 4) {
          return new typeClass(new Float32Array([
            this.__data[y * this.__width * this.__channels + x * this.__channels + 0],
            this.__data[y * this.__width * this.__channels + x * this.__channels + 1],
            this.__data[y * this.__width * this.__channels + x * this.__channels + 2],
            this.__data[y * this.__width * this.__channels + x * this.__channels + 3]
          ]));
        }
      }
      getPixelAsArray(x, y) {
        const array = [];
        for (let i2 = 0; i2 < this.__channels; i2++) {
          array.push(this.__data[y * this.__width * this.__channels + x * this.__channels + i2]);
        }
        return array;
      }
      initialize(width, height, channels) {
        this.__width = width;
        this.__height = height;
        this.__channels = channels;
        this.__data = new Float32Array(width * height * channels);
      }
      static transfer(source, length) {
        source = Object(source);
        const dest = new ArrayBuffer(length);
        if (!(source instanceof ArrayBuffer) || !(dest instanceof ArrayBuffer)) {
          throw new TypeError("Source and destination must be ArrayBuffer instances");
        }
        if (dest.byteLength >= source.byteLength) {
          let nextOffset = 0;
          let leftBytes = source.byteLength;
          const wordSizes = [
            8,
            4,
            2,
            1
          ];
          wordSizes.forEach((_wordSize_) => {
            if (leftBytes >= _wordSize_) {
              const done = transferWith(_wordSize_, source, dest, nextOffset, leftBytes);
              nextOffset = done.nextOffset;
              leftBytes = done.leftBytes;
            }
          });
        }
        return dest;
        function transferWith(wordSize, source2, dest2, nextOffset, leftBytes) {
          let ViewClass = Uint8Array;
          switch (wordSize) {
            case 8:
              ViewClass = Float64Array;
              break;
            case 4:
              ViewClass = Float32Array;
              break;
            case 2:
              ViewClass = Uint16Array;
              break;
            case 1:
              ViewClass = Uint8Array;
              break;
            default:
              ViewClass = Uint8Array;
              break;
          }
          const view_source = new ViewClass(source2, nextOffset, Math.trunc(leftBytes / wordSize));
          const view_dest = new ViewClass(dest2, nextOffset, Math.trunc(leftBytes / wordSize));
          for (let i2 = 0; i2 < view_dest.length; i2++) {
            view_dest[i2] = view_source[i2];
          }
          return {
            nextOffset: view_source.byteOffset + view_source.byteLength,
            leftBytes: source2.byteLength - (view_source.byteOffset + view_source.byteLength)
          };
        }
        __name(transferWith, "transferWith");
      }
    };
    __name(_TextureDataFloat, "TextureDataFloat");
    TextureDataFloat = _TextureDataFloat;
  }
});

// src/foundation/misc/ImageUtil.ts
function computeEigenVectors(input, eigenVectors) {
  let R = 0, G = 0, B2 = 0, RR = 0, GG = 0, BB = 0, RG2 = 0, RB = 0, GB = 0;
  for (let y = 0; y < input.height; y++) {
    for (let x = 0; x < input.width; x++) {
      const col = input.getPixelAs(x, y, 3, ColorRgb);
      R += col.x;
      G += col.y;
      B2 += col.z;
      RR += col.x * col.x;
      GG += col.y * col.y;
      BB += col.z * col.z;
      RG2 += col.x * col.y;
      RB += col.x * col.z;
      GB += col.y * col.z;
    }
  }
  const inputImagePixelsNumber = input.width * input.height;
  R /= inputImagePixelsNumber;
  G /= inputImagePixelsNumber;
  B2 /= inputImagePixelsNumber;
  RR /= inputImagePixelsNumber;
  GG /= inputImagePixelsNumber;
  BB /= inputImagePixelsNumber;
  RG2 /= inputImagePixelsNumber;
  RB /= inputImagePixelsNumber;
  GB /= inputImagePixelsNumber;
  const covarMat = MutableMatrix33.zero();
  covarMat.m00 = RR - R * R;
  covarMat.m01 = RG2 - R * G;
  covarMat.m02 = RB - R * B2;
  covarMat.m10 = RG2 - R * G;
  covarMat.m11 = GG - G * G;
  covarMat.m12 = GB - G * B2;
  covarMat.m20 = RB - R * B2;
  covarMat.m21 = GB - G * B2;
  covarMat.m22 = BB - B2 * B2;
  const eigenVectorsTemp = MutableMatrix33.zero();
  const eigenValuesTemp = MutableVector3.zero();
  MathUtil.computeEigenValuesAndVectors(covarMat, eigenVectorsTemp, eigenValuesTemp);
  eigenVectors[0] = Vector3.fromCopyArray([
    eigenVectorsTemp.m00,
    eigenVectorsTemp.m10,
    eigenVectorsTemp.m20
  ]);
  eigenVectors[1] = Vector3.fromCopyArray([
    eigenVectorsTemp.m01,
    eigenVectorsTemp.m11,
    eigenVectorsTemp.m21
  ]);
  eigenVectors[2] = Vector3.fromCopyArray([
    eigenVectorsTemp.m02,
    eigenVectorsTemp.m12,
    eigenVectorsTemp.m22
  ]);
}
function decorrelateColorSpace(input, input_decorrelated, colorSpaceVector1, colorSpaceVector2, colorSpaceVector3, colorSpaceOrigin) {
  const eigenvectors = [
    MutableVector3.zero(),
    MutableVector3.zero(),
    MutableVector3.zero()
  ];
  computeEigenVectors(input, eigenvectors);
  for (let y = 0; y < input.height; y++) for (let x = 0; x < input.width; x++) for (let channel = 0; channel < 3; ++channel) {
    const color = input.getPixelAs(x, y, 3, ColorRgb);
    const new_channel_value = Vector3.dot(color, eigenvectors[channel]);
    input_decorrelated.setPixelAtChannel(x, y, channel, new_channel_value);
  }
  const colorSpaceRanges = [
    MutableVector2.fromCopyArray2([
      Number.MAX_VALUE,
      -Number.MAX_VALUE
    ]),
    MutableVector2.fromCopyArray2([
      Number.MAX_VALUE,
      -Number.MAX_VALUE
    ]),
    MutableVector2.fromCopyArray2([
      Number.MAX_VALUE,
      -Number.MAX_VALUE
    ])
  ];
  for (let y = 0; y < input.height; y++) {
    for (let x = 0; x < input.width; x++) {
      for (let channel = 0; channel < 3; ++channel) {
        colorSpaceRanges[channel].x = Math.min(colorSpaceRanges[channel].x, input_decorrelated.getPixelAsArray(x, y)[channel]);
        colorSpaceRanges[channel].y = Math.max(colorSpaceRanges[channel].y, input_decorrelated.getPixelAsArray(x, y)[channel]);
      }
    }
  }
  for (let y = 0; y < input.height; y++) {
    for (let x = 0; x < input.width; x++) {
      for (let channel = 0; channel < 3; ++channel) {
        const value = input_decorrelated.getPixelAsArray(x, y)[channel];
        const remapped_value = (value - colorSpaceRanges[channel].x) / (colorSpaceRanges[channel].y - colorSpaceRanges[channel].x);
        input_decorrelated.setPixelAtChannel(x, y, channel, remapped_value);
      }
    }
  }
  colorSpaceOrigin.x = colorSpaceRanges[0].x * eigenvectors[0].x + colorSpaceRanges[1].x * eigenvectors[1].x + colorSpaceRanges[2].x * eigenvectors[2].x;
  colorSpaceOrigin.y = colorSpaceRanges[0].x * eigenvectors[0].y + colorSpaceRanges[1].x * eigenvectors[1].y + colorSpaceRanges[2].x * eigenvectors[2].y;
  colorSpaceOrigin.z = colorSpaceRanges[0].x * eigenvectors[0].z + colorSpaceRanges[1].x * eigenvectors[1].z + colorSpaceRanges[2].x * eigenvectors[2].z;
  colorSpaceVector1.x = eigenvectors[0].x * (colorSpaceRanges[0].y - colorSpaceRanges[0].x);
  colorSpaceVector1.y = eigenvectors[0].y * (colorSpaceRanges[0].y - colorSpaceRanges[0].x);
  colorSpaceVector1.z = eigenvectors[0].z * (colorSpaceRanges[0].y - colorSpaceRanges[0].x);
  colorSpaceVector2.x = eigenvectors[1].x * (colorSpaceRanges[1].y - colorSpaceRanges[1].x);
  colorSpaceVector2.y = eigenvectors[1].y * (colorSpaceRanges[1].y - colorSpaceRanges[1].x);
  colorSpaceVector2.z = eigenvectors[1].z * (colorSpaceRanges[1].y - colorSpaceRanges[1].x);
  colorSpaceVector3.x = eigenvectors[2].x * (colorSpaceRanges[2].y - colorSpaceRanges[2].x);
  colorSpaceVector3.y = eigenvectors[2].y * (colorSpaceRanges[2].y - colorSpaceRanges[2].x);
  colorSpaceVector3.z = eigenvectors[2].z * (colorSpaceRanges[2].y - colorSpaceRanges[2].x);
}
function computeLODAverageSubpixelVariance(image, LOD, channel) {
  const windowWidth = 1 << LOD;
  let average_window_variance = 0;
  for (let window_y = 0; window_y < image.height; window_y += windowWidth) {
    for (let window_x = 0; window_x < image.width; window_x += windowWidth) {
      let v = 0;
      let v2 = 0;
      for (let y = 0; y < windowWidth; y++) {
        for (let x = 0; x < windowWidth; x++) {
          const value = image.getPixel(window_x + x, window_y + y, channel);
          v += value;
          v2 += value * value;
        }
      }
      v /= windowWidth * windowWidth;
      v2 /= windowWidth * windowWidth;
      const window_variance = Math.max(0, v2 - v * v);
      average_window_variance += window_variance / (image.width * image.height / windowWidth / windowWidth);
    }
  }
  return average_window_variance;
}
function filterLUTValueAtx(LUT, x, std, channel, LUT_WIDTH = 128) {
  const numberOfSamples = 2 * LUT_WIDTH;
  let filtered_value = 0;
  for (let sample = 0; sample < numberOfSamples; sample++) {
    const U2 = (sample + 0.5) / numberOfSamples;
    const sample_x = MathUtil.invGaussianCdf(U2, x, std);
    const sample_texel = Math.max(0, Math.min(LUT_WIDTH - 1, Math.floor(sample_x * LUT_WIDTH)));
    const sample_value = LUT.getPixelAsArray(sample_texel, 0)[channel];
    filtered_value += sample_value;
  }
  filtered_value /= numberOfSamples;
  return filtered_value;
}
function prefilterLUT(image_T_Input, LUT_Tinv, channel) {
  for (let LOD = 1; LOD < LUT_Tinv.height; LOD++) {
    const window_variance = computeLODAverageSubpixelVariance(image_T_Input, LOD, channel);
    const window_std = Math.sqrt(window_variance);
    for (let i2 = 0; i2 < LUT_Tinv.width; i2++) {
      const x_texel = (i2 + 0.5) / LUT_Tinv.width;
      const filteredValue = filterLUTValueAtx(LUT_Tinv, x_texel, window_std, channel);
      LUT_Tinv.setPixelAtChannel(i2, LOD, channel, filteredValue);
    }
  }
}
function generatePixelSortTypeArray(arrayLength) {
  const array = [];
  for (let i2 = 0; i2 < arrayLength; i2++) {
    array.push({});
  }
  return array;
}
function computeTinput(input, T_input, channel, GAUSSIAN_AVERAGE = 0.5, GAUSSIAN_STD = 0.16666) {
  const sortedInputValues = generatePixelSortTypeArray(input.height * input.width);
  for (let y = 0; y < input.height; y++) {
    for (let x = 0; x < input.width; x++) {
      sortedInputValues[y * input.width + x].x = x;
      sortedInputValues[y * input.width + x].y = y;
      sortedInputValues[y * input.width + x].value = input.getPixel(x, y, channel);
    }
  }
  sortedInputValues.sort((a2, b) => {
    if (a2.value < b.value) return -1;
    if (a2.value > b.value) return 1;
    return 0;
  });
  for (let i2 = 0; i2 < sortedInputValues.length; i2++) {
    const x = sortedInputValues[i2].x;
    const y = sortedInputValues[i2].y;
    const U2 = (i2 + 0.5) / sortedInputValues.length;
    const G = MathUtil.invGaussianCdf(U2, GAUSSIAN_AVERAGE, GAUSSIAN_STD);
    T_input.setPixelAtChannel(x, y, channel, G);
  }
}
function computeInvT(input, Tinv, channel, GAUSSIAN_AVERAGE = 0.5, GAUSSIAN_STD = 0.16666) {
  const sortedInputValues = [];
  for (let y = 0; y < input.height; y++) {
    for (let x = 0; x < input.width; x++) {
      sortedInputValues[y * input.width + x] = input.getPixel(x, y, channel);
    }
  }
  sortedInputValues.sort((a2, b) => {
    if (a2 < b) return -1;
    if (a2 > b) return 1;
    return 0;
  });
  for (let i2 = 0; i2 < Tinv.width; i2++) {
    const G = (i2 + 0.5) / Tinv.width;
    const U2 = MathUtil.gaussianCdf(G, GAUSSIAN_AVERAGE, GAUSSIAN_STD);
    const index = Math.floor(U2 * sortedInputValues.length);
    const I2 = sortedInputValues[index];
    Tinv.setPixelAtChannel(i2, 0, channel, I2);
  }
}
function precomputations(input, LUT_WIDTH = 128) {
  const retVal = {};
  retVal.lutWidth = LUT_WIDTH;
  retVal.colorSpaceVector1 = MutableVector3.zero();
  retVal.colorSpaceVector2 = MutableVector3.zero();
  retVal.colorSpaceVector3 = MutableVector3.zero();
  retVal.colorSpaceOrigin = MutableVector3.zero();
  const input_decorrelated = new TextureDataFloat(input.width, input.height, 3);
  decorrelateColorSpace(input, input_decorrelated, retVal.colorSpaceVector1, retVal.colorSpaceVector2, retVal.colorSpaceVector3, retVal.colorSpaceOrigin);
  const Tinput = new TextureDataFloat(input.width, input.height, 3);
  retVal.Tinput = Tinput;
  for (let channel = 0; channel < 3; channel++) {
    computeTinput(input_decorrelated, Tinput, channel);
  }
  const Tinv = new TextureDataFloat(LUT_WIDTH, 1, 3);
  retVal.Tinv = Tinv;
  for (let channel = 0; channel < 3; channel++) {
    computeInvT(input_decorrelated, Tinv, channel);
  }
  Tinv.resize(Tinv.width, Math.floor(Math.log(Tinput.width) / Math.log(2)), 3);
  for (let channel = 0; channel < 3; channel++) {
    prefilterLUT(Tinput, Tinv, channel);
  }
  return retVal;
}
function convertHTMLImageElementToCanvas(image, width, height) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);
  return canvas;
}
function combineImages(data) {
  const width = data.width;
  const height = data.height;
  const outputCanvas = document.createElement("canvas");
  outputCanvas.width = width;
  outputCanvas.height = height;
  const outputCtx = outputCanvas.getContext("2d");
  const outputImageData = outputCtx.getImageData(0, 0, width, height);
  if (Is.exist(data.r_image)) {
    const inputR_ctx = data.r_image.getContext("2d");
    const r_imageData = inputR_ctx.getImageData(0, 0, data.r_image.width, data.r_image.height);
    for (let i2 = 0; i2 < width * height; i2++) {
      outputImageData.data[i2 * 4 + 0] = r_imageData.data[i2 * 4 + 0];
    }
  } else {
    for (let i2 = 0; i2 < width * height; i2++) {
      outputImageData.data[i2 * 4 + 0] = 0;
    }
  }
  if (Is.exist(data.g_image)) {
    const inputG_ctx = data.g_image.getContext("2d");
    const g_imageData = inputG_ctx.getImageData(0, 0, data.g_image.width, data.g_image.height);
    for (let i2 = 0; i2 < width * height; i2++) {
      outputImageData.data[i2 * 4 + 1] = g_imageData.data[i2 * 4 + 1];
    }
  } else {
    for (let i2 = 0; i2 < width * height; i2++) {
      outputImageData.data[i2 * 4 + 1] = 0;
    }
  }
  if (Is.exist(data.b_image)) {
    const inputB_ctx = data.b_image.getContext("2d");
    const b_imageData = inputB_ctx.getImageData(0, 0, data.b_image.width, data.b_image.height);
    for (let i2 = 0; i2 < width * height; i2++) {
      outputImageData.data[i2 * 4 + 2] = b_imageData.data[i2 * 4 + 2];
    }
  } else {
    for (let i2 = 0; i2 < width * height; i2++) {
      outputImageData.data[i2 * 4 + 2] = 0;
    }
  }
  if (Is.exist(data.a_image)) {
    const inputA_ctx = data.a_image.getContext("2d");
    const a_imageData = inputA_ctx.getImageData(0, 0, data.a_image.width, data.a_image.height);
    for (let i2 = 0; i2 < width * height; i2++) {
      outputImageData.data[i2 * 4 + 3] = a_imageData.data[i2 * 4 + 3];
    }
  } else {
    for (let i2 = 0; i2 < width * height; i2++) {
      outputImageData.data[i2 * 4 + 3] = 0;
    }
  }
  outputCtx.putImageData(outputImageData, 0, 0);
  return outputCanvas;
}
var ImageUtil;
var init_ImageUtil = __esm({
  "src/foundation/misc/ImageUtil.ts"() {
    "use strict";
    init_Vector3();
    init_MutableMatrix33();
    init_MathUtil();
    init_MutableVector3();
    init_ColorRgb();
    init_MutableVector2();
    init_TextureDataFloat();
    init_Is();
    __name(computeEigenVectors, "computeEigenVectors");
    __name(decorrelateColorSpace, "decorrelateColorSpace");
    __name(computeLODAverageSubpixelVariance, "computeLODAverageSubpixelVariance");
    __name(filterLUTValueAtx, "filterLUTValueAtx");
    __name(prefilterLUT, "prefilterLUT");
    __name(generatePixelSortTypeArray, "generatePixelSortTypeArray");
    __name(computeTinput, "computeTinput");
    __name(computeInvT, "computeInvT");
    __name(precomputations, "precomputations");
    __name(convertHTMLImageElementToCanvas, "convertHTMLImageElementToCanvas");
    __name(combineImages, "combineImages");
    ImageUtil = Object.freeze({
      precomputations
    });
  }
});

// src/foundation/misc/MiscUtil.ts
function assertExist(val) {
  if (val === void 0 || val === null) {
    throw new Error(`Expected 'val' to be existed, but received ${val}`);
  }
}
function deepCopyUsingJsonStringify(obj) {
  return JSON.parse(JSON.stringify(obj));
}
function downloadArrayBuffer(fileNameToDownload, arrayBuffer) {
  const a2 = document.createElement("a");
  a2.download = fileNameToDownload;
  const blob = new Blob([
    arrayBuffer
  ], {
    type: "octet/stream"
  });
  const url = URL.createObjectURL(blob);
  a2.href = url;
  const e3 = new MouseEvent("click");
  a2.dispatchEvent(e3);
  URL.revokeObjectURL(url);
}
function downloadTypedArray(fileNameToDownload, typedArray) {
  const a2 = document.createElement("a");
  a2.download = fileNameToDownload;
  const blob = new Blob([
    typedArray
  ], {
    type: "octet/stream"
  });
  const url = URL.createObjectURL(blob);
  a2.href = url;
  const e3 = new MouseEvent("click");
  a2.dispatchEvent(e3);
  URL.revokeObjectURL(url);
}
var isMobileVr, isMobile, isSafari, isIOS, isIPad, preventDefaultForDesktopOnly, isObject, fillTemplate, isNode, concatArrayBuffers, concatArrayBuffers2, valueWithDefault, ifExistsThen, ifExistsThenWithReturn, ifDefinedThen, ifDefinedThenWithReturn, ifUndefinedThen, ifUndefinedThenWithReturn, ifNotExistsThen, ifNotExistsThenWithReturn, defaultValue, valueWithCompensation, nullishToEmptyArray, nullishToEmptyMap, greaterThan, lessThan, addLineNumberToCode, MiscUtil;
var init_MiscUtil = __esm({
  "src/foundation/misc/MiscUtil.ts"() {
    "use strict";
    init_Is();
    isMobileVr = /* @__PURE__ */ __name(function() {
      if (typeof window !== "undefined") {
        return /(Pacific Build.+OculusBrowser.+SamsungBrowser.+)|(SamsungBrowser)|(Mobile VR)/i.test(window.navigator.userAgent);
      } else {
        return false;
      }
    }, "isMobileVr");
    isMobile = /* @__PURE__ */ __name(function() {
      const ua = [
        "iPod",
        "iPad",
        "iPhone",
        "Android"
      ];
      for (let i2 = 0; i2 < ua.length; i2++) {
        if (navigator.userAgent.indexOf(ua[i2]) > 0) {
          return true;
        }
      }
      return isIPad();
    }, "isMobile");
    isSafari = /* @__PURE__ */ __name(function() {
      const toBe = "Safari";
      const noToBe = "Chrome";
      if (navigator.userAgent.indexOf(toBe) > 0 && navigator.userAgent.indexOf(noToBe) === -1) {
        return true;
      }
      return false;
    }, "isSafari");
    isIOS = /* @__PURE__ */ __name(function() {
      const ua = [
        "iPod",
        "iPad",
        "iPhone"
      ];
      for (let i2 = 0; i2 < ua.length; i2++) {
        if (navigator.userAgent.indexOf(ua[i2]) > 0) {
          return true;
        }
      }
      return isIPad();
    }, "isIOS");
    isIPad = /* @__PURE__ */ __name(function() {
      return navigator.userAgent.indexOf("Macintosh") > -1 && "ontouchend" in document;
    }, "isIPad");
    preventDefaultForDesktopOnly = /* @__PURE__ */ __name(function(e3) {
      if (!isMobile()) {
        e3.preventDefault();
      }
    }, "preventDefaultForDesktopOnly");
    isObject = /* @__PURE__ */ __name(function(o2) {
      return o2 instanceof Object && !(o2 instanceof Array) ? true : false;
    }, "isObject");
    fillTemplate = /* @__PURE__ */ __name(function(templateString, templateVars) {
      return new Function("return `" + templateString + "`;").call(templateVars);
    }, "fillTemplate");
    isNode = /* @__PURE__ */ __name(function() {
      return typeof process !== "undefined" && typeof __require !== "undefined";
    }, "isNode");
    concatArrayBuffers = /* @__PURE__ */ __name(function(segments, sizes, offsets, finalSize) {
      let sumLength = 0;
      for (let i2 = 0; i2 < sizes.length; ++i2) {
        sumLength += sizes[i2];
      }
      let whole;
      if (finalSize != null) {
        whole = new Uint8Array(finalSize);
      } else {
        whole = new Uint8Array(sumLength);
      }
      const getExceededSize = /* @__PURE__ */ __name((sizeToAdd) => {
        if (finalSize != null && offsetOfBase + sizeToAdd > finalSize) {
          return offsetOfBase + sizeToAdd - finalSize;
        } else {
          return 0;
        }
      }, "getExceededSize");
      let offsetOfBase = 0;
      const addData = /* @__PURE__ */ __name((sizeToAdd, i2) => {
        const exceededSize = getExceededSize(sizeToAdd);
        if (exceededSize) {
          whole.set(new Uint8Array(segments[i2], offsets[i2], exceededSize), offsetOfBase);
          offsetOfBase += exceededSize;
          return true;
        } else {
          whole.set(new Uint8Array(segments[i2], offsets[i2], sizeToAdd), offsetOfBase);
          offsetOfBase += sizeToAdd;
          return false;
        }
      }, "addData");
      const addOverSizeData = /* @__PURE__ */ __name((overSize) => {
        const exceededSize = getExceededSize(overSize);
        if (exceededSize) {
          whole.set(new Uint8Array(exceededSize), offsetOfBase);
          offsetOfBase += exceededSize;
          return true;
        } else {
          whole.set(new Uint8Array(overSize), offsetOfBase);
          offsetOfBase += overSize;
          return false;
        }
      }, "addOverSizeData");
      for (let i2 = 0; i2 < segments.length; ++i2) {
        const delta = sizes[i2] + offsets[i2] - segments[i2].byteLength;
        const overSize = delta > 0 ? delta : 0;
        const sizeToAdd = sizes[i2] - overSize;
        if (addData(sizeToAdd, i2)) {
          return whole.buffer;
        }
        if (overSize > 0) {
          if (addOverSizeData(overSize)) {
            return whole.buffer;
          }
        }
      }
      if (finalSize != null && offsetOfBase < finalSize) {
        whole.set(new Uint8Array(finalSize - offsetOfBase), offsetOfBase);
      }
      return whole.buffer;
    }, "concatArrayBuffers");
    concatArrayBuffers2 = /* @__PURE__ */ __name(({ finalSize, srcs, srcsOffset, srcsCopySize }) => {
      const dstBuf = new Uint8Array(new ArrayBuffer(finalSize));
      let copiedSize = 0;
      for (const i2 in srcs) {
        const src = srcs[i2];
        const srcBuf = new Uint8Array(src, srcsOffset[i2], srcsCopySize[i2]);
        dstBuf.set(srcBuf, copiedSize);
        copiedSize += srcsCopySize[i2];
      }
      return dstBuf.buffer;
    }, "concatArrayBuffers2");
    valueWithDefault = /* @__PURE__ */ __name(({ value, defaultValue: defaultValue2 }) => {
      if (value == null) {
        return defaultValue2;
      }
      return value;
    }, "valueWithDefault");
    ifExistsThen = /* @__PURE__ */ __name((callback, value) => {
      if (Is.exist(value)) {
        callback(value);
        return true;
      }
      return false;
    }, "ifExistsThen");
    ifExistsThenWithReturn = /* @__PURE__ */ __name((callback, value) => {
      if (Is.exist(value)) {
        return callback(value);
      }
      return value;
    }, "ifExistsThenWithReturn");
    ifDefinedThen = /* @__PURE__ */ __name((callback, value) => {
      if (Is.exist(value)) {
        callback(value);
        return true;
      }
      return false;
    }, "ifDefinedThen");
    ifDefinedThenWithReturn = /* @__PURE__ */ __name((callback, value) => {
      if (Is.exist(value)) {
        return callback(value);
      }
      return value;
    }, "ifDefinedThenWithReturn");
    ifUndefinedThen = /* @__PURE__ */ __name((callback, value) => {
      if (Is.undefined(value)) {
        callback();
        return false;
      }
      return true;
    }, "ifUndefinedThen");
    ifUndefinedThenWithReturn = /* @__PURE__ */ __name((callback, value) => {
      if (Is.undefined(value)) {
        return callback();
      }
      return value;
    }, "ifUndefinedThenWithReturn");
    ifNotExistsThen = /* @__PURE__ */ __name((callback, value) => {
      if (Is.undefined(value)) {
        callback();
      }
    }, "ifNotExistsThen");
    ifNotExistsThenWithReturn = /* @__PURE__ */ __name((callback, value) => {
      if (Is.undefined(value)) {
        return callback();
      }
      return value;
    }, "ifNotExistsThenWithReturn");
    defaultValue = /* @__PURE__ */ __name((defaultValue2, value) => {
      if (value == null) {
        return defaultValue2;
      }
      return value;
    }, "defaultValue");
    valueWithCompensation = /* @__PURE__ */ __name(({ value, compensation }) => {
      if (value == null) {
        return compensation();
      }
      return value;
    }, "valueWithCompensation");
    nullishToEmptyArray = /* @__PURE__ */ __name((value) => {
      if (value == null) {
        return [];
      }
      return value;
    }, "nullishToEmptyArray");
    nullishToEmptyMap = /* @__PURE__ */ __name((value) => {
      if (value == null) {
        return /* @__PURE__ */ new Map();
      }
      return value;
    }, "nullishToEmptyMap");
    greaterThan = /* @__PURE__ */ __name((it, than) => {
      if (it > than) {
        return {
          result: true,
          greater: it,
          less: than
        };
      } else {
        return {
          result: false,
          greater: than,
          less: it
        };
      }
    }, "greaterThan");
    lessThan = /* @__PURE__ */ __name((it, than) => {
      if (it < than) {
        return {
          result: true,
          greater: than,
          less: it
        };
      } else {
        return {
          result: false,
          greater: it,
          less: than
        };
      }
    }, "lessThan");
    addLineNumberToCode = /* @__PURE__ */ __name((shaderString) => {
      const shaderTextLines = shaderString.split(/\r\n|\r|\n/);
      let shaderTextWithLineNumber = "";
      for (let i2 = 0; i2 < shaderTextLines.length; i2++) {
        const lineIndex = i2 + 1;
        let splitter = " : ";
        if (lineIndex < 10) {
          splitter = "  : ";
        } else if (lineIndex >= 100) {
          splitter = ": ";
        }
        shaderTextWithLineNumber += lineIndex + splitter + shaderTextLines[i2] + "\n";
      }
      return shaderTextWithLineNumber;
    }, "addLineNumberToCode");
    __name(assertExist, "assertExist");
    __name(deepCopyUsingJsonStringify, "deepCopyUsingJsonStringify");
    __name(downloadArrayBuffer, "downloadArrayBuffer");
    __name(downloadTypedArray, "downloadTypedArray");
    MiscUtil = Object.freeze({
      isMobileVr,
      isMobile,
      isIOS,
      isSafari,
      preventDefaultForDesktopOnly,
      isObject,
      fillTemplate,
      isNode,
      concatArrayBuffers,
      concatArrayBuffers2,
      addLineNumberToCode,
      downloadArrayBuffer,
      downloadTypedArray
    });
  }
});

// src/foundation/misc/Option.ts
function assertHas(value) {
  if (!value.has()) {
    throw new ReferenceError(errorStr);
  }
}
function assertDoesNotHave(value) {
  if (value.has()) {
    throw new ReferenceError(errorStr);
  }
}
var errorStr, _Some, Some, _None, None;
var init_Option = __esm({
  "src/foundation/misc/Option.ts"() {
    "use strict";
    errorStr = "The value does not exist!";
    _Some = class _Some {
      constructor(value) {
        __publicField(this, "value");
        this.value = value;
      }
      /**
      * This method is essentially same to the Some::and_then() in Rust language
      * @param f
      */
      andThen(f2) {
        return f2(this.value);
      }
      orElse(f2) {
        return this;
      }
      match(obj) {
        return obj.Some(this.value);
      }
      /**
      * @param altValue
      * @returns
      */
      unwrapOrDefault(altValue) {
        return this.value;
      }
      /**
      * @param altValue
      * @returns
      */
      unwrapOrElse(f2) {
        return this.value;
      }
      /**
      * @param altValue
      * @returns
      */
      unwrapForce() {
        return this.value;
      }
      unwrapOrUndefined() {
        return this.value;
      }
      get() {
        return this.value;
      }
      has() {
        return true;
      }
      doesNotHave() {
        return false;
      }
    };
    __name(_Some, "Some");
    Some = _Some;
    _None = class _None {
      andThen(f2) {
        return this;
      }
      orElse(f2) {
        return f2();
      }
      match(obj) {
        return obj.None();
      }
      unwrapOrDefault(value) {
        return value;
      }
      unwrapOrElse(f2) {
        return f2();
      }
      unwrapForce() {
        throw new ReferenceError(errorStr);
      }
      unwrapOrUndefined() {
        return void 0;
      }
      has() {
        return false;
      }
      doesNotHave() {
        return true;
      }
    };
    __name(_None, "None");
    None = _None;
    __name(assertHas, "assertHas");
    __name(assertDoesNotHave, "assertDoesNotHave");
  }
});

// src/foundation/misc/Time.ts
var _Time, Time;
var init_Time = __esm({
  "src/foundation/misc/Time.ts"() {
    "use strict";
    _Time = class _Time {
      /**
      * @internal
      */
      static _processBegin() {
        _Time.__currentProcessBeginTime = performance.now();
        _Time.__intervalProcessBegin = _Time.__currentProcessBeginTime - _Time.__lastProcessBeginTime;
        if (_Time.__systemStartTime === 0) {
          _Time.__systemStartTime = _Time.__currentProcessBeginTime;
        }
        _Time.__lastProcessBeginTime = _Time.__currentProcessBeginTime;
      }
      /**
      * @internal
      */
      static _processEnd() {
        _Time.__lastProcessEndTime = performance.now();
        _Time.__lastTickTimeInterval = _Time.__lastProcessEndTime - _Time.__currentProcessBeginTime;
      }
      static get timeAtProcessBeginMilliseconds() {
        return _Time.__currentProcessBeginTime;
      }
      static get timeAtProcessEndMilliseconds() {
        return _Time.__lastProcessEndTime;
      }
      static get timeFromSystemStart() {
        return (performance.now() - _Time.__systemStartTime) / 1e3;
      }
      static get lastTickTimeInterval() {
        return _Time.__lastTickTimeInterval / 1e3;
      }
      static get intervalProcessBegin() {
        return _Time.__intervalProcessBegin / 1e3;
      }
      static get lastTimeTimeIntervalInMilliseconds() {
        return _Time.__lastTickTimeInterval;
      }
    };
    __name(_Time, "Time");
    __publicField(_Time, "__currentProcessBeginTime", 0);
    __publicField(_Time, "__lastProcessBeginTime", 0);
    __publicField(_Time, "__lastProcessEndTime", 0);
    __publicField(_Time, "__lastTickTimeInterval", 0);
    __publicField(_Time, "__systemStartTime", 0);
    __publicField(_Time, "__intervalProcessBegin", 0);
    Time = _Time;
  }
});

// src/foundation/misc/WeakOption.ts
var errorStr2, _WeakOption, WeakOption, _WeakSome, WeakSome, _WeakNone, WeakNone;
var init_WeakOption = __esm({
  "src/foundation/misc/WeakOption.ts"() {
    "use strict";
    init_Is();
    errorStr2 = "The value does not exist!";
    _WeakOption = class _WeakOption {
      constructor() {
        __publicField(this, "__weakMap", /* @__PURE__ */ new WeakMap());
      }
      set(base, val) {
        this.__weakMap.set(base, val);
      }
      /**
      * @param altValue
      * @returns
      */
      unwrapOrDefault(base, altValue) {
        const value = this.__weakMap.get(base);
        return Is.exist(value) ? value : altValue;
      }
      /**
      * @param altValue
      * @returns
      */
      unwrapOrElse(base, f2) {
        const value = this.__weakMap.get(base);
        return Is.exist(value) ? value : f2();
      }
      /**
      * @returns
      */
      unwrapForce(base) {
        const value = this.__weakMap.get(base);
        if (Is.exist(value)) {
          return value;
        } else {
          throw new ReferenceError(errorStr2);
        }
      }
      unwrapOrUndefined(base) {
        return this.__weakMap.get(base);
      }
      has(base) {
        return this.__weakMap.has(base);
      }
    };
    __name(_WeakOption, "WeakOption");
    WeakOption = _WeakOption;
    _WeakSome = class _WeakSome {
      constructor(base, value) {
        __publicField(this, "__weakMap", /* @__PURE__ */ new WeakMap());
        this.__weakMap.set(base, value);
      }
      /**
      * @param altValue
      * @returns
      */
      unwrapOrDefault(base, altValue) {
        return this.__weakMap.get(base);
      }
      /**
      * @param altValue
      * @returns
      */
      unwrapOrElse(base, f2) {
        return this.__weakMap.get(base);
      }
      /**
      * @param altValue
      * @returns
      */
      unwrapForce(base) {
        return this.__weakMap.get(base);
      }
      get(base) {
        return this.__weakMap.get(base);
      }
      unwrapOrUndefined(base) {
        return this.__weakMap.get(base);
      }
      has(base) {
        return true;
      }
    };
    __name(_WeakSome, "WeakSome");
    WeakSome = _WeakSome;
    _WeakNone = class _WeakNone {
      then() {
        return this;
      }
      unwrapOrDefault(base, value) {
        return value;
      }
      unwrapOrElse(base, f2) {
        return f2(void 0);
      }
      unwrapForce(base) {
        throw new ReferenceError(errorStr2);
      }
      unwrapOrUndefined(base) {
        return void 0;
      }
      has() {
        return false;
      }
    };
    __name(_WeakNone, "WeakNone");
    WeakNone = _WeakNone;
  }
});

// src/foundation/misc/index.ts
var init_misc = __esm({
  "src/foundation/misc/index.ts"() {
    "use strict";
    init_cache();
    init_DataUtil();
    init_EnumIO();
    init_ImageUtil();
    init_Is();
    init_MiscUtil();
    init_Option();
    init_Result();
    init_RnPromise();
    init_RnException();
    init_Time();
    init_WeakOption();
    init_Logger();
  }
});

// src/foundation/core/Config.ts
var maxEntityNumber, maxLightNumberInShader, maxVertexMorphNumberInShader, maxVertexPrimitiveNumberInShader, maxMaterialInstanceForEachType, maxSkeletonNumber, maxCameraNumber, maxSizeLimitOfNonCompressedTexture, maxSkeletalBoneNumber, maxSkeletalBoneNumberForUniformMode, dataTextureWidth, dataTextureHeight, boneDataType, maxMorphTargetNumber, totalSizeOfGPUShaderDataStorageExceptMorphData, isUboEnabled, eventTargetDom, cacheWebGpuRenderBundles, cgApiDebugConsoleOutput, multiViewForWebVR, physicsTimeIntervalScale, vrmSpringBoneBonAxisCoeff, vrmSpringBoneToCoeff, isMobile2, Config;
var init_Config = __esm({
  "src/foundation/core/Config.ts"() {
    "use strict";
    init_BoneDataType();
    init_misc();
    maxEntityNumber = 5e3;
    maxLightNumberInShader = 4;
    maxVertexMorphNumberInShader = 41;
    maxVertexPrimitiveNumberInShader = 10;
    maxMaterialInstanceForEachType = 10;
    maxSkeletonNumber = 33;
    maxCameraNumber = 30;
    maxSizeLimitOfNonCompressedTexture = 512;
    maxSkeletalBoneNumber = 300;
    maxSkeletalBoneNumberForUniformMode = 50;
    dataTextureWidth = Math.pow(2, 12);
    dataTextureHeight = Math.pow(2, 12);
    boneDataType = BoneDataType.Mat43x1;
    maxMorphTargetNumber = 4;
    totalSizeOfGPUShaderDataStorageExceptMorphData = 0;
    isUboEnabled = false;
    cacheWebGpuRenderBundles = true;
    cgApiDebugConsoleOutput = false;
    multiViewForWebVR = false;
    physicsTimeIntervalScale = 1;
    vrmSpringBoneBonAxisCoeff = 0.5;
    vrmSpringBoneToCoeff = 0.4;
    isMobile2 = false;
    if (typeof navigator !== "undefined") {
      if (MiscUtil.isMobile() || MiscUtil.isMobileVr()) {
        maxVertexMorphNumberInShader = 4;
        maxSkeletonNumber = 32;
        dataTextureWidth = 2 ** 9;
        dataTextureHeight = 2 ** 9;
      }
    }
    Config = {
      maxEntityNumber,
      maxLightNumberInShader,
      maxVertexMorphNumberInShader,
      maxVertexPrimitiveNumberInShader,
      maxMaterialInstanceForEachType,
      boneDataType,
      maxSkeletonNumber,
      maxCameraNumber,
      maxSizeLimitOfNonCompressedTexture,
      maxSkeletalBoneNumber,
      maxSkeletalBoneNumberForUniformMode,
      dataTextureWidth,
      dataTextureHeight,
      maxMorphTargetNumber,
      totalSizeOfGPUShaderDataStorageExceptMorphData,
      isUboEnabled,
      eventTargetDom,
      cacheWebGpuRenderBundles,
      cgApiDebugConsoleOutput,
      multiViewForWebVR,
      physicsTimeIntervalScale,
      vrmSpringBoneBonAxisCoeff,
      vrmSpringBoneToCoeff,
      isMobile: isMobile2
    };
  }
});

// src/foundation/cameras/OrbitCameraController.ts
var _OrbitCameraController, OrbitCameraController;
var init_OrbitCameraController = __esm({
  "src/foundation/cameras/OrbitCameraController.ts"() {
    "use strict";
    init_Vector3();
    init_MutableVector3();
    init_MathUtil();
    init_MutableMatrix33();
    init_Matrix44();
    init_MutableMatrix44();
    init_AABB();
    init_AbstractCameraController();
    init_Is();
    init_InputManager();
    init_Config();
    _OrbitCameraController = class _OrbitCameraController extends AbstractCameraController {
      constructor(cameraControllerComponent) {
        super();
        __publicField(this, "dollyScale", 2);
        __publicField(this, "scaleOfLengthCenterToCamera", 1);
        __publicField(this, "moveSpeed", 1);
        __publicField(this, "followTargetAABB", false);
        __publicField(this, "autoUpdate", true);
        __publicField(this, "__updated", false);
        __publicField(this, "__updateCount", 0);
        __publicField(this, "__fixedLengthOfCenterToEye", 1);
        __publicField(this, "__isMouseDown", false);
        __publicField(this, "__lastMouseDownTimeStamp", 0);
        __publicField(this, "__lastMouseUpTimeStamp", 0);
        __publicField(this, "__originalY", -1);
        __publicField(this, "__originalX", -1);
        __publicField(this, "__buttonNumber", 0);
        __publicField(this, "__mouse_translate_y", 0);
        __publicField(this, "__mouse_translate_x", 0);
        __publicField(this, "__efficiency", 1);
        __publicField(this, "__lengthOfCenterToEye", 1);
        __publicField(this, "__fovyBias", 1);
        __publicField(this, "__scaleOfTranslation", 2.8);
        __publicField(this, "__mouseTranslateVec", MutableVector3.zero());
        __publicField(this, "__newEyeVec", MutableVector3.zero());
        __publicField(this, "__newCenterVec", MutableVector3.zero());
        __publicField(this, "__newUpVec", MutableVector3.zero());
        __publicField(this, "__newTangentVec", MutableVector3.zero());
        // private __verticalAngleThreshold = 0;
        // private __verticalAngleOfVectors = 0;
        __publicField(this, "__isSymmetryMode", true);
        // private __doResetWhenCameraSettingChanged = false;
        __publicField(this, "__rot_bgn_x", 0);
        __publicField(this, "__rot_bgn_y", 0);
        __publicField(this, "__rot_x", 0);
        __publicField(this, "__rot_y", 0);
        __publicField(this, "__dolly", 0.5);
        __publicField(this, "__eyeVec", MutableVector3.zero());
        __publicField(this, "__centerVec", MutableVector3.zero());
        __publicField(this, "__upVec", MutableVector3.zero());
        __publicField(this, "__targetEntities", []);
        __publicField(this, "__scaleOfZNearAndZFar", 5e3);
        __publicField(this, "__doPreventDefault", false);
        __publicField(this, "__isPressingShift", false);
        __publicField(this, "__isPressingCtrl", false);
        __publicField(this, "__pinchInOutControl", false);
        __publicField(this, "__pinchInOutOriginalDistance", null);
        __publicField(this, "__maximum_y");
        __publicField(this, "__minimum_y");
        __publicField(this, "__resetDollyTouchTime", 0);
        __publicField(this, "__initialTargetAABB");
        __publicField(this, "aabbWithSkeletal", true);
        __publicField(this, "useInitialTargetAABBForLength", false);
        // private __controllerTranslate = MutableVector3.zero();
        __publicField(this, "__mouseDownFunc", this.__mouseDown.bind(this));
        __publicField(this, "__mouseUpFunc", this.__mouseUp.bind(this));
        __publicField(this, "__mouseMoveFunc", this.__mouseMove.bind(this));
        __publicField(this, "__touchDownFunc", this.__touchDown.bind(this));
        __publicField(this, "__touchUpFunc", this.__touchUp.bind(this));
        __publicField(this, "__touchMoveFunc", this.__touchMove.bind(this));
        __publicField(this, "__pinchInOutFunc", this.__pinchInOut.bind(this));
        __publicField(this, "__pinchInOutEndFunc", this.__pinchInOutEnd.bind(this));
        __publicField(this, "__mouseWheelFunc", this.__mouseWheel.bind(this));
        __publicField(this, "__mouseDblClickFunc", this.__mouseDblClick.bind(this));
        __publicField(this, "__contextMenuFunc", this.__contextMenu.bind(this));
        __publicField(this, "__pressShiftFunc", this.__pressShift.bind(this));
        __publicField(this, "__releaseShiftFunc", this.__releaseShift.bind(this));
        __publicField(this, "__pressCtrlFunc", this.__pressCtrl.bind(this));
        __publicField(this, "__releaseCtrlFunc", this.__releaseCtrl.bind(this));
        __publicField(this, "__resetDollyAndPositionFunc", this.__resetDollyAndPosition.bind(this));
        __publicField(this, "__cameraControllerComponent");
        this.registerEventListeners();
        this.__cameraControllerComponent = cameraControllerComponent;
      }
      get updateCount() {
        return this.__updateCount;
      }
      _updateCount() {
        this.__updateCount++;
        this.__cameraControllerComponent._updateCount(this.__updateCount);
      }
      resetDollyAndTranslation() {
        this.__dolly = 0.5;
        this.__mouse_translate_x = 0;
        this.__mouse_translate_y = 0;
        this.__mouseTranslateVec = MutableVector3.zero();
      }
      setTarget(targetEntity) {
        this.setTargets([
          targetEntity
        ]);
      }
      setTargets(targetEntities) {
        this.__targetEntities = targetEntities;
        this.__initialTargetAABB = void 0;
        this.__updated = false;
        this._updateCount();
      }
      getTargets() {
        return this.__targetEntities;
      }
      set doPreventDefault(flag) {
        this.__doPreventDefault = flag;
      }
      get doPreventDefault() {
        return this.__doPreventDefault;
      }
      __mouseDown(e3) {
        this.__tryToPreventDefault(e3);
        if (this.__isPressingCtrl) return;
        this.__originalX = e3.clientX;
        this.__originalY = e3.clientY;
        this.__rot_bgn_x = this.__rot_x;
        this.__rot_bgn_y = this.__rot_y;
        this.__isMouseDown = true;
        this.__lastMouseDownTimeStamp = e3.timeStamp;
        this.__updated = false;
        this._updateCount();
      }
      __mouseMove(e3) {
        this.__tryToPreventDefault(e3);
        if (Is.false(this.isMouseDown)) return;
        if (this.__isPressingCtrl) return;
        if (this.__buttonNumber === 0) {
          this.__buttonNumber = e3.buttons;
        }
        const currentMouseX = e3.clientX;
        const currentMouseY = e3.clientY;
        switch (this.__buttonNumber) {
          case 1:
            if (this.__isPressingShift) {
              this.__parallelTranslateControl(this.__originalX, this.__originalY, currentMouseX, currentMouseY);
            } else {
              this.__rotateControl(this.__originalX, this.__originalY, currentMouseX, currentMouseY);
              this.__rot_bgn_x = this.__rot_x;
              this.__rot_bgn_y = this.__rot_y;
            }
            break;
          case 2:
            this.__zoomControl(this.__originalX, currentMouseX);
            break;
          case 4:
            this.__parallelTranslateControl(this.__originalX, this.__originalY, currentMouseX, currentMouseY);
            break;
          default:
            return;
        }
        this.__originalX = currentMouseX;
        this.__originalY = currentMouseY;
        this.__updated = false;
        this._updateCount();
      }
      __mouseUp(e3) {
        this.__buttonNumber = 0;
        this.__originalX = -1;
        this.__originalY = -1;
        this.__isMouseDown = false;
        this.__lastMouseUpTimeStamp = e3.timeStamp;
        this.__updated = false;
        this._updateCount();
      }
      __touchDown(e3) {
        this.__tryToPreventDefault(e3);
        if (e3.touches.length === 1) {
          this.__originalX = e3.touches[0].clientX;
          this.__originalY = e3.touches[0].clientY;
          this.__rot_bgn_x = this.__rot_x;
          this.__rot_bgn_y = this.__rot_y;
        } else {
          this.__originalX = (e3.touches[0].clientX + e3.touches[1].clientX) * 0.5;
          this.__originalY = (e3.touches[0].clientY + e3.touches[1].clientY) * 0.5;
        }
        this.__isMouseDown = true;
        this.__lastMouseDownTimeStamp = e3.timeStamp;
        this.__updated = false;
        this._updateCount();
      }
      __touchMove(e3) {
        this.__tryToPreventDefault(e3);
        if (Is.false(this.isMouseDown)) return;
        let currentTouchX = e3.touches[0].clientX;
        let currentTouchY = e3.touches[0].clientY;
        if (e3.touches.length === 1) {
          currentTouchX = e3.touches[0].clientX;
          currentTouchY = e3.touches[0].clientY;
          this.__rotateControl(this.__originalX, this.__originalY, currentTouchX, currentTouchY);
          this.__rot_bgn_x = this.__rot_x;
          this.__rot_bgn_y = this.__rot_y;
        } else {
          currentTouchX = (e3.touches[0].clientX + e3.touches[1].clientX) * 0.5;
          currentTouchY = (e3.touches[0].clientY + e3.touches[1].clientY) * 0.5;
          this.__parallelTranslateControl(this.__originalX, this.__originalY, currentTouchX, currentTouchY);
        }
        this.__originalX = currentTouchX;
        this.__originalY = currentTouchY;
        this.__updated = false;
        this._updateCount();
      }
      __touchUp(e3) {
        const touchNumber = e3.touches.length;
        if (touchNumber === 0) {
          this.__originalX = -1;
          this.__originalY = -1;
        } else if (touchNumber === 1) {
          this.__originalX = e3.touches[0].clientX;
          this.__originalY = e3.touches[0].clientY;
          this.__rot_bgn_x = this.__rot_x;
          this.__rot_bgn_y = this.__rot_y;
        } else {
          this.__originalX = (e3.touches[0].clientX + e3.touches[1].clientX) * 0.5;
          this.__originalY = (e3.touches[0].clientY + e3.touches[1].clientY) * 0.5;
        }
        this.__isMouseDown = false;
        this.__lastMouseUpTimeStamp = e3.timeStamp;
        this.__updated = false;
        this._updateCount();
      }
      set rotX(value) {
        this.__rot_x = value;
        this.__updated = false;
        this._updateCount();
      }
      get rotX() {
        return this.__rot_x;
      }
      set rotY(value) {
        this.__rot_y = value;
        this.__updated = false;
        this._updateCount();
      }
      get rotY() {
        return this.__rot_y;
      }
      set maximumY(maximum_y) {
        this.__maximum_y = maximum_y;
      }
      set minimumY(minimum_y) {
        this.__minimum_y = minimum_y;
      }
      __rotateControl(originalX, originalY, currentX, currentY) {
        const delta_x = (currentX - originalX) * this.__efficiency * 0.3;
        const delta_y = (currentY - originalY) * this.__efficiency * 0.3;
        this.__rot_x = this.__rot_bgn_x - delta_x;
        this.__rot_y = this.__rot_bgn_y - delta_y;
        if (this.__maximum_y != null && this.__rot_y > this.__maximum_y) {
          this.__rot_y = this.__maximum_y;
        }
        if (this.__minimum_y != null && this.__rot_y < this.__minimum_y) {
          this.__rot_y = this.__minimum_y;
        }
      }
      __zoomControl(originalValue, currentValue) {
        this.dolly -= (currentValue - originalValue) / 1e3 * this.__efficiency;
      }
      __parallelTranslateControl(originalX, originalY, currentX, currentY) {
        this.__mouse_translate_y = (currentY - originalY) / 1e3 * this.__efficiency;
        this.__mouse_translate_x = (currentX - originalX) / 1e3 * this.__efficiency;
        const scale = this.__lengthOfCenterToEye * this.__fovyBias * this.__scaleOfTranslation;
        const upDirTranslateVec = _OrbitCameraController.__tmpVec3_0;
        upDirTranslateVec.copyComponents(this.__newUpVec).normalize().multiply(this.__mouse_translate_y).multiply(scale);
        const tangentDirTranslateVec = _OrbitCameraController.__tmpVec3_1;
        tangentDirTranslateVec.copyComponents(this.__newTangentVec).normalize().multiply(this.__mouse_translate_x).multiply(scale);
        this.__mouseTranslateVec.add(upDirTranslateVec).add(tangentDirTranslateVec);
      }
      __getTouchesDistance(e3) {
        const touches = e3.touches;
        const diffX = touches[1].clientX - touches[0].clientX;
        const diffY = touches[1].clientY - touches[0].clientY;
        return Math.hypot(diffX, diffY);
      }
      __pinchInOut(e3) {
        if (e3.touches.length < 2) return;
        if (this.__pinchInOutOriginalDistance == null) {
          this.__pinchInOutOriginalDistance = this.__getTouchesDistance(e3);
          return;
        }
        const currentDistance = this.__getTouchesDistance(e3);
        const originalDistance = this.__pinchInOutOriginalDistance;
        if (!this.__pinchInOutControl) {
          if (Math.abs(currentDistance - originalDistance) > 35) {
            this.__pinchInOutOriginalDistance = currentDistance;
            this.__pinchInOutControl = true;
          }
          return;
        }
        const ratio = originalDistance / currentDistance;
        this.dolly *= Math.pow(ratio * this.__efficiency, 2.2 / 15);
        this.__pinchInOutOriginalDistance = currentDistance;
        this.__updated = false;
        this._updateCount();
      }
      __pinchInOutEnd(e3) {
        if (e3.touches.length < 2) {
          this.__pinchInOutControl = false;
          this.__pinchInOutOriginalDistance = null;
        }
        this.__updated = false;
        this._updateCount();
      }
      __tryToPreventDefault(evt) {
        if (this.__doPreventDefault) {
          evt.preventDefault();
        }
      }
      __mouseWheel(evt) {
        this.__tryToPreventDefault(evt);
        this.dolly += Math.sign(evt.deltaY) / 200;
        this.__updated = false;
        this._updateCount();
      }
      __contextMenu(evt) {
        this.__tryToPreventDefault(evt);
      }
      set dolly(value) {
        value = Math.min(value, 1);
        value = Math.max(value, 1e-4);
        let gamma = Math.pow(value, 5);
        gamma = Math.max(gamma, 1e-4);
        this.__dolly = gamma;
      }
      get dolly() {
        return Math.pow(this.__dolly, 1 / 5);
      }
      __mouseDblClick(evt) {
        if (evt.shiftKey) {
          this.__mouseTranslateVec.zero();
        } else if (evt.ctrlKey) {
          this.__rot_y = 0;
          this.__rot_x = 0;
          this.__rot_bgn_y = 0;
          this.__rot_bgn_x = 0;
        }
      }
      __resetDollyAndPosition(e3) {
        if (e3.touches.length > 1) return;
        const currentTime = (/* @__PURE__ */ new Date()).getTime();
        if (currentTime - this.__resetDollyTouchTime < 300) {
          this.dolly = Math.pow(0.5, 1 / 2.2);
          this.__mouseTranslateVec.zero();
          this.__rot_x = 0;
          this.__rot_y = 0;
        } else {
          this.__resetDollyTouchTime = currentTime;
        }
      }
      __pressShift(e3) {
        if (e3.shiftKey === true) {
          this.__isPressingShift = true;
        }
      }
      __releaseShift(e3) {
        if (e3.shiftKey === false) {
          this.__isPressingShift = false;
        }
      }
      __pressCtrl(e3) {
        if (e3.ctrlKey === true) {
          this.__isPressingCtrl = true;
        }
      }
      __releaseCtrl(e3) {
        if (e3.ctrlKey === false) {
          this.__isPressingCtrl = false;
        }
      }
      registerEventListeners() {
        let eventTargetDom2 = window;
        if (Is.exist(Config.eventTargetDom)) {
          eventTargetDom2 = Config.eventTargetDom;
        }
        if ("ontouchend" in document) {
          InputManager.register(INPUT_HANDLING_STATE_CAMERA_CONTROLLER, [
            {
              eventName: "touchstart",
              handler: this.__touchDownFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "touchmove",
              handler: this.__touchMoveFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "touchend",
              handler: this.__touchUpFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "touchmove",
              handler: this.__pinchInOutFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "touchend",
              handler: this.__pinchInOutEndFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "touchstart",
              handler: this.__resetDollyAndPositionFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "contextmenu",
              handler: this.__contextMenuFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "dblclick",
              handler: this.__mouseDblClickFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            }
          ]);
        } else {
          InputManager.register(INPUT_HANDLING_STATE_CAMERA_CONTROLLER, [
            {
              eventName: "mousedown",
              handler: this.__mouseDownFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "mouseup",
              handler: this.__mouseUpFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "mouseleave",
              handler: this.__mouseUpFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "mousemove",
              handler: this.__mouseMoveFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "keydown",
              handler: this.__pressShiftFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "keyup",
              handler: this.__releaseShiftFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "keydown",
              handler: this.__pressCtrlFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "keyup",
              handler: this.__releaseCtrlFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "contextmenu",
              handler: this.__contextMenuFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "wheel",
              handler: this.__mouseWheelFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "dblclick",
              handler: this.__mouseDblClickFunc,
              options: {
                passive: !this.__doPreventDefault
              },
              classInstance: this,
              eventTargetDom: eventTargetDom2
            }
          ]);
        }
      }
      unregisterEventListeners() {
        InputManager.unregister(INPUT_HANDLING_STATE_CAMERA_CONTROLLER);
      }
      __getFovyFromCamera(camera) {
        if (camera.fovy) {
          return camera.fovy;
        } else {
          return MathUtil.radianToDegree(2 * Math.atan(Math.abs(camera.top - camera.bottom) / (2 * camera.zNear)));
        }
      }
      logic(cameraComponent) {
        if (!this.__updated || this.autoUpdate) {
          this.__updateTargeting(cameraComponent);
          this.__calculateInfluenceOfController();
          this.__updateCameraComponent(cameraComponent);
          this.__updated = true;
        }
      }
      __getTargetAABB(targetEntity) {
        if (this.aabbWithSkeletal) {
          return targetEntity.tryToGetSceneGraph().worldMergedAABBWithSkeletal;
        } else {
          return targetEntity.tryToGetSceneGraph().worldMergedAABB;
        }
      }
      /**
      * update center, eye and up vectors of OrbitCameraController
      * @internal
      */
      __updateTargeting(camera) {
        const eyeVec = camera.eye;
        const centerVec = camera._direction;
        const upVec = camera._up;
        const newEyeVec = this.__eyeVec;
        const newCenterVec = this.__centerVec;
        const newUpVec = this.__upVec.copyComponents(upVec);
        if (this.__targetEntities.length === 0) {
          newEyeVec.copyComponents(eyeVec);
          newCenterVec.copyComponents(centerVec);
        } else {
          if (this.__initialTargetAABB == null) {
            const aabb = new AABB();
            for (const targetEntity of this.__targetEntities) {
              aabb.mergeAABB(this.__getTargetAABB(targetEntity));
            }
            this.__initialTargetAABB = aabb.clone();
          }
          let aabbToUse = this.__initialTargetAABB;
          if (this.followTargetAABB) {
            const aabb = new AABB();
            for (const targetEntity of this.__targetEntities) {
              aabb.mergeAABB(this.__getTargetAABB(targetEntity));
            }
            aabbToUse = aabb;
          }
          newCenterVec.copyComponents(aabbToUse.centerPoint);
          const centerToCameraVec = MutableVector3.subtractTo(eyeVec, centerVec, newEyeVec);
          const centerToCameraVecNormalized = centerToCameraVec.normalize();
          const lengthCenterToCorner = this.useInitialTargetAABBForLength ? this.__initialTargetAABB.lengthCenterToCorner : aabbToUse.lengthCenterToCorner;
          let lengthCenterToCamera = lengthCenterToCorner * (1 + 1 / Math.tan(MathUtil.degreeToRadian(camera.fovy / 2))) * this.scaleOfLengthCenterToCamera;
          if (Math.abs(lengthCenterToCamera) < 1e-5) {
            lengthCenterToCamera = 1;
          }
          centerToCameraVecNormalized.multiply(lengthCenterToCamera).add(newCenterVec);
          const sg = camera.entity.tryToGetSceneGraph();
          if (sg != null) {
            const invMat = Matrix44.invertTo(sg.matrixInner, _OrbitCameraController.__tmpMat44_0);
            invMat.multiplyVector3To(newCenterVec, newCenterVec);
            invMat.multiplyVector3To(newEyeVec, newEyeVec);
            invMat.multiplyVector3To(newUpVec, newUpVec);
          }
        }
      }
      /**
      * calculate up, eye, center and tangent vector with controller influence
      * @internal
      */
      __calculateInfluenceOfController() {
        const centerToEyeVec = MutableVector3.subtractTo(this.__eyeVec, this.__centerVec, _OrbitCameraController.__tmpVec3_0);
        centerToEyeVec.multiply(this.__dolly * this.dollyScale);
        this.__lengthOfCenterToEye = centerToEyeVec.length();
        const newUpVec = this.__newUpVec;
        const newEyeVec = this.__newEyeVec;
        const newCenterVec = this.__newCenterVec;
        const newTangentVec = this.__newTangentVec;
        if (this.__isSymmetryMode) {
          const projectedCenterToEyeVec = _OrbitCameraController.__tmpVec3_1;
          projectedCenterToEyeVec.setComponents(centerToEyeVec.x, 0, centerToEyeVec.z);
          let horizontalAngleOfVectors = Vector3.angleOfVectors(projectedCenterToEyeVec, _OrbitCameraController.__tmp_up);
          const horizontalSign = Math.sign(projectedCenterToEyeVec.cross(_OrbitCameraController.__tmp_up).y);
          horizontalAngleOfVectors *= horizontalSign;
          const rotateM_X = _OrbitCameraController.__tmp_rotateM_X;
          const rotateM_Y = _OrbitCameraController.__tmp_rotateM_Y;
          const rotateM_Reset = _OrbitCameraController.__tmp_rotateM_Reset;
          const rotateM_Revert = _OrbitCameraController.__tmp_rotateM_Revert;
          rotateM_X.rotateX(MathUtil.degreeToRadian(this.__rot_y));
          rotateM_Y.rotateY(MathUtil.degreeToRadian(this.__rot_x));
          rotateM_Reset.rotateY(MathUtil.degreeToRadian(horizontalAngleOfVectors));
          rotateM_Revert.rotateY(MathUtil.degreeToRadian(-horizontalAngleOfVectors));
          const rotateM = _OrbitCameraController.__tmp_rotateM;
          MutableMatrix33.multiplyTo(rotateM_X, rotateM_Reset, rotateM);
          rotateM.multiplyByLeft(rotateM_Y);
          rotateM.multiplyByLeft(rotateM_Revert);
          rotateM.multiplyVectorTo(this.__upVec, newUpVec);
          rotateM.multiplyVectorTo(centerToEyeVec, newEyeVec).add(this.__centerVec);
          newCenterVec.copyComponents(this.__centerVec);
          const newEyeToCenterVec = _OrbitCameraController.__tmpVec3_2;
          MutableVector3.subtractTo(newCenterVec, newEyeVec, newEyeToCenterVec);
          MutableVector3.crossTo(newUpVec, newEyeToCenterVec, newTangentVec);
          newEyeVec.add(this.__mouseTranslateVec);
          newCenterVec.add(this.__mouseTranslateVec);
        } else {
          const rotateM_X = _OrbitCameraController.__tmp_rotateM_X;
          const rotateM_Y = _OrbitCameraController.__tmp_rotateM_Y;
          rotateM_X.rotateX(MathUtil.degreeToRadian(this.__rot_y));
          rotateM_Y.rotateY(MathUtil.degreeToRadian(this.__rot_x));
          const rotateM = MutableMatrix33.multiplyTo(rotateM_Y, rotateM_X, _OrbitCameraController.__tmp_rotateM);
          rotateM.multiplyVectorTo(this.__upVec, newUpVec);
          rotateM.multiplyVectorTo(centerToEyeVec, newEyeVec).add(this.__centerVec);
          newCenterVec.copyComponents(this.__centerVec);
          const newEyeToCenterVec = _OrbitCameraController.__tmpVec3_1;
          MutableVector3.subtractTo(newCenterVec, newEyeVec, newEyeToCenterVec);
          MutableVector3.crossTo(newUpVec, newEyeToCenterVec, newTangentVec);
          newEyeVec.add(this.__mouseTranslateVec);
          newCenterVec.add(this.__mouseTranslateVec);
        }
      }
      __updateCameraComponent(camera) {
        const eyeDirection = _OrbitCameraController.__tmpVec3_0.copyComponents(this.__newCenterVec);
        eyeDirection.subtract(this.__newEyeVec).normalize();
        this._calcZNearInner(camera, this.__newEyeVec, eyeDirection);
        this._calcZFarInner(camera);
        const ratio = camera.zFar / camera.zNear;
        const minRatio = this.__scaleOfZNearAndZFar;
        const scale = ratio / minRatio;
        const newLeft = camera.left + scale;
        const newRight = camera.right + scale;
        const newTop = camera.top + scale;
        const newBottom = camera.bottom + scale;
        const fovy = this.__getFovyFromCamera(camera);
        this.__fovyBias = Math.tan(MathUtil.degreeToRadian(fovy / 2));
        camera.eyeInner = this.__newEyeVec;
        camera.directionInner = this.__newCenterVec;
        camera.upInner = this.__newUpVec;
        camera.leftInner = newLeft;
        camera.rightInner = newRight;
        camera.topInner = newTop;
        camera.bottomInner = newBottom;
        camera.fovyInner = fovy;
      }
      set scaleOfZNearAndZFar(value) {
        this.__scaleOfZNearAndZFar = value;
        this.__updated = false;
        this._updateCount();
      }
      get scaleOfZNearAndZFar() {
        return this.__scaleOfZNearAndZFar;
      }
      get isMouseDown() {
        return this.__isMouseDown;
      }
      get lastMouseDownTimeStamp() {
        return this.__lastMouseDownTimeStamp;
      }
      get lastMouseUpTimeStamp() {
        return this.__lastMouseUpTimeStamp;
      }
    };
    __name(_OrbitCameraController, "OrbitCameraController");
    __publicField(_OrbitCameraController, "__tmp_up", Vector3.fromCopyArray([
      0,
      0,
      1
    ]));
    __publicField(_OrbitCameraController, "__tmpVec3_0", MutableVector3.zero());
    __publicField(_OrbitCameraController, "__tmpVec3_1", MutableVector3.zero());
    __publicField(_OrbitCameraController, "__tmpVec3_2", MutableVector3.zero());
    __publicField(_OrbitCameraController, "__tmp_rotateM_X", MutableMatrix33.identity());
    __publicField(_OrbitCameraController, "__tmp_rotateM_Y", MutableMatrix33.identity());
    __publicField(_OrbitCameraController, "__tmp_rotateM", MutableMatrix33.identity());
    __publicField(_OrbitCameraController, "__tmp_rotateM_Reset", MutableMatrix33.identity());
    __publicField(_OrbitCameraController, "__tmp_rotateM_Revert", MutableMatrix33.identity());
    __publicField(_OrbitCameraController, "__tmpMat44_0", MutableMatrix44.identity());
    OrbitCameraController = _OrbitCameraController;
  }
});

// src/foundation/math/AbstractQuaternion.ts
var _AbstractQuaternion, AbstractQuaternion;
var init_AbstractQuaternion = __esm({
  "src/foundation/math/AbstractQuaternion.ts"() {
    "use strict";
    _AbstractQuaternion = class _AbstractQuaternion {
      constructor() {
        __publicField(this, "_v", new Float32Array());
      }
      get className() {
        return this.constructor.name;
      }
      get x() {
        return this._v[0];
      }
      get y() {
        return this._v[1];
      }
      get z() {
        return this._v[2];
      }
      get w() {
        return this._v[3];
      }
      at(i2) {
        return this._v[i2];
      }
      length() {
        return Math.hypot(this._v[0], this._v[1], this._v[2], this._v[3]);
      }
      lengthSquared() {
        return this._v[0] ** 2 + this._v[1] ** 2 + this._v[2] ** 2 + this._v[3] ** 2;
      }
      toString() {
        throw new Error("Method not implemented.");
      }
      toStringApproximately() {
        throw new Error("Method not implemented.");
      }
      flattenAsArray() {
        throw new Error("Method not implemented.");
      }
      isDummy() {
        throw new Error("Method not implemented.");
      }
      isEqual(vec, delta) {
        throw new Error("Method not implemented.");
      }
      isStrictEqual(vec) {
        throw new Error("Method not implemented.");
      }
      toEulerAnglesTo(out) {
        throw new Error("Method not implemented.");
      }
      toEulerAngles() {
        throw new Error("Method not implemented.");
      }
      transformVector3(vec) {
        throw new Error("Method not implemented.");
      }
      transformVector3To(vec, out) {
        throw new Error("Method not implemented.");
      }
      transformVector3Inverse(vec) {
        throw new Error("Method not implemented.");
      }
      /**
      * dot product
      */
      dot(quat) {
        return this._v[0] * quat._v[0] + this._v[1] * quat._v[1] + this._v[2] * quat._v[2] + this._v[3] * quat._v[3];
      }
      clone() {
        throw new Error("Method not implemented.");
      }
    };
    __name(_AbstractQuaternion, "AbstractQuaternion");
    AbstractQuaternion = _AbstractQuaternion;
  }
});

// src/foundation/math/Quaternion.ts
var _Quaternion, Quaternion;
var init_Quaternion = __esm({
  "src/foundation/math/Quaternion.ts"() {
    "use strict";
    init_MathUtil();
    init_CompositionType();
    init_AbstractQuaternion();
    init_Vector3();
    init_MutableVector3();
    init_MutableMatrix44();
    init_Logger();
    _Quaternion = class _Quaternion extends AbstractQuaternion {
      constructor(x) {
        super();
        this._v = x;
      }
      get className() {
        return "Quaternion";
      }
      static get compositionType() {
        return CompositionType.Vec4;
      }
      static identity() {
        return _Quaternion.fromCopy4(0, 0, 0, 1);
      }
      static dummy() {
        return new this(new Float32Array(0));
      }
      static invert(quat) {
        const norm = quat.length();
        if (norm === 0) {
          return _Quaternion.fromCopy4(0, 0, 0, 0);
        }
        const x = -quat._v[0] / norm;
        const y = -quat._v[1] / norm;
        const z = -quat._v[2] / norm;
        const w = quat._v[3] / norm;
        return _Quaternion.fromCopy4(x, y, z, w);
      }
      static invertTo(quat, out) {
        const norm = quat.length();
        if (norm === 0) {
          return out.setComponents(0, 0, 0, 0);
        }
        out._v[0] = -quat._v[0] / norm;
        out._v[1] = -quat._v[1] / norm;
        out._v[2] = -quat._v[2] / norm;
        out._v[3] = quat._v[3] / norm;
        return out;
      }
      /**
      * Compute spherical linear interpolation
      */
      static qlerp(l_quat, r_quat, ratio) {
        let dotProduct = l_quat._v[0] * r_quat._v[0] + l_quat._v[1] * r_quat._v[1] + l_quat._v[2] * r_quat._v[2] + l_quat._v[3] * r_quat._v[3];
        const ss = 1 - dotProduct * dotProduct;
        if (ss === 0) {
          return l_quat.clone();
        } else {
          if (dotProduct > 1) {
            dotProduct = 0.999;
          } else if (dotProduct < -1) {
            dotProduct = -0.999;
          }
          let theta = Math.acos(dotProduct);
          const sinTheta = Math.sin(theta);
          let s2;
          if (dotProduct < 0) {
            dotProduct *= -1;
            theta = Math.acos(dotProduct);
            s2 = -1 * Math.sin(theta * ratio) / sinTheta;
          } else {
            s2 = Math.sin(theta * ratio) / sinTheta;
          }
          const s1 = Math.sin(theta * (1 - ratio)) / sinTheta;
          let x = l_quat._v[0] * s1 + r_quat._v[0] * s2;
          let y = l_quat._v[1] * s1 + r_quat._v[1] * s2;
          let z = l_quat._v[2] * s1 + r_quat._v[2] * s2;
          let w = l_quat._v[3] * s1 + r_quat._v[3] * s2;
          const length = Math.hypot(x, y, z, w);
          x = x / length;
          y = y / length;
          z = z / length;
          w = w / length;
          return _Quaternion.fromCopy4(x, y, z, w);
        }
      }
      /**
      *  Compute the spherical linear interpolation and output it as the fourth argument
      */
      static qlerpTo(l_quat, r_quat, ratio, out) {
        let dotProduct = l_quat._v[0] * r_quat._v[0] + l_quat._v[1] * r_quat._v[1] + l_quat._v[2] * r_quat._v[2] + l_quat._v[3] * r_quat._v[3];
        const ss = 1 - dotProduct * dotProduct;
        if (ss === 0) {
          return out.copyComponents(l_quat);
        } else {
          if (dotProduct > 1) {
            dotProduct = 0.999;
          } else if (dotProduct < -1) {
            dotProduct = -0.999;
          }
          let theta = Math.acos(dotProduct);
          const sinTheta = Math.sin(theta);
          let s2;
          if (dotProduct < 0) {
            dotProduct *= -1;
            theta = Math.acos(dotProduct);
            s2 = -1 * Math.sin(theta * ratio) / sinTheta;
          } else {
            s2 = Math.sin(theta * ratio) / sinTheta;
          }
          const s1 = Math.sin(theta * (1 - ratio)) / sinTheta;
          out._v[0] = l_quat._v[0] * s1 + r_quat._v[0] * s2;
          out._v[1] = l_quat._v[1] * s1 + r_quat._v[1] * s2;
          out._v[2] = l_quat._v[2] * s1 + r_quat._v[2] * s2;
          out._v[3] = l_quat._v[3] * s1 + r_quat._v[3] * s2;
        }
        return out.normalize();
      }
      static lerp(l_quat, r_quat, ratio) {
        const x = l_quat._v[0] * (1 - ratio) + r_quat._v[0] * ratio;
        const y = l_quat._v[1] * (1 - ratio) + r_quat._v[1] * ratio;
        const z = l_quat._v[2] * (1 - ratio) + r_quat._v[2] * ratio;
        const w = l_quat._v[3] * (1 - ratio) + r_quat._v[3] * ratio;
        return _Quaternion.fromCopy4(x, y, z, w);
      }
      static lerpTo(l_quat, r_quat, ratio, out) {
        out._v[0] = l_quat._v[0] * (1 - ratio) + r_quat._v[0] * ratio;
        out._v[1] = l_quat._v[1] * (1 - ratio) + r_quat._v[1] * ratio;
        out._v[2] = l_quat._v[2] * (1 - ratio) + r_quat._v[2] * ratio;
        out._v[3] = l_quat._v[3] * (1 - ratio) + r_quat._v[3] * ratio;
        return out;
      }
      static axisAngle(vec, radian) {
        const halfAngle = 0.5 * radian;
        const sin = Math.sin(halfAngle);
        const length = vec.length();
        if (length === 0) {
          Logger.error("0 division occurred!");
        }
        return _Quaternion.fromCopy4(sin * vec._v[0] / length, sin * vec._v[1] / length, sin * vec._v[2] / length, Math.cos(halfAngle));
      }
      static fromMatrix(mat) {
        let sx = Math.hypot(mat.m00, mat.m10, mat.m20);
        const sy = Math.hypot(mat.m01, mat.m11, mat.m21);
        const sz = Math.hypot(mat.m02, mat.m12, mat.m22);
        const det = mat.determinant();
        if (det < 0) {
          sx = -sx;
        }
        const m = MutableMatrix44.fromCopyMatrix44(mat);
        const invSx = 1 / sx;
        const invSy = 1 / sy;
        const invSz = 1 / sz;
        m.m00 *= invSx;
        m.m10 *= invSx;
        m.m20 *= invSx;
        m.m01 *= invSy;
        m.m11 *= invSy;
        m.m21 *= invSy;
        m.m02 *= invSz;
        m.m12 *= invSz;
        m.m22 *= invSz;
        const trace = m.m00 + m.m11 + m.m22;
        if (trace > 0) {
          const S = 0.5 / Math.sqrt(trace + 1);
          const x = (m.m21 - m.m12) * S;
          const y = (m.m02 - m.m20) * S;
          const z = (m.m10 - m.m01) * S;
          const w = 0.25 / S;
          return _Quaternion.fromCopy4(x, y, z, w);
        } else if (m.m00 > m.m11 && m.m00 > m.m22) {
          const S = Math.sqrt(1 + m.m00 - m.m11 - m.m22) * 2;
          const x = 0.25 * S;
          const y = (m.m01 + m.m10) / S;
          const z = (m.m02 + m.m20) / S;
          const w = (m.m21 - m.m12) / S;
          return _Quaternion.fromCopy4(x, y, z, w);
        } else if (m.m11 > m.m22) {
          const S = Math.sqrt(1 + m.m11 - m.m00 - m.m22) * 2;
          const x = (m.m01 + m.m10) / S;
          const y = 0.25 * S;
          const z = (m.m12 + m.m21) / S;
          const w = (m.m02 - m.m20) / S;
          return _Quaternion.fromCopy4(x, y, z, w);
        } else {
          const S = Math.sqrt(1 + m.m22 - m.m00 - m.m11) * 2;
          const x = (m.m02 + m.m20) / S;
          const y = (m.m12 + m.m21) / S;
          const z = 0.25 * S;
          const w = (m.m10 - m.m01) / S;
          return _Quaternion.fromCopy4(x, y, z, w);
        }
      }
      static fromMatrixTo(mat, out) {
        let sx = Math.hypot(mat.m00, mat.m10, mat.m20);
        const sy = Math.hypot(mat.m01, mat.m11, mat.m21);
        const sz = Math.hypot(mat.m02, mat.m12, mat.m22);
        const det = mat.determinant();
        if (det < 0) {
          sx = -sx;
        }
        const m = MutableMatrix44.fromCopyMatrix44(mat);
        const invSx = 1 / sx;
        const invSy = 1 / sy;
        const invSz = 1 / sz;
        m.m00 *= invSx;
        m.m10 *= invSx;
        m.m20 *= invSx;
        m.m01 *= invSy;
        m.m11 *= invSy;
        m.m21 *= invSy;
        m.m02 *= invSz;
        m.m12 *= invSz;
        m.m22 *= invSz;
        const trace = m.m00 + m.m11 + m.m22;
        if (trace > 0) {
          const S = 0.5 / Math.sqrt(trace + 1);
          out._v[0] = (m.m21 - m.m12) * S;
          out._v[1] = (m.m02 - m.m20) * S;
          out._v[2] = (m.m10 - m.m01) * S;
          out._v[3] = 0.25 / S;
        } else if (m.m00 > m.m11 && m.m00 > m.m22) {
          const S = Math.sqrt(1 + m.m00 - m.m11 - m.m22) * 2;
          out._v[0] = 0.25 * S;
          out._v[1] = (m.m01 + m.m10) / S;
          out._v[2] = (m.m02 + m.m20) / S;
          out._v[3] = (m.m21 - m.m12) / S;
        } else if (m.m11 > m.m22) {
          const S = Math.sqrt(1 + m.m11 - m.m00 - m.m22) * 2;
          out._v[0] = (m.m01 + m.m10) / S;
          out._v[1] = 0.25 * S;
          out._v[2] = (m.m12 + m.m21) / S;
          out._v[3] = (m.m02 - m.m20) / S;
        } else {
          const S = Math.sqrt(1 + m.m22 - m.m00 - m.m11) * 2;
          out._v[0] = (m.m02 + m.m20) / S;
          out._v[1] = (m.m12 + m.m21) / S;
          out._v[2] = 0.25 * S;
          out._v[3] = (m.m10 - m.m01) / S;
        }
        return out;
      }
      static lookFromTo(fromDirection, toDirection) {
        if (fromDirection.isEqual(toDirection)) {
          return _Quaternion.fromCopy4(0, 0, 0, 1);
        }
        return this.qlerp(this.lookForward(fromDirection), this.lookForward(toDirection), 1);
      }
      static lookForward(forward) {
        if (_Quaternion.__tmp_upVec == null) {
          _Quaternion.__tmp_upVec = new forward.constructor(0, 1, 0);
        }
        return this.lookForwardAccordingToThisUp(forward, _Quaternion.__tmp_upVec);
      }
      static lookForwardAccordingToThisUp(forward, up) {
        const forwardLength = forward.length();
        if (forwardLength === 0) {
          Logger.error("0 division occurred!");
        }
        const forwardX = forward._v[0] / forwardLength;
        const forwardY = forward._v[1] / forwardLength;
        const forwardZ = forward._v[2] / forwardLength;
        const upLength = up.length();
        if (upLength === 0) {
          Logger.error("0 division occurred!");
        }
        const upX = up._v[0] / upLength;
        const upY = up._v[1] / upLength;
        const upZ = up._v[2] / upLength;
        let rightX = up._v[1] * forward._v[2] - up._v[2] * forward._v[1];
        let rightY = up._v[2] * forward._v[0] - up._v[0] * forward._v[2];
        let rightZ = up._v[0] * forward._v[1] - up._v[1] * forward._v[0];
        const rightLength = Math.hypot(rightX, rightY, rightZ);
        if (rightLength === 0) {
          Logger.error("0 division occurred!");
        }
        rightX /= rightLength;
        rightY /= rightLength;
        rightZ /= rightLength;
        const m00 = rightX;
        const m01 = rightY;
        const m02 = rightZ;
        const m10 = upX;
        const m11 = upY;
        const m12 = upZ;
        const m20 = forwardX;
        const m21 = forwardY;
        const m22 = forwardZ;
        const num8 = m00 + m11 + m22;
        if (num8 > 0) {
          const num = Math.sqrt(num8 + 1);
          const num2 = 0.5 / num;
          return _Quaternion.fromCopy4((m12 - m21) * num2, (m20 - m02) * num2, (m01 - m10) * num2, num * 0.5);
        } else if (m00 >= m11 && m00 >= m22) {
          const num7 = Math.sqrt(1 + m00 - m11 - m22);
          const num4 = 0.5 / num7;
          return _Quaternion.fromCopy4(0.5 * num7, (m01 + m10) * num4, (m02 + m20) * num4, (m12 - m21) * num4);
        } else if (m11 > m22) {
          const num6 = Math.sqrt(1 + m11 - m00 - m22);
          const num3 = 0.5 / num6;
          return _Quaternion.fromCopy4((m10 + m01) * num3, 0.5 * num6, (m21 + m12) * num3, (m20 - m02) * num3);
        } else {
          const num5 = Math.sqrt(1 + m22 - m00 - m11);
          const num2 = 0.5 / num5;
          return _Quaternion.fromCopy4((m20 + m02) * num2, (m21 + m12) * num2, 0.5 * num5, (m01 - m10) * num2);
        }
      }
      static fromPosition(vec) {
        return _Quaternion.fromCopy4(vec._v[0], vec._v[1], vec._v[2], 0);
      }
      static add(l_quat, r_quat) {
        const x = l_quat._v[0] + r_quat._v[0];
        const y = l_quat._v[1] + r_quat._v[1];
        const z = l_quat._v[2] + r_quat._v[2];
        const w = l_quat._v[3] + r_quat._v[3];
        return _Quaternion.fromCopy4(x, y, z, w);
      }
      static addTo(l_quat, r_quat, out) {
        out._v[0] = l_quat._v[0] + r_quat._v[0];
        out._v[1] = l_quat._v[1] + r_quat._v[1];
        out._v[2] = l_quat._v[2] + r_quat._v[2];
        out._v[3] = l_quat._v[3] + r_quat._v[3];
        return out;
      }
      static subtract(l_quat, r_quat) {
        const x = l_quat._v[0] - r_quat._v[0];
        const y = l_quat._v[1] - r_quat._v[1];
        const z = l_quat._v[2] - r_quat._v[2];
        const w = l_quat._v[3] - r_quat._v[3];
        return _Quaternion.fromCopy4(x, y, z, w);
      }
      static subtractTo(l_quat, r_quat, out) {
        out._v[0] = l_quat._v[0] - r_quat._v[0];
        out._v[1] = l_quat._v[1] - r_quat._v[1];
        out._v[2] = l_quat._v[2] - r_quat._v[2];
        out._v[3] = l_quat._v[3] - r_quat._v[3];
        return out;
      }
      static multiply(l_quat, r_quat) {
        const x = r_quat._v[3] * l_quat._v[0] + r_quat._v[2] * l_quat._v[1] - r_quat._v[1] * l_quat._v[2] + r_quat._v[0] * l_quat._v[3];
        const y = -r_quat._v[2] * l_quat._v[0] + r_quat._v[3] * l_quat._v[1] + r_quat._v[0] * l_quat._v[2] + r_quat._v[1] * l_quat._v[3];
        const z = r_quat._v[1] * l_quat._v[0] - r_quat._v[0] * l_quat._v[1] + r_quat._v[3] * l_quat._v[2] + r_quat._v[2] * l_quat._v[3];
        const w = -r_quat._v[0] * l_quat._v[0] - r_quat._v[1] * l_quat._v[1] - r_quat._v[2] * l_quat._v[2] + r_quat._v[3] * l_quat._v[3];
        return _Quaternion.fromCopy4(x, y, z, w);
      }
      static multiplyTo(l_quat, r_quat, out) {
        const x = r_quat._v[3] * l_quat._v[0] + r_quat._v[2] * l_quat._v[1] - r_quat._v[1] * l_quat._v[2] + r_quat._v[0] * l_quat._v[3];
        const y = -r_quat._v[2] * l_quat._v[0] + r_quat._v[3] * l_quat._v[1] + r_quat._v[0] * l_quat._v[2] + r_quat._v[1] * l_quat._v[3];
        const z = r_quat._v[1] * l_quat._v[0] - r_quat._v[0] * l_quat._v[1] + r_quat._v[3] * l_quat._v[2] + r_quat._v[2] * l_quat._v[3];
        const w = -r_quat._v[0] * l_quat._v[0] - r_quat._v[1] * l_quat._v[1] - r_quat._v[2] * l_quat._v[2] + r_quat._v[3] * l_quat._v[3];
        return out.setComponents(x, y, z, w);
      }
      static multiplyNumber(quat, value) {
        const x = quat._v[0] * value;
        const y = quat._v[1] * value;
        const z = quat._v[2] * value;
        const w = quat._v[3] * value;
        return _Quaternion.fromCopy4(x, y, z, w);
      }
      static multiplyNumberTo(quat, value, out) {
        out._v[0] = quat._v[0] * value;
        out._v[1] = quat._v[1] * value;
        out._v[2] = quat._v[2] * value;
        out._v[3] = quat._v[3] * value;
        return out;
      }
      static divideNumber(quat, value) {
        if (value === 0) {
          Logger.error("0 division occurred!");
        }
        const x = quat._v[0] / value;
        const y = quat._v[1] / value;
        const z = quat._v[2] / value;
        const w = quat._v[3] / value;
        return _Quaternion.fromCopy4(x, y, z, w);
      }
      static divideNumberTo(quat, value, out) {
        if (value === 0) {
          Logger.error("0 division occurred!");
        }
        out._v[0] = quat._v[0] / value;
        out._v[1] = quat._v[1] / value;
        out._v[2] = quat._v[2] / value;
        out._v[3] = quat._v[3] / value;
        return out;
      }
      toString() {
        return "(" + this._v[0] + ", " + this._v[1] + ", " + this._v[2] + ", " + this._v[3] + ")";
      }
      toStringApproximately() {
        return MathUtil.financial(this._v[0]) + " " + MathUtil.financial(this._v[1]) + " " + MathUtil.financial(this._v[2]) + " " + MathUtil.financial(this._v[3]) + "\n";
      }
      flattenAsArray() {
        return [
          this._v[0],
          this._v[1],
          this._v[2],
          this._v[3]
        ];
      }
      isDummy() {
        if (this._v.length === 0) {
          return true;
        } else {
          return false;
        }
      }
      isEqual(quat, delta = Number.EPSILON) {
        if (Math.abs(quat._v[0] - this._v[0]) < delta && Math.abs(quat._v[1] - this._v[1]) < delta && Math.abs(quat._v[2] - this._v[2]) < delta && Math.abs(quat._v[3] - this._v[3]) < delta) {
          return true;
        } else {
          return false;
        }
      }
      isStrictEqual(quat) {
        if (this._v[0] === quat._v[0] && this._v[1] === quat._v[1] && this._v[2] === quat._v[2] && this._v[3] === quat._v[3]) {
          return true;
        } else {
          return false;
        }
      }
      toEulerAnglesTo(out) {
        const t0 = 2 * (this._v[3] * this._v[0] + this._v[1] * this._v[2]);
        const t1 = 1 - 2 * (this._v[0] * this._v[0] + this._v[1] * this._v[1]);
        out._v[0] = Math.atan2(t0, t1);
        let t2 = 2 * (this._v[3] * this._v[1] - this._v[2] * this._v[0]);
        t2 = t2 > 1 ? 1 : t2;
        t2 = t2 < -1 ? -1 : t2;
        out._v[1] = Math.asin(t2);
        const t3 = 2 * (this._v[3] * this._v[2] + this._v[0] * this._v[1]);
        const t4 = 1 - 2 * (this._v[1] * this._v[1] + this._v[2] * this._v[2]);
        out._v[2] = Math.atan2(t3, t4);
        return out;
      }
      toEulerAngles() {
        const out = new Vector3(new Float32Array(3));
        const t0 = 2 * (this._v[3] * this._v[0] + this._v[1] * this._v[2]);
        const t1 = 1 - 2 * (this._v[0] * this._v[0] + this._v[1] * this._v[1]);
        out._v[0] = Math.atan2(t0, t1);
        let t2 = 2 * (this._v[3] * this._v[1] - this._v[2] * this._v[0]);
        t2 = t2 > 1 ? 1 : t2;
        t2 = t2 < -1 ? -1 : t2;
        out._v[1] = Math.asin(t2);
        const t3 = 2 * (this._v[3] * this._v[2] + this._v[0] * this._v[1]);
        const t4 = 1 - 2 * (this._v[1] * this._v[1] + this._v[2] * this._v[2]);
        out._v[2] = Math.atan2(t3, t4);
        return out;
      }
      /**
      * divide(static version)
      */
      static _divide(vec, value) {
        let x;
        let y;
        let z;
        let w;
        if (value !== 0) {
          x = vec._v[0] / value;
          y = vec._v[1] / value;
          z = vec._v[2] / value;
          w = vec._v[3] / value;
        } else {
          Logger.error("0 division occurred!");
          x = Infinity;
          y = Infinity;
          z = Infinity;
          w = Infinity;
        }
        return _Quaternion.fromCopy4(x, y, z, w);
      }
      /**
      * divide(static version)
      */
      static _divideTo(vec, value, out) {
        let x;
        let y;
        let z;
        let w;
        if (value !== 0) {
          x = vec._v[0] / value;
          y = vec._v[1] / value;
          z = vec._v[2] / value;
          w = vec._v[3] / value;
        } else {
          Logger.error("0 division occurred!");
          x = Infinity;
          y = Infinity;
          z = Infinity;
          w = Infinity;
        }
        out._v[0] = x;
        out._v[1] = y;
        out._v[2] = z;
        out._v[3] = w;
        return out;
      }
      /**
      * normalize(static version)
      */
      static normalize(vec) {
        const length = vec.length();
        return this._divide(vec, length);
      }
      /**
      * normalize(static version)
      */
      static normalizeTo(vec, out) {
        const length = vec.length();
        return this._divideTo(vec, length, out);
      }
      fromToRotation(from32, to) {
        const v0 = MutableVector3.fromCopyVector3(from32);
        const v1 = MutableVector3.fromCopyVector3(to);
        v0.normalize();
        v1.normalize();
        const d = v0.dot(v1);
        if (d > -1 + Number.EPSILON) {
          const s2 = Math.sqrt((1 + d) * 2);
          const invs = 1 / s2;
          const c2 = Vector3.multiply(v0.cross(v1), invs);
          this._v[0] = c2.x;
          this._v[1] = c2.y;
          this._v[2] = c2.z;
          this._v[3] = s2 * 0.5;
          return _Quaternion.normalize(this);
        } else {
          let axis = Vector3.fromCopy3(0, 1, 0);
          let axis2 = v0.cross(axis);
          if (axis2.length() < Number.EPSILON) {
            axis = Vector3.fromCopy3(1, 0, 0);
            axis2 = v0.cross(axis);
          }
          axis2.normalize();
          return _Quaternion.fromAxisAngle(axis2, Math.PI);
        }
      }
      static fromToRotation(from32, to) {
        let r2 = Vector3.dot(from32, to) + 1;
        if (r2 < Number.EPSILON) {
          r2 = 0;
          if (Math.abs(from32.x) > Math.abs(from32.z)) {
            const q = _Quaternion.fromCopy4(-from32.y, from32.x, 0, r2);
            return _Quaternion.normalize(q);
          } else {
            const q = _Quaternion.fromCopy4(0, -from32.z, from32.y, r2);
            return _Quaternion.normalize(q);
          }
        } else {
          const q = _Quaternion.fromCopy4(from32.y * to.z - from32.z * to.y, from32.z * to.x - from32.x * to.z, from32.x * to.y - from32.y * to.x, r2);
          return _Quaternion.normalize(q);
        }
      }
      static fromToRotationTo(from32, to, out) {
        let r2 = Vector3.dot(from32, to) + 1;
        if (r2 < Number.EPSILON) {
          r2 = 0;
          if (Math.abs(from32.x) > Math.abs(from32.z)) {
            out._v[0] = -from32.y;
            out._v[1] = from32.x;
            out._v[2] = 0;
            out._v[3] = r2;
            out.normalize();
            return out;
          } else {
            out._v[0] = 0;
            out._v[1] = -from32.z;
            out._v[2] = from32.y;
            out._v[3] = r2;
            out.normalize();
            return out;
          }
        } else {
          out._v[0] = from32.y * to.z - from32.z * to.y;
          out._v[1] = from32.z * to.x - from32.x * to.z;
          out._v[2] = from32.x * to.y - from32.y * to.x;
          out._v[3] = r2;
          out.normalize();
          return out;
        }
      }
      transformVector3(v) {
        const u = _Quaternion.__tmp_vec3_5;
        u.setComponents(this._v[0], this._v[1], this._v[2]);
        const uv = Vector3.cross(u, v);
        const uuv = Vector3.cross(u, uv);
        const uvw = Vector3.multiply(uv, this._v[3]);
        const uuv_uvw = Vector3.add(uuv, uvw);
        const uuv_uvw_2 = Vector3.multiply(uuv_uvw, 2);
        return Vector3.add(v, uuv_uvw_2);
      }
      transformVector3To(v, out) {
        const u = _Quaternion.__tmp_vec3_5;
        u.setComponents(this._v[0], this._v[1], this._v[2]);
        const uv = Vector3.crossTo(u, v, _Quaternion.__tmp_vec3_0);
        const uuv = Vector3.crossTo(u, uv, _Quaternion.__tmp_vec3_1);
        const uvw = Vector3.multiplyTo(uv, this._v[3], _Quaternion.__tmp_vec3_2);
        const uuv_uvw = Vector3.addTo(uuv, uvw, _Quaternion.__tmp_vec3_3);
        const uuv_uvw_2 = Vector3.multiplyTo(uuv_uvw, 2, _Quaternion.__tmp_vec3_4);
        return Vector3.addTo(v, uuv_uvw_2, out);
      }
      transformVector3Inverse(v) {
        const inv = _Quaternion.invert(this);
        return inv.transformVector3(v);
      }
      clone() {
        return _Quaternion.fromCopy4(this._v[0], this._v[1], this._v[2], this._v[3]);
      }
      static fromFloat32Array(array) {
        return new _Quaternion(array);
      }
      static fromCopyArray4(array) {
        return new _Quaternion(new Float32Array(array));
      }
      static fromCopyArray(array) {
        return new _Quaternion(new Float32Array(array.slice(0, 4)));
      }
      static fromCopy4(x, y, z, w) {
        return new _Quaternion(new Float32Array([
          x,
          y,
          z,
          w
        ]));
      }
      static fromCopyQuaternion(quat) {
        const v = new Float32Array(4);
        v[0] = quat._v[0];
        v[1] = quat._v[1];
        v[2] = quat._v[2];
        v[3] = quat._v[3];
        return new _Quaternion(v);
      }
      static fromCopyVector4(vec) {
        const v = new Float32Array(4);
        v[0] = vec._v[0];
        v[1] = vec._v[1];
        v[2] = vec._v[2];
        v[3] = vec._v[3];
        return new _Quaternion(v);
      }
      static fromCopyLogQuaternion(x) {
        const theta = x._v[0] * x._v[0] + x._v[1] * x._v[1] + x._v[2] * x._v[2];
        const sin = Math.sin(theta);
        const v = new Float32Array(4);
        v[0] = x._v[0] * (sin / theta);
        v[1] = x._v[1] * (sin / theta);
        v[2] = x._v[2] * (sin / theta);
        v[3] = Math.cos(theta);
        return new _Quaternion(v);
      }
      static fromAxisAngle(axis, rad) {
        rad = rad * 0.5;
        const s2 = Math.sin(rad);
        return _Quaternion.fromCopy4(s2 * axis.x, s2 * axis.y, s2 * axis.z, Math.cos(rad));
      }
      static fromAxisAngleTo(axis, rad, out) {
        rad = rad * 0.5;
        const s2 = Math.sin(rad);
        out._v[0] = s2 * axis.x;
        out._v[1] = s2 * axis.y;
        out._v[2] = s2 * axis.z;
        out._v[3] = Math.cos(rad);
        return out;
      }
      // Returns the rotation angle (0~π) of quaternion q
      static getQuaternionAngle(q) {
        const wClamped = Math.max(-1, Math.min(1, q.w));
        return 2 * Math.acos(wClamped);
      }
      static clampRotation(quat, thetaMax) {
        const theta = _Quaternion.getQuaternionAngle(quat);
        if (theta <= thetaMax) {
          return quat;
        } else {
          const t2 = thetaMax / theta;
          const qIdentity = _Quaternion.fromCopy4(0, 0, 0, 1);
          return _Quaternion.qlerp(qIdentity, quat, t2);
        }
      }
    };
    __name(_Quaternion, "Quaternion");
    __publicField(_Quaternion, "__tmp_upVec");
    __publicField(_Quaternion, "__tmp_vec3_0", MutableVector3.zero());
    __publicField(_Quaternion, "__tmp_vec3_1", MutableVector3.zero());
    __publicField(_Quaternion, "__tmp_vec3_2", MutableVector3.zero());
    __publicField(_Quaternion, "__tmp_vec3_3", MutableVector3.zero());
    __publicField(_Quaternion, "__tmp_vec3_4", MutableVector3.zero());
    __publicField(_Quaternion, "__tmp_vec3_5", MutableVector3.zero());
    Quaternion = _Quaternion;
  }
});

// src/foundation/math/MutableVector4.ts
var _MutableVector4_, MutableVector4_, _MutableVector4, MutableVector4, _MutableVector4d, MutableVector4d;
var init_MutableVector4 = __esm({
  "src/foundation/math/MutableVector4.ts"() {
    "use strict";
    init_Vector4();
    init_Logger();
    _MutableVector4_ = class _MutableVector4_ extends Vector4_ {
      constructor(x, { type }) {
        super(x, {
          type
        });
        __publicField(this, "__updateCount", 0);
      }
      set x(x) {
        this._v[0] = x;
        this.__updateCount++;
      }
      get x() {
        return this._v[0];
      }
      set y(y) {
        this._v[1] = y;
        this.__updateCount++;
      }
      get y() {
        return this._v[1];
      }
      set z(z) {
        this._v[2] = z;
        this.__updateCount++;
      }
      get z() {
        return this._v[2];
      }
      set w(w) {
        this._v[3] = w;
        this.__updateCount++;
      }
      get w() {
        return this._v[3];
      }
      raw() {
        return this._v;
      }
      setAt(i2, value) {
        this._v[i2] = value;
        this.__updateCount++;
        return this;
      }
      setComponents(x, y, z, w) {
        this._v[0] = x;
        this._v[1] = y;
        this._v[2] = z;
        this._v[3] = w;
        this.__updateCount++;
        return this;
      }
      copyComponents(vec) {
        return this.setComponents(vec._v[0], vec._v[1], vec._v[2], vec._v[3]);
      }
      zero() {
        return this.setComponents(0, 0, 0, 0);
      }
      one() {
        return this.setComponents(1, 1, 1, 1);
      }
      get bytesPerComponent() {
        return this._v.BYTES_PER_ELEMENT;
      }
      /**
      * normalize
      */
      normalize() {
        const length = this.length();
        this.divide(length);
        return this;
      }
      normalize3() {
        const length = Math.hypot(this._v[0], this._v[1], this._v[2]);
        this.divide(length);
        return this;
      }
      /**
      * add value
      */
      add(vec) {
        this._v[0] += vec._v[0];
        this._v[1] += vec._v[1];
        this._v[2] += vec._v[2];
        this._v[3] += vec._v[3];
        return this;
      }
      /**
      * subtract
      */
      subtract(vec) {
        this._v[0] -= vec._v[0];
        this._v[1] -= vec._v[1];
        this._v[2] -= vec._v[2];
        this._v[3] -= vec._v[3];
        return this;
      }
      /**
      * multiply
      */
      multiply(value) {
        this._v[0] *= value;
        this._v[1] *= value;
        this._v[2] *= value;
        this._v[3] *= value;
        return this;
      }
      /**
      * multiply vector
      */
      multiplyVector(vec) {
        this._v[0] *= vec._v[0];
        this._v[1] *= vec._v[1];
        this._v[2] *= vec._v[2];
        this._v[3] *= vec._v[3];
        return this;
      }
      /**
      * divide
      */
      divide(value) {
        if (value !== 0) {
          this._v[0] /= value;
          this._v[1] /= value;
          this._v[2] /= value;
          this._v[3] /= value;
        } else {
          Logger.error("0 division occurred!");
          this._v[0] = Infinity;
          this._v[1] = Infinity;
          this._v[2] = Infinity;
          this._v[3] = Infinity;
        }
        return this;
      }
      /**
      * divide vector
      */
      divideVector(vec) {
        if (vec._v[0] !== 0 && vec._v[1] !== 0 && vec._v[2] !== 0 && vec._v[3] !== 0) {
          this._v[0] /= vec._v[0];
          this._v[1] /= vec._v[1];
          this._v[2] /= vec._v[2];
          this._v[3] /= vec._v[3];
        } else {
          Logger.error("0 division occurred!");
          this._v[0] = vec._v[0] === 0 ? Infinity : this._v[0] / vec._v[0];
          this._v[1] = vec._v[1] === 0 ? Infinity : this._v[1] / vec._v[1];
          this._v[2] = vec._v[2] === 0 ? Infinity : this._v[2] / vec._v[2];
          this._v[3] = vec._v[3] === 0 ? Infinity : this._v[3] / vec._v[3];
        }
        return this;
      }
      get _updateCount() {
        return this.__updateCount;
      }
    };
    __name(_MutableVector4_, "MutableVector4_");
    MutableVector4_ = _MutableVector4_;
    _MutableVector4 = class _MutableVector4 extends MutableVector4_ {
      constructor(x) {
        super(x, {
          type: Float32Array
        });
      }
      static fromCopyArray(array) {
        return new _MutableVector4(new Float32Array(array).slice(0, 4));
      }
      static fromCopyArray4(array) {
        return new _MutableVector4(new Float32Array(array));
      }
      static fromCopy4(x, y, z, w) {
        return new _MutableVector4(new Float32Array([
          x,
          y,
          z,
          w
        ]));
      }
      static zero() {
        return super._zero(Float32Array);
      }
      static one() {
        return super._one(Float32Array);
      }
      static dummy() {
        return super._dummy(Float32Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float32Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
      }
      get className() {
        return "MutableVector4";
      }
      clone() {
        return new this.constructor(new this._v.constructor([
          this._v[0],
          this._v[1],
          this._v[2],
          this._v[3]
        ]));
      }
    };
    __name(_MutableVector4, "MutableVector4");
    MutableVector4 = _MutableVector4;
    _MutableVector4d = class _MutableVector4d extends MutableVector4_ {
      constructor(x) {
        super(x, {
          type: Float64Array
        });
      }
      static zero() {
        return super._zero(Float64Array);
      }
      static one() {
        return super._one(Float64Array);
      }
      static dummy() {
        return super._dummy(Float64Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float64Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float64Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float64Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float64Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float64Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float64Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float64Array);
      }
      static fromCopyArray4(array) {
        return new _MutableVector4d(new Float64Array(array));
      }
      static fromCopyArray(array) {
        return new _MutableVector4d(new Float64Array(array.slice(0, 4)));
      }
      static fromCopy4(x, y, z, w) {
        return new _MutableVector4d(new Float64Array([
          x,
          y,
          z,
          w
        ]));
      }
      clone() {
        return super.clone();
      }
    };
    __name(_MutableVector4d, "MutableVector4d");
    MutableVector4d = _MutableVector4d;
  }
});

// src/foundation/math/Scalar.ts
var _Scalar_, Scalar_, _Scalar, Scalar2, _Scalard, Scalard;
var init_Scalar = __esm({
  "src/foundation/math/Scalar.ts"() {
    "use strict";
    init_MathUtil();
    init_AbstractVector();
    init_CompositionType();
    _Scalar_ = class _Scalar_ extends AbstractVector {
      constructor(v, { type }) {
        super();
        this._v = v;
      }
      getValue() {
        return this._v[0];
      }
      getValueInArray() {
        return [
          this._v[0]
        ];
      }
      get x() {
        return this._v[0];
      }
      get raw() {
        return this._v;
      }
      isStrictEqual(scalar) {
        if (this.x === scalar.x) {
          return true;
        } else {
          return false;
        }
      }
      isEqual(scalar, delta = Number.EPSILON) {
        if (Math.abs(scalar.x - this.x) < delta) {
          return true;
        } else {
          return false;
        }
      }
      get glslStrAsFloat() {
        return `${MathUtil.convertToStringAsGLSLFloat(this.x)}`;
      }
      get glslStrAsInt() {
        return `${Math.floor(this.x)}`;
      }
      static _fromCopyNumber(value, type) {
        return new this(new type([
          value
        ]), {
          type
        });
      }
      static _dummy(type) {
        return new this(new type(), {
          type
        });
      }
      static get compositionType() {
        return CompositionType.Scalar;
      }
      get bytesPerComponent() {
        return this._v.BYTES_PER_ELEMENT;
      }
    };
    __name(_Scalar_, "Scalar_");
    Scalar_ = _Scalar_;
    _Scalar = class _Scalar extends Scalar_ {
      constructor(x) {
        super(x, {
          type: Float32Array
        });
      }
      static fromCopyNumber(value) {
        return super._fromCopyNumber(value, Float32Array);
      }
      static zero() {
        return _Scalar.fromCopyNumber(0);
      }
      static one() {
        return _Scalar.fromCopyNumber(1);
      }
      static dummy() {
        return super._dummy(Float32Array);
      }
      get className() {
        return "Scalar";
      }
      /**
      * change to string
      */
      toString() {
        return "(" + this._v[0] + ")";
      }
      clone() {
        return new _Scalar(this._v);
      }
    };
    __name(_Scalar, "Scalar");
    Scalar2 = _Scalar;
    _Scalard = class _Scalard extends Scalar_ {
      constructor(x) {
        super(x, {
          type: Float64Array
        });
      }
      static fromCopyNumber(value) {
        return super._fromCopyNumber(value, Float64Array);
      }
      static zero() {
        return _Scalard.fromCopyNumber(0);
      }
      static one() {
        return _Scalard.fromCopyNumber(1);
      }
      static dummy() {
        return super._dummy(Float64Array);
      }
      clone() {
        return new _Scalard(this._v);
      }
    };
    __name(_Scalard, "Scalard");
    Scalard = _Scalard;
  }
});

// src/foundation/math/MutableQuaternion.ts
var _MutableQuaternion, MutableQuaternion;
var init_MutableQuaternion = __esm({
  "src/foundation/math/MutableQuaternion.ts"() {
    "use strict";
    init_Quaternion();
    init_MutableMatrix44();
    init_Logger();
    _MutableQuaternion = class _MutableQuaternion extends Quaternion {
      constructor(x) {
        super(x);
      }
      set x(x) {
        this._v[0] = x;
      }
      get x() {
        return this._v[0];
      }
      set y(y) {
        this._v[1] = y;
      }
      get y() {
        return this._v[1];
      }
      set z(z) {
        this._v[2] = z;
      }
      get z() {
        return this._v[2];
      }
      set w(w) {
        this._v[3] = w;
      }
      get w() {
        return this._v[3];
      }
      get className() {
        return "MutableQuaternion";
      }
      static identity() {
        return _MutableQuaternion.fromCopy4(0, 0, 0, 1);
      }
      static dummy() {
        return new this(new Float32Array(0));
      }
      static invert(quat) {
        return super.invert(quat);
      }
      static qlerp(l_quat, r_quat, ratio) {
        return super.qlerp(l_quat, r_quat, ratio);
      }
      static lerp(l_quat, r_quat, ratio) {
        return super.lerp(l_quat, r_quat, ratio);
      }
      static axisAngle(vec, radian) {
        return super.axisAngle(vec, radian);
      }
      static fromMatrix(mat) {
        return super.fromMatrix(mat);
      }
      static fromPosition(vec) {
        return super.fromPosition(vec);
      }
      static add(l_quat, r_quat) {
        return super.add(l_quat, r_quat);
      }
      static subtract(l_quat, r_quat) {
        return super.subtract(l_quat, r_quat);
      }
      static multiply(l_quat, r_quat) {
        return super.multiply(l_quat, r_quat);
      }
      static multiplyNumber(quat, value) {
        return super.multiplyNumber(quat, value);
      }
      static divideNumber(quat, value) {
        return super.divideNumber(quat, value);
      }
      raw() {
        return this._v;
      }
      setAt(i2, value) {
        this._v[i2] = value;
        return this;
      }
      setComponents(x, y, z, w) {
        this._v[0] = x;
        this._v[1] = y;
        this._v[2] = z;
        this._v[3] = w;
        return this;
      }
      copyComponents(quat) {
        return this.setComponents(quat._v[0], quat._v[1], quat._v[2], quat._v[3]);
      }
      identity() {
        return this.setComponents(0, 0, 0, 1);
      }
      normalize() {
        const norm = this.length();
        return this.divideNumber(norm);
      }
      invert() {
        const norm = this.length();
        if (norm === 0) {
          return this;
        }
        this._v[0] = -this._v[0] / norm;
        this._v[1] = -this._v[1] / norm;
        this._v[2] = -this._v[2] / norm;
        this._v[3] = this._v[3] / norm;
        return this;
      }
      qlerp(l_quat, r_quat, ratio) {
        let qr = l_quat._v[3] * r_quat._v[3] + l_quat._v[0] * r_quat._v[0] + l_quat._v[1] * r_quat._v[1] + l_quat._v[2] * r_quat._v[2];
        const ss = 1 - qr * qr;
        if (ss === 0) {
          return this.copyComponents(l_quat);
        } else {
          if (qr > 1) {
            qr = 0.999;
          } else if (qr < -1) {
            qr = -0.999;
          }
          let ph = Math.acos(qr);
          let s2;
          if (qr < 0 && ph > Math.PI / 2) {
            qr = -l_quat._v[3] * r_quat._v[3] - l_quat._v[0] * r_quat._v[0] - l_quat._v[1] * r_quat._v[1] - l_quat._v[2] * r_quat._v[2];
            ph = Math.acos(qr);
            s2 = -1 * Math.sin(ph * ratio) / Math.sin(ph);
          } else {
            s2 = Math.sin(ph * ratio) / Math.sin(ph);
          }
          const s1 = Math.sin(ph * (1 - ratio)) / Math.sin(ph);
          this._v[0] = l_quat._v[0] * s1 + r_quat._v[0] * s2;
          this._v[1] = l_quat._v[1] * s1 + r_quat._v[1] * s2;
          this._v[2] = l_quat._v[2] * s1 + r_quat._v[2] * s2;
          this._v[3] = l_quat._v[3] * s1 + r_quat._v[3] * s2;
        }
        return this;
      }
      lerp(l_quat, r_quat, ratio) {
        this._v[0] = l_quat._v[0] * (1 - ratio) + r_quat._v[0] * ratio;
        this._v[1] = l_quat._v[1] * (1 - ratio) + r_quat._v[1] * ratio;
        this._v[2] = l_quat._v[2] * (1 - ratio) + r_quat._v[2] * ratio;
        this._v[3] = l_quat._v[3] * (1 - ratio) + r_quat._v[3] * ratio;
        return this;
      }
      axisAngle(vec, radian) {
        const halfAngle = 0.5 * radian;
        const sin = Math.sin(halfAngle);
        const length = vec.length();
        if (length === 0) {
          Logger.error("0 division occurred!");
        }
        this._v[3] = Math.cos(halfAngle);
        this._v[0] = sin * vec._v[0] / length;
        this._v[1] = sin * vec._v[1] / length;
        this._v[2] = sin * vec._v[2] / length;
        return this;
      }
      fromMatrix(mat) {
        let sx = Math.hypot(mat.m00, mat.m10, mat.m20);
        const sy = Math.hypot(mat.m01, mat.m11, mat.m21);
        const sz = Math.hypot(mat.m02, mat.m12, mat.m22);
        const det = mat.determinant();
        if (det < 0) {
          sx = -sx;
        }
        const m = MutableMatrix44.fromCopyMatrix44(mat);
        const invSx = 1 / sx;
        const invSy = 1 / sy;
        const invSz = 1 / sz;
        m.m00 *= invSx;
        m.m10 *= invSx;
        m.m20 *= invSx;
        m.m01 *= invSy;
        m.m11 *= invSy;
        m.m21 *= invSy;
        m.m02 *= invSz;
        m.m12 *= invSz;
        m.m22 *= invSz;
        const trace = m.m00 + m.m11 + m.m22;
        if (trace > 0) {
          const S = 0.5 / Math.sqrt(trace + 1);
          this._v[0] = (m.m21 - m.m12) * S;
          this._v[1] = (m.m02 - m.m20) * S;
          this._v[2] = (m.m10 - m.m01) * S;
          this._v[3] = 0.25 / S;
        } else if (m.m00 > m.m11 && m.m00 > m.m22) {
          const S = Math.sqrt(1 + m.m00 - m.m11 - m.m22) * 2;
          this._v[0] = 0.25 * S;
          this._v[1] = (m.m01 + m.m10) / S;
          this._v[2] = (m.m02 + m.m20) / S;
          this._v[3] = (m.m21 - m.m12) / S;
        } else if (m.m11 > m.m22) {
          const S = Math.sqrt(1 + m.m11 - m.m00 - m.m22) * 2;
          this._v[0] = (m.m01 + m.m10) / S;
          this._v[1] = 0.25 * S;
          this._v[2] = (m.m12 + m.m21) / S;
          this._v[3] = (m.m02 - m.m20) / S;
        } else {
          const S = Math.sqrt(1 + m.m22 - m.m00 - m.m11) * 2;
          this._v[0] = (m.m02 + m.m20) / S;
          this._v[1] = (m.m12 + m.m21) / S;
          this._v[2] = 0.25 * S;
          this._v[3] = (m.m10 - m.m01) / S;
        }
        return this;
      }
      fromPosition(vec) {
        return this.setComponents(vec._v[0], vec._v[1], vec._v[2], 0);
      }
      add(quat) {
        this._v[0] += quat._v[0];
        this._v[1] += quat._v[1];
        this._v[2] += quat._v[2];
        this._v[3] += quat._v[3];
        return this;
      }
      subtract(quat) {
        this._v[0] -= quat._v[0];
        this._v[1] -= quat._v[1];
        this._v[2] -= quat._v[2];
        this._v[3] -= quat._v[3];
        return this;
      }
      multiply(quat) {
        const x = quat._v[3] * this._v[0] + quat._v[2] * this._v[1] + quat._v[1] * this._v[2] - quat._v[0] * this._v[3];
        const y = -quat._v[2] * this._v[0] + quat._v[3] * this._v[1] + quat._v[0] * this._v[2] - quat._v[1] * this._v[3];
        const z = quat._v[1] * this._v[0] + quat._v[0] * this._v[1] + quat._v[3] * this._v[2] - quat._v[2] * this._v[3];
        const w = -quat._v[0] * this._v[0] - quat._v[1] * this._v[1] - quat._v[2] * this._v[2] - quat._v[3] * this._v[3];
        return this.setComponents(x, y, z, w);
      }
      multiplyNumber(value) {
        this._v[0] *= value;
        this._v[1] *= value;
        this._v[2] *= value;
        this._v[3] *= value;
        return this;
      }
      divideNumber(value) {
        if (value !== 0) {
          this._v[0] /= value;
          this._v[1] /= value;
          this._v[2] /= value;
          this._v[3] /= value;
        } else {
          Logger.error("0 division occurred!");
          this._v[0] = Infinity;
          this._v[1] = Infinity;
          this._v[2] = Infinity;
          this._v[3] = Infinity;
        }
        return this;
      }
      clone() {
        return _MutableQuaternion.fromCopy4(this._v[0], this._v[1], this._v[2], this._v[3]);
      }
      static fromFloat32Array(array) {
        return new _MutableQuaternion(array);
      }
      static fromCopyArray4(array) {
        return new _MutableQuaternion(new Float32Array(array));
      }
      static fromCopyArray(array) {
        return new _MutableQuaternion(new Float32Array(array.slice(0, 4)));
      }
      static fromCopy4(x, y, z, w) {
        return new _MutableQuaternion(new Float32Array([
          x,
          y,
          z,
          w
        ]));
      }
      static fromCopyQuaternion(quat) {
        const v = new Float32Array(4);
        v[0] = quat._v[0];
        v[1] = quat._v[1];
        v[2] = quat._v[2];
        v[3] = quat._v[3];
        return new _MutableQuaternion(v);
      }
      static fromCopyVector4(vec) {
        const v = new Float32Array(4);
        v[0] = vec._v[0];
        v[1] = vec._v[1];
        v[2] = vec._v[2];
        v[3] = vec._v[3];
        return new _MutableQuaternion(v);
      }
      static fromCopyLogQuaternion(x) {
        const theta = x._v[0] * x._v[0] + x._v[1] * x._v[1] + x._v[2] * x._v[2];
        const sin = Math.sin(theta);
        const v = new Float32Array(4);
        v[0] = x._v[0] * (sin / theta);
        v[1] = x._v[1] * (sin / theta);
        v[2] = x._v[2] * (sin / theta);
        v[3] = Math.cos(theta);
        return new _MutableQuaternion(v);
      }
    };
    __name(_MutableQuaternion, "MutableQuaternion");
    MutableQuaternion = _MutableQuaternion;
  }
});

// src/foundation/math/MutableScalar.ts
var _MutableScalar_, MutableScalar_, _MutableScalar, MutableScalar, _MutableScalard, MutableScalard;
var init_MutableScalar = __esm({
  "src/foundation/math/MutableScalar.ts"() {
    "use strict";
    init_Scalar();
    init_CompositionType();
    _MutableScalar_ = class _MutableScalar_ extends Scalar_ {
      constructor(x, { type }) {
        super(x, {
          type
        });
      }
      copyComponents(vec) {
        this._v[0] = vec._v[0];
      }
      get x() {
        return this._v[0];
      }
      set x(x) {
        this._v[0] = x;
      }
      get y() {
        return 0;
      }
      get z() {
        return 0;
      }
      get w() {
        return 1;
      }
      /**
      * change to string
      */
      toString() {
        return "(" + this._v[0] + ")";
      }
      setValue(value) {
        this.x = value;
        return this;
      }
      static get compositionType() {
        return CompositionType.Scalar;
      }
      get bytesPerComponent() {
        return this._v.BYTES_PER_ELEMENT;
      }
    };
    __name(_MutableScalar_, "MutableScalar_");
    MutableScalar_ = _MutableScalar_;
    _MutableScalar = class _MutableScalar extends MutableScalar_ {
      constructor(x) {
        super(x, {
          type: Float32Array
        });
      }
      clone() {
        return new _MutableScalar(new Float32Array([
          this.x
        ]));
      }
      static one() {
        return new _MutableScalar(new Float32Array([
          1
        ]));
      }
      static dummy() {
        return new _MutableScalar(new Float32Array([]));
      }
      static zero() {
        return new _MutableScalar(new Float32Array([
          0
        ]));
      }
      get className() {
        return "MutableScalar";
      }
    };
    __name(_MutableScalar, "MutableScalar");
    MutableScalar = _MutableScalar;
    _MutableScalard = class _MutableScalard extends MutableScalar_ {
      constructor(x) {
        super(x, {
          type: Float64Array
        });
      }
      clone() {
        return new _MutableScalard(new Float64Array([
          this.x
        ]));
      }
      static one() {
        return new _MutableScalard(new Float64Array([
          1
        ]));
      }
      static dummy() {
        return new _MutableScalard(new Float64Array([]));
      }
      static zero() {
        return new _MutableScalard(new Float64Array([
          0
        ]));
      }
    };
    __name(_MutableScalard, "MutableScalard");
    MutableScalard = _MutableScalard;
  }
});

// src/foundation/math/VectorN.ts
var _VectorN, VectorN;
var init_VectorN = __esm({
  "src/foundation/math/VectorN.ts"() {
    "use strict";
    _VectorN = class _VectorN {
      constructor(typedArray) {
        __publicField(this, "_v");
        this._v = typedArray;
      }
    };
    __name(_VectorN, "VectorN");
    VectorN = _VectorN;
  }
});

// src/foundation/math/MathClassUtil.ts
var _MathClassUtil, MathClassUtil;
var init_MathClassUtil = __esm({
  "src/foundation/math/MathClassUtil.ts"() {
    "use strict";
    init_Vector2();
    init_Vector3();
    init_Vector4();
    init_Quaternion();
    init_Matrix33();
    init_Matrix44();
    init_CompositionType();
    init_MutableMatrix44();
    init_MutableMatrix33();
    init_MutableVector4();
    init_MutableVector3();
    init_MutableVector2();
    init_Scalar();
    init_MutableQuaternion();
    init_MutableScalar();
    init_VectorN();
    init_Logger();
    _MathClassUtil = class _MathClassUtil {
      constructor() {
      }
      static arrayToVector(element) {
        if (Array.isArray(element)) {
          if (typeof element[3] !== "undefined") {
            return Vector4.fromCopyArray([
              element[0],
              element[1],
              element[2],
              element[3]
            ]);
          } else if (typeof element[2] !== "undefined") {
            return Vector3.fromCopyArray([
              element[0],
              element[1],
              element[2]
            ]);
          } else {
            return Vector2.fromCopyArray2([
              element[0],
              element[1]
            ]);
          }
        } else {
          return element;
        }
      }
      static arrayToVectorOrMatrix(element) {
        if (Array.isArray(element)) {
          if (typeof element[15] !== "undefined") {
            return Matrix44.fromCopyArrayRowMajor(element);
          } else if (typeof element[8] !== "undefined") {
            return Matrix33.fromCopyArrayRowMajor(element);
          } else if (typeof element[3] !== "undefined") {
            return Vector4.fromCopyArray([
              element[0],
              element[1],
              element[2],
              element[3]
            ]);
          } else if (typeof element[2] !== "undefined") {
            return Vector3.fromCopyArray([
              element[0],
              element[1],
              element[2]
            ]);
          } else {
            return Vector2.fromCopyArray2([
              element[0],
              element[1]
            ]);
          }
        } else {
          return element;
        }
      }
      static getImmutableValueClass(compositionType) {
        if (compositionType === CompositionType.Vec2) {
          return Vector2;
        } else if (compositionType === CompositionType.Vec3) {
          return Vector3;
        } else if (compositionType === CompositionType.Vec4) {
          return Vector4;
        } else if (compositionType === CompositionType.Mat3) {
          return Matrix33;
        } else if (compositionType === CompositionType.Mat4) {
          return Matrix44;
        }
        return void 0;
      }
      static getMutableValueClass(compositionType) {
        if (compositionType === CompositionType.Vec2) {
          return MutableVector2;
        } else if (compositionType === CompositionType.Vec3) {
          return MutableVector3;
        } else if (compositionType === CompositionType.Vec4) {
          return MutableVector4;
        } else if (compositionType === CompositionType.Mat3) {
          return MutableMatrix33;
        } else if (compositionType === CompositionType.Mat4) {
          return MutableMatrix44;
        } else {
          return void 0;
        }
      }
      static cloneOfMathObjects(element) {
        if (element instanceof Matrix44) {
          return element.clone();
        } else if (element instanceof Matrix33) {
          return element.clone();
        } else if (element instanceof Vector4) {
          return element.clone();
        } else if (element instanceof Vector3) {
          return element.clone();
        } else if (element instanceof Vector2) {
          return element.clone();
        } else {
          return element;
        }
      }
      static isAcceptableArrayForQuaternion(element) {
        if (Array.isArray(element)) {
          if (typeof element[3] !== "undefined") {
            return true;
          }
        }
        return false;
      }
      static arrayToQuaternion(element) {
        return Quaternion.fromCopy4(element[0], element[1], element[2], element[3]);
      }
      static makeSubArray(array, componentN) {
        if (componentN === 4) {
          return [
            array[0],
            array[1],
            array[2],
            array[3]
          ];
        } else if (componentN === 3) {
          return [
            array[0],
            array[1],
            array[2]
          ];
        } else if (componentN === 2) {
          return [
            array[0],
            array[1]
          ];
        } else {
          return array[0];
        }
      }
      static vectorToArray(element) {
        if (element instanceof Vector2) {
          return [
            element.x,
            element.y
          ];
        } else if (element instanceof Vector3) {
          return [
            element.x,
            element.y,
            element.z
          ];
        } else if (element instanceof Vector4 || element instanceof Quaternion) {
          return [
            element.x,
            element.y,
            element.z,
            element.w
          ];
        } else {
          return element;
        }
      }
      /**
      * discriminate which Vector instance
      * @param element any Vector instance
      * @return number of Vector instance
      */
      static componentNumberOfVector(element) {
        if (element instanceof Vector2) {
          return 2;
        } else if (element instanceof Vector3) {
          return 3;
        } else if (element instanceof Vector4 || element instanceof Quaternion) {
          return 4;
        } else if (Array.isArray(element)) {
          return element.length;
        } else {
          return 0;
        }
      }
      // values range must be [-1, 1]
      static packNormalizedVec4ToVec2(x, y, z, w, criteria) {
        let v0 = 0;
        let v1 = 0;
        x = (x + 1) / 2;
        y = (y + 1) / 2;
        z = (z + 1) / 2;
        w = (w + 1) / 2;
        const ir = Math.floor(x * (criteria - 1));
        const ig = Math.floor(y * (criteria - 1));
        const irg = ir * criteria + ig;
        v0 = irg / criteria;
        const ib = Math.floor(z * (criteria - 1));
        const ia = Math.floor(w * (criteria - 1));
        const iba = ib * criteria + ia;
        v1 = iba / criteria;
        return [
          v0,
          v1
        ];
      }
      static unProjectTo(windowPosX, windowPosY, windowPosZ, inversePVMat44, viewportVec4, out) {
        const input = this.__tmpVector4_0.setComponents((windowPosX - viewportVec4.x) / viewportVec4.z * 2 - 1, (windowPosY - viewportVec4.y) / viewportVec4.w * 2 - 1, 2 * windowPosZ - 1, 1);
        const outNonNormalized = inversePVMat44.multiplyVectorTo(input, this.__tmpVector4_1);
        if (outNonNormalized.w === 0) {
          Logger.error("0 division occurred!");
        }
        return MutableVector3.multiplyTo(outNonNormalized, 1 / outNonNormalized.w, out);
      }
      static add(lhs, rhs) {
        if (isFinite(lhs)) {
          return lhs + rhs;
        } else if (lhs instanceof Vector2) {
          return Vector2.add(lhs, rhs);
        } else if (lhs instanceof Vector3) {
          return Vector3.add(lhs, rhs);
        } else if (lhs instanceof Vector4) {
          return Vector4.add(lhs, rhs);
        } else if (lhs instanceof Quaternion) {
          return Quaternion.add(lhs, rhs);
        } else if (Array.isArray(lhs)) {
          const arr = [];
          for (let i2 = 0; i2 < lhs.length; i2++) {
            arr[i2] = lhs[i2] + rhs[i2];
          }
          return arr;
        } else {
          Logger.error("Non supported type!");
          return;
        }
      }
      static subtract(lhs, rhs) {
        if (isFinite(lhs)) {
          return lhs - rhs;
        } else if (lhs instanceof Vector2) {
          return Vector2.subtract(lhs, rhs);
        } else if (lhs instanceof Vector3) {
          return Vector3.subtract(lhs, rhs);
        } else if (lhs instanceof Vector4) {
          return Vector4.subtract(lhs, rhs);
        } else if (lhs instanceof Quaternion) {
          return Quaternion.subtract(lhs, rhs);
        } else if (Array.isArray(lhs)) {
          const arr = [];
          for (let i2 = 0; i2 < lhs.length; i2++) {
            arr[i2] = lhs[i2] - rhs[i2];
          }
          return arr;
        } else {
          Logger.error("Non supported type!");
          return;
        }
      }
      static multiplyNumber(lhs, rhs) {
        if (isFinite(lhs)) {
          return lhs * rhs;
        } else if (lhs instanceof Vector2) {
          return Vector2.multiply(lhs, rhs);
        } else if (lhs instanceof Vector3) {
          return Vector3.multiply(lhs, rhs);
        } else if (lhs instanceof Vector4) {
          return Vector4.multiply(lhs, rhs);
        } else if (lhs instanceof Quaternion) {
          return Quaternion.multiplyNumber(lhs, rhs);
        } else if (Array.isArray(lhs)) {
          const arr = [];
          for (let i2 = 0; i2 < lhs.length; i2++) {
            arr[i2] = lhs[i2] * rhs;
          }
          return arr;
        } else {
          Logger.error("Non supported type!");
          return;
        }
      }
      static divideNumber(lhs, rhs) {
        if (isFinite(lhs)) {
          return lhs / rhs;
        } else if (lhs instanceof Vector2) {
          return Vector2.multiply(lhs, 1 / rhs);
        } else if (lhs instanceof Vector3) {
          return Vector3.multiply(lhs, 1 / rhs);
        } else if (lhs instanceof Vector4) {
          return Vector4.multiply(lhs, 1 / rhs);
        } else if (lhs instanceof Quaternion) {
          return Quaternion.multiplyNumber(lhs, 1 / rhs);
        } else if (Array.isArray(lhs)) {
          const arr = [];
          for (let i2 = 0; i2 < lhs.length; i2++) {
            arr[i2] = lhs[i2] / rhs;
          }
          return arr;
        } else {
          Logger.error("Non supported type!");
          return;
        }
      }
      static initWithScalar(objForDetectType, val) {
        if (isFinite(objForDetectType)) {
          return val;
        } else if (objForDetectType instanceof Vector2) {
          return Vector2.fromCopyArray2([
            val,
            val
          ]);
        } else if (objForDetectType instanceof Vector3) {
          return Vector3.fromCopyArray([
            val,
            val,
            val
          ]);
        } else if (objForDetectType instanceof Vector4) {
          return Vector4.fromCopyArray([
            val,
            val,
            val,
            val
          ]);
        } else if (objForDetectType instanceof Quaternion) {
          return Quaternion.fromCopy4(0, 0, 0, 1);
        } else if (Array.isArray(objForDetectType)) {
          const arr = [];
          for (let i2 = 0; i2 < objForDetectType.length; i2++) {
            arr[i2] = val;
          }
          return arr;
        } else {
          Logger.error("Non supported type!");
          return void 0;
        }
      }
      static initWithFloat32Array(objForDetectType, val, floatArray, compositionType) {
        let obj;
        if (isFinite(objForDetectType)) {
          const array = new Float32Array(floatArray);
          floatArray._v = void 0;
          array[0] = val;
          return new Scalar2(array);
        } else if (objForDetectType instanceof Scalar2 || objForDetectType instanceof MutableScalar) {
          floatArray[0] = val.x;
          obj = new MutableScalar(floatArray);
        } else if (objForDetectType instanceof Vector2 || objForDetectType instanceof MutableVector2) {
          floatArray[0] = val.x;
          floatArray[1] = val.y;
          obj = new MutableVector2(floatArray);
        } else if (objForDetectType instanceof Vector3 || objForDetectType instanceof MutableVector3) {
          floatArray[0] = val.x;
          floatArray[1] = val.y;
          floatArray[2] = val.z;
          obj = MutableVector3.fromFloat32Array(floatArray);
        } else if (objForDetectType instanceof Vector4 || objForDetectType instanceof MutableVector4) {
          floatArray[0] = val.x;
          floatArray[1] = val.y;
          floatArray[2] = val.z;
          floatArray[3] = val.w;
          obj = new MutableVector4(floatArray);
        } else if (objForDetectType instanceof Quaternion || objForDetectType instanceof MutableQuaternion) {
          floatArray[0] = val.x;
          floatArray[1] = val.y;
          floatArray[2] = val.z;
          floatArray[3] = val.w;
          obj = new MutableQuaternion(floatArray);
        } else if (objForDetectType instanceof Matrix33 || objForDetectType instanceof MutableMatrix33) {
          obj = obj == null ? new MutableMatrix33(floatArray) : obj;
          obj.m00 = val.m00;
          obj.m01 = val.m01;
          obj.m02 = val.m02;
          obj.m10 = val.m10;
          obj.m11 = val.m11;
          obj.m12 = val.m12;
          obj.m20 = val.m20;
          obj.m21 = val.m21;
          obj.m22 = val.m22;
        } else if (objForDetectType instanceof Matrix44 || objForDetectType instanceof MutableMatrix44) {
          obj = new MutableMatrix44(floatArray);
          obj.m00 = val.m00;
          obj.m01 = val.m01;
          obj.m02 = val.m02;
          obj.m03 = val.m03;
          obj.m10 = val.m10;
          obj.m11 = val.m11;
          obj.m12 = val.m12;
          obj.m13 = val.m13;
          obj.m20 = val.m20;
          obj.m21 = val.m21;
          obj.m22 = val.m22;
          obj.m23 = val.m23;
          obj.m30 = val.m30;
          obj.m31 = val.m31;
          obj.m32 = val.m32;
          obj.m33 = val.m33;
        } else if (objForDetectType instanceof VectorN) {
          for (let i2 = 0; i2 < val._v.length; i2++) {
            floatArray[i2] = val._v[i2];
          }
          obj = new VectorN(floatArray);
        } else if (objForDetectType == null) {
          let vec;
          switch (floatArray.length) {
            case 4:
              vec = Vector4.fromCopyFloat32Array(floatArray);
              break;
            case 3:
              vec = Vector3.fromCopyFloat32Array(floatArray);
              break;
            case 2:
              vec = new Vector2(floatArray);
              break;
            case 1:
              vec = new Scalar2(floatArray);
              break;
          }
          floatArray._v = void 0;
          return vec;
        } else if (Array.isArray(objForDetectType) || ArrayBuffer.isView(objForDetectType) || ArrayBuffer.isView(objForDetectType._v)) {
          return objForDetectType;
        } else {
          Logger.error("Non supported type!");
          return void 0;
        }
        floatArray._v = void 0;
        return obj;
      }
      static _setForce(objForDetectType, val) {
        if (objForDetectType instanceof MutableVector4 || objForDetectType instanceof Vector4) {
          if (objForDetectType.isEqual(val)) {
            return false;
          }
          objForDetectType._v[0] = val._v[0];
          objForDetectType._v[1] = val._v[1];
          objForDetectType._v[2] = val._v[2];
          objForDetectType._v[3] = val._v[3];
        } else if (objForDetectType instanceof MutableVector2 || objForDetectType instanceof Vector2) {
          if (objForDetectType.isEqual(val)) {
            return false;
          }
          objForDetectType._v[0] = val._v[0];
          objForDetectType._v[1] = val._v[1];
        } else if (objForDetectType instanceof MutableVector3 || objForDetectType instanceof Vector3) {
          if (objForDetectType.isEqual(val)) {
            return false;
          }
          objForDetectType._v[0] = val._v[0];
          objForDetectType._v[1] = val._v[1];
          objForDetectType._v[2] = val._v[2];
        } else if (objForDetectType instanceof MutableScalar || objForDetectType instanceof Scalar2) {
          if (typeof val._v === "undefined") {
            if (objForDetectType._v[0] == val) {
              return false;
            }
            objForDetectType._v[0] = val;
          } else {
            if (objForDetectType._v[0] == val._v[0]) {
              return false;
            }
            objForDetectType._v[0] = val._v[0];
          }
        } else if (objForDetectType instanceof MutableMatrix33 || objForDetectType instanceof Matrix33) {
          if (objForDetectType.isEqual(val)) {
            return false;
          }
          objForDetectType._v[0] = val._v[0];
          objForDetectType._v[1] = val._v[1];
          objForDetectType._v[2] = val._v[2];
          objForDetectType._v[3] = val._v[3];
          objForDetectType._v[4] = val._v[4];
          objForDetectType._v[5] = val._v[5];
          objForDetectType._v[6] = val._v[6];
          objForDetectType._v[7] = val._v[7];
          objForDetectType._v[8] = val._v[8];
        } else if (objForDetectType instanceof MutableMatrix44 || objForDetectType instanceof Matrix44) {
          if (objForDetectType.isEqual(val)) {
            return false;
          }
          objForDetectType._v[0] = val._v[0];
          objForDetectType._v[1] = val._v[1];
          objForDetectType._v[2] = val._v[2];
          objForDetectType._v[3] = val._v[3];
          objForDetectType._v[4] = val._v[4];
          objForDetectType._v[5] = val._v[5];
          objForDetectType._v[6] = val._v[6];
          objForDetectType._v[7] = val._v[7];
          objForDetectType._v[8] = val._v[8];
          objForDetectType._v[9] = val._v[9];
          objForDetectType._v[10] = val._v[10];
          objForDetectType._v[11] = val._v[11];
          objForDetectType._v[12] = val._v[12];
          objForDetectType._v[13] = val._v[13];
          objForDetectType._v[14] = val._v[14];
          objForDetectType._v[15] = val._v[15];
        } else if (objForDetectType instanceof MutableQuaternion || objForDetectType instanceof Quaternion) {
          if (objForDetectType.isEqual(val)) {
            return false;
          }
          objForDetectType._v[0] = val._v[0];
          objForDetectType._v[1] = val._v[1];
          objForDetectType._v[2] = val._v[2];
          objForDetectType._v[3] = val._v[3];
        } else if (objForDetectType instanceof VectorN) {
          let valArray;
          if (val instanceof VectorN) {
            valArray = val._v;
          } else {
            valArray = val;
          }
          let isSame = true;
          for (let i2 = 0; i2 < valArray.length; i2++) {
            if (objForDetectType._v[i2] !== valArray[i2]) {
              isSame = false;
              break;
            }
          }
          if (isSame) {
            return false;
          }
          for (let i2 = 0; i2 < valArray.length; i2++) {
            objForDetectType._v[i2] = valArray[i2];
          }
        } else if (Array.isArray(objForDetectType)) {
          let isSame = true;
          for (let i2 = 0; i2 < objForDetectType.length; i2++) {
            if (objForDetectType[i2] !== val._v[i2]) {
              isSame = false;
              break;
            }
          }
          if (isSame) {
            return false;
          }
          for (let i2 = 0; i2 < objForDetectType.length; i2++) {
            objForDetectType[i2] = val._v[i2];
          }
        } else if (!isNaN(objForDetectType._v.length)) {
          let isSame = true;
          for (let i2 = 0; i2 < objForDetectType._v.length; i2++) {
            if (Array.isArray(val)) {
              if (objForDetectType._v[i2] !== val[i2]) {
                isSame = false;
                break;
              }
            } else {
              if (objForDetectType._v[i2] !== val._v[i2]) {
                isSame = false;
                break;
              }
            }
          }
          if (isSame) {
            return false;
          }
          for (let i2 = 0; i2 < objForDetectType._v.length; i2++) {
            if (Array.isArray(val)) {
              objForDetectType._v[i2] = val[i2];
            } else {
              objForDetectType._v[i2] = val._v[i2];
            }
          }
        } else {
          Logger.warn("Unknown type _setForce");
        }
        return true;
      }
    };
    __name(_MathClassUtil, "MathClassUtil");
    __publicField(_MathClassUtil, "__tmpVector4_0", MutableVector4.zero());
    __publicField(_MathClassUtil, "__tmpVector4_1", MutableVector4.zero());
    MathClassUtil = _MathClassUtil;
  }
});

// src/foundation/cameras/WalkThroughCameraController.ts
var _WalkThroughCameraController, WalkThroughCameraController;
var init_WalkThroughCameraController = __esm({
  "src/foundation/cameras/WalkThroughCameraController.ts"() {
    "use strict";
    init_Matrix44();
    init_MathClassUtil();
    init_MutableVector3();
    init_MutableMatrix33();
    init_MutableMatrix44();
    init_AbstractCameraController();
    init_MathUtil();
    init_Is();
    init_InputManager();
    init_AABB();
    _WalkThroughCameraController = class _WalkThroughCameraController extends AbstractCameraController {
      constructor(cameraControllerComponent, options = {
        eventTargetDom: document,
        verticalSpeed: 1,
        horizontalSpeed: 1,
        turnSpeed: 0.25,
        mouseWheelSpeedScale: 1,
        inverseVerticalRotating: false,
        inverseHorizontalRotating: false
      }) {
        super();
        __publicField(this, "__updateCount", 0);
        __publicField(this, "_horizontalSpeed");
        __publicField(this, "_verticalSpeed");
        __publicField(this, "_turnSpeed");
        __publicField(this, "_mouseWheelSpeedScale");
        __publicField(this, "_inverseVerticalRotating");
        __publicField(this, "_inverseHorizontalRotating");
        __publicField(this, "_onKeydown");
        __publicField(this, "_isKeyDown", false);
        __publicField(this, "_isMouseDrag", false);
        __publicField(this, "_lastKeyCode", -1);
        __publicField(this, "_onKeyup");
        __publicField(this, "_currentDir", MutableVector3.fromCopyArray([
          0,
          0,
          -1
        ]));
        __publicField(this, "_currentPos", MutableVector3.fromCopyArray([
          0,
          0,
          0
        ]));
        __publicField(this, "_currentCenter", MutableVector3.fromCopyArray([
          0,
          0,
          -1
        ]));
        __publicField(this, "_currentHorizontalDir", MutableVector3.fromCopyArray([
          0,
          0,
          -1
        ]));
        __publicField(this, "_newDir", MutableVector3.fromCopyArray([
          0,
          0,
          -1
        ]));
        __publicField(this, "_isMouseDown", false);
        __publicField(this, "_clickedMouseXOnCanvas", -1);
        __publicField(this, "_clickedMouseYOnCanvas", -1);
        __publicField(this, "_draggedMouseXOnCanvas", -1);
        __publicField(this, "_draggedMouseYOnCanvas", -1);
        __publicField(this, "_deltaMouseXOnCanvas", -1);
        __publicField(this, "_deltaMouseYOnCanvas", -1);
        __publicField(this, "_mouseXAdjustScale", 1);
        __publicField(this, "_mouseYAdjustScale", 1);
        __publicField(this, "_deltaY", -1);
        __publicField(this, "_deltaX", -1);
        __publicField(this, "_mouseUpBind", this._mouseUp.bind(this));
        __publicField(this, "_mouseDownBind", this._mouseDown.bind(this));
        __publicField(this, "_mouseMoveBind", this._mouseMove.bind(this));
        __publicField(this, "_mouseWheelBind", this._mouseWheel.bind(this));
        __publicField(this, "_eventTargetDom");
        __publicField(this, "__doPreventDefault", false);
        __publicField(this, "_needInitialize", true);
        __publicField(this, "__targetEntities", []);
        __publicField(this, "aabbWithSkeletal", true);
        __publicField(this, "__cameraControllerComponent");
        this.__cameraControllerComponent = cameraControllerComponent;
        this._horizontalSpeed = options.horizontalSpeed;
        this._verticalSpeed = options.verticalSpeed;
        this._turnSpeed = options.turnSpeed;
        this._mouseXAdjustScale = this._turnSpeed;
        this._mouseYAdjustScale = this._turnSpeed;
        this._mouseWheelSpeedScale = options.mouseWheelSpeedScale;
        this._inverseVerticalRotating = options.inverseVerticalRotating;
        this._inverseHorizontalRotating = options.inverseHorizontalRotating;
        this.reset();
        this._onKeydown = (e3) => {
          this._isKeyDown = true;
          this._lastKeyCode = e3.keyCode;
        };
        this._onKeyup = (e3) => {
          this._isKeyDown = false;
          this._lastKeyCode = -1;
        };
        const eventTargetDom2 = options.eventTargetDom;
        this.registerEventListeners(eventTargetDom2);
      }
      _updateCount() {
        this.__updateCount++;
        this.__cameraControllerComponent._updateCount(this.__updateCount);
      }
      get updateCount() {
        return this.__updateCount;
      }
      registerEventListeners(eventTargetDom2 = document) {
        this._eventTargetDom = eventTargetDom2;
        const inputHandlerInfos = [
          {
            eventName: "keydown",
            handler: this._onKeydown,
            options: {
              passive: !this.__doPreventDefault
            },
            classInstance: this,
            eventTargetDom: eventTargetDom2
          },
          {
            eventName: "keyup",
            handler: this._onKeyup,
            options: {
              passive: !this.__doPreventDefault
            },
            classInstance: this,
            eventTargetDom: eventTargetDom2
          }
        ];
        if ("ontouchend" in document) {
          inputHandlerInfos.push({
            eventName: "touchstart",
            handler: this._mouseDownBind,
            options: {
              passive: !this.__doPreventDefault
            },
            classInstance: this,
            eventTargetDom: eventTargetDom2
          }, {
            eventName: "touchend",
            handler: this._mouseUpBind,
            options: {
              passive: !this.__doPreventDefault
            },
            classInstance: this,
            eventTargetDom: eventTargetDom2
          }, {
            eventName: "touchmove",
            handler: this._mouseMoveBind,
            options: {
              passive: !this.__doPreventDefault
            },
            classInstance: this,
            eventTargetDom: eventTargetDom2
          });
        }
        if ("onmouseup" in document) {
          inputHandlerInfos.push({
            eventName: "mousedown",
            handler: this._mouseDownBind,
            options: {
              passive: !this.__doPreventDefault
            },
            classInstance: this,
            eventTargetDom: eventTargetDom2
          }, {
            eventName: "mouseup",
            handler: this._mouseUpBind,
            options: {
              passive: !this.__doPreventDefault
            },
            classInstance: this,
            eventTargetDom: eventTargetDom2
          }, {
            eventName: "mouseleave",
            handler: this._mouseUpBind,
            options: {
              passive: !this.__doPreventDefault
            },
            classInstance: this,
            eventTargetDom: eventTargetDom2
          }, {
            eventName: "mousemove",
            handler: this._mouseMoveBind,
            options: {
              passive: !this.__doPreventDefault
            },
            classInstance: this,
            eventTargetDom: eventTargetDom2
          });
        }
        if ("onwheel" in document) {
          inputHandlerInfos.push({
            eventName: "wheel",
            handler: this._mouseWheelBind,
            options: {
              passive: !this.__doPreventDefault
            },
            classInstance: this,
            eventTargetDom: eventTargetDom2
          });
        }
        InputManager.register(INPUT_HANDLING_STATE_CAMERA_CONTROLLER, inputHandlerInfos);
      }
      unregisterEventListeners() {
        InputManager.unregister(INPUT_HANDLING_STATE_CAMERA_CONTROLLER);
      }
      __tryToPreventDefault(evt) {
        if (this.__doPreventDefault) {
          evt.preventDefault();
        }
      }
      _mouseWheel(e3) {
        if (this._currentDir === null) {
          return;
        }
        const delta = -1 * Math.sign(e3.deltaY) * this._mouseWheelSpeedScale * this._horizontalSpeed;
        const horizontalDir = _WalkThroughCameraController.__tmp_Vec3_0;
        horizontalDir.setComponents(this._currentDir.x, 0, this._currentDir.z).normalize();
        const deltaVec = MutableVector3.multiplyTo(horizontalDir, delta, _WalkThroughCameraController.__tmp_Vec3_1);
        this._currentPos.add(deltaVec);
        this._currentCenter.add(deltaVec);
        this._updateCount();
      }
      _mouseDown(evt) {
        this.__tryToPreventDefault(evt);
        this._isMouseDown = true;
        const rect = evt.target.getBoundingClientRect();
        this._clickedMouseXOnCanvas = evt.clientX - rect.left;
        this._clickedMouseYOnCanvas = evt.clientY - rect.top;
        this._updateCount();
        return false;
      }
      _mouseMove(evt) {
        this.__tryToPreventDefault(evt);
        if (!this._isMouseDown) {
          return;
        }
        const rect = evt.target.getBoundingClientRect();
        this._draggedMouseXOnCanvas = evt.clientX - rect.left;
        this._draggedMouseYOnCanvas = evt.clientY - rect.top;
        this._deltaMouseXOnCanvas = this._draggedMouseXOnCanvas - this._clickedMouseXOnCanvas;
        this._deltaMouseYOnCanvas = this._draggedMouseYOnCanvas - this._clickedMouseYOnCanvas;
        this._isMouseDrag = true;
        this._updateCount();
      }
      _mouseUp(evt) {
        this._isMouseDown = false;
        this._isMouseDrag = false;
        const target = evt.target;
        if ((target == null ? void 0 : target.getBoundingClientRect) == null) {
          return;
        }
        const rect = target.getBoundingClientRect();
        this._clickedMouseXOnCanvas = evt.clientX - rect.left;
        this._clickedMouseYOnCanvas = evt.clientY - rect.top;
        this._updateCount();
      }
      tryReset() {
      }
      reset() {
        this._isKeyDown = false;
        this._lastKeyCode = -1;
        this._currentPos.zero();
        this._currentCenter.setComponents(0, 0, -1);
        this._currentDir.setComponents(0, 0, -1);
        this._currentHorizontalDir.setComponents(0, 0, -1);
        this._isMouseDown = false;
        this._isMouseDrag = false;
        this._draggedMouseXOnCanvas = -1;
        this._draggedMouseYOnCanvas = -1;
        this._deltaMouseXOnCanvas = -1;
        this._deltaMouseYOnCanvas = -1;
        this._mouseXAdjustScale = this._turnSpeed;
        this._mouseYAdjustScale = this._turnSpeed;
        this._deltaY = 0;
        this._deltaX = 0;
        this._newDir.setComponents(0, 0, -1);
      }
      logic(cameraComponent) {
        this.__updateCameraComponent(cameraComponent);
      }
      __updateCameraComponent(camera) {
        const aabb = new AABB();
        for (const targetEntity of this.__targetEntities) {
          aabb.mergeAABB(this.__getTargetAABB(targetEntity));
        }
        const targetAABB = aabb;
        if (this._needInitialize && targetAABB != null) {
          const lengthCenterToCamera = targetAABB.lengthCenterToCorner * (1 + 1 / Math.tan(MathUtil.degreeToRadian(camera.fovy / 2)));
          this._currentPos.copyComponents(targetAABB.centerPoint);
          this._currentPos.z += lengthCenterToCamera;
          this._currentCenter.copyComponents(targetAABB.centerPoint);
          this._currentDir.setComponents(0, 0, -1);
          const sceneComponent = camera.entity.tryToGetSceneGraph();
          if (Is.exist(sceneComponent)) {
            const invMat = Matrix44.invertTo(sceneComponent.matrixInner, _WalkThroughCameraController.__tmpInvMat);
            invMat.multiplyVector3To(this._currentPos, this._currentPos);
            invMat.multiplyVector3To(this._currentCenter, this._currentCenter);
          }
          this._needInitialize = false;
        }
        const t2 = this._deltaY / 90;
        this._newDir.x = this._currentDir.x * (1 - t2);
        this._newDir.y = t2;
        this._newDir.z = this._currentDir.z * (1 - t2);
        this._newDir.normalize();
        this._currentHorizontalDir.x = this._currentDir.x;
        this._currentHorizontalDir.y = 0;
        this._currentHorizontalDir.z = this._currentDir.z;
        this._currentHorizontalDir.normalize();
        const moveVector = _WalkThroughCameraController.__tmp_Vec3_0.zero();
        switch (this._lastKeyCode) {
          case 87:
          case 38:
            moveVector.x = this._currentHorizontalDir.x * this._horizontalSpeed;
            moveVector.z = this._currentHorizontalDir.z * this._horizontalSpeed;
            break;
          case 65:
          case 37:
            moveVector.x = this._currentHorizontalDir.z * this._horizontalSpeed;
            moveVector.z = -this._currentHorizontalDir.x * this._horizontalSpeed;
            break;
          case 83:
          case 40:
            moveVector.x = -this._currentHorizontalDir.x * this._horizontalSpeed;
            moveVector.z = -this._currentHorizontalDir.z * this._horizontalSpeed;
            break;
          case 68:
          case 39:
            moveVector.x = -this._currentHorizontalDir.z * this._horizontalSpeed;
            moveVector.z = this._currentHorizontalDir.x * this._horizontalSpeed;
            break;
          case 81:
            moveVector.x = -this._newDir.x * this._horizontalSpeed;
            moveVector.y = -this._newDir.y * this._horizontalSpeed;
            moveVector.z = -this._newDir.z * this._horizontalSpeed;
            break;
          case 69:
            moveVector.x = this._newDir.x * this._horizontalSpeed;
            moveVector.y = this._newDir.y * this._horizontalSpeed;
            moveVector.z = this._newDir.z * this._horizontalSpeed;
            break;
          case 82:
            moveVector.y = this._verticalSpeed;
            break;
          case 70:
            moveVector.y = -this._verticalSpeed;
            break;
        }
        this._currentPos.add(moveVector);
        this._currentCenter.add(moveVector);
        if (this._isMouseDrag) {
          if (this._inverseHorizontalRotating) {
            this._deltaX = this._deltaMouseXOnCanvas * this._mouseXAdjustScale;
          } else {
            this._deltaX = -this._deltaMouseXOnCanvas * this._mouseXAdjustScale;
          }
          if (this._inverseVerticalRotating) {
            this._deltaY += this._deltaMouseYOnCanvas * this._mouseYAdjustScale;
          } else {
            this._deltaY += -this._deltaMouseYOnCanvas * this._mouseYAdjustScale;
          }
          this._deltaY = Math.max(-120, Math.min(50, this._deltaY));
          const rotateMatrix = _WalkThroughCameraController.__tmpRotateMat.rotateY(MathUtil.degreeToRadian(this._deltaX));
          rotateMatrix.multiplyVectorTo(this._currentDir, this._currentDir);
          const newEyeToCenter = MutableVector3.subtractTo(this._currentCenter, this._currentPos, _WalkThroughCameraController.__tmp_Vec3_1);
          rotateMatrix.multiplyVectorTo(newEyeToCenter, newEyeToCenter);
          newEyeToCenter.x = newEyeToCenter.x * (1 - t2);
          newEyeToCenter.y = t2;
          newEyeToCenter.z = newEyeToCenter.z * (1 - t2);
          newEyeToCenter.normalize();
          this._currentCenter.copyComponents(this._currentPos);
          this._currentCenter.add(newEyeToCenter);
          this._clickedMouseXOnCanvas = this._draggedMouseXOnCanvas;
          this._clickedMouseYOnCanvas = this._draggedMouseYOnCanvas;
          this._deltaMouseXOnCanvas = 0;
          this._deltaMouseYOnCanvas = 0;
        }
        camera.eyeInner = this._currentPos;
        camera.directionInner = this._currentCenter;
        camera.upInner = camera._up;
        camera.leftInner = camera.left;
        camera.rightInner = camera.right;
        camera.topInner = camera.top;
        camera.bottomInner = camera.bottom;
        camera.fovyInner = camera.fovy;
        this._calcZNearInner(camera, this._currentPos, this._newDir);
        this._calcZFarInner(camera);
      }
      getDirection() {
        return this._currentCenter !== null ? this._newDir.clone() : null;
      }
      set horizontalSpeed(value) {
        this._horizontalSpeed = value;
      }
      get horizontalSpeed() {
        return this._horizontalSpeed;
      }
      set verticalSpeed(value) {
        this._verticalSpeed = value;
      }
      get verticalSpeed() {
        return this._verticalSpeed;
      }
      set mouseWheelSpeed(value) {
        this._mouseWheelSpeedScale = value;
      }
      get mouseWheelSpeed() {
        return this._mouseWheelSpeedScale;
      }
      setTarget(targetEntity) {
        this.setTargets([
          targetEntity
        ]);
      }
      __getTargetAABB(targetEntity) {
        if (this.aabbWithSkeletal) {
          return targetEntity.tryToGetSceneGraph().worldMergedAABBWithSkeletal;
        } else {
          return targetEntity.tryToGetSceneGraph().worldMergedAABB;
        }
      }
      setTargets(targetEntities) {
        const aabb = new AABB();
        for (const targetEntity of targetEntities) {
          aabb.mergeAABB(this.__getTargetAABB(targetEntity));
        }
        const speed = aabb.lengthCenterToCorner / 10;
        this.verticalSpeed = speed;
        this.horizontalSpeed = speed;
        this.__targetEntities = targetEntities;
        this._needInitialize = true;
        this._updateCount();
      }
      getTargets() {
        return this.__targetEntities;
      }
      get allInfo() {
        const info = {};
        info.verticalSpeed = this.verticalSpeed;
        info.horizontalSpeed = this.horizontalSpeed;
        info._turnSpeed = this._turnSpeed;
        if (this._currentPos) {
          info._currentPos = this._currentPos.clone();
        }
        if (this._currentCenter) {
          info._currentCenter = this._currentCenter.clone();
        }
        if (this._currentDir) {
          info._currentDir = this._currentDir.clone();
        }
        info._deltaY = this._deltaY;
        info._newDir = this._newDir.clone();
        return info;
      }
      set allInfo(arg) {
        let json = arg;
        if (typeof arg === "string") {
          json = JSON.parse(arg);
        }
        for (const key in json) {
          if (json.hasOwnProperty(key) && key in this) {
            if (key === "quaternion") {
              this[key] = MathClassUtil.cloneOfMathObjects(MathClassUtil.arrayToQuaternion(json[key]));
            } else {
              this[key] = MathClassUtil.cloneOfMathObjects(MathClassUtil.arrayToVectorOrMatrix(json[key]));
            }
          }
        }
      }
    };
    __name(_WalkThroughCameraController, "WalkThroughCameraController");
    __publicField(_WalkThroughCameraController, "__tmpInvMat", MutableMatrix44.identity());
    __publicField(_WalkThroughCameraController, "__tmpRotateMat", MutableMatrix33.identity());
    __publicField(_WalkThroughCameraController, "__tmp_Vec3_0", MutableVector3.zero());
    __publicField(_WalkThroughCameraController, "__tmp_Vec3_1", MutableVector3.zero());
    WalkThroughCameraController = _WalkThroughCameraController;
  }
});

// src/foundation/definitions/ComponentType.ts
function from3(index) {
  return _from({
    typeList: typeList3,
    index
  });
}
function fromString3(str) {
  return _fromString({
    typeList: typeList3,
    str
  });
}
function fromTypedArray(typedArray) {
  if (typedArray instanceof Int8Array) {
    return Byte;
  } else if (typedArray instanceof Uint8Array || typedArray instanceof Uint8ClampedArray) {
    return UnsignedByte;
  } else if (typedArray instanceof Int16Array) {
    return Short;
  } else if (typedArray instanceof Uint16Array) {
    return UnsignedShort;
  } else if (typedArray instanceof Int32Array) {
    return Int;
  } else if (typedArray instanceof Uint32Array) {
    return UnsignedInt;
  } else if (typedArray instanceof Float32Array) {
    return Float;
  } else if (typedArray instanceof Float64Array) {
    return Double;
  }
  return Unknown2;
}
function toTypedArray(componentType) {
  if (componentType === Byte) {
    return Int8Array;
  } else if (componentType === UnsignedByte) {
    return Uint8Array;
  } else if (componentType === Short) {
    return Int16Array;
  } else if (componentType === UnsignedShort) {
    return Uint16Array;
  } else if (componentType === Int) {
    return Int32Array;
  } else if (componentType === UnsignedInt) {
    return Uint32Array;
  } else if (componentType === Float) {
    return Float32Array;
  } else if (componentType === Double) {
    return Float64Array;
  } else {
    return void 0;
  }
}
function fromWgslString2(str_) {
  let str = str_;
  switch (str_) {
    case "bool":
      str = "BOOL";
      break;
    case "i32":
      str = "INT";
      break;
    case "u32":
      str = "UNSIGNED_INT";
      break;
    case "f32":
      str = "FLOAT";
      break;
    case "vec2<f32>":
      str = "FLOAT";
      break;
    case "vec3<f32>":
      str = "FLOAT";
      break;
    case "vec4<f32>":
      str = "FLOAT";
      break;
    case "mat2x2<f32>":
      str = "FLOAT";
      break;
    case "mat3x3<f32>":
      str = "FLOAT";
      break;
    case "mat4x4<f32>":
      str = "FLOAT";
      break;
    case "vec2<i32>":
      str = "INT";
      break;
    case "vec3<i32>":
      str = "INT";
      break;
    case "vec4<i32>":
      str = "INT";
      break;
    case "sampler_2d":
      str = "INT";
      break;
    case "sampler_2d_shadow":
      str = "INT";
      break;
    case "sampler_3d":
      str = "INT";
      break;
    case "sampler_cube":
      str = "INT";
      break;
  }
  return _fromString({
    typeList: typeList3,
    str
  });
}
function fromGlslString2(str_) {
  let str = str_;
  switch (str_) {
    case "bool":
      str = "BOOL";
      break;
    case "int":
      str = "INT";
      break;
    case "float":
      str = "FLOAT";
      break;
    case "vec2":
      str = "FLOAT";
      break;
    case "vec3":
      str = "FLOAT";
      break;
    case "vec4":
      str = "FLOAT";
      break;
    case "mat2":
      str = "FLOAT";
      break;
    case "mat3":
      str = "FLOAT";
      break;
    case "mat4":
      str = "FLOAT";
      break;
    case "ivec2":
      str = "INT";
      break;
    case "ivec3":
      str = "INT";
      break;
    case "ivec4":
      str = "INT";
      break;
    case "sampler2D":
      str = "INT";
      break;
    case "sampler2DShadow":
      str = "INT";
      break;
    case "sampler2DRect":
      str = "INT";
      break;
    case "sampler3D":
      str = "INT";
      break;
    case "samplerCube":
      str = "INT";
      break;
  }
  return _fromString({
    typeList: typeList3,
    str
  });
}
function toGltf2AccessorComponentType(componentTypeForGltf2) {
  return componentTypeForGltf2.index;
}
var _a5, ComponentTypeClass, Unknown2, Byte, UnsignedByte, Short, UnsignedShort, Int, UnsignedInt, Float, Double, Bool, HalfFloat, typeList3, ComponentType;
var init_ComponentType = __esm({
  "src/foundation/definitions/ComponentType.ts"() {
    "use strict";
    init_EnumIO();
    ComponentTypeClass = (_a5 = class extends EnumClass {
      constructor({ index, str, sizeInBytes, wgsl, webgpu }) {
        super({
          index,
          str
        });
        __publicField(this, "__webgpu");
        __publicField(this, "__wgsl");
        __publicField(this, "__sizeInBytes");
        __publicField(this, "__dummyStr");
        this.__sizeInBytes = sizeInBytes;
        this.__webgpu = webgpu;
        this.__wgsl = wgsl;
        this.__dummyStr = str;
      }
      get wgsl() {
        return this.__wgsl;
      }
      get webgpu() {
        return this.__webgpu;
      }
      getSizeInBytes() {
        return this.__sizeInBytes;
      }
      isFloatingPoint() {
        if (this.index === 5126 || // Float
        this.index === 5127 || // Double
        this.index === 36193) {
          return true;
        }
        return false;
      }
      isInteger() {
        if (this.index === 5120 || // Byte
        this.index === 5122 || // Short
        this.index === 5124) {
          return true;
        }
        return false;
      }
      isUnsignedInteger() {
        if (this.index === 5121 || // UnsignedByte
        this.index === 5123 || // UnsignedShort
        this.index === 5125) {
          return true;
        }
        return false;
      }
    }, __name(_a5, "ComponentTypeClass"), _a5);
    Unknown2 = new ComponentTypeClass({
      index: 5119,
      str: "UNKNOWN",
      sizeInBytes: 0,
      wgsl: "unknown",
      webgpu: "unknown"
    });
    Byte = new ComponentTypeClass({
      index: 5120,
      str: "BYTE",
      sizeInBytes: 1,
      wgsl: "i32",
      webgpu: "sint8"
    });
    UnsignedByte = new ComponentTypeClass({
      index: 5121,
      str: "UNSIGNED_BYTE",
      sizeInBytes: 1,
      wgsl: "u32",
      webgpu: "uint8"
    });
    Short = new ComponentTypeClass({
      index: 5122,
      str: "SHORT",
      sizeInBytes: 2,
      wgsl: "i32",
      webgpu: "sint16"
    });
    UnsignedShort = new ComponentTypeClass({
      index: 5123,
      str: "UNSIGNED_SHORT",
      sizeInBytes: 2,
      wgsl: "u32",
      webgpu: "uint16"
    });
    Int = new ComponentTypeClass({
      index: 5124,
      str: "INT",
      sizeInBytes: 4,
      wgsl: "i32",
      webgpu: "sint32"
    });
    UnsignedInt = new ComponentTypeClass({
      index: 5125,
      str: "UNSIGNED_INT",
      sizeInBytes: 4,
      wgsl: "u32",
      webgpu: "uint32"
    });
    Float = new ComponentTypeClass({
      index: 5126,
      str: "FLOAT",
      sizeInBytes: 4,
      wgsl: "f32",
      webgpu: "float32"
    });
    Double = new ComponentTypeClass({
      index: 5127,
      str: "DOUBLE",
      sizeInBytes: 8,
      wgsl: "f32",
      webgpu: "float64"
    });
    Bool = new ComponentTypeClass({
      index: 35670,
      str: "BOOL",
      sizeInBytes: 1,
      wgsl: "bool",
      webgpu: "bool"
    });
    HalfFloat = new ComponentTypeClass({
      index: 5131,
      str: "HALF_FLOAT",
      sizeInBytes: 2,
      wgsl: "f16",
      webgpu: "float16"
    });
    typeList3 = [
      Unknown2,
      Byte,
      UnsignedByte,
      Short,
      UnsignedShort,
      Int,
      UnsignedInt,
      Float,
      Double,
      HalfFloat,
      Bool
    ];
    __name(from3, "from");
    __name(fromString3, "fromString");
    __name(fromTypedArray, "fromTypedArray");
    __name(toTypedArray, "toTypedArray");
    __name(fromWgslString2, "fromWgslString");
    __name(fromGlslString2, "fromGlslString");
    __name(toGltf2AccessorComponentType, "toGltf2AccessorComponentType");
    ComponentType = Object.freeze({
      Unknown: Unknown2,
      Byte,
      UnsignedByte,
      Short,
      UnsignedShort,
      Int,
      UnsignedInt,
      Float,
      Double,
      Bool,
      HalfFloat,
      from: from3,
      fromTypedArray,
      toTypedArray,
      toGltf2AccessorComponentType,
      fromString: fromString3,
      fromGlslString: fromGlslString2,
      fromWgslString: fromWgslString2
    });
  }
});

// src/foundation/memory/Accessor.ts
var _Accessor, Accessor;
var init_Accessor = __esm({
  "src/foundation/memory/Accessor.ts"() {
    "use strict";
    init_ComponentType();
    init_CompositionType();
    init_Vector2();
    init_Vector3();
    init_Vector4();
    init_MutableVector2();
    init_MutableVector3();
    init_MutableVector4();
    init_Matrix33();
    init_MutableMatrix44();
    init_Is();
    init_Logger();
    _Accessor = class _Accessor {
      constructor({ bufferView, byteOffsetInBufferView, compositionType, componentType, byteStride, count, raw, max, min, arrayLength, normalized }) {
        __publicField(this, "__bufferView");
        __publicField(this, "__byteOffsetInRawArrayBufferOfBuffer");
        __publicField(this, "__compositionType", CompositionType.Unknown);
        __publicField(this, "__componentType", ComponentType.Unknown);
        __publicField(this, "__count", 0);
        __publicField(this, "__raw");
        __publicField(this, "__dataView");
        __publicField(this, "__typedArray");
        __publicField(this, "__takenCount", 0);
        __publicField(this, "__byteStride", 0);
        __publicField(this, "__typedArrayClass");
        __publicField(this, "__dataViewGetter");
        __publicField(this, "__dataViewSetter");
        __publicField(this, "__max", MutableVector4.fromCopyArray([
          -Number.MAX_VALUE,
          -Number.MAX_VALUE,
          -Number.MAX_VALUE,
          -Number.MAX_VALUE
        ]));
        __publicField(this, "__min", MutableVector4.fromCopyArray([
          Number.MAX_VALUE,
          Number.MAX_VALUE,
          Number.MAX_VALUE,
          Number.MAX_VALUE
        ]));
        __publicField(this, "__arrayLength", 1);
        __publicField(this, "__normalized", false);
        __publicField(this, "__isMinMixDirty", true);
        __publicField(this, "__version", 0);
        __publicField(this, "_primitive");
        var _a40, _b, _c, _d, _e, _f, _g, _h;
        this.__bufferView = bufferView;
        this.__byteOffsetInRawArrayBufferOfBuffer = bufferView.byteOffsetInRawArrayBufferOfBuffer + byteOffsetInBufferView;
        this.__compositionType = compositionType;
        this.__componentType = componentType;
        this.__count = count;
        this.__arrayLength = arrayLength;
        if (Is.exist(max)) {
          this.__max.setComponents((_a40 = max[0]) != null ? _a40 : -Number.MAX_VALUE, (_b = max[1]) != null ? _b : -Number.MAX_VALUE, (_c = max[2]) != null ? _c : -Number.MAX_VALUE, (_d = max[3]) != null ? _d : -Number.MAX_VALUE);
        }
        if (Is.exist(min)) {
          this.__min.setComponents((_e = min[0]) != null ? _e : Number.MAX_VALUE, (_f = min[1]) != null ? _f : Number.MAX_VALUE, (_g = min[2]) != null ? _g : Number.MAX_VALUE, (_h = min[3]) != null ? _h : Number.MAX_VALUE);
        }
        if (Is.exist(max) && Is.exist(min)) {
          this.__isMinMixDirty = false;
        }
        this.__raw = raw;
        this.__normalized = normalized;
        this.__byteStride = byteStride;
        if (this.__byteStride === 0) {
          this.__byteStride = this.__compositionType.getNumberOfComponents() * this.__componentType.getSizeInBytes() * this.__arrayLength;
        }
        const typedArrayClass = this.getTypedArrayClass(this.__componentType);
        this.__typedArrayClass = typedArrayClass;
        const maxExceededSizeOnAoS = this.__byteStride - this.__compositionType.getNumberOfComponents() * this.__componentType.getSizeInBytes();
        const sizeFromAccessorBeginToArrayBufferEnd = this.__raw.byteLength - this.__byteOffsetInRawArrayBufferOfBuffer;
        const maxLimitSizeToAccess = this.byteStride * this.__count - maxExceededSizeOnAoS;
        if (sizeFromAccessorBeginToArrayBufferEnd < maxLimitSizeToAccess) {
          Logger.error(`Requesting a data size that exceeds the remaining capacity of the buffer: ${this.bufferView.buffer.name}.
        Exceeded Size: ${maxLimitSizeToAccess - sizeFromAccessorBeginToArrayBufferEnd}
        this.__raw.byteLength: ${this.__raw.byteLength}
        this.__byteOffsetInRawArrayBufferOfBuffer: ${this.byteOffsetInRawArrayBufferOfBuffer}
        this.byteStride: ${this.byteStride}
        this.__count: ${this.__count}
        this.__raw.byteLength - this.__byteOffsetInRawArrayBufferOfBuffer: ${this.__raw.byteLength - this.__byteOffsetInRawArrayBufferOfBuffer}
        this.byteStride * this.__count: ${this.byteStride * this.__count}
        maxExceededSizeOnAoS: ${maxExceededSizeOnAoS}
        `);
        }
        this.__dataView = new DataView(this.__raw, this.__byteOffsetInRawArrayBufferOfBuffer, Math.min(this.__byteStride * this.__count, this.__raw.byteLength - this.__byteOffsetInRawArrayBufferOfBuffer));
        this.__typedArray = new typedArrayClass(this.__raw, this.__byteOffsetInRawArrayBufferOfBuffer, this.__compositionType.getNumberOfComponents() * this.__count);
        this.__dataViewGetter = this.__dataView[this.getDataViewGetter(this.__componentType)].bind(this.__dataView);
        this.__dataViewSetter = this.__dataView[this.getDataViewSetter(this.__componentType)].bind(this.__dataView);
      }
      __onUpdated() {
        var _a40;
        this.__version++;
        if (this._primitive != null) {
          (_a40 = this._primitive.deref()) == null ? void 0 : _a40.onAccessorUpdated(this.__version);
        }
      }
      getTypedArrayClass(componentType) {
        switch (componentType) {
          case ComponentType.Byte:
            return Int8Array;
          case ComponentType.UnsignedByte:
            return Uint8Array;
          case ComponentType.Short:
            return Int16Array;
          case ComponentType.UnsignedShort:
            return Uint16Array;
          case ComponentType.Int:
            return Int32Array;
          case ComponentType.UnsignedInt:
            return Uint32Array;
          case ComponentType.Float:
            return Float32Array;
          case ComponentType.Double:
            return Float64Array;
          default:
            Logger.error("Unexpected ComponentType!");
            return void 0;
        }
      }
      getDataViewGetter(componentType) {
        switch (componentType) {
          case ComponentType.Byte:
            return "getInt8";
          case ComponentType.UnsignedByte:
            return "getUint8";
          case ComponentType.Short:
            return "getInt16";
          case ComponentType.UnsignedShort:
            return "getUint16";
          case ComponentType.Int:
            return "getInt32";
          case ComponentType.UnsignedInt:
            return "getUint32";
          case ComponentType.Float:
            return "getFloat32";
          case ComponentType.Double:
            return "getFloat64";
          default:
            Logger.error("Unexpected ComponentType!");
            return "unknown";
        }
      }
      getDataViewSetter(componentType) {
        switch (componentType) {
          case ComponentType.Byte:
            return "setInt8";
          case ComponentType.UnsignedByte:
            return "setUint8";
          case ComponentType.Short:
            return "setInt16";
          case ComponentType.UnsignedShort:
            return "setUint16";
          case ComponentType.Int:
            return "setInt32";
          case ComponentType.UnsignedInt:
            return "setUint32";
          case ComponentType.Float:
            return "setFloat32";
          case ComponentType.Double:
            return "setFloat64";
          default:
            Logger.error("Unexpected ComponentType!");
        }
        return void 0;
      }
      takeOne() {
        const arrayBufferOfBufferView = this.__raw;
        if (this.__takenCount >= this.__count) {
          Logger.error("You are trying to allocate more than you have secured.");
        }
        const subTypedArray = new this.__typedArrayClass(arrayBufferOfBufferView, this.__byteOffsetInRawArrayBufferOfBuffer + this.__byteStride * this.__takenCount, this.__compositionType.getNumberOfComponents() * this.__arrayLength);
        subTypedArray._accessor = this;
        subTypedArray._idx_of_accessor = this.__takenCount;
        this.__takenCount += 1;
        return subTypedArray;
      }
      _takeExistedOne(idx) {
        const arrayBufferOfBufferView = this.__raw;
        if (idx >= this.__count) {
          Logger.error("You are trying to allocate more than you have secured.");
        }
        const subTypedArray = new this.__typedArrayClass(arrayBufferOfBufferView, this.__byteOffsetInRawArrayBufferOfBuffer + this.__byteStride * idx, this.__compositionType.getNumberOfComponents() * this.__arrayLength);
        subTypedArray._accessor = this;
        subTypedArray._idx_of_accessor = idx;
        return subTypedArray;
      }
      get takenCount() {
        return this.takenCount;
      }
      get numberOfComponents() {
        return this.__compositionType.getNumberOfComponents();
      }
      get componentSizeInBytes() {
        return this.__componentType.getSizeInBytes();
      }
      get elementSizeInBytes() {
        return this.numberOfComponents * this.componentSizeInBytes;
      }
      /**
      * get element count
      * element may be scalar, vec2, vec3, vec4, ...
      */
      get elementCount() {
        return this.__count;
      }
      get byteLength() {
        return this.__byteStride * this.__count;
      }
      get componentType() {
        return this.__componentType;
      }
      get compositionType() {
        return this.__compositionType;
      }
      /**
      *
      * @returns
      */
      getTypedArray() {
        return this.__typedArray;
      }
      getUint8Array() {
        return new Uint8Array(this.bufferView.buffer.getArrayBuffer(), this.byteOffsetInRawArrayBufferOfBuffer, this.byteLength);
      }
      get isAoS() {
        return !this.isSoA;
      }
      get isSoA() {
        const isSoA = this.byteStride === this.__compositionType.getNumberOfComponents() * this.__componentType.getSizeInBytes();
        return isSoA;
      }
      get byteStride() {
        return this.__byteStride;
      }
      getScalar(i2, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        return this.__dataViewGetter(this.__byteStride * index, endian);
      }
      getScalarAt(i2, compositionOffset, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        return this.__dataViewGetter(this.__byteStride * index + compositionOffset, endian);
      }
      getVec2AsArray(i2, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return [
          this.__dataViewGetter(this.__byteStride * index, endian),
          this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian)
        ];
      }
      getVec3AsArray(i2, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return [
          this.__dataViewGetter(this.__byteStride * index, endian),
          this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian)
        ];
      }
      getVec4AsArray(i2, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return [
          this.__dataViewGetter(this.__byteStride * index, endian),
          this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian)
        ];
      }
      getMat3AsArray(i2, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return [
          this.__dataViewGetter(this.__byteStride * index, endian),
          this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 4 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 5 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 6 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 7 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 8 * byteSize, endian)
        ];
      }
      getMat4AsArray(i2, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return [
          this.__dataViewGetter(this.__byteStride * index, endian),
          this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 4 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 5 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 6 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 7 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 8 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 9 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 10 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 11 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 12 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 13 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 14 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 15 * byteSize, endian)
        ];
      }
      getVec2(i2, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return Vector2.fromCopyArray2([
          this.__dataViewGetter(this.__byteStride * index, endian),
          this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian)
        ]);
      }
      getVec3(i2, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return Vector3.fromCopyArray([
          this.__dataViewGetter(this.__byteStride * index, endian),
          this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian)
        ]);
      }
      getVec4(i2, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return Vector4.fromCopyArray([
          this.__dataViewGetter(this.__byteStride * index, endian),
          this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian),
          this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian)
        ]);
      }
      getMat3(i2, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return Matrix33.fromCopy9RowMajor(this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 4 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 5 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 6 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 7 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 8 * byteSize, endian));
      }
      getMat4(i2, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return MutableMatrix44.fromCopy16RowMajor(this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 4 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 5 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 6 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 7 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 8 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 9 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 10 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 11 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 12 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 13 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 14 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 15 * byteSize, endian));
      }
      getVec2To(i2, out, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return out.setComponents(this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian));
      }
      getVec3To(i2, out, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return out.setComponents(this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian));
      }
      getVec4To(i2, out, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return out.setComponents(this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian));
      }
      getMat3To(i2, out, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return out.setComponents(this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 4 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 5 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 6 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 7 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 8 * byteSize, endian));
      }
      getMat4To(i2, out, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const byteSize = this.componentSizeInBytes;
        return out.setComponents(this.__dataViewGetter(this.__byteStride * index, endian), this.__dataViewGetter(this.__byteStride * index + 1 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 2 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 3 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 4 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 5 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 6 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 7 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 8 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 9 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 10 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 11 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 12 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 13 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 14 * byteSize, endian), this.__dataViewGetter(this.__byteStride * index + 15 * byteSize, endian));
      }
      setScalar(i2, value, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        this.__dataViewSetter(this.__byteStride * index, value, endian);
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      setVec2(i2, x, y, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const sizeInBytes = this.componentSizeInBytes;
        this.__dataViewSetter(this.__byteStride * index, x, endian);
        this.__dataViewSetter(this.__byteStride * index + 1 * sizeInBytes, y, endian);
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      setVec3(i2, x, y, z, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const sizeInBytes = this.componentSizeInBytes;
        this.__dataViewSetter(this.__byteStride * index, x, endian);
        this.__dataViewSetter(this.__byteStride * index + 1 * sizeInBytes, y, endian);
        this.__dataViewSetter(this.__byteStride * index + 2 * sizeInBytes, z, endian);
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      setVec4(i2, x, y, z, w, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const sizeInBytes = this.componentSizeInBytes;
        this.__dataViewSetter(this.__byteStride * index, x, endian);
        this.__dataViewSetter(this.__byteStride * index + 1 * sizeInBytes, y, endian);
        this.__dataViewSetter(this.__byteStride * index + 2 * sizeInBytes, z, endian);
        this.__dataViewSetter(this.__byteStride * index + 3 * sizeInBytes, w, endian);
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      setMat4(i2, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const sizeInBytes = this.componentSizeInBytes;
        this.__dataViewSetter(this.__byteStride * index, v0, endian);
        this.__dataViewSetter(this.__byteStride * index + 1 * sizeInBytes, v1, endian);
        this.__dataViewSetter(this.__byteStride * index + 2 * sizeInBytes, v2, endian);
        this.__dataViewSetter(this.__byteStride * index + 3 * sizeInBytes, v3, endian);
        this.__dataViewSetter(this.__byteStride * index + 4 * sizeInBytes, v4, endian);
        this.__dataViewSetter(this.__byteStride * index + 5 * sizeInBytes, v5, endian);
        this.__dataViewSetter(this.__byteStride * index + 6 * sizeInBytes, v6, endian);
        this.__dataViewSetter(this.__byteStride * index + 7 * sizeInBytes, v7, endian);
        this.__dataViewSetter(this.__byteStride * index + 8 * sizeInBytes, v8, endian);
        this.__dataViewSetter(this.__byteStride * index + 9 * sizeInBytes, v9, endian);
        this.__dataViewSetter(this.__byteStride * index + 10 * sizeInBytes, v10, endian);
        this.__dataViewSetter(this.__byteStride * index + 11 * sizeInBytes, v11, endian);
        this.__dataViewSetter(this.__byteStride * index + 12 * sizeInBytes, v12, endian);
        this.__dataViewSetter(this.__byteStride * index + 13 * sizeInBytes, v13, endian);
        this.__dataViewSetter(this.__byteStride * index + 14 * sizeInBytes, v14, endian);
        this.__dataViewSetter(this.__byteStride * index + 15 * sizeInBytes, v15, endian);
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      setVec2AsVector(i2, vec, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const sizeInBytes = this.componentSizeInBytes;
        this.__dataViewSetter(this.__byteStride * index, vec.x, endian);
        this.__dataViewSetter(this.__byteStride * index + 1 * sizeInBytes, vec.y, endian);
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      setVec3AsVector(i2, vec, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const sizeInBytes = this.componentSizeInBytes;
        this.__dataViewSetter(this.__byteStride * index, vec.x, endian);
        this.__dataViewSetter(this.__byteStride * index + 1 * sizeInBytes, vec.y, endian);
        this.__dataViewSetter(this.__byteStride * index + 2 * sizeInBytes, vec.z, endian);
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      setVec4AsVector(i2, vec, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const sizeInBytes = this.componentSizeInBytes;
        this.__dataViewSetter(this.__byteStride * index, vec.x, endian);
        this.__dataViewSetter(this.__byteStride * index + 1 * sizeInBytes, vec.y, endian);
        this.__dataViewSetter(this.__byteStride * index + 2 * sizeInBytes, vec.z, endian);
        this.__dataViewSetter(this.__byteStride * index + 3 * sizeInBytes, vec.w, endian);
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      setMat4AsMatrix44(i2, mat, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        const sizeInBytes = this.componentSizeInBytes;
        this.__dataViewSetter(this.__byteStride * index, mat._v[0], endian);
        this.__dataViewSetter(this.__byteStride * index + 1 * sizeInBytes, mat._v[1], endian);
        this.__dataViewSetter(this.__byteStride * index + 2 * sizeInBytes, mat._v[2], endian);
        this.__dataViewSetter(this.__byteStride * index + 3 * sizeInBytes, mat._v[3], endian);
        this.__dataViewSetter(this.__byteStride * index + 4 * sizeInBytes, mat._v[4], endian);
        this.__dataViewSetter(this.__byteStride * index + 5 * sizeInBytes, mat._v[5], endian);
        this.__dataViewSetter(this.__byteStride * index + 6 * sizeInBytes, mat._v[6], endian);
        this.__dataViewSetter(this.__byteStride * index + 7 * sizeInBytes, mat._v[7], endian);
        this.__dataViewSetter(this.__byteStride * index + 8 * sizeInBytes, mat._v[8], endian);
        this.__dataViewSetter(this.__byteStride * index + 9 * sizeInBytes, mat._v[9], endian);
        this.__dataViewSetter(this.__byteStride * index + 10 * sizeInBytes, mat._v[10], endian);
        this.__dataViewSetter(this.__byteStride * index + 11 * sizeInBytes, mat._v[11], endian);
        this.__dataViewSetter(this.__byteStride * index + 12 * sizeInBytes, mat._v[12], endian);
        this.__dataViewSetter(this.__byteStride * index + 13 * sizeInBytes, mat._v[13], endian);
        this.__dataViewSetter(this.__byteStride * index + 14 * sizeInBytes, mat._v[14], endian);
        this.__dataViewSetter(this.__byteStride * index + 15 * sizeInBytes, mat._v[15], endian);
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      copyFromTypedArray(typedArray) {
        const componentN = this.numberOfComponents;
        for (let j = 0; j < typedArray.byteLength / this.componentSizeInBytes; j++) {
          const idx = Math.floor(j / componentN);
          const idxN = idx * componentN;
          switch (componentN) {
            case 1:
              this.setScalar(idx, typedArray[idxN + 0], {});
              break;
            case 2:
              this.setVec2(idx, typedArray[idxN + 0], typedArray[idxN + 1], {});
              break;
            case 3:
              this.setVec3(idx, typedArray[idxN + 0], typedArray[idxN + 1], typedArray[idxN + 2], {});
              break;
            case 4:
              this.setVec4(idx, typedArray[idxN + 0], typedArray[idxN + 1], typedArray[idxN + 2], typedArray[idxN + 3], {});
              break;
            default:
              throw new Error("Other than vectors are currently not supported.");
          }
        }
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      setScalarAt(i2, compositionOffset, value, { indicesAccessor, endian = true }) {
        let index = i2;
        if (indicesAccessor) {
          index = indicesAccessor.getScalar(i2, {});
        }
        this.__dataViewSetter(this.__byteStride * index + compositionOffset, value, endian);
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      setElementFromSameCompositionAccessor(i2, accessor, secondIdx) {
        const j = secondIdx != null ? secondIdx : i2;
        if (this.compositionType.getNumberOfComponents() === 1) {
          this.setScalar(i2, accessor.getScalar(j, {}), {});
        } else if (this.compositionType.getNumberOfComponents() === 2) {
          this.setVec2AsVector(i2, accessor.getVec2(j, {}), {});
        } else if (this.compositionType.getNumberOfComponents() === 3) {
          this.setVec3AsVector(i2, accessor.getVec3(j, {}), {});
        } else if (this.compositionType.getNumberOfComponents() === 4) {
          this.setVec4AsVector(i2, accessor.getVec4(j, {}), {});
        }
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      copyBuffer(accessor) {
        new Uint8Array(this.__raw).set(new Uint8Array(accessor.__raw, accessor.__byteOffsetInRawArrayBufferOfBuffer, accessor.byteLength), this.__byteOffsetInRawArrayBufferOfBuffer);
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      setElementFromAccessor(i2, accessor, secondIdx) {
        const j = secondIdx != null ? secondIdx : i2;
        if (this.compositionType.getNumberOfComponents() === 1) {
          if (accessor.compositionType.getNumberOfComponents() === 1) {
            this.setScalar(i2, accessor.getScalar(j, {}), {});
          } else if (accessor.compositionType.getNumberOfComponents() === 2) {
            this.setScalar(i2, accessor.getVec2(j, {}).x, {});
          } else if (accessor.compositionType.getNumberOfComponents() === 3) {
            this.setScalar(i2, accessor.getVec3(j, {}).x, {});
          } else if (accessor.compositionType.getNumberOfComponents() === 4) {
            this.setScalar(i2, accessor.getVec4(j, {}).x, {});
          }
        } else if (this.compositionType.getNumberOfComponents() === 2) {
          if (accessor.compositionType.getNumberOfComponents() === 1) {
            const scalar = accessor.getScalar(j, {});
            this.setVec2(i2, scalar, 0, {});
          } else if (accessor.compositionType.getNumberOfComponents() === 2) {
            this.setVec2AsVector(i2, accessor.getVec2(j, {}), {});
          } else if (accessor.compositionType.getNumberOfComponents() === 3) {
            const vec = accessor.getVec3(j, {});
            this.setVec2(i2, vec.x, vec.y, {});
          } else if (accessor.compositionType.getNumberOfComponents() === 4) {
            const vec = accessor.getVec4(j, {});
            this.setVec2(i2, vec.x, vec.y, {});
          }
        } else if (this.compositionType.getNumberOfComponents() === 3) {
          if (accessor.compositionType.getNumberOfComponents() === 1) {
            const scalar = accessor.getScalar(j, {});
            this.setVec3(i2, scalar, 0, 0, {});
          } else if (accessor.compositionType.getNumberOfComponents() === 2) {
            const vec = accessor.getVec2(j, {});
            this.setVec3(i2, vec.x, vec.y, 0, {});
          } else if (accessor.compositionType.getNumberOfComponents() === 3) {
            const vec = accessor.getVec3(j, {});
            this.setVec3AsVector(i2, vec, {});
          } else if (accessor.compositionType.getNumberOfComponents() === 4) {
            const vec = accessor.getVec4(j, {});
            this.setVec3(i2, vec.x, vec.y, vec.z, {});
          }
        } else if (this.compositionType.getNumberOfComponents() === 4) {
          if (accessor.compositionType.getNumberOfComponents() === 1) {
            const scalar = accessor.getScalar(j, {});
            this.setVec4(i2, scalar, 0, 0, 0, {});
          } else if (accessor.compositionType.getNumberOfComponents() === 2) {
            const vec = accessor.getVec2(j, {});
            this.setVec4(i2, vec.x, vec.y, 0, 0, {});
          } else if (accessor.compositionType.getNumberOfComponents() === 3) {
            const vec = accessor.getVec3(j, {});
            this.setVec4(i2, vec.x, vec.y, vec.z, 0, {});
          } else if (accessor.compositionType.getNumberOfComponents() === 4) {
            const vec = accessor.getVec4(j, {});
            this.setVec4AsVector(i2, vec, {});
          }
        }
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      addElementFromSameCompositionAccessor(i2, accessor, coeff, secondIdx) {
        const j = secondIdx != null ? secondIdx : i2;
        if (this.compositionType.getNumberOfComponents() === 1) {
          this.setScalar(i2, this.getScalar(i2, {}) + coeff * accessor.getScalar(j, {}), {});
        } else if (this.compositionType.getNumberOfComponents() === 2) {
          this.setVec2AsVector(i2, Vector2.add(this.getVec2(i2, {}), Vector2.multiply(accessor.getVec2(j, {}), coeff)), {});
        } else if (this.compositionType.getNumberOfComponents() === 3) {
          this.setVec3AsVector(i2, Vector3.add(this.getVec3(i2, {}), Vector3.multiply(accessor.getVec3(j, {}), coeff)), {});
        } else if (this.compositionType.getNumberOfComponents() === 4) {
          this.setVec4AsVector(i2, Vector4.add(this.getVec4(i2, {}), Vector4.multiply(accessor.getVec4(j, {}), coeff)), {});
        }
        this.__isMinMixDirty = true;
        this.__onUpdated();
      }
      get arrayBufferOfBufferView() {
        return this.__raw;
      }
      get dataViewOfBufferView() {
        return this.__dataView;
      }
      get byteOffsetInBufferView() {
        return this.__byteOffsetInRawArrayBufferOfBuffer - this.__bufferView.byteOffsetInRawArrayBufferOfBuffer;
      }
      get byteOffsetInBuffer() {
        return this.__byteOffsetInRawArrayBufferOfBuffer - this.__bufferView.buffer.byteOffsetInRawArrayBuffer;
      }
      get byteOffsetInRawArrayBufferOfBuffer() {
        return this.__byteOffsetInRawArrayBufferOfBuffer;
      }
      get bufferView() {
        return this.__bufferView;
      }
      setMinMax(min, max) {
        const componentN = this.compositionType.getNumberOfComponents();
        if (componentN === 1) {
          this.__min._v[0] = min[0];
          this.__max._v[0] = max[0];
        } else if (componentN === 2) {
          this.__min._v[0] = min[0];
          this.__min._v[1] = min[1];
          this.__max._v[0] = max[0];
          this.__max._v[1] = max[1];
        } else if (componentN === 3) {
          this.__min._v[0] = min[0];
          this.__min._v[1] = min[1];
          this.__min._v[2] = min[2];
          this.__max._v[0] = max[0];
          this.__max._v[1] = max[1];
          this.__max._v[2] = max[2];
        } else if (componentN === 4) {
          this.__min._v[0] = min[0];
          this.__min._v[1] = min[1];
          this.__min._v[2] = min[2];
          this.__min._v[3] = min[3];
          this.__max._v[0] = max[0];
          this.__max._v[1] = max[1];
          this.__max._v[2] = max[2];
          this.__max._v[3] = max[3];
        }
        this.__isMinMixDirty = false;
      }
      get min() {
        if (this.__isMinMixDirty) {
          this.__calcMinMax();
        }
        const componentN = this.compositionType.getNumberOfComponents();
        if (componentN === 4) {
          return [
            this.__min._v[0],
            this.__min._v[1],
            this.__min._v[2],
            this.__min._v[3]
          ];
        } else if (componentN === 3) {
          return [
            this.__min._v[0],
            this.__min._v[1],
            this.__min._v[2]
          ];
        } else if (componentN === 2) {
          return [
            this.__min._v[0],
            this.__min._v[1]
          ];
        } else {
          return [
            this.__min._v[0]
          ];
        }
      }
      get max() {
        if (this.__isMinMixDirty) {
          this.__calcMinMax();
        }
        const componentN = this.compositionType.getNumberOfComponents();
        if (componentN === 4) {
          return [
            this.__max._v[0],
            this.__max._v[1],
            this.__max._v[2],
            this.__max._v[3]
          ];
        } else if (componentN === 3) {
          return [
            this.__max._v[0],
            this.__max._v[1],
            this.__max._v[2]
          ];
        } else if (componentN === 2) {
          return [
            this.__max._v[0],
            this.__max._v[1]
          ];
        } else {
          return [
            this.__max._v[0]
          ];
        }
      }
      get normalized() {
        return this.__normalized;
      }
      __calcMinMax() {
        const componentN = this.compositionType.getNumberOfComponents();
        if (componentN === 4) {
          this.__max.setComponents(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
          this.__min.setComponents(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
          const vec4 = _Accessor.__tmpVector4_0;
          for (let i2 = 0; i2 < this.elementCount; i2++) {
            this.getVec4To(i2, vec4, {});
            for (let j = 0; j < 4; j++) {
              if (this.__max._v[j] < vec4._v[j]) {
                this.__max._v[j] = vec4._v[j];
              }
              if (vec4._v[j] < this.__min._v[j]) {
                this.__min._v[j] = vec4._v[j];
              }
            }
          }
        } else if (componentN === 3) {
          this.__max.setComponents(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
          this.__min.setComponents(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
          const vec3 = _Accessor.__tmpVector3_0;
          for (let i2 = 0; i2 < this.elementCount; i2++) {
            this.getVec3To(i2, vec3, {});
            for (let j = 0; j < 3; j++) {
              if (this.__max._v[j] < vec3._v[j]) {
                this.__max._v[j] = vec3._v[j];
              }
              if (vec3._v[j] < this.__min._v[j]) {
                this.__min._v[j] = vec3._v[j];
              }
            }
          }
        } else if (componentN === 2) {
          this.__max.setComponents(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
          this.__min.setComponents(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
          const vec2 = _Accessor.__tmpVector2_0;
          for (let i2 = 0; i2 < this.elementCount; i2++) {
            this.getVec2To(i2, vec2, {});
            for (let j = 0; j < 2; j++) {
              if (this.__max._v[j] < vec2._v[j]) {
                this.__max._v[j] = vec2._v[j];
              }
              if (vec2._v[j] < this.__min._v[j]) {
                this.__min._v[j] = vec2._v[j];
              }
            }
          }
        } else if (componentN === 1) {
          this.__max.setComponents(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
          this.__min.setComponents(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
          for (let i2 = 0; i2 < this.elementCount; i2++) {
            const scalar = this.getScalar(i2, {});
            if (this.__max._v[0] < scalar) {
              this.__max._v[0] = scalar;
            }
            if (scalar < this.__min._v[0]) {
              this.__min._v[0] = scalar;
            }
          }
        }
        this.__isMinMixDirty = false;
      }
      get isMinMaxDirty() {
        return this.__isMinMixDirty;
      }
      get version() {
        return this.__version;
      }
      get actualByteStride() {
        if (this.__byteStride === 0) {
          const actualByteStride = this.__compositionType.getNumberOfComponents() * this.__componentType.getSizeInBytes() * this.__arrayLength;
          return actualByteStride;
        } else {
          return this.__byteStride;
        }
      }
      isSame(rnAccessor) {
        return this.byteLength === rnAccessor.byteLength && this.byteOffsetInRawArrayBufferOfBuffer === rnAccessor.byteOffsetInRawArrayBufferOfBuffer && this.bufferView.buffer.getArrayBuffer() === rnAccessor.bufferView.buffer.getArrayBuffer();
      }
    };
    __name(_Accessor, "Accessor");
    __publicField(_Accessor, "__tmpVector4_0", MutableVector4.zero());
    __publicField(_Accessor, "__tmpVector3_0", MutableVector3.zero());
    __publicField(_Accessor, "__tmpVector2_0", MutableVector2.zero());
    Accessor = _Accessor;
  }
});

// src/foundation/memory/BufferView.ts
var _BufferView, BufferView;
var init_BufferView = __esm({
  "src/foundation/memory/BufferView.ts"() {
    "use strict";
    init_Accessor();
    init_misc();
    _BufferView = class _BufferView {
      constructor({ buffer, byteOffsetInBuffer, defaultByteStride, byteLength, raw }) {
        __publicField(this, "__buffer");
        __publicField(this, "__byteOffsetInRawArrayBufferOfBuffer");
        __publicField(this, "__byteOffsetInBuffer");
        __publicField(this, "__byteLength");
        __publicField(this, "__defaultByteStride", 0);
        __publicField(this, "__takenByte", 0);
        __publicField(this, "__takenAccessorCount", 0);
        __publicField(this, "__raw");
        __publicField(this, "__accessors", []);
        this.__buffer = buffer;
        this.__byteOffsetInBuffer = byteOffsetInBuffer;
        this.__byteOffsetInRawArrayBufferOfBuffer = buffer.byteOffsetInRawArrayBuffer + byteOffsetInBuffer;
        this.__byteLength = byteLength;
        this.__defaultByteStride = defaultByteStride;
        this.__raw = raw;
      }
      get defaultByteStride() {
        return this.__defaultByteStride;
      }
      get byteLength() {
        return this.__byteLength;
      }
      /**
      * byteOffset in Buffer (includes byteOffset of Buffer in it's inner arraybuffer)
      */
      get byteOffsetInBuffer() {
        return this.__byteOffsetInRawArrayBufferOfBuffer - this.__buffer.byteOffsetInRawArrayBuffer;
      }
      /**
      * byteOffset in Buffer (includes byteOffset of Buffer in it's inner arraybuffer)
      */
      get byteOffsetInRawArrayBufferOfBuffer() {
        return this.__byteOffsetInRawArrayBufferOfBuffer;
      }
      get buffer() {
        return this.__buffer;
      }
      get isSoA() {
        return !this.isAoS;
      }
      get isAoS() {
        for (const accessor of this.__accessors) {
          if (accessor.isAoS) {
            return true;
          }
        }
        return false;
      }
      /**
      * get memory buffer as Uint8Array of this BufferView memory area data
      */
      getUint8Array() {
        return new Uint8Array(this.__raw, this.__byteOffsetInRawArrayBufferOfBuffer, this.__byteLength);
      }
      takeAccessor({ compositionType, componentType, count, byteStride = this.defaultByteStride, max, min, arrayLength = 1, normalized = false }) {
        const accessor = this.__takeAccessorInner({
          compositionType,
          componentType,
          count,
          byteStride,
          max,
          min,
          normalized,
          arrayLength
        });
        return accessor;
      }
      takeAccessorWithByteOffset({ compositionType, componentType, count, byteOffsetInBufferView, byteStride = this.defaultByteStride, max, min, normalized = false }) {
        const accessor = this.__takeAccessorInnerWithByteOffset({
          compositionType,
          componentType,
          count,
          byteStride,
          byteOffsetInBufferView,
          max,
          min,
          normalized
        });
        return accessor;
      }
      __takeAccessorInner({ compositionType, componentType, count, byteStride, max, min, arrayLength, normalized }) {
        const byteOffsetInBufferView = this.__takenByte;
        let actualByteStride = byteStride;
        if (actualByteStride === 0) {
          actualByteStride = compositionType.getNumberOfComponents() * componentType.getSizeInBytes() * arrayLength;
        }
        if (this.__takenByte + actualByteStride * (count - 1) + componentType.getSizeInBytes() * compositionType.getNumberOfComponents() > this.byteLength) {
          const message = `The size of the Accessor you are trying to take exceeds the byte length left in the BufferView.
BufferView.byteLength: ${this.byteLength}, BufferView.takenSizeInByte: ${this.__takenByte}, Accessor.byteStride: ${byteStride}, Accessor.count: ${count};
byteSizeToTake: ${actualByteStride * count}, the byte length left in the Buffer: ${this.byteLength - this.__takenByte}`;
          return new Err({
            message,
            error: void 0
          });
        }
        const accessor = new Accessor({
          bufferView: this,
          byteOffsetInBufferView,
          compositionType,
          componentType,
          byteStride,
          count,
          raw: this.__raw,
          max,
          min,
          arrayLength,
          normalized
        });
        this.__accessors.push(accessor);
        this.__takenByte += actualByteStride * count;
        return new Ok(accessor);
      }
      __takeAccessorInnerWithByteOffset({ compositionType, componentType, count, byteStride, byteOffsetInBufferView, max, min, normalized }) {
        if (this.__takenByte + byteStride * (count - 1) + componentType.getSizeInBytes() * compositionType.getNumberOfComponents() > this.byteLength) {
          const message = `The size of the Accessor you are trying to take exceeds the byte length left in the BufferView.
BufferView.byteLength: ${this.byteLength}, BufferView.takenSizeInByte: ${this.__takenByte}, Accessor.byteStride: ${byteStride}, Accessor.count: ${count};
byteSizeToTake: ${byteStride * count}, the byte length left in the Buffer: ${this.byteLength - this.__takenByte}`;
          return new Err({
            message,
            error: void 0
          });
        }
        const accessor = new Accessor({
          bufferView: this,
          byteOffsetInBufferView,
          compositionType,
          componentType,
          byteStride,
          count,
          raw: this.__raw,
          max,
          min,
          arrayLength: 1,
          normalized
        });
        this.__accessors.push(accessor);
        return new Ok(accessor);
      }
      isSame(rnBufferView) {
        return this.byteLength === rnBufferView.byteLength && this.byteOffsetInRawArrayBufferOfBuffer === rnBufferView.byteOffsetInRawArrayBufferOfBuffer && this.defaultByteStride === rnBufferView.defaultByteStride && this.buffer.getArrayBuffer() === rnBufferView.buffer.getArrayBuffer();
      }
    };
    __name(_BufferView, "BufferView");
    BufferView = _BufferView;
  }
});

// src/foundation/memory/Buffer.ts
var _Buffer, Buffer2;
var init_Buffer = __esm({
  "src/foundation/memory/Buffer.ts"() {
    "use strict";
    init_BufferView();
    init_CompositionType();
    init_ComponentType();
    init_DataUtil();
    init_Result();
    init_Logger();
    _Buffer = class _Buffer {
      constructor({ byteLength, buffer, name, byteAlign }) {
        __publicField(this, "__byteLength", 0);
        __publicField(this, "__byteOffset", 0);
        __publicField(this, "__takenBytesIndex", 0);
        __publicField(this, "__byteAlign");
        __publicField(this, "__raw");
        __publicField(this, "__name", "");
        __publicField(this, "__bufferViews", []);
        this.__name = name;
        this.__byteLength = byteLength;
        this.__byteAlign = byteAlign;
        if (buffer instanceof Uint8Array) {
          this.__raw = buffer.buffer;
          this.__byteOffset = buffer.byteOffset;
        } else {
          this.__raw = buffer;
        }
      }
      set name(str) {
        this.__name = str;
      }
      get name() {
        return this.__name;
      }
      getArrayBuffer() {
        return this.__raw;
      }
      __padding(byteLengthToNeed, byteAlign) {
        const paddingSize = DataUtil.calcPaddingBytes(byteLengthToNeed, byteAlign);
        if (paddingSize > 0) {
          Logger.info("Padding bytes added to takenBytesIndex.");
        }
        return paddingSize;
      }
      takeBufferView({ byteLengthToNeed, byteStride }) {
        const byteSizeToTake = byteLengthToNeed;
        if (byteSizeToTake + this.__takenBytesIndex > this.byteLength) {
          const message = `The size of the BufferView you are trying to take exceeds the byte length left in the Buffer.
Buffer.byteLength: ${this.byteLength}, Buffer.takenSizeInByte: ${this.takenSizeInByte},
byteSizeToTake: ${byteSizeToTake}, the byte length left in the Buffer: ${this.__byteLength - this.__takenBytesIndex}`;
          return new Err({
            message,
            error: {
              "Buffer.byteLength": this.takenSizeInByte,
              "Buffer.takenSizeInByte": this.takenSizeInByte
            }
          });
        }
        const bufferView = new BufferView({
          buffer: this,
          byteOffsetInBuffer: this.__takenBytesIndex,
          defaultByteStride: byteStride,
          byteLength: byteSizeToTake,
          raw: this.__raw
        });
        this.__takenBytesIndex += byteSizeToTake;
        this.__takenBytesIndex = DataUtil.addPaddingBytes(this.__takenBytesIndex, this.__byteAlign);
        this.__bufferViews.push(bufferView);
        return new Ok(bufferView);
      }
      takeBufferViewWithByteOffset({ byteLengthToNeed, byteStride, byteOffset }) {
        const byteSizeToTake = byteLengthToNeed;
        if (byteSizeToTake + byteOffset > this.byteLength) {
          const message = `The size of the BufferView you are trying to take exceeds the byte length left in the Buffer.
Buffer.byteLength: ${this.byteLength}, Buffer.takenSizeInByte: ${this.takenSizeInByte},
byteSizeToTake: ${byteLengthToNeed}, the byte length left in the Buffer: ${this.__byteLength - this.__takenBytesIndex}`;
          return new Err({
            message,
            error: void 0
          });
        }
        const bufferView = new BufferView({
          buffer: this,
          byteOffsetInBuffer: byteOffset,
          defaultByteStride: byteStride,
          byteLength: byteLengthToNeed,
          raw: this.__raw
        });
        const takenBytesIndex = Uint8Array.BYTES_PER_ELEMENT * byteLengthToNeed + byteOffset;
        if (this.__takenBytesIndex < takenBytesIndex) {
          this.__takenBytesIndex = takenBytesIndex;
        }
        this.__bufferViews.push(bufferView);
        return new Ok(bufferView);
      }
      _addTakenByteIndex(value) {
        this.__takenBytesIndex += value;
      }
      get byteLength() {
        return this.__byteLength;
      }
      get takenSizeInByte() {
        return this.__takenBytesIndex;
      }
      get byteOffsetInRawArrayBuffer() {
        return this.__byteOffset;
      }
      getTypedArray(offset4bytesUnit, compositionType, componentType, length = 100) {
        let ret;
        const typedArray = ComponentType.toTypedArray(componentType);
        if (typedArray === void 0) {
          Logger.warn("componentType is Invalid");
        }
        if (CompositionType.isArray(compositionType)) {
          ret = new typedArray(this.__raw, this.__byteOffset + offset4bytesUnit * 4, length);
        } else {
          ret = new typedArray(this.__raw, this.__byteOffset + offset4bytesUnit * 4, 1);
        }
        return ret;
      }
      isSame(buffer) {
        return this.__raw === buffer.__raw;
      }
    };
    __name(_Buffer, "Buffer");
    Buffer2 = _Buffer;
  }
});

// src/foundation/definitions/BufferUse.ts
function from4(index) {
  return _from({
    typeList: typeList4,
    index
  });
}
function fromString4(str) {
  return _fromString({
    typeList: typeList4,
    str
  });
}
var _a6, BufferUseClass, GPUInstanceData, GPUVertexData, UBOGeneric, CPUGeneric, typeList4, BufferUse;
var init_BufferUse = __esm({
  "src/foundation/definitions/BufferUse.ts"() {
    "use strict";
    init_EnumIO();
    BufferUseClass = (_a6 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a6, "BufferUseClass"), _a6);
    GPUInstanceData = new BufferUseClass({
      index: 0,
      str: "GPUInstanceData"
    });
    GPUVertexData = new BufferUseClass({
      index: 1,
      str: "GPUVertexData"
    });
    UBOGeneric = new BufferUseClass({
      index: 2,
      str: "UBOGeneric"
    });
    CPUGeneric = new BufferUseClass({
      index: 3,
      str: "CPUGeneric"
    });
    typeList4 = [
      GPUInstanceData,
      GPUVertexData,
      UBOGeneric,
      CPUGeneric
    ];
    __name(from4, "from");
    __name(fromString4, "fromString");
    BufferUse = Object.freeze({
      GPUInstanceData,
      GPUVertexData,
      UBOGeneric,
      CPUGeneric,
      from: from4,
      fromString: fromString4
    });
  }
});

// src/foundation/core/MemoryManager.ts
var _MemoryManager, MemoryManager;
var init_MemoryManager = __esm({
  "src/foundation/core/MemoryManager.ts"() {
    "use strict";
    init_Buffer();
    init_BufferUse();
    init_Config();
    init_MiscUtil();
    _MemoryManager = class _MemoryManager {
      constructor(cpuGeneric, gpuInstanceData, gpuVertexData) {
        //__entityMaxCount: number;
        __publicField(this, "__buffers", {});
        __publicField(this, "__buffersOnDemand", /* @__PURE__ */ new Map());
        __publicField(this, "__memorySizeRatios", {});
        this.__memorySizeRatios[BufferUse.CPUGeneric.str] = cpuGeneric;
        this.__memorySizeRatios[BufferUse.GPUInstanceData.str] = gpuInstanceData;
        this.__memorySizeRatios[BufferUse.GPUVertexData.str] = gpuVertexData;
      }
      static createInstanceIfNotCreated({ cpuGeneric, gpuInstanceData, gpuVertexData }) {
        if (!this.__instance) {
          this.__instance = new _MemoryManager(cpuGeneric, gpuInstanceData, gpuVertexData);
          return this.__instance;
        }
        return this.__instance;
      }
      __makeMultipleOf4byteSize(memorySize) {
        return memorySize + (memorySize % 4 === 0 ? 0 : 4 - memorySize % 4);
      }
      static getInstance() {
        return this.__instance;
      }
      getMemorySize() {
        return _MemoryManager.bufferWidthLength * _MemoryManager.bufferHeightLength * 4 * 4;
      }
      __createBuffer(bufferUse) {
        const memorySize = this.getMemorySize() * this.__memorySizeRatios[bufferUse.str];
        const arrayBuffer = new ArrayBuffer(this.__makeMultipleOf4byteSize(memorySize));
        let byteAlign = 4;
        if (bufferUse === BufferUse.GPUInstanceData || bufferUse === BufferUse.GPUVertexData) {
          byteAlign = 16;
        }
        const buffer = new Buffer2({
          byteLength: arrayBuffer.byteLength,
          buffer: arrayBuffer,
          name: bufferUse.str,
          byteAlign
        });
        this.__buffers[buffer.name] = buffer;
        return buffer;
      }
      getBuffer(bufferUse) {
        const buffer = this.__buffers[bufferUse.toString()];
        return buffer;
      }
      createOrGetBuffer(bufferUse) {
        let buffer = this.__buffers[bufferUse.toString()];
        if (buffer == null) {
          buffer = this.__createBuffer(bufferUse);
        }
        return buffer;
      }
      createBufferOnDemand(size, object, byteAlign) {
        const arrayBuffer = new ArrayBuffer(size);
        const buffer = new Buffer2({
          byteLength: arrayBuffer.byteLength,
          buffer: arrayBuffer,
          name: BufferUse.UBOGeneric.toString(),
          byteAlign
        });
        this.__buffersOnDemand.set(object.objectUID, buffer);
        return buffer;
      }
      getBufferOnDemand(object) {
        return this.__buffersOnDemand.get(object.objectUID);
      }
      static get bufferWidthLength() {
        return Config.dataTextureWidth;
      }
      static get bufferHeightLength() {
        return Config.dataTextureHeight;
      }
      printMemoryUsage() {
        const cpuGeneric = this.__buffers[BufferUse.CPUGeneric.toString()];
        const gpuInstanceData = this.__buffers[BufferUse.GPUInstanceData.toString()];
        const gpuVertexData = this.__buffers[BufferUse.GPUVertexData.toString()];
        console.log("Memory Usage in Memory Manager:");
        console.log(`CPUGeneric: ${cpuGeneric.takenSizeInByte} byte of ${cpuGeneric.byteLength} bytes. (${cpuGeneric.takenSizeInByte / cpuGeneric.byteLength * 100} %) `);
        console.log(`GPUInstanceData: ${gpuInstanceData.takenSizeInByte} byte of ${gpuInstanceData.byteLength} bytes. (${gpuInstanceData.takenSizeInByte / gpuInstanceData.byteLength * 100} %) `);
        if (gpuVertexData != null) {
          console.log(`GPUVertexData: ${gpuVertexData.takenSizeInByte} byte of ${gpuVertexData.byteLength} bytes. (${gpuVertexData.takenSizeInByte / gpuVertexData.byteLength * 100} %) `);
        }
      }
      dumpBuffer(bufferUse) {
        const buffer = this.__buffers[bufferUse.toString()];
        MiscUtil.downloadArrayBuffer(bufferUse.toString(), buffer.getArrayBuffer());
        return buffer;
      }
    };
    __name(_MemoryManager, "MemoryManager");
    __publicField(_MemoryManager, "__instance");
    MemoryManager = _MemoryManager;
  }
});

// src/foundation/definitions/ProcessStage.ts
function from5(index) {
  return _from({
    typeList: typeList5,
    index
  });
}
var _a7, ProcessStageClass, Unknown3, Create, Load, Mount, Logic, PreRender, Render, Unmount, Discard, typeList5, ProcessStage;
var init_ProcessStage = __esm({
  "src/foundation/definitions/ProcessStage.ts"() {
    "use strict";
    init_EnumIO();
    ProcessStageClass = (_a7 = class extends EnumClass {
      constructor({ index, str, methodName }) {
        super({
          index,
          str
        });
        __publicField(this, "methodName");
        this.methodName = methodName;
      }
    }, __name(_a7, "ProcessStageClass"), _a7);
    Unknown3 = new ProcessStageClass({
      index: -1,
      str: "UNKNOWN",
      methodName: "$unknown"
    });
    Create = new ProcessStageClass({
      index: 0,
      str: "CREATE",
      methodName: "$create"
    });
    Load = new ProcessStageClass({
      index: 1,
      str: "LOAD",
      methodName: "$load"
    });
    Mount = new ProcessStageClass({
      index: 2,
      str: "MOUNT",
      methodName: "$mount"
    });
    Logic = new ProcessStageClass({
      index: 3,
      str: "LOGIC",
      methodName: "$logic"
    });
    PreRender = new ProcessStageClass({
      index: 4,
      str: "PRE_RENDER",
      methodName: "$prerender"
    });
    Render = new ProcessStageClass({
      index: 5,
      str: "RENDER",
      methodName: "$render"
    });
    Unmount = new ProcessStageClass({
      index: 6,
      str: "UNMOUNT",
      methodName: "$unmount"
    });
    Discard = new ProcessStageClass({
      index: 7,
      str: "DISCARD",
      methodName: "$discard"
    });
    typeList5 = [
      Unknown3,
      Create,
      Load,
      Mount,
      Logic,
      PreRender,
      Render,
      Unmount,
      Discard
    ];
    __name(from5, "from");
    ProcessStage = Object.freeze({
      Unknown: Unknown3,
      Create,
      Load,
      Mount,
      Logic,
      PreRender,
      Render,
      Unmount,
      Discard,
      from: from5
    });
  }
});

// src/foundation/components/WellKnownComponentTIDs.ts
var AnimationStateComponentTID, AnimationComponentTID, TransformComponentTID, SceneGraphComponentTID, MeshComponentTID, MeshRendererComponentTID, LightComponentTID, CameraControllerComponentTID, CameraComponentTID, SkeletalComponentTID, BlendShapeComponentTID, PhysicsComponentTID, EffekseerComponentTID, VrmComponentTID, ConstraintComponentTID, maxWellKnownTidNumber, WellKnownComponentTIDs;
var init_WellKnownComponentTIDs = __esm({
  "src/foundation/components/WellKnownComponentTIDs.ts"() {
    "use strict";
    AnimationStateComponentTID = 1;
    AnimationComponentTID = 2;
    TransformComponentTID = 3;
    SceneGraphComponentTID = 4;
    MeshComponentTID = 5;
    MeshRendererComponentTID = 6;
    LightComponentTID = 7;
    CameraControllerComponentTID = 8;
    CameraComponentTID = 9;
    SkeletalComponentTID = 10;
    BlendShapeComponentTID = 11;
    PhysicsComponentTID = 12;
    EffekseerComponentTID = 13;
    VrmComponentTID = 14;
    ConstraintComponentTID = 15;
    maxWellKnownTidNumber = 15;
    WellKnownComponentTIDs = Object.freeze({
      AnimationStateComponentTID,
      AnimationComponentTID,
      TransformComponentTID,
      SceneGraphComponentTID,
      MeshComponentTID,
      MeshRendererComponentTID,
      LightComponentTID,
      CameraControllerComponentTID,
      CameraComponentTID,
      SkeletalComponentTID,
      BlendShapeComponentTID,
      PhysicsComponentTID,
      EffekseerComponentTID,
      VrmComponentTID,
      ConstraintComponentTID,
      maxWellKnownTidNumber
    });
  }
});

// src/foundation/core/ComponentRepository.ts
var _ComponentRepository, ComponentRepository;
var init_ComponentRepository = __esm({
  "src/foundation/core/ComponentRepository.ts"() {
    "use strict";
    init_Is();
    init_Config();
    init_WellKnownComponentTIDs();
    _ComponentRepository = class _ComponentRepository {
      constructor() {
      }
      /**
      * Registers the class object of the component.
      * @param componentClass A class object of the component.
      */
      static registerComponentClass(componentClass) {
        const thisClass = _ComponentRepository;
        thisClass.__componentClasses.set(componentClass.componentTID, componentClass);
      }
      /**
      * deregister the component.
      * @param componentTID A componentTID
      */
      static deregisterComponentClass(componentTID) {
        const thisClass = _ComponentRepository;
        thisClass.__componentClasses.delete(componentTID);
      }
      /**
      * Gets the class object of the component corresponding to specified ComponentTID.
      * @param componentTid The componentTID to get the class object.
      */
      static getComponentClass(componentTid) {
        return this.__componentClasses.get(componentTid);
      }
      /**
      * Creates an instance of the component for the entity.
      * @param componentTid The componentTID to create the instance.
      * @param entityUid The entityUID of the entity.
      * @param entityRepository the reference of the entityRepository.
      */
      static createComponent(componentTid, entityUid, entityRepository) {
        const thisClass = _ComponentRepository;
        const componentClass = thisClass.__componentClasses.get(componentTid);
        if (Is.exist(componentClass)) {
          let component_sid_count = this.__component_sid_count_map.get(componentTid);
          if (Is.not.exist(component_sid_count)) {
            this.__component_sid_count_map.set(componentTid, 0);
            component_sid_count = _ComponentRepository.invalidComponentSID;
          }
          const componentArray = this.__components.get(componentTid);
          let undefinedSid = -1;
          if (Is.exist(componentArray)) {
            for (let i2 = 0; i2 < componentArray.length; i2++) {
              if (Is.not.exist(componentArray[i2])) {
                undefinedSid = i2;
                break;
              }
            }
          }
          let componentSid = -1;
          let isReUse = false;
          if (undefinedSid === -1) {
            this.__component_sid_count_map.set(componentTid, ++component_sid_count);
            componentSid = component_sid_count;
          } else {
            componentSid = undefinedSid;
            isReUse = true;
          }
          const component = new componentClass(entityUid, componentSid, entityRepository, isReUse);
          if (!this.__components.has(componentTid)) {
            this.__components.set(componentTid, []);
            this.__updateComponentTIDs();
          }
          const array = this.__components.get(componentTid);
          array[component.componentSID] = component;
          return component;
        } else {
          throw new Error("The Component Class object is invalid.");
        }
      }
      static deleteComponent(component) {
        const thisClass = _ComponentRepository;
        const componentTid = component.componentTID;
        const componentSid = component.componentSID;
        const array = thisClass.__components.get(componentTid);
        if (array != null) {
          delete array[componentSid];
        }
      }
      /**
      * Get the instance of the component corresponding to the component class and componentSID.
      * @param componentClass The class object to get the component.
      * @param componentSid The componentSID to get the component.
      */
      static getComponent(componentClass, componentSid) {
        return this.getComponentFromComponentTID(componentClass.componentTID, componentSid);
      }
      /**
      * Get the instance of the component corresponding to the componentTID and componentSID.
      * @param componentTid The componentTID to get the component.
      * @param componentSid The componentSID to get the component.
      */
      static getComponentFromComponentTID(componentTid, componentSid) {
        const map = this.__components.get(componentTid);
        if (map != null) {
          const component = map[componentSid];
          if (component != null) {
            return map[componentSid];
          } else {
            return void 0;
          }
        }
        return void 0;
      }
      /**
      * @internal
      * Gets an array of components corresponding to the class object of the component.
      * @param componentClass The class object of the component.
      */
      static _getComponents(componentClass) {
        const components = this.__components.get(componentClass.componentTID);
        return components;
      }
      /**
      * @internal
      * Gets an array of components corresponding to the class object of the component (dead components included).
      * @param componentClass The class object of the component.
      */
      static _getComponentsIncludingDead(componentClass) {
        const components = this.__components.get(componentClass.componentTID);
        return components;
      }
      static getMemoryBeginIndex(componentTid) {
        let memoryBeginIndex = 0;
        for (let i2 = 0; i2 < componentTid; i2++) {
          const componentClass = _ComponentRepository.__componentClasses.get(i2);
          if (componentClass != null) {
            const sizeOfComponent = componentClass.sizeOfThisComponent;
            const maxEntityNumber2 = Config.maxEntityNumber;
            memoryBeginIndex += sizeOfComponent * maxEntityNumber2;
          }
        }
        return memoryBeginIndex;
      }
      /**
      * Gets an array of components corresponding to the class object of the component.
      * @param componentType The class object of the component.
      */
      static getComponentsWithType(componentType) {
        const components = this.__components.get(componentType.componentTID);
        if (components == null) {
          return [];
        }
        return components.filter((component) => component != null);
      }
      static __updateComponentTIDs() {
        const componentTids = Array.from(this.__components.keys());
        componentTids.sort((a2, b) => a2 - b);
        this.__componentTIDs = componentTids;
        const renderingComponentTids = [];
        renderingComponentTids.push(WellKnownComponentTIDs.MeshRendererComponentTID);
        if (this.__components.has(WellKnownComponentTIDs.EffekseerComponentTID)) {
          renderingComponentTids.push(WellKnownComponentTIDs.EffekseerComponentTID);
        }
        this.__renderingComponentTIDs = renderingComponentTids;
      }
      /**
      * Gets all componentTIDs.
      */
      static getComponentTIDs() {
        return this.__componentTIDs;
      }
      /**
      * Gets all rendering componentTIDs.
      */
      static getRenderingComponentTIDs() {
        return this.__renderingComponentTIDs;
      }
    };
    __name(_ComponentRepository, "ComponentRepository");
    __publicField(_ComponentRepository, "__component_sid_count_map", /* @__PURE__ */ new Map());
    __publicField(_ComponentRepository, "__components", /* @__PURE__ */ new Map());
    __publicField(_ComponentRepository, "__componentClasses", /* @__PURE__ */ new Map());
    __publicField(_ComponentRepository, "__componentTIDs", []);
    __publicField(_ComponentRepository, "__renderingComponentTIDs", []);
    __publicField(_ComponentRepository, "invalidComponentSID", -1);
    ComponentRepository = _ComponentRepository;
  }
});

// src/foundation/core/RnObject.ts
var _RnObject, RnObject;
var init_RnObject = __esm({
  "src/foundation/core/RnObject.ts"() {
    "use strict";
    init_MiscUtil();
    _RnObject = class _RnObject {
      constructor() {
        /// members
        __publicField(this, "__objectUid", _RnObject.currentMaxObjectCount++);
        __publicField(this, "__uniqueName");
        __publicField(this, "_tags", {});
        __publicField(this, "__combinedTagString", "");
        this.__uniqueName = `${this.constructor.name}__uid_${this.__objectUid}`;
        this.__updateInfo(this.__uniqueName);
      }
      __updateInfo(uniqueName) {
        _RnObject.__uniqueNames[this.__objectUid] = uniqueName;
        _RnObject.__objects[this.__objectUid] = new WeakRef(this);
        _RnObject.__objectsByNameMap.set(this.__uniqueName, new WeakRef(this));
      }
      unregister() {
        delete _RnObject.__objects[this.__objectUid];
        delete _RnObject.__uniqueNames[this.__objectUid];
        _RnObject.__objectsByNameMap.delete(this.__uniqueName);
      }
      static searchByTag(tag, value) {
        var _a40;
        for (const obj of _RnObject.__objects) {
          if (((_a40 = obj.deref()) == null ? void 0 : _a40.getTagValue(tag)) === value) {
            return obj;
          }
        }
        return void 0;
      }
      /**
      * Gets the objectUID of the object.
      */
      get objectUID() {
        return this.__objectUid;
      }
      /**
      * Gets the object by corresponding to the objectUID.
      * @param objectUid The objectUID of the object.
      */
      static getRnObject(objectUid) {
        var _a40;
        return (_a40 = _RnObject.__objects[objectUid]) == null ? void 0 : _a40.deref();
      }
      /**
      * Gets the object by the unique name.
      * @param uniqueName The unique name of the object.
      */
      static getRnObjectByName(uniqueName) {
        var _a40;
        return (_a40 = _RnObject.__objectsByNameMap.get(uniqueName)) == null ? void 0 : _a40.deref();
      }
      /**
      * Try to set a unique name of the entity.
      * @param name
      * @param toAddNameIfConflict If true, force to add name string to the current unique name string. If false, give up to change name.
      */
      tryToSetUniqueName(name, toAddNameIfConflict) {
        if (_RnObject.__uniqueNames.indexOf(name) !== -1) {
          if (toAddNameIfConflict) {
            const newName = name + "_(" + this.__objectUid + ")";
            if (_RnObject.__uniqueNames.indexOf(newName) === -1) {
              _RnObject.__objectsByNameMap.delete(this.__uniqueName);
              this.__uniqueName = newName;
              _RnObject.__uniqueNames[this.__objectUid] = this.__uniqueName;
              _RnObject.__objectsByNameMap.set(this.__uniqueName, new WeakRef(this));
              return true;
            }
          }
          return false;
        } else {
          this.__uniqueName = name;
          _RnObject.__uniqueNames[this.__objectUid] = this.__uniqueName;
          _RnObject.__objectsByNameMap.set(this.__uniqueName, new WeakRef(this));
          return true;
        }
      }
      /**
      * Validate the string of tags.
      * @param val The string to be validated
      */
      validateTagString(val) {
        const reg = new RegExp(/[!"#$%&'()\*\+\-\s\.,\/:;<=>?@\[\\\]^`{|}~]/g);
        if (reg.test(val)) {
          return false;
        }
        return true;
      }
      /**
      * Tries to set tag (name and value).
      * @param tagName The tag name.
      * @param tagValue Tha value of the tag.
      */
      tryToSetTag(tag) {
        if (this.validateTagString(tag.tag)) {
          if (this.hasTag(tag.tag)) {
            this.removeTag(tag.tag);
          }
          this._tags[tag.tag] = tag.value;
          this.__combinedTagString += `${tag.tag}:${tag.value} `;
          return true;
        }
        return false;
      }
      /**
      * Gets the value of the tag.
      * @param tagName The tag name.
      */
      getTagValue(tagName) {
        return this._tags[tagName];
      }
      /**
      * Gets the tag object.
      * @param tagName The tag name.
      */
      getTag(tagName) {
        const tag = {
          tag: tagName,
          value: this._tags[tagName]
        };
        return tag;
      }
      /**
      * Gets the boolean value whether this object has the tag or not.
      * @param tagName The tag name.
      */
      hasTag(tagName) {
        if (this._tags[tagName] != null) {
          return true;
        } else {
          return false;
        }
      }
      /**
      * Remove the tag.
      * @param tagName The tag name.
      */
      removeTag(tagName) {
        const strToDelete = `${tagName}:${this._tags[tagName]} `;
        this.__combinedTagString.replace(this.__combinedTagString, "");
        delete this._tags[tagName];
      }
      /**
      * Confirms the matching of the tag name and tag value.
      * @param tagName The tag name.
      * @param tagValue The tag value.
      */
      matchTag(tagName, tagValue) {
        if (this._tags[tagName] === tagValue) {
          return true;
        } else {
          return false;
        }
      }
      /**
      * Confirm that this object's tags includes given an array of string.
      * @param stringArray an array of string.
      */
      matchTagsAsFreeStrings(stringArray) {
        let regExpStr = "^";
        for (let i2 = 0; i2 < stringArray.length; i2++) {
          regExpStr += `(?=.*${stringArray[i2]})`;
        }
        const reg = new RegExp(regExpStr);
        if (reg.test(this.__combinedTagString)) {
          return true;
        } else {
          return false;
        }
      }
      /**
      * Confirm that this object's tags includes given set of tags.
      * @param tags The set of tags.
      */
      matchTags(tags) {
        let regExpStr = "^";
        for (const tagName in tags) {
          regExpStr += `(?=.*${[
            tagName
          ]}:${tags[tagName]})`;
        }
        const reg = new RegExp(regExpStr);
        if (reg.test(this.__combinedTagString)) {
          return true;
        } else {
          return false;
        }
      }
      /**
      * Get the unique name of the entity.
      */
      get uniqueName() {
        return this.__uniqueName;
      }
      /**
      * @internal
      */
      static _reset() {
        this.currentMaxObjectCount = 0;
        this.__uniqueNames = [];
        this.__objectsByNameMap = /* @__PURE__ */ new Map();
        this.__objects = [];
      }
      _copyFrom(rnObject) {
        this._tags = deepCopyUsingJsonStringify(rnObject._tags);
        this.__combinedTagString = rnObject.__combinedTagString;
      }
    };
    __name(_RnObject, "RnObject");
    /// static members
    __publicField(_RnObject, "InvalidObjectUID", -1);
    __publicField(_RnObject, "currentMaxObjectCount", 0);
    __publicField(_RnObject, "__uniqueNames", []);
    __publicField(_RnObject, "__objectsByNameMap", /* @__PURE__ */ new Map());
    __publicField(_RnObject, "__objects", []);
    RnObject = _RnObject;
  }
});

// src/foundation/core/Component.ts
var _Component, Component;
var init_Component = __esm({
  "src/foundation/core/Component.ts"() {
    "use strict";
    init_MemoryManager();
    init_ProcessStage();
    init_ComponentRepository();
    init_Config();
    init_RnObject();
    init_Result();
    init_misc();
    _Component = class _Component extends RnObject {
      /**
      * The constructor of the Component class.
      * When creating an Component, use the createComponent method of the ComponentRepository class
      * instead of directly calling this constructor.
      * @param entityUid Unique ID of the corresponding entity
      * @param componentSid Scoped ID of the Component
      * @param entityRepository The instance of the EntityRepository class (Dependency Injection)
      */
      constructor(entityUid, componentSid, entityRepository, isReUse) {
        super();
        __publicField(this, "_component_sid");
        __publicField(this, "_isAlive", true);
        __publicField(this, "__currentProcessStage", ProcessStage.Load);
        __publicField(this, "__byteOffsetOfThisComponent", -1);
        /** the entity unique Id which this component belongs to  */
        __publicField(this, "__entityUid");
        /** the instance of MemoryManager */
        __publicField(this, "__memoryManager");
        /** the instance of EntityRepository */
        __publicField(this, "__entityRepository");
        /** the MaxComponent Number of entities */
        __publicField(this, "__maxComponentNumber", Config.maxEntityNumber);
        this.__entityUid = entityUid;
        this._component_sid = componentSid;
        const stages = _Component._processStages;
        this.__memoryManager = MemoryManager.getInstance();
        this.__entityRepository = entityRepository;
      }
      /**
      * Move to the other stages of process
      * @param processStage stage of component's process
      */
      moveStageTo(processStage) {
        this.__currentProcessStage = processStage;
      }
      /**
      * @internal
      * set the Max number of components
      * this method is called by the ***Component classes only
      */
      _setMaxNumberOfComponent(value) {
        this.__maxComponentNumber = value;
      }
      /**
      * Get the max number of components
      */
      get maxNumberOfComponent() {
        return this.__maxComponentNumber;
      }
      /**
      * Get the Type ID of the Component
      */
      static get componentTID() {
        return 0;
      }
      /**
      * Get the Type ID of the Component
      */
      get componentTID() {
        return 0;
      }
      /**
      * Get the Scoped ID of the Component
      */
      get componentSID() {
        return this._component_sid;
      }
      /**
      * Get the unique ID of the entity corresponding to the component.
      */
      get entityUID() {
        return this.__entityUid;
      }
      /**
      * Get the current process stage of the component.
      */
      get currentProcessStage() {
        return this.__currentProcessStage;
      }
      /**
      * Get true or false whether the specified ProcessStage exists in Component.
      * @returns true or false
      */
      static doesTheProcessStageMethodExist(componentType, processStage) {
        if (componentType.prototype[processStage.methodName] == null) {
          return false;
        }
        return true;
      }
      /**
      * Get true or false whether the specified ProcessStage exists in Component.
      */
      isExistProcessStageMethod(processStage) {
        if (this[processStage.methodName] == null) {
          return false;
        }
        return true;
      }
      /**
      * Process the components
      * @param param0 params
      */
      static process(componentType, processStage) {
        if (!_Component.doesTheProcessStageMethodExist(componentType, processStage)) {
          return;
        }
        const methodName = processStage.methodName;
        const components = ComponentRepository.getComponentsWithType(componentType);
        for (const component of components) {
          if (processStage === component.__currentProcessStage) {
            component[methodName]();
          }
        }
      }
      static updateComponentsForRenderStage(componentClass, processStage, renderPass) {
        const method = componentClass["sort_$render"];
        return method(renderPass);
      }
      /**
      * get byte length of sum of member fields in the component class
      */
      static getByteLengthSumOfMembers(bufferUse, componentClass) {
        const byteLengthSumOfMembers = this.__byteLengthSumOfMembers.get(componentClass);
        return byteLengthSumOfMembers.get(bufferUse);
      }
      /**
      * register a dependency for the other components.
      * Note: This method is not used yet
      */
      registerDependency(component, isMust) {
      }
      // /**
      //  * take a buffer view from the buffer.
      //  */
      // static takeBufferView(
      //   bufferUse: BufferUseEnum,
      //   componentClass: Function,
      //   byteLengthSumOfMembers: Byte,
      //   count: Count
      // ) {
      //   const buffer = MemoryManager.getInstance().createOrGetBuffer(bufferUse);
      //   if (!this.__bufferViews.has(componentClass)) {
      //     this.__bufferViews.set(componentClass, new Map());
      //   }
      //   const bufferViews = this.__bufferViews.get(componentClass)!;
      //   if (!bufferViews.has(bufferUse)) {
      //     const bufferView = buffer.takeBufferView({
      //       byteLengthToNeed: byteLengthSumOfMembers * count,
      //       byteStride: 0,
      //     }).unwrapForce();
      //     bufferViews.set(bufferUse, bufferView);
      //     return bufferView;
      //   }
      //   return void 0;
      // }
      /**
      * take one memory area for the specified member for all same type of the component instances.
      */
      takeOne(memberName, dataClassType, initValues, isReUse, componentSid) {
        if (!this["_" + memberName].isDummy()) {
          return;
        }
        let taken;
        if (isReUse) {
          taken = _Component.__accessors.get(this.constructor).get(memberName)._takeExistedOne(componentSid);
        } else {
          taken = _Component.__accessors.get(this.constructor).get(memberName).takeOne();
        }
        this["_" + memberName] = new dataClassType(taken, false, true);
        for (let i2 = 0; i2 < this["_" + memberName]._v.length; ++i2) {
          this["_" + memberName]._v[i2] = initValues[i2];
        }
        return null;
      }
      /**
      * get the taken accessor for the member field.
      */
      static getAccessor(memberName, componentClass) {
        return this.__accessors.get(componentClass).get(memberName);
      }
      /**
      * take one accessor for the member field.
      */
      static takeAccessor(bufferUse, memberName, componentClass, compositionType, componentType, count) {
        if (!this.__accessors.has(componentClass)) {
          this.__accessors.set(componentClass, /* @__PURE__ */ new Map());
        }
        const accessors = this.__accessors.get(componentClass);
        if (!accessors.has(memberName)) {
          const bytes = compositionType.getNumberOfComponents() * componentType.getSizeInBytes();
          const buffer = MemoryManager.getInstance().createOrGetBuffer(bufferUse);
          const bufferViewResult = buffer.takeBufferView({
            byteLengthToNeed: bytes * count,
            byteStride: 0
          });
          if (bufferViewResult.isErr()) {
            return new Err({
              message: "Failed to take buffer view: " + bufferViewResult.getRnError().message,
              error: void 0
            });
          }
          const accessorResult = bufferViewResult.get().takeAccessor({
            compositionType,
            componentType,
            count,
            byteStride: bytes
          });
          if (accessorResult.isErr()) {
            return new Err({
              message: "Failed to take accessor: " + accessorResult.getRnError().message,
              error: void 0
            });
          }
          accessors.set(memberName, accessorResult.get());
          return accessorResult;
        } else {
          return new Err({
            message: "Already taken",
            error: void 0
          });
        }
      }
      static getByteOffsetOfThisComponentTypeInBuffer(bufferUse, componentClass) {
        return this.__bufferViews.get(componentClass).get(bufferUse).byteOffsetInBuffer;
      }
      static getByteOffsetOfFirstOfThisMemberInBuffer(memberName, componentClass) {
        return this.__accessors.get(componentClass).get(memberName).byteOffsetInBuffer;
      }
      static getByteOffsetOfFirstOfThisMemberInBufferView(memberName, componentClass) {
        return this.__accessors.get(componentClass).get(memberName).byteOffsetInBufferView;
      }
      /**
      * Register a member field of component class for memory allocation.
      * @param bufferUse purpose type of buffer use
      * @param memberName the name of member field
      * @param dataClassType a class of data
      * @param componentType a type of number
      * @param initValues a initial value
      */
      registerMember(bufferUse, memberName, dataClassType, componentType, initValues) {
        if (!_Component.__memberInfo.has(this.constructor)) {
          _Component.__memberInfo.set(this.constructor, []);
        }
        const memberInfoArray = _Component.__memberInfo.get(this.constructor);
        memberInfoArray.push({
          bufferUse,
          memberName,
          dataClassType,
          compositionType: dataClassType.compositionType,
          componentType,
          initValues
        });
      }
      /**
      * Allocate memory of self member fields
      * @param count a number of entities to need allocate
      */
      submitToAllocation(count, isReUse) {
        if (this._component_sid >= count) {
          const componentClass2 = this.constructor;
          console.error(`%c${componentClass2.name}: The number of components is over the limit. This may lead to incorrect processing results. Please consider to increase the limit. You can set the limit on Rn.Config.xxxxxx.`, "color: red; background: yellow; font-size: 2em;");
        }
        const componentClass = this.constructor;
        const memberInfoArray = _Component.__memberInfo.get(componentClass);
        if (this._component_sid === 0) {
          getBufferViewsAndAccessors(this);
        }
        const member = _Component.__members.get(componentClass);
        for (const bufferUse of member.keys()) {
          const infoArray = member.get(bufferUse);
          infoArray.forEach((info) => {
            this.takeOne(info.memberName, info.dataClassType, info.initValues, isReUse, this._component_sid);
          });
        }
        return;
        function getBufferViewsAndAccessors(that) {
          if (!_Component.__members.has(componentClass)) {
            _Component.__members.set(componentClass, /* @__PURE__ */ new Map());
          }
          const member2 = _Component.__members.get(componentClass);
          memberInfoArray.forEach((info) => {
            member2.set(info.bufferUse, []);
          });
          memberInfoArray.forEach((info) => {
            member2.get(info.bufferUse).push(info);
          });
          for (const bufferUse of member2.keys()) {
            const infoArray = member2.get(bufferUse);
            if (!_Component.__byteLengthSumOfMembers.has(componentClass)) {
              _Component.__byteLengthSumOfMembers.set(componentClass, /* @__PURE__ */ new Map());
            }
            const byteLengthSumOfMembers = _Component.__byteLengthSumOfMembers.get(componentClass);
            if (!byteLengthSumOfMembers.has(bufferUse)) {
              byteLengthSumOfMembers.set(bufferUse, 0);
            }
            infoArray.forEach((info) => {
              byteLengthSumOfMembers.set(bufferUse, byteLengthSumOfMembers.get(bufferUse) + info.compositionType.getNumberOfComponents() * info.componentType.getSizeInBytes());
            });
            if (infoArray.length > 0) {
            }
          }
          for (const bufferUse of member2.keys()) {
            const infoArray = member2.get(bufferUse);
            infoArray.forEach((info) => {
              const accessorResult = _Component.takeAccessor(info.bufferUse, info.memberName, componentClass, info.compositionType, info.componentType, count);
              if (accessorResult.isErr()) {
                throw new RnException(accessorResult.getRnError());
              }
              that["_byteOffsetOfAccessorInBuffer_" + info.memberName] = accessorResult.get().byteOffsetInBuffer;
              that["_byteOffsetOfAccessorInComponent_" + info.memberName] = accessorResult.get().byteOffsetInBufferView;
            });
          }
        }
        __name(getBufferViewsAndAccessors, "getBufferViewsAndAccessors");
      }
      /**
      * get the entity which has this component.
      * @returns the entity which has this component
      */
      get entity() {
        return this.__entityRepository.getEntity(this.__entityUid);
      }
      /**
      * get the bytes Information of the member
      * @param component a instance of the component
      * @param memberName the member of component in string
      * @returns bytes information
      */
      static getDataByteInfoInner(component, memberName) {
        const data = component["_" + memberName];
        const typedArray = data._v;
        const byteOffsetInBuffer = typedArray.byteOffset;
        const byteLength = typedArray.byteLength;
        const componentNumber = typedArray.length;
        const locationOffsetInBuffer = byteOffsetInBuffer / 4 / 4;
        const byteOffsetInThisComponent = this["_byteOffsetOfAccessorInComponent_" + memberName] + component.componentSID * componentNumber * 4;
        const locationOffsetInThisComponent = this["_byteOffsetOfAccessorInComponent_" + memberName] + component.componentSID * componentNumber;
        const thisComponentByteOffsetInBuffer = component.__byteOffsetOfThisComponent;
        const thisComponentLocationOffsetInBuffer = component.__byteOffsetOfThisComponent / 4 / 4;
        return {
          byteLength,
          byteOffsetInBuffer,
          byteOffsetInThisComponent,
          locationOffsetInBuffer,
          locationOffsetInThisComponent,
          thisComponentByteOffsetInBuffer,
          thisComponentLocationOffsetInBuffer,
          componentNumber
        };
      }
      /**
      * get the bytes Information of the member
      * @param memberName the member of component in string
      * @returns bytes information
      */
      getDataByteInfo(memberName) {
        return _Component.getDataByteInfoInner(this, memberName);
      }
      /**
      * get the bytes Information of the member (static version) by ComponentSID
      * @param componentType the Component type
      * @param componentSID the ComponentSID of the component
      * @param memberName the member of component in string
      * @returns bytes information
      */
      static getDataByteInfoByComponentSID(componentType, componentSID, memberName) {
        const component = ComponentRepository.getComponent(componentType, componentSID);
        if (component) {
          return _Component.getDataByteInfoInner(component, memberName);
        }
        return void 0;
      }
      /**
      * get the bytes Information of the member (static version) by EntityUID
      * @param componentType the component type
      * @param entityUID the EntityUID
      * @param memberName the member of component in string
      * @returns bytes information
      */
      // static getDataByteInfoByEntityUID(
      //   componentType: typeof Component,
      //   entityUID: EntityUID,
      //   memberName: string
      // ) {
      //   const component = EntityRepository.getComponentOfEntity(entityUID, componentType);
      //   if (component) {
      //     return Component.getDataByteInfoInner(component, memberName);
      //   }
      //   return void 0;
      // }
      /**
      * get the Pixel Location Offset in the Buffer of the Member
      * @param componentType the component type (e.g. TransformComponent )
      * @param memberName the member name in string
      * @returns the pixel offsets
      */
      static getLocationOffsetOfMemberOfComponent(componentType, memberName) {
        const component = ComponentRepository.getComponent(componentType, 0);
        return component["_byteOffsetOfAccessorInBuffer_" + memberName] / 4 / 4;
      }
      /**
      * @virtual
      * Add this component to the entity
      * @param base the target entity
      * @param _componentClass the component class to add
      */
      addThisComponentToEntity(base, _componentClass) {
        throw "Invalid Calling";
      }
      // $create() {
      //   // Define process dependencies with other components.
      //   // If circular dependencies are detected, the error will be reported.
      //   // this.registerDependency(TransformComponent);
      // }
      // $load() {}
      // $mount() {}
      // $logic() {}
      // $prerender(instanceIDBufferUid: CGAPIResourceHandle) {}
      // $render() {}
      // $unmount() {}
      // $discard() {}
      ///
      /// convenient methods but not used yet
      ///
      /**
      * Get the CompositionType of the member
      * @param memberName - the member name
      * @param componentClass - the component class
      * @returns CompositionType or undefined
      */
      static getCompositionTypeOfMember(memberName, componentClass) {
        const memberInfoArray = this.__memberInfo.get(componentClass);
        const info = memberInfoArray.find((info2) => {
          return info2.memberName === memberName;
        });
        if (info != null) {
          return info.compositionType;
        } else {
          return void 0;
        }
      }
      /**
      * Get the ComponentType of the member
      * @param memberName - the member name
      * @param componentClass - the component class
      * @returns ComponentType or undefined
      */
      static getComponentTypeOfMember(memberName, componentClass) {
        const memberInfoArray = this.__memberInfo.get(componentClass);
        const info = memberInfoArray.find((info2) => {
          return info2.memberName === memberName;
        });
        if (info != null) {
          return info.componentType;
        } else {
          return void 0;
        }
      }
      /**
      * @internal
      * Mark the component as destroyed
      */
      _destroy() {
        this._isAlive = false;
      }
      _shallowCopyFrom(component) {
      }
    };
    __name(_Component, "Component");
    __publicField(_Component, "__bufferViews", /* @__PURE__ */ new Map());
    __publicField(_Component, "__accessors", /* @__PURE__ */ new Map());
    __publicField(_Component, "__byteLengthSumOfMembers", /* @__PURE__ */ new Map());
    __publicField(_Component, "__memberInfo", /* @__PURE__ */ new Map());
    __publicField(_Component, "__members", /* @__PURE__ */ new Map());
    __publicField(_Component, "_processStages", [
      // ProcessStage.Create,
      ProcessStage.Load,
      // ProcessStage.Mount,
      ProcessStage.Logic,
      ProcessStage.Render
    ]);
    Component = _Component;
  }
});

// src/foundation/core/Entity.ts
var _Entity, Entity;
var init_Entity = __esm({
  "src/foundation/core/Entity.ts"() {
    "use strict";
    init_RnObject();
    init_Is();
    init_WellKnownComponentTIDs();
    _Entity = class _Entity extends RnObject {
      /**
      * The constructor of the Entity class.
      *
      * @remarks
      * When creating an Entity, use the createEntity method of the EntityRepository class
      * instead of directly calling this constructor.
      *
      * @param entityUID - The unique ID of the entity
      * @param isAlive - Whether this entity alive or not
      * @param entityComponent - The instance of EntityComponent (Dependency Injection)
      */
      constructor(entityUID, isAlive, components) {
        super();
        /** The Unique ID of Entity */
        __publicField(this, "___entity_uid");
        /** The Map of components. All components must be managed in this map */
        __publicField(this, "__components");
        __publicField(this, "_myLatestCopyEntityUID", _Entity.invalidEntityUID);
        /** No use yet */
        __publicField(this, "_isAlive");
        this.___entity_uid = entityUID;
        this._isAlive = isAlive;
        this.__components = Is.exist(components) ? components : /* @__PURE__ */ new Map();
      }
      /**
      * Get Unique ID of the entity.
      */
      get entityUID() {
        return this.___entity_uid;
      }
      /**
      * Sets a component to this entity.
      * @param component The component to set.
      *
      * @internal
      */
      _setComponent(componentType, component) {
        this.__components.set(componentType.componentTID, component);
      }
      /**
      * return whether this entity has the component or not
      * @param componentType - The component to check
      * @returns
      */
      hasComponent(componentType) {
        return this.__components.has(componentType.componentTID);
      }
      /**
      * Get the component of the specified type that the entity has
      * @param componentType
      */
      getComponent(componentType) {
        return this.__components.get(componentType.componentTID);
      }
      /**
      * Gets the component corresponding to the ComponentTID.
      * @param componentTID - The ComponentTID to get the component.
      */
      getComponentByComponentTID(componentTID) {
        return this.__components.get(componentTID);
      }
      /**
      * @param componentTID
      *
      * @internal
      */
      _removeComponent(componentTID) {
        this.__components.delete(componentTID);
      }
      ///
      /// tryToGet methods
      ///
      /**
      * try to get an Animation Component if the entity has it.
      * @returns AnimationComponent | undefined
      */
      tryToGetAnimation() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.AnimationComponentTID);
      }
      tryToGetAnimationState() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.AnimationStateComponentTID);
      }
      tryToGetBlendShape() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.BlendShapeComponentTID);
      }
      tryToGetCamera() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.CameraComponentTID);
      }
      tryToGetCameraController() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.CameraControllerComponentTID);
      }
      tryToGetLight() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.LightComponentTID);
      }
      tryToGetMesh() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.MeshComponentTID);
      }
      tryToGetMeshRenderer() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.MeshRendererComponentTID);
      }
      tryToGetPhysics() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.PhysicsComponentTID);
      }
      tryToGetSceneGraph() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.SceneGraphComponentTID);
      }
      tryToGetSkeletal() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.SkeletalComponentTID);
      }
      tryToGetTransform() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.TransformComponentTID);
      }
      tryToGetVrm() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.VrmComponentTID);
      }
      tryToGetConstraint() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.ConstraintComponentTID);
      }
      tryToGetEffekseer() {
        return this.getComponentByComponentTID(WellKnownComponentTIDs.EffekseerComponentTID);
      }
      /**
      * Mark the entity as destroyed
      */
      _destroy() {
        this.__components.forEach((component) => {
          component._destroy();
        });
        this._isAlive = false;
      }
    };
    __name(_Entity, "Entity");
    /** Invalid Entity UID constant value */
    __publicField(_Entity, "invalidEntityUID", -1);
    Entity = _Entity;
  }
});

// src/foundation/core/EntityRepository.ts
function applyMixins(derivedCtor, baseCtor) {
  Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
    Object.defineProperty(derivedCtor, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || /* @__PURE__ */ Object.create(null));
  });
}
function createEntity() {
  return EntityRepository.createEntity();
}
var _EntityRepository, EntityRepository;
var init_EntityRepository = __esm({
  "src/foundation/core/EntityRepository.ts"() {
    "use strict";
    init_Entity();
    init_ComponentRepository();
    init_MiscUtil();
    init_Is();
    init_WellKnownComponentTIDs();
    init_misc();
    _EntityRepository = class _EntityRepository {
      constructor() {
      }
      /**
      * Creates an entity
      */
      static createEntity() {
        let deadUid = -1;
        for (let i2 = 0; i2 < this.__entities.length; i2++) {
          if (this.__entities[i2] == null) {
            deadUid = i2;
          }
        }
        let entityUid = -1;
        if (deadUid === -1) {
          entityUid = ++this.__entity_uid_count;
        } else {
          entityUid = deadUid;
        }
        const entity = new Entity(entityUid, true);
        this.__entities[entityUid] = entity;
        this.__updateCount++;
        return entity;
      }
      static deleteEntity(entityUid) {
        var _a40;
        if (Is.not.exist(this._components[entityUid])) {
          return;
        }
        for (const [componentTid, component] of this._components[entityUid]) {
          if (componentTid === WellKnownComponentTIDs.SceneGraphComponentTID) {
            const sceneGraph = component;
            const children = sceneGraph.children.concat();
            for (const child of children) {
              _EntityRepository.deleteEntity(child.entity.entityUID);
            }
          }
          ComponentRepository.deleteComponent(component);
        }
        (_a40 = this.__entities[entityUid]) == null ? void 0 : _a40._destroy();
        delete this.__entities[entityUid];
        delete this._components[entityUid];
        this.__updateCount++;
      }
      static deleteEntityRecursively(entityUid) {
        const entity = this.getEntity(entityUid);
        const entities = [];
        const sg = entity.tryToGetSceneGraph();
        if (sg != null) {
          entities.push(sg.entity);
          addChild(sg);
        }
        function addChild(sg2) {
          const children = sg2.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            entities.push(child.entity);
            addChild(child);
          }
        }
        __name(addChild, "addChild");
        for (const entity2 of entities) {
          _EntityRepository.deleteEntity(entity2.entityUID);
        }
      }
      static shallowCopyEntity(entity) {
        const newEntity = _EntityRepository._shallowCopyEntityInner(entity);
        this.__setJoints(entity);
        this.__handleTagData(newEntity);
        return newEntity;
      }
      static __setJoints(entity) {
        const newEntity = _EntityRepository.getEntity(entity._myLatestCopyEntityUID);
        const skeletalComponentOfNew = newEntity.getComponentByComponentTID(WellKnownComponentTIDs.SkeletalComponentTID);
        const skeletalComponentOfOriginal = entity.getComponentByComponentTID(WellKnownComponentTIDs.SkeletalComponentTID);
        if (Is.exist(skeletalComponentOfNew) && Is.exist(skeletalComponentOfOriginal)) {
          const jointsOriginal = skeletalComponentOfOriginal.getJoints();
          const jointsNew = jointsOriginal.map((joint) => {
            return _EntityRepository.getEntity(joint.entity._myLatestCopyEntityUID).tryToGetSceneGraph();
          });
          skeletalComponentOfNew.setJoints(jointsNew);
        }
        const sceneGraph = entity.tryToGetSceneGraph();
        if (Is.exist(sceneGraph)) {
          sceneGraph.children.forEach((child) => {
            _EntityRepository.__setJoints(child.entity);
          });
        }
      }
      static _shallowCopyEntityInner(entity) {
        const newEntity = this.createEntity();
        newEntity._tags = Object.assign({}, entity._tags);
        entity._myLatestCopyEntityUID = newEntity.entityUID;
        for (let i2 = 1; i2 <= WellKnownComponentTIDs.maxWellKnownTidNumber; i2++) {
          const component = entity.getComponentByComponentTID(i2);
          if (Is.exist(component)) {
            this.tryToAddComponentToEntityByTID(i2, newEntity);
            const componentOfNewEntity = newEntity.getComponentByComponentTID(i2);
            if (Is.exist(componentOfNewEntity)) {
              componentOfNewEntity._shallowCopyFrom(component);
            }
          }
        }
        return newEntity;
      }
      static __handleTagData(newEntity) {
        const tags = newEntity._tags;
        if (Is.exist(tags)) {
          const tagKeys = Object.keys(tags);
          for (const tagKey of tagKeys) {
            if (tagKey === "rnEntities") {
              const entities = newEntity.getTagValue("rnEntities");
              const newEntities = entities.map((entity) => {
                return _EntityRepository.getEntity(entity._myLatestCopyEntityUID);
              });
              newEntity.tryToSetTag({
                tag: "rnEntities",
                value: newEntities
              });
            }
            if (tagKey === "rnEntitiesByNames") {
              const map = newEntity.getTagValue("rnEntitiesByNames");
              for (const name of Object.keys(map)) {
                const entity = map.get(name);
                map.set(name, _EntityRepository.getEntity(entity._myLatestCopyEntityUID));
              }
              newEntity.tryToSetTag({
                tag: "rnEntitiesByNames",
                value: map
              });
            }
          }
        }
        const sceneGraph = newEntity.tryToGetSceneGraph();
        if (Is.exist(sceneGraph)) {
          sceneGraph.children.forEach((child) => {
            _EntityRepository.__handleTagData(child.entity);
          });
        }
      }
      /**
      * Try to add a component to the entity by componentTID.
      * @param componentTID - the componentTID
      * @param entity - the entity
      * @returns the entity added a component
      */
      static tryToAddComponentToEntityByTID(componentTID, entity) {
        const componentClass = ComponentRepository.getComponentClass(componentTID);
        if (Is.not.exist(componentClass)) {
          return entity;
        }
        return this.addComponentToEntity(componentClass, entity);
      }
      /**
      * Add a Component to the entity
      * @param componentClass - a ComponentClass to add
      * @param entity - the entity
      * @returns the entity added a component
      */
      static addComponentToEntity(componentClass, entity) {
        if (entity.hasComponent(componentClass)) {
          Logger.info("This entity already has the Component.");
          return entity;
        }
        const component = ComponentRepository.createComponent(componentClass.componentTID, entity.entityUID, this);
        const map = valueWithCompensation({
          value: this._components[entity.entityUID],
          compensation: /* @__PURE__ */ __name(() => {
            return this._components[entity.entityUID] = /* @__PURE__ */ new Map();
          }, "compensation")
        });
        map.set(componentClass.componentTID, component);
        const entityClass = component.addThisComponentToEntity(entity, componentClass);
        entity._setComponent(componentClass, component);
        this.__updateCount++;
        return entity;
      }
      /**
      * Remove components from the entity.
      * Note: the returned entity's type will be IEntity (most basic type).
      *       You have to cast it to appropriate type later.
      * @param componentClass The class object of the component to remove.
      * @param entityUid The entityUID of the entity.
      */
      static removeComponentFromEntity(componentClass, entity) {
        let map = this._components[entity.entityUID];
        if (map == null) {
          map = /* @__PURE__ */ new Map();
          this._components[entity.entityUID] = map;
        }
        const component = map.get(componentClass.componentTID);
        if (Is.exist(component)) {
          component._destroy();
          map.delete(componentClass.componentTID);
          entity._removeComponent(componentClass.componentTID);
        }
        this.__updateCount++;
        return entity;
      }
      /**
      * Gets the entity corresponding to the entityUID.
      * @param entityUid The entityUID of the entity.
      */
      static getEntity(entityUid) {
        return this.__entities[entityUid];
      }
      /**
      * Gets the entity corresponding to the entityUID.
      * @param entityUid The entityUID of the entity.
      */
      getEntity(entityUid) {
        return _EntityRepository.__entities[entityUid];
      }
      /**
      * Gets the specified component from the entity.
      * @param entityUid The entity to get the component from.
      * @param componentType The class object of the component to get.
      */
      static getComponentOfEntity(entityUid, componentType) {
        const entity = this._components[entityUid];
        let component = null;
        if (entity != null) {
          component = entity.get(componentType.componentTID);
          if (component != null) {
            return component;
          } else {
            return null;
          }
        }
        return component;
      }
      /**
      * Search entities by the given tags.
      * @param tags The tags to search
      */
      static searchByTags(tags) {
        const matchEntities = [];
        for (const entity of this.__entities) {
          if (entity == null ? void 0 : entity.matchTags(tags)) {
            matchEntities.push(entity);
          }
        }
        return matchEntities;
      }
      /**
      * Gets entity by the unique name.
      * @param uniqueName The unique name of the entity.
      */
      static getEntityByUniqueName(uniqueName) {
        for (const entity of this.__entities) {
          if (entity != null && entity.uniqueName === uniqueName) {
            return entity;
          }
        }
        return void 0;
      }
      /**
      * @internal
      * Gets all entities.
      */
      static _getEntities() {
        return this.__entities.filter((entity) => entity != null && entity._isAlive);
      }
      /**
      * Gets the number of all entities.
      */
      static getEntitiesNumber() {
        const entities = this.__entities.filter((entity) => entity != null && entity._isAlive);
        return entities.length;
      }
      static get updateCount() {
        return this.__updateCount;
      }
    };
    __name(_EntityRepository, "EntityRepository");
    __publicField(_EntityRepository, "__entity_uid_count", Entity.invalidEntityUID);
    __publicField(_EntityRepository, "__entities", []);
    __publicField(_EntityRepository, "_components", []);
    __publicField(_EntityRepository, "__updateCount", 0);
    EntityRepository = _EntityRepository;
    __name(applyMixins, "applyMixins");
    __name(createEntity, "createEntity");
  }
});

// src/foundation/definitions/AnimationAttribute.ts
function from6(index) {
  return _from({
    typeList: typeList6,
    index
  });
}
function fromString5(str) {
  return _fromString({
    typeList: typeList6,
    str
  });
}
var _a8, AnimationAttributeClass, Quaternion2, Translate, Scale, Weights, Effekseer, typeList6, AnimationAttribute;
var init_AnimationAttribute = __esm({
  "src/foundation/definitions/AnimationAttribute.ts"() {
    "use strict";
    init_EnumIO();
    AnimationAttributeClass = (_a8 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a8, "AnimationAttributeClass"), _a8);
    Quaternion2 = new AnimationAttributeClass({
      index: 0,
      str: "Quaternion"
    });
    Translate = new AnimationAttributeClass({
      index: 1,
      str: "Translate"
    });
    Scale = new AnimationAttributeClass({
      index: 2,
      str: "Scale"
    });
    Weights = new AnimationAttributeClass({
      index: 3,
      str: "Weights"
    });
    Effekseer = new AnimationAttributeClass({
      index: 4,
      str: "Effekseer"
    });
    typeList6 = [
      Quaternion2,
      Translate,
      Scale,
      Weights,
      Effekseer
    ];
    __name(from6, "from");
    __name(fromString5, "fromString");
    AnimationAttribute = Object.freeze({
      Quaternion: Quaternion2,
      Translate,
      Scale,
      Weights,
      Effekseer,
      from: from6,
      fromString: fromString5
    });
  }
});

// src/foundation/system/EventPubSub.ts
var _EventPubSub, EventPubSub;
var init_EventPubSub = __esm({
  "src/foundation/system/EventPubSub.ts"() {
    "use strict";
    init_Is();
    init_MiscUtil();
    _EventPubSub = class _EventPubSub {
      constructor() {
        __publicField(this, "__subscriberMap", /* @__PURE__ */ new Map());
      }
      subscribe(type, handler) {
        let subscribers = this.__subscriberMap.get(type);
        if (Is.not.exist(subscribers)) {
          this.__subscriberMap.set(type, []);
          subscribers = this.__subscriberMap.get(type);
        }
        return subscribers.push(handler) - 1;
      }
      unsubscribe(type, index) {
        const subscribers = this.__subscriberMap.get(type);
        if (subscribers == null) {
          return;
        }
        subscribers.splice(index, 1);
      }
      unsubscribeAll(type) {
        this.__subscriberMap.delete(type);
      }
      publishAsync(type, event) {
        let count = 0;
        const subscribers = nullishToEmptyArray(this.__subscriberMap.get(type));
        for (const sub of subscribers) {
          setTimeout(sub.bind(this, event), 0);
          count++;
        }
        return count;
      }
      publishSync(type, event) {
        let count = 0;
        const subscribers = nullishToEmptyArray(this.__subscriberMap.get(type));
        for (const sub of subscribers) {
          sub(event);
          count++;
        }
        return count;
      }
    };
    __name(_EventPubSub, "EventPubSub");
    EventPubSub = _EventPubSub;
  }
});

// src/foundation/definitions/AnimationInterpolation.ts
function from7(index) {
  return _from({
    typeList: typeList7,
    index
  });
}
function fromString6(str) {
  return _fromString({
    typeList: typeList7,
    str
  });
}
var _a9, AnimationInterpolationClass, Linear, Step, CubicSpline, typeList7, AnimationInterpolation;
var init_AnimationInterpolation = __esm({
  "src/foundation/definitions/AnimationInterpolation.ts"() {
    "use strict";
    init_EnumIO();
    AnimationInterpolationClass = (_a9 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
      get GltfString() {
        return this.str.toUpperCase();
      }
    }, __name(_a9, "AnimationInterpolationClass"), _a9);
    Linear = new AnimationInterpolationClass({
      index: 0,
      str: "Linear"
    });
    Step = new AnimationInterpolationClass({
      index: 1,
      str: "Step"
    });
    CubicSpline = new AnimationInterpolationClass({
      index: 2,
      str: "CubicSpline"
    });
    typeList7 = [
      Linear,
      Step,
      CubicSpline
    ];
    __name(from7, "from");
    __name(fromString6, "fromString");
    AnimationInterpolation = Object.freeze({
      Linear,
      Step,
      CubicSpline,
      from: from7,
      fromString: fromString6
    });
  }
});

// src/foundation/components/Animation/AnimationOps.ts
function cubicSpline(p0, p1, m0, m1, t2) {
  const ret = new Array(p0.length);
  for (let i2 = 0; i2 < p0.length; i2++) {
    ret[i2] = (2 * t2 ** 3 - 3 * t2 ** 2 + 1) * p0[i2] + (t2 ** 3 - 2 * t2 ** 2 + t2) * m0[i2] + (-2 * t2 ** 3 + 3 * t2 ** 2) * p1[i2] + (t2 ** 3 - t2 ** 2) * m1[i2];
  }
  return ret;
}
function __prepareVariablesForCubicSpline(outputArray_, i2, componentN, t_diff) {
  const outputArray = outputArray_;
  if (componentN === 4) {
    const p_0 = outputArray[get4_offset](
      // In glTF CUBICSPLINE interpolation, tangents (ak, bk) and values (vk) are grouped within keyframes: a1,a2,…an,v1,v2,…vn,b1,b2,…bn
      componentN * 3 * i2 + componentN
    );
    const p_1 = outputArray[get4_offset](
      // In glTF CUBICSPLINE interpolation, tangents (ak, bk) and values (vk) are grouped within keyframes: a1,a2,…an,v1,v2,…vn,b1,b2,…bn
      componentN * 3 * (i2 + 1) + componentN
    );
    const m_0 = outputArray[mulArray4WithScalar_offset](componentN * 3 * i2 + componentN * 2, t_diff);
    const m_1 = outputArray[mulArray4WithScalar_offset](componentN * 3 * (i2 + 1), t_diff);
    return {
      p_0,
      p_1,
      m_0,
      m_1
    };
  } else if (componentN === 3) {
    const p_0 = outputArray[get3_offset](
      // In glTF CUBICSPLINE interpolation, tangents (ak, bk) and values (vk) are grouped within keyframes: a1,a2,…an,v1,v2,…vn,b1,b2,…bn
      componentN * 3 * i2 + componentN
    );
    const p_1 = outputArray[get3_offset](
      // In glTF CUBICSPLINE interpolation, tangents (ak, bk) and values (vk) are grouped within keyframes: a1,a2,…an,v1,v2,…vn,b1,b2,…bn
      componentN * 3 * (i2 + 1) + componentN
    );
    const m_0 = outputArray[mulArray3WithScalar_offset](componentN * 3 * i2 + componentN * 2, t_diff);
    const m_1 = outputArray[mulArray3WithScalar_offset](componentN * 3 * (i2 + 1), t_diff);
    return {
      p_0,
      p_1,
      m_0,
      m_1
    };
  } else {
    const p_0 = outputArray[getN_offset](
      // In glTF CUBICSPLINE interpolation, tangents (ak, bk) and values (vk) are grouped within keyframes: a1,a2,…an,v1,v2,…vn,b1,b2,…bn
      componentN * 3 * i2 + componentN,
      componentN
    );
    const p_1 = outputArray[getN_offset](
      // In glTF CUBICSPLINE interpolation, tangents (ak, bk) and values (vk) are grouped within keyframes: a1,a2,…an,v1,v2,…vn,b1,b2,…bn
      componentN * 3 * (i2 + 1) + componentN,
      componentN
    );
    const m_0 = outputArray[mulArrayNWithScalar_offset](componentN * 3 * i2 + componentN * 2, componentN, t_diff);
    const m_1 = outputArray[mulArrayNWithScalar_offset](componentN * 3 * (i2 + 1), componentN, t_diff);
    return {
      p_0,
      p_1,
      m_0,
      m_1
    };
  }
}
function __getOutputValue(keyFrameId, channel, array_) {
  const array = array_;
  if (channel.sampler.interpolationMethod === AnimationInterpolation.CubicSpline) {
    if (channel.sampler.outputComponentN === 4) {
      const value = array[get4_offset](channel.sampler.outputComponentN * 3 * keyFrameId + channel.sampler.outputComponentN);
      return value;
    } else if (channel.sampler.outputComponentN === 3) {
      const value = array[get3_offset](channel.sampler.outputComponentN * 3 * keyFrameId + channel.sampler.outputComponentN);
      return value;
    } else if (channel.sampler.outputComponentN === 1) {
      const value = array[get1_offset](channel.sampler.outputComponentN * 3 * keyFrameId + channel.sampler.outputComponentN);
      return value;
    } else {
      const value = array[getN_offset](channel.sampler.outputComponentN * 3 * keyFrameId + channel.sampler.outputComponentN, channel.sampler.outputComponentN);
      return value;
    }
  } else {
    if (channel.sampler.outputComponentN === 4) {
      const value = array[get4_offsetAsComposition](keyFrameId);
      return value;
    } else if (channel.sampler.outputComponentN === 3) {
      const value = array[get3_offsetAsComposition](keyFrameId);
      return value;
    } else if (channel.sampler.outputComponentN === 1) {
      const value = array[get1_offsetAsComposition](keyFrameId);
      return value;
    } else {
      const value = array[getN_offsetAsComposition](keyFrameId, channel.sampler.outputComponentN);
      return value;
    }
  }
}
function interpolationSearch(inputArray, currentTime) {
  let mid = 0;
  let lower = 0;
  let upper = inputArray.length - 1;
  let retVal = 0;
  while (lower <= upper && currentTime >= inputArray[lower] && currentTime <= inputArray[upper]) {
    mid = Math.floor(lower + (currentTime - inputArray[lower]) * (upper - lower) / (inputArray[upper] - inputArray[lower]));
    if (inputArray[mid] < currentTime) {
      lower = mid + 1;
      retVal = mid;
    } else if (currentTime < inputArray[mid]) {
      upper = mid - 1;
      retVal = upper;
    } else {
      return mid;
    }
  }
  return retVal;
}
function __lerp(data_, ratio, animationAttributeIndex, i2, outputComponentN) {
  const data = data_;
  if (animationAttributeIndex === AnimationAttribute.Quaternion.index) {
    const array4 = data[qlerp_offsetAsComposition](data, ratio, i2, i2 + 1);
    return array4;
  } else if (animationAttributeIndex === AnimationAttribute.Weights.index) {
    const arrayN = data[arrayN_lerp_offsetAsComposition](data, outputComponentN, ratio, i2, i2 + 1);
    return arrayN;
  } else {
    const array3 = data[array3_lerp_offsetAsComposition](data, ratio, i2, i2 + 1);
    return array3;
  }
}
function __interpolate(channel, currentTime, animationAttributeIndex) {
  var _a40;
  const inputArray = channel.sampler.input;
  const outputArray = channel.sampler.output;
  const method = (_a40 = channel.sampler.interpolationMethod) != null ? _a40 : AnimationInterpolation.Linear;
  if (currentTime <= inputArray[0]) {
    const outputOfZeroFrame = __getOutputValue(0, channel, outputArray);
    return outputOfZeroFrame;
  } else if (inputArray[inputArray.length - 1] <= currentTime) {
    const outputOfEndFrame = __getOutputValue(inputArray.length - 1, channel, outputArray);
    return outputOfEndFrame;
  }
  if (method === AnimationInterpolation.CubicSpline) {
    const i2 = interpolationSearch(inputArray, currentTime);
    const t_diff = inputArray[i2 + 1] - inputArray[i2];
    const t2 = (currentTime - inputArray[i2]) / t_diff;
    const { p_0, p_1, m_0, m_1 } = __prepareVariablesForCubicSpline(outputArray, i2, channel.sampler.outputComponentN, t_diff);
    const ret = cubicSpline(p_0, p_1, m_0, m_1, t2);
    if (animationAttributeIndex === AnimationAttribute.Quaternion.index) {
      ret[normalizeArray4]();
    }
    return ret;
  } else if (method === AnimationInterpolation.Linear) {
    const i2 = interpolationSearch(inputArray, currentTime);
    const ratio = (currentTime - inputArray[i2]) / (inputArray[i2 + 1] - inputArray[i2]);
    const ret = __lerp(outputArray, ratio, animationAttributeIndex, i2, channel.sampler.outputComponentN);
    return ret;
  } else if (method === AnimationInterpolation.Step) {
    for (let i2 = 0; i2 < inputArray.length - 1; i2++) {
      if (inputArray[i2] <= currentTime && currentTime < inputArray[i2 + 1]) {
        const output_frame_i = __getOutputValue(i2, channel, outputArray);
        return output_frame_i;
      }
    }
    const outputOfEndFrame = __getOutputValue(inputArray.length - 1, channel, outputArray);
    return outputOfEndFrame;
  }
  return [];
}
var init_AnimationOps = __esm({
  "src/foundation/components/Animation/AnimationOps.ts"() {
    "use strict";
    init_AnimationAttribute();
    init_AnimationInterpolation();
    init_raw_extension();
    __name(cubicSpline, "cubicSpline");
    __name(__prepareVariablesForCubicSpline, "__prepareVariablesForCubicSpline");
    __name(__getOutputValue, "__getOutputValue");
    __name(interpolationSearch, "interpolationSearch");
    __name(__lerp, "__lerp");
    __name(__interpolate, "__interpolate");
  }
});

// src/foundation/definitions/AlphaMode.ts
function from8(index) {
  return _from({
    typeList: typeList8,
    index
  });
}
function fromString7(str) {
  return _fromString({
    typeList: typeList8,
    str
  });
}
function fromGlTFString(str) {
  return _fromString({
    typeList: typeList8,
    str
  });
}
var _a10, AlphaModeClass, Opaque, Mask, Blend, typeList8, AlphaMode;
var init_AlphaMode = __esm({
  "src/foundation/definitions/AlphaMode.ts"() {
    "use strict";
    init_EnumIO();
    AlphaModeClass = (_a10 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
      toGltfString() {
        return this.str;
      }
    }, __name(_a10, "AlphaModeClass"), _a10);
    Opaque = new AlphaModeClass({
      index: 0,
      str: "OPAQUE"
    });
    Mask = new AlphaModeClass({
      index: 1,
      str: "MASK"
    });
    Blend = new AlphaModeClass({
      index: 2,
      str: "BLEND"
    });
    typeList8 = [
      Opaque,
      Mask,
      Blend
    ];
    __name(from8, "from");
    __name(fromString7, "fromString");
    __name(fromGlTFString, "fromGlTFString");
    AlphaMode = Object.freeze({
      Opaque,
      Mask,
      Blend,
      from: from8,
      fromString: fromString7,
      fromGlTFString
    });
  }
});

// src/foundation/definitions/BasisCompressionType.ts
function from9(index) {
  return _from({
    typeList: typeList9,
    index
  });
}
function fromString8(str) {
  return _fromString({
    typeList: typeList9,
    str
  });
}
var _a11, BasisCompressionTypeClass, ETC1, ETC2, BC1, BC3, BC4, BC5, BC7_M6_OPAQUE, BC7_M5, PVRTC1_RGB, PVRTC1_RGBA, ASTC, ATC_RGB, ATC_RGBA, RGBA32, RGB565, BGR565, RGBA4444, typeList9, BasisCompressionType;
var init_BasisCompressionType = __esm({
  "src/foundation/definitions/BasisCompressionType.ts"() {
    "use strict";
    init_EnumIO();
    BasisCompressionTypeClass = (_a11 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a11, "BasisCompressionTypeClass"), _a11);
    ETC1 = new BasisCompressionTypeClass({
      index: 0,
      str: "ETC1"
    });
    ETC2 = new BasisCompressionTypeClass({
      index: 1,
      str: "ETC2"
    });
    BC1 = new BasisCompressionTypeClass({
      index: 2,
      str: "BC1"
    });
    BC3 = new BasisCompressionTypeClass({
      index: 3,
      str: "BC3"
    });
    BC4 = new BasisCompressionTypeClass({
      index: 4,
      str: "BC4"
    });
    BC5 = new BasisCompressionTypeClass({
      index: 5,
      str: "BC5"
    });
    BC7_M6_OPAQUE = new BasisCompressionTypeClass({
      index: 6,
      str: "BC7_M6_OPAQUE"
    });
    BC7_M5 = new BasisCompressionTypeClass({
      index: 7,
      str: "BC7_M5"
    });
    PVRTC1_RGB = new BasisCompressionTypeClass({
      index: 8,
      str: "PVRTC1_RGB"
    });
    PVRTC1_RGBA = new BasisCompressionTypeClass({
      index: 9,
      str: "PVRTC1_RGBA"
    });
    ASTC = new BasisCompressionTypeClass({
      index: 10,
      str: "ASTC"
    });
    ATC_RGB = new BasisCompressionTypeClass({
      index: 11,
      str: "ATC_RGB"
    });
    ATC_RGBA = new BasisCompressionTypeClass({
      index: 12,
      str: "ATC_RGBA"
    });
    RGBA32 = new BasisCompressionTypeClass({
      index: 13,
      str: "RGBA32"
    });
    RGB565 = new BasisCompressionTypeClass({
      index: 14,
      str: "RGB565"
    });
    BGR565 = new BasisCompressionTypeClass({
      index: 15,
      str: "BGR565"
    });
    RGBA4444 = new BasisCompressionTypeClass({
      index: 16,
      str: "RGBA4444"
    });
    typeList9 = [
      ETC1,
      ETC2,
      BC1,
      BC3,
      BC4,
      BC5,
      BC7_M5,
      BC7_M6_OPAQUE,
      PVRTC1_RGB,
      PVRTC1_RGBA,
      ASTC,
      ATC_RGB,
      ATC_RGBA,
      RGBA32,
      RGB565,
      BGR565,
      RGBA4444
    ];
    __name(from9, "from");
    __name(fromString8, "fromString");
    BasisCompressionType = Object.freeze({
      ETC1,
      ETC2,
      BC1,
      BC3,
      BC4,
      BC5,
      BC7_M5,
      BC7_M6_OPAQUE,
      PVRTC1_RGB,
      PVRTC1_RGBA,
      ASTC,
      ATC_RGB,
      ATC_RGBA,
      RGBA32,
      RGB565,
      BGR565,
      RGBA4444,
      from: from9,
      fromString: fromString8
    });
  }
});

// src/foundation/definitions/CameraControllerType.ts
function from10(index) {
  return _from({
    typeList: typeList10,
    index
  });
}
function fromString9(str) {
  return _fromString({
    typeList: typeList10,
    str
  });
}
var _a12, CameraControllerTypeClass, Orbit, WalkThrough, typeList10, CameraControllerType;
var init_CameraControllerType = __esm({
  "src/foundation/definitions/CameraControllerType.ts"() {
    "use strict";
    init_EnumIO();
    CameraControllerTypeClass = (_a12 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a12, "CameraControllerTypeClass"), _a12);
    Orbit = new CameraControllerTypeClass({
      index: 0,
      str: "Orbit"
    });
    WalkThrough = new CameraControllerTypeClass({
      index: 1,
      str: "WalkThrough"
    });
    typeList10 = [
      Orbit,
      WalkThrough
    ];
    __name(from10, "from");
    __name(fromString9, "fromString");
    CameraControllerType = Object.freeze({
      Orbit,
      WalkThrough,
      from: from10,
      fromString: fromString9
    });
  }
});

// src/foundation/definitions/CameraType.ts
function from11(index) {
  return _from({
    typeList: typeList11,
    index
  });
}
function fromString10(str) {
  return _fromString({
    typeList: typeList11,
    str
  });
}
var _a13, CameraTypeClass, Perspective, Orthographic, Frustum, typeList11, CameraType;
var init_CameraType = __esm({
  "src/foundation/definitions/CameraType.ts"() {
    "use strict";
    init_EnumIO();
    CameraTypeClass = (_a13 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a13, "CameraTypeClass"), _a13);
    Perspective = new CameraTypeClass({
      index: 0,
      str: "Perspective"
    });
    Orthographic = new CameraTypeClass({
      index: 1,
      str: "Orthographic"
    });
    Frustum = new CameraTypeClass({
      index: 2,
      str: "Frustum"
    });
    typeList11 = [
      Perspective,
      Orthographic,
      Frustum
    ];
    __name(from11, "from");
    __name(fromString10, "fromString");
    CameraType = Object.freeze({
      Perspective,
      Orthographic,
      Frustum,
      from: from11,
      fromString: fromString10
    });
  }
});

// src/foundation/definitions/CompressionTextureType.ts
function from12(index) {
  return _from({
    typeList: typeList12,
    index
  });
}
function fromString11(str) {
  return _fromString({
    typeList: typeList12,
    str
  });
}
var _a14, CompressionTextureTypeClass, ASTC_RGBA_4x4, ASTC_RGBA_5x4, ASTC_RGBA_5x5, ASTC_RGBA_6x5, ASTC_RGBA_6x6, ASTC_RGBA_8x5, ASTC_RGBA_8x6, ASTC_RGBA_8x8, ASTC_RGBA_10x5, ASTC_RGBA_10x6, ASTC_RGBA_10x8, ASTC_RGBA_10x10, ASTC_RGBA_12x10, ASTC_RGBA_12x12, ASTC_SRGB_4x4, ASTC_SRGB_5x4, ASTC_SRGB_5x5, ASTC_SRGB_6x5, ASTC_SRGB_6x6, ASTC_SRGB_8x5, ASTC_SRGB_8x6, ASTC_SRGB_8x8, ASTC_SRGB_10x5, ASTC_SRGB_10x6, ASTC_SRGB_10x8, ASTC_SRGB_10x10, ASTC_SRGB_12x10, ASTC_SRGB_12x12, S3TC_RGB_DXT1, S3TC_RGBA_DXT1, S3TC_RGBA_DXT3, S3TC_RGBA_DXT5, BPTC_RGBA, PVRTC_RGBA_4BPPV1, PVRTC_RGB_4BPPV1, ETC2_RGBA8_EAC, ETC2_RGB8, ETC1_RGB, RGBA8_EXT, typeList12, CompressionTextureType;
var init_CompressionTextureType = __esm({
  "src/foundation/definitions/CompressionTextureType.ts"() {
    "use strict";
    init_EnumIO();
    CompressionTextureTypeClass = (_a14 = class extends EnumClass {
      constructor({ index, str, webgpu, blockInfo }) {
        super({
          index,
          str
        });
        __publicField(this, "__webgpu");
        __publicField(this, "__blockInfo");
        this.__webgpu = webgpu;
        this.__blockInfo = blockInfo;
      }
      get webgpu() {
        if (this.__webgpu === void 0) {
          throw new Error(`does not support ${this.str}`);
        }
        return this.__webgpu;
      }
      get blockInfo() {
        if (this.__blockInfo === void 0) {
          throw new Error(`does not support ${this.str}`);
        }
        return this.__blockInfo;
      }
    }, __name(_a14, "CompressionTextureTypeClass"), _a14);
    ASTC_RGBA_4x4 = new CompressionTextureTypeClass({
      index: 37808,
      str: "COMPRESSED_RGBA_ASTC_4x4_KHR",
      webgpu: "astc-4x4-unorm",
      blockInfo: {
        byteSize: 16,
        width: 4,
        height: 4
      }
    });
    ASTC_RGBA_5x4 = new CompressionTextureTypeClass({
      index: 37809,
      str: "COMPRESSED_RGBA_ASTC_5x4_KHR",
      webgpu: "astc-5x4-unorm"
    });
    ASTC_RGBA_5x5 = new CompressionTextureTypeClass({
      index: 37810,
      str: "COMPRESSED_RGBA_ASTC_5x5_KHR",
      webgpu: "astc-5x5-unorm"
    });
    ASTC_RGBA_6x5 = new CompressionTextureTypeClass({
      index: 37811,
      str: "COMPRESSED_RGBA_ASTC_6x5_KHR",
      webgpu: "astc-6x5-unorm"
    });
    ASTC_RGBA_6x6 = new CompressionTextureTypeClass({
      index: 37812,
      str: "COMPRESSED_RGBA_ASTC_6x6_KHR",
      webgpu: "astc-6x6-unorm"
    });
    ASTC_RGBA_8x5 = new CompressionTextureTypeClass({
      index: 37813,
      str: "COMPRESSED_RGBA_ASTC_8x5_KHR",
      webgpu: "astc-8x5-unorm"
    });
    ASTC_RGBA_8x6 = new CompressionTextureTypeClass({
      index: 37814,
      str: "COMPRESSED_RGBA_ASTC_8x6_KHR",
      webgpu: "astc-8x6-unorm"
    });
    ASTC_RGBA_8x8 = new CompressionTextureTypeClass({
      index: 37815,
      str: "COMPRESSED_RGBA_ASTC_8x8_KHR",
      webgpu: "astc-8x8-unorm"
    });
    ASTC_RGBA_10x5 = new CompressionTextureTypeClass({
      index: 37816,
      str: "COMPRESSED_RGBA_ASTC_10x5_KHR",
      webgpu: "astc-10x5-unorm"
    });
    ASTC_RGBA_10x6 = new CompressionTextureTypeClass({
      index: 37817,
      str: "COMPRESSED_RGBA_ASTC_10x6_KHR",
      webgpu: "astc-10x6-unorm"
    });
    ASTC_RGBA_10x8 = new CompressionTextureTypeClass({
      index: 37818,
      str: "COMPRESSED_RGBA_ASTC_10x8_KHR",
      webgpu: "astc-10x8-unorm"
    });
    ASTC_RGBA_10x10 = new CompressionTextureTypeClass({
      index: 37819,
      str: "COMPRESSED_RGBA_ASTC_10x10_KHR",
      webgpu: "astc-10x10-unorm"
    });
    ASTC_RGBA_12x10 = new CompressionTextureTypeClass({
      index: 37820,
      str: "COMPRESSED_RGBA_ASTC_12x10_KHR",
      webgpu: "astc-12x10-unorm"
    });
    ASTC_RGBA_12x12 = new CompressionTextureTypeClass({
      index: 37821,
      str: "COMPRESSED_RGBA_ASTC_12x12_KHR",
      webgpu: "astc-12x12-unorm"
    });
    ASTC_SRGB_4x4 = new CompressionTextureTypeClass({
      index: 37840,
      str: "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR",
      webgpu: "astc-4x4-unorm-srgb",
      blockInfo: {
        byteSize: 16,
        width: 4,
        height: 4
      }
    });
    ASTC_SRGB_5x4 = new CompressionTextureTypeClass({
      index: 37841,
      str: "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR",
      webgpu: "astc-5x4-unorm-srgb"
    });
    ASTC_SRGB_5x5 = new CompressionTextureTypeClass({
      index: 37842,
      str: "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR",
      webgpu: "astc-5x5-unorm-srgb"
    });
    ASTC_SRGB_6x5 = new CompressionTextureTypeClass({
      index: 37843,
      str: "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR",
      webgpu: "astc-6x5-unorm-srgb"
    });
    ASTC_SRGB_6x6 = new CompressionTextureTypeClass({
      index: 37844,
      str: "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR",
      webgpu: "astc-6x6-unorm-srgb"
    });
    ASTC_SRGB_8x5 = new CompressionTextureTypeClass({
      index: 37845,
      str: "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR",
      webgpu: "astc-8x5-unorm-srgb"
    });
    ASTC_SRGB_8x6 = new CompressionTextureTypeClass({
      index: 37846,
      str: "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR",
      webgpu: "astc-8x6-unorm-srgb"
    });
    ASTC_SRGB_8x8 = new CompressionTextureTypeClass({
      index: 37847,
      str: "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR",
      webgpu: "astc-8x8-unorm-srgb"
    });
    ASTC_SRGB_10x5 = new CompressionTextureTypeClass({
      index: 37848,
      str: "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR",
      webgpu: "astc-10x5-unorm-srgb"
    });
    ASTC_SRGB_10x6 = new CompressionTextureTypeClass({
      index: 37849,
      str: "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR",
      webgpu: "astc-10x6-unorm-srgb"
    });
    ASTC_SRGB_10x8 = new CompressionTextureTypeClass({
      index: 37850,
      str: "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR",
      webgpu: "astc-10x8-unorm-srgb"
    });
    ASTC_SRGB_10x10 = new CompressionTextureTypeClass({
      index: 37851,
      str: "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR",
      webgpu: "astc-10x10-unorm-srgb"
    });
    ASTC_SRGB_12x10 = new CompressionTextureTypeClass({
      index: 37852,
      str: "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR",
      webgpu: "astc-12x10-unorm-srgb"
    });
    ASTC_SRGB_12x12 = new CompressionTextureTypeClass({
      index: 37853,
      str: "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR",
      webgpu: "astc-12x12-unorm-srgb"
    });
    S3TC_RGB_DXT1 = new CompressionTextureTypeClass({
      index: 33776,
      str: "COMPRESSED_RGB_S3TC_DXT1_EXT",
      webgpu: "bc1-rgba-unorm",
      blockInfo: {
        byteSize: 8,
        width: 4,
        height: 4
      }
    });
    S3TC_RGBA_DXT1 = new CompressionTextureTypeClass({
      index: 33777,
      str: "COMPRESSED_RGBA_S3TC_DXT1_EXT",
      webgpu: "bc1-rgba-unorm",
      blockInfo: {
        byteSize: 8,
        width: 4,
        height: 4
      }
    });
    S3TC_RGBA_DXT3 = new CompressionTextureTypeClass({
      index: 33778,
      str: "COMPRESSED_RGBA_S3TC_DXT3_EXT",
      webgpu: "bc2-rgba-unorm",
      blockInfo: {
        byteSize: 16,
        width: 4,
        height: 4
      }
    });
    S3TC_RGBA_DXT5 = new CompressionTextureTypeClass({
      index: 33779,
      str: "COMPRESSED_RGBA_S3TC_DXT5_EXT",
      webgpu: "bc3-rgba-unorm",
      blockInfo: {
        byteSize: 16,
        width: 4,
        height: 4
      }
    });
    BPTC_RGBA = new CompressionTextureTypeClass({
      index: 36492,
      str: "COMPRESSED_RGBA_BPTC_UNORM_EXT",
      webgpu: "bc7-rgba-unorm",
      blockInfo: {
        byteSize: 16,
        width: 4,
        height: 4
      }
    });
    PVRTC_RGBA_4BPPV1 = new CompressionTextureTypeClass({
      index: 35842,
      str: "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",
      blockInfo: {
        byteSize: 8,
        width: 4,
        height: 4
      }
    });
    PVRTC_RGB_4BPPV1 = new CompressionTextureTypeClass({
      index: 35840,
      str: "COMPRESSED_RGB_PVRTC_4BPPV1_IMG",
      blockInfo: {
        byteSize: 8,
        width: 4,
        height: 4
      }
    });
    ETC2_RGBA8_EAC = new CompressionTextureTypeClass({
      index: 37496,
      str: "COMPRESSED_RGBA8_ETC2_EAC",
      webgpu: "etc2-rgba8unorm",
      blockInfo: {
        byteSize: 16,
        width: 4,
        height: 4
      }
    });
    ETC2_RGB8 = new CompressionTextureTypeClass({
      index: 37492,
      str: "COMPRESSED_RGB8_ETC2",
      webgpu: "etc2-rgb8unorm",
      blockInfo: {
        byteSize: 16,
        width: 4,
        height: 4
      }
    });
    ETC1_RGB = new CompressionTextureTypeClass({
      index: 36196,
      str: "COMPRESSED_RGB_ETC1_WEBGL"
    });
    RGBA8_EXT = new CompressionTextureTypeClass({
      index: 32856,
      str: "RGBA8_EXT",
      blockInfo: {
        byteSize: 4,
        width: 1,
        height: 1
      }
    });
    typeList12 = [
      ASTC_RGBA_4x4,
      ASTC_RGBA_5x4,
      ASTC_RGBA_5x5,
      ASTC_RGBA_6x5,
      ASTC_RGBA_6x6,
      ASTC_RGBA_8x5,
      ASTC_RGBA_8x6,
      ASTC_RGBA_8x8,
      ASTC_RGBA_10x5,
      ASTC_RGBA_10x6,
      ASTC_RGBA_10x8,
      ASTC_RGBA_10x10,
      ASTC_RGBA_12x10,
      ASTC_RGBA_12x12,
      ASTC_SRGB_4x4,
      ASTC_SRGB_5x4,
      ASTC_SRGB_5x5,
      ASTC_SRGB_6x5,
      ASTC_SRGB_6x6,
      ASTC_SRGB_8x5,
      ASTC_SRGB_8x6,
      ASTC_SRGB_8x8,
      ASTC_SRGB_10x5,
      ASTC_SRGB_10x6,
      ASTC_SRGB_10x8,
      ASTC_SRGB_10x10,
      ASTC_SRGB_12x10,
      ASTC_SRGB_12x12,
      S3TC_RGB_DXT1,
      S3TC_RGBA_DXT1,
      S3TC_RGBA_DXT3,
      S3TC_RGBA_DXT5,
      BPTC_RGBA,
      PVRTC_RGBA_4BPPV1,
      PVRTC_RGB_4BPPV1,
      ETC2_RGBA8_EAC,
      ETC2_RGB8,
      ETC1_RGB,
      RGBA8_EXT
    ];
    __name(from12, "from");
    __name(fromString11, "fromString");
    CompressionTextureType = Object.freeze({
      ASTC_RGBA_4x4,
      ASTC_RGBA_5x4,
      ASTC_RGBA_5x5,
      ASTC_RGBA_6x5,
      ASTC_RGBA_6x6,
      ASTC_RGBA_8x5,
      ASTC_RGBA_8x6,
      ASTC_RGBA_8x8,
      ASTC_RGBA_10x5,
      ASTC_RGBA_10x6,
      ASTC_RGBA_10x8,
      ASTC_RGBA_10x10,
      ASTC_RGBA_12x10,
      ASTC_RGBA_12x12,
      ASTC_SRGB_4x4,
      ASTC_SRGB_5x4,
      ASTC_SRGB_5x5,
      ASTC_SRGB_6x5,
      ASTC_SRGB_6x6,
      ASTC_SRGB_8x5,
      ASTC_SRGB_8x6,
      ASTC_SRGB_8x8,
      ASTC_SRGB_10x5,
      ASTC_SRGB_10x6,
      ASTC_SRGB_10x8,
      ASTC_SRGB_10x10,
      ASTC_SRGB_12x10,
      ASTC_SRGB_12x12,
      S3TC_RGB_DXT1,
      S3TC_RGBA_DXT1,
      S3TC_RGBA_DXT3,
      S3TC_RGBA_DXT5,
      BPTC_RGBA,
      PVRTC_RGBA_4BPPV1,
      PVRTC_RGB_4BPPV1,
      ETC2_RGBA8_EAC,
      ETC2_RGB8,
      ETC1_RGB,
      RGBA8_EXT,
      from: from12,
      fromString: fromString11
    });
  }
});

// src/foundation/definitions/FileType.ts
function from13(index) {
  return _from({
    typeList: typeList13,
    index
  });
}
function fromString12(str) {
  const filetype = _fromString({
    typeList: typeList13,
    str
  });
  if (filetype != null) {
    return filetype;
  } else {
    return Unknown4;
  }
}
function isGltfOrGlb(file) {
  if (file === Gltf || file === GltfBinary) {
    return true;
  } else {
    return false;
  }
}
var _a15, FileTypeClass, Unknown4, Gltf, GltfBinary, VRM, Draco, EffekseerEffect, typeList13, FileType;
var init_FileType = __esm({
  "src/foundation/definitions/FileType.ts"() {
    "use strict";
    init_EnumIO();
    FileTypeClass = (_a15 = class extends EnumClass {
      constructor({ index, str, ext, brand }) {
        super({
          index,
          str
        });
        __publicField(this, "extension");
        __publicField(this, "brand");
        this.extension = ext;
        this.brand = brand;
      }
    }, __name(_a15, "FileTypeClass"), _a15);
    Unknown4 = new FileTypeClass({
      index: -1,
      str: "unknown",
      ext: "unknown",
      brand: "UnKnown"
    });
    Gltf = new FileTypeClass({
      index: 0,
      str: "gltf",
      ext: "gltf",
      brand: "glTF"
    });
    GltfBinary = new FileTypeClass({
      index: 1,
      str: "glb",
      ext: "glb",
      brand: "glTF"
    });
    VRM = new FileTypeClass({
      index: 2,
      str: "vrm",
      ext: "vrm",
      brand: "VRM"
    });
    Draco = new FileTypeClass({
      index: 3,
      str: "drc",
      ext: "drc",
      brand: "Draco"
    });
    EffekseerEffect = new FileTypeClass({
      index: 4,
      str: "efk",
      ext: "efk",
      brand: "EffekseerEffect"
    });
    typeList13 = [
      Unknown4,
      Gltf,
      GltfBinary,
      VRM,
      Draco,
      EffekseerEffect
    ];
    __name(from13, "from");
    __name(fromString12, "fromString");
    __name(isGltfOrGlb, "isGltfOrGlb");
    FileType = Object.freeze({
      Unknown: Unknown4,
      Gltf,
      GltfBinary,
      VRM,
      Draco,
      EffekseerEffect,
      from: from13,
      fromString: fromString12,
      isGltfOrGlb
    });
  }
});

// src/foundation/definitions/HdriFormat.ts
function from14(index) {
  return _from({
    typeList: typeList14,
    index
  });
}
function fromString13(str) {
  return _fromString({
    typeList: typeList14,
    str
  });
}
var _a16, HdriFormatClass, LDR_SRGB, LDR_LINEAR, HDR_LINEAR, RGBE_PNG, RGB9_E5_PNG, OpenEXR, typeList14, HdriFormat;
var init_HdriFormat = __esm({
  "src/foundation/definitions/HdriFormat.ts"() {
    "use strict";
    init_EnumIO();
    HdriFormatClass = (_a16 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a16, "HdriFormatClass"), _a16);
    LDR_SRGB = new HdriFormatClass({
      index: 0,
      str: ".ldr_srgb"
    });
    LDR_LINEAR = new HdriFormatClass({
      index: 1,
      str: ".ldr_linear"
    });
    HDR_LINEAR = new HdriFormatClass({
      index: 2,
      str: ".hdr"
    });
    RGBE_PNG = new HdriFormatClass({
      index: 3,
      str: ".rgbe.png"
    });
    RGB9_E5_PNG = new HdriFormatClass({
      index: 4,
      str: ".rgb9_e5.png"
    });
    OpenEXR = new HdriFormatClass({
      index: 5,
      str: ".exr"
    });
    typeList14 = [
      LDR_SRGB,
      LDR_LINEAR,
      HDR_LINEAR,
      RGBE_PNG,
      RGB9_E5_PNG,
      OpenEXR
    ];
    __name(from14, "from");
    __name(fromString13, "fromString");
    HdriFormat = Object.freeze({
      LDR_SRGB,
      LDR_LINEAR,
      HDR_LINEAR,
      RGBE_PNG,
      RGB9_E5_PNG,
      OpenEXR,
      from: from14,
      fromString: fromString13
    });
  }
});

// src/foundation/definitions/LightType.ts
function from15(index) {
  return _from({
    typeList: typeList15,
    index
  });
}
function fromString14(str) {
  return _fromString({
    typeList: typeList15,
    str
  });
}
var _a17, LightTypeClass, Directional, Point, Spot, Ambient, typeList15, LightType;
var init_LightType = __esm({
  "src/foundation/definitions/LightType.ts"() {
    "use strict";
    init_EnumIO();
    LightTypeClass = (_a17 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a17, "LightTypeClass"), _a17);
    Directional = new LightTypeClass({
      index: 0,
      str: "Directional"
    });
    Point = new LightTypeClass({
      index: 1,
      str: "Point"
    });
    Spot = new LightTypeClass({
      index: 2,
      str: "Spot"
    });
    Ambient = new LightTypeClass({
      index: 3,
      str: "Ambient"
    });
    typeList15 = [
      Point,
      Directional,
      Spot,
      Ambient
    ];
    __name(from15, "from");
    __name(fromString14, "fromString");
    LightType = Object.freeze({
      Point,
      Directional,
      Spot,
      Ambient,
      from: from15,
      fromString: fromString14
    });
  }
});

// src/types/AnimationTypes.ts
var init_AnimationTypes = __esm({
  "src/types/AnimationTypes.ts"() {
    "use strict";
  }
});

// src/types/BasisTexture.ts
var init_BasisTexture = __esm({
  "src/types/BasisTexture.ts"() {
    "use strict";
  }
});

// src/types/CommonTypes.ts
var init_CommonTypes = __esm({
  "src/types/CommonTypes.ts"() {
    "use strict";
  }
});

// src/types/KTX2Texture.ts
var init_KTX2Texture = __esm({
  "src/types/KTX2Texture.ts"() {
    "use strict";
  }
});

// src/types/TypeConverter.ts
function fromTensorToCompositionType(vec) {
  switch (vec.className) {
    case "Scalar":
      return CompositionType.Scalar;
    case "Vector2":
      return CompositionType.Vec2;
    case "Vector3":
      return CompositionType.Vec3;
    case "Vector4":
      return CompositionType.Vec4;
    case "Matrix22":
      return CompositionType.Mat2;
    case "Matrix33":
      return CompositionType.Mat3;
    case "Matrix44":
      return CompositionType.Mat4;
    default:
      Logger.error("CompositionType.Unknown");
      return CompositionType.Unknown;
  }
}
var init_TypeConverter = __esm({
  "src/types/TypeConverter.ts"() {
    "use strict";
    init_CompositionType();
    init_Logger();
    __name(fromTensorToCompositionType, "fromTensorToCompositionType");
  }
});

// src/types/TypeGenerators.ts
var init_TypeGenerators = __esm({
  "src/types/TypeGenerators.ts"() {
    "use strict";
  }
});

// src/types/VRM0x.ts
var init_VRM0x = __esm({
  "src/types/VRM0x.ts"() {
    "use strict";
  }
});

// src/types/WebGLConstants.ts
var GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT, GL_COLOR_BUFFER_BIT, GL_POINTS, GL_LINES, GL_LINE_LOOP, GL_LINE_STRIP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA_SATURATE, GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, GL_FUNC_ADD, GL_FUNC_SUBSTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_BLEND_EQUATION, GL_BLEND_EQUATION_RGB, GL_BLEND_EQUATION_ALPHA, GL_BLEND_DST_RGB, GL_BLEND_SRC_RGB, GL_BLEND_DST_ALPHA, GL_BLEND_SRC_ALPHA, GL_BLEND_COLOR, GL_ARRAY_BUFFER_BINDING, GL_ELEMENT_ARRAY_BUFFER_BINDING, GL_LINE_WIDTH, GL_ALIASED_POINT_SIZE_RANGE, GL_ALIASED_LINE_WIDTH_RANGE, GL_CULL_FACE_MODE, GL_FRONT_FACE, GL_DEPTH_RANGE, GL_DEPTH_WRITEMASK, GL_DEPTH_CLEAR_VALUE, GL_DEPTH_FUNC, GL_STENCIL_CLEAR_VALUE, GL_STENCIL_FUNC, GL_STENCIL_FAIL, GL_STENCIL_PASS_DEPTH_FAIL, GL_STENCIL_PASS_DEPTH_PASS, GL_STENCIL_REF, GL_STENCIL_VALUE_MASK, GL_STENCIL_WRITEMASK, GL_STENCIL_BACK_FUNC, GL_STENCIL_BACK_FAIL, GL_STENCIL_BACK_PASS_DEPTH_FAIL, GL_STENCIL_BACK_PASS_DEPTH_PASS, GL_STENCIL_BACK_REF, GL_STENCIL_BACK_VALUE_MASK, GL_STENCIL_BACK_WRITEMASK, GL_VIEWPORT, GL_SCISSOR_BOX, GL_COLOR_CLEAR_VALUE, GL_COLOR_WRITEMASK, GL_UNPACK_ALIGNMENT, GL_PACK_ALIGNMENT, GL_MAX_TEXTURE_SIZE, GL_MAX_VIEWPORT_DIMS, GL_SUBPIXEL_BITS, GL_RED_BITS, GL_GREEN_BITS, GL_BLUE_BITS, GL_ALPHA_BITS, GL_DEPTH_BITS, GL_STENCIL_BITS, GL_POLYGON_OFFSET_UNITS, GL_POLYGON_OFFSET_FACTOR, GL_TEXTURE_BINDING_2D, GL_SAMPLE_BUFFERS, GL_SAMPLES, GL_SAMPLE_COVERAGE_VALUE, GL_SAMPLE_COVERAGE_INVERT, GL_COMPRESSED_TEXTURE_FORMATS, GL_VENDOR, GL_RENDERER, GL_VERSION, GL_IMPLEMENTATION_COLOR_READ_TYPE, GL_IMPLEMENTATION_COLOR_READ_FORMAT, GL_BROWSER_DEFAULT_WEBGL, GL_STATIC_DRAW, GL_STREAM_DRAW, GL_DYNAMIC_DRAW, GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_BUFFER_SIZE, GL_BUFFER_USAGE, GL_CURRENT_VERTEX_ATTRIB, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_POINTER, GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_CULL_FACE, GL_FRONT, GL_BACK, GL_FRONT_AND_BACK, GL_BLEND, GL_DEPTH_TEST, GL_DITHER, GL_POLYGON_OFFSET_FILL, GL_SAMPLE_ALPHA_TO_COVERAGE, GL_SAMPLE_COVERAGE, GL_SCISSOR_TEST, GL_STENCIL_TEST, GL_NO_ERROR, GL_INVALID_ENUM, GL_INVALID_VALUE, GL_INVALID_OPERATION, GL_OUT_OF_MEMORY, GL_CONTEXT_LOST_WEBGL, GL_CW, GL_CCW, GL_DONT_CARE, GL_FASTEST, GL_NICEST, GL_GENERATE_MIPMAP_HINT, GL_DATA_BYTE, GL_DATA_UNSIGNED_BYTE, GL_DATA_SHORT, GL_DATA_UNSIGNED_SHORT, GL_DATA_INT, GL_DATA_UNSIGNED_INT, GL_DATA_FLOAT, GL_DEPTH_COMPONENT, GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_PIXEL_UNSIGNED_BYTE, GL_PIXEL_UNSIGNED_SHORT_4_4_4_4, GL_PIXEL_UNSIGNED_SHORT_5_5_5_1, GL_PIXEL_UNSIGNED_SHORT_5_6_5, GL_FRAGMENT_SHADER, GL_VERTEX_SHADER, GL_COMPILE_STATUS, GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_ATTACHED_SHADERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_UNIFORMS, GL_MAX_VERTEX_ATTRIBS, GL_MAX_VERTEX_UNIFORM_VECTORS, GL_MAX_VARYING_VECTORS, GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS, GL_MAX_TEXTURE_IMAGE_UNITS, GL_MAX_FRAGMENT_UNIFORM_VECTORS, GL_SHADER_TYPE, GL_SHADING_LANGUAGE_VERSION, GL_CURRENT_PROGRAM, GL_NEVER, GL_ALWAYS, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_NOTEQUAL, GL_KEEP, GL_REPLACE, GL_INCR, GL_DECR, GL_INVERT, GL_INCR_WRAP, GL_DECR_WRAP, GL_NEAREST, GL_LINEAR, GL_NEAREST_MIPMAP_NEAREST, GL_LINEAR_MIPMAP_NEAREST, GL_NEAREST_MIPMAP_LINEAR, GL_LINEAR_MIPMAP_LINEAR, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_2D, GL_TEXTURE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_BINDING_CUBE_MAP, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_MAX_CUBE_MAP_TEXTURE_SIZE, GL_TEXTURE0, GL_TEXTURE1, GL_TEXTURE2, GL_TEXTURE3, GL_TEXTURE4, GL_TEXTURE5, GL_TEXTURE6, GL_TEXTURE7, GL_TEXTURE8, GL_TEXTURE9, GL_TEXTURE10, GL_TEXTURE11, GL_TEXTURE12, GL_TEXTURE13, GL_TEXTURE14, GL_TEXTURE15, GL_TEXTURE16, GL_TEXTURE17, GL_TEXTURE18, GL_TEXTURE19, GL_TEXTURE20, GL_TEXTURE21, GL_TEXTURE22, GL_TEXTURE23, GL_TEXTURE24, GL_TEXTURE25, GL_TEXTURE26, GL_TEXTURE27, GL_TEXTURE28, GL_TEXTURE29, GL_TEXTURE30, GL_TEXTURE31, GL_ACTIVE_TEXTURE, GL_REPEAT, GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, GL_FLOAT_VEC2, GL_FLOAT_VEC3, GL_FLOAT_VEC4, GL_INT_VEC2, GL_INT_VEC3, GL_INT_VEC4, GL_BOOL, GL_BOOL_VEC2, GL_BOOL_VEC3, GL_BOOL_VEC4, GL_FLOAT_MAT2, GL_FLOAT_MAT3, GL_FLOAT_MAT4, GL_SAMPLER_2D, GL_SAMPLER_CUBE, GL_LOW_FLOAT, GL_MEDIUM_FLOAT, GL_HIGH_FLOAT, GL_LOW_INT, GL_MEDIUM_INT, GL_HIGH_INT, GL_FRAMEBUFFER, GL_RENDERBUFFER, GL_RGBA4, GL_RGB5_A1, GL_RGB565, GL_DEPTH_COMPONENT16, GL_STENCIL_INDEX, GL_STENCIL_INDEX8, GL_DEPTH_STENCIL, GL_RENDERBUFFER_WIDTH, GL_RENDERBUFFER_HEIGHT, GL_RENDERBUFFER_INTERNAL_FORMAT, GL_RENDERBUFFER_RED_SIZE, GL_RENDERBUFFER_GREEN_SIZE, GL_RENDERBUFFER_BLUE_SIZE, GL_RENDERBUFFER_ALPHA_SIZE, GL_RENDERBUFFER_DEPTH_SIZE, GL_RENDERBUFFER_STENCIL_SIZE, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL, GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE, GL_COLOR_ATTACHMENT0, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT, GL_DEPTH_STENCIL_ATTACHMENT, GL_NONE, GL_FRAMEBUFFER_COMPLETE, GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT, GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT, GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS, GL_FRAMEBUFFER_UNSUPPORTED, GL_FRAMEBUFFER_BINDING, GL_RENDERBUFFER_BINDING, GL_MAX_RENDERBUFFER_SIZE, GL_INVALID_FRAMEBUFFER_OPERATION, GL_UNPACK_FLIP_Y_WEBGL, GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, GL_READ_BUFFER, GL_UNPACK_ROW_LENGTH, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_PIXELS, GL_PACK_ROW_LENGTH, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_PIXELS, GL_TEXTURE_BINDING_3D, GL_UNPACK_SKIP_IMAGES, GL_UNPACK_IMAGE_HEIGHT, GL_MAX_3D_TEXTURE_SIZE, GL_MAX_ELEMENTS_VERTICES, GL_MAX_ELEMENTS_INDICES, GL_MAX_TEXTURE_LOD_BIAS, GL_MAX_FRAGMENT_UNIFORM_COMPONENTS, GL_MAX_VERTEX_UNIFORM_COMPONENTS, GL_MAX_ARRAY_TEXTURE_LAYERS, GL_MIN_PROGRAM_TEXEL_OFFSET, GL_MAX_PROGRAM_TEXEL_OFFSET, GL_MAX_VARYING_COMPONENTS, GL_FRAGMENT_SHADER_DERIVATIVE_HINT, GL_RASTERIZER_DISCARD, GL_VERTEX_ARRAY_BINDING, GL_MAX_VERTEX_OUTPUT_COMPONENTS, GL_MAX_FRAGMENT_INPUT_COMPONENTS, GL_MAX_SERVER_WAIT_TIMEOUT, GL_MAX_ELEMENT_INDEX, GL_RED, GL_RGB8, GL_RGBA8, GL_RGB10_A2, GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_SRGB, GL_SRGB8, GL_SRGB8_ALPHA8, GL_COMPARE_REF_TO_TEXTURE, GL_RGBA32F, GL_RGB32F, GL_RGBA16F, GL_RGB16F, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_BINDING_2D_ARRAY, GL_R11F_G11F_B10F, GL_RGB9_E5, GL_RGBA32UI, GL_RGB32UI, GL_RGBA16UI, GL_RGB16UI, GL_RGBA8UI, GL_RGB8UI, GL_RGBA32I, GL_RGB32I, GL_RGBA16I, GL_RGB16I, GL_RGBA8I, GL_RGB8I, GL_RED_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_R8, GL_RG8, GL_R16F, GL_R32F, GL_RG16F, GL_RG32F, GL_R8I, GL_R8UI, GL_R16I, GL_R16UI, GL_R32I, GL_R32UI, GL_RG8I, GL_RG8UI, GL_RG16I, GL_RG16UI, GL_RG32I, GL_RG32UI, GL_R8_SNORM, GL_RG8_SNORM, GL_RGB8_SNORM, GL_RGBA8_SNORM, GL_RGB10_A2UI, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, GL_FLOAT_32_UNSIGNED_INT_24_8_REV, GL_UNSIGNED_INT_24_8, GL_HALF_FLOAT, GL_RG, GL_RG_INTEGER, GL_INT_2_10_10_10_REV, GL_CURRENT_QUERY, GL_QUERY_RESULT, GL_QUERY_RESULT_AVAILABLE, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_MAX_DRAW_BUFFERS, GL_DRAW_BUFFER0, GL_DRAW_BUFFER1, GL_DRAW_BUFFER2, GL_DRAW_BUFFER3, GL_DRAW_BUFFER4, GL_DRAW_BUFFER5, GL_DRAW_BUFFER6, GL_DRAW_BUFFER7, GL_DRAW_BUFFER8, GL_DRAW_BUFFER9, GL_DRAW_BUFFER10, GL_DRAW_BUFFER11, GL_DRAW_BUFFER12, GL_DRAW_BUFFER13, GL_DRAW_BUFFER14, GL_DRAW_BUFFER15, GL_MAX_COLOR_ATTACHMENTS, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3, GL_COLOR_ATTACHMENT4, GL_COLOR_ATTACHMENT5, GL_COLOR_ATTACHMENT6, GL_COLOR_ATTACHMENT7, GL_COLOR_ATTACHMENT8, GL_COLOR_ATTACHMENT9, GL_COLOR_ATTACHMENT10, GL_COLOR_ATTACHMENT11, GL_COLOR_ATTACHMENT12, GL_COLOR_ATTACHMENT13, GL_COLOR_ATTACHMENT14, GL_COLOR_ATTACHMENT15, GL_SAMPLER_3D, GL_SAMPLER_2D_SHADOW, GL_SAMPLER_2D_ARRAY, GL_SAMPLER_2D_ARRAY_SHADOW, GL_SAMPLER_CUBE_SHADOW, GL_INT_SAMPLER_2D, GL_INT_SAMPLER_3D, GL_INT_SAMPLER_CUBE, GL_INT_SAMPLER_2D_ARRAY, GL_UNSIGNED_INT_SAMPLER_2D, GL_UNSIGNED_INT_SAMPLER_3D, GL_UNSIGNED_INT_SAMPLER_CUBE, GL_UNSIGNED_INT_SAMPLER_2D_ARRAY, GL_MAX_SAMPLES, GL_SAMPLER_BINDING, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_PIXEL_PACK_BUFFER_BINDING, GL_PIXEL_UNPACK_BUFFER_BINDING, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_COPY_READ_BUFFER_BINDING, GL_COPY_WRITE_BUFFER_BINDING, GL_FLOAT_MAT2X3, GL_FLOAT_MAT2X4, GL_FLOAT_MAT3X2, GL_FLOAT_MAT3X4, GL_FLOAT_MAT4X2, GL_FLOAT_MAT4X3, GL_UNSIGNED_INT_VEC2, GL_UNSIGNED_INT_VEC3, GL_UNSIGNED_INT_VEC4, GL_UNSIGNED_NORMALIZED, GL_SIGNED_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS, GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS, GL_INTERLEAVED_ATTRIBS, GL_SEPARATE_ATTRIBS, GL_TRANSFORM_FEEDBACK_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_ACTIVE, GL_TRANSFORM_FEEDBACK_BINDING, GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE, GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE, GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE, GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE, GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE, GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE, GL_FRAMEBUFFER_DEFAULT, GL_DEPTH24_STENCIL8, GL_DRAW_FRAMEBUFFER_BINDING, GL_READ_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER_BINDING, GL_RENDERBUFFER_SAMPLES, GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER, GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE, GL_UNIFORM_BUFFER, GL_UNIFORM_BUFFER_BINDING, GL_UNIFORM_BUFFER_START, GL_UNIFORM_BUFFER_SIZE, GL_MAX_VERTEX_UNIFORM_BLOCKS, GL_MAX_FRAGMENT_UNIFORM_BLOCKS, GL_MAX_COMBINED_UNIFORM_BLOCKS, GL_MAX_UNIFORM_BUFFER_BINDINGS, GL_MAX_UNIFORM_BLOCK_SIZE, GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS, GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS, GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, GL_ACTIVE_UNIFORM_BLOCKS, GL_UNIFORM_TYPE, GL_UNIFORM_SIZE, GL_UNIFORM_BLOCK_INDEX, GL_UNIFORM_OFFSET, GL_UNIFORM_ARRAY_STRIDE, GL_UNIFORM_MATRIX_STRIDE, GL_UNIFORM_IS_ROW_MAJOR, GL_UNIFORM_BLOCK_BINDING, GL_UNIFORM_BLOCK_DATA_SIZE, GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS, GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES, GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER, GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER, GL_OBJECT_TYPE, GL_SYNC_CONDITION, GL_SYNC_STATUS, GL_SYNC_FLAGS, GL_SYNC_FENCE, GL_SYNC_GPU_COMMANDS_COMPLETE, GL_UNSIGNALED, GL_SIGNALED, GL_ALREADY_SIGNALED, GL_TIMEOUT_EXPIRED, GL_CONDITION_SATISFIED, GL_WAIT_FAILED, GL_SYNC_FLUSH_COMMANDS_BIT, GL_COLOR, GL_DEPTH, GL_STENCIL, GL_MIN, GL_MAX, GL_DEPTH_COMPONENT24, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_READ, GL_DYNAMIC_COPY, GL_DEPTH_COMPONENT32F, GL_DEPTH32F_STENCIL8, GL_INVALID_INDEX, GL_TIMEOUT_IGNORED, GL_MAX_CLIENT_WAIT_TIMEOUT_WEBGL, GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE, GL_UNMASKED_VENDOR_WEBGL, GL_UNMASKED_RENDERER_WEBGL, GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, GL_TEXTURE_MAX_ANISOTROPY_EXT, GL_COMPRESSED_RGB_S3TC_DXT1_EXT, GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, GL_COMPRESSED_RGBA_S3TC_DXT3_EXT, GL_COMPRESSED_RGBA_S3TC_DXT5_EXT, GL_COMPRESSED_SRGB_S3TC_DXT1_EXT, GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, GL_COMPRESSED_R11_EAC, GL_COMPRESSED_SIGNED_R11_EAC, GL_COMPRESSED_RG11_EAC, GL_COMPRESSED_SIGNED_RG11_EAC, GL_COMPRESSED_RGB8_ETC2, GL_COMPRESSED_RGBA8_ETC2_EAC, GL_COMPRESSED_SRGB8_ETC2, GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG, GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG, GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG, GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG, GL_COMPRESSED_RGB_ETC1_WEBGL, GL_COMPRESSED_RGB_ATC_WEBGL, GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL, GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL, GL_COMPRESSED_RGBA_ASTC_4X4_KHR, GL_COMPRESSED_RGBA_ASTC_5X4_KHR, GL_COMPRESSED_RGBA_ASTC_5X5_KHR, GL_COMPRESSED_RGBA_ASTC_6X5_KHR, GL_COMPRESSED_RGBA_ASTC_6X6_KHR, GL_COMPRESSED_RGBA_ASTC_8X5_KHR, GL_COMPRESSED_RGBA_ASTC_8X6_KHR, GL_COMPRESSED_RGBA_ASTC_8X8_KHR, GL_COMPRESSED_RGBA_ASTC_10X5_KHR, GL_COMPRESSED_RGBA_ASTC_10X6_KHR, GL_COMPRESSED_RGBA_ASTC_10X8_KHR, GL_COMPRESSED_RGBA_ASTC_10X10_KHR, GL_COMPRESSED_RGBA_ASTC_12X10_KHR, GL_COMPRESSED_RGBA_ASTC_12X12_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR, GL_UNSIGNED_INT_24_8_WEBGL, GL_HALF_FLOAT_OES, GL_RGBA32F_EXT, GL_RGB32F_EXT, GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT, GL_UNSIGNED_NORMALIZED_EXT, GL_MIN_EXT, GL_MAX_EXT, GL_SRGB_EXT, GL_SRGB_ALPHA_EXT, GL_SRGB8_ALPHA8_EXT, GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT, GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES, GL_COLOR_ATTACHMENT0_WEBGL, GL_COLOR_ATTACHMENT1_WEBGL, GL_COLOR_ATTACHMENT2_WEBGL, GL_COLOR_ATTACHMENT3_WEBGL, GL_COLOR_ATTACHMENT4_WEBGL, GL_COLOR_ATTACHMENT5_WEBGL, GL_COLOR_ATTACHMENT6_WEBGL, GL_COLOR_ATTACHMENT7_WEBGL, GL_COLOR_ATTACHMENT8_WEBGL, GL_COLOR_ATTACHMENT9_WEBGL, GL_COLOR_ATTACHMENT10_WEBGL, GL_COLOR_ATTACHMENT11_WEBGL, GL_COLOR_ATTACHMENT12_WEBGL, GL_COLOR_ATTACHMENT13_WEBGL, GL_COLOR_ATTACHMENT14_WEBGL, GL_COLOR_ATTACHMENT15_WEBGL, GL_DRAW_BUFFER0_WEBGL, GL_DRAW_BUFFER1_WEBGL, GL_DRAW_BUFFER2_WEBGL, GL_DRAW_BUFFER3_WEBGL, GL_DRAW_BUFFER4_WEBGL, GL_DRAW_BUFFER5_WEBGL, GL_DRAW_BUFFER6_WEBGL, GL_DRAW_BUFFER7_WEBGL, GL_DRAW_BUFFER8_WEBGL, GL_DRAW_BUFFER9_WEBGL, GL_DRAW_BUFFER10_WEBGL, GL_DRAW_BUFFER11_WEBGL, GL_DRAW_BUFFER12_WEBGL, GL_DRAW_BUFFER13_WEBGL, GL_DRAW_BUFFER14_WEBGL, GL_DRAW_BUFFER15_WEBGL, GL_MAX_COLOR_ATTACHMENTS_WEBGL, GL_MAX_DRAW_BUFFERS_WEBGL, GL_VERTEX_ARRAY_BINDING_OES, GL_QUERY_COUNTER_BITS_EXT, GL_CURRENT_QUERY_EXT, GL_QUERY_RESULT_EXT, GL_QUERY_RESULT_AVAILABLE_EXT, GL_TIME_ELAPSED_EXT, GL_TIMESTAMP_EXT, GL_GPU_DISJOINT_EXT;
var init_WebGLConstants = __esm({
  "src/types/WebGLConstants.ts"() {
    "use strict";
    GL_DEPTH_BUFFER_BIT = 256;
    GL_STENCIL_BUFFER_BIT = 1024;
    GL_COLOR_BUFFER_BIT = 16384;
    GL_POINTS = 0;
    GL_LINES = 1;
    GL_LINE_LOOP = 2;
    GL_LINE_STRIP = 3;
    GL_TRIANGLES = 4;
    GL_TRIANGLE_STRIP = 5;
    GL_TRIANGLE_FAN = 6;
    GL_ZERO = 0;
    GL_ONE = 1;
    GL_SRC_COLOR = 768;
    GL_ONE_MINUS_SRC_COLOR = 769;
    GL_SRC_ALPHA = 770;
    GL_ONE_MINUS_SRC_ALPHA = 771;
    GL_DST_ALPHA = 772;
    GL_ONE_MINUS_DST_ALPHA = 773;
    GL_DST_COLOR = 774;
    GL_ONE_MINUS_DST_COLOR = 775;
    GL_SRC_ALPHA_SATURATE = 776;
    GL_CONSTANT_COLOR = 32769;
    GL_ONE_MINUS_CONSTANT_COLOR = 32770;
    GL_CONSTANT_ALPHA = 32771;
    GL_ONE_MINUS_CONSTANT_ALPHA = 32772;
    GL_FUNC_ADD = 32774;
    GL_FUNC_SUBSTRACT = 32778;
    GL_FUNC_REVERSE_SUBTRACT = 32779;
    GL_BLEND_EQUATION = 32777;
    GL_BLEND_EQUATION_RGB = 32777;
    GL_BLEND_EQUATION_ALPHA = 34877;
    GL_BLEND_DST_RGB = 32968;
    GL_BLEND_SRC_RGB = 32969;
    GL_BLEND_DST_ALPHA = 32970;
    GL_BLEND_SRC_ALPHA = 32971;
    GL_BLEND_COLOR = 32773;
    GL_ARRAY_BUFFER_BINDING = 34964;
    GL_ELEMENT_ARRAY_BUFFER_BINDING = 34965;
    GL_LINE_WIDTH = 2849;
    GL_ALIASED_POINT_SIZE_RANGE = 33901;
    GL_ALIASED_LINE_WIDTH_RANGE = 33902;
    GL_CULL_FACE_MODE = 2885;
    GL_FRONT_FACE = 2886;
    GL_DEPTH_RANGE = 2928;
    GL_DEPTH_WRITEMASK = 2930;
    GL_DEPTH_CLEAR_VALUE = 2931;
    GL_DEPTH_FUNC = 2932;
    GL_STENCIL_CLEAR_VALUE = 2961;
    GL_STENCIL_FUNC = 2962;
    GL_STENCIL_FAIL = 2964;
    GL_STENCIL_PASS_DEPTH_FAIL = 2965;
    GL_STENCIL_PASS_DEPTH_PASS = 2966;
    GL_STENCIL_REF = 2967;
    GL_STENCIL_VALUE_MASK = 2963;
    GL_STENCIL_WRITEMASK = 2968;
    GL_STENCIL_BACK_FUNC = 34816;
    GL_STENCIL_BACK_FAIL = 34817;
    GL_STENCIL_BACK_PASS_DEPTH_FAIL = 34818;
    GL_STENCIL_BACK_PASS_DEPTH_PASS = 34819;
    GL_STENCIL_BACK_REF = 36003;
    GL_STENCIL_BACK_VALUE_MASK = 36004;
    GL_STENCIL_BACK_WRITEMASK = 36005;
    GL_VIEWPORT = 2978;
    GL_SCISSOR_BOX = 3088;
    GL_COLOR_CLEAR_VALUE = 3106;
    GL_COLOR_WRITEMASK = 3107;
    GL_UNPACK_ALIGNMENT = 3317;
    GL_PACK_ALIGNMENT = 3333;
    GL_MAX_TEXTURE_SIZE = 3379;
    GL_MAX_VIEWPORT_DIMS = 3386;
    GL_SUBPIXEL_BITS = 3408;
    GL_RED_BITS = 3410;
    GL_GREEN_BITS = 3411;
    GL_BLUE_BITS = 3412;
    GL_ALPHA_BITS = 3413;
    GL_DEPTH_BITS = 3414;
    GL_STENCIL_BITS = 3415;
    GL_POLYGON_OFFSET_UNITS = 10752;
    GL_POLYGON_OFFSET_FACTOR = 32824;
    GL_TEXTURE_BINDING_2D = 32873;
    GL_SAMPLE_BUFFERS = 32936;
    GL_SAMPLES = 32937;
    GL_SAMPLE_COVERAGE_VALUE = 32938;
    GL_SAMPLE_COVERAGE_INVERT = 32939;
    GL_COMPRESSED_TEXTURE_FORMATS = 34467;
    GL_VENDOR = 7936;
    GL_RENDERER = 7937;
    GL_VERSION = 7938;
    GL_IMPLEMENTATION_COLOR_READ_TYPE = 35738;
    GL_IMPLEMENTATION_COLOR_READ_FORMAT = 35739;
    GL_BROWSER_DEFAULT_WEBGL = 37444;
    GL_STATIC_DRAW = 35044;
    GL_STREAM_DRAW = 35040;
    GL_DYNAMIC_DRAW = 35048;
    GL_ARRAY_BUFFER = 34962;
    GL_ELEMENT_ARRAY_BUFFER = 34963;
    GL_BUFFER_SIZE = 34660;
    GL_BUFFER_USAGE = 34661;
    GL_CURRENT_VERTEX_ATTRIB = 34342;
    GL_VERTEX_ATTRIB_ARRAY_ENABLED = 34338;
    GL_VERTEX_ATTRIB_ARRAY_SIZE = 34339;
    GL_VERTEX_ATTRIB_ARRAY_STRIDE = 34340;
    GL_VERTEX_ATTRIB_ARRAY_TYPE = 34341;
    GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922;
    GL_VERTEX_ATTRIB_ARRAY_POINTER = 34373;
    GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975;
    GL_CULL_FACE = 2884;
    GL_FRONT = 1028;
    GL_BACK = 1029;
    GL_FRONT_AND_BACK = 1032;
    GL_BLEND = 3042;
    GL_DEPTH_TEST = 2929;
    GL_DITHER = 3024;
    GL_POLYGON_OFFSET_FILL = 32823;
    GL_SAMPLE_ALPHA_TO_COVERAGE = 32926;
    GL_SAMPLE_COVERAGE = 32928;
    GL_SCISSOR_TEST = 3089;
    GL_STENCIL_TEST = 2960;
    GL_NO_ERROR = 0;
    GL_INVALID_ENUM = 1280;
    GL_INVALID_VALUE = 1281;
    GL_INVALID_OPERATION = 1282;
    GL_OUT_OF_MEMORY = 1285;
    GL_CONTEXT_LOST_WEBGL = 37442;
    GL_CW = 2304;
    GL_CCW = 2305;
    GL_DONT_CARE = 4352;
    GL_FASTEST = 4353;
    GL_NICEST = 4354;
    GL_GENERATE_MIPMAP_HINT = 33170;
    GL_DATA_BYTE = 5120;
    GL_DATA_UNSIGNED_BYTE = 5121;
    GL_DATA_SHORT = 5122;
    GL_DATA_UNSIGNED_SHORT = 5123;
    GL_DATA_INT = 5124;
    GL_DATA_UNSIGNED_INT = 5125;
    GL_DATA_FLOAT = 5126;
    GL_DEPTH_COMPONENT = 6402;
    GL_ALPHA = 6406;
    GL_RGB = 6407;
    GL_RGBA = 6408;
    GL_LUMINANCE = 6409;
    GL_LUMINANCE_ALPHA = 6410;
    GL_PIXEL_UNSIGNED_BYTE = 5121;
    GL_PIXEL_UNSIGNED_SHORT_4_4_4_4 = 32819;
    GL_PIXEL_UNSIGNED_SHORT_5_5_5_1 = 32820;
    GL_PIXEL_UNSIGNED_SHORT_5_6_5 = 33635;
    GL_FRAGMENT_SHADER = 35632;
    GL_VERTEX_SHADER = 35633;
    GL_COMPILE_STATUS = 35713;
    GL_DELETE_STATUS = 35712;
    GL_LINK_STATUS = 35714;
    GL_VALIDATE_STATUS = 35715;
    GL_ATTACHED_SHADERS = 35717;
    GL_ACTIVE_ATTRIBUTES = 35721;
    GL_ACTIVE_UNIFORMS = 35718;
    GL_MAX_VERTEX_ATTRIBS = 34921;
    GL_MAX_VERTEX_UNIFORM_VECTORS = 36347;
    GL_MAX_VARYING_VECTORS = 36348;
    GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661;
    GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660;
    GL_MAX_TEXTURE_IMAGE_UNITS = 34930;
    GL_MAX_FRAGMENT_UNIFORM_VECTORS = 36349;
    GL_SHADER_TYPE = 35663;
    GL_SHADING_LANGUAGE_VERSION = 35724;
    GL_CURRENT_PROGRAM = 35725;
    GL_NEVER = 512;
    GL_ALWAYS = 519;
    GL_LESS = 513;
    GL_EQUAL = 514;
    GL_LEQUAL = 515;
    GL_GREATER = 516;
    GL_GEQUAL = 518;
    GL_NOTEQUAL = 517;
    GL_KEEP = 7680;
    GL_REPLACE = 7681;
    GL_INCR = 7682;
    GL_DECR = 7683;
    GL_INVERT = 5386;
    GL_INCR_WRAP = 34055;
    GL_DECR_WRAP = 34056;
    GL_NEAREST = 9728;
    GL_LINEAR = 9729;
    GL_NEAREST_MIPMAP_NEAREST = 9984;
    GL_LINEAR_MIPMAP_NEAREST = 9985;
    GL_NEAREST_MIPMAP_LINEAR = 9986;
    GL_LINEAR_MIPMAP_LINEAR = 9987;
    GL_TEXTURE_MAG_FILTER = 10240;
    GL_TEXTURE_MIN_FILTER = 10241;
    GL_TEXTURE_WRAP_S = 10242;
    GL_TEXTURE_WRAP_T = 10243;
    GL_TEXTURE_2D = 3553;
    GL_TEXTURE = 5890;
    GL_TEXTURE_CUBE_MAP = 34067;
    GL_TEXTURE_BINDING_CUBE_MAP = 34068;
    GL_TEXTURE_CUBE_MAP_POSITIVE_X = 34069;
    GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 34070;
    GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 34071;
    GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072;
    GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 34073;
    GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074;
    GL_MAX_CUBE_MAP_TEXTURE_SIZE = 34076;
    GL_TEXTURE0 = 33984;
    GL_TEXTURE1 = 33985;
    GL_TEXTURE2 = 33986;
    GL_TEXTURE3 = 33987;
    GL_TEXTURE4 = 33988;
    GL_TEXTURE5 = 33989;
    GL_TEXTURE6 = 33990;
    GL_TEXTURE7 = 33991;
    GL_TEXTURE8 = 33992;
    GL_TEXTURE9 = 33993;
    GL_TEXTURE10 = 33994;
    GL_TEXTURE11 = 33995;
    GL_TEXTURE12 = 33996;
    GL_TEXTURE13 = 33997;
    GL_TEXTURE14 = 33998;
    GL_TEXTURE15 = 33999;
    GL_TEXTURE16 = 34e3;
    GL_TEXTURE17 = 34001;
    GL_TEXTURE18 = 34002;
    GL_TEXTURE19 = 34003;
    GL_TEXTURE20 = 34004;
    GL_TEXTURE21 = 34005;
    GL_TEXTURE22 = 34006;
    GL_TEXTURE23 = 34007;
    GL_TEXTURE24 = 34008;
    GL_TEXTURE25 = 34009;
    GL_TEXTURE26 = 34010;
    GL_TEXTURE27 = 34011;
    GL_TEXTURE28 = 34012;
    GL_TEXTURE29 = 34013;
    GL_TEXTURE30 = 34014;
    GL_TEXTURE31 = 34015;
    GL_ACTIVE_TEXTURE = 34016;
    GL_REPEAT = 10497;
    GL_CLAMP_TO_EDGE = 33071;
    GL_MIRRORED_REPEAT = 33648;
    GL_FLOAT_VEC2 = 35664;
    GL_FLOAT_VEC3 = 35665;
    GL_FLOAT_VEC4 = 35666;
    GL_INT_VEC2 = 35667;
    GL_INT_VEC3 = 35668;
    GL_INT_VEC4 = 35669;
    GL_BOOL = 35670;
    GL_BOOL_VEC2 = 35671;
    GL_BOOL_VEC3 = 35672;
    GL_BOOL_VEC4 = 35673;
    GL_FLOAT_MAT2 = 35674;
    GL_FLOAT_MAT3 = 35675;
    GL_FLOAT_MAT4 = 35676;
    GL_SAMPLER_2D = 35678;
    GL_SAMPLER_CUBE = 35680;
    GL_LOW_FLOAT = 36336;
    GL_MEDIUM_FLOAT = 36337;
    GL_HIGH_FLOAT = 36338;
    GL_LOW_INT = 36339;
    GL_MEDIUM_INT = 36340;
    GL_HIGH_INT = 36341;
    GL_FRAMEBUFFER = 36160;
    GL_RENDERBUFFER = 36161;
    GL_RGBA4 = 32854;
    GL_RGB5_A1 = 32855;
    GL_RGB565 = 36194;
    GL_DEPTH_COMPONENT16 = 33189;
    GL_STENCIL_INDEX = 6401;
    GL_STENCIL_INDEX8 = 36168;
    GL_DEPTH_STENCIL = 34041;
    GL_RENDERBUFFER_WIDTH = 36162;
    GL_RENDERBUFFER_HEIGHT = 36163;
    GL_RENDERBUFFER_INTERNAL_FORMAT = 36164;
    GL_RENDERBUFFER_RED_SIZE = 36176;
    GL_RENDERBUFFER_GREEN_SIZE = 36177;
    GL_RENDERBUFFER_BLUE_SIZE = 36178;
    GL_RENDERBUFFER_ALPHA_SIZE = 36179;
    GL_RENDERBUFFER_DEPTH_SIZE = 36180;
    GL_RENDERBUFFER_STENCIL_SIZE = 36181;
    GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048;
    GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049;
    GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050;
    GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051;
    GL_COLOR_ATTACHMENT0 = 36064;
    GL_DEPTH_ATTACHMENT = 36096;
    GL_STENCIL_ATTACHMENT = 36128;
    GL_DEPTH_STENCIL_ATTACHMENT = 33306;
    GL_NONE = 0;
    GL_FRAMEBUFFER_COMPLETE = 36053;
    GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054;
    GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055;
    GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057;
    GL_FRAMEBUFFER_UNSUPPORTED = 36061;
    GL_FRAMEBUFFER_BINDING = 36006;
    GL_RENDERBUFFER_BINDING = 36007;
    GL_MAX_RENDERBUFFER_SIZE = 34024;
    GL_INVALID_FRAMEBUFFER_OPERATION = 1286;
    GL_UNPACK_FLIP_Y_WEBGL = 37440;
    GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441;
    GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443;
    GL_READ_BUFFER = 3074;
    GL_UNPACK_ROW_LENGTH = 3314;
    GL_UNPACK_SKIP_ROWS = 3315;
    GL_UNPACK_SKIP_PIXELS = 3316;
    GL_PACK_ROW_LENGTH = 3330;
    GL_PACK_SKIP_ROWS = 3331;
    GL_PACK_SKIP_PIXELS = 3332;
    GL_TEXTURE_BINDING_3D = 32874;
    GL_UNPACK_SKIP_IMAGES = 32877;
    GL_UNPACK_IMAGE_HEIGHT = 32878;
    GL_MAX_3D_TEXTURE_SIZE = 32883;
    GL_MAX_ELEMENTS_VERTICES = 33e3;
    GL_MAX_ELEMENTS_INDICES = 33001;
    GL_MAX_TEXTURE_LOD_BIAS = 34045;
    GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657;
    GL_MAX_VERTEX_UNIFORM_COMPONENTS = 35658;
    GL_MAX_ARRAY_TEXTURE_LAYERS = 35071;
    GL_MIN_PROGRAM_TEXEL_OFFSET = 35076;
    GL_MAX_PROGRAM_TEXEL_OFFSET = 35077;
    GL_MAX_VARYING_COMPONENTS = 35659;
    GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723;
    GL_RASTERIZER_DISCARD = 35977;
    GL_VERTEX_ARRAY_BINDING = 34229;
    GL_MAX_VERTEX_OUTPUT_COMPONENTS = 37154;
    GL_MAX_FRAGMENT_INPUT_COMPONENTS = 37157;
    GL_MAX_SERVER_WAIT_TIMEOUT = 37137;
    GL_MAX_ELEMENT_INDEX = 36203;
    GL_RED = 6403;
    GL_RGB8 = 32849;
    GL_RGBA8 = 32856;
    GL_RGB10_A2 = 32857;
    GL_TEXTURE_3D = 32879;
    GL_TEXTURE_WRAP_R = 32882;
    GL_TEXTURE_MIN_LOD = 33082;
    GL_TEXTURE_MAX_LOD = 33083;
    GL_TEXTURE_BASE_LEVEL = 33084;
    GL_TEXTURE_MAX_LEVEL = 33085;
    GL_TEXTURE_COMPARE_MODE = 34892;
    GL_TEXTURE_COMPARE_FUNC = 34893;
    GL_SRGB = 35904;
    GL_SRGB8 = 35905;
    GL_SRGB8_ALPHA8 = 35907;
    GL_COMPARE_REF_TO_TEXTURE = 34894;
    GL_RGBA32F = 34836;
    GL_RGB32F = 34837;
    GL_RGBA16F = 34842;
    GL_RGB16F = 34843;
    GL_TEXTURE_2D_ARRAY = 35866;
    GL_TEXTURE_BINDING_2D_ARRAY = 35869;
    GL_R11F_G11F_B10F = 35898;
    GL_RGB9_E5 = 35901;
    GL_RGBA32UI = 36208;
    GL_RGB32UI = 36209;
    GL_RGBA16UI = 36214;
    GL_RGB16UI = 36215;
    GL_RGBA8UI = 36220;
    GL_RGB8UI = 36221;
    GL_RGBA32I = 36226;
    GL_RGB32I = 36227;
    GL_RGBA16I = 36232;
    GL_RGB16I = 36233;
    GL_RGBA8I = 36238;
    GL_RGB8I = 36239;
    GL_RED_INTEGER = 36244;
    GL_RGB_INTEGER = 36248;
    GL_RGBA_INTEGER = 36249;
    GL_R8 = 33321;
    GL_RG8 = 33323;
    GL_R16F = 33325;
    GL_R32F = 33326;
    GL_RG16F = 33327;
    GL_RG32F = 33328;
    GL_R8I = 33329;
    GL_R8UI = 33330;
    GL_R16I = 33331;
    GL_R16UI = 33332;
    GL_R32I = 33333;
    GL_R32UI = 33334;
    GL_RG8I = 33335;
    GL_RG8UI = 33336;
    GL_RG16I = 33337;
    GL_RG16UI = 33338;
    GL_RG32I = 33339;
    GL_RG32UI = 33340;
    GL_R8_SNORM = 36756;
    GL_RG8_SNORM = 36757;
    GL_RGB8_SNORM = 36758;
    GL_RGBA8_SNORM = 36759;
    GL_RGB10_A2UI = 36975;
    GL_TEXTURE_IMMUTABLE_FORMAT = 37167;
    GL_TEXTURE_IMMUTABLE_LEVELS = 33503;
    GL_UNSIGNED_INT_2_10_10_10_REV = 33640;
    GL_UNSIGNED_INT_10F_11F_11F_REV = 35899;
    GL_UNSIGNED_INT_5_9_9_9_REV = 35902;
    GL_FLOAT_32_UNSIGNED_INT_24_8_REV = 36269;
    GL_UNSIGNED_INT_24_8 = 34042;
    GL_HALF_FLOAT = 5131;
    GL_RG = 33319;
    GL_RG_INTEGER = 33320;
    GL_INT_2_10_10_10_REV = 36255;
    GL_CURRENT_QUERY = 34917;
    GL_QUERY_RESULT = 34918;
    GL_QUERY_RESULT_AVAILABLE = 34919;
    GL_ANY_SAMPLES_PASSED = 35887;
    GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 36202;
    GL_MAX_DRAW_BUFFERS = 34852;
    GL_DRAW_BUFFER0 = 34853;
    GL_DRAW_BUFFER1 = 34854;
    GL_DRAW_BUFFER2 = 34855;
    GL_DRAW_BUFFER3 = 34856;
    GL_DRAW_BUFFER4 = 34857;
    GL_DRAW_BUFFER5 = 34858;
    GL_DRAW_BUFFER6 = 34859;
    GL_DRAW_BUFFER7 = 34860;
    GL_DRAW_BUFFER8 = 34861;
    GL_DRAW_BUFFER9 = 34862;
    GL_DRAW_BUFFER10 = 34863;
    GL_DRAW_BUFFER11 = 34864;
    GL_DRAW_BUFFER12 = 34865;
    GL_DRAW_BUFFER13 = 34866;
    GL_DRAW_BUFFER14 = 34867;
    GL_DRAW_BUFFER15 = 34868;
    GL_MAX_COLOR_ATTACHMENTS = 36063;
    GL_COLOR_ATTACHMENT1 = 36065;
    GL_COLOR_ATTACHMENT2 = 36066;
    GL_COLOR_ATTACHMENT3 = 36067;
    GL_COLOR_ATTACHMENT4 = 36068;
    GL_COLOR_ATTACHMENT5 = 36069;
    GL_COLOR_ATTACHMENT6 = 36070;
    GL_COLOR_ATTACHMENT7 = 36071;
    GL_COLOR_ATTACHMENT8 = 36072;
    GL_COLOR_ATTACHMENT9 = 36073;
    GL_COLOR_ATTACHMENT10 = 36074;
    GL_COLOR_ATTACHMENT11 = 36075;
    GL_COLOR_ATTACHMENT12 = 36076;
    GL_COLOR_ATTACHMENT13 = 36077;
    GL_COLOR_ATTACHMENT14 = 36078;
    GL_COLOR_ATTACHMENT15 = 36079;
    GL_SAMPLER_3D = 35679;
    GL_SAMPLER_2D_SHADOW = 35682;
    GL_SAMPLER_2D_ARRAY = 36289;
    GL_SAMPLER_2D_ARRAY_SHADOW = 36292;
    GL_SAMPLER_CUBE_SHADOW = 36293;
    GL_INT_SAMPLER_2D = 36298;
    GL_INT_SAMPLER_3D = 36299;
    GL_INT_SAMPLER_CUBE = 36300;
    GL_INT_SAMPLER_2D_ARRAY = 36303;
    GL_UNSIGNED_INT_SAMPLER_2D = 36306;
    GL_UNSIGNED_INT_SAMPLER_3D = 36307;
    GL_UNSIGNED_INT_SAMPLER_CUBE = 36308;
    GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311;
    GL_MAX_SAMPLES = 36183;
    GL_SAMPLER_BINDING = 35097;
    GL_PIXEL_PACK_BUFFER = 35051;
    GL_PIXEL_UNPACK_BUFFER = 35052;
    GL_PIXEL_PACK_BUFFER_BINDING = 35053;
    GL_PIXEL_UNPACK_BUFFER_BINDING = 35055;
    GL_COPY_READ_BUFFER = 36662;
    GL_COPY_WRITE_BUFFER = 36663;
    GL_COPY_READ_BUFFER_BINDING = 36662;
    GL_COPY_WRITE_BUFFER_BINDING = 36663;
    GL_FLOAT_MAT2X3 = 35685;
    GL_FLOAT_MAT2X4 = 35686;
    GL_FLOAT_MAT3X2 = 35687;
    GL_FLOAT_MAT3X4 = 35688;
    GL_FLOAT_MAT4X2 = 35689;
    GL_FLOAT_MAT4X3 = 35690;
    GL_UNSIGNED_INT_VEC2 = 36294;
    GL_UNSIGNED_INT_VEC3 = 36295;
    GL_UNSIGNED_INT_VEC4 = 36296;
    GL_UNSIGNED_NORMALIZED = 35863;
    GL_SIGNED_NORMALIZED = 36764;
    GL_VERTEX_ATTRIB_ARRAY_INTEGER = 35069;
    GL_VERTEX_ATTRIB_ARRAY_DIVISOR = 35070;
    GL_TRANSFORM_FEEDBACK_BUFFER_MODE = 35967;
    GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968;
    GL_TRANSFORM_FEEDBACK_VARYINGS = 35971;
    GL_TRANSFORM_FEEDBACK_BUFFER_START = 35972;
    GL_TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973;
    GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976;
    GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978;
    GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979;
    GL_INTERLEAVED_ATTRIBS = 35980;
    GL_SEPARATE_ATTRIBS = 35981;
    GL_TRANSFORM_FEEDBACK_BUFFER = 35982;
    GL_TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983;
    GL_TRANSFORM_FEEDBACK = 36386;
    GL_TRANSFORM_FEEDBACK_PAUSED = 36387;
    GL_TRANSFORM_FEEDBACK_ACTIVE = 36388;
    GL_TRANSFORM_FEEDBACK_BINDING = 36389;
    GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296;
    GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297;
    GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298;
    GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299;
    GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300;
    GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301;
    GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302;
    GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303;
    GL_FRAMEBUFFER_DEFAULT = 33304;
    GL_DEPTH24_STENCIL8 = 35056;
    GL_DRAW_FRAMEBUFFER_BINDING = 36006;
    GL_READ_FRAMEBUFFER = 36008;
    GL_DRAW_FRAMEBUFFER = 36009;
    GL_READ_FRAMEBUFFER_BINDING = 36010;
    GL_RENDERBUFFER_SAMPLES = 36011;
    GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052;
    GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182;
    GL_UNIFORM_BUFFER = 35345;
    GL_UNIFORM_BUFFER_BINDING = 35368;
    GL_UNIFORM_BUFFER_START = 35369;
    GL_UNIFORM_BUFFER_SIZE = 35370;
    GL_MAX_VERTEX_UNIFORM_BLOCKS = 35371;
    GL_MAX_FRAGMENT_UNIFORM_BLOCKS = 35373;
    GL_MAX_COMBINED_UNIFORM_BLOCKS = 35374;
    GL_MAX_UNIFORM_BUFFER_BINDINGS = 35375;
    GL_MAX_UNIFORM_BLOCK_SIZE = 35376;
    GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377;
    GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379;
    GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380;
    GL_ACTIVE_UNIFORM_BLOCKS = 35382;
    GL_UNIFORM_TYPE = 35383;
    GL_UNIFORM_SIZE = 35384;
    GL_UNIFORM_BLOCK_INDEX = 35386;
    GL_UNIFORM_OFFSET = 35387;
    GL_UNIFORM_ARRAY_STRIDE = 35388;
    GL_UNIFORM_MATRIX_STRIDE = 35389;
    GL_UNIFORM_IS_ROW_MAJOR = 35390;
    GL_UNIFORM_BLOCK_BINDING = 35391;
    GL_UNIFORM_BLOCK_DATA_SIZE = 35392;
    GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394;
    GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395;
    GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396;
    GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398;
    GL_OBJECT_TYPE = 37138;
    GL_SYNC_CONDITION = 37139;
    GL_SYNC_STATUS = 37140;
    GL_SYNC_FLAGS = 37141;
    GL_SYNC_FENCE = 37142;
    GL_SYNC_GPU_COMMANDS_COMPLETE = 37143;
    GL_UNSIGNALED = 37144;
    GL_SIGNALED = 37145;
    GL_ALREADY_SIGNALED = 37146;
    GL_TIMEOUT_EXPIRED = 37147;
    GL_CONDITION_SATISFIED = 37148;
    GL_WAIT_FAILED = 37149;
    GL_SYNC_FLUSH_COMMANDS_BIT = 1;
    GL_COLOR = 6144;
    GL_DEPTH = 6145;
    GL_STENCIL = 6146;
    GL_MIN = 32775;
    GL_MAX = 32776;
    GL_DEPTH_COMPONENT24 = 33190;
    GL_STREAM_READ = 35041;
    GL_STREAM_COPY = 35042;
    GL_STATIC_READ = 35045;
    GL_STATIC_COPY = 35046;
    GL_DYNAMIC_READ = 35049;
    GL_DYNAMIC_COPY = 35050;
    GL_DEPTH_COMPONENT32F = 36012;
    GL_DEPTH32F_STENCIL8 = 36013;
    GL_INVALID_INDEX = 4294967295;
    GL_TIMEOUT_IGNORED = -1;
    GL_MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447;
    GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 35070;
    GL_UNMASKED_VENDOR_WEBGL = 37445;
    GL_UNMASKED_RENDERER_WEBGL = 37446;
    GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
    GL_TEXTURE_MAX_ANISOTROPY_EXT = 34046;
    GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 33776;
    GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777;
    GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778;
    GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779;
    GL_COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916;
    GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917;
    GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918;
    GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919;
    GL_COMPRESSED_R11_EAC = 37488;
    GL_COMPRESSED_SIGNED_R11_EAC = 37489;
    GL_COMPRESSED_RG11_EAC = 37490;
    GL_COMPRESSED_SIGNED_RG11_EAC = 37491;
    GL_COMPRESSED_RGB8_ETC2 = 37492;
    GL_COMPRESSED_RGBA8_ETC2_EAC = 37493;
    GL_COMPRESSED_SRGB8_ETC2 = 37494;
    GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495;
    GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496;
    GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497;
    GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840;
    GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842;
    GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841;
    GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843;
    GL_COMPRESSED_RGB_ETC1_WEBGL = 36196;
    GL_COMPRESSED_RGB_ATC_WEBGL = 35986;
    GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986;
    GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798;
    GL_COMPRESSED_RGBA_ASTC_4X4_KHR = 37808;
    GL_COMPRESSED_RGBA_ASTC_5X4_KHR = 37809;
    GL_COMPRESSED_RGBA_ASTC_5X5_KHR = 37810;
    GL_COMPRESSED_RGBA_ASTC_6X5_KHR = 37811;
    GL_COMPRESSED_RGBA_ASTC_6X6_KHR = 37812;
    GL_COMPRESSED_RGBA_ASTC_8X5_KHR = 37813;
    GL_COMPRESSED_RGBA_ASTC_8X6_KHR = 37814;
    GL_COMPRESSED_RGBA_ASTC_8X8_KHR = 37815;
    GL_COMPRESSED_RGBA_ASTC_10X5_KHR = 37816;
    GL_COMPRESSED_RGBA_ASTC_10X6_KHR = 37817;
    GL_COMPRESSED_RGBA_ASTC_10X8_KHR = 37818;
    GL_COMPRESSED_RGBA_ASTC_10X10_KHR = 37819;
    GL_COMPRESSED_RGBA_ASTC_12X10_KHR = 37820;
    GL_COMPRESSED_RGBA_ASTC_12X12_KHR = 37821;
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR = 37840;
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR = 37841;
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR = 37842;
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR = 37843;
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR = 37844;
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR = 37845;
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR = 37846;
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR = 37847;
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR = 37848;
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR = 37849;
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR = 37850;
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR = 37851;
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR = 37852;
    GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR = 37853;
    GL_UNSIGNED_INT_24_8_WEBGL = 34042;
    GL_HALF_FLOAT_OES = 36193;
    GL_RGBA32F_EXT = 34836;
    GL_RGB32F_EXT = 34837;
    GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 33297;
    GL_UNSIGNED_NORMALIZED_EXT = 35863;
    GL_MIN_EXT = 32775;
    GL_MAX_EXT = 32776;
    GL_SRGB_EXT = 35904;
    GL_SRGB_ALPHA_EXT = 35906;
    GL_SRGB8_ALPHA8_EXT = 35907;
    GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT = 33296;
    GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 35723;
    GL_COLOR_ATTACHMENT0_WEBGL = 36064;
    GL_COLOR_ATTACHMENT1_WEBGL = 36065;
    GL_COLOR_ATTACHMENT2_WEBGL = 36066;
    GL_COLOR_ATTACHMENT3_WEBGL = 36067;
    GL_COLOR_ATTACHMENT4_WEBGL = 36068;
    GL_COLOR_ATTACHMENT5_WEBGL = 36069;
    GL_COLOR_ATTACHMENT6_WEBGL = 36070;
    GL_COLOR_ATTACHMENT7_WEBGL = 36071;
    GL_COLOR_ATTACHMENT8_WEBGL = 36072;
    GL_COLOR_ATTACHMENT9_WEBGL = 36073;
    GL_COLOR_ATTACHMENT10_WEBGL = 36074;
    GL_COLOR_ATTACHMENT11_WEBGL = 36075;
    GL_COLOR_ATTACHMENT12_WEBGL = 36076;
    GL_COLOR_ATTACHMENT13_WEBGL = 36077;
    GL_COLOR_ATTACHMENT14_WEBGL = 36078;
    GL_COLOR_ATTACHMENT15_WEBGL = 36079;
    GL_DRAW_BUFFER0_WEBGL = 34853;
    GL_DRAW_BUFFER1_WEBGL = 34854;
    GL_DRAW_BUFFER2_WEBGL = 34855;
    GL_DRAW_BUFFER3_WEBGL = 34856;
    GL_DRAW_BUFFER4_WEBGL = 34857;
    GL_DRAW_BUFFER5_WEBGL = 34858;
    GL_DRAW_BUFFER6_WEBGL = 34859;
    GL_DRAW_BUFFER7_WEBGL = 34860;
    GL_DRAW_BUFFER8_WEBGL = 34861;
    GL_DRAW_BUFFER9_WEBGL = 34862;
    GL_DRAW_BUFFER10_WEBGL = 34863;
    GL_DRAW_BUFFER11_WEBGL = 34864;
    GL_DRAW_BUFFER12_WEBGL = 34865;
    GL_DRAW_BUFFER13_WEBGL = 34866;
    GL_DRAW_BUFFER14_WEBGL = 34867;
    GL_DRAW_BUFFER15_WEBGL = 34868;
    GL_MAX_COLOR_ATTACHMENTS_WEBGL = 36063;
    GL_MAX_DRAW_BUFFERS_WEBGL = 34852;
    GL_VERTEX_ARRAY_BINDING_OES = 34229;
    GL_QUERY_COUNTER_BITS_EXT = 34916;
    GL_CURRENT_QUERY_EXT = 34917;
    GL_QUERY_RESULT_EXT = 34918;
    GL_QUERY_RESULT_AVAILABLE_EXT = 34919;
    GL_TIME_ELAPSED_EXT = 35007;
    GL_TIMESTAMP_EXT = 36392;
    GL_GPU_DISJOINT_EXT = 36795;
  }
});

// src/types/glTF1.ts
var init_glTF1 = __esm({
  "src/types/glTF1.ts"() {
    "use strict";
  }
});

// src/types/glTF2.ts
function isSameGlTF2TextureSampler(lhs, rhs) {
  return lhs.magFilter === rhs.magFilter && lhs.minFilter === rhs.minFilter && lhs.wrapS === rhs.wrapS && lhs.wrapT === rhs.wrapT;
}
var TagGltf2NodeIndex;
var init_glTF2 = __esm({
  "src/types/glTF2.ts"() {
    "use strict";
    TagGltf2NodeIndex = "gltf_node_index";
    __name(isSameGlTF2TextureSampler, "isSameGlTF2TextureSampler");
  }
});

// src/types/glTF2ForOutput.ts
var init_glTF2ForOutput = __esm({
  "src/types/glTF2ForOutput.ts"() {
    "use strict";
  }
});

// src/types/RnM2.ts
var init_RnM2 = __esm({
  "src/types/RnM2.ts"() {
    "use strict";
  }
});

// src/types/RnM2Vrma.ts
var init_RnM2Vrma = __esm({
  "src/types/RnM2Vrma.ts"() {
    "use strict";
  }
});

// src/types/ShaderNodeJson.ts
var init_ShaderNodeJson = __esm({
  "src/types/ShaderNodeJson.ts"() {
    "use strict";
  }
});

// src/types/index.ts
var init_types = __esm({
  "src/types/index.ts"() {
    "use strict";
    init_AnimationTypes();
    init_BasisTexture();
    init_CommonTypes();
    init_KTX2Texture();
    init_TypeConverter();
    init_TypeGenerators();
    init_VRM0x();
    init_WebGLConstants();
    init_glTF1();
    init_glTF2();
    init_glTF2ForOutput();
    init_RnM2();
    init_RnM2Vrma();
    init_ShaderNodeJson();
  }
});

// src/foundation/definitions/PixelFormat.ts
function getCompositionNumFromPixelFormat(pixelFormat) {
  switch (pixelFormat) {
    case DepthComponent:
      return 1;
    case DepthStencil:
      return 2;
    case Alpha:
      return 1;
    case RG:
      return 2;
    case RGB:
      return 3;
    case RGBA:
      return 4;
    case Luminance:
      return 1;
    case LuminanceAlpha:
      return 2;
    default:
      throw new Error(`Not supported ${pixelFormat}`);
  }
}
function from16(index) {
  return _from({
    typeList: typeList16,
    index
  });
}
var _a18, PixelFormatClass, DepthComponent, DepthStencil, Alpha, RG, RGB, RGBA, Luminance, LuminanceAlpha, typeList16, PixelFormat;
var init_PixelFormat = __esm({
  "src/foundation/definitions/PixelFormat.ts"() {
    "use strict";
    init_types();
    init_EnumIO();
    PixelFormatClass = (_a18 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a18, "PixelFormatClass"), _a18);
    DepthComponent = new PixelFormatClass({
      index: 6402,
      str: "DEPTH_COMPONENT"
    });
    DepthStencil = new PixelFormatClass({
      index: 34041,
      str: "DEPTH_STENCIL"
    });
    Alpha = new PixelFormatClass({
      index: 6406,
      str: "ALPHA"
    });
    RG = new PixelFormatClass({
      index: GL_RG,
      str: "RG"
    });
    RGB = new PixelFormatClass({
      index: 6407,
      str: "RGB"
    });
    RGBA = new PixelFormatClass({
      index: 6408,
      str: "RGBA"
    });
    Luminance = new PixelFormatClass({
      index: 6409,
      str: "LUMINANCE"
    });
    LuminanceAlpha = new PixelFormatClass({
      index: 6410,
      str: "LUMINANCE_ALPHA"
    });
    __name(getCompositionNumFromPixelFormat, "getCompositionNumFromPixelFormat");
    typeList16 = [
      DepthComponent,
      DepthStencil,
      Alpha,
      RG,
      RGB,
      RGBA,
      Luminance,
      LuminanceAlpha
    ];
    __name(from16, "from");
    PixelFormat = Object.freeze({
      DepthComponent,
      DepthStencil,
      Alpha,
      RG,
      RGB,
      RGBA,
      Luminance,
      LuminanceAlpha,
      from: from16,
      getCompositionNumFromPixelFormat
    });
  }
});

// src/foundation/definitions/PrimitiveMode.ts
function from17(index) {
  return _from({
    typeList: typeList17,
    index
  });
}
var _a19, PrimitiveModeClass, Unknown5, Points, Lines, LineLoop, LineStrip, Triangles, TriangleStrip, TriangleFan, typeList17, PrimitiveMode;
var init_PrimitiveMode = __esm({
  "src/foundation/definitions/PrimitiveMode.ts"() {
    "use strict";
    init_EnumIO();
    PrimitiveModeClass = (_a19 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
      getWebGPUTypeStr() {
        switch (this.index) {
          case 0:
            return "point-list";
          case 1:
            return "line-list";
          case 2:
            throw new Error("Not Supported in WebGPU");
          case 3:
            return "line-strip";
          case 4:
            return "triangle-list";
          case 5:
            return "triangle-strip";
          case 6:
            throw new Error("Not Supported in WebGPU");
          default:
            throw new Error("Not Supported in WebGPU");
        }
      }
    }, __name(_a19, "PrimitiveModeClass"), _a19);
    Unknown5 = new PrimitiveModeClass({
      index: -1,
      str: "UNKNOWN"
    });
    Points = new PrimitiveModeClass({
      index: 0,
      str: "POINTS"
    });
    Lines = new PrimitiveModeClass({
      index: 1,
      str: "LINES"
    });
    LineLoop = new PrimitiveModeClass({
      index: 2,
      str: "LINE_LOOP"
    });
    LineStrip = new PrimitiveModeClass({
      index: 3,
      str: "LINE_STRIP"
    });
    Triangles = new PrimitiveModeClass({
      index: 4,
      str: "TRIANGLES"
    });
    TriangleStrip = new PrimitiveModeClass({
      index: 5,
      str: "TRIANGLE_STRIP"
    });
    TriangleFan = new PrimitiveModeClass({
      index: 6,
      str: "TRIANGLE_FAN"
    });
    typeList17 = [
      Unknown5,
      Points,
      Lines,
      LineLoop,
      LineStrip,
      Triangles,
      TriangleStrip,
      TriangleFan
    ];
    __name(from17, "from");
    PrimitiveMode = Object.freeze({
      Unknown: Unknown5,
      Points,
      Lines,
      LineLoop,
      LineStrip,
      Triangles,
      TriangleStrip,
      TriangleFan,
      from: from17
    });
  }
});

// src/foundation/definitions/ProcessApproach.ts
var _ProcessApproachClass, ProcessApproachClass, None2, Uniform, DataTexture, WebGPU, isDataTextureApproach, isUniformApproach, isWebGpuApproach, isWebGL2Approach, ProcessApproach;
var init_ProcessApproach = __esm({
  "src/foundation/definitions/ProcessApproach.ts"() {
    "use strict";
    init_EnumIO();
    _ProcessApproachClass = class _ProcessApproachClass extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
      get webGLVersion() {
        switch (this) {
          case Uniform:
          case DataTexture:
            return 2;
          default:
            return 0;
        }
      }
    };
    __name(_ProcessApproachClass, "ProcessApproachClass");
    ProcessApproachClass = _ProcessApproachClass;
    None2 = new ProcessApproachClass({
      index: 0,
      str: "NONE"
    });
    Uniform = new ProcessApproachClass({
      index: 1,
      str: "UNIFORM"
    });
    DataTexture = new ProcessApproachClass({
      index: 2,
      str: "DataTexture"
    });
    WebGPU = new ProcessApproachClass({
      index: 3,
      str: "WebGPU"
    });
    isDataTextureApproach = /* @__PURE__ */ __name((processApproach) => {
      switch (processApproach) {
        case DataTexture:
          return true;
        default:
          return false;
      }
    }, "isDataTextureApproach");
    isUniformApproach = /* @__PURE__ */ __name((processApproach) => {
      switch (processApproach) {
        case Uniform:
          return true;
        default:
          return false;
      }
    }, "isUniformApproach");
    isWebGpuApproach = /* @__PURE__ */ __name((processApproach) => {
      switch (processApproach) {
        case WebGPU:
          return true;
        default:
          return false;
      }
    }, "isWebGpuApproach");
    isWebGL2Approach = /* @__PURE__ */ __name((processApproach) => {
      switch (processApproach) {
        case Uniform:
        case DataTexture:
          return true;
        default:
          return false;
      }
    }, "isWebGL2Approach");
    ProcessApproach = Object.freeze({
      isDataTextureApproach,
      isUniformApproach,
      isWebGpuApproach,
      None: None2,
      Uniform,
      DataTexture,
      WebGPU,
      isWebGL2Approach
    });
  }
});

// src/foundation/definitions/RenderBufferTarget.ts
function from18(index) {
  return _from({
    typeList: typeList18,
    index
  });
}
var _a20, RenderBufferTargetClass, None3, Back, ColorAttachment0, ColorAttachment1, ColorAttachment2, ColorAttachment3, ColorAttachment4, ColorAttachment5, ColorAttachment6, ColorAttachment7, ColorAttachment8, ColorAttachment9, ColorAttachment10, ColorAttachment11, ColorAttachment12, ColorAttachment13, ColorAttachment14, ColorAttachment15, typeList18, RenderBufferTarget;
var init_RenderBufferTarget = __esm({
  "src/foundation/definitions/RenderBufferTarget.ts"() {
    "use strict";
    init_EnumIO();
    RenderBufferTargetClass = (_a20 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
      webGLConstantValue() {
        if (this.index === -2) {
          return 0;
        } else if (this.index === -1) {
          return 1029;
        }
        return 36064 + this.index;
      }
    }, __name(_a20, "RenderBufferTargetClass"), _a20);
    None3 = new RenderBufferTargetClass({
      index: -2,
      str: "NONE"
    });
    Back = new RenderBufferTargetClass({
      index: -1,
      str: "BACK"
    });
    ColorAttachment0 = new RenderBufferTargetClass({
      index: 0,
      str: "COLOR_ATTACHMENT0"
    });
    ColorAttachment1 = new RenderBufferTargetClass({
      index: 1,
      str: "COLOR_ATTACHMENT1"
    });
    ColorAttachment2 = new RenderBufferTargetClass({
      index: 2,
      str: "COLOR_ATTACHMENT2"
    });
    ColorAttachment3 = new RenderBufferTargetClass({
      index: 3,
      str: "COLOR_ATTACHMENT3"
    });
    ColorAttachment4 = new RenderBufferTargetClass({
      index: 4,
      str: "COLOR_ATTACHMENT4"
    });
    ColorAttachment5 = new RenderBufferTargetClass({
      index: 5,
      str: "COLOR_ATTACHMENT5"
    });
    ColorAttachment6 = new RenderBufferTargetClass({
      index: 6,
      str: "COLOR_ATTACHMENT6"
    });
    ColorAttachment7 = new RenderBufferTargetClass({
      index: 7,
      str: "COLOR_ATTACHMENT7"
    });
    ColorAttachment8 = new RenderBufferTargetClass({
      index: 8,
      str: "COLOR_ATTACHMENT8"
    });
    ColorAttachment9 = new RenderBufferTargetClass({
      index: 9,
      str: "COLOR_ATTACHMENT9"
    });
    ColorAttachment10 = new RenderBufferTargetClass({
      index: 10,
      str: "COLOR_ATTACHMENT10"
    });
    ColorAttachment11 = new RenderBufferTargetClass({
      index: 11,
      str: "COLOR_ATTACHMENT11"
    });
    ColorAttachment12 = new RenderBufferTargetClass({
      index: 12,
      str: "COLOR_ATTACHMENT12"
    });
    ColorAttachment13 = new RenderBufferTargetClass({
      index: 13,
      str: "COLOR_ATTACHMENT13"
    });
    ColorAttachment14 = new RenderBufferTargetClass({
      index: 14,
      str: "COLOR_ATTACHMENT14"
    });
    ColorAttachment15 = new RenderBufferTargetClass({
      index: 15,
      str: "COLOR_ATTACHMENT15"
    });
    typeList18 = [
      None3,
      Back,
      ColorAttachment0,
      ColorAttachment1,
      ColorAttachment2,
      ColorAttachment3,
      ColorAttachment4,
      ColorAttachment5,
      ColorAttachment6,
      ColorAttachment7,
      ColorAttachment8,
      ColorAttachment9,
      ColorAttachment10,
      ColorAttachment11,
      ColorAttachment12,
      ColorAttachment13,
      ColorAttachment14,
      ColorAttachment15
    ];
    __name(from18, "from");
    RenderBufferTarget = Object.freeze({
      None: None3,
      Back,
      ColorAttachment0,
      ColorAttachment1,
      ColorAttachment2,
      ColorAttachment3,
      ColorAttachment4,
      ColorAttachment5,
      ColorAttachment6,
      ColorAttachment7,
      ColorAttachment8,
      ColorAttachment9,
      ColorAttachment10,
      ColorAttachment11,
      ColorAttachment12,
      ColorAttachment13,
      ColorAttachment14,
      ColorAttachment15,
      from: from18
    });
  }
});

// src/foundation/definitions/ShaderNode.ts
function from19(index) {
  return _from({
    typeList: typeList19,
    index
  });
}
function fromString15(str) {
  return _fromString({
    typeList: typeList19,
    str
  });
}
var _a21, ShaderNodeClass, ClassicShading, PBRShading, Lerp, Add, typeList19, ShaderNode;
var init_ShaderNode = __esm({
  "src/foundation/definitions/ShaderNode.ts"() {
    "use strict";
    init_EnumIO();
    ShaderNodeClass = (_a21 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a21, "ShaderNodeClass"), _a21);
    ClassicShading = new ShaderNodeClass({
      index: 0,
      str: "ClassicShading"
    });
    PBRShading = new ShaderNodeClass({
      index: 1,
      str: "PBRShading"
    });
    Lerp = new ShaderNodeClass({
      index: 2,
      str: "Lerp"
    });
    Add = new ShaderNodeClass({
      index: 3,
      str: "Add"
    });
    typeList19 = [
      ClassicShading,
      PBRShading
    ];
    __name(from19, "from");
    __name(fromString15, "fromString");
    ShaderNode = Object.freeze({
      ClassicShading,
      PBRShading,
      from: from19,
      fromString: fromString15
    });
  }
});

// src/foundation/definitions/ShaderSemantics.ts
function from20(index) {
  return _from({
    typeList: typeList20,
    index
  });
}
function fromString16(str) {
  return _fromString({
    typeList: typeList20,
    str
  });
}
function fromStringCaseSensitively(str) {
  return _fromStringCaseSensitively({
    typeList: typeList20,
    str
  });
}
function _getPropertyIndex2(shaderSemantic) {
  const propertyIndex = shaderSemantic.index;
  return propertyIndex;
}
var _ShaderSemanticsClass, ShaderSemanticsClass, WorldMatrix, ViewMatrix, IsBillboard, EnableViewMatrix, ProjectionMatrix, NormalMatrix, BoneMatrix, BaseColorFactor, BaseColorTexture, NormalTexture, MetallicRoughnessTexture, OcclusionTexture, EmissiveFactor, EmissiveTexture, LightNumber, LightPosition, LightDirection, LightIntensity, LightProperty, MetallicRoughnessFactor, BrdfLutTexture, DiffuseEnvTexture, SpecularEnvTexture, InverseEnvironment, IBLParameter, ViewPosition, Wireframe, DiffuseColorFactor, DiffuseColorTexture, Shininess, ShadingModel, SkinningMode, GeneralTexture, VertexAttributesExistenceArray, BoneQuaternion, BoneTranslateScale, BoneTranslatePackedQuat, BoneScalePackedQuat, BoneCompressedChunk, BoneCompressedInfo, PointSize, ColorEnvTexture, PointDistanceAttenuation, HDRIFormat, ScreenInfo, DepthTexture, LightViewProjectionMatrix, Anisotropy, ClearCoatParameter, SheenColorFactor, SheenColorTexture, SheenRoughnessFactor, SheenRoughnessTexture, SheenLutTexture, SpecularGlossinessFactor, SpecularGlossinessTexture, EntityUID, MorphTargetNumber, DataTextureMorphOffsetPosition, MorphWeights, CurrentComponentSIDs, AlphaCutoff, AlphaTexture, MakeOutputSrgb, FramebufferSize, ClearCoatFactor, ClearCoatTexture, ClearCoatRoughnessFactor, ClearCoatRoughnessTexture, ClearCoatNormalTexture, TransmissionFactor, TransmissionTexture, BackBufferTexture, BackBufferTextureSize, ThicknessFactor, ThicknessTexture, AttenuationDistance, AttenuationColor, IsOutputHDR, BaseColorTextureTransform, BaseColorTextureRotation, NormalTextureTransform, NormalTextureRotation, MetallicRoughnessTextureTransform, MetallicRoughnessTextureRotation, NormalTexcoordIndex, BaseColorTexcoordIndex, MetallicRoughnessTexcoordIndex, OcclusionTexcoordIndex, OcclusionTextureTransform, OcclusionTextureRotation, EmissiveTexcoordIndex, EmissiveTextureTransform, EmissiveTextureRotation, NormalScale, OcclusionStrength, envRotation, EnvHdriFormat, VrState, EnableLinearToSrgb, SpecularFactor, SpecularTexture, SpecularColorFactor, SpecularColorTexture, Ior, DepthBiasPV, ClearCoatTextureTransform, ClearCoatTextureRotation, ClearCoatRoughnessTextureTransform, ClearCoatRoughnessTextureRotation, ClearCoatNormalTextureTransform, ClearCoatNormalTextureRotation, ClearCoatTexcoordIndex, ClearCoatRoughnessTexcoordIndex, ClearCoatNormalTexcoordIndex, IridescenceFactor, IridescenceTexture, IridescenceIor, IridescenceThicknessMinimum, IridescenceThicknessMaximum, IridescenceThicknessTexture, GaussianKernelSize, GaussianRatio, IsHorizontal, AnisotropyStrength, AnisotropyRotation, AnisotropyTexture, EmissiveStrength, Time2, CubeMapFaceId, Roughness, DistributionType, typeList20, getShaderProperty, ShaderSemantics;
var init_ShaderSemantics = __esm({
  "src/foundation/definitions/ShaderSemantics.ts"() {
    "use strict";
    init_EnumIO();
    init_CompositionType();
    _ShaderSemanticsClass = class _ShaderSemanticsClass extends EnumClass {
      constructor({ str }) {
        super({
          index: ++_ShaderSemanticsClass.__indexCount * _ShaderSemanticsClass._scale,
          str,
          noCheckStrUnique: true
        });
        _ShaderSemanticsClass.__classes[this.index] = this;
      }
      static getShaderSemanticByIndex(index) {
        return this.__classes[Math.abs(index) - Math.abs(index) % this._scale];
      }
      static isNonArrayShaderSemanticIndex(index) {
        if (index >= this._scale) {
          return true;
        } else {
          return false;
        }
      }
      static isArrayAndZeroIndexShaderSemanticIndex(index) {
        if (index < 0 && Math.abs(index) % _ShaderSemanticsClass._scale === 0) {
          return true;
        } else {
          return false;
        }
      }
      static isArrayAndNonZeroIndexShaderSemanticIndex(index) {
        if (index < 0 && Math.abs(index) % _ShaderSemanticsClass._scale !== 0) {
          return true;
        } else {
          return false;
        }
      }
      static getIndexCount() {
        return _ShaderSemanticsClass.__indexCount;
      }
    };
    __name(_ShaderSemanticsClass, "ShaderSemanticsClass");
    __publicField(_ShaderSemanticsClass, "__indexCount", -1);
    __publicField(_ShaderSemanticsClass, "_scale", 1e4);
    __publicField(_ShaderSemanticsClass, "__classes", []);
    ShaderSemanticsClass = _ShaderSemanticsClass;
    WorldMatrix = new ShaderSemanticsClass({
      str: "worldMatrix"
    });
    ViewMatrix = new ShaderSemanticsClass({
      str: "viewMatrix"
    });
    IsBillboard = new ShaderSemanticsClass({
      str: "isBillboard"
    });
    EnableViewMatrix = new ShaderSemanticsClass({
      str: "enableViewMatrix"
    });
    ProjectionMatrix = new ShaderSemanticsClass({
      str: "projectionMatrix"
    });
    NormalMatrix = new ShaderSemanticsClass({
      str: "normalMatrix"
    });
    BoneMatrix = new ShaderSemanticsClass({
      str: "boneMatrix"
    });
    BaseColorFactor = new ShaderSemanticsClass({
      str: "baseColorFactor"
    });
    BaseColorTexture = new ShaderSemanticsClass({
      str: "baseColorTexture"
    });
    NormalTexture = new ShaderSemanticsClass({
      str: "normalTexture"
    });
    MetallicRoughnessTexture = new ShaderSemanticsClass({
      str: "metallicRoughnessTexture"
    });
    OcclusionTexture = new ShaderSemanticsClass({
      str: "occlusionTexture"
    });
    EmissiveFactor = new ShaderSemanticsClass({
      str: "emissiveFactor"
    });
    EmissiveTexture = new ShaderSemanticsClass({
      str: "emissiveTexture"
    });
    LightNumber = new ShaderSemanticsClass({
      str: "lightNumber"
    });
    LightPosition = new ShaderSemanticsClass({
      str: "lightPosition"
    });
    LightDirection = new ShaderSemanticsClass({
      str: "lightDirection"
    });
    LightIntensity = new ShaderSemanticsClass({
      str: "lightIntensity"
    });
    LightProperty = new ShaderSemanticsClass({
      str: "lightProperty"
    });
    MetallicRoughnessFactor = new ShaderSemanticsClass({
      str: "metallicRoughnessFactor"
    });
    BrdfLutTexture = new ShaderSemanticsClass({
      str: "brdfLutTexture"
    });
    DiffuseEnvTexture = new ShaderSemanticsClass({
      str: "diffuseEnvTexture"
    });
    SpecularEnvTexture = new ShaderSemanticsClass({
      str: "specularEnvTexture"
    });
    InverseEnvironment = new ShaderSemanticsClass({
      str: "inverseEnvironment"
    });
    IBLParameter = new ShaderSemanticsClass({
      str: "iblParameter"
    });
    ViewPosition = new ShaderSemanticsClass({
      str: "viewPosition"
    });
    Wireframe = new ShaderSemanticsClass({
      str: "wireframe"
    });
    DiffuseColorFactor = new ShaderSemanticsClass({
      str: "diffuseColorFactor"
    });
    DiffuseColorTexture = new ShaderSemanticsClass({
      str: "diffuseColorTexture"
    });
    Shininess = new ShaderSemanticsClass({
      str: "shininess"
    });
    ShadingModel = new ShaderSemanticsClass({
      str: "shadingModel"
    });
    SkinningMode = new ShaderSemanticsClass({
      str: "skinningMode"
    });
    GeneralTexture = new ShaderSemanticsClass({
      str: "generalTexture"
    });
    VertexAttributesExistenceArray = new ShaderSemanticsClass({
      str: "vertexAttributesExistenceArray"
    });
    BoneQuaternion = new ShaderSemanticsClass({
      str: "boneQuaternion"
    });
    BoneTranslateScale = new ShaderSemanticsClass({
      str: "boneTranslateScale"
    });
    BoneTranslatePackedQuat = new ShaderSemanticsClass({
      str: "boneTranslatePackedQuat"
    });
    BoneScalePackedQuat = new ShaderSemanticsClass({
      str: "boneScalePackedQuat"
    });
    BoneCompressedChunk = new ShaderSemanticsClass({
      str: "boneCompressedChunk"
    });
    BoneCompressedInfo = new ShaderSemanticsClass({
      str: "boneCompressedInfo"
    });
    PointSize = new ShaderSemanticsClass({
      str: "pointSize"
    });
    ColorEnvTexture = new ShaderSemanticsClass({
      str: "colorEnvTexture"
    });
    PointDistanceAttenuation = new ShaderSemanticsClass({
      str: "pointDistanceAttenuation"
    });
    HDRIFormat = new ShaderSemanticsClass({
      str: "hdriFormat"
    });
    ScreenInfo = new ShaderSemanticsClass({
      str: "screenInfo"
    });
    DepthTexture = new ShaderSemanticsClass({
      str: "depthTexture"
    });
    LightViewProjectionMatrix = new ShaderSemanticsClass({
      str: "lightViewProjectionMatrix"
    });
    Anisotropy = new ShaderSemanticsClass({
      str: "anisotropy"
    });
    ClearCoatParameter = new ShaderSemanticsClass({
      str: "clearcoatParameter"
    });
    SheenColorFactor = new ShaderSemanticsClass({
      str: "sheenColorFactor"
    });
    SheenColorTexture = new ShaderSemanticsClass({
      str: "sheenColorTexture"
    });
    SheenRoughnessFactor = new ShaderSemanticsClass({
      str: "sheenRoughnessFactor"
    });
    SheenRoughnessTexture = new ShaderSemanticsClass({
      str: "sheenRoughnessTexture"
    });
    SheenLutTexture = new ShaderSemanticsClass({
      str: "sheenLutTexture"
    });
    SpecularGlossinessFactor = new ShaderSemanticsClass({
      str: "specularGlossinessFactor"
    });
    SpecularGlossinessTexture = new ShaderSemanticsClass({
      str: "specularGlossinessTexture"
    });
    EntityUID = new ShaderSemanticsClass({
      str: "entityUID"
    });
    MorphTargetNumber = new ShaderSemanticsClass({
      str: "morphTargetNumber"
    });
    DataTextureMorphOffsetPosition = new ShaderSemanticsClass({
      str: "dataTextureMorphOffsetPosition"
    });
    MorphWeights = new ShaderSemanticsClass({
      str: "morphWeights"
    });
    CurrentComponentSIDs = new ShaderSemanticsClass({
      str: "currentComponentSIDs"
    });
    AlphaCutoff = new ShaderSemanticsClass({
      str: "alphaCutoff"
    });
    AlphaTexture = new ShaderSemanticsClass({
      str: "alphaTexture"
    });
    MakeOutputSrgb = new ShaderSemanticsClass({
      str: "makeOutputSrgb"
    });
    FramebufferSize = new ShaderSemanticsClass({
      str: "framebufferSize"
    });
    ClearCoatFactor = new ShaderSemanticsClass({
      str: "clearCoatFactor"
    });
    ClearCoatTexture = new ShaderSemanticsClass({
      str: "clearCoatTexture"
    });
    ClearCoatRoughnessFactor = new ShaderSemanticsClass({
      str: "clearCoatRoughnessFactor"
    });
    ClearCoatRoughnessTexture = new ShaderSemanticsClass({
      str: "clearCoatRoughnessTexture"
    });
    ClearCoatNormalTexture = new ShaderSemanticsClass({
      str: "clearCoatNormalTexture"
    });
    TransmissionFactor = new ShaderSemanticsClass({
      str: "transmissionFactor"
    });
    TransmissionTexture = new ShaderSemanticsClass({
      str: "transmissionTexture"
    });
    BackBufferTexture = new ShaderSemanticsClass({
      str: "backBufferTexture"
    });
    BackBufferTextureSize = new ShaderSemanticsClass({
      str: "backBufferTextureSize"
    });
    ThicknessFactor = new ShaderSemanticsClass({
      str: "thicknessFactor"
    });
    ThicknessTexture = new ShaderSemanticsClass({
      str: "thicknessTexture"
    });
    AttenuationDistance = new ShaderSemanticsClass({
      str: "attenuationDistance"
    });
    AttenuationColor = new ShaderSemanticsClass({
      str: "attenuationColor"
    });
    IsOutputHDR = new ShaderSemanticsClass({
      str: "isOutputHDR"
    });
    BaseColorTextureTransform = new ShaderSemanticsClass({
      str: "baseColorTextureTransform"
    });
    BaseColorTextureRotation = new ShaderSemanticsClass({
      str: "baseColorTextureRotation"
    });
    NormalTextureTransform = new ShaderSemanticsClass({
      str: "normalTextureTransform"
    });
    NormalTextureRotation = new ShaderSemanticsClass({
      str: "normalTextureRotation"
    });
    MetallicRoughnessTextureTransform = new ShaderSemanticsClass({
      str: "metallicRoughnessTextureTransform"
    });
    MetallicRoughnessTextureRotation = new ShaderSemanticsClass({
      str: "metallicRoughnessTextureRotation"
    });
    NormalTexcoordIndex = new ShaderSemanticsClass({
      str: "normalTexcoordIndex"
    });
    BaseColorTexcoordIndex = new ShaderSemanticsClass({
      str: "baseColorTexcoordIndex"
    });
    MetallicRoughnessTexcoordIndex = new ShaderSemanticsClass({
      str: "metallicRoughnessTexcoordIndex"
    });
    OcclusionTexcoordIndex = new ShaderSemanticsClass({
      str: "occlusionTexcoordIndex"
    });
    OcclusionTextureTransform = new ShaderSemanticsClass({
      str: "occlusionTextureTransform"
    });
    OcclusionTextureRotation = new ShaderSemanticsClass({
      str: "occlusionTextureRotation"
    });
    EmissiveTexcoordIndex = new ShaderSemanticsClass({
      str: "emissiveTexcoordIndex"
    });
    EmissiveTextureTransform = new ShaderSemanticsClass({
      str: "emissiveTextureTransform"
    });
    EmissiveTextureRotation = new ShaderSemanticsClass({
      str: "emissiveTextureRotation"
    });
    NormalScale = new ShaderSemanticsClass({
      str: "normalScale"
    });
    OcclusionStrength = new ShaderSemanticsClass({
      str: "occlusionStrength"
    });
    envRotation = new ShaderSemanticsClass({
      str: "envRotation"
    });
    EnvHdriFormat = new ShaderSemanticsClass({
      str: "envHdriFormat"
    });
    VrState = new ShaderSemanticsClass({
      str: "vrState"
    });
    EnableLinearToSrgb = new ShaderSemanticsClass({
      str: "enableLinearToSrgb"
    });
    SpecularFactor = new ShaderSemanticsClass({
      str: "specularFactor"
    });
    SpecularTexture = new ShaderSemanticsClass({
      str: "specularTexture"
    });
    SpecularColorFactor = new ShaderSemanticsClass({
      str: "specularColorFactor"
    });
    SpecularColorTexture = new ShaderSemanticsClass({
      str: "specularColorTexture"
    });
    Ior = new ShaderSemanticsClass({
      str: "ior"
    });
    DepthBiasPV = new ShaderSemanticsClass({
      str: "depthBiasPV"
    });
    ClearCoatTextureTransform = new ShaderSemanticsClass({
      str: "clearCoatTextureTransform"
    });
    ClearCoatTextureRotation = new ShaderSemanticsClass({
      str: "clearCoatTextureRotation"
    });
    ClearCoatRoughnessTextureTransform = new ShaderSemanticsClass({
      str: "clearCoatRoughnessTextureTransform"
    });
    ClearCoatRoughnessTextureRotation = new ShaderSemanticsClass({
      str: "clearCoatRoughnessTextureRotation"
    });
    ClearCoatNormalTextureTransform = new ShaderSemanticsClass({
      str: "clearCoatNormalTextureTransform"
    });
    ClearCoatNormalTextureRotation = new ShaderSemanticsClass({
      str: "clearCoatNormalTextureRotation"
    });
    ClearCoatTexcoordIndex = new ShaderSemanticsClass({
      str: "clearCoatTexcoordIndex"
    });
    ClearCoatRoughnessTexcoordIndex = new ShaderSemanticsClass({
      str: "clearCoatRoughnessTexcoordIndex"
    });
    ClearCoatNormalTexcoordIndex = new ShaderSemanticsClass({
      str: "clearCoatNormalTexcoordIndex"
    });
    IridescenceFactor = new ShaderSemanticsClass({
      str: "iridescenceFactor"
    });
    IridescenceTexture = new ShaderSemanticsClass({
      str: "iridescenceTexture"
    });
    IridescenceIor = new ShaderSemanticsClass({
      str: "iridescenceIor"
    });
    IridescenceThicknessMinimum = new ShaderSemanticsClass({
      str: "iridescenceThicknessMinimum"
    });
    IridescenceThicknessMaximum = new ShaderSemanticsClass({
      str: "iridescenceThicknessMaximum"
    });
    IridescenceThicknessTexture = new ShaderSemanticsClass({
      str: "iridescenceThicknessTexture"
    });
    GaussianKernelSize = new ShaderSemanticsClass({
      str: "gaussianKernelSize"
    });
    GaussianRatio = new ShaderSemanticsClass({
      str: "gaussianRatio"
    });
    IsHorizontal = new ShaderSemanticsClass({
      str: "isHorizontal"
    });
    AnisotropyStrength = new ShaderSemanticsClass({
      str: "anisotropyStrength"
    });
    AnisotropyRotation = new ShaderSemanticsClass({
      str: "anisotropyRotation"
    });
    AnisotropyTexture = new ShaderSemanticsClass({
      str: "anisotropyTexture"
    });
    EmissiveStrength = new ShaderSemanticsClass({
      str: "emissiveStrength"
    });
    Time2 = new ShaderSemanticsClass({
      str: "time"
    });
    CubeMapFaceId = new ShaderSemanticsClass({
      str: "cubeMapFaceId"
    });
    Roughness = new ShaderSemanticsClass({
      str: "roughness"
    });
    DistributionType = new ShaderSemanticsClass({
      str: "distributionType"
    });
    typeList20 = [
      WorldMatrix,
      ViewMatrix,
      IsBillboard,
      EnableViewMatrix,
      ProjectionMatrix,
      NormalMatrix,
      BoneMatrix,
      BaseColorFactor,
      BaseColorTexture,
      NormalTexture,
      MetallicRoughnessTexture,
      OcclusionTexture,
      EmissiveFactor,
      EmissiveTexture,
      LightNumber,
      LightPosition,
      LightDirection,
      LightIntensity,
      LightProperty,
      MetallicRoughnessFactor,
      BrdfLutTexture,
      DiffuseEnvTexture,
      SpecularEnvTexture,
      InverseEnvironment,
      IBLParameter,
      ViewPosition,
      Wireframe,
      DiffuseColorFactor,
      DiffuseColorTexture,
      Shininess,
      ShadingModel,
      SkinningMode,
      GeneralTexture,
      VertexAttributesExistenceArray,
      BoneQuaternion,
      BoneTranslateScale,
      BoneTranslatePackedQuat,
      BoneScalePackedQuat,
      BoneCompressedChunk,
      BoneCompressedInfo,
      PointSize,
      ColorEnvTexture,
      PointDistanceAttenuation,
      HDRIFormat,
      ScreenInfo,
      DepthTexture,
      LightViewProjectionMatrix,
      Anisotropy,
      ClearCoatParameter,
      SheenColorFactor,
      SheenColorTexture,
      SheenRoughnessFactor,
      SheenRoughnessTexture,
      SheenLutTexture,
      SpecularGlossinessFactor,
      SpecularGlossinessTexture,
      EntityUID,
      MorphTargetNumber,
      DataTextureMorphOffsetPosition,
      MorphWeights,
      CurrentComponentSIDs,
      AlphaCutoff,
      AlphaTexture,
      MakeOutputSrgb,
      ClearCoatFactor,
      ClearCoatTexture,
      ClearCoatRoughnessFactor,
      ClearCoatRoughnessTexture,
      ClearCoatNormalTexture,
      TransmissionFactor,
      TransmissionTexture,
      BackBufferTexture,
      BackBufferTextureSize,
      ThicknessFactor,
      ThicknessTexture,
      AttenuationDistance,
      AttenuationColor,
      IsOutputHDR,
      BaseColorTextureTransform,
      BaseColorTextureRotation,
      NormalTextureTransform,
      NormalTextureRotation,
      MetallicRoughnessTextureTransform,
      MetallicRoughnessTextureRotation,
      NormalTexcoordIndex,
      BaseColorTexcoordIndex,
      MetallicRoughnessTexcoordIndex,
      OcclusionTexcoordIndex,
      OcclusionTextureTransform,
      OcclusionTextureRotation,
      EmissiveTexcoordIndex,
      EmissiveTextureTransform,
      EmissiveTextureRotation,
      NormalScale,
      OcclusionStrength,
      envRotation,
      EnvHdriFormat,
      VrState,
      EnableLinearToSrgb,
      SpecularFactor,
      SpecularTexture,
      SpecularColorFactor,
      SpecularColorTexture,
      Ior,
      DepthBiasPV,
      ClearCoatTextureTransform,
      ClearCoatTextureRotation,
      ClearCoatRoughnessTextureTransform,
      ClearCoatRoughnessTextureRotation,
      ClearCoatNormalTextureTransform,
      ClearCoatNormalTextureRotation,
      ClearCoatTexcoordIndex,
      ClearCoatRoughnessTexcoordIndex,
      ClearCoatNormalTexcoordIndex,
      IridescenceFactor,
      IridescenceTexture,
      IridescenceIor,
      IridescenceThicknessMinimum,
      IridescenceThicknessMaximum,
      IridescenceThicknessTexture,
      GaussianKernelSize,
      GaussianRatio,
      IsHorizontal,
      AnisotropyStrength,
      AnisotropyRotation,
      AnisotropyTexture,
      EmissiveStrength,
      Time2,
      CubeMapFaceId,
      Roughness,
      DistributionType
    ];
    __name(from20, "from");
    __name(fromString16, "fromString");
    __name(fromStringCaseSensitively, "fromStringCaseSensitively");
    getShaderProperty = /* @__PURE__ */ __name((materialTypeName, info, isGlobalData, isWebGL2) => {
      const returnType = info.compositionType.getGlslStr(info.componentType);
      let variableName = info.semantic;
      const varType = info.compositionType.getGlslStr(info.componentType);
      let varIndexStr = "";
      if (info.arrayLength) {
        varIndexStr = `[${info.arrayLength}]`;
      }
      const varDef = `  uniform ${varType} u_${variableName}${varIndexStr};
`;
      let str = "";
      if (CompositionType.isArray(info.compositionType)) {
        if (variableName.match(/\[.+?\]/)) {
          variableName = variableName.replace(/\[.+?\]/g, "[i]");
        } else {
          variableName += "[i]";
        }
        str += `
        ${returnType} val;
          int i = index;
          return u_${variableName};
        `;
      } else {
        str += `return u_${variableName};`;
      }
      let funcDef = "";
      const isTexture2 = CompositionType.isTexture(info.compositionType);
      if (!isTexture2) {
        funcDef = `
  ${returnType} get_${info.semantic}(float instanceId, int index) {
    ${str}
  }
`;
      }
      return `${varDef}${funcDef}`;
    }, "getShaderProperty");
    __name(_getPropertyIndex2, "_getPropertyIndex2");
    ShaderSemantics = Object.freeze({
      from: from20,
      fromString: fromString16,
      fromStringCaseSensitively,
      WorldMatrix,
      ViewMatrix,
      IsBillboard,
      EnableViewMatrix,
      ProjectionMatrix,
      NormalMatrix,
      BoneMatrix,
      BaseColorFactor,
      BaseColorTexture,
      NormalTexture,
      MetallicRoughnessTexture,
      OcclusionTexture,
      EmissiveFactor,
      EmissiveTexture,
      LightNumber,
      LightPosition,
      LightDirection,
      LightIntensity,
      LightProperty,
      MetallicRoughnessFactor,
      BrdfLutTexture,
      DiffuseEnvTexture,
      SpecularEnvTexture,
      InverseEnvironment,
      IBLParameter,
      ViewPosition,
      Wireframe,
      DiffuseColorFactor,
      DiffuseColorTexture,
      Shininess,
      ShadingModel,
      SkinningMode,
      GeneralTexture,
      VertexAttributesExistenceArray,
      BoneQuaternion,
      BoneTranslateScale,
      BoneTranslatePackedQuat,
      BoneScalePackedQuat,
      BoneCompressedChunk,
      BoneCompressedInfo,
      PointSize,
      ColorEnvTexture,
      PointDistanceAttenuation,
      HDRIFormat,
      ScreenInfo,
      DepthTexture,
      LightViewProjectionMatrix,
      Anisotropy,
      ClearCoatParameter,
      SheenColorFactor,
      SheenColorTexture,
      SheenRoughnessFactor,
      SheenRoughnessTexture,
      SheenLutTexture,
      SpecularGlossinessFactor,
      SpecularGlossinessTexture,
      ClearCoatFactor,
      ClearCoatTexture,
      ClearCoatRoughnessFactor,
      ClearCoatRoughnessTexture,
      ClearCoatNormalTexture,
      TransmissionFactor,
      TransmissionTexture,
      BackBufferTexture,
      BackBufferTextureSize,
      ThicknessFactor,
      ThicknessTexture,
      AttenuationDistance,
      AttenuationColor,
      getShaderProperty,
      EntityUID,
      MorphTargetNumber,
      DataTextureMorphOffsetPosition,
      MorphWeights,
      CurrentComponentSIDs,
      AlphaCutoff,
      AlphaTexture,
      MakeOutputSrgb,
      FramebufferSize,
      IsOutputHDR,
      BaseColorTextureTransform,
      BaseColorTextureRotation,
      NormalTextureTransform,
      NormalTextureRotation,
      MetallicRoughnessTextureTransform,
      MetallicRoughnessTextureRotation,
      NormalTexcoordIndex,
      BaseColorTexcoordIndex,
      MetallicRoughnessTexcoordIndex,
      OcclusionTexcoordIndex,
      OcclusionTextureTransform,
      OcclusionTextureRotation,
      EmissiveTexcoordIndex,
      EmissiveTextureTransform,
      EmissiveTextureRotation,
      NormalScale,
      OcclusionStrength,
      envRotation,
      EnvHdriFormat,
      VrState,
      EnableLinearToSrgb,
      SpecularFactor,
      SpecularTexture,
      SpecularColorFactor,
      SpecularColorTexture,
      Ior,
      DepthBiasPV,
      ClearCoatTextureTransform,
      ClearCoatTextureRotation,
      ClearCoatRoughnessTextureTransform,
      ClearCoatRoughnessTextureRotation,
      ClearCoatNormalTextureTransform,
      ClearCoatNormalTextureRotation,
      ClearCoatTexcoordIndex,
      ClearCoatRoughnessTexcoordIndex,
      ClearCoatNormalTexcoordIndex,
      IridescenceFactor,
      IridescenceTexture,
      IridescenceIor,
      IridescenceThicknessMinimum,
      IridescenceThicknessMaximum,
      IridescenceThicknessTexture,
      GaussianKernelSize,
      GaussianRatio,
      IsHorizontal,
      AnisotropyStrength,
      AnisotropyRotation,
      AnisotropyTexture,
      EmissiveStrength,
      Time: Time2,
      CubeMapFaceId,
      Roughness,
      DistributionType
    });
  }
});

// src/foundation/definitions/ShaderSemanticsInfo.ts
function calcAlignedByteLength(semanticInfo) {
  const compositionNumber = semanticInfo.compositionType.getNumberOfComponents();
  const componentSizeInByte = semanticInfo.componentType.getSizeInBytes();
  const semanticInfoByte = compositionNumber * componentSizeInByte;
  let alignedByteLength = semanticInfoByte;
  if (alignedByteLength % 16 !== 0) {
    alignedByteLength = semanticInfoByte + 16 - semanticInfoByte % 16;
  }
  if (CompositionType.isArray(semanticInfo.compositionType)) {
    const maxArrayLength = semanticInfo.arrayLength;
    if (maxArrayLength != null) {
      alignedByteLength *= maxArrayLength;
    } else {
      Logger.error("semanticInfo has invalid maxIndex!");
      alignedByteLength *= 100;
    }
  }
  return alignedByteLength;
}
var init_ShaderSemanticsInfo = __esm({
  "src/foundation/definitions/ShaderSemanticsInfo.ts"() {
    "use strict";
    init_Logger();
    init_CompositionType();
    __name(calcAlignedByteLength, "calcAlignedByteLength");
  }
});

// src/foundation/definitions/ShaderType.ts
function from21(index) {
  return _from({
    typeList: typeList21,
    index
  });
}
function fromString17(str) {
  return _fromString({
    typeList: typeList21,
    str
  });
}
var _a22, ShaderTypeClass, VertexShader, PixelShader, VertexAndPixelShader, ComputeShader, typeList21, ShaderType;
var init_ShaderType = __esm({
  "src/foundation/definitions/ShaderType.ts"() {
    "use strict";
    init_EnumIO();
    ShaderTypeClass = (_a22 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a22, "ShaderTypeClass"), _a22);
    VertexShader = new ShaderTypeClass({
      index: 1,
      str: "VertexShader"
    });
    PixelShader = new ShaderTypeClass({
      index: 2,
      str: "PixelShader"
    });
    VertexAndPixelShader = new ShaderTypeClass({
      index: 3,
      str: "VertexAndPixelShader"
    });
    ComputeShader = new ShaderTypeClass({
      index: 4,
      str: "ComputeShader"
    });
    typeList21 = [
      VertexShader,
      PixelShader,
      VertexAndPixelShader,
      ComputeShader
    ];
    __name(from21, "from");
    __name(fromString17, "fromString");
    ShaderType = Object.freeze({
      VertexShader,
      PixelShader,
      VertexAndPixelShader,
      ComputeShader,
      from: from21,
      fromString: fromString17
    });
  }
});

// src/foundation/definitions/ShaderVariableType.ts
function from22(index) {
  return _from({
    typeList: typeList22,
    index
  });
}
function fromString18(str) {
  return _fromString({
    typeList: typeList22,
    str
  });
}
var _a23, ShaderVariableTypeClass, Varying, ReadOnlyData, typeList22, ShaderVariableType;
var init_ShaderVariableType = __esm({
  "src/foundation/definitions/ShaderVariableType.ts"() {
    "use strict";
    init_EnumIO();
    ShaderVariableTypeClass = (_a23 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a23, "ShaderVariableTypeClass"), _a23);
    Varying = new ShaderVariableTypeClass({
      index: 1,
      str: "Varying"
    });
    ReadOnlyData = new ShaderVariableTypeClass({
      index: 2,
      str: "ReadOnlyData"
    });
    typeList22 = [
      Varying,
      ReadOnlyData
    ];
    __name(from22, "from");
    __name(fromString18, "fromString");
    ShaderVariableType = Object.freeze({
      Varying,
      ReadOnlyData,
      from: from22,
      fromString: fromString18
    });
  }
});

// src/foundation/definitions/ShadingModel.ts
function from23(index) {
  return _from({
    typeList: typeList23,
    index
  });
}
var _a24, ShadingModelClass, Unknown6, Constant, Lambert, BlinnPhong, Phong, typeList23, ShadingModel2;
var init_ShadingModel = __esm({
  "src/foundation/definitions/ShadingModel.ts"() {
    "use strict";
    init_EnumIO();
    ShadingModelClass = (_a24 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a24, "ShadingModelClass"), _a24);
    Unknown6 = new ShadingModelClass({
      index: -1,
      str: "UNKNOWN"
    });
    Constant = new ShadingModelClass({
      index: 0,
      str: "CONSTANT"
    });
    Lambert = new ShadingModelClass({
      index: 1,
      str: "LAMBERT"
    });
    BlinnPhong = new ShadingModelClass({
      index: 2,
      str: "BLINN"
    });
    Phong = new ShadingModelClass({
      index: 3,
      str: "PHONG"
    });
    typeList23 = [
      Unknown6,
      Constant,
      Lambert,
      BlinnPhong,
      Phong
    ];
    __name(from23, "from");
    ShadingModel2 = Object.freeze({
      Unknown: Unknown6,
      Constant,
      Lambert,
      BlinnPhong,
      Phong,
      from: from23
    });
  }
});

// src/foundation/definitions/ShadowMap.ts
function from24(index) {
  return _from({
    typeList: typeList24,
    index
  });
}
function fromString19(str) {
  return _fromString({
    typeList: typeList24,
    str
  });
}
var _a25, ShadowMapClass, Standard, Variance, typeList24, ShadowMap;
var init_ShadowMap = __esm({
  "src/foundation/definitions/ShadowMap.ts"() {
    "use strict";
    init_EnumIO();
    ShadowMapClass = (_a25 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a25, "ShadowMapClass"), _a25);
    Standard = new ShadowMapClass({
      index: 0,
      str: "Standard"
    });
    Variance = new ShadowMapClass({
      index: 1,
      str: "Variance"
    });
    typeList24 = [
      Standard,
      Variance
    ];
    __name(from24, "from");
    __name(fromString19, "fromString");
    ShadowMap = Object.freeze({
      Standard,
      Variance,
      from: from24,
      fromString: fromString19
    });
  }
});

// src/foundation/definitions/TextureFormat.ts
function getPixelFormatFromTextureFormat(textureFormat) {
  switch (textureFormat) {
    case RGB8:
      return PixelFormat.RGB;
    case RGBA8:
      return PixelFormat.RGBA;
    case RGB10_A2:
      return PixelFormat.RGBA;
    case RG16F:
      return PixelFormat.RG;
    case RG32F:
      return PixelFormat.RG;
    case RGB16F:
      return PixelFormat.RGB;
    case RGB32F:
      return PixelFormat.RGB;
    case RGBA16F:
      return PixelFormat.RGBA;
    case RGBA32F:
      return PixelFormat.RGBA;
    case R11F_G11F_B10F:
      return PixelFormat.RGB;
    case Depth16:
      return PixelFormat.DepthComponent;
    case Depth24:
      return PixelFormat.DepthComponent;
    case Depth32F:
      return PixelFormat.DepthComponent;
    case Depth24Stencil8:
      return PixelFormat.DepthStencil;
    case Depth32FStencil8:
      return PixelFormat.DepthStencil;
    default:
      throw new Error(`Not implemented yet: ${textureFormat}`);
  }
}
function getPixelFormatAndComponentTypeFromTextureFormat(internalFormat) {
  let format = PixelFormat.RGBA;
  let type = ComponentType.UnsignedByte;
  if (internalFormat === TextureFormat.RGB8) {
    format = PixelFormat.RGB;
    type = ComponentType.UnsignedByte;
  } else if (internalFormat === TextureFormat.RGBA8) {
    format = PixelFormat.RGBA;
    type = ComponentType.UnsignedByte;
  } else if (internalFormat === TextureFormat.RGB10_A2) {
    format = PixelFormat.RGBA;
    type = ComponentType.UnsignedByte;
  } else if (internalFormat === TextureFormat.RG16F) {
    format = PixelFormat.RG;
    type = ComponentType.HalfFloat;
  } else if (internalFormat === TextureFormat.RG32F) {
    format = PixelFormat.RG;
    type = ComponentType.Float;
  } else if (internalFormat === TextureFormat.RGB16F) {
    format = PixelFormat.RGB;
    type = ComponentType.HalfFloat;
  } else if (internalFormat === TextureFormat.RGB32F) {
    format = PixelFormat.RGB;
    type = ComponentType.Float;
  } else if (internalFormat === TextureFormat.RGBA16F) {
    format = PixelFormat.RGBA;
    type = ComponentType.HalfFloat;
  } else if (internalFormat === TextureFormat.RGBA32F) {
    format = PixelFormat.RGBA;
    type = ComponentType.Float;
  } else if (internalFormat === TextureFormat.R11F_G11F_B10F) {
    format = PixelFormat.RGB;
    type = ComponentType.Float;
  } else if (internalFormat === TextureFormat.Depth16) {
    format = PixelFormat.DepthComponent;
    type = ComponentType.UnsignedShort;
  } else if (internalFormat === TextureFormat.Depth24 || internalFormat === TextureFormat.Depth24Stencil8) {
    format = PixelFormat.DepthComponent;
    type = ComponentType.UnsignedInt;
  } else if (internalFormat === TextureFormat.Depth32F || internalFormat === TextureFormat.Depth32FStencil8) {
    format = PixelFormat.DepthComponent;
    type = ComponentType.Float;
  }
  return {
    format,
    type
  };
}
function from25(index) {
  return _from({
    typeList: typeList25,
    index
  });
}
var _a26, TextureFormatClass, RGB8, RGBA8, RGB10_A2, RG16F, RG32F, RGB16F, RGB32F, RGBA16F, RGBA32F, R11F_G11F_B10F, Depth16, Depth24, Depth32F, Depth24Stencil8, Depth32FStencil8, typeList25, TextureFormat;
var init_TextureFormat = __esm({
  "src/foundation/definitions/TextureFormat.ts"() {
    "use strict";
    init_types();
    init_EnumIO();
    init_ComponentType();
    init_PixelFormat();
    TextureFormatClass = (_a26 = class extends EnumClass {
      constructor({ index, str, webgpu }) {
        super({
          index,
          str
        });
        __publicField(this, "__webgpu");
        this.__webgpu = webgpu;
      }
      get webgpu() {
        if (this.__webgpu === void 0) {
          throw new Error(`does not support ${this.str}`);
        }
        return this.__webgpu;
      }
    }, __name(_a26, "TextureFormatClass"), _a26);
    RGB8 = new TextureFormatClass({
      index: 32849,
      str: "RGB8",
      webgpu: "rgb8unorm"
    });
    RGBA8 = new TextureFormatClass({
      index: 32856,
      str: "RGBA8",
      webgpu: "rgba8unorm"
    });
    RGB10_A2 = new TextureFormatClass({
      index: 32857,
      str: "RGB10_A2",
      webgpu: "rgb10a2unorm"
    });
    RG16F = new TextureFormatClass({
      index: GL_RG16F,
      str: "RG16F",
      webgpu: "rg16float"
    });
    RG32F = new TextureFormatClass({
      index: GL_RG32F,
      str: "RG32F",
      webgpu: "rg32float"
    });
    RGB16F = new TextureFormatClass({
      index: 34843,
      str: "RGB16F",
      webgpu: "rgba16float"
    });
    RGB32F = new TextureFormatClass({
      index: 34837,
      str: "RGB32F",
      webgpu: "rgba32float"
    });
    RGBA16F = new TextureFormatClass({
      index: 34842,
      str: "RGBA16F",
      webgpu: "rgba16float"
    });
    RGBA32F = new TextureFormatClass({
      index: 34836,
      str: "RGBA32F",
      webgpu: "rgba32float"
    });
    R11F_G11F_B10F = new TextureFormatClass({
      index: 35898,
      str: "R11F_G11F_B10F",
      webgpu: "rg11b10ufloat"
    });
    Depth16 = new TextureFormatClass({
      index: 33189,
      str: "DEPTH_COMPONENT16",
      webgpu: "depth16unorm"
    });
    Depth24 = new TextureFormatClass({
      index: 33190,
      str: "DEPTH_COMPONENT24",
      webgpu: "depth24plus"
    });
    Depth32F = new TextureFormatClass({
      index: 36012,
      str: "DEPTH_COMPONENT32F",
      webgpu: "depth32float"
    });
    Depth24Stencil8 = new TextureFormatClass({
      index: 35056,
      str: "DEPTH24_STENCIL8",
      webgpu: "depth24plus-stencil8"
    });
    Depth32FStencil8 = new TextureFormatClass({
      index: 36013,
      str: "DEPTH32F_STENCIL8",
      webgpu: "depth32float-stencil8"
    });
    __name(getPixelFormatFromTextureFormat, "getPixelFormatFromTextureFormat");
    __name(getPixelFormatAndComponentTypeFromTextureFormat, "getPixelFormatAndComponentTypeFromTextureFormat");
    typeList25 = [
      RGB8,
      RGBA8,
      RGB10_A2,
      RG16F,
      RG32F,
      RGB16F,
      RGB32F,
      RGBA16F,
      RGBA32F,
      R11F_G11F_B10F,
      Depth16,
      Depth24,
      Depth32F,
      Depth24Stencil8,
      Depth32FStencil8
    ];
    __name(from25, "from");
    TextureFormat = Object.freeze({
      RGB8,
      RGBA8,
      RGB10_A2,
      RG16F,
      RG32F,
      RGB16F,
      RGB32F,
      RGBA16F,
      RGBA32F,
      R11F_G11F_B10F,
      Depth16,
      Depth24,
      Depth32F,
      Depth24Stencil8,
      Depth32FStencil8,
      getPixelFormatFromTextureFormat,
      getPixelFormatAndComponentTypeFromTextureFormat,
      from: from25
    });
  }
});

// src/foundation/definitions/TextureParameter.ts
function from26(index) {
  return _from({
    typeList: typeList26,
    index
  });
}
var _a27, TextureParameterClass, Nearest, Linear2, NearestMipmapNearest, LinearMipmapNearest, NearestMipmapLinear, LinearMipmapLinear, TextureMagFilter, TextureMinFilter, TextureWrapS, TextureWrapT, Texture2D2, Texture, Texture0, Texture1, ActiveTexture, Repeat, ClampToEdge, MirroredRepeat, typeList26, TextureParameter;
var init_TextureParameter = __esm({
  "src/foundation/definitions/TextureParameter.ts"() {
    "use strict";
    init_EnumIO();
    TextureParameterClass = (_a27 = class extends EnumClass {
      constructor({ index, str, webgpu }) {
        super({
          index,
          str
        });
        __publicField(this, "__webgpu");
        this.__webgpu = webgpu;
      }
      get webgpu() {
        if (this.__webgpu === void 0) {
          throw new Error(`does not support ${this.str}`);
        }
        return this.__webgpu;
      }
    }, __name(_a27, "TextureParameterClass"), _a27);
    Nearest = new TextureParameterClass({
      index: 9728,
      str: "NEAREST",
      webgpu: "nearest"
    });
    Linear2 = new TextureParameterClass({
      index: 9729,
      str: "LINEAR",
      webgpu: "linear"
    });
    NearestMipmapNearest = new TextureParameterClass({
      index: 9984,
      str: "NEAREST_MIPMAP_NEAREST",
      webgpu: "nearest"
    });
    LinearMipmapNearest = new TextureParameterClass({
      index: 9985,
      str: "LINEAR_MIPMAP_NEAREST",
      webgpu: "linear"
    });
    NearestMipmapLinear = new TextureParameterClass({
      index: 9986,
      str: "NEAREST_MIPMAP_LINEAR",
      webgpu: "nearest"
    });
    LinearMipmapLinear = new TextureParameterClass({
      index: 9987,
      str: "LINEAR_MIPMAP_LINEAR",
      webgpu: "linear"
    });
    TextureMagFilter = new TextureParameterClass({
      index: 10240,
      str: "TEXTURE_MAG_FILTER"
    });
    TextureMinFilter = new TextureParameterClass({
      index: 10241,
      str: "TEXTURE_MIN_FILTER"
    });
    TextureWrapS = new TextureParameterClass({
      index: 10242,
      str: "TEXTURE_WRAP_S"
    });
    TextureWrapT = new TextureParameterClass({
      index: 10243,
      str: "TEXTURE_WRAP_T"
    });
    Texture2D2 = new TextureParameterClass({
      index: 3553,
      str: "TEXTURE_2D"
    });
    Texture = new TextureParameterClass({
      index: 5890,
      str: "TEXTURE"
    });
    Texture0 = new TextureParameterClass({
      index: 33984,
      str: "TEXTURE0"
    });
    Texture1 = new TextureParameterClass({
      index: 33985,
      str: "TEXTURE1"
    });
    ActiveTexture = new TextureParameterClass({
      index: 34016,
      str: "ACTIVE_TEXTURE"
    });
    Repeat = new TextureParameterClass({
      index: 10497,
      str: "REPEAT",
      webgpu: "repeat"
    });
    ClampToEdge = new TextureParameterClass({
      index: 33071,
      str: "CLAMP_TO_EDGE",
      webgpu: "clamp-to-edge"
    });
    MirroredRepeat = new TextureParameterClass({
      index: 33648,
      str: "MIRRORED_REPEAT",
      webgpu: "mirror-repeat"
    });
    typeList26 = [
      Nearest,
      Linear2,
      NearestMipmapNearest,
      LinearMipmapNearest,
      NearestMipmapLinear,
      LinearMipmapLinear,
      TextureMagFilter,
      TextureMinFilter,
      TextureWrapS,
      TextureWrapT,
      Texture2D2,
      Texture,
      Texture0,
      Texture1,
      ActiveTexture,
      Repeat,
      ClampToEdge,
      MirroredRepeat
    ];
    __name(from26, "from");
    TextureParameter = Object.freeze({
      Nearest,
      Linear: Linear2,
      NearestMipmapNearest,
      LinearMipmapNearest,
      NearestMipmapLinear,
      LinearMipmapLinear,
      TextureMagFilter,
      TextureMinFilter,
      TextureWrapS,
      TextureWrapT,
      Texture2D: Texture2D2,
      Texture,
      Texture0,
      Texture1,
      ActiveTexture,
      Repeat,
      ClampToEdge,
      MirroredRepeat,
      from: from26
    });
  }
});

// src/foundation/definitions/VertexAttribute.ts
function isInstanceOfVertexAttributeClass(obj) {
  return obj instanceof VertexAttributeClass;
}
function from27(index) {
  return _from({
    typeList: typeList27,
    index
  });
}
function fromString20(str) {
  let newStr = str;
  if (str === "COLOR") {
    newStr = "COLOR_0";
  } else if (str === "TEXCOORD") {
    newStr = "TEXCOORD_0";
  } else if (str === "JOINTS") {
    newStr = "JOINTS_0";
  } else if (str === "WEIGHTS") {
    newStr = "WEIGHTS_0";
  }
  return _fromString({
    typeList: typeList27,
    str: newStr
  });
}
function toVertexAttributeSemanticJoinedStringAsGltfStyle(attribute) {
  switch (attribute) {
    case Position:
      return attribute.XYZ;
    case Color0:
      return attribute.XYZ;
    case Normal:
      return attribute.XYZ;
    case Tangent:
      return attribute.XYZ;
    case Texcoord0:
      return attribute.XY;
    case Texcoord1:
      return attribute.XY;
    case Texcoord2:
      return attribute.XY;
    case Joints0:
      return attribute.XYZW;
    case Weights0:
      return attribute.XYZW;
    case Instance:
      return attribute.XYZW;
    case FaceNormal:
      return attribute.XYZW;
    case BaryCentricCoord:
      return attribute.XYZW;
    default:
      throw new Error("Invalied glTF VertexAttributeEnum");
  }
}
function toAttributeSlotFromJoinedString(str) {
  switch (str) {
    case Position.XYZ:
      return Position.getAttributeSlot();
    case Color0.XYZ:
      return Color0.getAttributeSlot();
    case Normal.XYZ:
      return Normal.getAttributeSlot();
    case Tangent.XYZ:
      return Tangent.getAttributeSlot();
    case Texcoord0.XY:
      return Texcoord0.getAttributeSlot();
    case Texcoord1.XY:
      return Texcoord1.getAttributeSlot();
    case Texcoord2.XY:
      return Texcoord2.getAttributeSlot();
    case Joints0.XYZW:
      return Joints0.getAttributeSlot();
    case Weights0.XYZW:
      return Weights0.getAttributeSlot();
    case Instance.XYZW:
      return Instance.getAttributeSlot();
    case FaceNormal.XYZ:
      return FaceNormal.getAttributeSlot();
    case BaryCentricCoord.XYZ:
      return BaryCentricCoord.getAttributeSlot();
    default:
      throw new Error("Invalied glTF VertexAttributeEnum");
  }
}
function toVectorComponentN(joinedString) {
  return joinedString.split(",").length;
}
var _VertexAttributeClass, VertexAttributeClass, Unknown7, Position, Normal, Tangent, Texcoord0, Texcoord1, Color0, Joints0, Weights0, Instance, FaceNormal, BaryCentricCoord, Texcoord2, typeList27, AttributeTypeNumber, VertexAttribute;
var init_VertexAttribute = __esm({
  "src/foundation/definitions/VertexAttribute.ts"() {
    "use strict";
    init_EnumIO();
    init_RnException();
    _VertexAttributeClass = class _VertexAttributeClass extends EnumClass {
      constructor({ str, shaderStr, attributeSlot, gltfComponentN }) {
        super({
          index: _VertexAttributeClass.__indexCount++,
          str
        });
        __publicField(this, "__attributeSlot");
        __publicField(this, "__shaderStr");
        __publicField(this, "__gltfComponentN");
        this.__attributeSlot = attributeSlot;
        this.__shaderStr = shaderStr;
        this.__gltfComponentN = gltfComponentN;
      }
      getAttributeSlot() {
        return this.__attributeSlot;
      }
      get shaderStr() {
        return this.__shaderStr;
      }
      get attributeTypeName() {
        return this.str;
      }
      _setShaderStr(str) {
        this.__shaderStr = this.__shaderStr + str;
      }
      get X() {
        return `${this.attributeTypeName}.X`;
      }
      get Y() {
        return `${this.attributeTypeName}.Y`;
      }
      get Z() {
        return `${this.attributeTypeName}.Z`;
      }
      get W() {
        return `${this.attributeTypeName}.W`;
      }
      get XY() {
        return `${this.attributeTypeName}.X,${this.attributeTypeName}.Y`;
      }
      get XYZ() {
        return `${this.attributeTypeName}.X,${this.attributeTypeName}.Y,${this.attributeTypeName}.Z`;
      }
      get XYZW() {
        return `${this.attributeTypeName}.X,${this.attributeTypeName}.Y,${this.attributeTypeName}.Z,${this.attributeTypeName}.W`;
      }
      getVertexAttributeComponentsAsGltf() {
        if (this.__gltfComponentN === 1) {
          return this.X;
        } else if (this.__gltfComponentN === 2) {
          return this.XY;
        } else if (this.__gltfComponentN === 3) {
          return this.XYZ;
        } else if (this.__gltfComponentN === 4) {
          return this.XYZW;
        } else {
          throw new RnException({
            message: "Invalid gltf component number",
            error: this.__gltfComponentN
          });
        }
      }
      static __createVertexAttributeClass(desc) {
        return new _VertexAttributeClass(desc);
      }
    };
    __name(_VertexAttributeClass, "VertexAttributeClass");
    __publicField(_VertexAttributeClass, "__indexCount", -1);
    VertexAttributeClass = _VertexAttributeClass;
    Unknown7 = VertexAttributeClass.__createVertexAttributeClass({
      str: "UNKNOWN",
      shaderStr: "a_unknown",
      attributeSlot: -1,
      gltfComponentN: 0
    });
    Position = VertexAttributeClass.__createVertexAttributeClass({
      str: "POSITION",
      shaderStr: "a_position",
      attributeSlot: 0,
      gltfComponentN: 3
    });
    Normal = VertexAttributeClass.__createVertexAttributeClass({
      str: "NORMAL",
      shaderStr: "a_normal",
      attributeSlot: 1,
      gltfComponentN: 3
    });
    Tangent = VertexAttributeClass.__createVertexAttributeClass({
      str: "TANGENT",
      shaderStr: "a_tangent",
      attributeSlot: 2,
      gltfComponentN: 4
    });
    Texcoord0 = VertexAttributeClass.__createVertexAttributeClass({
      str: "TEXCOORD_0",
      shaderStr: "a_texcoord_0",
      attributeSlot: 3,
      gltfComponentN: 2
    });
    Texcoord1 = VertexAttributeClass.__createVertexAttributeClass({
      str: "TEXCOORD_1",
      shaderStr: "a_texcoord_1",
      attributeSlot: 4,
      gltfComponentN: 2
    });
    Color0 = VertexAttributeClass.__createVertexAttributeClass({
      str: "COLOR_0",
      shaderStr: "a_color_0",
      attributeSlot: 5,
      gltfComponentN: 4
    });
    Joints0 = VertexAttributeClass.__createVertexAttributeClass({
      str: "JOINTS_0",
      shaderStr: "a_joints_0",
      attributeSlot: 6,
      gltfComponentN: 4
    });
    Weights0 = VertexAttributeClass.__createVertexAttributeClass({
      str: "WEIGHTS_0",
      shaderStr: "a_weights_0",
      attributeSlot: 7,
      gltfComponentN: 4
    });
    Instance = VertexAttributeClass.__createVertexAttributeClass({
      str: "INSTANCE",
      shaderStr: "a_instanceInfo",
      attributeSlot: 8,
      gltfComponentN: 4
    });
    FaceNormal = VertexAttributeClass.__createVertexAttributeClass({
      str: "FACE_NORMAL",
      shaderStr: "a_faceNormal",
      attributeSlot: 9,
      gltfComponentN: 3
    });
    BaryCentricCoord = VertexAttributeClass.__createVertexAttributeClass({
      str: "BARY_CENTRIC_COORD",
      shaderStr: "a_baryCentricCoord",
      attributeSlot: 10,
      gltfComponentN: 4
    });
    Texcoord2 = VertexAttributeClass.__createVertexAttributeClass({
      str: "TEXCOORD_2",
      shaderStr: "a_texcoord_2",
      attributeSlot: 11,
      gltfComponentN: 2
    });
    typeList27 = [
      Unknown7,
      Position,
      Normal,
      Tangent,
      Texcoord0,
      Texcoord1,
      Color0,
      Joints0,
      Weights0,
      Instance,
      FaceNormal,
      BaryCentricCoord,
      Texcoord2
    ];
    AttributeTypeNumber = typeList27.length - 1;
    __name(isInstanceOfVertexAttributeClass, "isInstanceOfVertexAttributeClass");
    __name(from27, "from");
    __name(fromString20, "fromString");
    __name(toVertexAttributeSemanticJoinedStringAsGltfStyle, "toVertexAttributeSemanticJoinedStringAsGltfStyle");
    __name(toAttributeSlotFromJoinedString, "toAttributeSlotFromJoinedString");
    __name(toVectorComponentN, "toVectorComponentN");
    VertexAttribute = Object.freeze({
      Unknown: Unknown7,
      Position,
      Normal,
      Tangent,
      Texcoord0,
      Texcoord1,
      Color0,
      Joints0,
      Weights0,
      Instance,
      FaceNormal,
      BaryCentricCoord,
      AttributeTypeNumber,
      isInstanceOfVertexAttributeClass,
      toVertexAttributeSemanticJoinedStringAsGltfStyle,
      toAttributeSlotFromJoinedString,
      toVectorComponentN,
      from: from27,
      fromString: fromString20
    });
  }
});

// src/foundation/definitions/Visibility.ts
function from28(index) {
  return _from({
    typeList: typeList28,
    index
  });
}
function fromString21(str) {
  return _fromString({
    typeList: typeList28,
    str
  });
}
var _a28, VisibilityClass, Neutral, Visible, Invisible, typeList28, Visibility;
var init_Visibility = __esm({
  "src/foundation/definitions/Visibility.ts"() {
    "use strict";
    init_EnumIO();
    VisibilityClass = (_a28 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a28, "VisibilityClass"), _a28);
    Neutral = new VisibilityClass({
      index: 0,
      str: "Neutral"
    });
    Visible = new VisibilityClass({
      index: 1,
      str: "Visible"
    });
    Invisible = new VisibilityClass({
      index: -1,
      str: "Invisible"
    });
    typeList28 = [
      Visible,
      Invisible,
      Neutral
    ];
    __name(from28, "from");
    __name(fromString21, "fromString");
    Visibility = Object.freeze({
      Visible,
      Invisible,
      Neutral,
      from: from28,
      fromString: fromString21
    });
  }
});

// src/foundation/definitions/ToneMappingType.ts
function from29(index) {
  return _from({
    typeList: typeList29,
    index
  });
}
var _a29, ToneMappingTypeClass, None4, KhronosPbrNeutral, Reinhard, GT_ToneMap, ACES_Narkowicz, ACES_Hill, ACES_Hill_Exposure_Boost, typeList29, ToneMappingType;
var init_ToneMappingType = __esm({
  "src/foundation/definitions/ToneMappingType.ts"() {
    "use strict";
    init_EnumIO();
    ToneMappingTypeClass = (_a29 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a29, "ToneMappingTypeClass"), _a29);
    None4 = new ToneMappingTypeClass({
      index: -1,
      str: "None"
    });
    KhronosPbrNeutral = new ToneMappingTypeClass({
      index: 0,
      str: "Khronos_PBR_Neutral"
    });
    Reinhard = new ToneMappingTypeClass({
      index: 1,
      str: "Reinhard"
    });
    GT_ToneMap = new ToneMappingTypeClass({
      index: 2,
      str: "GT_ToneMap"
    });
    ACES_Narkowicz = new ToneMappingTypeClass({
      index: 3,
      str: "ACES_Filmic_ToneMap_Narkowicz"
    });
    ACES_Hill = new ToneMappingTypeClass({
      index: 4,
      str: "ACES_Filmic_ToneMap_Hill"
    });
    ACES_Hill_Exposure_Boost = new ToneMappingTypeClass({
      index: 5,
      str: "ACES_Filmic_ToneMap_Hill_Exposure_Boost"
    });
    typeList29 = [
      None4,
      KhronosPbrNeutral,
      Reinhard,
      GT_ToneMap,
      ACES_Narkowicz,
      ACES_Hill,
      ACES_Hill_Exposure_Boost
    ];
    __name(from29, "from");
    ToneMappingType = Object.freeze({
      None: None4,
      KhronosPbrNeutral,
      Reinhard,
      GT_ToneMap,
      ACES_Narkowicz,
      ACES_Hill,
      ACES_Hill_Exposure_Boost,
      from: from29
    });
  }
});

// src/foundation/definitions/index.ts
var init_definitions = __esm({
  "src/foundation/definitions/index.ts"() {
    "use strict";
    init_AlphaMode();
    init_AnimationAttribute();
    init_AnimationInterpolation();
    init_BasisCompressionType();
    init_BoneDataType();
    init_BufferUse();
    init_CameraControllerType();
    init_CameraType();
    init_ComponentType();
    init_CompositionType();
    init_CompressionTextureType();
    init_FileType();
    init_HdriFormat();
    init_LightType();
    init_PixelFormat();
    init_PrimitiveMode();
    init_ProcessApproach();
    init_ProcessStage();
    init_RenderBufferTarget();
    init_ShaderNode();
    init_ShaderSemantics();
    init_ShaderSemanticsInfo();
    init_ShaderType();
    init_ShaderVariableType();
    init_ShadingModel();
    init_ShadowMap();
    init_TextureFormat();
    init_TextureParameter();
    init_VertexAttribute();
    init_Visibility();
    init_ToneMappingType();
  }
});

// src/foundation/components/Animation/AnimationComponent.ts
var ChangeAnimationInfo, PlayEnd, _AnimationComponent, AnimationComponent;
var init_AnimationComponent = __esm({
  "src/foundation/components/Animation/AnimationComponent.ts"() {
    "use strict";
    init_Component();
    init_ComponentRepository();
    init_EntityRepository();
    init_WellKnownComponentTIDs();
    init_AnimationAttribute();
    init_MiscUtil();
    init_EventPubSub();
    init_Quaternion();
    init_Vector3();
    init_Is();
    init_AnimationOps();
    init_definitions();
    init_MutableQuaternion();
    init_MutableVector3();
    init_MathUtil();
    ChangeAnimationInfo = Symbol("AnimationComponentEventChangeAnimationInfo");
    PlayEnd = Symbol("AnimationComponentEventPlayEnd");
    _AnimationComponent = class _AnimationComponent extends Component {
      constructor(entityUid, componentSid, entityRepository, isReUse) {
        super(entityUid, componentSid, entityRepository, isReUse);
        /// inner states ///
        // The name of the current Active Track
        __publicField(this, "__firstActiveAnimationTrackName");
        __publicField(this, "__secondActiveAnimationTrackName");
        __publicField(this, "animationBlendingRatio", 0);
        // Animation Data of each AnimationComponent
        __publicField(this, "__animationTracks", /* @__PURE__ */ new Map());
        __publicField(this, "__isEffekseerState", -1);
        /// flags ///
        __publicField(this, "__isAnimating", true);
        __publicField(this, "isLoop", true);
        // Global animation time in Rhodonite
        __publicField(this, "useGlobalTime", true);
        // animation time in this animation component
        __publicField(this, "time", 0);
      }
      /// LifeCycle Methods ///
      $load() {
        this.moveStageTo(ProcessStage.Logic);
      }
      $logic() {
        if (!_AnimationComponent.isAnimating || !this.isAnimating) {
          return;
        }
        this.__applyAnimation();
      }
      __applyAnimation() {
        let time = this.time;
        if (this.useGlobalTime) {
          time = _AnimationComponent.globalTime;
        }
        const transformComponent = this.entity.getTransform();
        const blendShapeComponent = this.entity.tryToGetBlendShape();
        const effekseerComponent = this.entity.tryToGetEffekseer();
        if (Is.exist(this.__firstActiveAnimationTrackName) && this.animationBlendingRatio < 1) {
          if (this.isLoop) {
            const duration = _AnimationComponent.__animationGlobalInfo.get(this.__firstActiveAnimationTrackName).maxEndInputTime;
            time = time % duration;
          }
          const animationSetOf1st = this.__animationTracks.get(this.__firstActiveAnimationTrackName);
          if (animationSetOf1st !== void 0) {
            for (const [attributeName, channel] of animationSetOf1st) {
              const i2 = AnimationAttribute.fromString(attributeName).index;
              const value = __interpolate(channel, time, i2);
              if (i2 === AnimationAttribute.Quaternion.index) {
                transformComponent.setLocalRotationAsArray4(value);
              } else if (i2 === AnimationAttribute.Translate.index) {
                transformComponent.setLocalPositionAsArray3(value);
              } else if (i2 === AnimationAttribute.Scale.index) {
                transformComponent.setLocalScaleAsArray3(value);
              } else if (i2 === AnimationAttribute.Weights.index) {
                blendShapeComponent.weights = value;
              } else if (i2 === AnimationAttribute.Effekseer.index) {
                if (value[0] > 0.5) {
                  if (this.__isEffekseerState === 0) {
                    effekseerComponent == null ? void 0 : effekseerComponent.play();
                  }
                } else {
                  if (this.__isEffekseerState === 1) {
                    effekseerComponent == null ? void 0 : effekseerComponent.pause();
                  }
                }
                this.__isEffekseerState = value[0];
              }
            }
          }
        }
        if (Is.exist(this.__secondActiveAnimationTrackName) && this.animationBlendingRatio > 0) {
          if (this.isLoop) {
            const duration = _AnimationComponent.__animationGlobalInfo.get(this.__secondActiveAnimationTrackName).maxEndInputTime;
            time = time % duration;
          }
          const animationSetOf2nd = this.__animationTracks.get(this.__secondActiveAnimationTrackName);
          if (animationSetOf2nd !== void 0) {
            for (const [attributeName, channel] of animationSetOf2nd) {
              const i2 = AnimationAttribute.fromString(attributeName).index;
              const value = __interpolate(channel, time, i2);
              if (i2 === AnimationAttribute.Quaternion.index) {
                _AnimationComponent.__tmpQuat._v[0] = value[0];
                _AnimationComponent.__tmpQuat._v[1] = value[1];
                _AnimationComponent.__tmpQuat._v[2] = value[2];
                _AnimationComponent.__tmpQuat._v[3] = value[3];
                transformComponent.localRotation = Quaternion.qlerp(transformComponent.localRotationInner, _AnimationComponent.__tmpQuat, this.animationBlendingRatio);
              } else if (i2 === AnimationAttribute.Translate.index) {
                _AnimationComponent.__tmpPos._v[0] = value[0];
                _AnimationComponent.__tmpPos._v[1] = value[1];
                _AnimationComponent.__tmpPos._v[2] = value[2];
                transformComponent.localPosition = Vector3.lerp(transformComponent.localPositionInner, _AnimationComponent.__tmpPos, this.animationBlendingRatio);
              } else if (i2 === AnimationAttribute.Scale.index) {
                _AnimationComponent.__tmpScale._v[0] = value[0];
                _AnimationComponent.__tmpScale._v[1] = value[1];
                _AnimationComponent.__tmpScale._v[2] = value[2];
                transformComponent.localScale = Vector3.lerp(transformComponent.localScaleInner, _AnimationComponent.__tmpScale, this.animationBlendingRatio);
              } else if (i2 === AnimationAttribute.Weights.index) {
                const weightsOf2nd = value;
                for (let i3 = 0; i3 < weightsOf2nd.length; i3++) {
                  blendShapeComponent.weights[i3] = MathUtil.lerp(blendShapeComponent.weights[i3], weightsOf2nd[i3], this.animationBlendingRatio);
                }
              } else if (i2 === AnimationAttribute.Effekseer.index) {
              }
            }
          }
        }
      }
      static subscribe(type, handler) {
        _AnimationComponent.__pubsub.subscribe(type, handler);
      }
      setIsAnimating(flg) {
        this.__isAnimating = flg;
      }
      static setActiveAnimationForAll(animationTrackName) {
        const components = ComponentRepository.getComponentsWithType(_AnimationComponent);
        for (const component of components) {
          component.setActiveAnimationTrack(animationTrackName);
        }
      }
      setActiveAnimationTrack(animationTrackName) {
        if (this.__animationTracks.has(animationTrackName)) {
          this.__firstActiveAnimationTrackName = animationTrackName;
          return true;
        } else {
          return false;
        }
      }
      setSecondActiveAnimationTrack(animationTrackName) {
        if (this.__animationTracks.has(animationTrackName)) {
          this.__secondActiveAnimationTrackName = animationTrackName;
          return true;
        } else {
          return false;
        }
      }
      getActiveAnimationTrack() {
        return this.__firstActiveAnimationTrackName;
      }
      hasAnimation(trackName, pathName) {
        const animationSet = this.__animationTracks.get(trackName);
        if (Is.not.exist(animationSet)) {
          return false;
        }
        return animationSet.has(pathName);
      }
      /**
      * set an animation channel to AnimationSet
      * @param trackName - the name of animation track
      * @param pathName - the name of animation path
      * @param inputArray - the array of input values
      * @param outputArray - the array of output values
      * @param outputComponentN - the number of output value's components
      * @param interpolation - the interpolation type
      * @param makeThisActiveAnimation - if true, set this animation track as current active animation
      */
      setAnimation(trackName, pathName, inputArray, outputArray, outputComponentN, interpolation, makeThisActiveAnimation = true) {
        if (makeThisActiveAnimation) {
          this.__firstActiveAnimationTrackName = trackName;
        } else {
          this.__firstActiveAnimationTrackName = valueWithDefault({
            value: this.__firstActiveAnimationTrackName,
            defaultValue: trackName
          });
        }
        const animationSet = valueWithCompensation({
          value: this.__animationTracks.get(trackName),
          compensation: /* @__PURE__ */ __name(() => {
            const animationSet2 = /* @__PURE__ */ new Map();
            this.__animationTracks.set(trackName, animationSet2);
            return animationSet2;
          }, "compensation")
        });
        const channel = {
          sampler: {
            input: inputArray,
            output: outputArray,
            outputComponentN,
            interpolationMethod: interpolation
          },
          target: {
            pathName,
            entity: this.entity
          },
          belongTrackName: trackName
        };
        animationSet.set(pathName, channel);
        const newMinStartInputTime = inputArray[0];
        const newMaxEndInputTime = inputArray[inputArray.length - 1];
        const info = {
          name: trackName,
          minStartInputTime: newMinStartInputTime,
          maxEndInputTime: newMaxEndInputTime
        };
        _AnimationComponent.__animationGlobalInfo.set(trackName, info);
        _AnimationComponent.__pubsub.publishAsync(_AnimationComponent.Event.ChangeAnimationInfo, {
          infoMap: new Map(_AnimationComponent.__animationGlobalInfo)
        });
        this.entity.getTransform()._backupTransformAsRest();
      }
      getStartInputValueOfAnimation(animationTrackName) {
        let maxStartInputTime = Number.MAX_VALUE;
        const animationTrack = this.__animationTracks.get(animationTrackName);
        if (Is.not.exist(animationTrack)) {
          return -1;
        }
        animationTrack.forEach((channel) => {
          const input = channel.sampler.input[0];
          if (input < maxStartInputTime) {
            maxStartInputTime = input;
          }
        });
        return maxStartInputTime;
      }
      getEndInputValueOfAnimation(animationTrackName) {
        const animationTrack = this.__animationTracks.get(animationTrackName);
        if (Is.not.exist(animationTrack)) {
          return -1;
        }
        let maxEndInputTime = 0;
        animationTrack.forEach((channel) => {
          const input = channel.sampler.input[channel.sampler.input.length - 1];
          if (maxEndInputTime < input) {
            maxEndInputTime = input;
          }
        });
        return maxEndInputTime;
      }
      /**
      * get the Array of Animation Track Name
      * @returns Array of Animation Track Name
      */
      static getAnimationList() {
        return Array.from(this.__animationGlobalInfo.keys());
      }
      /**
      * get the AnimationInfo of the Component
      * @returns the map of
      */
      static getAnimationInfo() {
        return new Map(this.__animationGlobalInfo);
      }
      /**
      * get animation track names of this component
      * @returns an array of animation track name
      */
      getAnimationTrackNames() {
        return Array.from(this.__animationTracks.keys());
      }
      /**
      * get the animation channels of the animation track
      * @param animationTrackName the name of animation track to get
      * @returns the channel maps of the animation track
      */
      getAnimationChannelsOfTrack(animationTrackName) {
        return this.__animationTracks.get(animationTrackName);
      }
      get isAnimating() {
        return this.__isAnimating;
      }
      static get startInputValue() {
        const components = ComponentRepository.getComponentsWithType(_AnimationComponent);
        if (components.length === 0) {
          return 0;
        } else {
          const infoArray = Array.from(this.__animationGlobalInfo.values());
          const lastInfo = infoArray[infoArray.length - 1];
          return lastInfo.minStartInputTime;
        }
      }
      static get endInputValue() {
        const components = ComponentRepository.getComponentsWithType(_AnimationComponent);
        if (components.length === 0) {
          return 0;
        } else {
          const infoArray = Array.from(this.__animationGlobalInfo.values());
          const lastInfo = infoArray[infoArray.length - 1];
          return lastInfo.maxEndInputTime;
        }
      }
      static get componentTID() {
        return WellKnownComponentTIDs.AnimationComponentTID;
      }
      get componentTID() {
        return WellKnownComponentTIDs.AnimationComponentTID;
      }
      /**
      * get the entity which has this component.
      * @returns the entity which has this component
      */
      get entity() {
        return EntityRepository.getEntity(this.__entityUid);
      }
      /**
      * @override
      * Add this component to the entity
      * @param base the target entity
      * @param _componentClass the component class to add
      */
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let AnimationEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
          }
          getAnimation() {
            return this.getComponentByComponentTID(WellKnownComponentTIDs.AnimationComponentTID);
          }
        }, __name(_a40, "AnimationEntity"), _a40);
        applyMixins(base, AnimationEntity);
        return base;
      }
      addKeyFrame(trackName, pathName, frameToInsert, fps) {
        const secBegin = frameToInsert / fps;
        const input = secBegin;
        const secEnd = (frameToInsert + 1) / fps;
        const animationSet = this.__animationTracks.get(trackName);
        if (Is.not.exist(animationSet)) {
          return false;
        }
        const channel = animationSet.get(pathName);
        if (Is.not.exist(channel)) {
          return false;
        }
        const i2 = AnimationAttribute.fromString(pathName).index;
        const output = __interpolate(channel, _AnimationComponent.globalTime, i2);
        if (channel.sampler.input.length === 0) {
          const inputArray = Array.from(channel.sampler.input);
          inputArray.push(input);
          channel.sampler.input = new Float32Array(inputArray);
          const outputArray = Array.from(channel.sampler.output);
          outputArray.push(...output);
          channel.sampler.output = new Float32Array(outputArray);
        } else if (channel.sampler.input.length === 1) {
          const existedInput = channel.sampler.input[0];
          if (secEnd < existedInput) {
            const inputArray = Array.from(channel.sampler.input);
            inputArray.unshift(input);
            channel.sampler.input = new Float32Array(inputArray);
            const outputArray = Array.from(channel.sampler.output);
            outputArray.unshift(...output);
            channel.sampler.output = new Float32Array(outputArray);
          } else if (existedInput < secBegin) {
            const inputArray = Array.from(channel.sampler.input);
            inputArray.push(input);
            channel.sampler.input = new Float32Array(inputArray);
            const outputArray = Array.from(channel.sampler.output);
            outputArray.push(...output);
            channel.sampler.output = new Float32Array(outputArray);
          } else {
            const inputArray = Array.from(channel.sampler.input);
            inputArray.splice(0, 0, input);
            channel.sampler.input = new Float32Array(inputArray);
            const outputArray = Array.from(channel.sampler.output);
            outputArray.splice(0, 0, ...output);
            channel.sampler.output = new Float32Array(outputArray);
          }
        } else {
          for (let i3 = 0; i3 < channel.sampler.input.length; i3++) {
            const existedInput = channel.sampler.input[i3];
            if (secBegin <= existedInput) {
              if (secBegin <= existedInput && existedInput <= secEnd) {
                channel.sampler.input[i3] = input;
                for (let j = 0; j < channel.sampler.outputComponentN; j++) {
                  channel.sampler.output[i3 * channel.sampler.outputComponentN + j] = output[j];
                }
              } else {
                const inputArray = Array.from(channel.sampler.input);
                inputArray.splice(i3, 0, input);
                channel.sampler.input = new Float32Array(inputArray);
                const outputArray = Array.from(channel.sampler.output);
                outputArray.splice(i3 * channel.sampler.outputComponentN, 0, ...output);
                channel.sampler.output = new Float32Array(outputArray);
              }
              break;
            }
          }
        }
        return true;
      }
      addKeyFrameWithValue(trackName, pathName, frameToInsert, output, fps) {
        const secBegin = frameToInsert / fps;
        const input = secBegin;
        const secEnd = (frameToInsert + 1) / fps;
        const animationSet = this.__animationTracks.get(trackName);
        if (Is.not.exist(animationSet)) {
          return false;
        }
        const channel = animationSet.get(pathName);
        if (Is.not.exist(channel)) {
          return false;
        }
        if (channel.sampler.input.length === 0) {
          const inputArray = Array.from(channel.sampler.input);
          inputArray.push(input);
          channel.sampler.input = new Float32Array(inputArray);
          const outputArray = Array.from(channel.sampler.output);
          outputArray.push(...output);
          channel.sampler.output = new Float32Array(outputArray);
        } else if (channel.sampler.input.length === 1) {
          const existedInput = channel.sampler.input[0];
          if (secEnd < existedInput) {
            const inputArray = Array.from(channel.sampler.input);
            inputArray.unshift(input);
            channel.sampler.input = new Float32Array(inputArray);
            const outputArray = Array.from(channel.sampler.output);
            outputArray.unshift(...output);
            channel.sampler.output = new Float32Array(outputArray);
          } else if (existedInput < secBegin) {
            const inputArray = Array.from(channel.sampler.input);
            inputArray.push(input);
            channel.sampler.input = new Float32Array(inputArray);
            const outputArray = Array.from(channel.sampler.output);
            outputArray.push(...output);
            channel.sampler.output = new Float32Array(outputArray);
          } else {
            const inputArray = Array.from(channel.sampler.input);
            inputArray.splice(0, 0, input);
            channel.sampler.input = new Float32Array(inputArray);
            const outputArray = Array.from(channel.sampler.output);
            outputArray.splice(0, 0, ...output);
            channel.sampler.output = new Float32Array(outputArray);
          }
        } else {
          for (let i2 = 0; i2 < channel.sampler.input.length; i2++) {
            const existedInput = channel.sampler.input[i2];
            if (secBegin <= existedInput) {
              if (secBegin <= existedInput && existedInput <= secEnd) {
                channel.sampler.input[i2] = input;
                for (let j = 0; j < channel.sampler.outputComponentN; j++) {
                  channel.sampler.output[i2 * channel.sampler.outputComponentN + j] = output[j];
                }
              } else {
                const inputArray = Array.from(channel.sampler.input);
                inputArray.splice(i2, 0, input);
                channel.sampler.input = new Float32Array(inputArray);
                const outputArray = Array.from(channel.sampler.output);
                outputArray.splice(i2 * channel.sampler.outputComponentN, 0, ...output);
                channel.sampler.output = new Float32Array(outputArray);
              }
              break;
            }
          }
        }
        return true;
      }
      deleteKeysAtFrame(trackName, pathName, frameToDelete, fps) {
        const secBegin = frameToDelete / fps;
        const secEnd = (frameToDelete + 1) / fps;
        const animationSet = this.__animationTracks.get(trackName);
        if (Is.not.exist(animationSet)) {
          return false;
        }
        const channel = animationSet.get(pathName);
        if (Is.not.exist(channel)) {
          return false;
        }
        for (let i2 = 0; i2 < channel.sampler.input.length; i2++) {
          const input = channel.sampler.input[i2];
          if (secBegin <= input && input < secEnd) {
            const input2 = Array.from(channel.sampler.input);
            input2.splice(i2, 1);
            channel.sampler.input = new Float32Array(input2);
            const output = Array.from(channel.sampler.output);
            output.splice(i2 * channel.sampler.outputComponentN, channel.sampler.outputComponentN);
            channel.sampler.output = new Float32Array(output);
          }
        }
        return true;
      }
      hasKeyFramesAtFrame(trackName, pathName, frame, fps) {
        const secBegin = frame / fps;
        const secEnd = (frame + 1) / fps;
        const animationSet = this.__animationTracks.get(trackName);
        if (Is.not.exist(animationSet)) {
          return false;
        }
        const channel = animationSet.get(pathName);
        if (Is.not.exist(channel)) {
          return false;
        }
        for (let i2 = 0; i2 < channel.sampler.input.length; i2++) {
          const input = channel.sampler.input[i2];
          if (secBegin <= input && input < secEnd) {
            return true;
          }
        }
        return false;
      }
      static setIsAnimating(flag) {
        this.isAnimating = flag;
      }
      _shallowCopyFrom(component_) {
        const component = component_;
        this.__firstActiveAnimationTrackName = component.__firstActiveAnimationTrackName;
        this.__animationTracks = new Map(component.__animationTracks);
        this.__isEffekseerState = component.__isEffekseerState;
        this.__isAnimating = component.__isAnimating;
      }
      _setRetarget(retarget, postfixToTrackName) {
        const srcEntity = retarget.getEntity();
        const srcAnim = srcEntity.tryToGetAnimation();
        const dstEntity = this.entity;
        this.entity.getTransform()._backupTransformAsRest();
        if (Is.not.exist(srcAnim)) {
          return [];
        }
        srcAnim.useGlobalTime = false;
        const trackNames = [];
        for (const [_trackName, track] of srcAnim.__animationTracks) {
          const trackName = _trackName + (postfixToTrackName != null ? postfixToTrackName : "");
          trackNames.push(trackName);
          for (const [pathName, channel] of track) {
            if (channel == null) {
              continue;
            }
            const input = channel.sampler.input;
            if (channel.target.pathName === "translate") {
              const outputs = retargetTranslate(input, srcAnim);
              this.setAnimation(trackName, pathName, input, outputs, 3, channel.sampler.interpolationMethod, false);
            }
            if (channel.target.pathName === "quaternion") {
              const outputs = retargetQuaternion(input, srcAnim);
              this.setAnimation(trackName, pathName, input, outputs, 4, channel.sampler.interpolationMethod, false);
            }
            if (channel.target.pathName === "scale") {
              const outputs = retargetScale(input, srcAnim);
              this.setAnimation(trackName, pathName, input, outputs, 3, channel.sampler.interpolationMethod, false);
            }
          }
        }
        function retargetTranslate(input, srcAnim2) {
          const outputsTranslation = new Float32Array(input.length * 3);
          for (let i2 = 0; i2 < input.length; i2++) {
            srcAnim2.time = input[i2];
            srcAnim2.__applyAnimation();
            const outputTranslation = retarget.retargetTranslate(dstEntity);
            outputsTranslation[i2 * 3 + 0] = outputTranslation.x;
            outputsTranslation[i2 * 3 + 1] = outputTranslation.y;
            outputsTranslation[i2 * 3 + 2] = outputTranslation.z;
          }
          return outputsTranslation;
        }
        __name(retargetTranslate, "retargetTranslate");
        function retargetQuaternion(input, srcAnim2) {
          const outputsQuaternion = new Float32Array(input.length * 4);
          for (let i2 = 0; i2 < input.length; i2++) {
            srcAnim2.time = input[i2];
            srcAnim2.__applyAnimation();
            const outputQuaternion = retarget.retargetQuaternion(dstEntity);
            outputsQuaternion[i2 * 4 + 0] = outputQuaternion.x;
            outputsQuaternion[i2 * 4 + 1] = outputQuaternion.y;
            outputsQuaternion[i2 * 4 + 2] = outputQuaternion.z;
            outputsQuaternion[i2 * 4 + 3] = outputQuaternion.w;
          }
          return outputsQuaternion;
        }
        __name(retargetQuaternion, "retargetQuaternion");
        function retargetScale(input, srcAnim2) {
          const outputsScale = new Float32Array(input.length * 3);
          for (let i2 = 0; i2 < input.length; i2++) {
            srcAnim2.time = input[i2];
            srcAnim2.__applyAnimation();
            const outputScale = retarget.retargetScale(dstEntity);
            outputsScale[i2 * 3 + 0] = outputScale.x;
            outputsScale[i2 * 3 + 1] = outputScale.y;
            outputsScale[i2 * 3 + 2] = outputScale.z;
          }
          return outputsScale;
        }
        __name(retargetScale, "retargetScale");
        return trackNames;
      }
      resetAnimationTracks() {
        this.__animationTracks.clear();
      }
      resetAnimationTrack(trackName) {
        this.__animationTracks.delete(trackName);
      }
      resetAnimationTrackByPostfix(postfix) {
        const trackNames = this.getAnimationTrackNames();
        for (const trackName of trackNames) {
          if (trackName.endsWith(postfix)) {
            this.__animationTracks.delete(trackName);
          }
        }
      }
      _destroy() {
        super._destroy();
        this.__animationTracks.clear();
        this.__isAnimating = false;
      }
    };
    __name(_AnimationComponent, "AnimationComponent");
    __publicField(_AnimationComponent, "__animationGlobalInfo", /* @__PURE__ */ new Map());
    __publicField(_AnimationComponent, "isAnimating", true);
    __publicField(_AnimationComponent, "globalTime", 0);
    // Event for pubsub of notifications
    __publicField(_AnimationComponent, "Event", {
      ChangeAnimationInfo,
      PlayEnd
    });
    __publicField(_AnimationComponent, "__tmpQuat", MutableQuaternion.identity());
    __publicField(_AnimationComponent, "__tmpPos", MutableVector3.zero());
    __publicField(_AnimationComponent, "__tmpScale", MutableVector3.one());
    __publicField(_AnimationComponent, "__pubsub", new EventPubSub());
    AnimationComponent = _AnimationComponent;
  }
});

// src/foundation/components/Animation/IAnimationEntity.ts
var init_IAnimationEntity = __esm({
  "src/foundation/components/Animation/IAnimationEntity.ts"() {
    "use strict";
  }
});

// src/foundation/components/Animation/AnimationConstants.ts
var defaultAnimationTrackName;
var init_AnimationConstants = __esm({
  "src/foundation/components/Animation/AnimationConstants.ts"() {
    "use strict";
    defaultAnimationTrackName = "Default";
  }
});

// src/foundation/components/Animation/index.ts
var init_Animation = __esm({
  "src/foundation/components/Animation/index.ts"() {
    "use strict";
    init_AnimationComponent();
    init_IAnimationEntity();
    init_AnimationConstants();
  }
});

// src/foundation/components/BlendShape/BlendShapeComponent.ts
var _BlendShapeComponent, BlendShapeComponent;
var init_BlendShapeComponent = __esm({
  "src/foundation/components/BlendShape/BlendShapeComponent.ts"() {
    "use strict";
    init_Component();
    init_EntityRepository();
    init_WellKnownComponentTIDs();
    init_ProcessStage();
    _BlendShapeComponent = class _BlendShapeComponent extends Component {
      constructor(entityUid, componentSid, entityComponent, isReUse) {
        super(entityUid, componentSid, entityComponent, isReUse);
        __publicField(this, "__weights", []);
        __publicField(this, "__targetNames", []);
        this.moveStageTo(ProcessStage.Logic);
      }
      static get updateCount() {
        return this.__updateCount;
      }
      static get componentTID() {
        return WellKnownComponentTIDs.BlendShapeComponentTID;
      }
      get componentTID() {
        return WellKnownComponentTIDs.BlendShapeComponentTID;
      }
      set weights(weights) {
        this.__weights = weights;
        _BlendShapeComponent.__updateCount++;
      }
      get weights() {
        return this.__weights;
      }
      set targetNames(names) {
        this.__targetNames = names;
        _BlendShapeComponent.__updateCount++;
      }
      get targetNames() {
        return this.__targetNames;
      }
      setWeightByIndex(index, weight) {
        this.__weights[index] = weight;
        _BlendShapeComponent.__updateCount++;
      }
      $logic() {
      }
      _destroy() {
        super._destroy();
      }
      /**
      * @override
      * Add this component to the entity
      * @param base the target entity
      * @param _componentClass the component class to add
      */
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let BlendShapeEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
          }
          getBlendShape() {
            return this.getComponentByComponentTID(WellKnownComponentTIDs.BlendShapeComponentTID);
          }
        }, __name(_a40, "BlendShapeEntity"), _a40);
        applyMixins(base, BlendShapeEntity);
        return base;
      }
    };
    __name(_BlendShapeComponent, "BlendShapeComponent");
    __publicField(_BlendShapeComponent, "__updateCount", 0);
    BlendShapeComponent = _BlendShapeComponent;
  }
});

// src/foundation/components/BlendShape/IBlendShapeEntity.ts
var init_IBlendShapeEntity = __esm({
  "src/foundation/components/BlendShape/IBlendShapeEntity.ts"() {
    "use strict";
  }
});

// src/foundation/components/BlendShape/index.ts
var init_BlendShape = __esm({
  "src/foundation/components/BlendShape/index.ts"() {
    "use strict";
    init_BlendShapeComponent();
    init_IBlendShapeEntity();
  }
});

// src/foundation/geometry/Frustum.ts
var _Frustum, Frustum2;
var init_Frustum = __esm({
  "src/foundation/geometry/Frustum.ts"() {
    "use strict";
    init_Vector4();
    init_Matrix44();
    init_MutableMatrix44();
    init_MutableVector4();
    _Frustum = class _Frustum {
      constructor() {
        __publicField(this, "top", MutableVector4.zero());
        __publicField(this, "bottom", MutableVector4.zero());
        __publicField(this, "right", MutableVector4.zero());
        __publicField(this, "left", MutableVector4.zero());
        __publicField(this, "zNear", MutableVector4.zero());
        __publicField(this, "zFar", MutableVector4.zero());
        __publicField(this, "__updated", false);
        __publicField(this, "__vp", MutableMatrix44.zero());
        __publicField(this, "__invProjMat", MutableMatrix44.zero());
        __publicField(this, "__invViewMat", MutableMatrix44.zero());
        __publicField(this, "__tmp_vec4_0", MutableVector4.zero());
        __publicField(this, "__tmp_vec4_1", MutableVector4.zero());
        __publicField(this, "__tmp_vec4_array", [
          MutableVector4.zero(),
          MutableVector4.zero(),
          MutableVector4.zero(),
          MutableVector4.zero(),
          MutableVector4.zero(),
          MutableVector4.zero(),
          MutableVector4.zero(),
          MutableVector4.zero()
        ]);
        __publicField(this, "__hCorners", [
          // near
          Vector4.fromCopy4(-1, 1, 1, 1),
          Vector4.fromCopy4(1, 1, 1, 1),
          Vector4.fromCopy4(1, -1, 1, 1),
          Vector4.fromCopy4(-1, -1, 1, 1),
          // far
          Vector4.fromCopy4(-1, 1, -1, 1),
          Vector4.fromCopy4(1, 1, -1, 1),
          Vector4.fromCopy4(1, -1, -1, 1),
          Vector4.fromCopy4(-1, -1, -1, 1)
        ]);
        __publicField(this, "corners", []);
      }
      /**
      * Updates this view frustum data from the view and projection matrices.
      * @param viewMatrix The view matrix.
      * @param projectionMatrix The projection matrix.
      */
      update(viewMatrix, projectionMatrix) {
        Matrix44.multiplyTo(projectionMatrix, viewMatrix, this.__vp);
        this.zNear.x = this.__vp.m20 + this.__vp.m30;
        this.zNear.y = this.__vp.m21 + this.__vp.m31;
        this.zNear.z = this.__vp.m22 + this.__vp.m32;
        this.zNear.w = this.__vp.m23 + this.__vp.m33;
        this.zFar.x = -this.__vp.m20 + this.__vp.m30;
        this.zFar.y = -this.__vp.m21 + this.__vp.m31;
        this.zFar.z = -this.__vp.m22 + this.__vp.m32;
        this.zFar.w = -this.__vp.m23 + this.__vp.m33;
        this.bottom.x = this.__vp.m10 + this.__vp.m30;
        this.bottom.y = this.__vp.m11 + this.__vp.m31;
        this.bottom.z = this.__vp.m12 + this.__vp.m32;
        this.bottom.w = this.__vp.m13 + this.__vp.m33;
        this.top.x = -this.__vp.m10 + this.__vp.m30;
        this.top.y = -this.__vp.m11 + this.__vp.m31;
        this.top.z = -this.__vp.m12 + this.__vp.m32;
        this.top.w = -this.__vp.m13 + this.__vp.m33;
        this.left.x = this.__vp.m00 + this.__vp.m30;
        this.left.y = this.__vp.m01 + this.__vp.m31;
        this.left.z = this.__vp.m02 + this.__vp.m32;
        this.left.w = this.__vp.m03 + this.__vp.m33;
        this.right.x = -this.__vp.m00 + this.__vp.m30;
        this.right.y = -this.__vp.m01 + this.__vp.m31;
        this.right.z = -this.__vp.m02 + this.__vp.m32;
        this.right.w = -this.__vp.m03 + this.__vp.m33;
        Matrix44.invertTo(projectionMatrix, this.__invProjMat);
        Matrix44.invertTo(viewMatrix, this.__invViewMat);
        for (let i2 = 0; i2 < 8; i2++) {
          this.__invProjMat.multiplyVectorTo(this.__hCorners[i2], this.__tmp_vec4_0);
          this.__tmp_vec4_1.x = this.__tmp_vec4_0.x / this.__tmp_vec4_0.w;
          this.__tmp_vec4_1.y = this.__tmp_vec4_0.y / this.__tmp_vec4_0.w;
          this.__tmp_vec4_1.z = this.__tmp_vec4_0.z / this.__tmp_vec4_0.w;
          this.__tmp_vec4_1.w = 1;
          this.__invViewMat.multiplyVectorTo(this.__tmp_vec4_1, this.__tmp_vec4_array[i2]);
          this.corners[i2] = this.__tmp_vec4_array[i2];
        }
      }
      /**
      * false if fully outside, true if inside or intersects
      *
      * original idea is from https://iquilezles.org/articles/frustumcorrect/
      */
      culling(meshComponent) {
        const aabb = meshComponent.entity.getSceneGraph().worldMergedAABBWithSkeletal;
        for (let i2 = 0; i2 < 6; i2++) {
          let out2 = 0;
          const plane = this.getPlane(i2);
          out2 += plane.x * aabb.minPoint.x + plane.y * aabb.minPoint.y + plane.z * aabb.minPoint.z + plane.w < 0 ? 1 : 0;
          out2 += plane.x * aabb.maxPoint.x + plane.y * aabb.minPoint.y + plane.z * aabb.minPoint.z + plane.w < 0 ? 1 : 0;
          out2 += plane.x * aabb.minPoint.x + plane.y * aabb.maxPoint.y + plane.z * aabb.minPoint.z + plane.w < 0 ? 1 : 0;
          out2 += plane.x * aabb.maxPoint.x + plane.y * aabb.maxPoint.y + plane.z * aabb.minPoint.z + plane.w < 0 ? 1 : 0;
          out2 += plane.x * aabb.minPoint.x + plane.y * aabb.minPoint.y + plane.z * aabb.maxPoint.z + plane.w < 0 ? 1 : 0;
          out2 += plane.x * aabb.maxPoint.x + plane.y * aabb.minPoint.y + plane.z * aabb.maxPoint.z + plane.w < 0 ? 1 : 0;
          out2 += plane.x * aabb.minPoint.x + plane.y * aabb.maxPoint.y + plane.z * aabb.maxPoint.z + plane.w < 0 ? 1 : 0;
          out2 += plane.x * aabb.maxPoint.x + plane.y * aabb.maxPoint.y + plane.z * aabb.maxPoint.z + plane.w < 0 ? 1 : 0;
          if (out2 === 8) {
            return false;
          }
        }
        let out = 0;
        out = 0;
        for (let i2 = 0; i2 < 8; i2++) {
          const plane = this.corners[i2];
          out += plane.x > aabb.maxPoint.x ? 1 : 0;
        }
        if (out === 8) {
          return false;
        }
        out = 0;
        for (let i2 = 0; i2 < 8; i2++) {
          const plane = this.corners[i2];
          out += plane.x < aabb.minPoint.x ? 1 : 0;
        }
        if (out === 8) {
          return false;
        }
        out = 0;
        for (let i2 = 0; i2 < 8; i2++) {
          const plane = this.corners[i2];
          out += plane.y > aabb.maxPoint.y ? 1 : 0;
        }
        if (out === 8) {
          return false;
        }
        out = 0;
        for (let i2 = 0; i2 < 8; i2++) {
          const plane = this.corners[i2];
          out += plane.y < aabb.minPoint.y ? 1 : 0;
        }
        if (out === 8) {
          return false;
        }
        out = 0;
        for (let i2 = 0; i2 < 8; i2++) {
          const plane = this.corners[i2];
          out += plane.z > aabb.maxPoint.z ? 1 : 0;
        }
        if (out === 8) {
          return false;
        }
        out = 0;
        for (let i2 = 0; i2 < 8; i2++) {
          const plane = this.corners[i2];
          out += plane.z < aabb.minPoint.z ? 1 : 0;
        }
        if (out === 8) {
          return false;
        }
        return true;
      }
      getPlane(i2) {
        switch (i2) {
          case 0:
            return this.top;
          case 1:
            return this.bottom;
          case 2:
            return this.right;
          case 3:
            return this.left;
          case 4:
            return this.zNear;
          case 5:
            return this.zFar;
          default:
            throw new Error("Invalid plane index.");
        }
      }
    };
    __name(_Frustum, "Frustum");
    Frustum2 = _Frustum;
  }
});

// src/webgl/getRenderingStrategy.ts
var getRenderingStrategy, getRenderingStrategy_default;
var init_getRenderingStrategy = __esm({
  "src/webgl/getRenderingStrategy.ts"() {
    "use strict";
    init_ProcessApproach();
    init_ModuleManager();
    getRenderingStrategy = /* @__PURE__ */ __name(function(processApproach) {
      const moduleName = "webgl";
      const moduleManager = ModuleManager.getInstance();
      const webglModule = moduleManager.getModule(moduleName);
      if (ProcessApproach.isDataTextureApproach(processApproach)) {
        return webglModule.WebGLStrategyDataTexture.getInstance();
      } else if (ProcessApproach.isUniformApproach(processApproach)) {
        return webglModule.WebGLStrategyUniform.getInstance();
      }
      return webglModule.WebGLStrategyUniform.getInstance();
    }, "getRenderingStrategy");
    getRenderingStrategy_default = getRenderingStrategy;
  }
});

// src/webgl/WebGLExtension.ts
var _a30, WebGLExtensionClass, VertexArrayObject, TextureFloat, TextureHalfFloat, TextureFloatLinear, TextureHalfFloatLinear, InstancedArrays, TextureFilterAnisotropic, ElementIndexUint, ShaderTextureLod, ShaderDerivatives, DrawBuffers, BlendMinmax, ColorBufferFloatWebGL1, CompressedTextureAstc, CompressedTextureS3tc, CompressedTexturePvrtc, CompressedTextureAtc, CompressedTextureEtc, CompressedTextureEtc1, CompressedTextureBptc, GMAN_WEBGL_MEMORY, ColorBufferFloatWebGL2, ColorBufferHalfFloatWebGL2, OculusMultiview, OvrMultiview2, ClipControl, WebGLExtension;
var init_WebGLExtension = __esm({
  "src/webgl/WebGLExtension.ts"() {
    "use strict";
    init_EnumIO();
    WebGLExtensionClass = (_a30 = class extends EnumClass {
      constructor({ index, str }) {
        super({
          index,
          str
        });
      }
    }, __name(_a30, "WebGLExtensionClass"), _a30);
    VertexArrayObject = new WebGLExtensionClass({
      index: 1,
      str: "OES_vertex_array_object"
    });
    TextureFloat = new WebGLExtensionClass({
      index: 2,
      str: "OES_texture_float"
    });
    TextureHalfFloat = new WebGLExtensionClass({
      index: 3,
      str: "OES_texture_half_float"
    });
    TextureFloatLinear = new WebGLExtensionClass({
      index: 4,
      str: "OES_texture_float_linear"
    });
    TextureHalfFloatLinear = new WebGLExtensionClass({
      index: 5,
      str: "OES_texture_half_float_linear"
    });
    InstancedArrays = new WebGLExtensionClass({
      index: 6,
      str: "ANGLE_instanced_arrays"
    });
    TextureFilterAnisotropic = new WebGLExtensionClass({
      index: 7,
      str: "EXT_texture_filter_anisotropic"
    });
    ElementIndexUint = new WebGLExtensionClass({
      index: 8,
      str: "OES_element_index_uint"
    });
    ShaderTextureLod = new WebGLExtensionClass({
      index: 9,
      str: "EXT_shader_texture_lod"
    });
    ShaderDerivatives = new WebGLExtensionClass({
      index: 10,
      str: "OES_standard_derivatives"
    });
    DrawBuffers = new WebGLExtensionClass({
      index: 11,
      str: "WEBGL_draw_buffers"
    });
    BlendMinmax = new WebGLExtensionClass({
      index: 12,
      str: "EXT_blend_minmax"
    });
    ColorBufferFloatWebGL1 = new WebGLExtensionClass({
      index: 13,
      str: "WEBGL_color_buffer_float"
    });
    CompressedTextureAstc = new WebGLExtensionClass({
      index: 14,
      str: "WEBGL_compressed_texture_astc"
    });
    CompressedTextureS3tc = new WebGLExtensionClass({
      index: 15,
      str: "WEBGL_compressed_texture_s3tc"
    });
    CompressedTexturePvrtc = new WebGLExtensionClass({
      index: 16,
      str: "WEBGL_compressed_texture_pvrtc"
    });
    CompressedTextureAtc = new WebGLExtensionClass({
      index: 17,
      str: "WEBGL_compressed_texture_atc"
    });
    CompressedTextureEtc = new WebGLExtensionClass({
      index: 18,
      str: "WEBGL_compressed_texture_etc"
    });
    CompressedTextureEtc1 = new WebGLExtensionClass({
      index: 19,
      str: "WEBGL_compressed_texture_etc1"
    });
    CompressedTextureBptc = new WebGLExtensionClass({
      index: 20,
      str: "EXT_texture_compression_bptc"
    });
    GMAN_WEBGL_MEMORY = new WebGLExtensionClass({
      index: 21,
      str: "GMAN_webgl_memory"
    });
    ColorBufferFloatWebGL2 = new WebGLExtensionClass({
      index: 22,
      str: "EXT_color_buffer_float"
    });
    ColorBufferHalfFloatWebGL2 = new WebGLExtensionClass({
      index: 23,
      str: "EXT_color_buffer_half_float"
    });
    OculusMultiview = new WebGLExtensionClass({
      index: 24,
      str: "OCULUS_multiview"
    });
    OvrMultiview2 = new WebGLExtensionClass({
      index: 25,
      str: "OVR_multiview2"
    });
    ClipControl = new WebGLExtensionClass({
      index: 26,
      str: "EXT_clip_control"
    });
    WebGLExtension = Object.freeze({
      VertexArrayObject,
      TextureFloat,
      TextureHalfFloat,
      TextureFloatLinear,
      TextureHalfFloatLinear,
      InstancedArrays,
      TextureFilterAnisotropic,
      ElementIndexUint,
      ShaderTextureLod,
      ShaderDerivatives,
      DrawBuffers,
      BlendMinmax,
      ColorBufferFloatWebGL1,
      CompressedTextureAstc,
      CompressedTextureS3tc,
      CompressedTexturePvrtc,
      CompressedTextureAtc,
      CompressedTextureEtc,
      CompressedTextureEtc1,
      CompressedTextureBptc,
      ColorBufferFloatWebGL2,
      ColorBufferHalfFloatWebGL2,
      OculusMultiview,
      OvrMultiview2,
      GMAN_WEBGL_MEMORY,
      ClipControl
    });
  }
});

// src/webgl/WebGLContextWrapper.ts
var INVALID_SIZE, _alignedMaxUniformBlockSize, _maxUniformBlockSize, _uniformBufferOffsetAlignment, _maxVertexUniformBlocks, _maxFragmentUniformBlocks, _maxConventionUniformBlocks, _WebGLContextWrapper, WebGLContextWrapper;
var init_WebGLContextWrapper = __esm({
  "src/webgl/WebGLContextWrapper.ts"() {
    "use strict";
    init_WebGLExtension();
    init_Vector4();
    init_Config();
    init_Logger();
    INVALID_SIZE = -1;
    _WebGLContextWrapper = class _WebGLContextWrapper {
      constructor(gl, canvas) {
        __publicField(this, "__gl");
        __publicField(this, "__webglVersion", 1);
        __publicField(this, "width", 0);
        __publicField(this, "height", 0);
        __publicField(this, "canvas");
        __publicField(this, "webgl1ExtVAO");
        __publicField(this, "webgl1ExtIA");
        __publicField(this, "webgl1ExtTF");
        __publicField(this, "webgl1ExtTHF");
        __publicField(this, "webgl1ExtTFL");
        __publicField(this, "webgl1ExtTHFL");
        __publicField(this, "webgl1ExtTFA");
        __publicField(this, "webgl1ExtEIUI");
        __publicField(this, "webgl1ExtSTL");
        __publicField(this, "webgl1ExtDRV");
        __publicField(this, "webgl1ExtDB");
        __publicField(this, "webgl1ExtBM");
        __publicField(this, "webgl1ExtCBF");
        __publicField(this, "webgl1ExtCTAstc");
        __publicField(this, "webgl1ExtCTS3tc");
        __publicField(this, "webgl1ExtCTPvrtc");
        __publicField(this, "webgl1ExtCTAtc");
        __publicField(this, "webgl1ExtCTEtc");
        __publicField(this, "webgl1ExtCTEtc1");
        __publicField(this, "webgl1ExtCTBptc");
        __publicField(this, "webgl2ExtTFL");
        __publicField(this, "webgl2ExtTHFL");
        __publicField(this, "webgl2ExtTFA");
        __publicField(this, "webgl2ExtCBF");
        __publicField(this, "webgl2ExtCBHF");
        __publicField(this, "webgl2ExtCTAstc");
        __publicField(this, "webgl2ExtCTS3tc");
        __publicField(this, "webgl2ExtCTPvrtc");
        __publicField(this, "webgl2ExtCTAtc");
        __publicField(this, "webgl2ExtCTEtc");
        __publicField(this, "webgl2ExtCTEtc1");
        __publicField(this, "webgl2ExtCTBptc");
        __publicField(this, "webgl2ExtMLTVIEW");
        __publicField(this, "webgl2ExtClipCtrl");
        __publicField(this, "webgl2ExtGmanWM");
        __publicField(this, "__activeTextureBackup", -1);
        __publicField(this, "__activeTextures2D", []);
        __publicField(this, "__activeTextures2DArray", []);
        __publicField(this, "__activeTexturesCube", []);
        __publicField(this, "__boundTextures", /* @__PURE__ */ new Map());
        __publicField(this, "__boundSamplers", /* @__PURE__ */ new Map());
        __publicField(this, "__viewport_left", 0);
        __publicField(this, "__viewport_top", 0);
        __publicField(this, "__viewport_width", 0);
        __publicField(this, "__viewport_height", 0);
        __publicField(this, "__default_viewport_left", 0);
        __publicField(this, "__default_viewport_top", 0);
        __publicField(this, "__default_viewport_width", 0);
        __publicField(this, "__default_viewport_height", 0);
        __privateAdd(this, _alignedMaxUniformBlockSize, INVALID_SIZE);
        __privateAdd(this, _maxUniformBlockSize, INVALID_SIZE);
        __privateAdd(this, _uniformBufferOffsetAlignment, INVALID_SIZE);
        __privateAdd(this, _maxVertexUniformBlocks, INVALID_SIZE);
        __privateAdd(this, _maxFragmentUniformBlocks, INVALID_SIZE);
        __privateAdd(this, _maxConventionUniformBlocks, INVALID_SIZE);
        __publicField(this, "__maxVertexUniformVectors", INVALID_SIZE);
        __publicField(this, "__maxFragmentUniformVectors", INVALID_SIZE);
        __publicField(this, "__is_multiview");
        __publicField(this, "_isWebXRMode", false);
        __publicField(this, "__extensions", /* @__PURE__ */ new Map());
        this.__gl = gl;
        this.width = canvas.width;
        this.height = canvas.height;
        this.canvas = canvas;
        this.__viewport_width = this.__default_viewport_width = this.width;
        this.__viewport_height = this.__default_viewport_height = this.height;
        this.__is_multiview = true;
        if (this.__gl.constructor.name === "WebGL2RenderingContext") {
          this.__webglVersion = 2;
          this.webgl2ExtTFL = this.__getExtension(WebGLExtension.TextureFloatLinear);
          this.webgl2ExtTHFL = this.__getExtension(WebGLExtension.TextureHalfFloatLinear);
          this.webgl2ExtTFA = this.__getExtension(WebGLExtension.TextureFilterAnisotropic);
          this.webgl2ExtCBF = this.__getExtension(WebGLExtension.ColorBufferFloatWebGL2);
          this.webgl2ExtCBHF = this.__getExtension(WebGLExtension.ColorBufferHalfFloatWebGL2);
          this.webgl2ExtCTAstc = this.__getCompressedTextureExtension(WebGLExtension.CompressedTextureAstc);
          this.webgl2ExtCTS3tc = this.__getCompressedTextureExtension(WebGLExtension.CompressedTextureS3tc);
          this.webgl2ExtCTPvrtc = this.__getCompressedTextureExtension(WebGLExtension.CompressedTexturePvrtc);
          this.webgl2ExtCTAtc = this.__getCompressedTextureExtension(WebGLExtension.CompressedTextureAtc);
          this.webgl2ExtCTEtc = this.__getCompressedTextureExtension(WebGLExtension.CompressedTextureEtc);
          this.webgl2ExtCTEtc1 = this.__getCompressedTextureExtension(WebGLExtension.CompressedTextureEtc1);
          this.webgl2ExtCTBptc = this.__getCompressedTextureExtension(WebGLExtension.CompressedTextureBptc);
          this.webgl2ExtMLTVIEW = this.__getExtension(WebGLExtension.OculusMultiview);
          if (this.webgl2ExtMLTVIEW) {
            this.webgl2ExtMLTVIEW.is_multisample = true;
          } else {
            this.webgl2ExtMLTVIEW = this.__getExtension(WebGLExtension.OvrMultiview2);
            if (this.webgl2ExtMLTVIEW) {
              this.webgl2ExtMLTVIEW.is_multisample = false;
            } else {
              if (Config.cgApiDebugConsoleOutput) {
                Logger.info("OCULUS_multiview and OVR_multiview2 extensions are not supported");
              }
              this.__is_multiview = false;
            }
          }
          this.webgl2ExtClipCtrl = this.__getExtension(WebGLExtension.ClipControl);
          this.webgl2ExtGmanWM = this.__getExtension(WebGLExtension.GMAN_WEBGL_MEMORY);
        }
        this.__getUniformBufferInfo();
        this.__getMaxUniformVectors();
      }
      getRawContext() {
        return this.__gl;
      }
      getRawContextAsWebGL1() {
        return this.__gl;
      }
      getRawContextAsWebGL2() {
        return this.__gl;
      }
      get viewport() {
        return Vector4.fromCopyArray([
          this.__viewport_left,
          this.__viewport_top,
          this.__viewport_width,
          this.__viewport_height
        ]);
      }
      get defaultViewport() {
        return Vector4.fromCopyArray([
          this.__default_viewport_left,
          this.__default_viewport_top,
          this.__default_viewport_width,
          this.__default_viewport_height
        ]);
      }
      isSupportWebGL1Extension(webGLExtension) {
        if (this.__getExtension(webGLExtension)) {
          return true;
        } else {
          return false;
        }
      }
      isNotSupportWebGL1Extension(webGLExtension) {
        return !this.isSupportWebGL1Extension(webGLExtension);
      }
      getIsWebGL2(gl) {
        return this.isWebGL2;
      }
      get isWebGL2() {
        if (this.__webglVersion === 2) {
          return true;
        } else {
          return false;
        }
      }
      createVertexArray() {
        if (this.getIsWebGL2(this.__gl)) {
          return this.__gl.createVertexArray();
        } else {
          if (this.webgl1ExtVAO != null) {
            return this.webgl1ExtVAO.createVertexArrayOES();
          } else {
            return void 0;
          }
        }
      }
      deleteVertexArray(vertexArray) {
        if (this.getIsWebGL2(this.__gl)) {
          this.__gl.deleteVertexArray(vertexArray);
        } else {
          if (this.webgl1ExtVAO != null) {
            this.webgl1ExtVAO.deleteVertexArrayOES(vertexArray);
          }
        }
      }
      bindVertexArray(vao) {
        if (this.getIsWebGL2(this.__gl)) {
          this.__gl.bindVertexArray(vao);
        } else {
          if (this.webgl1ExtVAO != null) {
            this.webgl1ExtVAO.bindVertexArrayOES(vao);
          }
        }
      }
      vertexAttribDivisor(index, divisor) {
        if (this.getIsWebGL2(this.__gl)) {
          this.__gl.vertexAttribDivisor(index, divisor);
        } else {
          this.webgl1ExtIA.vertexAttribDivisorANGLE(index, divisor);
        }
      }
      drawElementsInstanced(primitiveMode, indexCount, type, offset, instanceCount) {
        this.__gl.drawElementsInstanced(primitiveMode, indexCount, type, offset, instanceCount);
      }
      drawArraysInstanced(primitiveMode, first, count, instanceCount) {
        this.__gl.drawArraysInstanced(primitiveMode, first, count, instanceCount);
      }
      colorAttachment(index) {
        return 36064 + index;
      }
      drawBuffers(buffers) {
        const gl = this.__gl;
        if (buffers.length === 0) {
          gl.drawBuffers([
            gl.NONE
          ]);
          return;
        }
        const buffer = buffers[0].webGLConstantValue();
        gl.drawBuffers(buffers.map((buf) => {
          return buf.webGLConstantValue();
        }));
        if (buffer === gl.NONE || buffers.length === 0) {
          gl.colorMask(false, false, false, false);
        } else {
          gl.colorMask(true, true, true, true);
        }
      }
      __activeTexture(activeTextureIndex) {
        if (this.__activeTextureBackup === activeTextureIndex) {
          return;
        }
        this.__gl.activeTexture(this.__gl.TEXTURE0 + activeTextureIndex);
        this.__activeTextureBackup = activeTextureIndex;
      }
      bindTexture2D(activeTextureIndex, texture) {
        const tex = this.__boundTextures.get(activeTextureIndex);
        if (tex !== texture) {
          this.__activeTexture(activeTextureIndex);
          this.__gl.bindTexture(this.__gl.TEXTURE_2D, texture);
          this.__boundTextures.set(activeTextureIndex, texture);
        }
        this.__activeTextures2D[activeTextureIndex] = texture;
      }
      bindTexture2DArray(activeTextureIndex, texture) {
        const tex = this.__boundTextures.get(activeTextureIndex);
        if (tex !== texture) {
          this.__activeTexture(activeTextureIndex);
          this.__gl.bindTexture(this.__gl.TEXTURE_2D_ARRAY, texture);
          this.__boundTextures.set(activeTextureIndex, texture);
        }
        this.__activeTextures2DArray[activeTextureIndex] = texture;
      }
      bindTextureSampler(activeTextureIndex, sampler) {
        this.__gl.bindSampler(activeTextureIndex, sampler);
        this.__boundSamplers.set(activeTextureIndex, sampler);
      }
      bindTextureCube(activeTextureIndex, texture) {
        const tex = this.__boundTextures.get(activeTextureIndex);
        if (tex !== texture) {
          this.__activeTexture(activeTextureIndex);
          this.__gl.bindTexture(this.__gl.TEXTURE_CUBE_MAP, texture);
          this.__boundTextures.set(activeTextureIndex, texture);
        }
        this.__activeTexturesCube[activeTextureIndex] = texture;
      }
      unbindTexture2D(activeTextureIndex) {
        this.__activeTexture(activeTextureIndex);
        this.__gl.bindTexture(this.__gl.TEXTURE_2D, null);
        this.__boundTextures.delete(activeTextureIndex);
        delete this.__activeTextures2D[activeTextureIndex];
      }
      unbindTextureCube(activeTextureIndex) {
        this.__activeTexture(activeTextureIndex);
        this.__gl.bindTexture(this.__gl.TEXTURE_CUBE_MAP, null);
        this.__boundTextures.delete(activeTextureIndex);
        delete this.__activeTexturesCube[activeTextureIndex];
      }
      unbindTextures() {
        for (let i2 = 0; i2 < this.__activeTextures2D.length; i2++) {
          if (this.__activeTextures2D[i2] == null) {
            continue;
          }
          this.__activeTexture(15);
          this.__gl.bindTexture(this.__gl.TEXTURE_2D, null);
          delete this.__activeTextures2D[i2];
        }
        for (let i2 = 0; i2 < this.__activeTextures2DArray.length; i2++) {
          if (this.__activeTextures2DArray[i2] == null) {
            continue;
          }
          this.__activeTexture(15);
          this.__gl.bindTexture(this.__gl.TEXTURE_2D_ARRAY, null);
          delete this.__activeTextures2DArray[i2];
        }
        for (let i2 = 0; i2 < this.__activeTexturesCube.length; i2++) {
          if (this.__activeTexturesCube[i2] == null) {
            continue;
          }
          this.__activeTexture(15);
          this.__gl.bindTexture(this.__gl.TEXTURE_CUBE_MAP, null);
          delete this.__activeTexturesCube[i2];
        }
      }
      __getExtension(extension) {
        const gl = this.__gl;
        if (!this.__extensions.has(extension)) {
          const extObj = gl.getExtension(extension.toString());
          if (extObj == null && Config.cgApiDebugConsoleOutput) {
            const text = `${extension.toString()} Not Available in this environment`;
            Logger.info(text);
          }
          this.__extensions.set(extension, extObj);
          return extObj;
        }
        return this.__extensions.get(extension);
      }
      __getCompressedTextureExtension(extension) {
        var _a40, _b;
        const gl = this.__gl;
        if (!this.__extensions.has(extension)) {
          const extensionName = extension.toString();
          const extObj = (_b = (_a40 = gl.getExtension(extensionName)) != null ? _a40 : gl.getExtension("MOZ_" + extensionName)) != null ? _b : gl.getExtension("WEBKIT_" + extensionName);
          if (extObj == null && Config.cgApiDebugConsoleOutput) {
            const text = `${extension.toString()} Not Available in this environment`;
            Logger.info(text);
          } else {
            this.__extensions.set(extension, extObj);
          }
          return extObj;
        }
        return this.__extensions.get(extension);
      }
      setViewport(left, top, width, height) {
        const gl = this.__gl;
        if (this.__viewport_width !== width || this.__viewport_height !== height || this.__viewport_left !== left || this.__viewport_top !== top) {
          gl.viewport(left, top, width, height);
          this.__viewport_left = left;
          this.__viewport_top = top;
          this.__viewport_width = width;
          this.__viewport_height = height;
        }
      }
      setViewportAsVector4(viewport) {
        const gl = this.__gl;
        if (this.__viewport_width !== viewport.z || this.__viewport_height !== viewport.w || this.__viewport_left !== viewport.x || this.__viewport_top !== viewport.y) {
          gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
          this.__viewport_left = viewport.x;
          this.__viewport_top = viewport.y;
          this.__viewport_width = viewport.z;
          this.__viewport_height = viewport.w;
        }
      }
      __getUniformBufferInfo() {
        if (!this.isWebGL2) {
          return;
        }
        const gl = this.__gl;
        const offsetAlignment = gl.getParameter(gl.UNIFORM_BUFFER_OFFSET_ALIGNMENT);
        const maxBlockSize = gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE);
        __privateSet(this, _maxVertexUniformBlocks, gl.getParameter(gl.MAX_VERTEX_UNIFORM_BLOCKS));
        __privateSet(this, _maxFragmentUniformBlocks, gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_BLOCKS));
        __privateSet(this, _maxConventionUniformBlocks, Math.min(__privateGet(this, _maxVertexUniformBlocks), __privateGet(this, _maxFragmentUniformBlocks)));
        __privateSet(this, _alignedMaxUniformBlockSize, maxBlockSize - maxBlockSize % offsetAlignment);
        __privateSet(this, _uniformBufferOffsetAlignment, offsetAlignment);
        __privateSet(this, _maxUniformBlockSize, maxBlockSize);
      }
      __getMaxUniformVectors() {
        const gl = this.getRawContext();
        this.__maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        this.__maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
      }
      getMaxConventionUniformBlocks() {
        return __privateGet(this, _maxConventionUniformBlocks);
      }
      getAlignedMaxUniformBlockSize() {
        return __privateGet(this, _alignedMaxUniformBlockSize);
      }
      getMaxVertexUniformVectors() {
        return this.__maxVertexUniformVectors;
      }
      getMaxFragmentUniformVectors() {
        return this.__maxFragmentUniformVectors;
      }
      getWebGLMemoryInfo() {
        if (this.webgl2ExtGmanWM) {
          const result = this.webgl2ExtGmanWM.getMemoryInfo();
          return result;
        }
        return void 0;
      }
      isMultiview() {
        return this.__is_multiview && Config.multiViewForWebVR;
      }
    };
    _alignedMaxUniformBlockSize = new WeakMap();
    _maxUniformBlockSize = new WeakMap();
    _uniformBufferOffsetAlignment = new WeakMap();
    _maxVertexUniformBlocks = new WeakMap();
    _maxFragmentUniformBlocks = new WeakMap();
    _maxConventionUniformBlocks = new WeakMap();
    __name(_WebGLContextWrapper, "WebGLContextWrapper");
    WebGLContextWrapper = _WebGLContextWrapper;
  }
});

// src/foundation/textures/AbstractTexture.ts
var _AbstractTexture, AbstractTexture;
var init_AbstractTexture = __esm({
  "src/foundation/textures/AbstractTexture.ts"() {
    "use strict";
    init_RnObject();
    init_PixelFormat();
    init_ComponentType();
    init_TextureDataFloat();
    init_CompositionType();
    init_Is();
    init_TextureFormat();
    _AbstractTexture = class _AbstractTexture extends RnObject {
      constructor() {
        super();
        __publicField(this, "__width", 0);
        __publicField(this, "__height", 0);
        __publicField(this, "__level", 0);
        __publicField(this, "__mipLevelCount", 1);
        __publicField(this, "__internalFormat", TextureFormat.RGBA8);
        __publicField(this, "__format", PixelFormat.RGBA);
        __publicField(this, "__type", ComponentType.UnsignedByte);
        __publicField(this, "__hasTransparentPixels", false);
        __publicField(this, "__textureUid");
        __publicField(this, "__img");
        __publicField(this, "__isTextureReady", false);
        __publicField(this, "__startedToLoad", false);
        __publicField(this, "__htmlImageElement");
        __publicField(this, "__htmlCanvasElement");
        __publicField(this, "__canvasContext");
        __publicField(this, "__uri");
        __publicField(this, "__name", "untitled");
        __publicField(this, "_textureResourceUid", -1);
        __publicField(this, "_samplerResourceUid", -1);
        __publicField(this, "_textureViewResourceUid", -1);
        __publicField(this, "_textureViewAsRenderTargetResourceUid", -1);
        __publicField(this, "_recommendedTextureSampler");
        this.__textureUid = ++_AbstractTexture.__textureUidCount;
      }
      get textureUID() {
        return this.__textureUid;
      }
      get width() {
        return this.__width;
      }
      getWidthAtMipLevel(mipLevel) {
        return Math.max(1, Math.floor(this.__width / Math.pow(2, mipLevel)));
      }
      getHeightAtMipLevel(mipLevel) {
        return Math.max(1, Math.floor(this.__height / Math.pow(2, mipLevel)));
      }
      set width(val) {
        this.__width = val;
      }
      get height() {
        return this.__height;
      }
      set height(val) {
        this.__height = val;
      }
      get isTextureReady() {
        return this.__isTextureReady;
      }
      get startedToLoad() {
        return this.__startedToLoad;
      }
      get htmlImageElement() {
        return this.__htmlImageElement;
      }
      get htmlCanvasElement() {
        const canvas = document.createElement("canvas");
        const ctx = canvas == null ? void 0 : canvas.getContext("2d");
        this.__htmlCanvasElement = canvas;
        if (Is.exist(ctx) && Is.exist(this.__htmlImageElement)) {
          canvas.width = this.__htmlImageElement.width;
          canvas.height = this.__htmlImageElement.height;
          ctx.drawImage(this.__htmlImageElement, 0, 0, this.__htmlImageElement.width, this.__htmlImageElement.height);
        }
        return this.__htmlCanvasElement;
      }
      get uri() {
        return this.__uri;
      }
      set name(name) {
        this.__name = name;
      }
      get name() {
        return this.__name;
      }
      getImageData(x, y, width, height) {
        if (this.__canvasContext === void 0) {
          this.createInternalCanvasContext();
        }
        return this.__canvasContext.getImageData(x, y, width, height);
      }
      getPixelAs(x, y, typeClass) {
        const pixel = this.getImageData(x, y, 1, 1);
        const data = pixel.data;
        if (typeClass.compositionType === CompositionType.Vec4) {
          return new typeClass(new Float32Array([
            data[0],
            data[1],
            data[2],
            data[3]
          ]));
        } else {
          return new typeClass(new Float32Array([
            data[0],
            data[1],
            data[2]
          ]));
        }
      }
      /**
      * get the pixel data at (x,y) in the Texture as Uint8Clamped Array
      * @param x x position in the texture
      * @param y y position in the texture
      * @returns a pixel data as Uint8Clamped Array
      */
      getPixelAsArray(x, y) {
        const pixel = this.getImageData(x, y, 1, 1);
        return pixel.data;
      }
      setPixel(x, y, value) {
        const pixel = this.getImageData(x, y, 1, 1);
        const data = pixel.data;
        const classOfValue = value.constructor;
        const numberOfComponents = classOfValue.compositionType.getNumberOfComponents();
        for (let i2 = 0; i2 < numberOfComponents; i2++) {
          data[i2] = value.at(i2);
        }
        this.__canvasContext.putImageData(pixel, x, y);
      }
      setPixelAtChannel(x, y, channelIdx, value) {
        const pixel = this.getImageData(x, y, 1, 1);
        const data = pixel.data;
        data[channelIdx] = value;
        this.__canvasContext.putImageData(pixel, x, y);
      }
      get isTransparent() {
        return this.__hasTransparentPixels;
      }
      createInternalCanvasContext() {
        let canvas;
        if (this.__htmlCanvasElement != null) {
          canvas = this.__htmlCanvasElement;
        } else {
          canvas = document.createElement("canvas");
          canvas.width = this.width;
          canvas.height = this.height;
        }
        this.__htmlCanvasElement = canvas;
        this.__canvasContext = canvas.getContext("2d");
      }
      getTextureDataFloat(channels) {
        const pixel = this.getImageData(0, 0, this.width, this.height);
        const textureDataFloat = new TextureDataFloat(this.width, this.height, channels);
        const data = pixel.data;
        for (let i2 = 0; i2 < this.height; i2++) {
          for (let j = 0; j < this.width; j++) {
            for (let k = 0; k < channels; k++) {
              textureDataFloat.setPixelAtChannel(j, i2, k, data[i2 * this.width * 4 + j * 4 + k] / 255);
            }
          }
        }
        return textureDataFloat;
      }
    };
    __name(_AbstractTexture, "AbstractTexture");
    __publicField(_AbstractTexture, "InvalidTextureUid", -1);
    __publicField(_AbstractTexture, "__textureUidCount", _AbstractTexture.InvalidTextureUid);
    AbstractTexture = _AbstractTexture;
  }
});

// src/foundation/system/SystemState.ts
var currentProcessApproach, SystemState;
var init_SystemState = __esm({
  "src/foundation/system/SystemState.ts"() {
    "use strict";
    init_ProcessApproach();
    currentProcessApproach = ProcessApproach.None;
    SystemState = {
      currentProcessApproach,
      viewportAspectRatio: 0,
      webgpuRenderBundleMode: false
    };
  }
});

// src/foundation/textures/RenderTargetTexture.ts
var _RenderTargetTexture, RenderTargetTexture;
var init_RenderTargetTexture = __esm({
  "src/foundation/textures/RenderTargetTexture.ts"() {
    "use strict";
    init_AbstractTexture();
    init_PixelFormat();
    init_ComponentType();
    init_CGAPIResourceRepository();
    init_Vector4();
    init_SystemState();
    init_definitions();
    init_TextureFormat();
    _RenderTargetTexture = class _RenderTargetTexture extends AbstractTexture {
      constructor() {
        super();
        __publicField(this, "__fbo");
        __publicField(this, "__arrayLength", 0);
      }
      create({ width, height, mipLevelCount, format: internalFormat }) {
        this.__width = width;
        this.__height = height;
        this.__mipLevelCount = mipLevelCount != null ? mipLevelCount : Math.floor(Math.log2(Math.max(width, height))) + 1;
        const { format, type } = TextureFormat.getPixelFormatAndComponentTypeFromTextureFormat(internalFormat);
        this.__internalFormat = internalFormat;
        this.__format = format;
        this.__type = type;
        this.__createRenderTargetTexture();
      }
      createTextureArray({ width, height, level = 0, internalFormat = TextureFormat.RGB8, format = PixelFormat.RGBA, type = ComponentType.UnsignedByte, arrayLength }) {
        this.__width = width;
        this.__height = height;
        this.__level = level;
        this.__internalFormat = internalFormat;
        this.__format = format;
        this.__type = type;
        this.__arrayLength = arrayLength;
        this.__createRenderTargetTextureArray();
      }
      set _fbo(fbo) {
        this.__fbo = fbo;
      }
      get fbo() {
        return this.__fbo;
      }
      get arrayLength() {
        return this.__arrayLength;
      }
      __createRenderTargetTexture() {
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        const texture = cgApiResourceRepository.createRenderTargetTexture({
          width: this.__width,
          height: this.__height,
          mipLevelCount: this.__mipLevelCount,
          format: this.__internalFormat
        });
        this._textureResourceUid = texture;
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          this._textureViewResourceUid = cgApiResourceRepository.createTextureView2d(this._textureResourceUid);
          this._textureViewAsRenderTargetResourceUid = cgApiResourceRepository.createTextureViewAsRenderTarget(this._textureResourceUid);
        }
      }
      __createRenderTargetTextureArray() {
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        const texture = cgApiResourceRepository.createRenderTargetTextureArray({
          width: this.__width,
          height: this.__height,
          level: this.__level,
          internalFormat: this.__internalFormat,
          format: this.__format,
          type: this.__type,
          arrayLength: this.__arrayLength
        });
        this._textureResourceUid = texture;
      }
      resize(width, height) {
        this.destroy3DAPIResources();
        this.__width = width;
        this.__height = height;
        if (this.__arrayLength > 0) {
          this.__createRenderTargetTextureArray();
        } else {
          this.__createRenderTargetTexture();
        }
      }
      destroy3DAPIResources() {
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        cgApiResourceRepository.deleteTexture(this._textureResourceUid);
        this._textureResourceUid = CGAPIResourceRepository.InvalidCGAPIResourceUid;
        return true;
      }
      async getTexturePixelData() {
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        const data = cgApiResourceRepository.getTexturePixelData(this._textureResourceUid, this.__width, this.__height, this.__fbo.framebufferUID, this.__fbo.whichColorAttachment(this));
        return data;
      }
      async downloadTexturePixelData() {
        const data = await this.getTexturePixelData();
        const canvas = document.createElement("canvas");
        canvas.width = this.__width;
        canvas.height = this.__height;
        const ctx = canvas.getContext("2d");
        const imageData = new ImageData(new Uint8ClampedArray(data.buffer), this.__width, this.__height);
        ctx.putImageData(imageData, this.__width, this.__height);
        const dataUri = canvas.toDataURL("image/png");
        const a2 = document.createElement("a");
        const e3 = document.createEvent("MouseEvent");
        a2.href = dataUri;
        a2.download = "texture.png";
        e3.initEvent("click", true, true);
        a2.dispatchEvent(e3);
      }
      /**
      * Origin is left bottom
      *
      * @param x horizontal pixel position (0 is left)
      * @param y vertical pixel position (0 is bottom)
      * @param argByteArray Pixel Data as Uint8Array
      * @returns Pixel Value in Vector4
      */
      async getPixelValueAt(x, y, argByteArray) {
        let byteArray = argByteArray;
        if (!byteArray) {
          byteArray = await this.getTexturePixelData();
        }
        const color = Vector4.fromCopyArray([
          byteArray[(y * this.width + x) * 4 + 0],
          byteArray[(y * this.width + x) * 4 + 1],
          byteArray[(y * this.width + x) * 4 + 2],
          byteArray[(y * this.width + x) * 4 + 3]
        ]);
        return color;
      }
      generateMipmaps() {
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        cgApiResourceRepository.generateMipmaps2d(this._textureResourceUid, this.width, this.height);
      }
      blitToTexture2dFromTexture2dArray(targetTexture2D) {
        if (this.__arrayLength === 0) {
          return;
        }
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        webglResourceRepository.blitToTexture2dFromTexture2dArray(this._textureResourceUid, targetTexture2D.__fbo.cgApiResourceUid, targetTexture2D.width, targetTexture2D.height);
      }
      blitToTexture2dFromTexture2dArrayFake(targetTexture2D) {
        if (this.__arrayLength === 0) {
          return;
        }
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        webglResourceRepository.blitToTexture2dFromTexture2dArrayFake(this._textureResourceUid, targetTexture2D.__fbo.cgApiResourceUid, targetTexture2D.width, targetTexture2D.height);
      }
      blitToTexture2dFromTexture2dArray2(targetTexture2D) {
        if (this.__arrayLength === 0) {
          return;
        }
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        webglResourceRepository.blitToTexture2dFromTexture2dArray2(this._textureResourceUid, targetTexture2D._textureResourceUid, targetTexture2D.width / 2, targetTexture2D.height);
      }
      createCubeTextureViewAsRenderTarget(faceIdx, mipLevel) {
      }
    };
    __name(_RenderTargetTexture, "RenderTargetTexture");
    RenderTargetTexture = _RenderTargetTexture;
  }
});

// src/foundation/textures/Sampler.ts
var _Sampler, Sampler;
var init_Sampler = __esm({
  "src/foundation/textures/Sampler.ts"() {
    "use strict";
    init_definitions();
    init_CGAPIResourceRepository();
    _Sampler = class _Sampler {
      constructor(desc) {
        __publicField(this, "__minFilter");
        __publicField(this, "__magFilter");
        __publicField(this, "__wrapS");
        __publicField(this, "__wrapT");
        __publicField(this, "__wrapR");
        __publicField(this, "__anisotropy");
        __publicField(this, "__shadowCompareMode");
        __publicField(this, "__samplerResourceUid", -1);
        var _a40, _b, _c;
        this.__minFilter = desc.minFilter;
        this.__magFilter = desc.magFilter;
        this.__wrapS = desc.wrapS;
        this.__wrapT = desc.wrapT;
        this.__wrapR = (_a40 = desc.wrapR) != null ? _a40 : TextureParameter.Repeat;
        this.__anisotropy = (_b = desc.anisotropy) != null ? _b : true;
        this.__shadowCompareMode = (_c = desc.shadowCompareMode) != null ? _c : false;
      }
      create() {
        const webGLResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        this.__samplerResourceUid = webGLResourceRepository == null ? void 0 : webGLResourceRepository.createTextureSampler({
          minFilter: this.__minFilter,
          magFilter: this.__magFilter,
          wrapS: this.__wrapS,
          wrapT: this.__wrapT,
          wrapR: this.__wrapR,
          anisotropy: this.__anisotropy,
          shadowCompareMode: this.__shadowCompareMode
        });
      }
      get created() {
        return this.__samplerResourceUid !== -1;
      }
      get minFilter() {
        return this.__minFilter;
      }
      get magFilter() {
        return this.__magFilter;
      }
      get wrapS() {
        return this.__wrapS;
      }
      get wrapT() {
        return this.__wrapT;
      }
      get wrapR() {
        return this.__wrapR;
      }
      get _samplerResourceUid() {
        return this.__samplerResourceUid;
      }
    };
    __name(_Sampler, "Sampler");
    Sampler = _Sampler;
  }
});

// src/webgl/WebGLStereoUtil.ts
var VSMultiview, FSMultiview, _WebGLStereoUtil, WebGLStereoUtil;
var init_WebGLStereoUtil = __esm({
  "src/webgl/WebGLStereoUtil.ts"() {
    "use strict";
    init_Logger();
    VSMultiview = [
      "#version 300 es",
      "uniform vec2 u_offset;",
      "uniform vec2 u_scale;",
      "out mediump vec3 v_texcoord;",
      "void main() {",
      // offset of eye quad in -1..1 space
      "    const float eye_offset_x[12] = float[12] (",
      "        0.0, 0.0, 0.0, 0.0, 0.0, 0.0,",
      "        1.0, 1.0, 1.0, 1.0, 1.0, 1.0",
      "    );",
      //  xy - coords of the quad, normalized to 0..1
      //  xy  - UV of the source texture coordinate.
      //  z   - texture layer (eye) index - 0 or 1.
      "    const vec3 quad_positions[12] = vec3[12]",
      "    (",
      "        vec3(0.0, 0.0, 0.0),",
      "        vec3(1.0, 0.0, 0.0),",
      "        vec3(0.0, 1.0, 0.0),",
      "        vec3(0.0, 1.0, 0.0),",
      "        vec3(1.0, 0.0, 0.0),",
      "        vec3(1.0, 1.0, 0.0),",
      "        vec3(0.0, 0.0, 1.0),",
      "        vec3(1.0, 0.0, 1.0),",
      "        vec3(0.0, 1.0, 1.0),",
      "        vec3(0.0, 1.0, 1.0),",
      "        vec3(1.0, 0.0, 1.0),",
      "        vec3(1.0, 1.0, 1.0)",
      "    );",
      "    const vec2 pos_scale = vec2(0.5, 1.0);",
      "    vec2 eye_offset = vec2(eye_offset_x[gl_VertexID], 0.0);",
      "    gl_Position = vec4(((quad_positions[gl_VertexID].xy * u_scale + u_offset) * pos_scale * 2.0) - 1.0 + eye_offset, 0.0, 1.0);",
      "    v_texcoord = vec3(quad_positions[gl_VertexID].xy * u_scale + u_offset, quad_positions[gl_VertexID].z);",
      "}"
    ].join("\n");
    FSMultiview = [
      "#version 300 es",
      "uniform mediump sampler2DArray u_source_texture;",
      "in mediump vec3 v_texcoord;",
      "out mediump vec4 output_color;",
      "void main()",
      "{",
      "    output_color = texture(u_source_texture, v_texcoord);",
      "}"
    ].join("\n");
    _WebGLStereoUtil = class _WebGLStereoUtil {
      constructor(gl) {
        __publicField(this, "__gl");
        // private __vao: WebGLVertexArrayObject;
        __publicField(this, "__vertexShader");
        __publicField(this, "__fragmentShader");
        __publicField(this, "__program");
        __publicField(this, "__attrib");
        __publicField(this, "__uniform");
        this.__gl = gl;
        this.__program = gl.createProgram();
        this.__attachShaderSource(VSMultiview, gl.VERTEX_SHADER);
        this.__attachShaderSource(FSMultiview, gl.FRAGMENT_SHADER);
        this.__gl.linkProgram(this.__program);
        this.__bindAttribLocation({
          v_texcoord: 0
        });
        this.__getUniformLocations();
      }
      static getInstance(gl) {
        if (!this.__instance) {
          this.__instance = new _WebGLStereoUtil(gl);
        }
        return this.__instance;
      }
      __attachShaderSource(source, type) {
        const gl = this.__gl;
        let shader;
        switch (type) {
          case gl.VERTEX_SHADER:
            this.__vertexShader = gl.createShader(type);
            shader = this.__vertexShader;
            break;
          case gl.FRAGMENT_SHADER:
            this.__fragmentShader = gl.createShader(type);
            shader = this.__fragmentShader;
            break;
          default:
            Logger.error("Invalid Shader Type: " + type);
            return;
        }
        gl.attachShader(this.__program, shader);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
      }
      __bindAttribLocation(attribLocationMap) {
        const gl = this.__gl;
        if (attribLocationMap) {
          this.__attrib = {};
          for (const attribName in attribLocationMap) {
            gl.bindAttribLocation(this.__program, attribLocationMap[attribName], attribName);
            this.__attrib[attribName] = attribLocationMap[attribName];
          }
        }
      }
      __getUniformLocations() {
        const gl = this.__gl;
        if (this.__uniform == null) {
          this.__uniform = {};
          const uniformCount = gl.getProgramParameter(this.__program, gl.ACTIVE_UNIFORMS);
          let uniformName = "";
          for (let i2 = 0; i2 < uniformCount; i2++) {
            const uniformInfo = gl.getActiveUniform(this.__program, i2);
            uniformName = uniformInfo.name.replace("[0]", "");
            this.__uniform[uniformName] = gl.getUniformLocation(this.__program, uniformName);
          }
        }
      }
      blit(source_texture, source_rect_uv_x, source_rect_uv_y, source_rect_uv_width, source_rect_uv_height, dest_surface_width, dest_surface_height) {
        const gl = this.__gl;
        const program = this.__program;
        gl.activeTexture(gl.TEXTURE15);
        gl.bindTexture(gl.TEXTURE_2D_ARRAY, source_texture);
        gl.useProgram(program);
        const depthTestEnabled = gl.getParameter(gl.DEPTH_TEST);
        const depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
        gl.disable(gl.SCISSOR_TEST);
        if (depthTestEnabled) {
          gl.disable(gl.DEPTH_TEST);
        }
        gl.disable(gl.STENCIL_TEST);
        gl.colorMask(true, true, true, true);
        if (depthMask) {
          gl.depthMask(false);
        }
        const viewport = gl.getParameter(gl.VIEWPORT);
        gl.viewport(0, 0, dest_surface_width, dest_surface_height);
        gl.uniform2f(this.__uniform["u_scale"], source_rect_uv_width, source_rect_uv_height);
        gl.uniform2f(this.__uniform["u_offset"], source_rect_uv_x, source_rect_uv_y);
        gl.uniform1i(this.__uniform["u_source_texture"], 15);
        gl.drawArrays(gl.TRIANGLES, 0, 12);
        gl.__changedProgram = true;
        gl.viewport(viewport[0], viewport[1], viewport[2], viewport[3]);
        if (depthTestEnabled) {
          gl.enable(gl.DEPTH_TEST);
        }
        gl.depthMask(depthMask);
        gl.flush();
      }
      blitFake(source_texture, source_rect_uv_x, source_rect_uv_y, source_rect_uv_width, source_rect_uv_height, dest_surface_width, dest_surface_height) {
        const gl = this.__gl;
        const program = this.__program;
        gl.activeTexture(gl.TEXTURE15);
        gl.bindTexture(gl.TEXTURE_2D_ARRAY, source_texture);
        gl.useProgram(program);
        const viewport = gl.getParameter(gl.VIEWPORT);
        gl.viewport(0, 0, dest_surface_width, dest_surface_height);
        gl.uniform2f(this.__uniform["u_scale"], source_rect_uv_width, source_rect_uv_height);
        gl.uniform2f(this.__uniform["u_offset"], source_rect_uv_x, source_rect_uv_y);
        gl.uniform1i(this.__uniform["u_source_texture"], 15);
        gl.drawArrays(gl.TRIANGLES, 0, 12);
        gl.__changedProgram = true;
        gl.viewport(viewport[0], viewport[1], viewport[2], viewport[3]);
      }
      blit2(srcTexture, dstTexture, width, height) {
        const gl = this.__gl;
        const readFramebuffer = gl.createFramebuffer();
        const drawFramebuffer = gl.createFramebuffer();
        function blitTextureArrayLayer(layer, xOffset) {
          const tempTexture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, tempTexture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, readFramebuffer);
          gl.framebufferTextureLayer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, srcTexture, 0, layer);
          gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, drawFramebuffer);
          gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tempTexture, 0);
          gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
          gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tempTexture, 0);
          gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, dstTexture, 0);
          gl.blitFramebuffer(0, 0, width, height, xOffset, 0, xOffset + width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
        }
        __name(blitTextureArrayLayer, "blitTextureArrayLayer");
        blitTextureArrayLayer(0, 0);
        blitTextureArrayLayer(1, width);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
    };
    __name(_WebGLStereoUtil, "WebGLStereoUtil");
    __publicField(_WebGLStereoUtil, "__instance");
    WebGLStereoUtil = _WebGLStereoUtil;
  }
});

// vendor/hdrpng.js
var hdrpng_default;
var init_hdrpng = __esm({
  "vendor/hdrpng.js"() {
    "use strict";
    hdrpng_default = function(name, context, definition) {
      const HDRImage = definition();
      return HDRImage;
    }("HDRImage", void 0, function() {
      function HDRImage() {
        var res = document.createElement("canvas"), HDRsrc = "t", HDRexposure = 1, HDRgamma = 2.2, HDRdata = null, context, HDRD;
        res.__defineGetter__("exposure", function() {
          return HDRexposure;
        });
        res.__defineSetter__("exposure", function(val) {
          HDRexposure = val;
          if (HDRdata) {
            rgbeToLDR(HDRdata, HDRexposure, HDRgamma, HDRD.data);
            context.putImageData(HDRD, 0, 0);
          }
        });
        res.__defineGetter__("gamma", function() {
          return HDRgamma;
        });
        res.__defineSetter__("gamma", function(val) {
          HDRgamma = val;
          if (HDRdata) {
            rgbeToLDR(HDRdata, HDRexposure, HDRgamma, HDRD.data);
            context.putImageData(HDRD, 0, 0);
          }
        });
        res.__defineGetter__("dataFloat", function() {
          return rgbeToFloat(HDRdata);
        });
        res.__defineGetter__("dataRGBE", function() {
          return HDRdata;
        });
        res.toHDRBlob = function(cb, m2, q) {
          function createShader(gl2, source, type) {
            var shader = gl2.createShader(type);
            gl2.shaderSource(shader, source);
            gl2.compileShader(shader);
            return shader;
          }
          __name(createShader, "createShader");
          function createProgram(gl2, vertexShaderSource, fragmentShaderSource) {
            var program2 = gl2.createProgram(), vs, fs;
            gl2.attachShader(program2, vs = createShader(gl2, vertexShaderSource, gl2.VERTEX_SHADER));
            gl2.attachShader(program2, fs = createShader(gl2, fragmentShaderSource, gl2.FRAGMENT_SHADER));
            gl2.linkProgram(program2);
            gl2.deleteShader(vs);
            gl2.deleteShader(fs);
            return program2;
          }
          __name(createProgram, "createProgram");
          ;
          var ar = m2 && m2.match(/rgb9_e5/i) ? new Uint8Array(floatToRgb9_e5(rgbeToFloat(HDRdata)).buffer) : new Uint8Array(HDRdata.buffer);
          var vs2 = "precision highp float;\nattribute vec3 position;\nvarying vec2 tex;\nvoid main() { tex = position.xy/2.0+0.5; gl_Position = vec4(position, 1.0); }";
          var fs2 = "precision highp float;\nprecision highp sampler2D;\nuniform sampler2D tx;\nvarying vec2 tex;\nvoid main() { gl_FragColor = texture2D(tx,tex); }";
          var x = this.width, y = this.height;
          if (x * y * 4 < ar.byteLength) return console.error("not big enough.");
          var c2 = document.createElement("canvas");
          c2.width = x;
          c2.height = y;
          var gl = c2.getContext("webgl", {
            antialias: false,
            alpha: true,
            premultipliedAlpha: false,
            preserveDrawingBuffer: true
          });
          var texture = gl.createTexture();
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, x, y, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(ar.buffer));
          var program = createProgram(gl, vs2, fs2), uniformTexLocation = gl.getUniformLocation(program, "tx");
          var positions = new Float32Array([
            -1,
            -1,
            0,
            1,
            -1,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            -1,
            1,
            0,
            -1,
            -1,
            0
          ]), vertexPosBuffer = gl.createBuffer();
          gl.enableVertexAttribArray(0);
          gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
          gl.useProgram(program);
          gl.uniform1i(uniformTexLocation, 0);
          gl.drawArrays(gl.TRIANGLES, 0, 6);
          gl.deleteTexture(texture);
          gl.deleteProgram(program);
          if (cb) return c2.toBlob(cb);
        };
        res.__defineGetter__("src", function() {
          return HDRsrc;
        });
        res.__defineSetter__("src", function(val) {
          HDRsrc = val;
          context && context.clearRect(0, 0, this.width, this.height);
          if (val.match(/\.hdr$/i)) loadHDR(val, function(img, width, height) {
            HDRdata = img;
            this.width = this.style.width = width;
            this.height = this.style.height = height;
            context = this.getContext("2d");
            HDRD = context.getImageData(0, 0, width, height);
            rgbeToLDR(img, HDRexposure, HDRgamma, HDRD.data);
            context.putImageData(HDRD, 0, 0);
            this.onload && this.onload();
          }.bind(res));
          else if (val.match(/\.rgb9_e5\.png$/i)) {
            var i2 = new Image();
            i2.src = val;
            i2.onload = function() {
              var c2 = document.createElement("canvas"), x = this.width = this.style.width = c2.width = i2.width, y = this.height = this.style.height = c2.height = i2.height, gl = c2.getContext("webgl");
              var texture = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, i2);
              fb = gl.createFramebuffer();
              gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
              var res2 = new Uint8Array(x * y * 4);
              gl.readPixels(0, 0, x, y, gl.RGBA, gl.UNSIGNED_BYTE, res2);
              gl.deleteTexture(texture);
              gl.deleteFramebuffer(fb);
              this.dataRAW = new Uint32Array(res2.buffer);
              HDRdata = floatToRgbe(rgb9_e5ToFloat(this.dataRAW));
              context = this.getContext("2d");
              HDRD = context.getImageData(0, 0, x, y);
              rgbeToLDR(HDRdata, HDRexposure, HDRgamma, HDRD.data);
              context.putImageData(HDRD, 0, 0);
              this.onload && this.onload();
            }.bind(res);
          } else if (val.match(/\.hdr\.png$|\.rgbe\.png/i)) {
            var i2 = new Image();
            i2.src = val;
            i2.onload = function() {
              var c2 = document.createElement("canvas"), x = this.width = this.style.width = c2.width = i2.width, y = this.height = this.style.height = c2.height = i2.height, gl = c2.getContext("webgl");
              var texture = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, i2);
              fb = gl.createFramebuffer();
              gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
              var res2 = new Uint8Array(x * y * 4);
              gl.readPixels(0, 0, x, y, gl.RGBA, gl.UNSIGNED_BYTE, res2);
              gl.deleteTexture(texture);
              gl.deleteFramebuffer(fb);
              HDRdata = res2;
              context = this.getContext("2d");
              HDRD = context.getImageData(0, 0, x, y);
              rgbeToLDR(HDRdata, HDRexposure, HDRgamma, HDRD.data);
              context.putImageData(HDRD, 0, 0);
              this.onload && this.onload();
            }.bind(res);
          }
        });
        return res;
      }
      __name(HDRImage, "HDRImage");
      function m(a2, b) {
        for (var i2 in b) a2[i2] = b[i2];
        return a2;
      }
      __name(m, "m");
      ;
      function loadHDR(url, completion) {
        var req = m(new XMLHttpRequest(), {
          responseType: "arraybuffer"
        });
        req.onerror = completion.bind(req, false);
        req.onload = function() {
          if (this.status >= 400) return this.onerror();
          var header = "", pos = 0, d8 = new Uint8Array(this.response), format;
          while (!header.match(/\n\n[^\n]+\n/g)) header += String.fromCharCode(d8[pos++]);
          format = header.match(/FORMAT=(.*)$/m)[1];
          if (format != "32-bit_rle_rgbe") return console.warn("unknown format : " + format), this.onerror();
          var rez = header.split(/\n/).reverse()[1].split(" "), width = rez[3] * 1, height = rez[1] * 1;
          var img = new Uint8Array(width * height * 4), ipos = 0;
          for (var j = 0; j < height; j++) {
            var rgbe = d8.slice(pos, pos += 4), scanline = [];
            if (rgbe[0] != 2 || rgbe[1] != 2 || rgbe[2] & 128) {
              var len = width, rs = 0;
              pos -= 4;
              while (len > 0) {
                img.set(d8.slice(pos, pos += 4), ipos);
                if (img[ipos] == 1 && img[ipos + 1] == 1 && img[ipos + 2] == 1) {
                  for (img[ipos + 3] << rs; i2 > 0; i2--) {
                    img.set(img.slice(ipos - 4, ipos), ipos);
                    ipos += 4;
                    len--;
                  }
                  rs += 8;
                } else {
                  len--;
                  ipos += 4;
                  rs = 0;
                }
              }
            } else {
              if ((rgbe[2] << 8) + rgbe[3] != width) return console.warn("HDR line mismatch .."), this.onerror();
              for (var i2 = 0; i2 < 4; i2++) {
                var ptr = i2 * width, ptr_end = (i2 + 1) * width, buf, count;
                while (ptr < ptr_end) {
                  buf = d8.slice(pos, pos += 2);
                  if (buf[0] > 128) {
                    count = buf[0] - 128;
                    while (count-- > 0) scanline[ptr++] = buf[1];
                  } else {
                    count = buf[0] - 1;
                    scanline[ptr++] = buf[1];
                    while (count-- > 0) scanline[ptr++] = d8[pos++];
                  }
                }
              }
              for (var i2 = 0; i2 < width; i2++) {
                img[ipos++] = scanline[i2];
                img[ipos++] = scanline[i2 + width];
                img[ipos++] = scanline[i2 + 2 * width];
                img[ipos++] = scanline[i2 + 3 * width];
              }
            }
          }
          completion && completion(img, width, height);
        };
        req.open("GET", url, true);
        req.send(null);
        return req;
      }
      __name(loadHDR, "loadHDR");
      function floatToRgb9_e5(buffer, res) {
        var r2, g2, b, v, maxColor, ExpShared, denom, s2, l2 = buffer.byteLength / 12 | 0, res = res || new Uint32Array(l2);
        for (var i2 = 0; i2 < l2; i2++) {
          r2 = Math.min(32768, buffer[i2 * 3]);
          g2 = Math.min(32768, buffer[i2 * 3 + 1]);
          b = Math.min(32768, buffer[i2 * 3 + 2]);
          maxColor = Math.max(Math.max(r2, g2), b);
          ExpShared = Math.max(-16, Math.floor(Math.log2(maxColor))) + 16;
          denom = Math.pow(2, ExpShared - 24);
          if (Math.floor(maxColor / denom + 0.5) == 511) {
            denom *= 2;
            ExpShared += 1;
          }
          res[i2] = (Math.floor(r2 / denom + 0.5) << 23) + (Math.floor(g2 / denom + 0.5) << 14) + (Math.floor(b / denom + 0.5) << 5) + (ExpShared | 0);
        }
        return res;
      }
      __name(floatToRgb9_e5, "floatToRgb9_e5");
      function rgb9_e5ToFloat(buffer, res) {
        var v, s2, l2 = buffer.byteLength >> 2, res = res || new Float32Array(l2 * 3);
        for (var i2 = 0; i2 < l2; i2++) {
          v = buffer[i2];
          s2 = Math.pow(2, (v & 31) - 24);
          res[i2 * 3] = (v >>> 23) * s2;
          res[i2 * 3 + 1] = (v >>> 14 & 511) * s2;
          res[i2 * 3 + 2] = (v >>> 5 & 511) * s2;
        }
        return res;
      }
      __name(rgb9_e5ToFloat, "rgb9_e5ToFloat");
      function floatToRgbe(buffer, res) {
        var r2, g2, b, v, s2, l2 = buffer.byteLength / 12 | 0, res = res || new Uint8Array(l2 * 4);
        for (var i2 = 0; i2 < l2; i2++) {
          r2 = buffer[i2 * 3];
          g2 = buffer[i2 * 3 + 1];
          b = buffer[i2 * 3 + 2];
          v = Math.max(Math.max(r2, g2), b);
          e = Math.ceil(Math.log2(v));
          s2 = Math.pow(2, e - 8);
          res[i2 * 4] = r2 / s2 | 0;
          res[i2 * 4 + 1] = g2 / s2 | 0;
          res[i2 * 4 + 2] = b / s2 | 0;
          res[i2 * 4 + 3] = e + 128;
        }
        return res;
      }
      __name(floatToRgbe, "floatToRgbe");
      function rgbeToFloat(buffer, res) {
        var s2, l2 = buffer.byteLength >> 2, res = res || new Float32Array(l2 * 3);
        for (var i2 = 0; i2 < l2; i2++) {
          s2 = Math.pow(2, buffer[i2 * 4 + 3] - (128 + 8));
          res[i2 * 3] = buffer[i2 * 4] * s2;
          res[i2 * 3 + 1] = buffer[i2 * 4 + 1] * s2;
          res[i2 * 3 + 2] = buffer[i2 * 4 + 2] * s2;
        }
        return res;
      }
      __name(rgbeToFloat, "rgbeToFloat");
      function rgbeToLDR(buffer, exposure, gamma, res) {
        exposure = Math.pow(2, exposure === void 0 ? 1 : exposure) / 2;
        if (gamma === void 0) gamma = 2.2;
        var one_over_gamma = 1 / gamma, s2, l2 = buffer.byteLength >> 2, res = res || new Uint8ClampedArray(l2 * 4);
        for (var i2 = 0; i2 < l2; i2++) {
          s2 = exposure * Math.pow(2, buffer[i2 * 4 + 3] - (128 + 8));
          res[i2 * 4] = 255 * Math.pow(buffer[i2 * 4] * s2, one_over_gamma);
          res[i2 * 4 + 1] = 255 * Math.pow(buffer[i2 * 4 + 1] * s2, one_over_gamma);
          res[i2 * 4 + 2] = 255 * Math.pow(buffer[i2 * 4 + 2] * s2, one_over_gamma);
          res[i2 * 4 + 3] = 255;
        }
        return res;
      }
      __name(rgbeToLDR, "rgbeToLDR");
      function floatToLDR(buffer, exposure, gamma, res) {
        exposure = Math.pow(2, exposure === void 0 ? 1 : exposure) / 2;
        if (gamma === void 0) gamma = 2.2;
        var one_over_gamma = 1 / gamma, s2, l2 = buffer.byteLength / 12 | 0, res = res || new Uint8ClampedArray(l2 * 4);
        for (var i2 = 0; i2 < l2; i2++) {
          res[i2 * 4] = 255 * Math.pow(buffer[i2 * 3] * exposure, one_over_gamma);
          res[i2 * 4 + 1] = 255 * Math.pow(buffer[i2 * 3 + 1] * exposure, one_over_gamma);
          res[i2 * 4 + 2] = 255 * Math.pow(buffer[i2 * 3 + 2] * exposure, one_over_gamma);
          res[i2 * 4 + 3] = 255;
        }
        return res;
      }
      __name(floatToLDR, "floatToLDR");
      HDRImage.floatToRgbe = floatToRgbe;
      HDRImage.rgbeToFloat = rgbeToFloat;
      HDRImage.floatToRgb9_e5 = floatToRgb9_e5;
      HDRImage.rgb9_e5ToFloat = rgb9_e5ToFloat;
      HDRImage.rgbeToLDR = rgbeToLDR;
      HDRImage.floatToLDR = floatToLDR;
      return HDRImage;
    });
  }
});

// src/webgl/WebGLResourceRepository.ts
var _WebGLResourceRepository, WebGLResourceRepository;
var init_WebGLResourceRepository = __esm({
  "src/webgl/WebGLResourceRepository.ts"() {
    "use strict";
    init_CGAPIResourceRepository();
    init_VertexAttribute();
    init_TextureParameter();
    init_PixelFormat();
    init_CompositionType();
    init_ComponentType();
    init_WebGLContextWrapper();
    init_RenderTargetTexture();
    init_HdriFormat();
    init_Vector4();
    init_RenderBufferTarget();
    init_MiscUtil();
    init_DataUtil();
    init_BasisCompressionType();
    init_WebGLExtension();
    init_Is();
    init_getRenderingStrategy();
    init_Config();
    init_WebGLConstants();
    init_Sampler();
    init_SystemState();
    init_WebGLStereoUtil();
    init_ProcessApproach();
    init_TextureFormat();
    init_Logger();
    init_hdrpng();
    _WebGLResourceRepository = class _WebGLResourceRepository extends CGAPIResourceRepository {
      constructor() {
        super();
        __publicField(this, "__webglContexts", /* @__PURE__ */ new Map());
        __publicField(this, "__glw");
        __publicField(this, "__resourceCounter", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__webglResources", /* @__PURE__ */ new Map());
        __publicField(this, "__samplerClampToEdgeLinearUid", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__samplerClampToEdgeNearestUid", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__samplerRepeatNearestUid", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__samplerRepeatLinearUid", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__samplerShadowUid", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__samplerRepeatTriLinearUid", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__samplerRepeatAnisotropyLinearUid", CGAPIResourceRepository.InvalidCGAPIResourceUid);
      }
      static getInstance() {
        if (!this.__instance) {
          this.__instance = new _WebGLResourceRepository();
        }
        return this.__instance;
      }
      addWebGLContext(gl, canvas, asCurrent) {
        const glw = new WebGLContextWrapper(gl, canvas);
        this.__webglContexts.set("default", glw);
        if (asCurrent) {
          this.__glw = glw;
        }
      }
      generateWebGLContext(canvas, asCurrent, webglOption) {
        const gl = canvas.getContext("webgl2", webglOption);
        this.addWebGLContext(gl, canvas, asCurrent);
        if (MiscUtil.isSafari()) {
          Config.isUboEnabled = false;
        }
        return gl;
      }
      get currentWebGLContextWrapper() {
        return this.__glw;
      }
      getResourceNumber() {
        return ++this.__resourceCounter;
      }
      __registerResource(obj) {
        const handle = this.getResourceNumber();
        obj._resourceUid = handle;
        this.__webglResources.set(handle, obj);
        return handle;
      }
      getWebGLResource(WebGLResourceHandle) {
        const result = this.__webglResources.get(WebGLResourceHandle);
        return result != null ? result : null;
      }
      createIndexBuffer(accessor) {
        const gl = this.__glw.getRawContext();
        if (gl == null) {
          throw new Error("No WebGLRenderingContext set as Default.");
        }
        this.__glw.bindVertexArray(null);
        const ibo = gl.createBuffer();
        const resourceHandle = this.__registerResource(ibo);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, accessor.getTypedArray(), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        return resourceHandle;
      }
      updateIndexBuffer(accessor, resourceHandle) {
        const glw = this.__glw;
        const gl = glw == null ? void 0 : glw.getRawContext();
        if (Is.not.exist(gl)) {
          throw new Error("No WebGLRenderingContext set as Default.");
        }
        const ibo = this.__webglResources.get(resourceHandle);
        if (Is.not.exist(ibo)) {
          throw new Error("Not found IBO.");
        }
        glw.bindVertexArray(null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, accessor.getTypedArray());
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      }
      createVertexBuffer(accessor) {
        const gl = this.__glw.getRawContext();
        if (gl == null) {
          throw new Error("No WebGLRenderingContext set as Default.");
        }
        this.__glw.bindVertexArray(null);
        const vbo = gl.createBuffer();
        const resourceHandle = this.__registerResource(vbo);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, accessor.getUint8Array(), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return resourceHandle;
      }
      createVertexBufferFromTypedArray(typedArray) {
        const gl = this.__glw.getRawContext();
        if (gl == null) {
          throw new Error("No WebGLRenderingContext set as Default.");
        }
        this.__glw.bindVertexArray(null);
        const vbo = gl.createBuffer();
        const resourceHandle = this.__registerResource(vbo);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, typedArray, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return resourceHandle;
      }
      updateVertexBuffer(accessor, resourceHandle) {
        const glw = this.__glw;
        const gl = glw == null ? void 0 : glw.getRawContext();
        if (!Is.exist(gl)) {
          throw new Error("No WebGLRenderingContext set as Default.");
        }
        const vbo = this.__webglResources.get(resourceHandle);
        if (!Is.exist(vbo)) {
          throw new Error("Not found VBO.");
        }
        glw.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, accessor.bufferView.getUint8Array());
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }
      createVertexArray() {
        const gl = this.__glw;
        if (gl == null) {
          throw new Error("No WebGLRenderingContext set as Default.");
        }
        const vao = this.__glw.createVertexArray();
        if (Is.not.exist(vao)) {
          return void 0;
        }
        const resourceHandle = this.__registerResource(vao);
        return resourceHandle;
      }
      /**
      * bind the Texture2D
      * @param textureSlotIndex
      * @param textureUid
      */
      bindTexture2D(textureSlotIndex, textureUid) {
        const texture = this.getWebGLResource(textureUid);
        this.__glw.bindTexture2D(textureSlotIndex, texture);
      }
      /**
      * bind the Sampler
      * @param textureSlotIndex
      * @param samplerUid
      */
      bindTextureSampler(textureSlotIndex, samplerUid) {
        if (samplerUid === -1) {
          this.__glw.bindTextureSampler(textureSlotIndex, null);
        } else {
          const sampler = this.getWebGLResource(samplerUid);
          this.__glw.bindTextureSampler(textureSlotIndex, sampler);
        }
      }
      /**
      * bind the TextureCube
      * @param textureSlotIndex
      * @param textureUid
      */
      bindTextureCube(textureSlotIndex, textureUid) {
        const texture = this.getWebGLResource(textureUid);
        this.__glw.bindTextureCube(textureSlotIndex, texture);
      }
      /**
      * create a VertexBuffer and IndexBuffer
      * @param primitive
      * @returns
      */
      createVertexBufferAndIndexBuffer(primitive) {
        let iboHandle;
        if (primitive.hasIndices()) {
          iboHandle = this.createIndexBuffer(primitive.indicesAccessor);
        }
        const attributesFlags = [];
        for (let i2 = 0; i2 < VertexAttribute.AttributeTypeNumber; i2++) {
          attributesFlags[i2] = false;
        }
        const vboHandles = [];
        primitive.attributeAccessors.forEach((accessor, i2) => {
          const vboHandle = this.createVertexBuffer(accessor);
          const slotIdx = VertexAttribute.toAttributeSlotFromJoinedString(primitive.attributeSemantics[i2]);
          attributesFlags[slotIdx] = true;
          vboHandles.push(vboHandle);
        });
        return {
          vaoHandle: -1,
          iboHandle,
          vboHandles,
          attributesFlags,
          setComplete: false
        };
      }
      /**
      * update the VertexBuffer and IndexBuffer
      * @param primitive
      * @param vertexHandles
      */
      updateVertexBufferAndIndexBuffer(primitive, vertexHandles) {
        if (vertexHandles.iboHandle) {
          this.updateIndexBuffer(primitive.indicesAccessor, vertexHandles.iboHandle);
        }
        const attributeAccessors = primitive.attributeAccessors;
        for (let i2 = 0; i2 < attributeAccessors.length; i2++) {
          this.updateVertexBuffer(attributeAccessors[i2], vertexHandles.vboHandles[i2]);
        }
      }
      /**
      * create a shader program
      * @returns a object which has shader modules
      */
      createShaderProgram({ material, primitive, vertexShaderStr, fragmentShaderStr, attributeNames, attributeSemantics, onError }) {
        const gl = this.__glw.getRawContext();
        if (gl == null) {
          throw new Error("No WebGLRenderingContext set as Default.");
        }
        const isDebugMode = Config.cgApiDebugConsoleOutput;
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderStr);
        gl.compileShader(vertexShader);
        if (isDebugMode) {
          const result = this.__checkShaderCompileStatus(material.materialTypeName, vertexShader, vertexShaderStr, onError);
          if (!result) {
            return CGAPIResourceRepository.InvalidCGAPIResourceUid;
          }
        }
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderStr);
        gl.compileShader(fragmentShader);
        if (isDebugMode) {
          this.__checkShaderCompileStatus(material.materialTypeName, fragmentShader, fragmentShaderStr, onError);
        }
        const shaderProgram = gl.createProgram();
        shaderProgram._gl = gl;
        shaderProgram._materialTypeName = material.materialTypeName;
        shaderProgram._vertexShaderStr = vertexShaderStr;
        shaderProgram._fragmentShaderStr = fragmentShaderStr;
        shaderProgram._shaderSemanticsInfoMap = /* @__PURE__ */ new Map();
        shaderProgram._material = new WeakRef(material);
        shaderProgram._primitive = new WeakRef(primitive);
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        attributeNames.forEach((attributeName, i2) => {
          gl.bindAttribLocation(shaderProgram, attributeSemantics[i2].getAttributeSlot(), attributeName);
        });
        gl.linkProgram(shaderProgram);
        if (isDebugMode) {
          const result = this.__checkShaderProgramLinkStatus(material.materialTypeName, shaderProgram, vertexShaderStr, fragmentShaderStr);
          if (!result) {
            return CGAPIResourceRepository.InvalidCGAPIResourceUid;
          }
        }
        shaderProgram.__SPECTOR_rebuildProgram = this.rebuildProgramBySpector.bind(shaderProgram);
        const resourceHandle = this.__registerResource(shaderProgram);
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        return resourceHandle;
      }
      __checkShaderCompileStatus(materialTypeName, shader, shaderText, onError) {
        const glw = this.__glw;
        const gl = glw.getRawContext();
        if (Is.false(gl.getShaderParameter(shader, gl.COMPILE_STATUS)) && Is.false(gl.isContextLost())) {
          Logger.info("MaterialTypeName: " + materialTypeName);
          const lineNumberedShaderText = MiscUtil.addLineNumberToCode(shaderText);
          Logger.info(lineNumberedShaderText);
          const log = gl.getShaderInfoLog(shader);
          if (onError === void 0) {
            Logger.error("An error occurred compiling the shaders:" + log);
            return false;
          } else {
            onError(log);
            return false;
          }
        }
        return true;
      }
      __checkShaderProgramLinkStatus(materialTypeName, shaderProgram, vertexShaderText, fragmentShaderText) {
        const glw = this.__glw;
        const gl = glw.getRawContext();
        if (Is.false(gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) && Is.false(gl.isContextLost())) {
          Logger.info("MaterialTypeName: " + materialTypeName);
          Logger.info(MiscUtil.addLineNumberToCode("Vertex Shader:"));
          Logger.info(MiscUtil.addLineNumberToCode(vertexShaderText));
          Logger.info(MiscUtil.addLineNumberToCode("Fragment Shader:"));
          Logger.info(MiscUtil.addLineNumberToCode(fragmentShaderText));
          const log = gl.getProgramInfoLog(shaderProgram);
          Logger.error("Unable to initialize the shader program: " + log);
          return false;
        }
        return true;
      }
      /**
      * setup the uniform locations
      * @param shaderProgramUid
      * @param infoArray
      * @param isUniformOnlyMode
      * @returns
      */
      setupUniformLocations(shaderProgramUid, infoArray, isUniformOnlyMode) {
        const glw = this.__glw;
        const gl = glw.getRawContext();
        const shaderProgram = this.getWebGLResource(shaderProgramUid);
        const infoArrayLen = infoArray.length;
        for (let i2 = 0; i2 < infoArrayLen; i2++) {
          const info = infoArray[i2];
          shaderProgram._shaderSemanticsInfoMap.set(info.semantic, info);
        }
        for (let i2 = 0; i2 < infoArrayLen; i2++) {
          const info = infoArray[i2];
          const isUniformExist = isUniformOnlyMode || info.needUniformInDataTextureMode || CompositionType.isTexture(info.compositionType);
          if (isUniformExist) {
            const semanticSingular = info.semantic;
            const identifier = semanticSingular;
            const shaderVarName = "u_" + info.semantic;
            const location = gl.getUniformLocation(shaderProgram, shaderVarName);
            const _shaderProgram = shaderProgram;
            _shaderProgram[identifier] = location;
            if (location == null && Config.cgApiDebugConsoleOutput) {
              Logger.info(`Can not get the uniform location: ${shaderVarName}. The uniform may be unused by other code so implicitly removed.`);
            }
          }
        }
        return shaderProgram;
      }
      setupBasicUniformLocations(shaderProgramUid) {
        const shaderProgram = this.getWebGLResource(shaderProgramUid);
        const gl = this.currentWebGLContextWrapper.getRawContext();
        shaderProgram.dataTexture = gl.getUniformLocation(shaderProgram, "u_dataTexture");
        shaderProgram.isMainVr = gl.getUniformLocation(shaderProgram, "u_isMainVr");
        shaderProgram.currentComponentSIDs = gl.getUniformLocation(shaderProgram, "u_currentComponentSIDs");
      }
      setUniform1iForTexture(shaderProgram_, semanticStr, value) {
        const shaderProgram = shaderProgram_;
        const info = shaderProgram._shaderSemanticsInfoMap.get(semanticStr);
        if (info == null) {
          return;
        }
        const gl = this.__glw.getRawContext();
        const loc = shaderProgram[semanticStr];
        gl.uniform1i(loc, value[0]);
        this.bindTexture(info, value);
      }
      /**
      * set an uniform value
      */
      setUniformValue(shaderProgram_, semanticStr, firstTime, value) {
        const shaderProgram = shaderProgram_;
        const info = shaderProgram._shaderSemanticsInfoMap.get(semanticStr);
        if (info == null) {
          return false;
        }
        let setAsMatrix = false;
        let componentNumber = 0;
        if (info.compositionType === CompositionType.Mat3) {
          setAsMatrix = true;
          componentNumber = 3;
        } else if (info.compositionType === CompositionType.Mat4) {
          setAsMatrix = true;
          componentNumber = 4;
        } else {
          componentNumber = info.compositionType.getNumberOfComponents();
        }
        const isCompositionTypeArray = info.compositionType === CompositionType.ScalarArray || info.compositionType === CompositionType.Vec4Array || info.compositionType === CompositionType.Vec3Array || info.compositionType === CompositionType.Vec2Array;
        const isCompositionTypeTexture = CompositionType.isTexture(info.compositionType);
        const key = semanticStr;
        let updated = false;
        if (isCompositionTypeTexture) {
          updated = this.setUniformValueInner(shaderProgram_, key, info, setAsMatrix, componentNumber, false, {
            x: value[0]
          });
          this.bindTexture(info, value);
        } else if (isCompositionTypeArray) {
          if (value._v == null) {
            updated = this.setUniformValueInner(shaderProgram_, key, info, setAsMatrix, componentNumber, true, {
              x: value
            });
          } else {
            updated = this.setUniformValueInner(shaderProgram_, key, info, setAsMatrix, componentNumber, true, {
              x: value._v
            });
          }
        } else if (info.compositionType === CompositionType.Scalar) {
          if (value._v == null) {
            updated = this.setUniformValueInner(shaderProgram_, key, info, setAsMatrix, componentNumber, false, {
              x: value
            });
          } else {
            updated = this.setUniformValueInner(shaderProgram_, key, info, setAsMatrix, componentNumber, true, {
              x: value._v
            });
          }
        } else {
          if (value._v == null) {
            updated = this.setUniformValueInner(shaderProgram_, key, info, setAsMatrix, componentNumber, false, value);
          } else {
            updated = this.setUniformValueInner(shaderProgram_, key, info, setAsMatrix, componentNumber, true, {
              x: value._v
            });
          }
        }
        return updated;
      }
      /**
      * bind the texture
      * @param info
      * @param value
      */
      bindTexture(info, value) {
        var _a40, _b;
        if (info.compositionType === CompositionType.Texture2D || info.compositionType === CompositionType.Texture2DShadow) {
          this.bindTexture2D(value[0], value[1]._textureResourceUid);
          if (value[2] != null) {
            this.bindTextureSampler(value[0], value[2]._samplerResourceUid);
          } else {
            if (info.compositionType === CompositionType.Texture2D) {
              const samplerUid = this.createOrGetTextureSamplerClampToEdgeLinear();
              this.bindTextureSampler(value[0], samplerUid);
            } else if (info.compositionType === CompositionType.Texture2DShadow) {
              const samplerUid = this.createOrGetTextureSamplerShadow();
              this.bindTextureSampler(value[0], samplerUid);
            }
          }
        } else if (info.compositionType === CompositionType.TextureCube) {
          this.bindTextureCube(value[0], value[1]._textureResourceUid);
          if (value[2] != null) {
            this.bindTextureSampler(value[0], value[2]._samplerResourceUid);
          } else {
            const textureCube = value[1];
            this.bindTextureSampler(value[0], (_b = (_a40 = textureCube._recommendedTextureSampler) == null ? void 0 : _a40._samplerResourceUid) != null ? _b : -1);
          }
        }
      }
      /**
      * set the uniform value
      * @param shaderProgram
      * @param semanticStr
      * @param info
      * @param isMatrix
      * @param componentNumber
      * @param isVector
      * @param param6
      * @param index
      * @returns
      */
      setUniformValueInner(shaderProgram, semanticStr, info, isMatrix, componentNumber, isVector, { x, y, z, w }) {
        const identifier = semanticStr;
        const loc = shaderProgram[identifier];
        if (loc == null) {
          return false;
        }
        const uLocation = loc;
        const gl = this.__glw.getRawContext();
        if (isMatrix) {
          if (componentNumber === 4) {
            gl.uniformMatrix4fv(uLocation, false, x);
          } else {
            gl.uniformMatrix3fv(uLocation, false, x);
          }
        } else if (isVector) {
          const componentType = info.componentType === ComponentType.Int || info.componentType === ComponentType.Short || info.componentType === ComponentType.Byte;
          if (componentNumber === 1) {
            if (componentType) {
              gl.uniform1iv(uLocation, x);
            } else {
              gl.uniform1fv(uLocation, x);
            }
          } else if (componentNumber === 2) {
            if (componentType) {
              gl.uniform2iv(uLocation, x);
            } else {
              gl.uniform2fv(uLocation, x);
            }
          } else if (componentNumber === 3) {
            if (componentType) {
              gl.uniform3iv(uLocation, x);
            } else {
              gl.uniform3fv(uLocation, x);
            }
          } else if (componentNumber === 4) {
            if (componentType) {
              gl.uniform4iv(uLocation, x);
            } else {
              gl.uniform4fv(uLocation, x);
            }
          }
        } else {
          const componentType = info.componentType === ComponentType.Int || info.componentType === ComponentType.Short || info.componentType === ComponentType.Byte;
          if (componentNumber === 1) {
            if (componentType) {
              gl.uniform1i(uLocation, x);
            } else {
              gl.uniform1f(uLocation, x);
            }
          } else if (componentNumber === 2) {
            if (componentType) {
              gl.uniform2i(uLocation, x, y);
            } else {
              gl.uniform2f(uLocation, x, y);
            }
          } else if (componentNumber === 3) {
            if (componentType) {
              gl.uniform3i(uLocation, x, y, z);
            } else {
              gl.uniform3f(uLocation, x, y, z);
            }
          } else if (componentNumber === 4) {
            if (componentType) {
              gl.uniform4i(uLocation, x, y, z, w);
            } else {
              gl.uniform4f(uLocation, x, y, z, w);
            }
          }
        }
        return true;
      }
      /**
      * set the VertexData to the Pipeline
      */
      setVertexDataToPipeline({ vaoHandle, iboHandle, vboHandles }, primitive, instanceIDBufferUid = CGAPIResourceRepository.InvalidCGAPIResourceUid) {
        const gl = this.__glw.getRawContext();
        const vao = this.getWebGLResource(vaoHandle);
        this.__glw.bindVertexArray(vao);
        if (iboHandle != null) {
          const ibo = this.getWebGLResource(iboHandle);
          if (ibo != null) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
          } else {
            throw new Error("Nothing Element Array Buffer!");
          }
        }
        vboHandles.forEach((vboHandle, i2) => {
          const vbo = this.getWebGLResource(vboHandle);
          if (vbo != null) {
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
          } else {
            throw new Error("Nothing Element Array Buffer at index " + i2);
          }
          gl.enableVertexAttribArray(VertexAttribute.toAttributeSlotFromJoinedString(primitive.attributeSemantics[i2]));
          gl.vertexAttribPointer(VertexAttribute.toAttributeSlotFromJoinedString(primitive.attributeSemantics[i2]), primitive.attributeCompositionTypes[i2].getNumberOfComponents(), primitive.attributeComponentTypes[i2].index, primitive.attributeAccessors[i2].normalized, primitive.attributeAccessors[i2].byteStride, 0);
        });
        if (instanceIDBufferUid !== CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          const instanceIDBuffer = this.getWebGLResource(instanceIDBufferUid);
          if (instanceIDBuffer != null) {
            gl.bindBuffer(gl.ARRAY_BUFFER, instanceIDBuffer);
          } else {
            throw new Error("Nothing Element Array Buffer at index");
          }
          gl.enableVertexAttribArray(VertexAttribute.Instance.getAttributeSlot());
          gl.vertexAttribPointer(VertexAttribute.Instance.getAttributeSlot(), CompositionType.Vec4.getNumberOfComponents(), ComponentType.Float.index, false, 0, 0);
          this.__glw.vertexAttribDivisor(VertexAttribute.Instance.getAttributeSlot(), 1);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        this.__glw.bindVertexArray(null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      }
      /**
      * create a TexStorage2D
      * @param data
      * @param param1
      * @returns
      */
      createTexStorage2D({ levels, internalFormat, width, height }) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const texture = gl.createTexture();
        this.__glw.bindTexture2D(15, texture);
        gl.texStorage2D(GL_TEXTURE_2D, levels, internalFormat.index, width, height);
        const resourceHandle = this.__registerResource(texture);
        this.__glw.unbindTexture2D(15);
        return resourceHandle;
      }
      createTextureSampler({ magFilter, minFilter, wrapS, wrapT, wrapR, anisotropy, isPremultipliedAlpha, shadowCompareMode }) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const sampler = gl.createSampler();
        const resourceHandle = this.__registerResource(sampler);
        gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, minFilter.index);
        gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, magFilter.index);
        gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, wrapS.index);
        gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, wrapT.index);
        gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_R, wrapR.index);
        if (shadowCompareMode) {
          gl.samplerParameteri(sampler, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
          gl.samplerParameteri(sampler, gl.TEXTURE_COMPARE_FUNC, gl.LESS);
        }
        if (anisotropy) {
          if (this.__glw.webgl2ExtTFA) {
            gl.samplerParameteri(sampler, this.__glw.webgl2ExtTFA.TEXTURE_MAX_ANISOTROPY_EXT, 4);
          }
        }
        return resourceHandle;
      }
      createOrGetTextureSamplerClampToEdgeLinear() {
        if (this.__samplerClampToEdgeLinearUid === CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          const gl = this.__glw.getRawContextAsWebGL2();
          const sampler = gl.createSampler();
          const resourceHandle = this.__registerResource(sampler);
          this.__samplerClampToEdgeLinearUid = resourceHandle;
          gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
        }
        return this.__samplerClampToEdgeLinearUid;
      }
      createOrGetTextureSamplerClampToEdgeNearest() {
        if (this.__samplerClampToEdgeNearestUid === CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          const gl = this.__glw.getRawContextAsWebGL2();
          const sampler = gl.createSampler();
          const resourceHandle = this.__registerResource(sampler);
          this.__samplerClampToEdgeNearestUid = resourceHandle;
          gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
        }
        return this.__samplerClampToEdgeNearestUid;
      }
      createOrGetTextureSamplerRepeatNearest() {
        if (this.__samplerRepeatNearestUid === CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          const gl = this.__glw.getRawContextAsWebGL2();
          const sampler = gl.createSampler();
          const resourceHandle = this.__registerResource(sampler);
          this.__samplerRepeatNearestUid = resourceHandle;
          gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, gl.REPEAT);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, gl.REPEAT);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_R, gl.REPEAT);
        }
        return this.__samplerRepeatNearestUid;
      }
      createOrGetTextureSamplerRepeatLinear() {
        if (this.__samplerRepeatLinearUid === CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          const gl = this.__glw.getRawContextAsWebGL2();
          const sampler = gl.createSampler();
          const resourceHandle = this.__registerResource(sampler);
          this.__samplerRepeatLinearUid = resourceHandle;
          gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, gl.REPEAT);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, gl.REPEAT);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_R, gl.REPEAT);
        }
        return this.__samplerRepeatLinearUid;
      }
      createOrGetTextureSamplerRepeatTriLinear() {
        if (this.__samplerRepeatTriLinearUid === CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          const gl = this.__glw.getRawContextAsWebGL2();
          const sampler = gl.createSampler();
          const resourceHandle = this.__registerResource(sampler);
          this.__samplerRepeatTriLinearUid = resourceHandle;
          gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
          gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, gl.REPEAT);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, gl.REPEAT);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_R, gl.REPEAT);
        }
        return this.__samplerRepeatTriLinearUid;
      }
      createOrGetTextureSamplerShadow() {
        if (this.__samplerShadowUid === CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          const gl = this.__glw.getRawContextAsWebGL2();
          const sampler = gl.createSampler();
          const resourceHandle = this.__registerResource(sampler);
          this.__samplerShadowUid = resourceHandle;
          gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.samplerParameteri(sampler, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
          gl.samplerParameteri(sampler, gl.TEXTURE_COMPARE_FUNC, gl.LESS);
        }
        return this.__samplerShadowUid;
      }
      createOrGetTextureSamplerRepeatAnisotropyLinear() {
        if (this.__samplerRepeatAnisotropyLinearUid === CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          const gl = this.__glw.getRawContextAsWebGL2();
          const sampler = gl.createSampler();
          const resourceHandle = this.__registerResource(sampler);
          this.__samplerRepeatAnisotropyLinearUid = resourceHandle;
          gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
          gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, gl.REPEAT);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, gl.REPEAT);
          gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_R, gl.REPEAT);
          gl.samplerParameteri(sampler, this.__glw.webgl2ExtTFA.TEXTURE_MAX_ANISOTROPY_EXT, 4);
        }
        return this.__samplerRepeatAnisotropyLinearUid;
      }
      /**
      * create a Texture
      * @param imageData
      * @param param1
      * @returns
      */
      createTextureFromImageBitmapData(imageData, { level, internalFormat, width, height, border, format, type, generateMipmap }) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const texture = gl.createTexture();
        const textureHandle = this.__registerResource(texture);
        this.__glw.bindTexture2D(15, texture);
        const levels = Math.floor(Math.log2(Math.max(width, height))) + 1;
        gl.texStorage2D(GL_TEXTURE_2D, levels, internalFormat.index, width, height);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, format.index, type.index, imageData);
        this.__createTextureInner(gl, width, height, generateMipmap);
        return textureHandle;
      }
      __createTextureInner(gl, width, height, generateMipmap) {
        gl.generateMipmap(gl.TEXTURE_2D);
        this.__glw.unbindTexture2D(15);
      }
      /**
      * create a Texture
      * @param imageData
      * @param param1
      * @returns
      */
      async createTextureFromHTMLImageElement(imageData, { level, internalFormat, width, height, border, format, type, generateMipmap }) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const texture = gl.createTexture();
        const resourceHandle = this.__registerResource(texture);
        this.__glw.bindTexture2D(15, texture);
        const levels = generateMipmap ? Math.max(Math.log2(width), Math.log2(height)) : 1;
        gl.texStorage2D(GL_TEXTURE_2D, levels, internalFormat.index, width, height);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, format.index, type.index, imageData);
        this.__createTextureInner(gl, width, height, generateMipmap);
        return resourceHandle;
      }
      /**
      * allocate a Texture
      * @param format - the internal format of the texture
      * @param width - the width of the texture
      * @param height - the height of the texture
      * @param mipmapCount - the number of mipmap levels
      * @returns the handle of the texture
      */
      allocateTexture({ format, width, height, mipLevelCount }) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const texture = gl.createTexture();
        const resourceHandle = this.__registerResource(texture);
        this.__glw.bindTexture2D(15, texture);
        gl.texStorage2D(GL_TEXTURE_2D, mipLevelCount, format.index, width, height);
        this.__glw.unbindTexture2D(15);
        return resourceHandle;
      }
      /**
      * Load an image to a specific mip level of a texture
      * @param mipLevel - the mip level to load the image to
      * @param textureUid - the handle of the texture
      * @param format - the format of the image
      * @param type - the type of the data
      * @param xOffset - the x offset of copy region
      * @param yOffset - the y offset of copy region
      * @param width - the width of the image
      * @param height - the height of the image
      * @param data - the typedarray data of the image
      */
      loadImageToMipLevelOfTexture2D({ mipLevel, textureUid, format, type, xOffset, yOffset, width, height, rowSizeByPixel, data }) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const texture = this.getWebGLResource(textureUid);
        const pixelFormat = TextureFormat.getPixelFormatFromTextureFormat(format);
        const compositionNum = PixelFormat.getCompositionNumFromPixelFormat(pixelFormat);
        const reducedData = new data.constructor(width * height * compositionNum);
        for (let y = 0; y < height; y++) {
          const srcOffset = y * rowSizeByPixel * compositionNum;
          const destOffset = y * width * compositionNum;
          for (let x = 0; x < width; x++) {
            reducedData.set(data.subarray(srcOffset + x * compositionNum, srcOffset + (x + 1) * compositionNum), destOffset + x * compositionNum);
          }
        }
        this.__glw.bindTexture2D(15, texture);
        gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, xOffset, yOffset, width, height, pixelFormat.index, type.index, reducedData);
        this.__glw.unbindTexture2D(15);
      }
      /**
      * create a Texture from TypedArray
      * @param imageData
      * @param param1
      * @returns
      */
      createTextureFromTypedArray(imageData, { level, internalFormat, width, height, border, format, type, generateMipmap }) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const texture = gl.createTexture();
        const resourceHandle = this.__registerResource(texture);
        this.__glw.bindTexture2D(15, texture);
        const levels = generateMipmap ? Math.max(Math.log2(width), Math.log2(height)) : 1;
        gl.texStorage2D(GL_TEXTURE_2D, levels, internalFormat.index, width, height);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, format.index, type.index, imageData);
        this.__createTextureInner(gl, width, height, generateMipmap);
        return resourceHandle;
      }
      /**
      * Create and bind compressed texture object
      * @param textureDataArray transcoded texture data for each mipmaps(levels)
      * @param compressionTextureType
      */
      createCompressedTexture(textureDataArray, compressionTextureType) {
        const gl = this.__glw.getRawContext();
        const texture = gl.createTexture();
        const resourceHandle = this.__registerResource(texture);
        this.__glw.bindTexture2D(15, texture);
        const internalFormat = compressionTextureType.index;
        for (const textureData of textureDataArray) {
          gl.compressedTexImage2D(gl.TEXTURE_2D, textureData.level, internalFormat, textureData.width, textureData.height, 0, textureData.buffer);
        }
        this.__glw.unbindTexture2D(15);
        return resourceHandle;
      }
      /**
      * create CompressedTextureFromBasis
      * @param basisFile
      * @param param1
      * @returns
      */
      createCompressedTextureFromBasis(basisFile, { border, format, type }) {
        let basisCompressionType;
        let compressionType;
        const gl = this.__glw.getRawContext();
        const texture = gl.createTexture();
        const resourceHandle = this.__registerResource(texture);
        this.__glw.bindTexture2D(15, texture);
        const s3tc = gl.getExtension("WEBGL_compressed_texture_s3tc");
        if (s3tc) {
          basisCompressionType = BasisCompressionType.BC3;
          compressionType = s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        const etc1 = gl.getExtension("WEBGL_compressed_texture_etc1");
        if (etc1) {
          basisCompressionType = BasisCompressionType.ETC1;
          compressionType = etc1.COMPRESSED_RGB_ETC1_WEBGL;
        }
        const atc = gl.getExtension("WEBGL_compressed_texture_atc");
        if (atc) {
          basisCompressionType = BasisCompressionType.ATC_RGBA;
          compressionType = atc.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
        }
        const etc2 = gl.getExtension("WEBGL_compressed_texture_etc");
        if (etc2) {
          basisCompressionType = BasisCompressionType.ETC2;
          compressionType = etc2.COMPRESSED_RGBA8_ETC2_EAC;
        }
        const pvrtc = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        if (pvrtc) {
          basisCompressionType = BasisCompressionType.PVRTC1_RGBA;
          compressionType = pvrtc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        }
        const astc = gl.getExtension("WEBGL_compressed_texture_astc");
        if (astc) {
          basisCompressionType = BasisCompressionType.ASTC;
          compressionType = astc.COMPRESSED_RGBA_ASTC_4x4_KHR;
        }
        const mipmapDepth = basisFile.getNumLevels(0);
        for (let i2 = 0; i2 < mipmapDepth; i2++) {
          const width = basisFile.getImageWidth(0, i2);
          const height = basisFile.getImageHeight(0, i2);
          const textureSource = this.decodeBasisImage(basisFile, basisCompressionType, 0, i2);
          gl.compressedTexImage2D(gl.TEXTURE_2D, i2, compressionType, width, height, border, textureSource);
        }
        this.__glw.unbindTexture2D(15);
        return resourceHandle;
      }
      /**
      * decode the BasisImage
      * @param basisFile
      * @param basisCompressionType
      * @param imageIndex
      * @param levelIndex
      * @returns
      */
      decodeBasisImage(basisFile, basisCompressionType, imageIndex, levelIndex) {
        const extractSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisCompressionType.index);
        const textureSource = new Uint8Array(extractSize);
        if (!basisFile.transcodeImage(textureSource, imageIndex, levelIndex, basisCompressionType.index, 0, 0)) {
          Logger.error("failed to transcode the image.");
        }
        return textureSource;
      }
      /**
      * create a FrameBufferObject
      * @returns
      */
      createFrameBufferObject() {
        const gl = this.__glw.getRawContext();
        const fbo = gl.createFramebuffer();
        const resourceHandle = this.__registerResource(fbo);
        return resourceHandle;
      }
      /**
      * attach the ColorBuffer to the FrameBufferObject
      * @param framebuffer a Framebuffer
      * @param renderable a ColorBuffer
      */
      attachColorBufferToFrameBufferObject(framebuffer, index, renderable) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const fbo = this.getWebGLResource(framebuffer.framebufferUID);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        const renderableWebGLResource = this.getWebGLResource(renderable._textureResourceUid);
        const attachmentId = this.__glw.colorAttachment(index);
        if (renderable instanceof RenderTargetTexture && renderable.arrayLength > 0) {
          renderable._fbo = framebuffer;
          if (this.__glw.webgl2ExtMLTVIEW.is_multisample) {
            this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, attachmentId, renderableWebGLResource, 0, 4, 0, renderable.arrayLength);
          } else {
            this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, attachmentId, renderableWebGLResource, 0, 0, renderable.arrayLength);
          }
        } else if (renderable instanceof RenderTargetTexture && renderable.arrayLength === 0) {
          renderable._fbo = framebuffer;
          gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentId, gl.TEXTURE_2D, renderableWebGLResource, 0);
        } else {
          renderable._fbo = framebuffer;
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentId, gl.RENDERBUFFER, renderableWebGLResource);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      /**
      * attach the ColorBuffer to the FrameBufferObject
      * @param framebuffer a Framebuffer
      * @param attachmentIndex a attachment index
      * @param faceIndex a face index
      * @param mipLevel a mip level
      * @param renderable a ColorBuffer
      */
      attachColorBufferCubeToFrameBufferObject(framebuffer, attachmentIndex, faceIndex, mipLevel, renderable) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const fbo = this.getWebGLResource(framebuffer.framebufferUID);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        const renderableWebGLResource = this.getWebGLResource(renderable._textureResourceUid);
        const attachmentId = this.__glw.colorAttachment(attachmentIndex);
        renderable._fbo = framebuffer;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentId, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, renderableWebGLResource, mipLevel);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      /**
      * attach the DepthBuffer to the FrameBufferObject
      * @param framebuffer a Framebuffer
      * @param renderable a DepthBuffer
      */
      attachDepthBufferToFrameBufferObject(framebuffer, renderable) {
        this.__attachDepthOrStencilBufferToFrameBufferObject(framebuffer, renderable, 36096);
      }
      /**
      * attach the StencilBuffer to the FrameBufferObject
      * @param framebuffer a Framebuffer
      * @param renderable a StencilBuffer
      */
      attachStencilBufferToFrameBufferObject(framebuffer, renderable) {
        this.__attachDepthOrStencilBufferToFrameBufferObject(framebuffer, renderable, 36128);
      }
      /**
      * attach the depthStencilBuffer to the FrameBufferObject
      * @param framebuffer a Framebuffer
      * @param renderable a depthStencilBuffer
      */
      attachDepthStencilBufferToFrameBufferObject(framebuffer, renderable) {
        this.__attachDepthOrStencilBufferToFrameBufferObject(framebuffer, renderable, 33306);
      }
      __attachDepthOrStencilBufferToFrameBufferObject(framebuffer, renderable, attachmentType) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const fbo = this.getWebGLResource(framebuffer.framebufferUID);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        const renderableWebGLResource = this.getWebGLResource(renderable._textureResourceUid);
        if (renderable instanceof RenderTargetTexture && renderable.arrayLength > 0) {
          renderable._fbo = framebuffer;
          if (this.__glw.webgl2ExtMLTVIEW.is_multisample) {
            this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, attachmentType, renderableWebGLResource, 0, 4, 0, renderable.arrayLength);
          } else {
            this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, attachmentType, renderableWebGLResource, 0, 0, renderable.arrayLength);
          }
        } else if (renderable instanceof RenderTargetTexture && renderable.arrayLength === 0) {
          renderable._fbo = framebuffer;
          gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentType, gl.TEXTURE_2D, renderableWebGLResource, 0);
        } else {
          renderable._fbo = framebuffer;
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentType, gl.RENDERBUFFER, renderableWebGLResource);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      /**
      * create Renderbuffer
      */
      createRenderBuffer(width, height, internalFormat, isMSAA, sampleCountMSAA) {
        const gl = this.__glw.getRawContext();
        const renderBuffer = gl.createRenderbuffer();
        const resourceHandle = this.__registerResource(renderBuffer);
        gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
        if (isMSAA) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, sampleCountMSAA, gl[internalFormat.str], width, height);
        } else {
          gl.renderbufferStorage(gl.RENDERBUFFER, gl[internalFormat.str], width, height);
        }
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        return resourceHandle;
      }
      /**
      * set drawTargets
      * @param framebuffer
      */
      setDrawTargets(renderPass) {
        const framebuffer = renderPass.getFramebuffer();
        if (framebuffer) {
          const renderBufferTargetEnums = renderPass.getRenderTargetColorAttachments();
          if (Is.exist(renderBufferTargetEnums)) {
            this.__glw.drawBuffers(renderBufferTargetEnums);
          } else {
            this.__glw.drawBuffers(framebuffer.colorAttachmentsRenderBufferTargets);
          }
        } else {
          this.__glw.drawBuffers([
            RenderBufferTarget.Back
          ]);
        }
      }
      /**
      * bind Framebuffer
      * @param framebuffer
      */
      bindFramebuffer(framebuffer) {
        const gl = this.__glw.getRawContext();
        if (framebuffer) {
          const fboUid = framebuffer.cgApiResourceUid;
          const fbo = this.getWebGLResource(fboUid);
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        } else {
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
      }
      /**
      * unbind Framebuffer
      */
      unbindFramebuffer() {
        const gl = this.__glw.getRawContext();
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      /**
      * create a RenderTargetTexture
      * @param param0
      * @returns
      */
      createRenderTargetTexture({ width, height, mipLevelCount, format }) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const texture = gl.createTexture();
        const resourceHandle = this.__registerResource(texture);
        this.__glw.bindTexture2D(15, texture);
        gl.texStorage2D(gl.TEXTURE_2D, mipLevelCount, format.index, width, height);
        this.__glw.unbindTexture2D(15);
        return resourceHandle;
      }
      /**
      * create a RenderTargetTextureArray
      * @param param0
      * @returns
      */
      createRenderTargetTextureArray({ width, height, level, internalFormat, format, type, arrayLength }) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const texture = gl.createTexture();
        const resourceHandle = this.__registerResource(texture);
        this.__glw.bindTexture2DArray(15, texture);
        gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, internalFormat.index, width, height, arrayLength);
        return resourceHandle;
      }
      /**
      * create a RenderTargetTextureCube
      * @param param0
      * @returns
      */
      createRenderTargetTextureCube({ width, height, mipLevelCount, format }) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const texture = gl.createTexture();
        const resourceHandle = this.__registerResource(texture);
        this.__glw.bindTextureCube(15, texture);
        gl.texStorage2D(gl.TEXTURE_CUBE_MAP, mipLevelCount, format.index, width, height);
        this.__glw.unbindTextureCube(15);
        return resourceHandle;
      }
      /**
      * create a CubeTexture
      *
      * @param mipLevelCount
      * @param images
      * @param width
      * @param height
      * @returns resource handle
      */
      createCubeTexture(mipLevelCount, images, width, height) {
        const gl = this.__glw.getRawContext();
        const texture = gl.createTexture();
        const resourceHandle = this.__registerResource(texture);
        this.__glw.bindTextureCube(15, texture);
        const wrapS = TextureParameter.ClampToEdge;
        const wrapT = TextureParameter.ClampToEdge;
        let minFilter = TextureParameter.Linear;
        let magFilter = TextureParameter.Linear;
        if (images[0].posX.hdriFormat === HdriFormat.HDR_LINEAR && this.__glw.isNotSupportWebGL1Extension(WebGLExtension.TextureFloatLinear)) {
          if (mipLevelCount >= 2) {
            minFilter = TextureParameter.NearestMipmapNearest;
          } else {
            minFilter = TextureParameter.Nearest;
          }
          magFilter = TextureParameter.Nearest;
        } else {
          if (mipLevelCount >= 2) {
            minFilter = TextureParameter.LinearMipmapLinear;
          } else {
            minFilter = TextureParameter.Linear;
          }
          magFilter = TextureParameter.Linear;
        }
        const sampler = new Sampler({
          wrapS,
          wrapT,
          minFilter,
          magFilter
        });
        sampler.create();
        const loadImageToGPU = /* @__PURE__ */ __name((image, cubeMapSide, i2) => {
          if (image.hdriFormat === HdriFormat.HDR_LINEAR) {
            const gl2 = this.__glw.getRawContextAsWebGL2();
            gl2.texImage2D(cubeMapSide, i2, Config.isMobile ? gl2.RGB16F : gl2.RGB32F, image.width, image.height, 0, gl2.RGB, gl2.FLOAT, image.dataFloat);
          } else if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
            gl.texImage2D(cubeMapSide, i2, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
          } else {
            gl.texImage2D(cubeMapSide, i2, gl.RGBA, width / 2 ** i2, height / 2 ** i2, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
          }
        }, "loadImageToGPU");
        for (let i2 = 0; i2 < images.length; i2++) {
          const image = images[i2];
          loadImageToGPU(image.posX, gl.TEXTURE_CUBE_MAP_POSITIVE_X, i2);
          loadImageToGPU(image.negX, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, i2);
          loadImageToGPU(image.posY, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, i2);
          loadImageToGPU(image.negY, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, i2);
          loadImageToGPU(image.posZ, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, i2);
          loadImageToGPU(image.negZ, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, i2);
        }
        this.__glw.unbindTextureCube(15);
        return [
          resourceHandle,
          sampler
        ];
      }
      /**
      * Create Cube Texture from image files.
      * @param baseUri the base uri to load images;
      * @param mipLevelCount the number of mip levels (include root level). if no mipmap, the value should be 1;
      * @returns the WebGLResourceHandle for the generated Cube Texture
      */
      async createCubeTextureFromFiles(baseUri, mipLevelCount, isNamePosNeg, hdriFormat) {
        const gl = this.__glw.getRawContext();
        const imageArgs = [];
        let width = 0;
        let height = 0;
        for (let i2 = 0; i2 < mipLevelCount; i2++) {
          const loadOneLevel = /* @__PURE__ */ __name(() => {
            return new Promise((resolve, reject) => {
              let loadedCount = 0;
              const images2 = [];
              let extension = ".jpg";
              if (hdriFormat === HdriFormat.HDR_LINEAR) {
                extension = ".hdr";
              } else if (hdriFormat === HdriFormat.RGBE_PNG) {
                extension = ".RGBE.PNG";
              }
              let posX = "_right_";
              let negX = "_left_";
              let posY = "_top_";
              let negY = "_bottom_";
              let posZ = "_front_";
              let negZ = "_back_";
              if (isNamePosNeg) {
                posX = "_posx_";
                negX = "_negx_";
                posY = "_posy_";
                negY = "_negy_";
                posZ = "_posz_";
                negZ = "_negz_";
              }
              const faces = [
                [
                  baseUri + posX + i2 + extension,
                  gl.TEXTURE_CUBE_MAP_POSITIVE_X
                ],
                [
                  baseUri + negX + i2 + extension,
                  gl.TEXTURE_CUBE_MAP_NEGATIVE_X
                ],
                [
                  baseUri + posY + i2 + extension,
                  gl.TEXTURE_CUBE_MAP_POSITIVE_Y
                ],
                [
                  baseUri + negY + i2 + extension,
                  gl.TEXTURE_CUBE_MAP_NEGATIVE_Y
                ],
                [
                  baseUri + posZ + i2 + extension,
                  gl.TEXTURE_CUBE_MAP_POSITIVE_Z
                ],
                [
                  baseUri + negZ + i2 + extension,
                  gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
                ]
              ];
              for (let j = 0; j < faces.length; j++) {
                const face = faces[j][1];
                let image;
                if (hdriFormat === HdriFormat.HDR_LINEAR || hdriFormat === HdriFormat.RGB9_E5_PNG) {
                  image = new hdrpng_default();
                } else {
                  image = new Image();
                }
                image.hdriFormat = hdriFormat;
                image.side = face;
                image.uri = faces[j][0];
                image.crossOrigin = "Anonymous";
                image.onload = () => {
                  loadedCount++;
                  images2.push(image);
                  if (loadedCount === 6) {
                    resolve(images2);
                  }
                };
                image.onerror = () => {
                  reject(image.uri);
                };
                image.src = faces[j][0];
              }
            });
          }, "loadOneLevel");
          let images;
          try {
            images = await loadOneLevel();
          } catch (e3) {
            try {
              images = await loadOneLevel();
            } catch (uri) {
              Logger.error(`failed to load ${uri}`);
            }
          }
          const imageObj = {};
          for (const image of images) {
            switch (image.side) {
              case gl.TEXTURE_CUBE_MAP_POSITIVE_X:
                imageObj.posX = image;
                break;
              case gl.TEXTURE_CUBE_MAP_POSITIVE_Y:
                imageObj.posY = image;
                break;
              case gl.TEXTURE_CUBE_MAP_POSITIVE_Z:
                imageObj.posZ = image;
                break;
              case gl.TEXTURE_CUBE_MAP_NEGATIVE_X:
                imageObj.negX = image;
                break;
              case gl.TEXTURE_CUBE_MAP_NEGATIVE_Y:
                imageObj.negY = image;
                break;
              case gl.TEXTURE_CUBE_MAP_NEGATIVE_Z:
                imageObj.negZ = image;
                break;
            }
            if (i2 === 0) {
              width = image.width;
              height = image.height;
            }
          }
          imageArgs.push(imageObj);
        }
        return this.createCubeTexture(mipLevelCount, imageArgs, width, height);
      }
      createCubeTextureFromBasis(basisFile, { magFilter = TextureParameter.Linear, minFilter = TextureParameter.LinearMipmapLinear, wrapS = TextureParameter.Repeat, wrapT = TextureParameter.Repeat, border = 0 }) {
        const gl = this.__glw.getRawContext();
        let basisCompressionType;
        let compressionType;
        const texture = gl.createTexture();
        const resourceHandle = this.__registerResource(texture);
        this.__glw.bindTextureCube(15, texture);
        const s3tc = gl.getExtension("WEBGL_compressed_texture_s3tc");
        if (s3tc) {
          basisCompressionType = BasisCompressionType.BC3;
          compressionType = s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        const etc1 = gl.getExtension("WEBGL_compressed_texture_etc1");
        if (etc1) {
          basisCompressionType = BasisCompressionType.ETC1;
          compressionType = etc1.COMPRESSED_RGB_ETC1_WEBGL;
        }
        const atc = gl.getExtension("WEBGL_compressed_texture_atc");
        if (atc) {
          basisCompressionType = BasisCompressionType.ATC_RGBA;
          compressionType = atc.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
        }
        const etc2 = gl.getExtension("WEBGL_compressed_texture_etc");
        if (etc2) {
          basisCompressionType = BasisCompressionType.ETC2;
          compressionType = etc2.COMPRESSED_RGBA8_ETC2_EAC;
        }
        const pvrtc = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        if (pvrtc) {
          basisCompressionType = BasisCompressionType.PVRTC1_RGBA;
          compressionType = pvrtc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        }
        const astc = gl.getExtension("WEBGL_compressed_texture_astc");
        if (astc) {
          basisCompressionType = BasisCompressionType.ASTC;
          compressionType = astc.COMPRESSED_RGBA_ASTC_4x4_KHR;
        }
        const numImages = basisFile.getNumImages();
        const mipmapDepth = basisFile.getNumLevels(0);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, wrapS.index);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, wrapT.index);
        if (mipmapDepth >= 2) {
          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, minFilter.index);
          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, magFilter.index);
        } else {
          let minFilter_ = minFilter;
          if (minFilter === TextureParameter.LinearMipmapLinear) {
            minFilter_ = TextureParameter.Linear;
          }
          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, minFilter_.index);
          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, magFilter.index);
        }
        for (let i2 = 0; i2 < mipmapDepth; i2++) {
          for (let j = 0; j < numImages; j++) {
            const width = basisFile.getImageWidth(j, i2);
            const height = basisFile.getImageHeight(j, i2);
            const textureSource = this.decodeBasisImage(basisFile, basisCompressionType, j, i2);
            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, i2, compressionType, width, height, border, textureSource);
          }
        }
        this.__glw.unbindTextureCube(15);
        return resourceHandle;
      }
      createDummyBlackCubeTexture() {
        const base64 = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPj/HwADBwIAMCbHYQAAAABJRU5ErkJggg==";
        const arrayBuffer = this.__createDummyTextureInner(base64);
        const typedArray = new Uint8Array(arrayBuffer);
        return this.createCubeTexture(1, [
          {
            posX: typedArray,
            negX: typedArray,
            posY: typedArray,
            negY: typedArray,
            posZ: typedArray,
            negZ: typedArray
          }
        ], 1, 1);
      }
      createDummyCubeTexture(rgbaStr = "rgba(0,0,0,1)") {
        const canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = 1;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = rgbaStr;
        ctx.fillRect(0, 0, 1, 1);
        return this.createCubeTexture(1, [
          {
            posX: canvas,
            negX: canvas,
            posY: canvas,
            negY: canvas,
            posZ: canvas,
            negZ: canvas
          }
        ], 1, 1);
      }
      setWebGLTextureDirectly(webGLTexture) {
        const texture = webGLTexture;
        const resourceHandle = this.__registerResource(texture);
        return resourceHandle;
      }
      async createTextureFromDataUri(dataUri, { level, internalFormat, border, format, type, generateMipmap }) {
        return new Promise((resolve) => {
          const img = new Image();
          if (!dataUri.match(/^data:/)) {
            img.crossOrigin = "Anonymous";
          }
          img.onload = () => {
            const width = img.width;
            const height = img.height;
            const texture = this.createTextureFromHTMLImageElement(img, {
              level,
              internalFormat,
              width,
              height,
              border,
              format,
              type,
              generateMipmap
            });
            resolve(texture);
          };
          img.src = dataUri;
        });
      }
      updateLevel0TextureAndGenerateMipmap(textureUid, textureData, { width, height, format, type }) {
        const texture = this.getWebGLResource(textureUid);
        this.__glw.bindTexture2D(15, texture);
        const gl = this.__glw.getRawContextAsWebGL2();
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, format.index, type.index, textureData);
        gl.generateMipmap(gl.TEXTURE_2D);
        this.__glw.unbindTexture2D(15);
      }
      updateTexture(textureUid, textureData, { level, xoffset, yoffset, width, height, format, type }) {
        const texture = this.getWebGLResource(textureUid);
        this.__glw.bindTexture2D(15, texture);
        const gl = this.__glw.getRawContextAsWebGL2();
        gl.texSubImage2D(gl.TEXTURE_2D, level, 0, 0, width, height, format.index, type.index, textureData);
        this.__glw.unbindTexture2D(15);
      }
      deleteFrameBufferObject(frameBufferObjectHandle) {
        const fbo = this.getWebGLResource(frameBufferObjectHandle);
        const gl = this.__glw.getRawContext();
        if (fbo != null) {
          gl.deleteFramebuffer(fbo);
          this.__webglResources.delete(frameBufferObjectHandle);
        }
      }
      deleteRenderBuffer(renderBufferUid) {
        const gl = this.__glw.getRawContext();
        const renderBuffer = this.getWebGLResource(renderBufferUid);
        gl.deleteRenderbuffer(renderBuffer);
        this.__webglResources.delete(renderBufferUid);
      }
      deleteTexture(textureHandle) {
        const texture = this.getWebGLResource(textureHandle);
        const gl = this.__glw.getRawContext();
        if (texture != null) {
          gl.deleteTexture(texture);
          this.__webglResources.delete(textureHandle);
          Logger.debug("gl.deleteTexture called: " + textureHandle);
        }
      }
      createDummyTexture(rgbaStr = "rgba(255,255,255,1)") {
        const canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = 1;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = rgbaStr;
        ctx.fillRect(0, 0, 1, 1);
        return this.createTextureFromImageBitmapData(canvas, {
          level: 0,
          internalFormat: TextureFormat.RGBA8,
          width: 1,
          height: 1,
          border: 0,
          format: PixelFormat.RGBA,
          type: ComponentType.UnsignedByte,
          generateMipmap: false
        });
      }
      createDummyBlackTexture() {
        const base64 = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPj/HwADBwIAMCbHYQAAAABJRU5ErkJggg==";
        return this.__createDummyTextureInner(base64);
      }
      createDummyWhiteTexture() {
        const base64 = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5/hPwAIAgL/4d1j8wAAAABJRU5ErkJggg==";
        return this.__createDummyTextureInner(base64);
      }
      createDummyNormalTexture() {
        const base64 = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mOsr///HwAGgAL+v1RumAAAAABJRU5ErkJggg==";
        return this.__createDummyTextureInner(base64);
      }
      __createDummyTextureInner(base64) {
        const arrayBuffer = DataUtil.base64ToArrayBuffer(base64);
        return this.createTextureFromTypedArray(new Uint8Array(arrayBuffer), {
          level: 0,
          internalFormat: TextureFormat.RGBA8,
          width: 1,
          height: 1,
          border: 0,
          format: PixelFormat.RGBA,
          type: ComponentType.UnsignedByte,
          generateMipmap: false
        });
      }
      generateMipmaps2d(textureHandle, width, height) {
        const gl = this.__glw.getRawContext();
        const texture = this.getWebGLResource(textureHandle);
        this.__glw.bindTexture2D(15, texture);
        gl.generateMipmap(gl.TEXTURE_2D);
        this.__glw.unbindTexture2D(15);
      }
      generateMipmapsCube(textureHandle, width, height) {
        const gl = this.__glw.getRawContext();
        const texture = this.getWebGLResource(textureHandle);
        this.__glw.bindTextureCube(15, texture);
        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
        this.__glw.unbindTextureCube(15);
      }
      async getTexturePixelData(textureHandle, width, height, frameBufferUid, colorAttachmentIndex) {
        const gl = this.__glw.getRawContext();
        const fbo = this.getWebGLResource(frameBufferUid);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        const data = new Uint8Array(width * height * 4);
        if (gl.readBuffer != null) {
          gl.readBuffer(36064 + colorAttachmentIndex);
        }
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return data;
      }
      createUniformBuffer(bufferView) {
        const gl = this.__glw.getRawContextAsWebGL2();
        if (gl == null) {
          throw new Error("No WebGLRenderingContext set as Default.");
        }
        const ubo = gl.createBuffer();
        const resourceHandle = this.__registerResource(ubo);
        gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);
        gl.bufferData(gl.UNIFORM_BUFFER, bufferView, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
        return resourceHandle;
      }
      updateUniformBuffer(uboUid, typedArray, offsetByte, arrayLength) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const ubo = this.getWebGLResource(uboUid);
        gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);
        gl.bufferSubData(gl.UNIFORM_BUFFER, 0, typedArray, offsetByte, arrayLength);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
      }
      bindUniformBlock(shaderProgramUid, blockName, blockIndex) {
        const gl = this.__glw.getRawContextAsWebGL2();
        if (gl == null) {
          throw new Error("No WebGLRenderingContext set as Default.");
        }
        const shaderProgram = this.getWebGLResource(shaderProgramUid);
        const block = gl.getUniformBlockIndex(shaderProgram, blockName);
        gl.uniformBlockBinding(shaderProgram, block, blockIndex);
      }
      bindUniformBufferBase(blockIndex, uboUid) {
        const gl = this.__glw.getRawContextAsWebGL2();
        if (gl == null) {
          throw new Error("No WebGLRenderingContext set as Default.");
        }
        const ubo = this.getWebGLResource(uboUid);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, blockIndex, ubo);
      }
      deleteUniformBuffer(uboUid) {
        const gl = this.__glw.getRawContext();
        if (gl == null) {
          new Error("No WebGLRenderingContext set as Default.");
        }
        const ubo = this.getWebGLResource(uboUid);
        this.__webglResources.delete(uboUid);
        gl.deleteBuffer(ubo);
      }
      setupUniformBufferDataArea(typedArray) {
        const gl = this.__glw.getRawContextAsWebGL2();
        if (gl == null) {
          new Error("No WebGLRenderingContext set as Default.");
        }
        const ubo = gl.createBuffer();
        const resourceHandle = this.__registerResource(ubo);
        const maxConventionBlocks = this.__glw.getMaxConventionUniformBlocks();
        const alignedMaxUniformBlockSize = this.__glw.getAlignedMaxUniformBlockSize();
        const realSize = alignedMaxUniformBlockSize * maxConventionBlocks;
        const array = new Float32Array(realSize / 4);
        if (Is.exist(typedArray)) {
          array.set(typedArray.subarray(0, array.length));
        }
        gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);
        gl.bufferData(gl.UNIFORM_BUFFER, array, gl.DYNAMIC_DRAW, 0, 0);
        for (let i2 = 0; i2 < maxConventionBlocks; i2++) {
          gl.bindBufferRange(gl.UNIFORM_BUFFER, i2, ubo, alignedMaxUniformBlockSize * i2, alignedMaxUniformBlockSize);
        }
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
        return resourceHandle;
      }
      getGlslRenderTargetBeginString(renderTargetNumber) {
        let text = "";
        for (let i2 = 0; i2 < renderTargetNumber; i2++) {
          text += `layout(location = ${i2}) out vec4 rt${i2};`;
        }
        return text;
      }
      getGlslRenderTargetEndString(renderTargetNumber) {
        const text = "";
        return text;
      }
      getGlslDataUBODefinitionString() {
        let text = "";
        const maxConventionblocks = this.__glw.getMaxConventionUniformBlocks();
        const alignedMaxUniformBlockSize = this.__glw.getAlignedMaxUniformBlockSize();
        for (let i2 = 0; i2 < maxConventionblocks; i2++) {
          text += `
layout (std140) uniform Vec4Block${i2} {
  vec4 vec4Block${i2}[${alignedMaxUniformBlockSize / 4 / 4}];
};
`;
        }
        text += `
vec4 fetchVec4FromVec4Block(int vec4Idx) {
  int vec4IdxForEachBlock = vec4Idx % dataUBOVec4Size;
  if (vec4Idx < dataUBOVec4Size) {
    return vec4Block0[vec4IdxForEachBlock];
  }`;
        for (let i2 = 1; i2 < maxConventionblocks; i2++) {
          text += `
 else if (vec4Idx < dataUBOVec4Size * ${i2 + 1}) {
    return vec4Block${i2}[vec4IdxForEachBlock];
}`;
        }
        text += "}\n";
        return text;
      }
      getGlslDataUBOVec4SizeString() {
        const alignedMaxUniformBlockSize = this.__glw.getAlignedMaxUniformBlockSize();
        return `const int dataUBOVec4Size = ${alignedMaxUniformBlockSize / 4 / 4};`;
      }
      createMultiviewFramebuffer(width, height, samples) {
        if (Is.not.exist(this.__glw.webgl2ExtMLTVIEW)) {
          return [
            -1,
            -1
          ];
        }
        const gl = this.__glw.getRawContextAsWebGL2();
        const framebuffer = gl.createFramebuffer();
        const framebufferHandle = this.__registerResource(framebuffer);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
        const colorTexture = gl.createTexture();
        const colorTextureHandle = this.__registerResource(colorTexture);
        gl.bindTexture(gl.TEXTURE_2D_ARRAY, colorTexture);
        gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.RGBA8, width, height, 2);
        if (!this.__glw.webgl2ExtMLTVIEW.is_multisample) this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorTexture, 0, 0, 2);
        else this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorTexture, 0, samples, 0, 2);
        const depthStencilTex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D_ARRAY, depthStencilTex);
        gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.DEPTH32F_STENCIL8, width, height, 2);
        if (!this.__glw.webgl2ExtMLTVIEW.is_multisample) this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, depthStencilTex, 0, 0, 2);
        else this.__glw.webgl2ExtMLTVIEW.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, depthStencilTex, 0, samples, 0, 2);
        return [
          framebufferHandle,
          colorTextureHandle
        ];
      }
      createTransformFeedback() {
        const gl = this.__glw.getRawContextAsWebGL2();
        const transformFeedback = gl.createTransformFeedback();
        const resourceHandle = this.__registerResource(transformFeedback);
        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);
        return resourceHandle;
      }
      deleteTransformFeedback(transformFeedbackUid) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const transformFeedback = this.getWebGLResource(transformFeedbackUid);
        gl.deleteTransformFeedback(transformFeedback);
        this.__webglResources.delete(transformFeedbackUid);
      }
      setViewport(viewport) {
        var _a40, _b;
        if (viewport) {
          (_a40 = this.__glw) == null ? void 0 : _a40.setViewportAsVector4(viewport);
          SystemState.viewportAspectRatio = (viewport.z - viewport.x) / (viewport.w - viewport.y);
        } else {
          (_b = this.__glw) == null ? void 0 : _b.setViewport(0, 0, this.__glw.width, this.__glw.height);
          SystemState.viewportAspectRatio = this.__glw.width / this.__glw.height;
        }
      }
      clearFrameBuffer(renderPass) {
        const gl = this.__glw.getRawContext();
        let bufferBit = 0;
        if (renderPass.toClearColorBuffer) {
          gl.clearColor(renderPass.clearColor.x, renderPass.clearColor.y, renderPass.clearColor.z, renderPass.clearColor.w);
          bufferBit |= gl.COLOR_BUFFER_BIT;
        }
        if (renderPass.toClearDepthBuffer) {
          gl.clearDepth(renderPass.clearDepth);
          bufferBit |= gl.DEPTH_BUFFER_BIT;
        }
        if (renderPass.toClearStencilBuffer) {
          gl.clearStencil(renderPass.clearStencil);
          bufferBit |= gl.STENCIL_BUFFER_BIT;
        }
        if (bufferBit !== 0) {
          gl.clear(bufferBit);
        }
      }
      deleteVertexDataResources(vertexHandles) {
        const gl = this.__glw.getRawContext();
        const iboHandle = vertexHandles.iboHandle;
        if (iboHandle) {
          const ibo = this.getWebGLResource(iboHandle);
          gl.deleteBuffer(ibo);
          this.__webglResources.delete(iboHandle);
        }
        const vboHandles = vertexHandles.vboHandles;
        for (const vboHandle of vboHandles) {
          const vbo = this.getWebGLResource(vboHandle);
          gl.deleteBuffer(vbo);
          this.__webglResources.delete(vboHandle);
        }
        const vaoHandle = vertexHandles.vaoHandle;
        const vao = this.getWebGLResource(vaoHandle);
        this.__glw.deleteVertexArray(vao);
        this.__webglResources.delete(vaoHandle);
      }
      deleteVertexArray(vaoHandle) {
        const vao = this.getWebGLResource(vaoHandle);
        this.__glw.deleteVertexArray(vao);
        this.__webglResources.delete(vaoHandle);
      }
      deleteVertexBuffer(vboUid) {
        const gl = this.__glw.getRawContext();
        const vbo = this.getWebGLResource(vboUid);
        gl.deleteBuffer(vbo);
        this.__webglResources.delete(vboUid);
      }
      resizeCanvas(width, height) {
        this.__glw.width = width;
        this.__glw.height = height;
        this.__glw.canvas.width = width;
        this.__glw.canvas.height = height;
        this.__glw.setViewportAsVector4(Vector4.fromCopyArray([
          0,
          0,
          width,
          height
        ]));
      }
      getCanvasSize() {
        return [
          this.__glw.canvas.width,
          this.__glw.canvas.height
        ];
      }
      switchDepthTest(flag) {
        const gl = this.__glw.getRawContext();
        if (flag) {
          gl.enable(gl.DEPTH_TEST);
        } else {
          gl.disable(gl.DEPTH_TEST);
        }
      }
      rebuildProgramBySpector(updatedVertexSourceCode, updatedFragmentSourceCode, onCompiled, onError) {
        const material = this._material.deref();
        if (Is.not.exist(material)) {
          const warn = "Material Not found";
          Logger.warn(warn);
          onError(warn);
          return false;
        }
        const processApproach = SystemState.currentProcessApproach;
        const renderingStrategy = getRenderingStrategy_default(processApproach);
        const modifiedVertexSourceCode = updatedVertexSourceCode.replace(/! =/g, "!=");
        const modifiedPixelSourceCode = updatedFragmentSourceCode.replace(/! =/g, "!=");
        const programUid = renderingStrategy._reSetupShaderForMaterialBySpector(material, this._primitive.deref(), {
          vertex: modifiedVertexSourceCode,
          pixel: modifiedPixelSourceCode
        }, onError);
        if (programUid < 0) {
          return false;
        }
        const webglResourceRepository = _WebGLResourceRepository.getInstance();
        const program = webglResourceRepository.getWebGLResource(programUid);
        if (programUid > 0) {
          onCompiled(program);
        }
        return true;
      }
      getPixelDataFromTexture(texUid, x, y, width, height) {
        const gl = this.__glw.getRawContext();
        const pixels = new Uint8Array((width - x) * (height - y) * 4);
        const texture = this.getWebGLResource(texUid);
        const fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteFramebuffer(fbo);
        return pixels;
      }
      setWebGLStateToDefault() {
        const gl = this.__glw.getRawContextAsWebGL2();
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindVertexArray(null);
        gl.clearColor(0, 0, 0, 0);
        gl.clearDepth(1);
        gl.clearStencil(0);
        gl.depthFunc(gl.LESS);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.STENCIL_TEST);
        gl.disable(gl.BLEND);
        gl.disable(gl.DITHER);
        gl.disable(gl.SCISSOR_TEST);
        gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.disable(gl.SAMPLE_COVERAGE);
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
        gl.disable(gl.CULL_FACE);
        gl.frontFace(gl.CCW);
        gl.cullFace(gl.BACK);
        gl.blendColor(0, 0, 0, 0);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
        gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 0, 4294967295);
        gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 0, 4294967295);
        gl.stencilMaskSeparate(gl.FRONT, 4294967295);
        gl.stencilMaskSeparate(gl.BACK, 4294967295);
        gl.colorMask(true, true, true, true);
        gl.depthMask(true);
        gl.sampleCoverage(1, false);
        for (let i2 = 0; i2 < 16; i2++) {
          gl.activeTexture(gl.TEXTURE0 + i2);
          gl.bindTexture(gl.TEXTURE_2D, null);
          gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
          gl.bindSampler(i2, null);
        }
      }
      unbindTextureSamplers() {
        const gl = this.__glw.getRawContextAsWebGL2();
        for (let i2 = 0; i2 < 16; i2++) {
          gl.bindSampler(i2, null);
        }
      }
      isSupportMultiViewVRRendering() {
        if (SystemState.currentProcessApproach === ProcessApproach.DataTexture) {
          return this.__glw.isMultiview();
        } else {
          return false;
        }
      }
      blitToTexture2dFromTexture2dArray(srcTextureUid, dstFboUid, dstWidth, dstHeight) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const srcTexture = this.getWebGLResource(srcTextureUid);
        const dstFbo = this.getWebGLResource(dstFboUid);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFbo);
        const webStereoUtil = WebGLStereoUtil.getInstance(gl);
        webStereoUtil.blit(srcTexture, 0, 0, 1, 1, dstWidth, dstHeight);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      }
      blitToTexture2dFromTexture2dArrayFake(srcTextureUid, dstFboUid, dstWidth, dstHeight) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const srcTexture = this.getWebGLResource(srcTextureUid);
        const dstFbo = this.getWebGLResource(dstFboUid);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFbo);
        const webStereoUtil = WebGLStereoUtil.getInstance(gl);
        webStereoUtil.blitFake(srcTexture, 0, 0, 1, 1, dstWidth, dstHeight);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      }
      blitToTexture2dFromTexture2dArray2(srcTextureUid, dstTextureUid, dstWidth, dstHeight) {
        const gl = this.__glw.getRawContextAsWebGL2();
        const srcTexture = this.getWebGLResource(srcTextureUid);
        const dstTexture = this.getWebGLResource(dstTextureUid);
        const webStereoUtil = WebGLStereoUtil.getInstance(gl);
        webStereoUtil.blit2(srcTexture, dstTexture, dstWidth, dstHeight);
      }
    };
    __name(_WebGLResourceRepository, "WebGLResourceRepository");
    __publicField(_WebGLResourceRepository, "__instance");
    WebGLResourceRepository = _WebGLResourceRepository;
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/common/prerequisites.glsl
var prerequisites_default;
var init_prerequisites = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/common/prerequisites.glsl"() {
    prerequisites_default = { code: "const float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/common/vertexInput.wgsl
var vertexInput_default;
var init_vertexInput = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/common/vertexInput.wgsl"() {
    vertexInput_default = { code: "#ifdef RN_USE_INSTANCE\n  @location(8) instance_ids: vec4<f32>,\n#endif\n\n\n#ifdef RN_USE_POSITION_FLOAT\n  @location(0) position: vec3<f32>,\n#endif\n#ifdef RN_USE_POSITION_INT\n  @location(0) position: vec3<i32>,\n#endif\n#ifdef RN_USE_POSITION_UINT\n  @location(0) position: vec3<u32>,\n#endif\n\n#ifdef RN_USE_NORMAL\n  @location(1) normal: vec3<f32>,\n#endif\n#ifdef RN_USE_TANGENT\n  @location(2) tangent: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_0\n  @location(3) texcoord_0: vec2<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  @location(4) texcoord_1: vec2<f32>,\n#endif\n\n#ifdef RN_USE_COLOR_0_FLOAT\n  @location(5) color_0: vec4<f32>,\n#endif\n#ifdef RN_USE_COLOR_0_INT\n  @location(5) color_0: vec4<i32>,\n#endif\n#ifdef RN_USE_COLOR_0_UINT\n  @location(5) color_0: vec4<u32>,\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  @location(6) joints_0: vec4<u32>,\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  @location(7) weights_0: vec4<f32>,\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  @location(10) baryCentricCoord: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  @location(11) texcoord_2: vec2<f32>,\n#endif\n  @builtin(vertex_index) vertexIdx : u32,\n\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/common/prerequisites.wgsl
var prerequisites_default2;
var init_prerequisites2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/common/prerequisites.wgsl"() {
    prerequisites_default2 = { code: "struct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/common/mainPrerequisites.glsl
var mainPrerequisites_default;
var init_mainPrerequisites = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/common/mainPrerequisites.glsl"() {
    mainPrerequisites_default = { code: "#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/common/mainPrerequisites.wgsl
var mainPrerequisites_default2;
var init_mainPrerequisites2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/common/mainPrerequisites.wgsl"() {
    mainPrerequisites_default2 = { code: "let materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// src/foundation/renderer/Expression.ts
var _Expression, Expression;
var init_Expression = __esm({
  "src/foundation/renderer/Expression.ts"() {
    "use strict";
    init_RnObject();
    _Expression = class _Expression extends RnObject {
      constructor() {
        super();
        __publicField(this, "__renderPasses", []);
      }
      clone() {
        const exp = new _Expression();
        exp.tryToSetUniqueName(this.uniqueName + "_cloned", true);
        const renderPasses = [];
        for (const renderPass of this.__renderPasses) {
          renderPasses.push(renderPass.clone());
        }
        exp.addRenderPasses(renderPasses);
        return exp;
      }
      /**
      * Add render passes to the end of this expression.
      */
      addRenderPasses(renderPasses) {
        for (const renderPass of renderPasses) {
          this.__renderPasses.push(renderPass);
        }
      }
      /**
      * Clear render passes of this expression.
      */
      clearRenderPasses() {
        this.__renderPasses.length = 0;
      }
      /**
      * Gets the list of render passes of this expression.
      */
      get renderPasses() {
        return this.__renderPasses;
      }
      setViewport(viewport) {
        for (const renderPass of this.__renderPasses) {
          renderPass.setViewport(viewport);
        }
      }
    };
    __name(_Expression, "Expression");
    Expression = _Expression;
  }
});

// src/foundation/renderer/Frame.ts
var _Frame, Frame;
var init_Frame = __esm({
  "src/foundation/renderer/Frame.ts"() {
    "use strict";
    init_RnObject();
    init_Is();
    _Frame = class _Frame extends RnObject {
      constructor() {
        super();
        __publicField(this, "__expressions", []);
        __publicField(this, "__expressionsCache", []);
        __publicField(this, "__expressionQueries", []);
      }
      /**
      * Add render passes to the end of this expression.
      */
      addExpression(expression, { inputRenderPasses, outputs } = {
        inputRenderPasses: [],
        outputs: []
      }) {
        if (Is.exist(outputs)) {
          for (const output of outputs) {
            let renderPass = output.renderPass.instance;
            if (Is.exist(output.renderPass.instance)) {
              renderPass = output.renderPass.instance;
            } else if (Is.exist(output.renderPass.index)) {
              renderPass = expression.renderPasses[output.renderPass.index];
            } else if (Is.exist(output.renderPass.uniqueName)) {
              renderPass = RnObject.getRnObjectByName(output.renderPass.uniqueName);
            }
            if (Is.exist(renderPass)) {
              renderPass.setFramebuffer(output.frameBuffer);
            }
          }
        }
        this.__expressions.push({
          expression,
          inputRenderPasses: Is.exist(inputRenderPasses) ? inputRenderPasses : []
        });
        this.__expressionsCache.push(expression);
      }
      /**
      * Get ColorAttachment RenderBuffer from input render pass of the expression
      * @param inputFrom input Expression
      * @param {inputIndex: number, colorAttachmentIndex: number} input RenderPass Index and ColorAttachmen tIndex
      * @returns {Promise<RenderTargetTexture>}
      */
      getColorAttachmentFromInputOf(inputFrom, renderPassArg = {
        renderPass: {
          index: 0
        },
        colorAttachmentIndex: 0,
        framebufferType: _Frame.FrameBuffer
      }) {
        const promise = new Promise((resolve) => {
          function* generatorFunc() {
            const renderTargetTexture = yield;
            resolve(renderTargetTexture);
            return renderTargetTexture;
          }
          __name(generatorFunc, "generatorFunc");
          const generator = generatorFunc();
          this.__expressionQueries.push([
            inputFrom,
            renderPassArg.renderPass,
            renderPassArg.colorAttachmentIndex,
            generator,
            renderPassArg.framebufferType
          ]);
        });
        return promise;
      }
      /**
      *
      */
      resolve() {
        for (const [exp, renderPassArg, colorAttachmentIndex, generator, frameBufferType] of this.__expressionQueries) {
          for (const expData of this.__expressions) {
            if (exp === expData.expression) {
              let renderPassObj = renderPassArg.instance;
              if (Is.exist(renderPassArg.instance)) {
                renderPassObj = renderPassArg.instance;
              } else if (Is.exist(renderPassArg.index)) {
                renderPassObj = expData.inputRenderPasses[renderPassArg.index];
              } else if (Is.exist(renderPassArg.uniqueName)) {
                renderPassObj = RnObject.getRnObjectByName(renderPassArg.uniqueName);
              }
              let framebuffer;
              if (frameBufferType === "ResolveFrameBuffer2") {
                framebuffer = renderPassObj.getResolveFramebuffer2();
              } else if (frameBufferType === "ResolveFrameBuffer") {
                framebuffer = renderPassObj.getResolveFramebuffer();
              } else if (frameBufferType === "FrameBuffer") {
                framebuffer = renderPassObj.getFramebuffer();
              }
              if (Is.exist(framebuffer)) {
                const renderTargetTexture = framebuffer.getColorAttachedRenderTargetTexture(colorAttachmentIndex);
                if (Is.exist(renderTargetTexture)) {
                  generator.next(renderTargetTexture);
                  generator.next(renderTargetTexture);
                }
              }
            }
          }
        }
      }
      /**
      * Clear render passes of this expression.
      */
      clearExpressions() {
        this.__expressions.length = 0;
        this.__expressionsCache.length = 0;
      }
      /**
      * Get expressions
      */
      get expressions() {
        return this.__expressionsCache;
      }
      setViewport(viewport) {
        for (const exp of this.__expressions) {
          exp.expression.setViewport(viewport);
        }
      }
    };
    __name(_Frame, "Frame");
    __publicField(_Frame, "FrameBuffer", "FrameBuffer");
    __publicField(_Frame, "ResolveFrameBuffer", "ResolveFrameBuffer");
    __publicField(_Frame, "ResolveFrameBuffer2", "ResolveFrameBuffer2");
    Frame = _Frame;
  }
});

// node_modules/shaderity/dist/esm/index.js
var require_esm = __commonJS({
  "node_modules/shaderity/dist/esm/index.js"(exports, module) {
    "use strict";
    module.exports = /******/
    function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module1 = installedModules[moduleId] = {
          /******/
          i: moduleId,
          /******/
          l: false,
          /******/
          exports: {}
        };
        modules[moduleId].call(module1.exports, module1, module1.exports, __webpack_require__);
        module1.l = true;
        return module1.exports;
      }
      __name(__webpack_require__, "__webpack_require__");
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, {
            enumerable: true,
            get: getter
          });
        }
      };
      __webpack_require__.r = function(exports2) {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports2, Symbol.toStringTag, {
            value: "Module"
          });
        }
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
      };
      __webpack_require__.t = function(value, mode) {
        if (mode & 1) value = __webpack_require__(value);
        if (mode & 8) return value;
        if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
        var ns = /* @__PURE__ */ Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", {
          enumerable: true,
          value
        });
        if (mode & 2 && typeof value != "string") for (var key in value) __webpack_require__.d(ns, key, function(key2) {
          return value[key2];
        }.bind(null, key));
        return ns;
      };
      __webpack_require__.n = function(module1) {
        var getter = module1 && module1.__esModule ? (
          /******/
          /* @__PURE__ */ __name(function getDefault() {
            return module1["default"];
          }, "getDefault")
        ) : (
          /******/
          /* @__PURE__ */ __name(function getModuleExports() {
            return module1;
          }, "getModuleExports")
        );
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "./../../dist/";
      return __webpack_require__(__webpack_require__.s = "./src/index.ts");
    }({
      /***/
      "./src/index.ts": (
        /*!**********************!*\
        !*** ./src/index.ts ***!
        \**********************/
        /*! no static exports found */
        /***/
        /* @__PURE__ */ __name(function(module1, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
              "default": mod
            };
          };
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          const Shaderity_1 = __importDefault(__webpack_require__(
            /*! ./main/Shaderity */
            "./src/main/Shaderity.ts"
          ));
          exports2.default = Shaderity_1.default;
        }, "./src/index.ts")
      ),
      /***/
      "./src/main/PreProcessor.ts": (
        /*!**********************************!*\
        !*** ./src/main/PreProcessor.ts ***!
        \**********************************/
        /*! no static exports found */
        /***/
        /* @__PURE__ */ __name(function(module1, exports2, __webpack_require__) {
          "use strict";
          var _a40;
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          let PreProcessor = (_a40 = class {
            static process(splittedLines) {
              const define = /#define[\t ]+(\w+)/;
              const ifdef = /#ifdef[\t ]+(\w+)/;
              const elif = /#elif[\t ]+defined\((\w+)\)/;
              const _else = /#else/;
              const endif = /#endif/;
              const outputHistory = [];
              let outputFlg = true;
              const definitions = [];
              const ifdefs = [];
              const outputLines = [];
              for (const line of splittedLines) {
                let isPragma = false;
                {
                  const re = line.match(define);
                  if (re != null) {
                    definitions.push(re[1]);
                    isPragma = true;
                  }
                }
                if (outputHistory.indexOf(false) === -1) {
                  const re = line.match(ifdef);
                  if (re != null) {
                    outputHistory.push(outputFlg);
                    const toCheckDef = re[1];
                    ifdefs.push([
                      toCheckDef
                    ]);
                    if (definitions.indexOf(toCheckDef) === -1) {
                      outputFlg = false;
                    }
                    isPragma = true;
                  }
                }
                if (outputHistory.indexOf(false) === -1) {
                  const re = line.match(elif);
                  if (re != null) {
                    const toCheckDef = re[1];
                    const currentIfdefs = ifdefs[ifdefs.length - 1];
                    let notFound = true;
                    for (const currentIfdef of currentIfdefs) {
                      if (definitions.indexOf(currentIfdef) !== -1) {
                        notFound = false;
                      }
                    }
                    if (notFound && definitions.indexOf(toCheckDef) !== -1) {
                      outputFlg = true;
                    } else {
                      outputFlg = false;
                    }
                    currentIfdefs.push(toCheckDef);
                    isPragma = true;
                  }
                }
                if (outputHistory.indexOf(false) === -1) {
                  const re = line.match(_else);
                  if (re != null) {
                    const currentIfdefs = ifdefs[ifdefs.length - 1];
                    let outputFlgInner = true;
                    for (const currentIfdef of currentIfdefs) {
                      if (definitions.indexOf(currentIfdef) !== -1) {
                        outputFlgInner = false;
                      }
                    }
                    outputFlg = outputFlgInner;
                    isPragma = true;
                  }
                }
                {
                  const re = line.match(endif);
                  if (re != null) {
                    if (outputHistory.indexOf(false) === -1) {
                      outputFlg = true;
                    }
                    isPragma = true;
                    ifdefs.pop();
                    outputHistory.pop();
                  }
                }
                if (outputFlg && !isPragma) {
                  outputLines.push(line);
                }
              }
              return outputLines;
            }
          }, __name(_a40, "PreProcessor"), _a40);
          exports2.default = PreProcessor;
        }, "./src/main/PreProcessor.ts")
      ),
      /***/
      "./src/main/Reflection.ts": (
        /*!********************************!*\
        !*** ./src/main/Reflection.ts ***!
        \********************************/
        /*! no static exports found */
        /***/
        /* @__PURE__ */ __name(function(module1, exports2, __webpack_require__) {
          "use strict";
          var _a40;
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          let Reflection = (_a40 = class {
            constructor(splittedShaderityShaderCode, shaderStage) {
              this.__attributeSemanticsMap = /* @__PURE__ */ new Map();
              this.__uniformSemanticsMap = /* @__PURE__ */ new Map();
              this.__attributes = [];
              this.__varyings = [];
              this.__uniforms = [];
              this.__splittedShaderCode = splittedShaderityShaderCode;
              this.__shaderStage = shaderStage;
              this.__setDefaultAttributeAndUniformSemanticsMap();
            }
            /**
            * Gets all attribute variable information in the shader code.
            * Before calling this method, you need to call the reflect method of this instance.
            * @returns Array of ReflectionAttribute object
            */
            get attributes() {
              return this.__attributes;
            }
            /**
            * Gets all varying variable information in the shader code.
            * Before calling this method, you need to call the reflect method of this instance.
            * @returns Array of ReflectionVarying object
            */
            get varyings() {
              return this.__varyings;
            }
            /**
            * Gets all uniform variable information in the shader code.
            * Before calling this method, you need to call the reflect method of this instance.
            * @returns Array of ReflectionUniform object
            */
            get uniforms() {
              return this.__uniforms;
            }
            /**
            * Get the names of all attributes included in the shader.
            * Before calling this method, you need to call the reflect method of this instance.
            * @returns Array of string
            */
            get attributesNames() {
              return this.__attributes.map((attribute) => {
                return attribute.name;
              });
            }
            /**
            * Get the attribute semantic (e.g. 'POSITION') of all attributes included in the shader.
            * Before calling this method, you need to call the reflect method of this instance.
            * @returns Array of AttributeSemantics object
            */
            get attributesSemantics() {
              return this.__attributes.map((attribute) => {
                return attribute.semantic;
              });
            }
            /**
            * Get the variable type (e.g. 'vec4') of all attributes included in the shader.
            * Before calling this method, you need to call the reflect method of this instance.
            * @returns Array of VarType object
            */
            get attributesTypes() {
              return this.__attributes.map((attribute) => {
                return attribute.type;
              });
            }
            /**
            * Add an attributeSemantics.
            * The attributeSemantics is used in the ReflectionAttribute.semantics
            * (See reflect method of this class)
            */
            addAttributeSemanticsMap(map) {
              this.__attributeSemanticsMap = new Map([
                ...this.__attributeSemanticsMap,
                ...map
              ]);
            }
            /**
            * Add a uniformSemantics.
            * The attributeSemantics is used in the ReflectionAttribute.semantics
            * (See reflect method of this class)
            */
            addUniformSemanticsMap(map) {
              this.__uniformSemanticsMap = new Map([
                ...this.__uniformSemanticsMap,
                ...map
              ]);
            }
            /**
            * Add an attributeSemantics.
            * The attributeSemantics is used in the ReflectionAttribute.semantics
            * (See reflect method of this class)
            */
            addAttributeSemantics(key, value) {
              this.__attributeSemanticsMap.set(key, value);
            }
            /**
            * Add a uniformSemantics.
            * The attributeSemantics is used in the ReflectionAttribute.semantics
            * (See reflect method of this class)
            */
            addUniformSemantics(key, value) {
              this.__uniformSemanticsMap.set(key, value);
            }
            /**
            * Initialize attributeSemantics
            */
            resetAttributeSemantics() {
              this.__attributeSemanticsMap = /* @__PURE__ */ new Map();
            }
            /**
            * Initialize uniformSemantics
            */
            resetUniformSemantics() {
              this.__uniformSemanticsMap = /* @__PURE__ */ new Map();
            }
            /**
            * Analyze shader code of the shaderity and get information of attribute, varying and uniform.
            * The information can be retrieved from the get method of this instance.
            *
            * The semantic property of the ReflectionAttribute is assigned to the value of the semantic if
            * it is specified in the attribute line of the shader code. If not, the AttributeSemanticsMap
            * is searched for matching semantics, or UNKNOWN. The same applies to the semantic property of
            * ReflectionUniform.
            */
            reflect() {
              const splittedShaderCode = this.__splittedShaderCode;
              const shaderStage = this.__shaderStage;
              for (const shaderCodeLine of splittedShaderCode) {
                const isAttributeLine = this.__matchAttribute(shaderCodeLine, shaderStage);
                if (isAttributeLine) {
                  this.__addAttribute(shaderCodeLine);
                  continue;
                }
                const isVaryingLine = this.__matchVarying(shaderCodeLine, shaderStage);
                if (isVaryingLine) {
                  this.__addVarying(shaderCodeLine, shaderStage);
                  continue;
                }
                const isUniformLine = shaderCodeLine.match(/^(?![\/])[\t ]*uniform[\t ]+/);
                if (isUniformLine) {
                  this.__addUniform(shaderCodeLine);
                  continue;
                }
              }
            }
            __setDefaultAttributeAndUniformSemanticsMap() {
              this.__attributeSemanticsMap.set("position", "POSITION");
              this.__attributeSemanticsMap.set("color$", "COLOR_0");
              this.__attributeSemanticsMap.set("color_?0", "COLOR_0");
              this.__attributeSemanticsMap.set("texcoord$", "TEXCOORD_0");
              this.__attributeSemanticsMap.set("texcoord_?0", "TEXCOORD_0");
              this.__attributeSemanticsMap.set("texcoord_?1", "TEXCOORD_1");
              this.__attributeSemanticsMap.set("texcoord_?2", "TEXCOORD_2");
              this.__attributeSemanticsMap.set("normal", "NORMAL");
              this.__attributeSemanticsMap.set("tangent", "TANGENT");
              this.__attributeSemanticsMap.set("joint$", "JOINTS_0");
              this.__attributeSemanticsMap.set("bone$", "JOINTS_0");
              this.__attributeSemanticsMap.set("joint_?0", "JOINTS_0");
              this.__attributeSemanticsMap.set("bone_?0", "JOINTS_0");
              this.__attributeSemanticsMap.set("weight$", "WEIGHTS_0");
              this.__attributeSemanticsMap.set("weight_?0", "WEIGHTS_0");
              this.__uniformSemanticsMap.set("worldmatrix", "WorldMatrix");
              this.__uniformSemanticsMap.set("normalmatrix", "NormalMatrix");
              this.__uniformSemanticsMap.set("viewmatrix", "ViewMatrix");
              this.__uniformSemanticsMap.set("projectionmatrix", "ProjectionMatrix");
              this.__uniformSemanticsMap.set("modelviewmatrix", "ModelViewMatrix");
            }
            __matchAttribute(shaderCodeLine, shaderStage) {
              if (shaderStage !== "vertex") {
                return false;
              }
              return shaderCodeLine.match(/^(?![\/])[\t ]*(attribute|in)[\t ]+.+;/);
            }
            __addAttribute(shaderCodeLine) {
              const reflectionAttribute = {
                name: "",
                type: "float",
                semantic: "UNKNOWN"
              };
              const matchType = shaderCodeLine.match(_a40.attributeAndVaryingTypeRegExp);
              if (matchType) {
                const type = matchType[1];
                reflectionAttribute.type = type;
                const name = matchType[2];
                reflectionAttribute.name = name;
                const matchSemantic = shaderCodeLine.match(_a40.semanticRegExp);
                if (matchSemantic) {
                  reflectionAttribute.semantic = matchSemantic[1];
                } else {
                  for (let [key, value] of this.__attributeSemanticsMap) {
                    if (name.match(new RegExp(key, "i"))) {
                      reflectionAttribute.semantic = value;
                    }
                  }
                }
              }
              this.__attributes.push(reflectionAttribute);
            }
            __matchVarying(shaderCodeLine, shaderStage) {
              if (shaderStage === "vertex") {
                return shaderCodeLine.match(/^(?![\/])[\t ]*(varying|out)[\t ]+.+;/);
              } else {
                return shaderCodeLine.match(/^(?![\/])[\t ]*(varying|in)[\t ]+.+;/);
              }
            }
            __addVarying(shaderCodeLine, shaderStage) {
              const reflectionVarying = {
                name: "",
                type: "float",
                inout: "in"
              };
              const matchType = shaderCodeLine.match(_a40.attributeAndVaryingTypeRegExp);
              if (matchType) {
                const type = matchType[1];
                reflectionVarying.type = type;
                const name = matchType[2];
                reflectionVarying.name = name;
                reflectionVarying.inout = shaderStage === "vertex" ? "out" : "in";
              }
              this.__varyings.push(reflectionVarying);
            }
            __addUniform(shaderCodeLine) {
              const reflectionUniform = {
                name: "",
                type: "float",
                semantic: "UNKNOWN"
              };
              const matchType = shaderCodeLine.match(_a40.uniformTypeRegExp);
              if (matchType) {
                const type = matchType[1];
                reflectionUniform.type = type;
                const name = matchType[2];
                reflectionUniform.name = name;
                const matchSemantics = shaderCodeLine.match(_a40.semanticRegExp);
                if (matchSemantics) {
                  reflectionUniform.semantic = matchSemantics[1];
                } else {
                  for (let [key, value] of this.__uniformSemanticsMap) {
                    if (name.match(new RegExp(key, "i"))) {
                      reflectionUniform.semantic = value;
                    }
                  }
                }
              }
              this.__uniforms.push(reflectionUniform);
            }
          }, __name(_a40, "Reflection"), _a40);
          exports2.default = Reflection;
          Reflection.attributeAndVaryingTypeRegExp = /[\t ]+(float|int|vec2|vec3|vec4|mat2|mat3|mat4|ivec2|ivec3|ivec4)[\t ]+(\w+);/;
          Reflection.uniformTypeRegExp = /[\t ]+(float|int|vec2|vec3|vec4|mat2|mat3|mat4|ivec2|ivec3|ivec4|sampler2D|samplerCube|sampler3D)[\t ]+(\w+);/;
          Reflection.semanticRegExp = /<.*semantic[\t ]*=[\t ]*(\w+).*>/;
          ;
        }, "./src/main/Reflection.ts")
      ),
      /***/
      "./src/main/ShaderEditor.ts": (
        /*!**********************************!*\
        !*** ./src/main/ShaderEditor.ts ***!
        \**********************************/
        /*! no static exports found */
        /***/
        /* @__PURE__ */ __name(function(module1, exports2, __webpack_require__) {
          "use strict";
          var _a40;
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          let ShaderEditor = (_a40 = class {
            static _insertDefinition(splittedShaderCode, definition) {
              const defStr = definition.replace(/#define[\t ]+/, "");
              splittedShaderCode.unshift(`#define ${defStr}`);
            }
            static _fillTemplate(shaderCode, templateObject) {
              const templateString = shaderCode.replace(/\/\*[\t ]*shaderity:[\t ]*(@{[\t ]*)(\S+)([\t ]*})[\t ]*\*\//g, "${this.$2}");
              const resultCode = new Function("return `" + templateString + "`;").call(templateObject);
              return resultCode;
            }
          }, __name(_a40, "ShaderEditor"), _a40);
          exports2.default = ShaderEditor;
        }, "./src/main/ShaderEditor.ts")
      ),
      /***/
      "./src/main/ShaderTransformer.ts": (
        /*!***************************************!*\
        !*** ./src/main/ShaderTransformer.ts ***!
        \***************************************/
        /*! no static exports found */
        /***/
        /* @__PURE__ */ __name(function(module1, exports2, __webpack_require__) {
          "use strict";
          var _a40;
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          let ShaderTransformer = (_a40 = class {
            /**
            * @private
            * Translate a GLSL ES3 shader code to a GLSL ES1 shader code
            */
            static _transformToGLSLES1(splittedShaderCode, isFragmentShader, embedErrorsInOutput) {
              this.__convertOrInsertVersionGLSLES1(splittedShaderCode);
              this.__removeES3Qualifier(splittedShaderCode, embedErrorsInOutput);
              this.__convertIn(splittedShaderCode, isFragmentShader);
              this.__convertOut(splittedShaderCode, isFragmentShader, embedErrorsInOutput);
              this.__removePrecisionForES3(splittedShaderCode);
              this.__convertTextureFunctionToES1(splittedShaderCode, isFragmentShader, embedErrorsInOutput);
              const transformedSplittedShaderCode = splittedShaderCode;
              return transformedSplittedShaderCode;
            }
            /**
            * @private
            * Translate a GLSL ES1 shader code to a GLSL ES3 shader code
            */
            static _transformToGLSLES3(splittedShaderCode, isFragmentShader) {
              this.__convertOrInsertVersionGLSLES3(splittedShaderCode);
              this.__convertAttribute(splittedShaderCode, isFragmentShader);
              this.__convertVarying(splittedShaderCode, isFragmentShader);
              this.__convertTextureCube(splittedShaderCode);
              this.__convertTexture2D(splittedShaderCode);
              this.__convertTexture2DProd(splittedShaderCode);
              this.__convertTexture3D(splittedShaderCode);
              this.__convertTexture3DProd(splittedShaderCode);
              const transformedSplittedShaderCode = splittedShaderCode;
              return transformedSplittedShaderCode;
            }
            /**
            * @private
            * Translate a GLSL shader code to a shader code of specified GLSL version
            */
            static _transformTo(version, splittedShaderCode, isFragmentShader, embedErrorsInOutput) {
              if (version.match(/webgl2|es3/i)) {
                return this._transformToGLSLES3(splittedShaderCode, isFragmentShader);
              } else if (version.match(/webgl1|es1/i)) {
                return this._transformToGLSLES1(splittedShaderCode, isFragmentShader, embedErrorsInOutput);
              } else {
                console.error("Invalid Version");
                return splittedShaderCode;
              }
            }
            /**
            * @private
            * If the first line contains version information, overwrite the first line with '#version 100'.
            * If not, add '#version 100' to the first line.
            *
            * Note: If the first line is commented out and the version information is written in the second or later line,
            * the appropriate version information will be added to the first line and the user-defined version information
            * in the second or later line will be removed.
            */
            static __convertOrInsertVersionGLSLES1(splittedShaderCode) {
              const reg = /^(?![\/])[\t ]*#[\t ]*version[\t ]+.*/;
              this.__removeFirstMatchingLine(splittedShaderCode, reg);
              splittedShaderCode.unshift("#version 100");
            }
            /**
            * @private
            * If the first line contains version information, overwrite the first line with '#version 300 es'.
            * If not, add '#version 300 es' to the first line.
            * In both cases, '#define GLSL_ES3' will be inserted in the second line.
            * Use the '#define GLSL_ES3' directive if you want to write a shader code that will only run in the case of webgl2.
            *
            * Note: If the first line is commented out and the version information is written in the second or later line,
            * the appropriate version information will be added to the first line and the user-defined version information
            * in the second or later line will be removed.
            */
            static __convertOrInsertVersionGLSLES3(splittedShaderCode) {
              const reg = /^(?![\/])[\t ]*#[\t ]*version[\t ]+.*/;
              this.__removeFirstMatchingLine(splittedShaderCode, reg);
              splittedShaderCode.unshift("#define GLSL_ES3");
              splittedShaderCode.unshift("#version 300 es");
            }
            /**
            * @private
            * Find the 'in' qualifier in the shader code and replace it with the GLSL ES1 qualifier('attribute' or 'varying')
            * This method directly replace the elements of the splittedShaderCode variable.
            */
            static __convertIn(splittedShaderCode, isFragmentShader) {
              const reg = /^(?![\/])[\t ]*in[\t ]+((highp|mediump|lowp|)[\t ]*\w+[\t ]*\w+[\t ]*;)/;
              let replaceFunc;
              if (isFragmentShader) {
                replaceFunc = /* @__PURE__ */ __name(function(match, p1) {
                  return "varying " + p1;
                }, "replaceFunc");
              } else {
                replaceFunc = /* @__PURE__ */ __name(function(match, p1) {
                  return "attribute " + p1;
                }, "replaceFunc");
              }
              this.__replaceLine(splittedShaderCode, reg, replaceFunc);
            }
            /**
            * @private
            * Find the "out" qualifier in the shader code and modify the shader code.
            * If the shader stage is vertex, the "out" qualifiers will be replaced by "varying" qualifier.
            * If the shader stage is fragment and the shader has "out" qualifiers, the "out" qualifiers will
            * be deleted and the variable is used to assign a value to gl_FragColor.
            * This method directly replace the elements of the splittedShaderCode variable.
            */
            static __convertOut(splittedShaderCode, isFragmentShader, embedErrorsInOutput) {
              if (isFragmentShader) {
                const variableName = this.__removeOutQualifier(splittedShaderCode, embedErrorsInOutput);
                if (variableName == null) {
                  return;
                }
                this.__addGLFragColor(variableName, splittedShaderCode, embedErrorsInOutput);
              } else {
                const reg = /^(?![\/])[\t ]*out[\t ]+((highp|mediump|lowp|)[\t ]*\w+[\t ]*\w+[\t ]*;)/;
                const replaceFunc = /* @__PURE__ */ __name(function(match, p1) {
                  return "varying " + p1;
                }, "replaceFunc");
                this.__replaceLine(splittedShaderCode, reg, replaceFunc);
              }
            }
            /**
            * @private
            * This method is a part of __convertOut method.
            * This method deletes the "out" qualifiers and adds the line for assigning to gl_FragColor.
            * If the shader does not have the "out" qualifiers, this method does nothing.
            */
            static __removeOutQualifier(splittedShaderCode, embedErrorsInOutput) {
              const reg = /^(?![\/])[\t ]*out[\t ]+((highp|mediump|lowp|)[\t ]*\w+[\t ]*(\w+)[\t ]*;)/;
              let variableName;
              for (let i2 = 0; i2 < splittedShaderCode.length; i2++) {
                const match = splittedShaderCode[i2].match(reg);
                if (match) {
                  splittedShaderCode[i2] = match[1];
                  variableName = match[3];
                  break;
                }
              }
              return variableName;
            }
            static __addGLFragColor(variableName, splittedShaderCode, embedErrorsInOutput) {
              const closeBracketReg = /(.*)\}[\n\t ]*$/;
              const returnReg = /[\n\t ]*return[\n\t ]*;/;
              const mainFuncStartReg = /(^|^(?![\/])[\t\n ]+)void[\t\n ]+main([\t\n ]|\(|$)/;
              const fragColorCode = `  gl_FragColor = ${variableName};`;
              let setGlFragColorInLastLine = false;
              for (let i2 = splittedShaderCode.length - 1; i2 >= 0; i2--) {
                const line = splittedShaderCode[i2];
                if (!setGlFragColorInLastLine && line.match(closeBracketReg)) {
                  splittedShaderCode[i2] = line.replace(closeBracketReg, `$1
${fragColorCode}
}
`);
                  setGlFragColorInLastLine = true;
                }
                if (line.match(returnReg)) {
                  splittedShaderCode.splice(i2, 0, fragColorCode);
                }
                if (line.match(mainFuncStartReg)) {
                  break;
                }
              }
              if (!setGlFragColorInLastLine) {
                const errorMessage = "__removeOutQualifier: Not found the closing brackets for the main function";
                this.__outError(splittedShaderCode, splittedShaderCode.length, errorMessage, embedErrorsInOutput);
              }
            }
            /**
            * @private
            * Find the qualifier for es3 only in the shader code and remove it
            * This method directly replace the elements of the splittedShaderCode variable.
            */
            static __removeES3Qualifier(splittedShaderCode, embedErrorsInOutput) {
              this.__removeVaryingQualifier(splittedShaderCode, embedErrorsInOutput);
              this.__removeLayout(splittedShaderCode);
            }
            /**
            * @private
            * Find the "flat" and "smooth" qualifier in the shader code and remove it
            */
            static __removeVaryingQualifier(splittedShaderCode, embedErrorsInOutput) {
              const reg = /^(?![\/])[\t ]*(flat|smooth)[\t ]*((in|out)[\t ]+.*)/;
              const errorMessage = "__removeVaryingQualifier: glsl es1 does not support flat qualifier";
              for (let i2 = 0; i2 < splittedShaderCode.length; i2++) {
                splittedShaderCode[i2] = splittedShaderCode[i2].replace(reg, (match, p1, p2) => {
                  if (p1 === "flat") {
                    this.__outError(splittedShaderCode, i2 + 1, errorMessage, embedErrorsInOutput);
                    return match;
                  }
                  return p2;
                });
              }
            }
            /**
            * @private
            * Find the "layout" qualifier in the shader code and remove it
            */
            static __removeLayout(splittedShaderCode) {
              const reg = /^(?![\/])[\t ]*layout[\t ]*\([\t ]*location[\t ]*\=[\t ]*\d[\t ]*\)[\t ]+/g;
              this.__replaceLine(splittedShaderCode, reg, "");
            }
            /**
            * @private
            * Find the "precision" qualifier in the shader code and remove it if the "precision" qualifier is valid for only GLSL ES3
            * This method directly replace the elements of the splittedShaderCode variable.
            */
            static __removePrecisionForES3(splittedShaderCode) {
              const reg = /^(?![\/])[\t ]*precision[\t ]+(highp|mediump|lowp)[\t ]+(\w+)[\t ]*;/;
              for (let i2 = 0; i2 < splittedShaderCode.length; i2++) {
                const match = splittedShaderCode[i2].match(reg);
                if (match != null) {
                  if (match[2] === "int" || match[2] === "float" || match[2] === "sampler2D" || match[2] === "samplerCube") {
                    continue;
                  } else {
                    splittedShaderCode.splice(i2--, 1);
                  }
                }
              }
            }
            /**
            * @private
            * Find the "texture" and "textureProj" method in the shader code and
            * replace it with the GLSL ES1 method('texture2D', 'texture2D', and so on)
            * This method directly replace the elements of the splittedShaderCode variable.
            */
            static __convertTextureFunctionToES1(splittedShaderCode, isFragmentShader, embedErrorsInOutput) {
              var _a41, _b;
              const sbl = this.__regSymbols();
              const regTextureProj = new RegExp(`(${sbl}+)textureProj(Lod|)(${sbl}+)`, "g");
              const regTexture = new RegExp(`(${sbl}+)texture(Lod|)(${sbl}+)`, "g");
              let argumentSamplerMap;
              const uniformSamplerMap = this.__createUniformSamplerMap(splittedShaderCode, embedErrorsInOutput);
              for (let i2 = 0; i2 < splittedShaderCode.length; i2++) {
                const line = splittedShaderCode[i2];
                const matchTextureProj = line.match(/textureProj(Lod|)[\t ]*\([\t ]*(\w+),/);
                if (matchTextureProj) {
                  argumentSamplerMap = argumentSamplerMap !== null && argumentSamplerMap !== void 0 ? argumentSamplerMap : this.__createArgumentSamplerMap(splittedShaderCode, i2, embedErrorsInOutput);
                  const isLodMethod = matchTextureProj[1] === "Lod";
                  const extensionStr = isFragmentShader && isLodMethod ? `EXT` : ``;
                  const variableName = matchTextureProj[2];
                  const samplerType = (_a41 = argumentSamplerMap === null || argumentSamplerMap === void 0 ? void 0 : argumentSamplerMap.get(variableName)) !== null && _a41 !== void 0 ? _a41 : uniformSamplerMap.get(variableName);
                  if (samplerType != null) {
                    if (samplerType === "sampler2D") {
                      splittedShaderCode[i2] = splittedShaderCode[i2].replace(regTextureProj, `$1texture2DProj$2${extensionStr}$3`);
                    } else {
                      const errorMessage = "__convertTextureFunctionToES1: do not support " + samplerType + " type";
                      this.__outError(splittedShaderCode, i2, errorMessage, embedErrorsInOutput);
                    }
                  }
                  continue;
                }
                const matchTexture = line.match(/texture(Lod|)[\t ]*\([\t ]*(\w+),/);
                if (matchTexture) {
                  argumentSamplerMap = argumentSamplerMap !== null && argumentSamplerMap !== void 0 ? argumentSamplerMap : this.__createArgumentSamplerMap(splittedShaderCode, i2, embedErrorsInOutput);
                  const isLodMethod = matchTexture[1] === "Lod";
                  const extensionStr = isFragmentShader && isLodMethod ? `EXT` : ``;
                  const variableName = matchTexture[2];
                  const samplerType = (_b = argumentSamplerMap === null || argumentSamplerMap === void 0 ? void 0 : argumentSamplerMap.get(variableName)) !== null && _b !== void 0 ? _b : uniformSamplerMap.get(variableName);
                  if (samplerType != null) {
                    let textureFunc;
                    if (samplerType === "sampler2D") {
                      textureFunc = "texture2D";
                    } else if (samplerType === "samplerCube") {
                      textureFunc = "textureCube";
                    } else {
                      textureFunc = "";
                      const errorMessage = "__convertTextureFunctionToES1: do not support " + samplerType + " type";
                      this.__outError(splittedShaderCode, i2, errorMessage, embedErrorsInOutput);
                    }
                    if (textureFunc !== "") {
                      splittedShaderCode[i2] = splittedShaderCode[i2].replace(regTexture, `$1${textureFunc}$2${extensionStr}$3`);
                    }
                  }
                  continue;
                }
                const isBlockEnd = !!line.match(/\}/);
                if (isBlockEnd) {
                  argumentSamplerMap = void 0;
                }
              }
            }
            /**
            * @private
            * This method finds uniform declarations of sampler types in the shader and
            * creates a map with variable names as keys and types as values.
            */
            static __createUniformSamplerMap(splittedShaderCode, embedErrorsInOutput) {
              const uniformSamplerMap = /* @__PURE__ */ new Map();
              for (let i2 = 0; i2 < splittedShaderCode.length; i2++) {
                const line = splittedShaderCode[i2];
                const match = line.match(/^(?![\/])[\t ]*uniform*[\t ]*(highp|mediump|lowp|)[\t ]*(sampler\w+)[\t ]+(\w+)/);
                if (match) {
                  const samplerType = match[2];
                  const name = match[3];
                  if (uniformSamplerMap.get(name)) {
                    const errorMessage = "__createUniformSamplerMap: duplicate variable name";
                    this.__outError(splittedShaderCode, i2, errorMessage, embedErrorsInOutput);
                  }
                  uniformSamplerMap.set(name, samplerType);
                }
              }
              return uniformSamplerMap;
            }
            /**
            * @private
            * This method finds sampler types from the function arguments and
            * creates a map with variable names as keys and types as values.
            */
            static __createArgumentSamplerMap(splittedShaderCode, lineIndex, embedErrorsInOutput) {
              var _a41, _b;
              const argumentSamplerMap = /* @__PURE__ */ new Map();
              for (let i2 = lineIndex; i2 >= 0; i2--) {
                const line = splittedShaderCode[i2];
                const isBlockStartLine = !!line.match(/\{/);
                if (!isBlockStartLine) {
                  continue;
                }
                const bracketSectionCode = this.__getBracketSection(splittedShaderCode, i2);
                const innerBracketSectionCode = (_a41 = bracketSectionCode.match(/.*\((.*)\)/)) === null || _a41 === void 0 ? void 0 : _a41[1];
                if (innerBracketSectionCode == null) {
                  return;
                }
                const variableCandidates = innerBracketSectionCode.split(",");
                const samplerTypeDefinitionReg = /[\n\t ]*(highp|mediump|lowp|)[\n\t ]*(sampler\w+)[\n\t ]*(\w+)[\n\t ]*/;
                const isFunctionBracket = !!((_b = variableCandidates[0].match(samplerTypeDefinitionReg)) !== null && _b !== void 0 ? _b : variableCandidates[0].match(/^[\n\t ]*$/));
                if (!isFunctionBracket) {
                  continue;
                }
                for (const variableCandidate of variableCandidates) {
                  const samplerVariableMatch = variableCandidate.match(samplerTypeDefinitionReg);
                  if (samplerVariableMatch == null) {
                    continue;
                  }
                  const samplerType = samplerVariableMatch[2];
                  const name = samplerVariableMatch[3];
                  if (argumentSamplerMap.get(name)) {
                    const errorMessage = "__createArgumentSamplerMap: duplicate variable name";
                    this.__outError(splittedShaderCode, i2, errorMessage, embedErrorsInOutput);
                  }
                  argumentSamplerMap.set(name, samplerType);
                }
                break;
              }
              return argumentSamplerMap;
            }
            /**
            * @private
            * This method returns the part enclosed in brackets(= '()').
            * For example, you can get lines that contain function arguments, conditional expressions for if statements, etc.
            */
            static __getBracketSection(splittedShaderCode, bracketEndIndex) {
              let bracketStartIndex = 0;
              for (let j = bracketEndIndex; j >= 0; j--) {
                const line = splittedShaderCode[j];
                const isBracketStartMatch = !!line.match(/\(/);
                if (isBracketStartMatch) {
                  bracketStartIndex = j;
                  break;
                }
              }
              let containBracketCode = "";
              for (let j = bracketStartIndex; j <= bracketEndIndex; j++) {
                containBracketCode += splittedShaderCode[j];
              }
              return containBracketCode;
            }
            /**
            * @private
            * Find the 'attribute' qualifier in the vertex shader code and replace it with the GLSL ES3 qualifier('in')
            * This method directly replace the elements of the splittedShaderCode variable.
            */
            static __convertAttribute(splittedShaderCode, isFragmentShader) {
              if (isFragmentShader) {
                return;
              }
              const reg = /^(?![\/])[\t ]*attribute[\t ]+/g;
              const replaceStr = "in ";
              this.__replaceLine(splittedShaderCode, reg, replaceStr);
            }
            /**
            * @private
            * Find the 'varying' qualifier in the shader code and replace it with the GLSL ES3 qualifier('in' or 'out')
            * This method directly replace the elements of the splittedShaderCode variable.
            */
            static __convertVarying(splittedShaderCode, isFragmentShader) {
              const reg = /^(?![\/])[\t ]*varying[\t ]+/g;
              const replaceStr = isFragmentShader ? "in " : "out ";
              this.__replaceLine(splittedShaderCode, reg, replaceStr);
            }
            /**
            * @private
            * Find the 'textureCube' method in the shader code and replace it with the GLSL ES3 method('texture')
            * This method directly replace the elements of the splittedShaderCode variable.
            */
            static __convertTextureCube(splittedShaderCode) {
              const sbl = this.__regSymbols();
              const reg = new RegExp(`(${sbl}+)(textureCube)(${sbl}+)`, "g");
              const replaceStr = "texture";
              this.__replaceLine(splittedShaderCode, reg, "$1" + replaceStr + "$3");
            }
            /**
            * @private
            * Find the 'texture2D' method in the shader code and replace it with the GLSL ES3 method('texture')
            * This method directly replace the elements of the splittedShaderCode variable.
            */
            static __convertTexture2D(splittedShaderCode) {
              const sbl = this.__regSymbols();
              const reg = new RegExp(`(${sbl}+)(texture2D)(${sbl}+)`, "g");
              const replaceStr = "texture";
              this.__replaceLine(splittedShaderCode, reg, "$1" + replaceStr + "$3");
            }
            /**
            * @private
            * Find the 'texture2DProj' method in the shader code and replace it with the GLSL ES3 method('textureProj')
            * This method directly replace the elements of the splittedShaderCode variable.
            */
            static __convertTexture2DProd(splittedShaderCode) {
              const sbl = this.__regSymbols();
              const reg = new RegExp(`(${sbl}+)(texture2DProj)(${sbl}+)`, "g");
              const replaceStr = "textureProj";
              this.__replaceLine(splittedShaderCode, reg, "$1" + replaceStr + "$3");
            }
            /**
            * @private
            * Find the 'texture3D' method in the shader code and replace it with the GLSL ES3 method('texture')
            * This method directly replace the elements of the splittedShaderCode variable.
            */
            static __convertTexture3D(splittedShaderCode) {
              const sbl = this.__regSymbols();
              const reg = new RegExp(`(${sbl}+)(texture3D)(${sbl}+)`, "g");
              const replaceStr = "texture";
              this.__replaceLine(splittedShaderCode, reg, "$1" + replaceStr + "$3");
            }
            /**
            * @private
            * Find the 'texture3DProj' method in the shader code and replace it with the GLSL ES3 method('textureProj')
            * This method directly replace the elements of the splittedShaderCode variable.
            */
            static __convertTexture3DProd(splittedShaderCode) {
              const sbl = this.__regSymbols();
              const reg = new RegExp(`(${sbl}+)(texture3DProj)(${sbl}+)`, "g");
              const replaceStr = "textureProj";
              this.__replaceLine(splittedShaderCode, reg, "$1" + replaceStr + "$3");
            }
            static __regSymbols() {
              return `[!"#$%&'()*+-.,/:;<=>?@[\\]^\`{|}~	
 ]`;
            }
            static __replaceLine(splittedShaderCode, reg, replacement) {
              for (let i2 = 0; i2 < splittedShaderCode.length; i2++) {
                splittedShaderCode[i2] = splittedShaderCode[i2].replace(reg, replacement);
              }
            }
            static __removeFirstMatchingLine(splittedShaderCode, reg) {
              for (let i2 = 0; i2 < splittedShaderCode.length; i2++) {
                if (splittedShaderCode[i2].match(reg)) {
                  splittedShaderCode.splice(i2, 1);
                  break;
                }
              }
            }
            static __outError(splittedShaderCode, lineIndex, errorMessage, embedErrorsInOutput) {
              if (embedErrorsInOutput) {
                const shaderOutputMessage = `// line ${lineIndex}: ${errorMessage}
`;
                const closeBracketReg = /(.*)\}[\n\t ]*$/;
                for (let i2 = splittedShaderCode.length - 1; i2 >= 0; i2--) {
                  const line = splittedShaderCode[i2];
                  if (line.match(closeBracketReg)) {
                    break;
                  }
                  if (splittedShaderCode[i2] === shaderOutputMessage) {
                    return;
                  }
                }
                console.error(errorMessage);
                splittedShaderCode.push(shaderOutputMessage);
              } else {
                throw new Error(errorMessage);
              }
            }
          }, __name(_a40, "ShaderTransformer"), _a40);
          exports2.default = ShaderTransformer;
        }, "./src/main/ShaderTransformer.ts")
      ),
      /***/
      "./src/main/Shaderity.ts": (
        /*!*******************************!*\
        !*** ./src/main/Shaderity.ts ***!
        \*******************************/
        /*! no static exports found */
        /***/
        /* @__PURE__ */ __name(function(module1, exports2, __webpack_require__) {
          "use strict";
          var _a40;
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
              "default": mod
            };
          };
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          const Reflection_1 = __importDefault(__webpack_require__(
            /*! ./Reflection */
            "./src/main/Reflection.ts"
          ));
          const ShaderTransformer_1 = __importDefault(__webpack_require__(
            /*! ./ShaderTransformer */
            "./src/main/ShaderTransformer.ts"
          ));
          const ShaderEditor_1 = __importDefault(__webpack_require__(
            /*! ./ShaderEditor */
            "./src/main/ShaderEditor.ts"
          ));
          const Utility_1 = __importDefault(__webpack_require__(
            /*! ./Utility */
            "./src/main/Utility.ts"
          ));
          const ShaderityObjectCreator_1 = __importDefault(__webpack_require__(
            /*! ./ShaderityObjectCreator */
            "./src/main/ShaderityObjectCreator.ts"
          ));
          const PreProcessor_1 = __importDefault(__webpack_require__(
            /*! ./PreProcessor */
            "./src/main/PreProcessor.ts"
          ));
          let Shaderity4 = (_a40 = class {
            // =========================================================================================================
            // shader transformation functions
            // =========================================================================================================
            /**
            * Translate a GLSL ES3 shader code to a GLSL ES1 shader code
            * @param obj Shaderity object to translate to glsl es1
            * @param embedErrorsInOutput If true, when there is an error in the conversion,
            *    the error and the number of lines are output at the bottom of the return
            *    value ShaderityObject.code. If false, throw an error.
            * @returns ShaderityObject whose code property is the shader code for GLSL ES1
            */
            static transformToGLSLES1(obj, embedErrorsInOutput = false) {
              const splittedShaderCode = Utility_1.default._splitByLineFeedCode(obj.code);
              const transformedSplittedShaderCode = ShaderTransformer_1.default._transformToGLSLES1(splittedShaderCode, obj.isFragmentShader, embedErrorsInOutput);
              const resultCode = Utility_1.default._joinSplittedLine(transformedSplittedShaderCode);
              const resultObj = {
                code: resultCode,
                shaderStage: obj.shaderStage,
                isFragmentShader: obj.isFragmentShader
              };
              return resultObj;
            }
            /**
            * Translate a GLSL ES1 shader code to a GLSL ES3 shader code
            */
            static transformToGLSLES3(obj) {
              const splittedShaderCode = Utility_1.default._splitByLineFeedCode(obj.code);
              const transformedSplittedShaderCode = ShaderTransformer_1.default._transformToGLSLES3(splittedShaderCode, obj.isFragmentShader);
              const resultCode = Utility_1.default._joinSplittedLine(transformedSplittedShaderCode);
              const resultObj = {
                code: resultCode,
                shaderStage: obj.shaderStage,
                isFragmentShader: obj.isFragmentShader
              };
              return resultObj;
            }
            /**
            * Translate a GLSL shader code to a shader code of specified GLSL version
            */
            static transformTo(version, obj, embedErrorsInOutput = false) {
              const splittedShaderCode = Utility_1.default._splitByLineFeedCode(obj.code);
              const transformedSplittedShaderCode = ShaderTransformer_1.default._transformTo(version, splittedShaderCode, obj.isFragmentShader, embedErrorsInOutput);
              const resultCode = Utility_1.default._joinSplittedLine(transformedSplittedShaderCode);
              const resultObj = {
                code: resultCode,
                shaderStage: obj.shaderStage,
                isFragmentShader: obj.isFragmentShader
              };
              return resultObj;
            }
            static processPragma(obj) {
              const splittedShaderCode = Utility_1.default._splitByLineFeedCode(obj.code);
              const transformedSplittedShaderCode = PreProcessor_1.default.process(splittedShaderCode);
              const resultCode = Utility_1.default._joinSplittedLine(transformedSplittedShaderCode);
              const resultObj = {
                code: resultCode,
                shaderStage: obj.shaderStage,
                isFragmentShader: obj.isFragmentShader
              };
              return resultObj;
            }
            // =========================================================================================================
            // shaderity object creation functions
            // =========================================================================================================
            /**
            * Create an instance to create shaderity object.
            */
            static createShaderityObjectCreator(shaderStage) {
              return new ShaderityObjectCreator_1.default(shaderStage);
            }
            // =========================================================================================================
            // shader edit functions
            // =========================================================================================================
            /**
            * Find the following template pattern in the shader code and replace key to value
            * @param templateObject An object that represents the string before and after the replacement
            * The key can be a string or an object. If an object is used as the key,
            * the key in the pattern of shaderCode must also match the object.
            * For example, if templateObject is
               {
                   sample {
                       sampleA: 0
                   }
               }
            * then the key in a shader code is sample.sampleA.
            */
            // The template pattern is	/* shaderity: @{key} */
            static fillTemplate(obj, arg) {
              const copy = this.__copyShaderityObject(obj);
              copy.code = ShaderEditor_1.default._fillTemplate(copy.code, arg);
              return copy;
            }
            /**
            * Insert define directive
            */
            static insertDefinition(obj, definition) {
              const copy = this.__copyShaderityObject(obj);
              const splittedShaderCode = Utility_1.default._splitByLineFeedCode(obj.code);
              ShaderEditor_1.default._insertDefinition(splittedShaderCode, definition);
              copy.code = Utility_1.default._joinSplittedLine(splittedShaderCode);
              return copy;
            }
            // =========================================================================================================
            // reflection functions
            // =========================================================================================================
            /**
            * Create an instance to get the attribute, varying, and uniform information from a shader code of the shaderity.
            * To get these information, you need to call reflection.reflect method.
            */
            static createReflectionObject(obj) {
              const splittedShaderCode = Utility_1.default._splitByLineFeedCode(obj.code);
              const reflection = new Reflection_1.default(splittedShaderCode, obj.shaderStage);
              return reflection;
            }
            // =========================================================================================================
            // private functions
            // =========================================================================================================
            static __copyShaderityObject(obj) {
              const copiedObj = {
                code: obj.code,
                shaderStage: obj.shaderStage,
                isFragmentShader: obj.isFragmentShader
              };
              return copiedObj;
            }
          }, __name(_a40, "Shaderity"), _a40);
          exports2.default = Shaderity4;
        }, "./src/main/Shaderity.ts")
      ),
      /***/
      "./src/main/ShaderityObjectCreator.ts": (
        /*!********************************************!*\
        !*** ./src/main/ShaderityObjectCreator.ts ***!
        \********************************************/
        /*! no static exports found */
        /***/
        /* @__PURE__ */ __name(function(module1, exports2, __webpack_require__) {
          "use strict";
          var _a40;
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
              "default": mod
            };
          };
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          const Utility_1 = __importDefault(__webpack_require__(
            /*! ./Utility */
            "./src/main/Utility.ts"
          ));
          let ShaderityObjectCreator = (_a40 = class {
            constructor(shaderStage) {
              this.__functionIdCount = 0;
              this.__defineDirectiveNames = [];
              this.__extensions = [];
              this.__globalPrecision = {
                int: "highp",
                float: "highp",
                sampler2D: "highp",
                samplerCube: "highp",
                sampler3D: "highp",
                sampler2DArray: "highp",
                isampler2D: "highp",
                isamplerCube: "highp",
                isampler3D: "highp",
                isampler2DArray: "highp",
                usampler2D: "highp",
                usamplerCube: "highp",
                usampler3D: "highp",
                usampler2DArray: "highp",
                sampler2DShadow: "highp",
                samplerCubeShadow: "highp",
                sampler2DArrayShadow: "highp"
              };
              this.__structDefinitions = [];
              this.__globalConstantValues = [];
              this.__globalConstantStructValues = [];
              this.__attributes = [];
              this.__varyings = [];
              this.__uniforms = [];
              this.__uniformStructs = [];
              this.__uniformBufferObjects = [];
              this.__functions = [];
              this.__mainFunctionCode = "void main() {}";
              this.__outputColorVariableName = "renderTarget0";
              this.__shaderStage = shaderStage;
            }
            // =========================================================================================================
            // add parameters functions
            // =========================================================================================================
            addDefineDirective(defineDirectiveName) {
              const isDuplicate = this.__defineDirectiveNames.some((name) => name === defineDirectiveName);
              if (isDuplicate) {
                console.warn("addDefineDirective: this define directive is already set");
                return;
              }
              this.__defineDirectiveNames.push(defineDirectiveName);
            }
            addExtension(extensionName, behavior = "enable") {
              const isDuplicate = this.__extensions.some((extension) => extension.extensionName === extensionName);
              if (isDuplicate) {
                console.warn("addExtension: this extension is already set");
                return;
              }
              this.__extensions.push({
                extensionName,
                behavior
              });
            }
            // only define types
            addStructDefinition(structName, memberObjects) {
              const isDuplicate = this.__structDefinitions.some((structDefinition) => structDefinition.structName === structName);
              if (isDuplicate) {
                console.error(`addStructDefinition: duplicate struct type name ${structName}`);
                return;
              }
              this.__structDefinitions.push({
                structName,
                memberObjects
              });
            }
            addGlobalConstantValue(variableName, type, values) {
              const isDuplicate = this.__globalConstantValues.some((globalConstantValue) => globalConstantValue.variableName === variableName);
              if (isDuplicate) {
                console.error(`addGlobalConstantValue: duplicate variable name ${variableName}`);
                return;
              }
              const isValidComponentNumber = Utility_1.default._isValidComponentCount(type, values);
              if (!isValidComponentNumber) {
                console.error(`addGlobalConstantValue: the component count of ${variableName} is invalid`);
                return;
              }
              const isIntType = Utility_1.default._isIntType(type);
              if (isIntType) {
                const existNonIntegerValue = _a40.__existNonIntegerValue(values);
                if (existNonIntegerValue) {
                  console.warn(`addGlobalConstantValue: non-integer value is set to ${variableName}`);
                }
              }
              this.__globalConstantValues.push({
                variableName,
                type,
                values
              });
            }
            // need to define struct by the addStructDefinition method
            // validate that the corresponding structure is defined by the __createGlobalConstantStructValueShaderCode method
            addGlobalConstantStructValue(structName, variableName, values) {
              const isDuplicate = this.__globalConstantStructValues.some((structValue) => structValue.variableName === variableName);
              if (isDuplicate) {
                console.error(`addGlobalConstantStructValue: duplicate variable name ${variableName}`);
                return;
              }
              this.__globalConstantStructValues.push({
                variableName,
                structName,
                values
              });
            }
            addAttributeDeclaration(variableName, type, options) {
              if (this.__shaderStage !== "vertex") {
                console.error("addAttribute: this method is for vertex shader only");
                return;
              }
              const isDuplicate = this.__attributes.some((attribute) => attribute.variableName === variableName);
              if (isDuplicate) {
                console.error(`addAttribute: duplicate variable name ${variableName}`);
                return;
              }
              this.__attributes.push({
                variableName,
                type,
                precision: options === null || options === void 0 ? void 0 : options.precision,
                location: options === null || options === void 0 ? void 0 : options.location
              });
            }
            addVaryingDeclaration(variableName, type, options) {
              const isDuplicate = this.__varyings.some((varying) => varying.variableName === variableName);
              if (isDuplicate) {
                console.error(`addVarying: duplicate variable name ${variableName}`);
                return;
              }
              const isIntType = Utility_1.default._isIntType(type);
              let interpolationType = options === null || options === void 0 ? void 0 : options.interpolationType;
              if (isIntType && interpolationType !== "flat") {
                if (interpolationType != null) {
                  console.error(`addVarying: the interpolationType must be flat for integer types`);
                  return;
                } else {
                  console.warn(`addVarying: set the interpolationType of integer types to flat to avoid compilation error`);
                  interpolationType = "flat";
                }
              }
              this.__varyings.push({
                variableName,
                type,
                precision: options === null || options === void 0 ? void 0 : options.precision,
                interpolationType
              });
            }
            addUniformDeclaration(variableName, type, options) {
              const isDuplicate = this.__uniforms.some((uniform) => uniform.variableName === variableName);
              if (isDuplicate) {
                console.error(`addUniform: duplicate variable name ${variableName}`);
                return;
              }
              if (type === "bool" && (options === null || options === void 0 ? void 0 : options.precision) != null) {
                console.warn(`addUniform: remove the specification of precision for bool type to avoid compilation error`);
                options.precision = void 0;
              }
              this.__uniforms.push({
                variableName,
                type,
                precision: options === null || options === void 0 ? void 0 : options.precision
              });
            }
            // need to define struct by the addStructDefinition method
            addUniformStructDeclaration(structName, variableName) {
              const isDuplicate = this.__uniformStructs.some((uniformStruct) => uniformStruct.variableName === variableName);
              if (isDuplicate) {
                console.error(`addUniformStructDeclaration: duplicate variable name ${variableName}`);
                return;
              }
              this.__uniformStructs.push({
                variableName,
                structName
              });
            }
            // for es3
            addUniformBufferObjectDeclaration(blockName, variableObjects, options) {
              const isDuplicateBlockName = this.__uniformBufferObjects.some((ubo) => ubo.blockName === blockName);
              if (isDuplicateBlockName) {
                console.error(`addUniformBufferObjectDeclaration: duplicate block name ${blockName}`);
                return;
              }
              for (const ubo of this.__uniformBufferObjects) {
                for (const uboVariableObject of ubo.variableObjects) {
                  for (const variableObject of variableObjects) {
                    if (uboVariableObject.variableName === variableObject.variableName) {
                      console.error(`addUniformBufferObjectDeclaration: duplicate variable name ${variableObject.variableName}`);
                      return;
                    }
                  }
                }
              }
              this.__uniformBufferObjects.push({
                blockName,
                variableObjects,
                instanceName: options === null || options === void 0 ? void 0 : options.instanceName
              });
            }
            // the return value Id is a value to delete the function
            // the main function is defined (updated) by the updateMainFunction method
            addFunctionDefinition(functionCode, options) {
              var _a41, _b;
              const functionId = this.__functionIdCount++;
              const dependencyLevel = (_a41 = options === null || options === void 0 ? void 0 : options.dependencyLevel) !== null && _a41 !== void 0 ? _a41 : 0;
              this.__functions[dependencyLevel] = (_b = this.__functions[dependencyLevel]) !== null && _b !== void 0 ? _b : [];
              this.__functions[dependencyLevel].push({
                functionCode,
                functionId
              });
              return functionId;
            }
            // =========================================================================================================
            // update parameters functions
            // =========================================================================================================
            updateGlobalPrecision(precision) {
              Object.assign(this.__globalPrecision, precision);
            }
            updateStructDefinition(structName, memberObjects) {
              const matchedIndex = this.__structDefinitions.findIndex((structDefinition) => structDefinition.structName === structName);
              if (matchedIndex === -1) {
                console.error(`updateStructDefinition: the struct type name ${structName} is not exist`);
                return;
              }
              this.__structDefinitions[matchedIndex].memberObjects = memberObjects;
            }
            updateGlobalConstantValue(variableName, values) {
              const matchedIndex = this.__globalConstantValues.findIndex((globalConstantValue) => globalConstantValue.variableName === variableName);
              if (matchedIndex === -1) {
                console.warn(`updateGlobalConstantValue: the variable name ${variableName} is not exist`);
                return;
              }
              const type = this.__globalConstantValues[matchedIndex].type;
              const isValidComponentNumber = Utility_1.default._isValidComponentCount(type, values);
              if (!isValidComponentNumber) {
                console.error("updateGlobalConstantValue: the component count is invalid");
                return;
              }
              const isIntType = Utility_1.default._isIntType(type);
              if (isIntType) {
                const existNonIntegerValue = _a40.__existNonIntegerValue(values);
                if (existNonIntegerValue) {
                  console.warn(`updateGlobalConstantValue: the ${variableName} has a non-integer value.`);
                }
              }
              this.__globalConstantValues[matchedIndex].values = values;
            }
            updateGlobalConstantStructValue(variableName, values) {
              const matchedIndex = this.__globalConstantStructValues.findIndex((structValue) => structValue.variableName === variableName);
              if (matchedIndex === -1) {
                console.error(`updateGlobalConstantStructValue:  the variable name ${variableName} is not exist`);
                return;
              }
              this.__globalConstantStructValues[matchedIndex].values = values;
            }
            updateMainFunction(mainFunctionCodeInner) {
              this.__mainFunctionCode = mainFunctionCodeInner;
            }
            // specify the name of the output color variable from the main function in the fragment shader.
            // users have to assign the result of fragment shader calculation to this variable.
            updateOutputColorVariableName(outputColorVariableName) {
              if (this.__shaderStage !== "fragment") {
                console.error("updateOutputColorVariableName: this method is for fragment shader only");
                return;
              }
              if (outputColorVariableName.length === 0) {
                console.error("updateOutputColorVariableName: invalid outColorVariableName");
                return;
              }
              this.__outputColorVariableName = outputColorVariableName;
            }
            // =========================================================================================================
            // remove parameters functions
            // =========================================================================================================
            removeDefineDirective(defineDirectiveName) {
              const matchedIndex = this.__defineDirectiveNames.indexOf(defineDirectiveName);
              if (matchedIndex === -1) {
                console.warn("removedDefineDirective: this define directive is not exist");
                return;
              }
              this.__defineDirectiveNames.splice(matchedIndex, 1);
            }
            removeExtension(extensionName) {
              const matchedIndex = this.__extensions.findIndex((extension) => extension.extensionName === extensionName);
              if (matchedIndex === -1) {
                console.warn("removeExtension: this extension is not exist");
                return;
              }
              this.__extensions.splice(matchedIndex, 1);
            }
            removeStructDefinition(structName) {
              const matchedIndex = this.__structDefinitions.findIndex((structDefinition) => structDefinition.structName === structName);
              if (matchedIndex === -1) {
                console.error(`removeStructDefinition: the struct type name ${structName} is not exist`);
                return;
              }
              this.__structDefinitions.splice(matchedIndex, 1);
            }
            removeGlobalConstantValue(variableName) {
              const matchedIndex = this.__globalConstantValues.findIndex((globalConstantValue) => globalConstantValue.variableName === variableName);
              if (matchedIndex === -1) {
                console.warn(`removeGlobalConstantValue: the variable name ${variableName} is not exist`);
                return;
              }
              this.__globalConstantValues.splice(matchedIndex, 1);
            }
            removeGlobalConstantStructValue(variableName) {
              const matchedIndex = this.__globalConstantStructValues.findIndex((structValue) => structValue.variableName === variableName);
              if (matchedIndex === -1) {
                console.error(`updateGlobalConstantStructValue:  the variable name ${variableName} is not exist`);
                return;
              }
              this.__globalConstantStructValues.splice(matchedIndex, 1);
            }
            removeAttributeDeclaration(variableName) {
              const matchedIndex = this.__attributes.findIndex((attribute) => attribute.variableName === variableName);
              if (matchedIndex === -1) {
                console.warn(`removeAttribute: the variable name ${variableName} is not exist`);
                return;
              }
              this.__attributes.splice(matchedIndex, 1);
            }
            removeVaryingDeclaration(variableName) {
              const matchedIndex = this.__varyings.findIndex((varying) => varying.variableName === variableName);
              if (matchedIndex === -1) {
                console.warn(`removeVarying: the variable name ${variableName} is not exist`);
                return;
              }
              this.__varyings.splice(matchedIndex, 1);
            }
            removeUniformDeclaration(variableName) {
              const matchedIndex = this.__uniforms.findIndex((uniform) => uniform.variableName === variableName);
              if (matchedIndex === -1) {
                console.warn(`removeUniform: the variable name ${variableName} is not exist`);
                return;
              }
              this.__uniforms.splice(matchedIndex, 1);
            }
            removeUniformStructDeclaration(variableName) {
              const matchedIndex = this.__uniformStructs.findIndex((uniformStruct) => uniformStruct.variableName === variableName);
              if (matchedIndex === -1) {
                console.warn(`removeUniformStructDeclaration: the variable name ${variableName} is not exist`);
                return;
              }
              this.__uniformStructs.splice(matchedIndex, 1);
            }
            removeUniformBufferObjectDeclaration(blockName) {
              const matchedIndex = this.__uniformBufferObjects.findIndex((ubo) => ubo.blockName === blockName);
              if (matchedIndex === -1) {
                console.warn(`removeUniformStructDeclaration: the variable name ${blockName} is not exist`);
                return;
              }
              this.__uniformBufferObjects.splice(matchedIndex, 1);
            }
            removeFunctionDefinition(functionId) {
              this.__fillEmptyFunctions();
              if (functionId < 0 || functionId >= this.__functionIdCount) {
                console.warn("removeFunctionDefinition: invalid function id");
              }
              for (const functionObjects of this.__functions) {
                const matchedIndex = functionObjects.findIndex((functionObject) => functionObject.functionId === functionId);
                if (matchedIndex !== -1) {
                  functionObjects.splice(matchedIndex, 1);
                  return;
                }
              }
              console.warn(`removeFunctionDefinition: not found the function of functionId ${functionId}`);
            }
            // =========================================================================================================
            // create shaderity object function
            // =========================================================================================================
            createShaderityObject() {
              const shaderityObj = {
                code: this.__createShaderCode(),
                shaderStage: this.__shaderStage,
                isFragmentShader: this.__shaderStage === "fragment"
              };
              return shaderityObj;
            }
            // =========================================================================================================
            // private methods
            // =========================================================================================================
            static __existNonIntegerValue(values) {
              for (const value of values) {
                if (!Number.isInteger(value)) {
                  return true;
                }
              }
              return false;
            }
            // TODO: implement shader code import feature (low priority)
            // public importShaderCode(code: string) {}
            // need to apply Shaderity.transformToGLSLES1, transformToGLSLES3 or transformTo method
            __createShaderCode() {
              this.__fillEmptyFunctions();
              const code = `#version 300 es

` + this.__createDefineDirectiveShaderCode() + this.__createExtensionShaderCode() + this.__createGlobalPrecisionShaderCode() + this.__createStructDefinitionShaderCode() + this.__createGlobalConstantValueShaderCode() + this.__createGlobalConstantStructValueShaderCode() + this.__createAttributeDeclarationShaderCode() + this.__createVaryingDeclarationShaderCode() + this.__createOutputColorDeclarationShaderCode() + this.__createUniformDeclarationShaderCode() + this.__createUniformStructDeclarationShaderCode() + this.__createUniformBufferObjectShaderCode() + this.__createFunctionDefinitionShaderCode() + this.__createMainFunctionDefinitionShaderCode();
              return code;
            }
            __fillEmptyFunctions() {
              var _a41;
              for (let i2 = 0; i2 < this.__functions.length; i2++) {
                this.__functions[i2] = (_a41 = this.__functions[i2]) !== null && _a41 !== void 0 ? _a41 : [];
              }
            }
            __createDefineDirectiveShaderCode() {
              let shaderCode = "";
              for (const defineDirectiveName of this.__defineDirectiveNames) {
                shaderCode += `#define ${defineDirectiveName}
`;
              }
              return Utility_1.default._addLineFeedCodeIfNotNullString(shaderCode);
              ;
            }
            __createExtensionShaderCode() {
              let shaderCode = "";
              for (const extension of this.__extensions) {
                shaderCode += `#extension ${extension.extensionName}: ${extension.behavior}
`;
              }
              return Utility_1.default._addLineFeedCodeIfNotNullString(shaderCode);
            }
            //TODO: remove needless precisions
            __createGlobalPrecisionShaderCode() {
              let shaderCode = "";
              for (const type in this.__globalPrecision) {
                const precisionType = type;
                const precisionQualifier = this.__globalPrecision[precisionType];
                shaderCode += `precision ${precisionQualifier} ${precisionType};
`;
              }
              return Utility_1.default._addLineFeedCodeIfNotNullString(shaderCode);
            }
            __createStructDefinitionShaderCode() {
              let shaderCode = "";
              for (const structDefinition of this.__structDefinitions) {
                shaderCode += `struct ${structDefinition.structName} {
`;
                for (let i2 = 0; i2 < structDefinition.memberObjects.length; i2++) {
                  const variable = structDefinition.memberObjects[i2];
                  shaderCode += `  `;
                  if (variable.precision != null) {
                    shaderCode += `${variable.precision} `;
                  }
                  shaderCode += `${variable.type} ${variable.memberName};
`;
                }
                shaderCode += `};
`;
              }
              return Utility_1.default._addLineFeedCodeIfNotNullString(shaderCode);
            }
            __createGlobalConstantValueShaderCode() {
              let shaderCode = "";
              for (const globalConstantValue of this.__globalConstantValues) {
                const type = globalConstantValue.type;
                const variableName = globalConstantValue.variableName;
                const value = globalConstantValue.values;
                shaderCode += `const ${type} ${variableName} = ${type}(`;
                for (let i2 = 0; i2 < value.length; i2++) {
                  shaderCode += value[i2] + ", ";
                }
                shaderCode = shaderCode.replace(/,\s$/, ");\n");
              }
              return Utility_1.default._addLineFeedCodeIfNotNullString(shaderCode);
            }
            __createGlobalConstantStructValueShaderCode() {
              let shaderCode = "";
              for (const structValue of this.__globalConstantStructValues) {
                const matchedIndex = this.__structDefinitions.findIndex((definition) => definition.structName === structValue.structName);
                if (matchedIndex === -1) {
                  console.error(`__createGlobalConstantStructValueShaderCode: the struct type ${structValue.structName} is not defined`);
                  continue;
                }
                shaderCode += `const ${structValue.structName} ${structValue.variableName} = ${structValue.structName} (
`;
                const structDefinition = this.__structDefinitions[matchedIndex];
                if (structDefinition.memberObjects.length !== Object.keys(structValue.values).length) {
                  console.error(`__createGlobalConstantStructValueShaderCode: Invalid number of variables that ${structValue.variableName} has`);
                  continue;
                }
                const hasSamplerType = structDefinition.memberObjects.some((memberObject) => Utility_1.default._isSamplerType(memberObject.type));
                if (hasSamplerType) {
                  console.error(`__createGlobalConstantStructValueShaderCode: ConstantStructValue (${structValue.variableName}) cannot have sampler type parameter`);
                  continue;
                }
                for (let i2 = 0; i2 < structDefinition.memberObjects.length; i2++) {
                  const variableName = structDefinition.memberObjects[i2].memberName;
                  const value = structValue.values[variableName];
                  if (value == null) {
                    console.error(`__createGlobalConstantStructValueShaderCode: ${structValue.variableName} does not have the value of ${variableName}`);
                    continue;
                  }
                  const type = structDefinition.memberObjects[i2].type;
                  const isValidComponentNumber = Utility_1.default._isValidComponentCount(type, value);
                  if (!isValidComponentNumber) {
                    console.error(`__createGlobalConstantStructValueShaderCode: the component count of ${variableName} in ${structValue.variableName} is invalid`);
                    continue;
                  }
                  shaderCode += `  ${type}(`;
                  for (let i3 = 0; i3 < value.length; i3++) {
                    shaderCode += value[i3] + ", ";
                  }
                  shaderCode = shaderCode.replace(/,\s$/, "),\n");
                }
                shaderCode = shaderCode.replace(/,\n$/, "\n);\n");
              }
              return Utility_1.default._addLineFeedCodeIfNotNullString(shaderCode);
            }
            __createAttributeDeclarationShaderCode() {
              let shaderCode = "";
              for (const attribute of this.__attributes) {
                if (attribute.location != null) {
                  shaderCode += `layout (location = ${attribute.location}) `;
                }
                shaderCode += `in `;
                if (attribute.precision != null) {
                  shaderCode += `${attribute.precision} `;
                }
                shaderCode += `${attribute.type} ${attribute.variableName};
`;
              }
              return Utility_1.default._addLineFeedCodeIfNotNullString(shaderCode);
            }
            __createVaryingDeclarationShaderCode() {
              let shaderCode = "";
              for (const varying of this.__varyings) {
                if (varying.interpolationType != null) {
                  shaderCode += `${varying.interpolationType} `;
                }
                shaderCode += this.__shaderStage == "vertex" ? `out ` : `in `;
                if (varying.precision != null) {
                  shaderCode += `${varying.precision} `;
                }
                shaderCode += `${varying.type} ${varying.variableName};
`;
              }
              return Utility_1.default._addLineFeedCodeIfNotNullString(shaderCode);
            }
            //TODO: translate when glsl es1
            __createOutputColorDeclarationShaderCode() {
              if (this.__shaderStage !== "fragment") {
                return "";
              }
              return `layout(location = 0) out vec4 ${this.__outputColorVariableName};

`;
            }
            __createUniformDeclarationShaderCode() {
              let shaderCode = "";
              for (const uniform of this.__uniforms) {
                shaderCode += `uniform `;
                if (uniform.precision != null) {
                  shaderCode += `${uniform.precision} `;
                }
                shaderCode += `${uniform.type} ${uniform.variableName};
`;
              }
              return Utility_1.default._addLineFeedCodeIfNotNullString(shaderCode);
            }
            __createUniformStructDeclarationShaderCode() {
              let shaderCode = "";
              for (const uniformStruct of this.__uniformStructs) {
                const structName = uniformStruct.structName;
                const existStructDefinition = this.__structDefinitions.some((definition) => definition.structName === structName);
                if (!existStructDefinition) {
                  console.error(`__createUniformStructDeclarationShaderCode: the struct type ${structName} is not defined`);
                  continue;
                }
                shaderCode += `uniform ${structName} ${uniformStruct.variableName};
`;
              }
              return Utility_1.default._addLineFeedCodeIfNotNullString(shaderCode);
            }
            __createUniformBufferObjectShaderCode() {
              let shaderCode = "";
              for (const ubo of this.__uniformBufferObjects) {
                shaderCode += `layout (std140) uniform ${ubo.blockName} {
`;
                for (let i2 = 0; i2 < ubo.variableObjects.length; i2++) {
                  const variableObj = ubo.variableObjects[i2];
                  shaderCode += `  ${variableObj.type} ${variableObj.variableName};
`;
                }
                if (ubo.instanceName != null) {
                  shaderCode += `} ${ubo.instanceName};
`;
                } else {
                  shaderCode += `};
`;
                }
              }
              return Utility_1.default._addLineFeedCodeIfNotNullString(shaderCode);
            }
            __createFunctionDefinitionShaderCode() {
              let shaderCode = "";
              for (let i2 = 0; i2 < this.__functions.length; i2++) {
                const functionObjects = this.__functions[i2];
                for (let j = 0; j < functionObjects.length; j++) {
                  shaderCode += functionObjects[j].functionCode + `
`;
                }
              }
              return Utility_1.default._addLineFeedCodeIfNotNullString(shaderCode);
            }
            __createMainFunctionDefinitionShaderCode() {
              return this.__mainFunctionCode + `
`;
            }
          }, __name(_a40, "ShaderityObjectCreator"), _a40);
          exports2.default = ShaderityObjectCreator;
        }, "./src/main/ShaderityObjectCreator.ts")
      ),
      /***/
      "./src/main/Utility.ts": (
        /*!*****************************!*\
        !*** ./src/main/Utility.ts ***!
        \*****************************/
        /*! no static exports found */
        /***/
        /* @__PURE__ */ __name(function(module1, exports2, __webpack_require__) {
          "use strict";
          var _a40;
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          let Utility = (_a40 = class {
            static _splitByLineFeedCode(source) {
              return source.split(/\r\n|\n/);
            }
            static _joinSplittedLine(splittedLine) {
              return splittedLine.join("\n");
            }
            static _addLineFeedCodeIfNotNullString(source) {
              return source === "" ? source : source + "\n";
            }
            static _componentNumber(type) {
              let componentNumber;
              if (type === "float" || type === "int" || type === "bool" || type === "uint" || type === "sampler2D" || type === "samplerCube" || type === "sampler3D" || type === "sampler2DArray" || type === "isampler2D" || type === "isamplerCube" || type === "isampler3D" || type === "isampler2DArray" || type === "usampler2D" || type === "usamplerCube" || type === "usampler3D" || type === "usampler2DArray" || type === "sampler2DShadow" || type === "samplerCubeShadow" || type === "sampler2DArrayShadow") {
                componentNumber = 1;
              } else if (type === "vec2" || type === "ivec2" || type === "bvec2" || type === "uvec2") {
                componentNumber = 2;
              } else if (type === "vec3" || type === "ivec3" || type === "bvec3" || type === "uvec3") {
                componentNumber = 3;
              } else if (type === "vec4" || type === "ivec4" || type === "bvec4" || type === "uvec4" || type === "mat2" || type === "mat2x2") {
                componentNumber = 4;
              } else if (type === "mat2x3" || type === "mat3x2") {
                componentNumber = 6;
              } else if (type === "mat2x4" || type === "mat4x2") {
                componentNumber = 8;
              } else if (type === "mat3" || type === "mat3x3") {
                componentNumber = 9;
              } else if (type === "mat3x4" || type === "mat4x3") {
                componentNumber = 12;
              } else if (type === "mat4" || type === "mat4x4") {
                componentNumber = 16;
              } else {
                componentNumber = 0;
                console.error("Utility._componentNumber: detect unknown type");
              }
              return componentNumber;
            }
            static _isIntType(type) {
              if (type === "int" || type === "ivec2" || type === "ivec3" || type === "ivec4" || type === "uint" || type === "uvec2" || type === "uvec3" || type === "uvec4") {
                return true;
              } else {
                return false;
              }
            }
            static _isValidComponentCount(type, values) {
              const validComponentCount = _a40._componentNumber(type);
              if (validComponentCount === values.length) {
                return true;
              }
              return false;
            }
            static _isSamplerType(type) {
              if (type === "sampler2D" || type === "samplerCube" || type === "sampler3D" || type === "sampler2DArray" || type === "isampler2D" || type === "isamplerCube" || type === "isampler3D" || type === "isampler2DArray" || type === "usampler2D" || type === "usamplerCube" || type === "usampler3D" || type === "usampler2DArray" || type === "sampler2DShadow" || type === "samplerCubeShadow" || type === "sampler2DArrayShadow") {
                return true;
              } else {
                return false;
              }
            }
          }, __name(_a40, "Utility"), _a40);
          exports2.default = Utility;
        }, "./src/main/Utility.ts")
      )
    });
  }
});

// src/foundation/math/Matrix22.ts
var _Matrix22, Matrix22;
var init_Matrix22 = __esm({
  "src/foundation/math/Matrix22.ts"() {
    "use strict";
    init_CompositionType();
    init_Vector2();
    init_MathUtil();
    init_AbstractMatrix();
    init_Logger();
    _Matrix22 = class _Matrix22 extends AbstractMatrix {
      constructor(m) {
        super();
        this._v = m;
      }
      get m00() {
        return this._v[0];
      }
      get m10() {
        return this._v[1];
      }
      get m01() {
        return this._v[2];
      }
      get m11() {
        return this._v[3];
      }
      get className() {
        return "Matrix22";
      }
      static get compositionType() {
        return CompositionType.Mat2;
      }
      /**
      * Create zero matrix
      */
      static zero() {
        return _Matrix22.fromCopy4RowMajor(0, 0, 0, 0);
      }
      /**
      * Create identity matrix
      */
      static identity() {
        return _Matrix22.fromCopy4RowMajor(1, 0, 0, 1);
      }
      static dummy() {
        return new this(new Float32Array(0));
      }
      /**
      * Create transpose matrix
      */
      static transpose(mat) {
        return _Matrix22.fromCopy4RowMajor(mat._v[0], mat._v[1], mat._v[2], mat._v[3]);
      }
      /**
      * Create invert matrix
      */
      static invert(mat) {
        const det = mat.determinant();
        if (det === 0) {
          Logger.error("the determinant is 0!");
        }
        const m00 = mat._v[3] / det;
        const m01 = mat._v[2] / det * -1;
        const m10 = mat._v[1] / det * -1;
        const m11 = mat._v[0] / det;
        return _Matrix22.fromCopy4RowMajor(m00, m01, m10, m11);
      }
      static invertTo(mat, outMat) {
        const det = mat.determinant();
        if (det === 0) {
          Logger.error("the determinant is 0!");
        }
        const m00 = mat._v[3] / det;
        const m01 = mat._v[2] / det * -1;
        const m10 = mat._v[1] / det * -1;
        const m11 = mat._v[0] / det;
        return outMat.setComponents(m00, m01, m10, m11);
      }
      /**
      * Create Rotation Matrix
      */
      static rotate(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return _Matrix22.fromCopy4RowMajor(cos, -sin, sin, cos);
      }
      /**
      * Create Scale Matrix
      */
      static scale(vec) {
        return _Matrix22.fromCopy4RowMajor(vec._v[0], 0, 0, vec._v[1]);
      }
      /**
      * multiply matrixes
      */
      static multiply(l_mat, r_mat) {
        const m00 = l_mat._v[0] * r_mat._v[0] + l_mat._v[2] * r_mat._v[1];
        const m10 = l_mat._v[1] * r_mat._v[0] + l_mat._v[3] * r_mat._v[1];
        const m01 = l_mat._v[0] * r_mat._v[2] + l_mat._v[2] * r_mat._v[3];
        const m11 = l_mat._v[1] * r_mat._v[2] + l_mat._v[3] * r_mat._v[3];
        return _Matrix22.fromCopy4RowMajor(m00, m01, m10, m11);
      }
      /**
      * multiply matrixes
      */
      static multiplyTo(l_mat, r_mat, outMat) {
        const m00 = l_mat._v[0] * r_mat._v[0] + l_mat._v[2] * r_mat._v[1];
        const m10 = l_mat._v[1] * r_mat._v[0] + l_mat._v[3] * r_mat._v[1];
        const m01 = l_mat._v[0] * r_mat._v[2] + l_mat._v[2] * r_mat._v[3];
        const m11 = l_mat._v[1] * r_mat._v[2] + l_mat._v[3] * r_mat._v[3];
        return outMat.setComponents(m00, m01, m10, m11);
      }
      toString() {
        return this._v[0] + " " + this._v[2] + "\n" + this._v[1] + " " + this._v[3] + " \n";
      }
      toStringApproximately() {
        return MathUtil.financial(this._v[0]) + " " + MathUtil.financial(this._v[2]) + "\n" + MathUtil.financial(this._v[1]) + " " + MathUtil.financial(this._v[3]) + " \n";
      }
      flattenAsArray() {
        return [
          this._v[0],
          this._v[1],
          this._v[2],
          this._v[3]
        ];
      }
      isDummy() {
        if (this._v.length === 0) {
          return true;
        } else {
          return false;
        }
      }
      isEqual(mat, delta = Number.EPSILON) {
        if (Math.abs(mat._v[0] - this._v[0]) < delta && Math.abs(mat._v[1] - this._v[1]) < delta && Math.abs(mat._v[2] - this._v[2]) < delta && Math.abs(mat._v[3] - this._v[3]) < delta) {
          return true;
        } else {
          return false;
        }
      }
      isStrictEqual(mat) {
        if (mat._v[0] === this._v[0] && mat._v[1] === this._v[1] && mat._v[2] === this._v[2] && mat._v[3] === this._v[3]) {
          return true;
        } else {
          return false;
        }
      }
      at(row_i, column_i) {
        return this._v[row_i + column_i * 2];
      }
      determinant() {
        return this._v[0] * this._v[3] - this._v[1] * this._v[2];
      }
      multiplyVector(vec) {
        const x = this._v[0] * vec._v[0] + this._v[2] * vec._v[1];
        const y = this._v[1] * vec._v[0] + this._v[3] * vec._v[1];
        return Vector2.fromCopyArray2([
          x,
          y
        ]);
      }
      multiplyVectorTo(vec, outVec) {
        const x = this._v[0] * vec._v[0] + this._v[2] * vec._v[1];
        const y = this._v[1] * vec._v[0] + this._v[3] * vec._v[1];
        outVec._v[0] = x;
        outVec._v[1] = y;
        return outVec;
      }
      getScale() {
        return Vector2.fromCopyArray2([
          Math.hypot(this.m00, this.m01),
          Math.hypot(this.m10, this.m11)
        ]);
      }
      getScaleTo(outVec) {
        outVec._v[0] = Math.hypot(this._v[0], this._v[2]);
        outVec._v[1] = Math.hypot(this._v[1], this._v[3]);
        return outVec;
      }
      clone() {
        return this.constructor.fromCopy4RowMajor(this._v[0], this._v[2], this._v[1], this._v[3]);
      }
      /**
      * Set values as Row Major
      * Note that WebGL matrix keeps the values in column major.
      * If you write 4 values in 2x2 style (2 values in each row),
      *   It will becomes an intuitive handling.
      * @returns
      */
      static fromCopy4RowMajor(m00, m01, m10, m11) {
        const v = new Float32Array(4);
        v[0] = m00;
        v[2] = m01;
        v[1] = m10;
        v[3] = m11;
        return new _Matrix22(v);
      }
      /**
      * Set values as Column Major
      * Note that WebGL matrix keeps the values in column major.
      * @returns
      */
      static fromCopy4ColumnMajor(m00, m10, m01, m11) {
        const v = new Float32Array(4);
        v[0] = m00;
        v[2] = m01;
        v[1] = m10;
        v[3] = m11;
        return new _Matrix22(v);
      }
      static fromFloat32ArrayColumnMajor(float32Array) {
        return new _Matrix22(float32Array);
      }
      static fromCopyFloat32ArrayColumnMajor(float32Array) {
        const v = new Float32Array(4);
        v.set(float32Array);
        return new _Matrix22(v);
      }
      static fromCopyFloat32ArrayRowMajor(array) {
        const v = new Float32Array(4);
        v[0] = array[0];
        v[3] = array[1];
        v[1] = array[2];
        v[4] = array[3];
        return new _Matrix22(v);
      }
      static fromCopyMatrix22(mat) {
        const v = new Float32Array(4);
        v[0] = mat._v[0];
        v[3] = mat._v[1];
        v[1] = mat._v[2];
        v[4] = mat._v[3];
        return new _Matrix22(v);
      }
      static fromCopyArray9ColumnMajor(array) {
        const v = new Float32Array(4);
        v.set(array);
        return new _Matrix22(v);
      }
      static fromCopyArrayColumnMajor(array) {
        const v = new Float32Array(4);
        v.set(array);
        return new _Matrix22(v);
      }
      static fromCopyArray9RowMajor(array) {
        const v = new Float32Array(4);
        v[0] = array[0];
        v[3] = array[1];
        v[1] = array[2];
        v[4] = array[3];
        return new _Matrix22(v);
      }
      static fromCopyArrayRowMajor(array) {
        const v = new Float32Array(4);
        v[0] = array[0];
        v[3] = array[1];
        v[1] = array[2];
        v[4] = array[3];
        return new _Matrix22(v);
      }
    };
    __name(_Matrix22, "Matrix22");
    Matrix22 = _Matrix22;
  }
});

// src/foundation/math/MutableMatrix22.ts
var _MutableMatrix22, MutableMatrix22;
var init_MutableMatrix22 = __esm({
  "src/foundation/math/MutableMatrix22.ts"() {
    "use strict";
    init_Matrix22();
    init_Logger();
    _MutableMatrix22 = class _MutableMatrix22 extends Matrix22 {
      constructor(m) {
        super(m);
      }
      set m00(val) {
        this._v[0] = val;
      }
      get m00() {
        return this._v[0];
      }
      set m10(val) {
        this._v[1] = val;
      }
      get m10() {
        return this._v[1];
      }
      set m01(val) {
        this._v[2] = val;
      }
      get m01() {
        return this._v[2];
      }
      set m11(val) {
        this._v[3] = val;
      }
      get m11() {
        return this._v[3];
      }
      get className() {
        return "MutableMatrix22";
      }
      /**
      * Create zero matrix
      */
      static zero() {
        return super.zero();
      }
      /**
      * Create identity matrix
      */
      static identity() {
        return super.identity();
      }
      static dummy() {
        return super.dummy();
      }
      /**
      * Create transpose matrix
      */
      static transpose(mat) {
        return super.transpose(mat);
      }
      /**
      * Create invert matrix
      */
      static invert(mat) {
        return super.invert(mat);
      }
      /**
      * Create Rotation Matrix
      */
      static rotate(radian) {
        return super.rotate(radian);
      }
      /**
      * Create Scale Matrix
      */
      static scale(vec) {
        return super.scale(vec);
      }
      /**
      * multiply matrixes
      */
      static multiply(l_mat, r_mat) {
        return super.multiply(l_mat, r_mat);
      }
      clone() {
        const result = super.clone();
        return result;
      }
      raw() {
        return this._v;
      }
      setAt(row_i, column_i, value) {
        this._v[row_i + column_i * 2] = value;
        return this;
      }
      setComponents(m00, m01, m10, m11) {
        this._v[0] = m00;
        this._v[2] = m01;
        this._v[1] = m10;
        this._v[3] = m11;
        return this;
      }
      copyComponents(mat) {
        this._v[0] = mat.m00;
        this._v[2] = mat.m01;
        this._v[1] = mat.m10;
        this._v[3] = mat.m11;
        return this;
      }
      /**
      * zero matrix
      */
      zero() {
        return this.setComponents(0, 0, 0, 0);
      }
      identity() {
        return this.setComponents(1, 0, 0, 1);
      }
      _swap(l2, r2) {
        this._v[r2] = [
          this._v[l2],
          this._v[l2] = this._v[r2]
        ][0];
      }
      /**
      * transpose
      */
      transpose() {
        this._swap(1, 2);
        return this;
      }
      invert() {
        const det = this.determinant();
        if (det === 0) {
          Logger.error("the determinant is 0!");
        }
        const m00 = this._v[3] / det;
        const m01 = this._v[2] / det * -1;
        const m10 = this._v[1] / det * -1;
        const m11 = this._v[0] / det;
        return this.setComponents(m00, m01, m10, m11);
      }
      /**
      * Create Rotation Matrix
      */
      rotate(radian) {
        const cos = Math.cos(radian);
        const sin = Math.sin(radian);
        return this.setComponents(cos, -sin, sin, cos);
      }
      scale(vec) {
        return this.setComponents(vec._v[0], 0, 0, vec._v[1]);
      }
      multiplyScale(vec) {
        this._v[0] *= vec._v[0];
        this._v[2] *= vec._v[0];
        this._v[1] *= vec._v[1];
        this._v[3] *= vec._v[1];
        return this;
      }
      /**
      * multiply the input matrix from right side
      */
      multiply(mat) {
        const m00 = this._v[0] * mat._v[0] + this._v[2] * mat._v[1];
        const m01 = this._v[0] * mat._v[2] + this._v[2] * mat._v[3];
        const m10 = this._v[1] * mat._v[0] + this._v[3] * mat._v[1];
        const m11 = this._v[1] * mat._v[2] + this._v[3] * mat._v[3];
        return this.setComponents(m00, m01, m10, m11);
      }
      multiplyByLeft(mat) {
        const m00 = mat._v[0] * this._v[0] + mat._v[2] * this._v[1];
        const m01 = mat._v[0] * this._v[2] + mat._v[2] * this._v[3];
        const m10 = mat._v[1] * this._v[0] + mat._v[3] * this._v[1];
        const m11 = mat._v[1] * this._v[2] + mat._v[3] * this._v[3];
        return this.setComponents(m00, m01, m10, m11);
      }
      /**
      * Set values as Row Major
      * Note that WebGL matrix keeps the values in column major.
      * If you write 4 values in 2x2 style (2 values in each row),
      *   It will becomes an intuitive handling.
      * @returns
      */
      static fromCopy4RowMajor(m00, m01, m10, m11) {
        const v = new Float32Array(4);
        v[0] = m00;
        v[2] = m01;
        v[1] = m10;
        v[3] = m11;
        return new _MutableMatrix22(v);
      }
      /**
      * Set values as Column Major
      * Note that WebGL matrix keeps the values in column major.
      * @returns
      */
      static fromCopy4ColumnMajor(m00, m10, m01, m11) {
        const v = new Float32Array(4);
        v[0] = m00;
        v[2] = m01;
        v[1] = m10;
        v[3] = m11;
        return new _MutableMatrix22(v);
      }
      static fromFloat32ArrayColumnMajor(float32Array) {
        return new _MutableMatrix22(float32Array);
      }
      static fromCopyFloat32ArrayColumnMajor(float32Array) {
        const v = new Float32Array(4);
        v.set(float32Array);
        return new _MutableMatrix22(v);
      }
      static fromCopyFloat32ArrayRowMajor(array) {
        const v = new Float32Array(4);
        v[0] = array[0];
        v[3] = array[1];
        v[1] = array[2];
        v[4] = array[3];
        return new _MutableMatrix22(v);
      }
      static fromCopyMatrix22(mat) {
        const v = new Float32Array(4);
        v[0] = mat._v[0];
        v[3] = mat._v[1];
        v[1] = mat._v[2];
        v[4] = mat._v[3];
        return new _MutableMatrix22(v);
      }
      static fromCopyArray9ColumnMajor(array) {
        const v = new Float32Array(4);
        v.set(array);
        return new _MutableMatrix22(v);
      }
      static fromCopyArrayColumnMajor(array) {
        const v = new Float32Array(4);
        v.set(array);
        return new _MutableMatrix22(v);
      }
      static fromCopyArray9RowMajor(array) {
        const v = new Float32Array(4);
        v[0] = array[0];
        v[3] = array[1];
        v[1] = array[2];
        v[4] = array[3];
        return new _MutableMatrix22(v);
      }
      static fromCopyArrayRowMajor(array) {
        const v = new Float32Array(4);
        v[0] = array[0];
        v[3] = array[1];
        v[1] = array[2];
        v[4] = array[3];
        return new _MutableMatrix22(v);
      }
    };
    __name(_MutableMatrix22, "MutableMatrix22");
    MutableMatrix22 = _MutableMatrix22;
  }
});

// src/foundation/textures/CubeTexture.ts
var _CubeTexture, CubeTexture;
var init_CubeTexture = __esm({
  "src/foundation/textures/CubeTexture.ts"() {
    "use strict";
    init_AbstractTexture();
    init_HdriFormat();
    init_CGAPIResourceRepository();
    init_TextureParameter();
    init_SystemState();
    init_ProcessApproach();
    init_Logger();
    _CubeTexture = class _CubeTexture extends AbstractTexture {
      constructor() {
        super();
        __publicField(this, "baseUriToLoad");
        __publicField(this, "mipmapLevelNumber", 1);
        __publicField(this, "hdriFormat", HdriFormat.LDR_SRGB);
        __publicField(this, "isNamePosNeg", false);
        __publicField(this, "__onTextureLoadedArray", []);
      }
      __setTextureResourceUid(textureResourceUid, uniqueName) {
        this._textureResourceUid = textureResourceUid;
        _CubeTexture.managedRegistry.register(this, {
          textureResourceUid,
          uniqueName
        }, this);
      }
      registerOnTextureLoaded(func) {
        this.__onTextureLoadedArray.push(func);
      }
      async loadTextureImages() {
        this.__startedToLoad = true;
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        const [resourceUid, sampler] = await cgApiResourceRepository.createCubeTextureFromFiles(this.baseUriToLoad, this.mipmapLevelNumber, this.isNamePosNeg, this.hdriFormat);
        this._recommendedTextureSampler = sampler;
        this.__setTextureResourceUid(resourceUid, this.uniqueName);
        this._samplerResourceUid = sampler._samplerResourceUid;
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          this._textureViewResourceUid = cgApiResourceRepository.createTextureViewCube(this._textureResourceUid);
        }
        this.__isTextureReady = true;
      }
      loadTextureImagesAsync() {
        return new Promise((resolve) => {
          this.__startedToLoad = true;
          const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
          cgApiResourceRepository.createCubeTextureFromFiles(this.baseUriToLoad, this.mipmapLevelNumber, this.isNamePosNeg, this.hdriFormat).then(([cubeTextureUid, sampler]) => {
            this.__setTextureResourceUid(cubeTextureUid, this.uniqueName);
            this._recommendedTextureSampler = sampler;
            this._samplerResourceUid = sampler._samplerResourceUid;
            if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
              this._textureViewResourceUid = cgApiResourceRepository.createTextureViewCube(this._textureResourceUid);
            }
          }).then(() => {
            this.__isTextureReady = true;
            this.__onTextureLoadedArray.forEach((func) => {
              func();
            });
            this.__onTextureLoadedArray = [];
            resolve();
          });
        });
      }
      loadTextureImagesFromBasis(uint8Array, { magFilter = TextureParameter.Linear, minFilter = TextureParameter.LinearMipmapLinear, wrapS = TextureParameter.Repeat, wrapT = TextureParameter.Repeat } = {}) {
        this.__startedToLoad = true;
        if (typeof BASIS === "undefined") {
          Logger.error("Failed to call BASIS() function. Please check to import basis_transcoder.js.");
        }
        BASIS().then((basisTransCoder) => {
          const { initializeBasis } = basisTransCoder;
          initializeBasis();
          const BasisFile = basisTransCoder.BasisFile;
          const basisFile = new BasisFile(uint8Array);
          if (!basisFile.startTranscoding()) {
            Logger.error("failed to start transcoding.");
            basisFile.close();
            basisFile.delete();
            return;
          }
          const webGLResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
          const texture = webGLResourceRepository.createCubeTextureFromBasis(basisFile, {
            magFilter,
            minFilter,
            wrapS,
            wrapT
          });
          this.__setTextureResourceUid(texture, this.uniqueName);
          this.__isTextureReady = true;
          basisFile.close();
          basisFile.delete();
        });
      }
      load1x1Texture(rgbaStr = "rgba(0,0,0,1)") {
        const canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = 1;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = rgbaStr;
        ctx.fillRect(0, 0, 1, 1);
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        const [resourceUid, sampler] = cgApiResourceRepository.createCubeTexture(1, [
          {
            posX: canvas,
            negX: canvas,
            posY: canvas,
            negY: canvas,
            posZ: canvas,
            negZ: canvas
          }
        ], 1, 1);
        this.__setTextureResourceUid(resourceUid, this.uniqueName);
        this._recommendedTextureSampler = sampler;
        this._samplerResourceUid = sampler._samplerResourceUid;
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          this._textureViewResourceUid = cgApiResourceRepository.createTextureViewCube(this._textureResourceUid);
        }
        this.__isTextureReady = true;
      }
      /**
      * Generate cubemap texture object from typed array of cubemap images
      * @param typedArrays Array of typed array object for cubemap textures. The nth element is the nth mipmap reduction level(level 0 is the base image level).
      * @param width Texture width of the base image level texture
      * @param height Texture height of the base image level texture
      */
      generateTextureFromTypedArrays(typedArrayImages, baseLevelWidth, baseLevelHeight) {
        const webGLResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        const [resourceId, sampler] = webGLResourceRepository.createCubeTexture(typedArrayImages.length, typedArrayImages, baseLevelWidth, baseLevelHeight);
        this._recommendedTextureSampler = sampler;
        this.__setTextureResourceUid(resourceId, this.uniqueName);
        this.__isTextureReady = true;
        this.__startedToLoad = true;
      }
      importWebGLTextureDirectly(webGLTexture, width = 0, height = 0) {
        this.__width = width;
        this.__height = height;
        const webGLResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        const texture = webGLResourceRepository.setWebGLTextureDirectly(webGLTexture);
        this.__setTextureResourceUid(texture, this.uniqueName);
        this.__startedToLoad = true;
        this.__isTextureReady = true;
      }
      static __deleteInternalTexture(textureResourceUid) {
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        cgApiResourceRepository.deleteTexture(textureResourceUid);
      }
      destroy3DAPIResources() {
        _CubeTexture.__deleteInternalTexture(this._textureResourceUid);
        this._textureResourceUid = CGAPIResourceRepository.InvalidCGAPIResourceUid;
        this.__isTextureReady = false;
        this.__startedToLoad = false;
      }
      [Symbol.dispose]() {
        Logger.debug("[Symbol.dispose] is called");
        this.destroy();
      }
      destroy() {
        this.destroy3DAPIResources();
        this.unregister();
        _CubeTexture.managedRegistry.unregister(this);
      }
    };
    __name(_CubeTexture, "CubeTexture");
    __publicField(_CubeTexture, "managedRegistry", new FinalizationRegistry((texObj) => {
      Logger.info(`WebGL/WebGPU cube texture "${texObj.uniqueName}" was automatically released along with GC. But explicit release is recommended.`);
      _CubeTexture.__deleteInternalTexture(texObj.textureResourceUid);
    }));
    CubeTexture = _CubeTexture;
  }
});

// node_modules/ktx-parse/dist/ktx-parse.modern.js
function _(t2) {
  return "undefined" != typeof TextDecoder ? new TextDecoder().decode(t2) : Buffer.from(t2).toString("utf8");
}
function p(t2) {
  const n2 = new Uint8Array(t2.buffer, t2.byteOffset, e2.length);
  if (n2[0] !== e2[0] || n2[1] !== e2[1] || n2[2] !== e2[2] || n2[3] !== e2[3] || n2[4] !== e2[4] || n2[5] !== e2[5] || n2[6] !== e2[6] || n2[7] !== e2[7] || n2[8] !== e2[8] || n2[9] !== e2[9] || n2[10] !== e2[10] || n2[11] !== e2[11]) throw new Error("Missing KTX 2.0 identifier.");
  const i2 = new U(), s2 = 17 * Uint32Array.BYTES_PER_ELEMENT, a2 = new c(t2, e2.length, s2, true);
  i2.vkFormat = a2._nextUint32(), i2.typeSize = a2._nextUint32(), i2.pixelWidth = a2._nextUint32(), i2.pixelHeight = a2._nextUint32(), i2.pixelDepth = a2._nextUint32(), i2.layerCount = a2._nextUint32(), i2.faceCount = a2._nextUint32();
  const r2 = a2._nextUint32();
  i2.supercompressionScheme = a2._nextUint32();
  const o2 = a2._nextUint32(), l2 = a2._nextUint32(), f2 = a2._nextUint32(), h = a2._nextUint32(), g2 = a2._nextUint64(), p2 = a2._nextUint64(), x = new c(t2, e2.length + s2, 3 * r2 * 8, true);
  for (let e3 = 0; e3 < r2; e3++) i2.levels.push({
    levelData: new Uint8Array(t2.buffer, t2.byteOffset + x._nextUint64(), x._nextUint64()),
    uncompressedByteLength: x._nextUint64()
  });
  const u = new c(t2, o2, l2, true), y = {
    vendorId: u._skip(4)._nextUint16(),
    descriptorType: u._nextUint16(),
    versionNumber: u._nextUint16(),
    descriptorBlockSize: u._nextUint16(),
    colorModel: u._nextUint8(),
    colorPrimaries: u._nextUint8(),
    transferFunction: u._nextUint8(),
    flags: u._nextUint8(),
    texelBlockDimension: {
      x: u._nextUint8() + 1,
      y: u._nextUint8() + 1,
      z: u._nextUint8() + 1,
      w: u._nextUint8() + 1
    },
    bytesPlane: [
      u._nextUint8(),
      u._nextUint8(),
      u._nextUint8(),
      u._nextUint8(),
      u._nextUint8(),
      u._nextUint8(),
      u._nextUint8(),
      u._nextUint8()
    ],
    samples: []
  }, D = (y.descriptorBlockSize / 4 - 6) / 4;
  for (let t3 = 0; t3 < D; t3++) y.samples[t3] = {
    bitOffset: u._nextUint16(),
    bitLength: u._nextUint8(),
    channelID: u._nextUint8(),
    samplePosition: [
      u._nextUint8(),
      u._nextUint8(),
      u._nextUint8(),
      u._nextUint8()
    ],
    sampleLower: u._nextUint32(),
    sampleUpper: u._nextUint32()
  };
  i2.dataFormatDescriptor.length = 0, i2.dataFormatDescriptor.push(y);
  const b = new c(t2, f2, h, true);
  for (; b._offset < h; ) {
    const t3 = b._nextUint32(), e3 = b._scan(t3), n3 = _(e3), s3 = b._scan(t3 - e3.byteLength);
    i2.keyValue[n3] = n3.match(/^ktx/i) ? _(s3) : s3, b._offset % 4 && b._skip(4 - b._offset % 4);
  }
  if (p2 <= 0) return i2;
  const d = new c(t2, g2, p2, true), B2 = d._nextUint16(), w = d._nextUint16(), A2 = d._nextUint32(), S = d._nextUint32(), m = d._nextUint32(), L = d._nextUint32(), I2 = [];
  for (let t3 = 0; t3 < r2; t3++) I2.push({
    imageFlags: d._nextUint32(),
    rgbSliceByteOffset: d._nextUint32(),
    rgbSliceByteLength: d._nextUint32(),
    alphaSliceByteOffset: d._nextUint32(),
    alphaSliceByteLength: d._nextUint32()
  });
  const R = g2 + d._offset, E = R + A2, T = E + S, O = T + m, P = new Uint8Array(t2.buffer, t2.byteOffset + R, A2), C2 = new Uint8Array(t2.buffer, t2.byteOffset + E, S), F = new Uint8Array(t2.buffer, t2.byteOffset + T, m), G = new Uint8Array(t2.buffer, t2.byteOffset + O, L);
  return i2.globalData = {
    endpointCount: B2,
    selectorCount: w,
    imageDescs: I2,
    endpointsData: P,
    selectorsData: C2,
    tablesData: F,
    extendedData: G
  }, i2;
}
var t, e2, n, i, s, a, r, o, l, f, _a31, U, _a32, c;
var init_ktx_parse_modern = __esm({
  "node_modules/ktx-parse/dist/ktx-parse.modern.js"() {
    "use strict";
    t = new Uint8Array([
      0
    ]);
    e2 = [
      171,
      75,
      84,
      88,
      32,
      50,
      48,
      187,
      13,
      10,
      26,
      10
    ];
    !function(t2) {
      t2[t2.NONE = 0] = "NONE", t2[t2.BASISLZ = 1] = "BASISLZ", t2[t2.ZSTD = 2] = "ZSTD", t2[t2.ZLIB = 3] = "ZLIB";
    }(n || (n = {})), function(t2) {
      t2[t2.BASICFORMAT = 0] = "BASICFORMAT";
    }(i || (i = {})), function(t2) {
      t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.ETC1S = 163] = "ETC1S", t2[t2.UASTC = 166] = "UASTC";
    }(s || (s = {})), function(t2) {
      t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.SRGB = 1] = "SRGB";
    }(a || (a = {})), function(t2) {
      t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.LINEAR = 1] = "LINEAR", t2[t2.SRGB = 2] = "SRGB", t2[t2.ITU = 3] = "ITU", t2[t2.NTSC = 4] = "NTSC", t2[t2.SLOG = 5] = "SLOG", t2[t2.SLOG2 = 6] = "SLOG2";
    }(r || (r = {})), function(t2) {
      t2[t2.ALPHA_STRAIGHT = 0] = "ALPHA_STRAIGHT", t2[t2.ALPHA_PREMULTIPLIED = 1] = "ALPHA_PREMULTIPLIED";
    }(o || (o = {})), function(t2) {
      t2[t2.RGB = 0] = "RGB", t2[t2.RRR = 3] = "RRR", t2[t2.GGG = 4] = "GGG", t2[t2.AAA = 15] = "AAA";
    }(l || (l = {})), function(t2) {
      t2[t2.RGB = 0] = "RGB", t2[t2.RGBA = 3] = "RGBA", t2[t2.RRR = 4] = "RRR", t2[t2.RRRG = 5] = "RRRG";
    }(f || (f = {}));
    U = (_a31 = class {
      constructor() {
        this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = n.NONE, this.levels = [], this.dataFormatDescriptor = [
          {
            vendorId: 0,
            descriptorType: i.BASICFORMAT,
            versionNumber: 2,
            descriptorBlockSize: 40,
            colorModel: s.UNSPECIFIED,
            colorPrimaries: a.SRGB,
            transferFunction: a.SRGB,
            flags: o.ALPHA_STRAIGHT,
            texelBlockDimension: {
              x: 4,
              y: 4,
              z: 1,
              w: 1
            },
            bytesPlane: [],
            samples: []
          }
        ], this.keyValue = {}, this.globalData = null;
      }
    }, __name(_a31, "U"), _a31);
    c = (_a32 = class {
      constructor(t2, e3, n2, i2) {
        this._dataView = new DataView(t2.buffer, t2.byteOffset + e3, n2), this._littleEndian = i2, this._offset = 0;
      }
      _nextUint8() {
        const t2 = this._dataView.getUint8(this._offset);
        return this._offset += 1, t2;
      }
      _nextUint16() {
        const t2 = this._dataView.getUint16(this._offset, this._littleEndian);
        return this._offset += 2, t2;
      }
      _nextUint32() {
        const t2 = this._dataView.getUint32(this._offset, this._littleEndian);
        return this._offset += 4, t2;
      }
      _nextUint64() {
        const t2 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
        return this._offset += 8, t2;
      }
      _skip(t2) {
        return this._offset += t2, this;
      }
      _scan(t2, e3 = 0) {
        const n2 = this._offset;
        let i2 = 0;
        for (; this._dataView.getUint8(this._offset) !== e3 && i2 < t2; ) i2++, this._offset++;
        return i2 < t2 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n2, i2);
      }
    }, __name(_a32, "c"), _a32);
    __name(_, "_");
    __name(p, "p");
  }
});

// node_modules/zstddec/dist/zstddec.modern.js
var A, I, B, g, _a33, Q, C;
var init_zstddec_modern = __esm({
  "node_modules/zstddec/dist/zstddec.modern.js"() {
    "use strict";
    g = {
      env: {
        emscripten_notify_memory_growth: /* @__PURE__ */ __name(function(A2) {
          B = new Uint8Array(I.exports.memory.buffer);
        }, "emscripten_notify_memory_growth")
      }
    };
    Q = (_a33 = class {
      init() {
        return A || (A = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + C).then((A2) => A2.arrayBuffer()).then((A2) => WebAssembly.instantiate(A2, g)).then(this._init) : WebAssembly.instantiate(Buffer.from(C, "base64"), g).then(this._init), A);
      }
      _init(A2) {
        I = A2.instance, g.env.emscripten_notify_memory_growth(0);
      }
      decode(A2, g2 = 0) {
        if (!I) throw new Error("ZSTDDecoder: Await .init() before decoding.");
        const Q2 = A2.byteLength, C2 = I.exports.malloc(Q2);
        B.set(A2, C2), g2 = g2 || Number(I.exports.ZSTD_findDecompressedSize(C2, Q2));
        const E = I.exports.malloc(g2), i2 = I.exports.ZSTD_decompress(E, g2, C2, Q2), D = B.slice(E, E + i2);
        return I.exports.free(C2), I.exports.free(E), D;
      }
    }, __name(_a33, "Q"), _a33);
    C = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";
  }
});

// src/webgl/textureLoader/KTX2TextureLoader.ts
var CompressedTextureFormat, TranscodeTarget, _KTX2TextureLoader, KTX2TextureLoader;
var init_KTX2TextureLoader = __esm({
  "src/webgl/textureLoader/KTX2TextureLoader.ts"() {
    "use strict";
    init_ktx_parse_modern();
    init_CGAPIResourceRepository();
    init_CompressionTextureType();
    init_zstddec_modern();
    init_ProcessApproach();
    init_SystemState();
    init_Logger();
    CompressedTextureFormat = {
      ETC1S: 0,
      UASTC4x4: 1
    };
    TranscodeTarget = {
      ETC1_RGB: "ETC1_RGB",
      BC1_RGB: "BC1_RGB",
      BC4_R: "BC4_R",
      BC5_RG: "BC5_RG",
      BC3_RGBA: "BC3_RGBA",
      PVRTC1_4_RGB: "PVRTC1_4_RGB",
      PVRTC1_4_RGBA: "PVRTC1_4_RGBA",
      BC7_RGBA: "BC7_RGBA",
      BC7_M6_RGB: "BC7_M6_RGB",
      BC7_M5_RGBA: "BC7_M5_RGBA",
      ETC2_RGBA: "ETC2_RGBA",
      ASTC_4x4_RGBA: "ASTC_4x4_RGBA",
      RGBA32: "RGBA32",
      RGB565: "RGB565",
      BGR565: "BGR565",
      RGBA4444: "RGBA4444",
      PVRTC2_4_RGB: "PVRTC2_4_RGB",
      PVRTC2_4_RGBA: "PVRTC2_4_RGBA",
      EAC_R11: "EAC_R11",
      EAC_RG11: "EAC_RG11"
    };
    _KTX2TextureLoader = class _KTX2TextureLoader {
      constructor() {
        __publicField(this, "__mscTranscoderPromise");
        if (typeof MSC_TRANSCODER === "undefined") {
          Logger.error("Failed to call MSC_TRANSCODER() function. Please check to import msc_basis_transcoder.js.");
        }
        this.__mscTranscoderPromise = this.__loadMSCTranscoder();
      }
      // ----- Public Methods -----------------------------------------------------
      static getInstance() {
        if (!this.__instance) {
          this.__instance = new _KTX2TextureLoader();
        }
        return this.__instance;
      }
      transcode(uint8Array) {
        const ktx2Container = this.__parse(uint8Array);
        if (ktx2Container.pixelDepth > 0) {
          throw new Error("Only 2D textures are currently supported");
        }
        if (ktx2Container.layerCount > 1) {
          throw new Error("Array textures are not currently supported");
        }
        if (ktx2Container.faceCount > 1) {
          throw new Error("Cube textures are not currently supported");
        }
        if (ktx2Container.supercompressionScheme === n.ZSTD) {
          if (_KTX2TextureLoader.__zstdDecoder == null) {
            _KTX2TextureLoader.__zstdDecoder = new Q();
          }
          return _KTX2TextureLoader.__zstdDecoder.init().then(() => {
            return this.__mscTranscoderPromise.then(() => {
              return this.__transcodeData(ktx2Container);
            });
          });
        } else {
          return this.__mscTranscoderPromise.then(() => {
            return this.__transcodeData(ktx2Container);
          });
        }
      }
      // ----- Private Methods ----------------------------------------------------
      __loadMSCTranscoder() {
        return new Promise((resolve) => {
          if (_KTX2TextureLoader.__mscTranscoderModule) {
            resolve();
          }
          MSC_TRANSCODER().then((transcoderModule) => {
            transcoderModule.initTranscoders();
            _KTX2TextureLoader.__mscTranscoderModule = transcoderModule;
            resolve();
          });
        });
      }
      __getDeviceDependentParametersWebGL(hasAlpha) {
        const webGLResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        const glw = webGLResourceRepository.currentWebGLContextWrapper;
        const astc = glw.webgl2ExtCTAstc || glw.webgl1ExtCTAstc;
        const bptc = glw.webgl2ExtCTBptc || glw.webgl1ExtCTBptc;
        const s3tc = glw.webgl2ExtCTS3tc || glw.webgl1ExtCTS3tc;
        const pvrtc = glw.webgl2ExtCTPvrtc || glw.webgl1ExtCTPvrtc;
        const etc2 = glw.webgl2ExtCTEtc || glw.webgl1ExtCTEtc;
        const etc1 = glw.webgl2ExtCTEtc1 || glw.webgl1ExtCTEtc1;
        let transcodeTargetStr;
        let compressionTextureType;
        if (astc) {
          transcodeTargetStr = TranscodeTarget.ASTC_4x4_RGBA;
          compressionTextureType = CompressionTextureType.ASTC_RGBA_4x4;
        } else if (bptc) {
          transcodeTargetStr = TranscodeTarget.BC7_RGBA;
          compressionTextureType = CompressionTextureType.BPTC_RGBA;
        } else if (s3tc) {
          if (hasAlpha) {
            transcodeTargetStr = TranscodeTarget.BC3_RGBA;
            compressionTextureType = CompressionTextureType.S3TC_RGBA_DXT5;
          } else {
            transcodeTargetStr = TranscodeTarget.BC1_RGB;
            compressionTextureType = CompressionTextureType.S3TC_RGB_DXT1;
          }
        } else if (pvrtc) {
          if (hasAlpha) {
            transcodeTargetStr = TranscodeTarget.PVRTC1_4_RGBA;
            compressionTextureType = CompressionTextureType.PVRTC_RGBA_4BPPV1;
          } else {
            transcodeTargetStr = TranscodeTarget.PVRTC1_4_RGB;
            compressionTextureType = CompressionTextureType.PVRTC_RGB_4BPPV1;
          }
        } else if (etc2) {
          if (hasAlpha) {
            transcodeTargetStr = TranscodeTarget.ETC2_RGBA;
            compressionTextureType = CompressionTextureType.ETC2_RGBA8_EAC;
          } else {
            transcodeTargetStr = TranscodeTarget.ETC1_RGB;
            compressionTextureType = CompressionTextureType.ETC2_RGB8;
          }
        } else if (etc1) {
          transcodeTargetStr = TranscodeTarget.ETC1_RGB;
          compressionTextureType = CompressionTextureType.ETC1_RGB;
        } else {
          transcodeTargetStr = TranscodeTarget.RGBA32;
          compressionTextureType = CompressionTextureType.RGBA8_EXT;
        }
        return {
          transcodeTargetStr,
          compressionTextureType
        };
      }
      __getDeviceDependentParametersWebGPU(hasAlpha) {
        const webGpuResourceRepository = CGAPIResourceRepository.getWebGpuResourceRepository();
        const adapter = webGpuResourceRepository.getWebGpuDeviceWrapper().gpuAdapter;
        const astc = adapter.features.has("texture-compression-astc");
        const s3tc = adapter.features.has("texture-compression-bc");
        const etc2 = adapter.features.has("texture-compression-etc2");
        let transcodeTargetStr;
        let compressionTextureType;
        if (astc) {
          transcodeTargetStr = TranscodeTarget.ASTC_4x4_RGBA;
          compressionTextureType = CompressionTextureType.ASTC_RGBA_4x4;
        } else if (s3tc) {
          if (hasAlpha) {
            transcodeTargetStr = TranscodeTarget.BC3_RGBA;
            compressionTextureType = CompressionTextureType.S3TC_RGBA_DXT5;
          } else {
            transcodeTargetStr = TranscodeTarget.BC1_RGB;
            compressionTextureType = CompressionTextureType.S3TC_RGB_DXT1;
          }
        } else if (etc2) {
          if (hasAlpha) {
            transcodeTargetStr = TranscodeTarget.ETC2_RGBA;
            compressionTextureType = CompressionTextureType.ETC2_RGBA8_EAC;
          } else {
            transcodeTargetStr = TranscodeTarget.ETC1_RGB;
            compressionTextureType = CompressionTextureType.ETC2_RGB8;
          }
        } else {
          transcodeTargetStr = TranscodeTarget.RGBA32;
          compressionTextureType = CompressionTextureType.RGBA8_EXT;
        }
        return {
          transcodeTargetStr,
          compressionTextureType
        };
      }
      __parse(uint8Array) {
        return p(uint8Array);
      }
      __transcodeData(ktx2Container) {
        var _a40;
        const width = ktx2Container.pixelWidth;
        const height = ktx2Container.pixelHeight;
        const faceCount = ktx2Container.faceCount;
        const imageDescs = (_a40 = ktx2Container.globalData) == null ? void 0 : _a40.imageDescs;
        const dfd = ktx2Container.dataFormatDescriptor[0];
        const compressedTextureFormat = dfd.colorModel === s.UASTC ? CompressedTextureFormat.UASTC4x4 : CompressedTextureFormat.ETC1S;
        const hasAlpha = this.__hasAlpha(dfd, compressedTextureFormat);
        const isVideo = false;
        const transcoderModule = _KTX2TextureLoader.__mscTranscoderModule;
        const transcoder = compressedTextureFormat === CompressedTextureFormat.UASTC4x4 ? new transcoderModule.UastcImageTranscoder() : new transcoderModule.BasisLzEtc1sImageTranscoder();
        const textureFormat = compressedTextureFormat === CompressedTextureFormat.UASTC4x4 ? transcoderModule.TextureFormat.UASTC4x4 : transcoderModule.TextureFormat.ETC1S;
        const { transcodeTargetStr, compressionTextureType } = SystemState.currentProcessApproach === ProcessApproach.WebGPU ? this.__getDeviceDependentParametersWebGPU(hasAlpha) : this.__getDeviceDependentParametersWebGL(hasAlpha);
        const transcodeTarget = transcoderModule.TranscodeTarget[transcodeTargetStr];
        const mipmapData = [];
        const transcodedData = {
          width,
          height,
          compressionTextureType,
          mipmapData,
          needGammaCorrection: dfd.transferFunction !== r.SRGB
        };
        for (let level = 0; level < ktx2Container.levels.length; level++) {
          const levelWidth = Math.max(1, width >> level);
          const levelHeight = Math.max(1, height >> level);
          const imageInfo = new transcoderModule.ImageInfo(textureFormat, levelWidth, levelHeight, level);
          let levelBuffer = ktx2Container.levels[level].levelData;
          const levelUncompressedByteLength = ktx2Container.levels[level].uncompressedByteLength;
          const levelBufferByteLength = imageInfo.numBlocksX * imageInfo.numBlocksY * dfd.bytesPlane[0];
          if (ktx2Container.supercompressionScheme === n.ZSTD) {
            levelBuffer = _KTX2TextureLoader.__zstdDecoder.decode(levelBuffer, levelUncompressedByteLength);
          }
          let faceBufferByteOffset = 0;
          const firstImageDescIndexInLevel = level * Math.max(ktx2Container.layerCount, 1) * faceCount * Math.max(ktx2Container.pixelDepth, 1);
          for (let faceIndex = 0; faceIndex < faceCount; faceIndex++) {
            let imageDesc = null;
            let faceBuffer;
            if (ktx2Container.supercompressionScheme === n.BASISLZ) {
              imageDesc = imageDescs == null ? void 0 : imageDescs[firstImageDescIndexInLevel + faceIndex];
              faceBuffer = new Uint8Array(levelBuffer, imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength + imageDesc.alphaSliceByteLength);
            } else {
              faceBuffer = new Uint8Array(levelBuffer, faceBufferByteOffset, levelBufferByteLength);
              faceBufferByteOffset += levelBufferByteLength;
            }
            let result;
            if (compressedTextureFormat === CompressedTextureFormat.UASTC4x4) {
              imageInfo.flags = 0;
              imageInfo.rgbByteOffset = 0;
              imageInfo.rgbByteLength = levelUncompressedByteLength;
              imageInfo.alphaByteOffset = 0;
              imageInfo.alphaByteLength = 0;
              result = transcoder.transcodeImage(transcodeTarget, faceBuffer, imageInfo, 0, hasAlpha, isVideo);
            } else {
              const sgd = ktx2Container.globalData;
              const basisTranscoder = transcoder;
              basisTranscoder.decodePalettes(sgd.endpointCount, sgd.endpointsData, sgd.selectorCount, sgd.selectorsData);
              basisTranscoder.decodeTables(sgd.tablesData);
              imageInfo.flags = imageDesc.imageFlags;
              imageInfo.rgbByteOffset = 0;
              imageInfo.rgbByteLength = imageDesc.rgbSliceByteLength;
              imageInfo.alphaByteOffset = imageDesc.alphaSliceByteOffset > 0 ? imageDesc.rgbSliceByteLength : 0;
              imageInfo.alphaByteLength = imageDesc.alphaSliceByteLength;
              result = basisTranscoder.transcodeImage(transcodeTarget, faceBuffer, imageInfo, 0, isVideo);
            }
            if ((result == null ? void 0 : result.transcodedImage) != null) {
              const transcodedTextureBuffer = result.transcodedImage.get_typed_memory_view().slice();
              result.transcodedImage.delete();
              const mipmap = {
                level,
                width: levelWidth,
                height: levelHeight,
                buffer: transcodedTextureBuffer
              };
              mipmapData.push(mipmap);
            }
          }
        }
        return transcodedData;
      }
      __hasAlpha(dfd, compressedTextureFormat) {
        if (compressedTextureFormat === CompressedTextureFormat.UASTC4x4) {
          return dfd.samples[0].channelID === f.RGBA;
        } else {
          return dfd.samples.length === 2 && (dfd.samples[0].channelID === l.AAA || dfd.samples[1].channelID === l.AAA);
        }
      }
    };
    __name(_KTX2TextureLoader, "KTX2TextureLoader");
    __publicField(_KTX2TextureLoader, "__instance");
    // TODO: create type of __mscTranscoderModule
    __publicField(_KTX2TextureLoader, "__mscTranscoderModule");
    __publicField(_KTX2TextureLoader, "__zstdDecoder");
    KTX2TextureLoader = _KTX2TextureLoader;
  }
});

// src/foundation/textures/Texture.ts
var _Texture, Texture2;
var init_Texture = __esm({
  "src/foundation/textures/Texture.ts"() {
    "use strict";
    init_PixelFormat();
    init_ComponentType();
    init_AbstractTexture();
    init_CGAPIResourceRepository();
    init_Config();
    init_DataUtil();
    init_KTX2TextureLoader();
    init_ModuleManager();
    init_ProcessApproach();
    init_SystemState();
    init_TextureFormat();
    init_Logger();
    _Texture = class _Texture extends AbstractTexture {
      constructor() {
        super();
        __publicField(this, "autoResize", true);
        __publicField(this, "autoDetectTransparency", false);
        __publicField(this, "__uriToLoadLazy");
        __publicField(this, "__imgToLoadLazy");
        __publicField(this, "__optionsToLoadLazy");
      }
      __setTextureResourceUid(textureResourceUid, uniqueName) {
        this._textureResourceUid = textureResourceUid;
        _Texture.managedRegistry.register(this, {
          textureResourceUid,
          uniqueName
        }, this);
      }
      get hasDataToLoadLazy() {
        return this.__uriToLoadLazy != null || this.__imgToLoadLazy != null;
      }
      generateTextureFromBasis(uint8Array, options) {
        var _a40;
        this.__startedToLoad = true;
        if (typeof BASIS === "undefined") {
          Logger.error("Failed to call BASIS() function. Please check to import basis_transcoder.js.");
        }
        if (!_Texture.__loadedBasisFunc) {
          _Texture.__loadedBasisFunc = true;
          _Texture.__basisLoadPromise = new Promise((resolve) => {
            BASIS().then((basisTransCoder) => {
              const { initializeBasis } = basisTransCoder;
              initializeBasis();
              _Texture.__BasisFile = basisTransCoder.BasisFile;
              this.__setBasisTexture(uint8Array, options);
              resolve();
            });
          });
        } else {
          if (_Texture.__BasisFile) {
            this.__setBasisTexture(uint8Array, options);
          } else {
            (_a40 = _Texture.__basisLoadPromise) == null ? void 0 : _a40.then(() => {
              this.__setBasisTexture(uint8Array, options);
            });
          }
        }
      }
      __setBasisTexture(uint8Array, { level = 0, internalFormat = TextureFormat.RGBA8, format = PixelFormat.RGBA, type = ComponentType.UnsignedByte, generateMipmap = true } = {}) {
        this.__startedToLoad = true;
        const basisFile = new _Texture.__BasisFile(uint8Array);
        if (!basisFile.startTranscoding()) {
          Logger.error("failed to start transcoding.");
          basisFile.close();
          basisFile.delete();
          return;
        }
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        const texture = cgApiResourceRepository.createCompressedTextureFromBasis(basisFile, {
          border: 0,
          format,
          type
        });
        this.__setTextureResourceUid(texture, this.uniqueName);
        this.__isTextureReady = true;
        basisFile.close();
        basisFile.delete();
      }
      async generateTextureFromKTX2(uint8Array) {
        this.__startedToLoad = true;
        const transcodedData = await KTX2TextureLoader.getInstance().transcode(uint8Array);
        this.__width = transcodedData.width;
        this.__height = transcodedData.height;
        this.generateCompressedTextureWithMipmapFromTypedArray(transcodedData.mipmapData, transcodedData.compressionTextureType);
      }
      generateTextureFromImage(image, { level = 0, internalFormat = TextureFormat.RGBA8, format = PixelFormat.RGBA, type = ComponentType.UnsignedByte, generateMipmap = true } = {}) {
        this.__imgToLoadLazy = image;
        this.__optionsToLoadLazy = {
          level,
          internalFormat,
          format,
          type,
          generateMipmap
        };
      }
      async loadFromImgLazy() {
        var _a40, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        if (this.__imgToLoadLazy == null) {
          return;
        }
        const image = this.__imgToLoadLazy;
        const level = (_b = (_a40 = this.__optionsToLoadLazy) == null ? void 0 : _a40.level) != null ? _b : 0;
        const internalFormat = (_d = (_c = this.__optionsToLoadLazy) == null ? void 0 : _c.internalFormat) != null ? _d : TextureFormat.RGBA8;
        const format = (_f = (_e = this.__optionsToLoadLazy) == null ? void 0 : _e.format) != null ? _f : PixelFormat.RGBA;
        const type = (_h = (_g = this.__optionsToLoadLazy) == null ? void 0 : _g.type) != null ? _h : ComponentType.UnsignedByte;
        const generateMipmap = (_j = (_i = this.__optionsToLoadLazy) == null ? void 0 : _i.generateMipmap) != null ? _j : true;
        this.__startedToLoad = true;
        this.__htmlImageElement = image;
        let img = image;
        if (this.autoResize) {
          const [resizedCanvas, resizedWidth, resizedHeight] = DataUtil.getResizedCanvas(img, Config.maxSizeLimitOfNonCompressedTexture);
          img = resizedCanvas;
          this.__width = resizedWidth;
          this.__height = resizedHeight;
          this.__htmlCanvasElement = resizedCanvas;
        }
        if (this.autoDetectTransparency) {
          this.__hasTransparentPixels = DataUtil.detectTransparentPixelExistence(img);
        }
        this.__width = img.width;
        this.__height = img.height;
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        let texture;
        if (img instanceof HTMLImageElement) {
          texture = await cgApiResourceRepository.createTextureFromHTMLImageElement(img, {
            level,
            internalFormat,
            width: this.__width,
            height: this.__height,
            border: 0,
            format,
            type,
            generateMipmap
          });
        } else if (img instanceof HTMLCanvasElement) {
          const textureHandle = cgApiResourceRepository.createTextureFromImageBitmapData(img, {
            level,
            internalFormat,
            width: this.__width,
            height: this.__height,
            border: 0,
            format,
            type,
            generateMipmap
          });
          texture = textureHandle;
        } else {
          throw new Error("Unsupported image type.");
        }
        this.__setTextureResourceUid(texture, this.uniqueName);
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          this._textureViewResourceUid = cgApiResourceRepository.createTextureView2d(this._textureResourceUid);
        }
        this.__isTextureReady = true;
        this.__uri = image.src;
        this.__imgToLoadLazy = void 0;
      }
      generateTextureFromUri(imageUri, { level = 0, internalFormat = TextureFormat.RGBA8, format = PixelFormat.RGBA, type = ComponentType.UnsignedByte, generateMipmap = true } = {}) {
        this.__uriToLoadLazy = imageUri;
        this.__optionsToLoadLazy = {
          level,
          internalFormat,
          format,
          type,
          generateMipmap
        };
      }
      async loadFromUrlLazy() {
        var _a40, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        if (this.__uriToLoadLazy == null) {
          return;
        }
        const imageUri = this.__uriToLoadLazy;
        const level = (_b = (_a40 = this.__optionsToLoadLazy) == null ? void 0 : _a40.level) != null ? _b : 0;
        const internalFormat = (_d = (_c = this.__optionsToLoadLazy) == null ? void 0 : _c.internalFormat) != null ? _d : TextureFormat.RGBA8;
        const format = (_f = (_e = this.__optionsToLoadLazy) == null ? void 0 : _e.format) != null ? _f : PixelFormat.RGBA;
        const type = (_h = (_g = this.__optionsToLoadLazy) == null ? void 0 : _g.type) != null ? _h : ComponentType.UnsignedByte;
        const generateMipmap = (_j = (_i = this.__optionsToLoadLazy) == null ? void 0 : _i.generateMipmap) != null ? _j : true;
        this.__uri = imageUri;
        this.__startedToLoad = true;
        return new Promise((resolve, reject) => {
          this.__img = new Image();
          if (!imageUri.match(/^data:/)) {
            this.__img.crossOrigin = "Anonymous";
          }
          this.__img.onload = () => {
            this.__htmlImageElement = this.__img;
            let img = this.__img;
            if (this.autoResize) {
              const [resizedCanvas, resizedWidth, resizedHeight] = DataUtil.getResizedCanvas(img, Config.maxSizeLimitOfNonCompressedTexture);
              img = resizedCanvas;
              this.__width = resizedWidth;
              this.__height = resizedHeight;
              this.__htmlCanvasElement = resizedCanvas;
            }
            if (this.autoDetectTransparency) {
              this.__hasTransparentPixels = DataUtil.detectTransparentPixelExistence(img);
            }
            this.__width = img.width;
            this.__height = img.height;
            const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
            let texture = CGAPIResourceRepository.InvalidCGAPIResourceUid;
            (async () => {
              if (img instanceof HTMLImageElement) {
                texture = await cgApiResourceRepository.createTextureFromHTMLImageElement(img, {
                  level,
                  internalFormat,
                  width: this.__width,
                  height: this.__height,
                  border: 0,
                  format,
                  type,
                  generateMipmap
                });
              } else if (img instanceof HTMLCanvasElement) {
                const textureHandle = cgApiResourceRepository.createTextureFromImageBitmapData(img, {
                  level,
                  internalFormat,
                  width: this.__width,
                  height: this.__height,
                  border: 0,
                  format,
                  type,
                  generateMipmap
                });
                texture = textureHandle;
              } else {
                throw new Error("Unsupported image type");
              }
              this.__setTextureResourceUid(texture, this.uniqueName);
              if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
                this._textureViewResourceUid = cgApiResourceRepository.createTextureView2d(this._textureResourceUid);
              }
              this.__isTextureReady = true;
              this.__uriToLoadLazy = void 0;
              resolve();
            })();
          };
          this.__img.src = imageUri;
        });
      }
      generate1x1TextureFrom(rgbaStr = "rgba(255,255,255,1)") {
        const canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = 1;
        this.__width = 1;
        this.__height = 1;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = rgbaStr;
        ctx.fillRect(0, 0, 1, 1);
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        const textureHandle = cgApiResourceRepository.createTextureFromImageBitmapData(canvas, {
          level: 0,
          internalFormat: TextureFormat.RGBA8,
          width: 1,
          height: 1,
          border: 0,
          format: PixelFormat.RGBA,
          type: ComponentType.UnsignedByte,
          generateMipmap: false
        });
        this.__setTextureResourceUid(textureHandle, this.uniqueName);
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          this._textureViewResourceUid = cgApiResourceRepository.createTextureView2d(this._textureResourceUid);
        }
        this.__isTextureReady = true;
      }
      async generateSheenLutTextureFromDataUri() {
        const moduleName = "pbr";
        const moduleManager = ModuleManager.getInstance();
        const pbrModule = moduleManager.getModule(moduleName);
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        const textureHandle = await cgApiResourceRepository.createTextureFromDataUri(pbrModule.sheen_E_and_DGTerm, {
          level: 0,
          internalFormat: TextureFormat.RGBA8,
          border: 0,
          format: PixelFormat.RGBA,
          type: ComponentType.UnsignedByte,
          generateMipmap: false
        });
        this.__setTextureResourceUid(textureHandle, this.uniqueName);
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          this._textureViewResourceUid = cgApiResourceRepository.createTextureView2d(this._textureResourceUid);
        }
        this.__isTextureReady = true;
      }
      allocate(desc) {
        var _a40;
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        desc.mipLevelCount = (_a40 = desc.mipLevelCount) != null ? _a40 : Math.floor(Math.log2(Math.max(desc.width, desc.height))) + 1;
        const texture = cgApiResourceRepository.allocateTexture({
          mipLevelCount: desc.mipLevelCount,
          width: desc.width,
          height: desc.height,
          format: desc.format
        });
        this.__setTextureResourceUid(texture, this.uniqueName);
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          this._textureViewResourceUid = cgApiResourceRepository.createTextureView2d(this._textureResourceUid);
        }
        this.__width = desc.width;
        this.__height = desc.height;
        this.__mipLevelCount = desc.mipLevelCount;
        this.__internalFormat = desc.format;
      }
      async loadImageToMipLevel(desc) {
        const webGLResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        await webGLResourceRepository.loadImageToMipLevelOfTexture2D({
          mipLevel: desc.mipLevel,
          textureUid: this._textureResourceUid,
          format: this.__internalFormat,
          type: desc.type,
          xOffset: desc.xOffset,
          yOffset: desc.yOffset,
          width: desc.width,
          height: desc.height,
          rowSizeByPixel: desc.rowSizeByPixel,
          data: desc.data
        });
        if (desc.mipLevel === 0) {
          this.__isTextureReady = true;
        }
      }
      generateCompressedTextureFromTypedArray(typedArray, width, height, compressionTextureType) {
        this.__width = width;
        this.__height = height;
        const textureData = {
          level: 0,
          width,
          height,
          buffer: typedArray
        };
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        const texture = cgApiResourceRepository.createCompressedTexture([
          textureData
        ], compressionTextureType);
        this.__setTextureResourceUid(texture, this.uniqueName);
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          this._textureViewResourceUid = cgApiResourceRepository.createTextureView2d(this._textureResourceUid);
        }
        this.__isTextureReady = true;
      }
      generateCompressedTextureWithMipmapFromTypedArray(textureDataArray, compressionTextureType) {
        const originalTextureData = textureDataArray.find((textureData) => textureData.level === 0);
        if (originalTextureData == null) {
          throw new Error("texture data with level 0 is not found");
        }
        this.__width = originalTextureData.width;
        this.__height = originalTextureData.height;
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        const texture = cgApiResourceRepository.createCompressedTexture(textureDataArray, compressionTextureType);
        this.__setTextureResourceUid(texture, this.uniqueName);
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          this._textureViewResourceUid = cgApiResourceRepository.createTextureView2d(this._textureResourceUid);
        }
        this.__isTextureReady = true;
      }
      /**
      * Generate mipmaps for the texture.
      */
      generateMipmaps() {
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        cgApiResourceRepository.generateMipmaps2d(this._textureResourceUid, this.__width, this.__height);
      }
      importWebGLTextureDirectly(webGLTexture, width = 0, height = 0) {
        this.__width = width;
        this.__height = height;
        const webGLResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        const texture = webGLResourceRepository.setWebGLTextureDirectly(webGLTexture);
        this.__setTextureResourceUid(texture, this.uniqueName);
        this.__startedToLoad = true;
        this.__isTextureReady = true;
      }
      destroy3DAPIResources() {
        _Texture.__deleteInternalTexture(this._textureResourceUid);
        this._textureResourceUid = CGAPIResourceRepository.InvalidCGAPIResourceUid;
        this.__isTextureReady = false;
        this.__startedToLoad = false;
        return true;
      }
      static __deleteInternalTexture(textureResourceUid) {
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        cgApiResourceRepository.deleteTexture(textureResourceUid);
      }
      [Symbol.dispose]() {
        Logger.debug("[Symbol.dispose] is called");
        this.destroy();
      }
      destroy() {
        this.destroy3DAPIResources();
        this.unregister();
        _Texture.managedRegistry.unregister(this);
      }
    };
    __name(_Texture, "Texture");
    __publicField(_Texture, "__loadedBasisFunc", false);
    __publicField(_Texture, "__basisLoadPromise");
    __publicField(_Texture, "__BasisFile");
    __publicField(_Texture, "managedRegistry", new FinalizationRegistry((texObj) => {
      Logger.info(`WebGL/WebGPU 2D texture "${texObj.uniqueName}" was automatically released along with GC. But explicit release is recommended.`);
      _Texture.__deleteInternalTexture(texObj.textureResourceUid);
    }));
    Texture2 = _Texture;
  }
});

// src/foundation/materials/core/DummyTextures.ts
async function initDefaultTextures() {
  if (dummyWhiteTexture.isTextureReady) {
    return;
  }
  dummyWhiteTexture.tryToSetUniqueName("dummyWhiteTexture", true);
  dummyBlueTexture.tryToSetUniqueName("dummyBlueTexture", true);
  dummyBlackTexture.tryToSetUniqueName("dummyBlackTexture", true);
  dummyBlackCubeTexture.tryToSetUniqueName("dummyBlackCubeTexture", true);
  sheenLutTexture.tryToSetUniqueName("sheenLutTexture", true);
  dummySRGBGrayTexture.tryToSetUniqueName("dummySRGBGrayTexture", true);
  dummyAnisotropyTexture.tryToSetUniqueName("dummyAnisotropyTexture", true);
  dummyWhiteTexture.generate1x1TextureFrom();
  dummyBlueTexture.generate1x1TextureFrom("rgba(127.5, 127.5, 255, 1)");
  dummyBlackTexture.generate1x1TextureFrom("rgba(0, 0, 0, 1)");
  dummyBlackCubeTexture.load1x1Texture("rgba(0, 0, 0, 1)");
  await sheenLutTexture.generateSheenLutTextureFromDataUri();
  dummySRGBGrayTexture.generate1x1TextureFrom("rgba(186, 186, 186, 1)");
  dummyAnisotropyTexture.generate1x1TextureFrom("rgba(255, 127.5, 255, 1)");
}
var dummyWhiteTexture, dummyBlueTexture, dummyBlackTexture, dummyBlackCubeTexture, sheenLutTexture, dummySRGBGrayTexture, dummyAnisotropyTexture, DefaultTextures;
var init_DummyTextures = __esm({
  "src/foundation/materials/core/DummyTextures.ts"() {
    "use strict";
    init_CubeTexture();
    init_Texture();
    dummyWhiteTexture = new Texture2();
    dummyBlueTexture = new Texture2();
    dummyBlackTexture = new Texture2();
    dummyBlackCubeTexture = new CubeTexture();
    sheenLutTexture = new Texture2();
    dummySRGBGrayTexture = new Texture2();
    dummyAnisotropyTexture = new Texture2();
    __name(initDefaultTextures, "initDefaultTextures");
    DefaultTextures = {
      dummyWhiteTexture,
      dummyBlueTexture,
      dummyBlackTexture,
      dummyBlackCubeTexture,
      sheenLutTexture,
      dummySRGBGrayTexture,
      dummyAnisotropyTexture
    };
  }
});

// src/foundation/materials/core/ShaderityUtilityWebGPU.ts
var import_shaderity, Shaderity, _ShaderityUtilityWebGPU, ShaderityUtilityWebGPU;
var init_ShaderityUtilityWebGPU = __esm({
  "src/foundation/materials/core/ShaderityUtilityWebGPU.ts"() {
    "use strict";
    import_shaderity = __toESM(require_esm(), 1);
    init_ComponentType();
    init_CompositionType();
    init_WellKnownComponentTIDs();
    init_Config();
    init_MutableVector2();
    init_MutableVector3();
    init_MutableVector4();
    init_MutableMatrix33();
    init_MutableMatrix44();
    init_MutableScalar();
    init_MutableMatrix22();
    init_ShaderType();
    init_DummyTextures();
    init_definitions();
    init_Sampler();
    init_Logger();
    Shaderity = import_shaderity.default.default || import_shaderity.default;
    _ShaderityUtilityWebGPU = class _ShaderityUtilityWebGPU {
      static fillTemplate(shaderityObject, args) {
        const templateObject = Object.assign(args, {
          WellKnownComponentTIDs,
          Config
        });
        return Shaderity.fillTemplate(shaderityObject, templateObject);
      }
      static getShaderDataReflection(shaderityObject) {
        const copiedShaderityObject = this.__copyShaderityObject(shaderityObject);
        const textureMap = /* @__PURE__ */ new Map();
        const splitCode = shaderityObject.code.split(/\r\n|\n/);
        const uniformOmittedShaderRows = [];
        const shaderSemanticsInfoArray = [];
        for (const row of splitCode) {
          const reg = /^[\t ]*\/\/[\t ]*#param[\t ]+(\w+)[ \t]*:[\t ]*([\w><]+);[\t ]*(\/\/)*[\t ]*(.*)/;
          const matchUniformDeclaration = row.match(reg);
          const tex = /^[\t ]*@group\(1\) @binding\((\d+)\)[ \t]*var[ \t]*(\w+)[ \t]*:[ \t]*([\w><]+);[\t ]*\/\/*[\t ]*(.*)/;
          const matchTextureDeclaration = row.match(tex);
          const sampler = /^[\t ]*@group\(2\) @binding\((\d+)\)[ \t]*var[ \t]*(\w+)[ \t]*:[ \t]*sampler;/;
          const matchSamplerDeclaration = row.match(sampler);
          if (matchUniformDeclaration) {
            const type = matchUniformDeclaration[2];
            const variableName = matchUniformDeclaration[1];
            const info = matchUniformDeclaration[4];
            const shaderSemanticsInfo = this.__createShaderSemanticsInfo(type, variableName, info, shaderityObject.isFragmentShader);
            shaderSemanticsInfoArray.push(shaderSemanticsInfo);
          } else if (matchTextureDeclaration) {
            const binding = parseInt(matchTextureDeclaration[1]);
            const variableName = matchTextureDeclaration[2];
            const type = matchTextureDeclaration[3];
            const info = matchTextureDeclaration[4];
            const shaderSemanticsInfo = this.__createShaderSemanticInfoForTexture(type, variableName, binding, info, shaderityObject.isFragmentShader);
            textureMap.set(binding, shaderSemanticsInfo);
            shaderSemanticsInfoArray.push(shaderSemanticsInfo);
          } else if (matchSamplerDeclaration) {
            const binding = parseInt(matchSamplerDeclaration[1]);
            const variableName = matchSamplerDeclaration[2];
            if (textureMap.has(binding)) {
              const textureShaderSemanticsInfo = textureMap.get(binding);
              if (textureShaderSemanticsInfo) {
                const sampler2 = new Sampler({
                  magFilter: TextureParameter.Linear,
                  minFilter: TextureParameter.Linear,
                  wrapS: TextureParameter.Repeat,
                  wrapT: TextureParameter.Repeat,
                  wrapR: TextureParameter.Repeat,
                  anisotropy: false
                });
                textureShaderSemanticsInfo.initialValue[2] = sampler2;
              }
            }
          } else {
            uniformOmittedShaderRows.push(row);
          }
        }
        copiedShaderityObject.code = uniformOmittedShaderRows.join("\n");
        return {
          shaderSemanticsInfoArray,
          shaderityObject: copiedShaderityObject
        };
      }
      static __createShaderSemanticInfoForTexture(type, variableName, binding, info, isFragmentShader) {
        const componentType = ComponentType.Int;
        let compositionType = CompositionType.Texture2D;
        if (type.indexOf("texture_2d") !== -1) {
          compositionType = CompositionType.Texture2D;
        } else if (type.indexOf("texture_cube") !== -1) {
          compositionType = CompositionType.TextureCube;
        }
        const stage = isFragmentShader ? ShaderType.PixelShader : ShaderType.VertexShader;
        const shaderSemanticsInfo = {
          semantic: variableName,
          compositionType,
          componentType,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: false,
          stage
        };
        const initialValue = info.match(/initialValue[\t ]*=[\t ]*(.+)[,\t ]*/);
        if (initialValue) {
          const initialValueText = initialValue[1];
          shaderSemanticsInfo.initialValue = this.__getInitialValueFromTextForTexture(shaderSemanticsInfo, binding, initialValueText);
        } else {
          shaderSemanticsInfo.initialValue = this.__getDefaultInitialValue(shaderSemanticsInfo);
        }
        return shaderSemanticsInfo;
      }
      static __createShaderSemanticsInfo(type, variableName, info, isFragmentShader) {
        const componentType = ComponentType.fromWgslString(type);
        const compositionType = CompositionType.fromWgslString(type);
        const stage = isFragmentShader ? ShaderType.PixelShader : ShaderType.VertexShader;
        const shaderSemanticsInfo = {
          semantic: variableName,
          compositionType,
          componentType,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: false,
          stage
        };
        this.__setRhodoniteOriginalParametersTo(shaderSemanticsInfo, info);
        return shaderSemanticsInfo;
      }
      static __setRhodoniteOriginalParametersTo(shaderSemanticsInfo, info) {
        const soloDatum = info.match(/soloDatum[\t ]*=[\t ]*(\w+)[,\t ]*/);
        let isSoloDatumFlg = false;
        if ((soloDatum == null ? void 0 : soloDatum[1]) === "true") {
          isSoloDatumFlg = true;
        }
        shaderSemanticsInfo.soloDatum = isSoloDatumFlg;
        const isInternalSetting = info.match(/isInternalSetting[\t ]*=[\t ]*(\w+)[,\t ]*/);
        let isInternalSettingFlg = false;
        if ((isInternalSetting == null ? void 0 : isInternalSetting[1]) === "true") {
          isInternalSettingFlg = true;
        }
        shaderSemanticsInfo.isInternalSetting = isInternalSettingFlg;
        const initialValue = info.match(/initialValue[\t ]*=[\t ]*(.+)[,\t ]*/);
        if (initialValue) {
          const initialValueText = initialValue[1];
          shaderSemanticsInfo.initialValue = this.__getInitialValueFromText(shaderSemanticsInfo, initialValueText);
        } else {
          shaderSemanticsInfo.initialValue = this.__getDefaultInitialValue(shaderSemanticsInfo);
        }
        const needUniformInDataTextureMode = info.match(/needUniformInDataTextureMode[\t ]*=[\t ]*(.+)[,\t ]*/);
        if (needUniformInDataTextureMode) {
          let needUniformInDataTextureModeFlg = false;
          if ((needUniformInDataTextureMode == null ? void 0 : needUniformInDataTextureMode[1]) === "true") {
            needUniformInDataTextureModeFlg = true;
          }
          shaderSemanticsInfo.needUniformInDataTextureMode = needUniformInDataTextureModeFlg;
        }
      }
      static __getInitialValueFromTextForTexture(shaderSemanticsInfo, binding, initialValueText) {
        let initialValue;
        const sampler = new Sampler({
          magFilter: TextureParameter.Linear,
          minFilter: TextureParameter.Linear,
          wrapS: TextureParameter.ClampToEdge,
          wrapT: TextureParameter.ClampToEdge,
          wrapR: TextureParameter.ClampToEdge,
          anisotropy: false
        });
        if (shaderSemanticsInfo.compositionType === CompositionType.Texture2D || shaderSemanticsInfo.compositionType === CompositionType.Texture2DShadow) {
          const color = initialValueText.charAt(0).toUpperCase() + initialValueText.slice(1);
          initialValue = [
            binding,
            DefaultTextures[`dummy${color}Texture`],
            sampler
          ];
        } else if (shaderSemanticsInfo.compositionType === CompositionType.TextureCube) {
          const color = initialValueText.charAt(0).toUpperCase() + initialValueText.slice(1);
          initialValue = [
            binding,
            DefaultTextures[`dummy${color}CubeTexture`],
            sampler
          ];
        }
        return initialValue;
      }
      static __getInitialValueFromText(shaderSemanticsInfo, initialValueText) {
        const tuple = initialValueText.match(/\(([\d\w., ]+)\)/);
        const checkCompositionNumber = /* @__PURE__ */ __name((expected) => {
          if (shaderSemanticsInfo.compositionType !== expected) {
            Logger.error("component number of initialValue is invalid:" + shaderSemanticsInfo.semantic);
          }
        }, "checkCompositionNumber");
        let initialValue;
        if (tuple) {
          const text = tuple[1];
          const split = text.split(",");
          switch (split.length) {
            case 1:
              checkCompositionNumber(CompositionType.Scalar);
              if (split[0] === "true") {
                initialValue = new MutableScalar(new Float32Array([
                  1
                ]));
              } else if (split[0] === "false") {
                initialValue = new MutableScalar(new Float32Array([
                  0
                ]));
              } else {
                initialValue = new MutableScalar(new Float32Array([
                  parseFloat(split[0])
                ]));
              }
              break;
            case 2:
              checkCompositionNumber(CompositionType.Vec2);
              initialValue = MutableVector2.fromCopyArray([
                parseFloat(split[0]),
                parseFloat(split[1])
              ]);
              break;
            case 3:
              checkCompositionNumber(CompositionType.Vec3);
              initialValue = MutableVector3.fromCopyArray([
                parseFloat(split[0]),
                parseFloat(split[1]),
                parseFloat(split[2])
              ]);
              break;
            case 4:
              checkCompositionNumber(CompositionType.Vec4);
              initialValue = MutableVector4.fromCopyArray([
                parseFloat(split[0]),
                parseFloat(split[1]),
                parseFloat(split[2]),
                parseFloat(split[3])
              ]);
              break;
            case 9:
              checkCompositionNumber(CompositionType.Mat3);
              initialValue = MutableMatrix33.fromCopy9RowMajor(parseFloat(split[0]), parseFloat(split[1]), parseFloat(split[2]), parseFloat(split[3]), parseFloat(split[4]), parseFloat(split[5]), parseFloat(split[6]), parseFloat(split[7]), parseFloat(split[8]));
              break;
            case 16:
              checkCompositionNumber(CompositionType.Mat4);
              initialValue = MutableMatrix44.fromCopy16RowMajor(parseFloat(split[0]), parseFloat(split[1]), parseFloat(split[2]), parseFloat(split[3]), parseFloat(split[4]), parseFloat(split[5]), parseFloat(split[6]), parseFloat(split[7]), parseFloat(split[8]), parseFloat(split[9]), parseFloat(split[10]), parseFloat(split[11]), parseFloat(split[12]), parseFloat(split[13]), parseFloat(split[14]), parseFloat(split[15]));
              break;
            default:
              Logger.error("Invalid format");
          }
        } else {
          checkCompositionNumber(CompositionType.Scalar);
          if (initialValueText === "true") {
            initialValue = new MutableScalar(new Float32Array([
              1
            ]));
          } else if (initialValueText === "false") {
            initialValue = new MutableScalar(new Float32Array([
              0
            ]));
          } else {
            initialValue = new MutableScalar(new Float32Array([
              parseFloat(initialValueText)
            ]));
          }
        }
        return initialValue;
      }
      static __getDefaultInitialValue(shaderSemanticsInfo) {
        if (shaderSemanticsInfo.compositionType === CompositionType.Scalar) {
          return new MutableScalar(new Float32Array([
            0
          ]));
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Vec2) {
          return MutableVector2.zero();
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Vec3) {
          return MutableVector3.zero();
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Vec4) {
          return MutableVector4.zero();
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Mat2) {
          return MutableMatrix22.identity();
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Mat3) {
          return MutableMatrix33.identity();
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Mat4) {
          return MutableMatrix44.identity();
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Texture2D) {
          return [
            0,
            dummyWhiteTexture
          ];
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Texture2DShadow) {
          return [
            0,
            dummyWhiteTexture
          ];
        } else if (shaderSemanticsInfo.compositionType === CompositionType.TextureCube) {
          return [
            0,
            dummyBlackTexture
          ];
        }
        Logger.warn("initial value is not found");
        return;
      }
      static __copyShaderityObject(obj) {
        const copiedObj = {
          code: obj.code,
          shaderStage: obj.shaderStage,
          isFragmentShader: obj.shaderStage === "fragment"
        };
        return copiedObj;
      }
    };
    __name(_ShaderityUtilityWebGPU, "ShaderityUtilityWebGPU");
    ShaderityUtilityWebGPU = _ShaderityUtilityWebGPU;
  }
});

// src/foundation/materials/core/ShaderityUtilityWebGL.ts
var import_shaderity2, Shaderity2, _ShaderityUtilityWebGL, ShaderityUtilityWebGL;
var init_ShaderityUtilityWebGL = __esm({
  "src/foundation/materials/core/ShaderityUtilityWebGL.ts"() {
    "use strict";
    import_shaderity2 = __toESM(require_esm(), 1);
    init_ComponentType();
    init_CompositionType();
    init_VertexAttribute();
    init_MemoryManager();
    init_WellKnownComponentTIDs();
    init_Config();
    init_MutableVector2();
    init_MutableVector3();
    init_MutableVector4();
    init_MutableMatrix33();
    init_MutableMatrix44();
    init_MutableScalar();
    init_MutableMatrix22();
    init_ShaderType();
    init_DummyTextures();
    init_Logger();
    Shaderity2 = import_shaderity2.default.default || import_shaderity2.default;
    _ShaderityUtilityWebGL = class _ShaderityUtilityWebGL {
      static fillTemplate(shaderityObject, args) {
        const templateObject = Object.assign(args, {
          WellKnownComponentTIDs,
          widthOfDataTexture: `const int widthOfDataTexture = ${MemoryManager.bufferWidthLength};`,
          heightOfDataTexture: `const int heightOfDataTexture = ${MemoryManager.bufferHeightLength};`,
          Config
        });
        return Shaderity2.fillTemplate(shaderityObject, templateObject);
      }
      static transformWebGLVersion(shaderityObject, isWebGL2) {
        if (isWebGL2) {
          return Shaderity2.transformToGLSLES3(shaderityObject);
        } else {
          return Shaderity2.transformToGLSLES1(shaderityObject, true);
        }
      }
      static getAttributeReflection(shaderityObject) {
        const reflection = Shaderity2.createReflectionObject(shaderityObject);
        this.__setDefaultAttributeSemanticMap(reflection);
        reflection.reflect();
        const names = reflection.attributesNames;
        const semantics = reflection.attributesSemantics.map((semantic) => {
          return VertexAttribute.fromString(semantic);
        });
        const compositions = reflection.attributesTypes.map((type) => {
          return CompositionType.fromGlslString(type);
        });
        const components = reflection.attributesTypes.map((type) => {
          return ComponentType.fromGlslString(type);
        });
        return {
          names,
          semantics,
          compositions,
          components
        };
      }
      static __setDefaultAttributeSemanticMap(reflection) {
        const attributeSemanticsMap = /* @__PURE__ */ new Map();
        attributeSemanticsMap.set("instanceinfo", "INSTANCE");
        attributeSemanticsMap.set("barycentriccoord", "BARY_CENTRIC_COORD");
        reflection.addAttributeSemanticsMap(attributeSemanticsMap);
      }
      static getShaderDataReflection(shaderityObject) {
        const copiedShaderityObject = this.__copyShaderityObject(shaderityObject);
        const splitCode = shaderityObject.code.split(/\r\n|\n/);
        const uniformOmittedShaderRows = [];
        const shaderSemanticsInfoArray = [];
        for (const row of splitCode) {
          const reg = /^(?![/])[\t ]*uniform[\t ]+(\w+)[\t ]+(\w+);[\t ]*(\/\/)*[\t ]*(.*)/;
          const matchUniformDeclaration = row.match(reg);
          if (matchUniformDeclaration) {
            const type = matchUniformDeclaration[1];
            const variableName = matchUniformDeclaration[2];
            const info = matchUniformDeclaration[4];
            if (this.__ignoreThisUniformDeclaration(info)) {
              uniformOmittedShaderRows.push(row);
              continue;
            }
            const shaderSemanticsInfo = this.__createShaderSemanticsInfo(type, variableName, info, shaderityObject.isFragmentShader);
            shaderSemanticsInfoArray.push(shaderSemanticsInfo);
          } else {
            uniformOmittedShaderRows.push(row);
          }
        }
        copiedShaderityObject.code = uniformOmittedShaderRows.join("\n");
        return {
          shaderSemanticsInfoArray,
          shaderityObject: copiedShaderityObject
        };
      }
      static __copyShaderityObject(obj) {
        const copiedObj = {
          code: obj.code,
          shaderStage: obj.shaderStage,
          isFragmentShader: obj.shaderStage === "fragment"
        };
        return copiedObj;
      }
      static __ignoreThisUniformDeclaration(info) {
        const skipProcess = info.match(/skipProcess[\t ]*=[\t ]*(\w+)[,\t ]*/);
        if ((skipProcess == null ? void 0 : skipProcess[1]) === "true") {
          return true;
        }
        return false;
      }
      static __createShaderSemanticsInfo(type, variableName, info, isFragmentShader) {
        const componentType = ComponentType.fromGlslString(type);
        const compositionType = CompositionType.fromGlslString(type);
        const stage = isFragmentShader ? ShaderType.PixelShader : ShaderType.VertexShader;
        const u_prefixedName = variableName.match(/u_(\w+)/);
        variableName = u_prefixedName[1];
        const shaderSemanticsInfo = {
          semantic: variableName,
          compositionType,
          componentType,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: false,
          stage
        };
        this.__setRhodoniteOriginalParametersTo(shaderSemanticsInfo, info);
        return shaderSemanticsInfo;
      }
      static __setRhodoniteOriginalParametersTo(shaderSemanticsInfo, info) {
        const soloDatum = info.match(/soloDatum[\t ]*=[\t ]*(\w+)[,\t ]*/);
        let isSoloDatumFlg = false;
        if ((soloDatum == null ? void 0 : soloDatum[1]) === "true") {
          isSoloDatumFlg = true;
        }
        shaderSemanticsInfo.soloDatum = isSoloDatumFlg;
        const isInternalSetting = info.match(/isInternalSetting[\t ]*=[\t ]*(\w+)[,\t ]*/);
        let isInternalSettingFlg = false;
        if ((isInternalSetting == null ? void 0 : isInternalSetting[1]) === "true") {
          isInternalSettingFlg = true;
        }
        shaderSemanticsInfo.isInternalSetting = isInternalSettingFlg;
        const initialValue = info.match(/initialValue[\t ]*=[\t ]*(.+)[,\t ]*/);
        if (initialValue) {
          const initialValueText = initialValue[1];
          shaderSemanticsInfo.initialValue = this.__getInitialValueFromText(shaderSemanticsInfo, initialValueText);
        } else {
          shaderSemanticsInfo.initialValue = this.__getDefaultInitialValue(shaderSemanticsInfo);
        }
        const needUniformInDataTextureMode = info.match(/needUniformInDataTextureMode[\t ]*=[\t ]*(.+)[,\t ]*/);
        if (needUniformInDataTextureMode) {
          let needUniformInDataTextureModeFlg = false;
          if ((needUniformInDataTextureMode == null ? void 0 : needUniformInDataTextureMode[1]) === "true") {
            needUniformInDataTextureModeFlg = true;
          }
          shaderSemanticsInfo.needUniformInDataTextureMode = needUniformInDataTextureModeFlg;
        }
      }
      static __getInitialValueFromText(shaderSemanticsInfo, initialValueText) {
        const tuple = initialValueText.match(/\(([\d\w., ]+)\)/);
        const checkCompositionNumber = /* @__PURE__ */ __name((expected) => {
          if (shaderSemanticsInfo.compositionType !== expected) {
            Logger.error("component number of initialValue is invalid:" + shaderSemanticsInfo.semantic);
          }
        }, "checkCompositionNumber");
        let initialValue;
        if (tuple) {
          const text = tuple[1];
          const split = text.split(",");
          switch (split.length) {
            case 1:
              checkCompositionNumber(CompositionType.Scalar);
              if (split[0] === "true") {
                initialValue = new MutableScalar(new Float32Array([
                  1
                ]));
              } else if (split[0] === "false") {
                initialValue = new MutableScalar(new Float32Array([
                  0
                ]));
              } else {
                initialValue = new MutableScalar(new Float32Array([
                  parseFloat(split[0])
                ]));
              }
              break;
            case 2:
              if (shaderSemanticsInfo.compositionType === CompositionType.Texture2D || shaderSemanticsInfo.compositionType === CompositionType.Texture2DShadow) {
                const color = split[1].charAt(0).toUpperCase() + split[1].slice(1);
                initialValue = [
                  parseInt(split[0]),
                  DefaultTextures[`dummy${color}Texture`]
                ];
              } else if (shaderSemanticsInfo.compositionType === CompositionType.TextureCube) {
                const color = split[1].charAt(0).toUpperCase() + split[1].slice(1);
                initialValue = [
                  parseInt(split[0]),
                  DefaultTextures[`dummy${color}CubeTexture`]
                ];
              } else {
                checkCompositionNumber(CompositionType.Vec2);
                initialValue = MutableVector2.fromCopyArray([
                  parseFloat(split[0]),
                  parseFloat(split[1])
                ]);
              }
              break;
            case 3:
              checkCompositionNumber(CompositionType.Vec3);
              initialValue = MutableVector3.fromCopyArray([
                parseFloat(split[0]),
                parseFloat(split[1]),
                parseFloat(split[2])
              ]);
              break;
            case 4:
              checkCompositionNumber(CompositionType.Vec4);
              initialValue = MutableVector4.fromCopyArray([
                parseFloat(split[0]),
                parseFloat(split[1]),
                parseFloat(split[2]),
                parseFloat(split[3])
              ]);
              break;
            case 9:
              checkCompositionNumber(CompositionType.Mat3);
              initialValue = MutableMatrix33.fromCopy9RowMajor(parseFloat(split[0]), parseFloat(split[1]), parseFloat(split[2]), parseFloat(split[3]), parseFloat(split[4]), parseFloat(split[5]), parseFloat(split[6]), parseFloat(split[7]), parseFloat(split[8]));
              break;
            case 16:
              checkCompositionNumber(CompositionType.Mat4);
              initialValue = MutableMatrix44.fromCopy16RowMajor(parseFloat(split[0]), parseFloat(split[1]), parseFloat(split[2]), parseFloat(split[3]), parseFloat(split[4]), parseFloat(split[5]), parseFloat(split[6]), parseFloat(split[7]), parseFloat(split[8]), parseFloat(split[9]), parseFloat(split[10]), parseFloat(split[11]), parseFloat(split[12]), parseFloat(split[13]), parseFloat(split[14]), parseFloat(split[15]));
              break;
            default:
              Logger.error("Invalid format");
          }
        } else {
          checkCompositionNumber(CompositionType.Scalar);
          if (initialValueText === "true") {
            initialValue = new MutableScalar(new Float32Array([
              1
            ]));
          } else if (initialValueText === "false") {
            initialValue = new MutableScalar(new Float32Array([
              0
            ]));
          } else {
            initialValue = new MutableScalar(new Float32Array([
              parseFloat(initialValueText)
            ]));
          }
        }
        return initialValue;
      }
      static __getDefaultInitialValue(shaderSemanticsInfo) {
        if (shaderSemanticsInfo.compositionType === CompositionType.Scalar) {
          return new MutableScalar(new Float32Array([
            0
          ]));
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Vec2) {
          return MutableVector2.zero();
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Vec3) {
          return MutableVector3.zero();
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Vec4) {
          return MutableVector4.zero();
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Mat2) {
          return MutableMatrix22.identity();
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Mat3) {
          return MutableMatrix33.identity();
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Mat4) {
          return MutableMatrix44.identity();
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Texture2D) {
          return [
            0,
            dummyWhiteTexture
          ];
        } else if (shaderSemanticsInfo.compositionType === CompositionType.Texture2DShadow) {
          return [
            0,
            dummyWhiteTexture
          ];
        } else if (shaderSemanticsInfo.compositionType === CompositionType.TextureCube) {
          return [
            0,
            dummyBlackTexture
          ];
        }
        Logger.warn("initial value is not found");
        return;
      }
    };
    __name(_ShaderityUtilityWebGL, "ShaderityUtilityWebGL");
    ShaderityUtilityWebGL = _ShaderityUtilityWebGL;
  }
});

// src/foundation/materials/core/AbstractMaterialContent.ts
var _AbstractMaterialContent, AbstractMaterialContent;
var init_AbstractMaterialContent = __esm({
  "src/foundation/materials/core/AbstractMaterialContent.ts"() {
    "use strict";
    init_RnObject();
    init_Config();
    init_MutableVector2();
    init_MutableVector4();
    init_Vector3();
    init_MutableMatrix44();
    init_VertexAttribute();
    init_ProcessApproach();
    init_BoneDataType();
    init_SystemState();
    init_ShaderType();
    init_ModuleManager();
    init_ComponentRepository();
    init_ShaderityUtilityWebGPU();
    init_ShaderityUtilityWebGL();
    init_misc();
    _AbstractMaterialContent = class _AbstractMaterialContent extends RnObject {
      constructor(materialName, { isMorphing = false, isSkinning = false, isLighting = false } = {}, vertexShaderityObject, pixelShaderityObject) {
        super();
        __publicField(this, "__semantics", []);
        __publicField(this, "__materialName");
        __publicField(this, "__definitions", "");
        __publicField(this, "__isMorphing");
        __publicField(this, "__isSkinning");
        __publicField(this, "__isLighting");
        __publicField(this, "__vertexShaderityObject");
        __publicField(this, "__pixelShaderityObject");
        __publicField(this, "shaderType", ShaderType.VertexAndPixelShader);
        this.__materialName = materialName;
        this.__isMorphing = isMorphing;
        this.__isSkinning = isSkinning;
        this.__isLighting = isLighting;
        this.__vertexShaderityObject = vertexShaderityObject;
        this.__pixelShaderityObject = pixelShaderityObject;
      }
      getMaterialSemanticsVariantName() {
        let semantics = "";
        for (const semantic of this.__semantics) {
          semantics += `${semantic.semantic} ${semantic.stage.index} ${semantic.componentType.index} ${semantic.compositionType.index} ${semantic.soloDatum} ${semantic.isInternalSetting} ${semantic.arrayLength} ${semantic.needUniformInDataTextureMode}
`;
        }
        const hash = DataUtil.toCRC32(semantics);
        return this.__materialName + "_semanticsVariation" + hash;
      }
      get vertexShaderityObject() {
        return this.__vertexShaderityObject;
      }
      get pixelShaderityObject() {
        return this.__pixelShaderityObject;
      }
      getDefinitions() {
        return this.__definitions;
      }
      static getMaterialNode(materialNodeUid) {
        return _AbstractMaterialContent.materialNodes[materialNodeUid];
      }
      get _semanticsInfoArray() {
        return this.__semantics;
      }
      get isSkinning() {
        return this.__isSkinning;
      }
      get isMorphing() {
        return this.__isMorphing;
      }
      get isLighting() {
        return this.__isLighting;
      }
      setShaderSemanticsInfoArray(shaderSemanticsInfoArray) {
        const infoArray = [];
        for (const info of shaderSemanticsInfoArray) {
          infoArray.push(info);
        }
        this.__semantics = infoArray;
      }
      setupBasicInfo(args, shaderProgram, firstTime, material, CameraComponentClass) {
        if (args.setUniform) {
          this.setWorldMatrix(shaderProgram, args.worldMatrix);
          this.setNormalMatrix(shaderProgram, args.normalMatrix);
          this.setIsBillboard(shaderProgram, args.isBillboard);
          if (firstTime || args.isVr) {
            let cameraComponent = args.renderPass.cameraComponent;
            if (cameraComponent == null) {
              cameraComponent = ComponentRepository.getComponent(CameraComponentClass, CameraComponentClass.current);
            }
            this.setViewInfo(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
            this.setProjection(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          }
          if (firstTime) {
            this.setLightsInfo(shaderProgram, args.lightComponents, material, args.setUniform);
            const skeletalComponent = args.entity.tryToGetSkeletal();
            this.setSkinning(shaderProgram, args.setUniform, skeletalComponent);
          }
        }
        const blendShapeComponent = args.entity.tryToGetBlendShape();
        this.setMorphInfo(shaderProgram, args.entity.getMesh(), args.primitive, blendShapeComponent);
      }
      setWorldMatrix(shaderProgram, worldMatrix) {
        shaderProgram._gl.uniformMatrix4fv(shaderProgram.worldMatrix, false, worldMatrix._v);
      }
      setNormalMatrix(shaderProgram, normalMatrix) {
        shaderProgram._gl.uniformMatrix3fv(shaderProgram.normalMatrix, false, normalMatrix._v);
      }
      setIsBillboard(shaderProgram, isBillboard) {
        shaderProgram._gl.uniform1i(shaderProgram.isBillboard, isBillboard ? 1 : 0);
      }
      setViewInfo(shaderProgram, cameraComponent, isVr, displayIdx) {
        let viewMatrix;
        let cameraPosition;
        if (isVr) {
          const rnXRModule = ModuleManager.getInstance().getModule("xr");
          const webxrSystem = rnXRModule.WebXRSystem.getInstance();
          if (webxrSystem.isWebXRMode) {
            viewMatrix = webxrSystem._getViewMatrixAt(displayIdx);
            cameraPosition = webxrSystem._getCameraWorldPositionAt(displayIdx);
          }
        } else if (cameraComponent) {
          cameraPosition = cameraComponent.worldPosition;
          viewMatrix = cameraComponent.viewMatrix;
        } else {
          viewMatrix = MutableMatrix44.identity();
          cameraPosition = Vector3.fromCopyArray([
            0,
            0,
            10
          ]);
        }
        shaderProgram._gl.uniformMatrix4fv(shaderProgram.viewMatrix, false, viewMatrix._v);
        shaderProgram._gl.uniform3fv(shaderProgram.viewPosition, cameraPosition._v);
      }
      setProjection(shaderProgram, cameraComponent, isVr, displayIdx) {
        let projectionMatrix;
        if (isVr) {
          const rnXRModule = ModuleManager.getInstance().getModule("xr");
          const webxrSystem = rnXRModule.WebXRSystem.getInstance();
          if (webxrSystem.isWebXRMode) {
            projectionMatrix = webxrSystem._getProjectMatrixAt(displayIdx);
          }
        } else if (cameraComponent) {
          projectionMatrix = cameraComponent.projectionMatrix;
        } else {
          projectionMatrix = MutableMatrix44.identity();
        }
        shaderProgram._gl.uniformMatrix4fv(shaderProgram.projectionMatrix, false, projectionMatrix._v);
      }
      setSkinning(shaderProgram, setUniform, skeletalComponent) {
        if (!this.__isSkinning) {
          return;
        }
        if (skeletalComponent) {
          if (setUniform) {
            if (Config.boneDataType === BoneDataType.Mat43x1) {
              const jointMatricesArray = skeletalComponent.jointMatricesArray;
              shaderProgram._gl.uniformMatrix4x3fv(shaderProgram.boneMatrix, false, jointMatricesArray);
            } else if (Config.boneDataType === BoneDataType.Vec4x2) {
              const jointTranslatePackedQuat = skeletalComponent.jointTranslatePackedQuat;
              const jointScalePackedQuat = skeletalComponent.jointScalePackedQuat;
              shaderProgram._gl.uniform4fv(shaderProgram.boneTranslatePackedQuat, jointTranslatePackedQuat);
              shaderProgram._gl.uniform4fv(shaderProgram.boneScalePackedQuat, jointScalePackedQuat);
            } else if (Config.boneDataType === BoneDataType.Vec4x2Old) {
              const jointQuaternionArray = skeletalComponent.jointQuaternionArray;
              const jointTranslateScaleArray = skeletalComponent.jointTranslateScaleArray;
              shaderProgram._gl.uniform4fv(shaderProgram.boneQuaternion, jointQuaternionArray);
              shaderProgram._gl.uniform4fv(shaderProgram.boneTranslateScale, jointTranslateScaleArray);
            } else if (Config.boneDataType === BoneDataType.Vec4x1) {
              const jointCompressedChunk = skeletalComponent.jointCompressedChunk;
              const jointCompressedInfo = skeletalComponent.jointCompressedInfo;
              shaderProgram._gl.uniform4fv(shaderProgram.boneCompressedChunk, jointCompressedChunk);
              shaderProgram._gl.uniform4fv(shaderProgram.boneCompressedInfo, jointCompressedInfo._v);
            }
            shaderProgram._gl.uniform1i(shaderProgram.skinningMode, skeletalComponent.componentSID);
          }
        } else {
          if (setUniform) {
            shaderProgram._gl.uniform1i(shaderProgram.skinningMode, -1);
          }
        }
      }
      setLightsInfo(shaderProgram, lightComponents, material, setUniform) {
        if (!this.__isLighting) {
          return;
        }
        if (setUniform) {
          const lightComponentsEnabled = lightComponents.filter((lightComponent) => lightComponent.enable);
          shaderProgram._gl.uniform1i(shaderProgram.lightNumber, lightComponentsEnabled.length);
          const length = Math.min(lightComponentsEnabled.length, Config.maxLightNumberInShader);
          if (_AbstractMaterialContent.__lightPositions.length !== 3 * length) {
            _AbstractMaterialContent.__lightPositions = new Float32Array(3 * length);
            _AbstractMaterialContent.__lightDirections = new Float32Array(3 * length);
            _AbstractMaterialContent.__lightIntensities = new Float32Array(3 * length);
            _AbstractMaterialContent.__lightProperties = new Float32Array(4 * length);
          }
          for (let i2 = 0; i2 < lightComponentsEnabled.length; i2++) {
            if (i2 >= Config.maxLightNumberInShader) {
              break;
            }
            if (shaderProgram.lightPosition == null) {
              break;
            }
            const lightComponent = lightComponentsEnabled[i2];
            const sceneGraphComponent = lightComponent.entity.getSceneGraph();
            const worldLightPosition = sceneGraphComponent.worldPosition;
            const worldLightDirection = lightComponent.direction;
            const worldLightIntensity = lightComponent.intensity;
            _AbstractMaterialContent.__lightPositions[i2 * 3 + 0] = worldLightPosition.x;
            _AbstractMaterialContent.__lightPositions[i2 * 3 + 1] = worldLightPosition.y;
            _AbstractMaterialContent.__lightPositions[i2 * 3 + 2] = worldLightPosition.z;
            const lightAngleScale = 1 / Math.max(1e-3, Math.cos(lightComponent.innerConeAngle) - Math.cos(lightComponent.outerConeAngle));
            const lightAngleOffset = -Math.cos(lightComponent.outerConeAngle) * lightAngleScale;
            _AbstractMaterialContent.__lightDirections[i2 * 3 + 0] = worldLightDirection.x;
            _AbstractMaterialContent.__lightDirections[i2 * 3 + 1] = worldLightDirection.y;
            _AbstractMaterialContent.__lightDirections[i2 * 3 + 2] = worldLightDirection.z;
            _AbstractMaterialContent.__lightIntensities[i2 * 3 + 0] = worldLightIntensity.x;
            _AbstractMaterialContent.__lightIntensities[i2 * 3 + 1] = worldLightIntensity.y;
            _AbstractMaterialContent.__lightIntensities[i2 * 3 + 2] = worldLightIntensity.z;
            _AbstractMaterialContent.__lightProperties[i2 * 4 + 0] = lightComponent.enable ? lightComponent.type.index : -1;
            _AbstractMaterialContent.__lightProperties[i2 * 4 + 1] = lightComponent.range;
            _AbstractMaterialContent.__lightProperties[i2 * 4 + 2] = lightAngleScale;
            _AbstractMaterialContent.__lightProperties[i2 * 4 + 3] = lightAngleOffset;
          }
          if (length > 0) {
            shaderProgram._gl.uniform3fv(shaderProgram.lightPosition, _AbstractMaterialContent.__lightPositions);
            shaderProgram._gl.uniform3fv(shaderProgram.lightDirection, _AbstractMaterialContent.__lightDirections);
            shaderProgram._gl.uniform3fv(shaderProgram.lightIntensity, _AbstractMaterialContent.__lightIntensities);
            shaderProgram._gl.uniform4fv(shaderProgram.lightProperty, _AbstractMaterialContent.__lightProperties);
          }
        }
      }
      setMorphInfo(shaderProgram, meshComponent, primitive, blendShapeComponent) {
        if (!this.__isMorphing) {
          return;
        }
        if (primitive.targets.length === 0) {
          shaderProgram._gl.uniform1i(shaderProgram.morphTargetNumber, 0);
          return;
        }
        shaderProgram._gl.uniform1i(shaderProgram.morphTargetNumber, primitive.targets.length);
        const dataTextureMorphOffsetPositionOfTargets = primitive.targets.map((target) => {
          const accessor = target.get(VertexAttribute.Position.XYZ);
          let offset = 0;
          if (ProcessApproach.isDataTextureApproach(SystemState.currentProcessApproach)) {
            offset = Config.totalSizeOfGPUShaderDataStorageExceptMorphData;
          }
          return (offset + accessor.byteOffsetInBuffer) / 4 / 4;
        });
        shaderProgram._gl.uniform1iv(shaderProgram.dataTextureMorphOffsetPosition, dataTextureMorphOffsetPositionOfTargets);
        let weights;
        if (blendShapeComponent.weights.length > 0) {
          weights = blendShapeComponent.weights;
        } else {
          weights = new Float32Array(primitive.targets.length);
        }
        shaderProgram._gl.uniform1fv(shaderProgram.morphWeights, weights);
      }
      _setInternalSettingParametersToGpuWebGL({ material, shaderProgram, firstTime, args }) {
      }
      _setInternalSettingParametersToGpuWebGLPerPrimitive({ material, shaderProgram, firstTime, args }) {
      }
      _setInternalSettingParametersToGpuWebGpu({ material, args }) {
      }
      getDefinition() {
        return "";
      }
      doShaderReflection(vertexShader, pixelShader, vertexShaderWebGpu, pixelShaderWebGpu) {
        let vertexShaderData;
        let pixelShaderData;
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          vertexShaderData = ShaderityUtilityWebGPU.getShaderDataReflection(vertexShaderWebGpu);
          pixelShaderData = ShaderityUtilityWebGPU.getShaderDataReflection(pixelShaderWebGpu);
          this.__vertexShaderityObject = vertexShaderData.shaderityObject;
          this.__pixelShaderityObject = pixelShaderData.shaderityObject;
        } else {
          vertexShaderData = ShaderityUtilityWebGL.getShaderDataReflection(vertexShader);
          pixelShaderData = ShaderityUtilityWebGL.getShaderDataReflection(pixelShader);
          this.__vertexShaderityObject = vertexShaderData.shaderityObject;
          this.__pixelShaderityObject = pixelShaderData.shaderityObject;
        }
        const shaderSemanticsInfoArray = [];
        for (const vertexShaderSemanticsInfo of vertexShaderData.shaderSemanticsInfoArray) {
          vertexShaderSemanticsInfo.stage = ShaderType.VertexShader;
          shaderSemanticsInfoArray.push(vertexShaderSemanticsInfo);
        }
        for (const pixelShaderSemanticsInfo of pixelShaderData.shaderSemanticsInfoArray) {
          const foundShaderSemanticsInfo = shaderSemanticsInfoArray.find((vertexInfo) => {
            if (vertexInfo.semantic === pixelShaderSemanticsInfo.semantic) {
              return true;
            } else {
              return false;
            }
          });
          if (foundShaderSemanticsInfo) {
            foundShaderSemanticsInfo.stage = ShaderType.VertexAndPixelShader;
          } else {
            pixelShaderSemanticsInfo.stage = ShaderType.PixelShader;
            shaderSemanticsInfoArray.push(pixelShaderSemanticsInfo);
          }
        }
        return shaderSemanticsInfoArray;
      }
    };
    __name(_AbstractMaterialContent, "AbstractMaterialContent");
    __publicField(_AbstractMaterialContent, "materialNodes", []);
    __publicField(_AbstractMaterialContent, "__gl");
    __publicField(_AbstractMaterialContent, "__tmp_vector4", MutableVector4.zero());
    __publicField(_AbstractMaterialContent, "__tmp_vector2", MutableVector2.zero());
    __publicField(_AbstractMaterialContent, "__lightPositions", new Float32Array(0));
    __publicField(_AbstractMaterialContent, "__lightDirections", new Float32Array(0));
    __publicField(_AbstractMaterialContent, "__lightIntensities", new Float32Array(0));
    __publicField(_AbstractMaterialContent, "__lightProperties", new Float32Array(0));
    AbstractMaterialContent = _AbstractMaterialContent;
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/DepthEncodeSingleShader/DepthEncodeSingleShader.vert
var DepthEncodeSingleShader_default;
var init_DepthEncodeSingleShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/DepthEncodeSingleShader/DepthEncodeSingleShader.vert"() {
    DepthEncodeSingleShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec4 a_joint;\nin vec4 a_weight;\n\nout vec3 v_normal_inWorld;\nout vec4 v_position_inLocal;\nout vec4 v_position_inWorld;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main(){\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n\n  // Skeletal\n  processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n  v_position_inLocal = gl_Position;\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/DepthEncodeSingleShader/DepthEncodeSingleShader.frag
var DepthEncodeSingleShader_default2;
var init_DepthEncodeSingleShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/DepthEncodeSingleShader/DepthEncodeSingleShader.frag"() {
    DepthEncodeSingleShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec4 v_position_inLocal;\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nvec4 encodeDepthToRGBA(float depth){\n  float r = depth;\n  float g = fract(r * 255.0);\n  float b = fract(g * 255.0);\n  float a = fract(b * 255.0);\n  float coef = 1.0 / 255.0;\n  r -= g * coef;\n  g -= b * coef;\n  b -= a * coef;\n  return vec4(r, g, b, a);\n}\n\nvoid main (){\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n  float depth;\n  bool isPointLight = get_isPointLight(materialSID, 0);\n  if(isPointLight){\n    float zNear = get_zNearInner(materialSID, 0);\n    float zFar = get_zFarInner(materialSID, 0);\n    float normalizationCoefficient = 1.0 / (zFar - zNear);\n    depth = normalizationCoefficient * length(v_position_inLocal);\n  }else{\n    depth = gl_FragCoord.z;\n  }\n\n  float depthPow = get_depthPow(materialSID, 0);\n  float depthData = pow(depth, depthPow);\n  vec4 encodedDepth = encodeDepthToRGBA(depthData);\n\n  rt0 = encodedDepth;\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// src/foundation/materials/contents/DepthEncodeMaterialContent.ts
var _DepthEncodeMaterialContent, DepthEncodeMaterialContent;
var init_DepthEncodeMaterialContent = __esm({
  "src/foundation/materials/contents/DepthEncodeMaterialContent.ts"() {
    "use strict";
    init_AbstractMaterialContent();
    init_CameraComponent();
    init_ComponentRepository();
    init_ComponentType();
    init_CompositionType();
    init_Scalar();
    init_ShaderSemantics();
    init_ShaderType();
    init_Vector3();
    init_DepthEncodeSingleShader();
    init_DepthEncodeSingleShader2();
    _DepthEncodeMaterialContent = class _DepthEncodeMaterialContent extends AbstractMaterialContent {
      constructor(materialName, depthPow, { isSkinning }) {
        super(materialName, {
          isMorphing: false,
          isSkinning,
          isLighting: false
        }, DepthEncodeSingleShader_default, DepthEncodeSingleShader_default2);
        __publicField(this, "__lastZNear", 0);
        __publicField(this, "__lastZFar", 0);
        const shaderSemanticsInfoArray = [
          {
            semantic: "zNearInner",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            isInternalSetting: true,
            initialValue: Scalar2.fromCopyNumber(0.1),
            min: 1e-4,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "zFarInner",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            isInternalSetting: true,
            initialValue: Scalar2.fromCopyNumber(1e4),
            min: 1e-4,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "isPointLight",
            componentType: ComponentType.Bool,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(1),
            min: 0,
            max: 1
          },
          {
            semantic: "depthPow",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(depthPow),
            min: 1,
            max: 2
          },
          {
            semantic: "pointSize",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.VertexShader,
            soloDatum: true,
            initialValue: Scalar2.fromCopyNumber(30),
            min: 0,
            max: 100
          },
          {
            semantic: "pointDistanceAttenuation",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Vec3,
            stage: ShaderType.VertexShader,
            soloDatum: true,
            initialValue: Vector3.fromCopyArray([
              0,
              0.1,
              0.01
            ]),
            min: 0,
            max: 1
          }
        ];
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
      }
      _setInternalSettingParametersToGpuWebGL({ material, shaderProgram, firstTime, args }) {
        let cameraComponent = args.renderPass.cameraComponent;
        if (cameraComponent == null) {
          cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
        }
        if (args.setUniform) {
          this.setWorldMatrix(shaderProgram, args.worldMatrix);
          this.setNormalMatrix(shaderProgram, args.normalMatrix);
          this.setViewInfo(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          this.setProjection(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          if (firstTime || this.__lastZNear !== cameraComponent.zNearInner) {
            shaderProgram._gl.uniform1f(shaderProgram.zNearInner, cameraComponent.zNearInner);
            this.__lastZNear = cameraComponent.zNearInner;
          }
          if (this.__lastZFar !== cameraComponent.zFarInner) {
            shaderProgram._gl.uniform1f(shaderProgram.zFarInner, cameraComponent.zFarInner);
            this.__lastZFar = cameraComponent.zFarInner;
          }
        } else {
          material.setParameter("zNearInner", cameraComponent.zNearInner);
          material.setParameter("zFarInner", cameraComponent.zFarInner);
        }
        const skeletalComponent = args.entity.tryToGetSkeletal();
        this.setSkinning(shaderProgram, args.setUniform, skeletalComponent);
      }
    };
    __name(_DepthEncodeMaterialContent, "DepthEncodeMaterialContent");
    __publicField(_DepthEncodeMaterialContent, "zNearInner", new ShaderSemanticsClass({
      str: "zNearInner"
    }));
    __publicField(_DepthEncodeMaterialContent, "zFarInner", new ShaderSemanticsClass({
      str: "zFarInner"
    }));
    __publicField(_DepthEncodeMaterialContent, "isPointLight", new ShaderSemanticsClass({
      str: "isPointLight"
    }));
    __publicField(_DepthEncodeMaterialContent, "depthPow", new ShaderSemanticsClass({
      str: "depthPow"
    }));
    DepthEncodeMaterialContent = _DepthEncodeMaterialContent;
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ShadowMapDecodeClassicSingleShader/ShadowMapDecodeClassicSingleShader.vert
var ShadowMapDecodeClassicSingleShader_default;
var init_ShadowMapDecodeClassicSingleShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ShadowMapDecodeClassicSingleShader/ShadowMapDecodeClassicSingleShader.vert"() {
    ShadowMapDecodeClassicSingleShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec2 a_texcoord_1;\nin vec4 a_joint;\nin vec4 a_weight;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout vec4 v_texcoord_1;\nout vec4 v_projPosition_from_light;\n\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main(){\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n\n  // Skeletal\n  processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n  // Shadow mapping\n  mat4 lightViewProjectionMatrix = get_lightViewProjectionMatrix(materialSID, 0);\n  v_projPosition_from_light = lightViewProjectionMatrix * v_position_inWorld;\n\n  // Following tMatrix is based on https://wgld.org/d/webgl/w051.html\n  mat4 tMatrix = mat4(\n    0.5, 0.0, 0.0, 0.0,\n    0.0, 0.5, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.5, 0.5, 0.0, 1.0\n  );\n  v_texcoord_1 = tMatrix * v_projPosition_from_light;\n\n  v_color = a_color;\n  v_normal_inWorld = normalMatrix * a_normal;\n  v_texcoord_0 = a_texcoord_0;\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ShadowMapDecodeClassicSingleShader/ShadowMapDecodeClassicSingleShader.frag
var ShadowMapDecodeClassicSingleShader_default2;
var init_ShadowMapDecodeClassicSingleShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ShadowMapDecodeClassicSingleShader/ShadowMapDecodeClassicSingleShader.frag"() {
    ShadowMapDecodeClassicSingleShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin vec2 v_texcoord_0;\nin vec4 v_texcoord_1;\nin vec4 v_projPosition_from_light;\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nstruct Light {\n  int type; // 0 = directional, 1 = point, 2 = spot\n  vec3 position;\n  vec3 intensity;\n  vec3 attenuatedIntensity;\n  vec3 directionOfLightObject;\n  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)\n  vec3 pointToLight; // not normalized\n  float spotAngleScale;\n  float spotAngleOffset;\n  float effectiveRange;\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(Light light)\n{\n  float distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(Light light)\n{\n\n  float cd = dot(light.directionOfLightObject, light.direction);\n  float angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nvoid getLightAttenuated(Light light) {\n  light.attenuatedIntensity = light.intensity;\n  // if (light.type == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.type == 1)\n  {\n    light.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.type == 2)\n  {\n    light.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n}\n\nLight getLight(int lightIdx, vec3 v_position_inWorld) {\n  vec3 lightPosition = get_lightPosition(0.0, lightIdx);\n  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);\n  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);\n  vec4 lightProperty = get_lightProperty(0.0, lightIdx);\n  Light light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  float lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3(0.0);\n    light.type = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.type = 1;\n  } else { // is Directional Light\n    light.type = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.type = 2;\n  }\n\n  const float M_PI = 3.141592653589793;\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  getLightAttenuated(light);\n\n  return light;\n}\n\n\nfloat decodeRGBAToDepth(vec4 RGBA){\n  const float rMask = 1.0;\n  const float gMask = 1.0 / 255.0;\n  const float bMask = 1.0 / (255.0 * 255.0);\n  const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n  float depth = dot(RGBA, vec4(rMask, gMask, bMask, aMask));\n  return depth;\n}\n\nvoid main (){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n\n  // diffuseColor\n  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n  float alpha = 1.0;\n\n  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);\n  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {\n    diffuseColor = v_color * diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (v_color == diffuseColor) {\n    diffuseColor = diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (diffuseColorFactor.rgb == diffuseColor) {\n    diffuseColor = v_color;\n  } else {\n    diffuseColor = vec3(1.0, 1.0, 1.0);\n  }\n\n  // diffuseColorTexture\n  vec4 textureColor = texture(u_diffuseColorTexture, v_texcoord_0);\n  if (textureColor.r > 0.05) {\n    diffuseColor *= textureColor.rgb;\n    alpha *= textureColor.a;\n  }\n\n  // shadow mapping\n  if(v_projPosition_from_light.w > 0.0){\n    float zNear = get_zNearInner(materialSID, 0);\n    float zFar = get_zFarInner(materialSID, 0);\n    float normalizationCoefficient = 1.0 / (zFar - zNear);\n\n    vec2 shadowMapUV = v_texcoord_1.xy / v_texcoord_1.w;\n\n    #ifdef RN_IS_DEBUGGING\n      bool inShadowMap = (shadowMapUV.x >= 0.0 && shadowMapUV.x <= 1.0) && (shadowMapUV.y >= 0.0 && shadowMapUV.y <= 1.0);\n      if(inShadowMap == false){\n        rt0 = get_debugColorFactor(materialSID, 0);\n/* shaderity: @{renderTargetEnd} */\n\n        return;\n      }\n    #endif\n\n    float measureDepth = normalizationCoefficient * length(v_projPosition_from_light);\n    float textureDepth = decodeRGBAToDepth(texture(u_depthTexture, shadowMapUV));\n    float allowableDepthError = get_allowableDepthError(materialSID, 0);\n\n    if(measureDepth > textureDepth + allowableDepthError){\n      // case of shadow\n      vec4 shadowColorFactor = get_shadowColorFactor(materialSID, 0);\n      diffuseColor = shadowColorFactor.rgb;\n      alpha = shadowColorFactor.a;\n    }\n  }\n\n  // Lighting\n  vec3 shadingColor = vec3(0.0, 0.0, 0.0);\n  int shadingModel = get_shadingModel(materialSID, 0);\n  if (shadingModel > 0) {\n\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    int lightNumber = get_lightNumber(materialSID, 0);\n    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {\n      if (i >= lightNumber) {\n        break;\n      }\n\n      // Light\n      Light light = getLight(i, v_position_inWorld.xyz);\n\n      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, light.direction)) * light.attenuatedIntensity;\n\n      vec3 viewPosition = get_viewPosition(cameraSID, 0);\n      float shininess = get_shininess(materialSID, 0);\n      if (shadingModel == 2) {// BLINN\n        // ViewDirection\n        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n        vec3 halfVector = normalize(light.direction + viewDirection);\n        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), shininess);\n      } else if (shadingModel == 3) { // PHONG\n        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n        vec3 R = reflect(light.direction, normal_inWorld);\n        specular += pow(max(0.0, dot(R, viewDirection)), shininess);\n      }\n\n    }\n\n    shadingColor = diffuse + specular;\n  } else {\n    shadingColor = diffuseColor;\n  }\n\n  rt0 = vec4(shadingColor, alpha);\n  //rt0 = vec4(u_lightNumber, 0.0, 0.0, 1.0);\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// src/foundation/materials/contents/ShadowMapDecodeClassicMaterialContent.ts
var _ShadowMapDecodeClassicMaterialContent, ShadowMapDecodeClassicMaterialContent;
var init_ShadowMapDecodeClassicMaterialContent = __esm({
  "src/foundation/materials/contents/ShadowMapDecodeClassicMaterialContent.ts"() {
    "use strict";
    init_ShaderSemantics();
    init_AbstractMaterialContent();
    init_CompositionType();
    init_ComponentType();
    init_Vector4();
    init_Vector3();
    init_ShadingModel();
    init_ShaderType();
    init_ComponentRepository();
    init_CameraComponent();
    init_VectorN();
    init_Scalar();
    init_Config();
    init_CGAPIResourceRepository();
    init_MutableMatrix44();
    init_ShadowMapDecodeClassicSingleShader();
    init_ShadowMapDecodeClassicSingleShader2();
    init_DummyTextures();
    init_Logger();
    _ShadowMapDecodeClassicMaterialContent = class _ShadowMapDecodeClassicMaterialContent extends AbstractMaterialContent {
      /**
      * The constructor of the ShadowMapDecodeClassicMaterialContent
      * @param isMorphing True if the morphing is to be applied
      * @param isSkinning True if the skeleton is to be applied
      * @param isLighting True if the lighting is to be applied. When isLighting is false, the Shader draws the original color of the material, except for the shadow area.
      * @param isDebugging True if the shader displays the DebugColorFactor color in areas outside of the depth map.
      * @param colorAttachmentsNumber The index of colorAttachment in a framebuffer. The colorAttachment must have depth information drawn by the DepthEncodeMaterialContent.
      * @param encodedDepthRenderPass The render pass where the depth information from the DepthEncodeMaterialContent is drawn to the frame buffer
      */
      constructor(materialName, { isMorphing, isSkinning, isLighting, isDebugging, colorAttachmentsNumber }, encodedDepthRenderPass) {
        super(materialName, {
          isMorphing,
          isSkinning,
          isLighting
        }, ShadowMapDecodeClassicSingleShader_default, ShadowMapDecodeClassicSingleShader_default2);
        __publicField(this, "__encodedDepthRenderPass");
        this.__encodedDepthRenderPass = encodedDepthRenderPass;
        const encodedDepthFramebuffer = encodedDepthRenderPass.getFramebuffer();
        if (encodedDepthFramebuffer == null) {
          Logger.error("encodedDepthRenderPass does not have framebuffer");
          return;
        }
        const encodedDepthTexture = encodedDepthFramebuffer.colorAttachments[colorAttachmentsNumber];
        const viewport = encodedDepthRenderPass.getViewport();
        viewport.setComponents(1, 1, viewport.z - 1, viewport.w - 1);
        encodedDepthRenderPass.setViewport(viewport);
        const shaderSemanticsInfoArray = [
          {
            semantic: "lightViewProjectionMatrix",
            compositionType: CompositionType.Mat4,
            componentType: ComponentType.Float,
            stage: ShaderType.VertexShader,
            initialValue: MutableMatrix44.zero(),
            min: -Number.MAX_VALUE,
            max: Number.MAX_VALUE
          },
          {
            semantic: "shadingModel",
            compositionType: CompositionType.Scalar,
            componentType: ComponentType.Int,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(ShadingModel2.Constant.index),
            min: 0,
            max: 3
          },
          {
            semantic: "shininess",
            compositionType: CompositionType.Scalar,
            componentType: ComponentType.Float,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(5),
            min: 0,
            max: Number.MAX_VALUE
          },
          {
            semantic: "allowableDepthError",
            compositionType: CompositionType.Scalar,
            componentType: ComponentType.Float,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(1e-4),
            min: 0,
            max: 1
          },
          {
            semantic: "shadowColorFactor",
            compositionType: CompositionType.Vec4,
            componentType: ComponentType.Float,
            stage: ShaderType.PixelShader,
            initialValue: Vector4.fromCopyArray([
              0.5,
              0.5,
              0.5,
              1
            ]),
            min: 0,
            max: 1
          },
          {
            semantic: "diffuseColorFactor",
            compositionType: CompositionType.Vec4,
            componentType: ComponentType.Float,
            stage: ShaderType.PixelShader,
            initialValue: Vector4.fromCopyArray([
              1,
              1,
              1,
              1
            ]),
            min: 0,
            max: 2
          },
          {
            semantic: "isPointLight",
            componentType: ComponentType.Bool,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(1),
            min: 0,
            max: 1
          },
          {
            semantic: "wireframe",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Vec3,
            stage: ShaderType.PixelShader,
            initialValue: Vector3.fromCopyArray([
              0,
              0,
              1
            ]),
            min: 0,
            max: 10
          },
          {
            semantic: "normalTexture",
            compositionType: CompositionType.Texture2D,
            componentType: ComponentType.Int,
            stage: ShaderType.PixelShader,
            initialValue: [
              0,
              dummyBlueTexture
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "depthTexture",
            compositionType: CompositionType.Texture2D,
            componentType: ComponentType.Int,
            stage: ShaderType.PixelShader,
            initialValue: [
              0,
              encodedDepthTexture
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "diffuseColorTexture",
            compositionType: CompositionType.Texture2D,
            componentType: ComponentType.Int,
            stage: ShaderType.PixelShader,
            initialValue: [
              1,
              dummyWhiteTexture
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "zNearInner",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            isInternalSetting: true,
            initialValue: Scalar2.fromCopyNumber(0.1),
            min: 1e-4,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "zFarInner",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            isInternalSetting: true,
            initialValue: Scalar2.fromCopyNumber(1e4),
            min: 1e-4,
            max: Number.MAX_SAFE_INTEGER
          }
        ];
        shaderSemanticsInfoArray.push({
          semantic: "pointSize",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.VertexShader,
          soloDatum: true,
          initialValue: Scalar2.fromCopyNumber(30),
          min: 0,
          max: 100
        }, {
          semantic: "pointDistanceAttenuation",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Vec3,
          stage: ShaderType.VertexShader,
          soloDatum: true,
          initialValue: Vector3.fromCopyArray([
            0,
            0.1,
            0.01
          ]),
          min: 0,
          max: 1
        });
        if (isMorphing) {
          shaderSemanticsInfoArray.push({
            semantic: "morphTargetNumber",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.VertexShader,
            isInternalSetting: true,
            soloDatum: true,
            initialValue: Scalar2.fromCopyNumber(0),
            min: 0,
            max: Config.maxVertexMorphNumberInShader,
            needUniformInDataTextureMode: true
          }, {
            semantic: "dataTextureMorphOffsetPosition",
            componentType: ComponentType.Int,
            compositionType: CompositionType.ScalarArray,
            arrayLength: Config.maxVertexMorphNumberInShader,
            stage: ShaderType.VertexShader,
            isInternalSetting: true,
            soloDatum: true,
            initialValue: new VectorN(new Int32Array(Config.maxVertexMorphNumberInShader)),
            min: -Number.MAX_VALUE,
            max: Number.MAX_VALUE,
            needUniformInDataTextureMode: true
          }, {
            semantic: "morphWeights",
            componentType: ComponentType.Float,
            compositionType: CompositionType.ScalarArray,
            arrayLength: Config.maxVertexMorphNumberInShader,
            stage: ShaderType.VertexShader,
            isInternalSetting: true,
            soloDatum: true,
            initialValue: new VectorN(new Float32Array(Config.maxVertexMorphNumberInShader)),
            min: -Number.MAX_VALUE,
            max: Number.MAX_VALUE,
            needUniformInDataTextureMode: true
          });
        }
        if (isDebugging) {
          shaderSemanticsInfoArray.push({
            semantic: "debugColorFactor",
            compositionType: CompositionType.Vec4,
            componentType: ComponentType.Float,
            stage: ShaderType.PixelShader,
            initialValue: Vector4.fromCopyArray([
              1,
              0,
              0,
              1
            ]),
            min: 0,
            max: 2
          });
        }
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
      }
      _setInternalSettingParametersToGpuWebGL({ material, shaderProgram, firstTime, args }) {
        let cameraComponent = args.renderPass.cameraComponent;
        if (cameraComponent == null) {
          cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
        }
        const encodedDepthCameraComponent = this.__encodedDepthRenderPass.cameraComponent;
        if (args.setUniform) {
          this.setWorldMatrix(shaderProgram, args.worldMatrix);
          this.setNormalMatrix(shaderProgram, args.normalMatrix);
          this.setViewInfo(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          this.setProjection(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          if (_ShadowMapDecodeClassicMaterialContent.__lastZNear !== encodedDepthCameraComponent.zNearInner) {
            shaderProgram._gl.uniform1f(shaderProgram.zNearInner, encodedDepthCameraComponent.zNearInner);
            _ShadowMapDecodeClassicMaterialContent.__lastZNear = encodedDepthCameraComponent.zNearInner;
          }
          if (_ShadowMapDecodeClassicMaterialContent.__lastZFar !== encodedDepthCameraComponent.zFarInner) {
            shaderProgram._gl.uniform1f(shaderProgram.zFarInner, encodedDepthCameraComponent.zFarInner);
            _ShadowMapDecodeClassicMaterialContent.__lastZFar = encodedDepthCameraComponent.zFarInner;
          }
          const __webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
          __webglResourceRepository.setUniformValue(shaderProgram, ShaderSemantics.LightViewProjectionMatrix.str, true, this.__encodedDepthRenderPass.cameraComponent.viewProjectionMatrix);
        } else {
          material.setParameter("zNearInner", encodedDepthCameraComponent.zNearInner);
          material.setParameter("zFarInner", encodedDepthCameraComponent.zFarInner);
          material.setParameter("lightViewProjectionMatrix", this.__encodedDepthRenderPass.cameraComponent.viewProjectionMatrix);
        }
        const skeletalComponent = args.entity.tryToGetSkeletal();
        this.setSkinning(shaderProgram, args.setUniform, skeletalComponent);
        this.setLightsInfo(shaderProgram, args.lightComponents, material, args.setUniform);
        const blendShapeComponent = args.entity.tryToGetBlendShape();
        this.setMorphInfo(shaderProgram, args.entity.getMesh(), args.primitive, blendShapeComponent);
      }
    };
    __name(_ShadowMapDecodeClassicMaterialContent, "ShadowMapDecodeClassicMaterialContent");
    __publicField(_ShadowMapDecodeClassicMaterialContent, "ShadowColorFactor", new ShaderSemanticsClass({
      str: "shadowColorFactor"
    }));
    __publicField(_ShadowMapDecodeClassicMaterialContent, "ShadowAlpha", new ShaderSemanticsClass({
      str: "shadowAlpha"
    }));
    __publicField(_ShadowMapDecodeClassicMaterialContent, "NonShadowAlpha", new ShaderSemanticsClass({
      str: "nonShadowAlpha"
    }));
    __publicField(_ShadowMapDecodeClassicMaterialContent, "AllowableDepthError", new ShaderSemanticsClass({
      str: "allowableDepthError"
    }));
    __publicField(_ShadowMapDecodeClassicMaterialContent, "zNearInner", new ShaderSemanticsClass({
      str: "zNearInner"
    }));
    __publicField(_ShadowMapDecodeClassicMaterialContent, "zFarInner", new ShaderSemanticsClass({
      str: "zFarInner"
    }));
    __publicField(_ShadowMapDecodeClassicMaterialContent, "DebugColorFactor", new ShaderSemanticsClass({
      str: "debugColorFactor"
    }));
    __publicField(_ShadowMapDecodeClassicMaterialContent, "DepthTexture", new ShaderSemanticsClass({
      str: "depthTexture"
    }));
    __publicField(_ShadowMapDecodeClassicMaterialContent, "IsPointLight", new ShaderSemanticsClass({
      str: "isPointLight"
    }));
    __publicField(_ShadowMapDecodeClassicMaterialContent, "__lastZNear", 0);
    __publicField(_ShadowMapDecodeClassicMaterialContent, "__lastZFar", 0);
    ShadowMapDecodeClassicMaterialContent = _ShadowMapDecodeClassicMaterialContent;
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/EntityUIDOutputSingleShader/EntityUIDOutputSingleShader.vert
var EntityUIDOutputSingleShader_default;
var init_EntityUIDOutputSingleShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/EntityUIDOutputSingleShader/EntityUIDOutputSingleShader.vert"() {
    EntityUIDOutputSingleShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec4 a_joint;\nin vec4 a_weight;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout float v_instanceInfo;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\n\nvoid main()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n\n  // Skeletal\n  processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n  v_instanceInfo = a_instanceInfo.x;\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/EntityUIDOutputSingleShader/EntityUIDOutputSingleShader.frag
var EntityUIDOutputSingleShader_default2;
var init_EntityUIDOutputSingleShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/EntityUIDOutputSingleShader/EntityUIDOutputSingleShader.frag"() {
    EntityUIDOutputSingleShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin float v_instanceInfo;\n\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nconst vec4 bitEnc = vec4(1.,255.,65025.,16581375.);\nconst vec4 bitDec = 1./bitEnc;\n\nvec4 encodeFloatRGBA(float v) {\n  float val = v;\n  float r = mod(val, 255.0);\n  val -= r;\n  float g = mod(val, 65025.0);\n  val -= g;\n  float b = mod(val, 16581375.0);\n  return vec4(r/255.0, g/65025.0, b/16581375.0, 1.0);\n}\n\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  rt0 = encodeFloatRGBA(v_instanceInfo);\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// src/foundation/materials/contents/EntityUIDOutputMaterialContent.ts
var _EntityUIDOutputMaterialContent, EntityUIDOutputMaterialContent;
var init_EntityUIDOutputMaterialContent = __esm({
  "src/foundation/materials/contents/EntityUIDOutputMaterialContent.ts"() {
    "use strict";
    init_AbstractMaterialContent();
    init_CompositionType();
    init_ComponentType();
    init_Vector3();
    init_ShaderType();
    init_Scalar();
    init_ComponentRepository();
    init_CameraComponent();
    init_EntityUIDOutputSingleShader();
    init_EntityUIDOutputSingleShader2();
    _EntityUIDOutputMaterialContent = class _EntityUIDOutputMaterialContent extends AbstractMaterialContent {
      constructor(materialName) {
        super(materialName, {
          isMorphing: false,
          isSkinning: true,
          isLighting: false
        }, EntityUIDOutputSingleShader_default, EntityUIDOutputSingleShader_default2);
        const shaderSemanticsInfoArray = [
          // {semantic: ShaderSemantics.ViewMatrix, isComponentData: true, compositionType: CompositionType.Mat4, componentType: ComponentType.Float,
          //   stage: ShaderType.VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isInternalSetting: true, updateInterval: ShaderVariableUpdateInterval.FirstTimeOnly, initialValue: MutableMatrix44.zero() },
          // {semantic: ShaderSemantics.ProjectionMatrix, isComponentData: true, compositionType: CompositionType.Mat4, componentType: ComponentType.Float,
          //   stage: ShaderType.VertexShader, min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isInternalSetting: true, updateInterval: ShaderVariableUpdateInterval.FirstTimeOnly, initialValue: MutableMatrix44.zero() },
          // {
          //   semantic: ShaderSemantics.ViewPosition,
          //   compositionType: CompositionType.Vec3,
          //   componentType: ComponentType.Float,
          //   stage: ShaderType.VertexShader,
          //   min: -Number.MAX_VALUE,
          //   max: Number.MAX_VALUE,
          //   isInternalSetting: true,
          //   updateInterval: ShaderVariableUpdateInterval.FirstTimeOnly,
          //   initialValue: Vector3.fromCopyArray([0, 0, 0]),
          //   soloDatum: true
          // },
          {
            semantic: "pointSize",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.VertexShader,
            soloDatum: true,
            initialValue: Scalar2.fromCopyNumber(30),
            min: 0,
            max: 100
          },
          {
            semantic: "pointDistanceAttenuation",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Vec3,
            stage: ShaderType.VertexShader,
            soloDatum: true,
            initialValue: Vector3.fromCopyArray([
              0,
              0.1,
              0.01
            ]),
            min: 0,
            max: 1
          }
        ];
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
      }
      _setInternalSettingParametersToGpuWebGL({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
          this.setWorldMatrix(shaderProgram, args.worldMatrix);
          this.setNormalMatrix(shaderProgram, args.normalMatrix);
          let cameraComponent = args.renderPass.cameraComponent;
          if (cameraComponent == null) {
            cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
          }
          this.setViewInfo(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          this.setProjection(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          const skeletalComponent = args.entity.tryToGetSkeletal();
          this.setSkinning(shaderProgram, args.setUniform, skeletalComponent);
          this.setLightsInfo(shaderProgram, args.lightComponents, material, args.setUniform);
        }
      }
    };
    __name(_EntityUIDOutputMaterialContent, "EntityUIDOutputMaterialContent");
    EntityUIDOutputMaterialContent = _EntityUIDOutputMaterialContent;
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/MToon0xSingleShader/MToon0xSingleShader.vert.glsl
var MToon0xSingleShader_vert_default;
var init_MToon0xSingleShader_vert = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/MToon0xSingleShader/MToon0xSingleShader.vert.glsl"() {
    MToon0xSingleShader_vert_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\n// This shader is based on https://github.com/Santarh/MToon\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_baryCentricCoord;\nin vec4 a_joint;\nin vec4 a_weight;\n\nout vec2 v_texcoord_0;\nout vec3 v_baryCentricCoord;\nout vec3 v_normal_inView;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout float v_instanceInfo;\n\n#ifdef RN_USE_TANGENT\nin vec4 a_tangent;\nout vec3 v_tangent_inWorld;\nout vec3 v_binormal_inWorld; // bitangent_inWorld\n#endif\n\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main(){\n  #ifdef RN_MTOON_IS_OUTLINE\n    #ifdef RN_MTOON_OUTLINE_NONE\n      return;\n    #endif\n  #endif\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  bool isSkinning = false;\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n\n  v_normal_inView = vec3(viewMatrix * vec4(v_normal_inWorld, 0.0));\n\n  #ifdef RN_MTOON_IS_OUTLINE\n    #if defined(RN_MTOON_HAS_OUTLINE_WIDTH_TEXTURE)\n      float outlineTex = texture(u_outlineWidthTexture, a_texcoord_0).r;\n    #else\n      float outlineTex = 1.0;\n    #endif\n\n    #if defined(RN_MTOON_OUTLINE_WIDTH_WORLD)\n      float outlineWidth = get_outlineWidth(materialSID, 0);\n      vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * a_normal;\n      vec4 worldOutlineOffset = worldMatrix * vec4(outlineOffset, 0.0);\n      gl_Position = projectionMatrix * viewMatrix * (v_position_inWorld + worldOutlineOffset);\n\n    #elif defined(RN_MTOON_OUTLINE_WIDTH_SCREEN)\n      vec4 vertex = projectionMatrix * viewMatrix * v_position_inWorld;\n\n      vec3 clipNormal = (projectionMatrix * vec4(v_normal_inView, 1.0)).xyz;\n      vec2 projectedNormal = normalize(clipNormal.xy);\n      float outlineScaledMaxDistance = get_outlineScaledMaxDistance(materialSID, 0);\n      projectedNormal *= min(vertex.w, outlineScaledMaxDistance);\n      float aspect = abs(get_aspect(0.0, 0)); //solo datum\n      projectedNormal.x *= aspect;\n\n      float outlineWidth = get_outlineWidth(materialSID, 0);\n      vertex.xy += 0.01 * outlineWidth * outlineTex * projectedNormal * clamp(1.0 - abs(v_normal_inView.z), 0.0, 1.0); // ignore offset when normal toward camera\n\n      gl_Position = vertex;\n    #else\n      gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n    #endif\n  #else\n    gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n  #endif\n\n  #ifdef RN_USE_TANGENT\n    v_tangent_inWorld = normalMatrix * a_tangent.xyz;\n    v_binormal_inWorld = cross(v_normal_inWorld, v_tangent_inWorld) * a_tangent.w;\n  #endif\n\n  v_texcoord_0 = a_texcoord_0;\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n  v_instanceInfo = a_instanceInfo.x;\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/MToon0xSingleShader/MToon0xSingleShader.frag.glsl
var MToon0xSingleShader_frag_default;
var init_MToon0xSingleShader_frag = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/MToon0xSingleShader/MToon0xSingleShader.frag.glsl"() {
    MToon0xSingleShader_frag_default = { code: `
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

const float Epsilon = 0.0000001;
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}

float saturate(float t)
{
  return clamp(t, 0.0, 1.0);
}


const float EPS_COL = 0.00001;

in vec2 v_texcoord_0;
in vec3 v_baryCentricCoord;
in vec3 v_normal_inView;
in vec3 v_normal_inWorld;
in vec4 v_position_inWorld;
in float v_instanceInfo;
#ifdef RN_USE_TANGENT
  in vec3 v_tangent_inWorld;
  in vec3 v_binormal_inWorld; // bitangent_inWorld
#endif

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

struct Light {
  int type; // 0 = directional, 1 = point, 2 = spot
  vec3 position;
  vec3 intensity;
  vec3 attenuatedIntensity;
  vec3 directionOfLightObject;
  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)
  vec3 pointToLight; // not normalized
  float spotAngleScale;
  float spotAngleOffset;
  float effectiveRange;
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
float getRangeAttenuation(Light light)
{
  float distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
float getSpotAttenuation(Light light)
{

  float cd = dot(light.directionOfLightObject, light.direction);
  float angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);
  return angularAttenuation;
}

void getLightAttenuated(Light light) {
  light.attenuatedIntensity = light.intensity;
  // if (light.type == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light
  if (light.type == 1)
  {
    light.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot light
  if (light.type == 2)
  {
    light.attenuatedIntensity *= getSpotAttenuation(light);
  }
}

Light getLight(int lightIdx, vec3 v_position_inWorld) {
  vec3 lightPosition = get_lightPosition(0.0, lightIdx);
  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);
  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);
  vec4 lightProperty = get_lightProperty(0.0, lightIdx);
  Light light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  float lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.spotAngleScale = lightProperty.z;
  light.spotAngleOffset = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3(0.0);
    light.type = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.type = 1;
  } else { // is Directional Light
    light.type = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.type = 2;
  }

  const float M_PI = 3.141592653589793;
  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  getLightAttenuated(light);

  return light;
}

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

float angular_n_h(float NH) {
  return acos(NH);
}

float d_phong(float NH, float c1) {
  return pow(
    cos(acos(NH))
    , c1
  );
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec2 envBRDFApprox( float Roughness, float NoV ) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022 );
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );
  vec4 r = Roughness * c0 + c1;
  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}

// GGX NDF
float d_GGX(float NH, float alphaRoughness) {
  float roughnessSqr = alphaRoughness * alphaRoughness;
  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

float d_torrance_reiz(float NH, float c3) {
  float CosSquared = NH*NH;
  float TanSquared = (1.0 - CosSquared)/CosSquared;
  //return (1.0/M_PI) * sq(c3/(CosSquared * (c3*c3 + TanSquared)));  // gamma = 2, aka GGX
  return (1.0/sqrt(M_PI)) * (sq(c3)/(CosSquared * (c3*c3 + TanSquared))); // gamma = 1, D_Berry
}

float d_beckmann(float NH, float m) {
  float co = 1.0 / (4.0 * m * m * NH * NH * NH * NH);
  float expx = exp((NH * NH - 1.0) / (m * m * NH * NH));
  return co * expx;
}

// the same as glTF WebGL sample
// https://github.com/KhronosGroup/glTF-WebGL-PBR/blob/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders/pbr-frag.glsl#L188
// That is, Unreal Engine based approach, but modified to use alphaRoughness (squared artist's roughness parameter),
// and based on 'Separable Masking and Shadowing' approximation (propesed by Christophe Schlick)
// https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf
float g_shielding(float NL, float NV, float alphaRoughness) {
  float r = alphaRoughness;

  // Local Shadowing using "Schlick-Smith" Masking Function
  float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));

  // Local Masking using "Schlick-Smith" Masking Function
  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));

  return localShadowing * localMasking;
}

// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
float v_GGXCorrelated(float NL, float NV, float alphaRoughness) {
  float a2 = alphaRoughness * alphaRoughness;
  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  float GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  return 0.5 / (GGXV + GGXL);
}

float v_GGXCorrelatedFast(float NL, float NV, float alphaRoughness) {
  float a = alphaRoughness;
  float GGXV = NL * (NV * (1.0 - a) + a);
  float GGXL = NV * (NL * (1.0 - a) + a);
  return 0.5 / (GGXV + GGXL);
}

// The Schlick Approximation to Fresnel
float fresnel(float f0, float f90, float VdotH) {
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

vec3 fresnel(vec3 f0, vec3 f90, float VdotH) {
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

vec3 fresnel(vec3 f0, float f90, float VdotH)
{
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

float fresnel(float f0, float VdotH)
{
  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnel(f0, f90, VdotH);
}
vec3 fresnel(vec3 f0, float VdotH)
{
  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnel(f0, f90, VdotH);
}

vec3 cook_torrance_specular_brdf(float NH, float NL, float NV, vec3 F, float alphaRoughness, float specularWeight) {
  float D = d_GGX(NH, alphaRoughness);
  float V = v_GGXCorrelated(NL, NV, alphaRoughness);
  return vec3(D) * vec3(V) * F * specularWeight;
//      float G = g_shielding(NL, NV, alphaRoughness);
//      return vec3(D)*vec3(G)*F/vec3(4.0*NL*NV);

}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf
vec3 BRDF_lambertian(vec3 albedo, vec3 F, float specularWeight)
{
  // (1/pi) * diffuseAlbedo
  return (vec3(1.0) - specularWeight * F) * albedo * RECIPROCAL_PI;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#specular-brdf
float specular_brdf(float alphaRoughness, float NdotL, float NdotV, float NdotH) {
  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  float D = d_GGX(NdotH, alphaRoughness);
  return V * D;
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes
float specular_btdf(float alphaRoughness, float NdotL, float NdotV, float NdotHt) {
  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  float D = d_GGX(NdotHt, alphaRoughness);
  return V * D;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel
vec3 conductor_fresnel(vec3 f0, float brdf, float alphaRoughness, float VdotH) {
  return vec3(brdf) * (f0.rgb + (vec3(1.0) - f0.rgb) * vec3(pow(1.0 - abs(VdotH), 5.0)));
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel
vec3 fresnel_mix(float ior, vec3 base, vec3 layer, float VdotH) {
  float f0 = pow((1.0 - ior)/(1.0 + ior), 2.0);
  float fr = f0 + (1.0 - f0) * pow(1.0 - abs(VdotH), 5.0);
  return mix(base, layer, fr);
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf
vec3 metal_brdf(float perceptualRoughness, vec3 baseColor, float NdotL, float NdotV, float NdotH, float VdotH) {
  float alphaRoughness = perceptualRoughness * perceptualRoughness;
  return conductor_fresnel(
    baseColor,
    specular_brdf(alphaRoughness, NdotL, NdotV, NdotH),
    alphaRoughness,
    VdotH
  );
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf
// vec3 dielectric_brdf(float ior, vec3 baseColor, float perceptualRoughness, float NdotL, float NdotV, float NdotH, float VdotH) {
//   vec3 base = BRDF_lambertian(baseColor);
//   float alphaRoughness = perceptualRoughness * perceptualRoughness;
//   vec3 layer = vec3(specular_brdf(alphaRoughness, NdotL, NdotV, NdotH));
//   return fresnel_mix(ior, base, layer, VdotH);
// }

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering
vec3 coated_material_s(vec3 base, float perceptualRoughness, float clearcoatRoughness, float clearcoat, float VdotNc, float LdotNc, float NdotHc) {
  float clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);
  float clearcoatAlpha = clearcoatRoughness * clearcoatRoughness;
  float alphaRoughness = perceptualRoughness * perceptualRoughness;
  float D = d_GGX(NdotHc, clearcoatAlpha);
  float V = v_GGXCorrelated(LdotNc, VdotNc, clearcoatAlpha);
  float f_clearcoat = clearcoatFresnel * D * V;

  // base = (f_diffuse + f_specular) in https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering
  return base * vec3(1.0 - clearcoat * clearcoatFresnel) + vec3(f_clearcoat * clearcoat);
}
vec3 srgbToLinear(vec3 srgbColor) {
  return pow(srgbColor, vec3(2.2));
}

float srgbToLinear(float value) {
  return pow(value, 2.2);
}

vec3 linearToSrgb(vec3 linearColor) {
  return pow(linearColor, vec3(1.0/2.2));
}

float linearToSrgb(float value) {
  return pow(value, 1.0/2.2);
}

// Roughness Dependent Fresnel
// https://www.jcgt.org/published/0008/01/03/paper.pdf
vec3 fresnelSchlickRoughness(vec3 F0, float cosTheta, float roughness)
{
  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;
  vec3 k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);
  return k_S;
}

// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66
vec3 Schlick_to_F0(vec3 f, vec3 f90, float VdotH) {
    float x = clamp(1.0 - VdotH, 0.0, 1.0);
    float x2 = x * x;
    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

float Schlick_to_F0(float f, float f90, float VdotH) {
    float x = clamp(1.0 - VdotH, 0.0, 1.0);
    float x2 = x * x;
    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

vec3 Schlick_to_F0(vec3 f, float VdotH) {
    return Schlick_to_F0(f, vec3(1.0), VdotH);
}

float Schlick_to_F0(float f, float VdotH) {
    return Schlick_to_F0(f, 1.0, VdotH);
}

vec3 normalBlendingUDN(sampler2D baseMap, sampler2D detailMap, vec2 baseUv, vec2 detailUv) {
  vec3 t = texture(baseMap,   baseUv).xyz * 2.0 - 1.0;
  vec3 u = texture(detailMap, detailUv).xyz * 2.0 - 1.0;
  vec3 r = normalize(vec3(t.xy + u.xy, t.z));
  return r;
}

vec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {
  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  mat3 rotationMat = mat3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  mat3 matrix = translationMat * rotationMat * scaleMat;
  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;

  return uvTransformed;
}

float IsotropicNDFFiltering(vec3 normal, float roughness2) {
  float SIGMA2 = 0.15915494;
  float KAPPA = 0.18;
  vec3 dndu = dFdx(normal);
  vec3 dndv = dFdy(normal);
  float kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));
  float clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);
  float filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);
  return filteredRoughness2;
}


////////////////////////////////////////
// glTF KHR_materials_volume
////////////////////////////////////////

#ifdef RN_USE_VOLUME
// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
vec3 volumeAttenuation(vec3 attenuationColor, float attenuationDistance, vec3 intensity, float transmissionDistance)
{
  if (attenuationDistance == 0.0) { // means Infinite distance
    return intensity; // No attenuation
  } else {
    vec3 attenuationCo = -log(attenuationColor) / attenuationDistance;
    vec3 attenuatedTransmittance = exp(-attenuationCo * transmissionDistance);
    return intensity * attenuatedTransmittance;
  }
}
#endif






////////////////////////////////////////
// glTF KHR_materials_anisotropy
////////////////////////////////////////
#ifdef RN_USE_ANISOTROPY
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
float D_GGX_anisotropic(float NdotH, float TdotH, float BdotH, float at, float ab)
{
    float a2 = at * ab;
    vec3 f = vec3(ab * TdotH, at * BdotH, a2 * NdotH);
    float w2 = a2 / dot(f, f);
    return a2 * w2 * w2 / M_PI;
}

float V_GGX_anisotropic(float NdotL, float NdotV, float BdotV, float TdotV, float TdotL, float BdotL,
    float at, float ab)
{
    float GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));
    float GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));
    float v = 0.5 / (GGXV + GGXL);
    return clamp(v, 0.0, 1.0);
}

vec3 BRDF_specularAnisotropicGGX(vec3 F, float alphaRoughness,
    float VdotH, float NdotL, float NdotV, float NdotH, float BdotV, float TdotV,
    float TdotL, float BdotL, float TdotH, float BdotH, float anisotropy)
{
    float at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
    float ab = alphaRoughness;

    float V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);
    float D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);

    return F * V * D;
}
#endif



////////////////////////////////////////
// glTF KHR_materials_sheen
////////////////////////////////////////

#ifdef RN_USE_SHEEN
float d_Charlie(float sheenPerceptualRoughness, float NoH) {
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  float alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;
  float invAlpha  = 1.0 / alphaG;
  float cos2h = NoH * NoH;
  float sin2h = 1.0 - cos2h;
  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
float sheenSimpleVisibility(float NdotL, float NdotV) {
  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
float charlieL(float x, float alphaG) {
  float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
  float a = mix(21.5473, 25.3245, oneMinusAlphaSq);
  float b = mix(3.82987, 3.32435, oneMinusAlphaSq);
  float c = mix(0.19823, 0.16801, oneMinusAlphaSq);
  float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
  float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
  return a / (1.0 + b * pow(x, c)) + d * x + e;
}

float lambdaSheen(float cosTheta, float alphaG)
{
  return abs(cosTheta) < 0.5 ? exp(charlieL(cosTheta, alphaG)) : exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG));
}

float sheenCharlieVisibility(float NdotL, float NdotV, float sheenPerceptualRoughness) {
  float alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;
  float sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));
  return sheenVisibility;
}

vec3 sheen_brdf(vec3 sheenColor, float sheenPerceptualRoughness, float NdotL, float NdotV, float NdotH) {
  float sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);
  float sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);
  return sheenColor * sheenDistribution * sheenVisibility;
}
#endif









////////////////////////////////////////
// glTF KHR_materials_irirdescence
////////////////////////////////////////

#ifdef RN_USE_IRIDESCENCE
// XYZ to REC709(sRGB) conversion matrix
const mat3 XYZ_TO_REC709 = mat3(
     3.2404542, -0.9692660,  0.0556434,
    -1.5371385,  1.8760108, -0.2040259,
    -0.4985314,  0.0415560,  1.0572252
);

vec3 fresnelSchlickRoughnessWithIridescence(
  vec3 F0, float cosTheta, float roughness,
  vec3 iridescenceFresnel, float iridescence
  )
{
  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;
  vec3 k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);
  return k_S;
}

// Assume air interface for top
vec3 Fresnel0ToIor(vec3 F0) {
    vec3 sqrtF0 = sqrt(F0);
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// Conversion from IOR to F0
// ior is a value between 1.0 and 3.0. 1.0 is air interface
vec3 IorToFresnel0(vec3 transmittedIor, float incidentIor) {
    return sq((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
float IorToFresnel0(float transmittedIor, float incidentIor) {
    return sq((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration
 */
vec3 evalSensitivity(float OPD, vec3 shift) {
    float phase = 2.0 * M_PI * OPD * 1.0e-9;
    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);

    vec3 xyz = val * sqrt(2.0 * M_PI * var) * cos(pos * phase + shift) * exp(-(phase * phase) * var);
    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));
    xyz /= 1.0685e-7;

    vec3 rgb = XYZ_TO_REC709 * xyz;
    return rgb;
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel
 */
vec3 calcIridescence(float outsideIor, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {


  // iridescenceIor is the index of refraction of the thin-film layer
  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
  float iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));

  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)
  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.
  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.
  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):
  float sinTheta2Sq = sq(outsideIor / iridescenceIor) * (1.0 - sq(cosTheta1));
  float cosTheta2Sq = 1.0 - sinTheta2Sq;

  // Handle total internal reflection
  if (cosTheta2Sq < 0.0) {
      return vec3(1.0);
  }

  float cosTheta2 = sqrt(cosTheta2Sq);

  /// Material Interfaces
  // The iridescence model defined by Belcour/Barla models two material interfaces
  // - one from the outside to the thin-film layer
  // and another one from the thin-film to the base material. These two interfaces are defined as follows:

  // First interface (from the outside to the thin-film layer)
  float R0 = IorToFresnel0(iridescenceIor, outsideIor);
  float R12 = fresnel(R0, cosTheta1);
  float R21 = R12;
  float T121 = 1.0 - R12;

  // Second interface (from the thin-film to the base material)
  vec3 baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0
  vec3 R1 = IorToFresnel0(baseIor, iridescenceIor);
  vec3 R23 = fresnel(R1, cosTheta2);

  // phi12 and phi23 define the base phases per interface and are approximated with 0.0
  // if the IOR of the hit material (iridescenceIor or baseIor) is higher
  // than the IOR of the previous material (outsideIor or iridescenceIor) and \u03C0 otherwise.
  // Also here, polarization is ignored.  float phi12 = 0.0;

  // First interface (from the outside to the thin-film layer)
  float phi12 = 0.0;
  if (iridescenceIor < outsideIor) phi12 = M_PI;
  float phi21 = M_PI - phi12;

  // Second interface (from the thin-film to the base material)
  vec3 phi23 = vec3(0.0);
  if (baseIor[0] < iridescenceIor) phi23[0] = M_PI;
  if (baseIor[1] < iridescenceIor) phi23[1] = M_PI;
  if (baseIor[2] < iridescenceIor) phi23[2] = M_PI;

  // OPD (optical path difference)
  float OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
  // Phase shift
  vec3 phi = vec3(phi21) + phi23;

  // Compound terms
  vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);
  vec3 r123 = sqrt(R123);
  vec3 Rs = (T121 * T121) * R23 / (vec3(1.0) - R123);

  // Reflectance term for m = 0 (DC term amplitude)
  vec3 C0 = R12 + Rs;
  vec3 I = C0;

  // Reflectance term for m > 0 (pairs of diracs)
  vec3 Cm = Rs - T121;
  for (int m = 1; m <= 2; ++m)
  {
      Cm *= r123;
      vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);
      I += Cm * Sm;
  }

  vec3 F_iridescence = max(I, vec3(0.0));

  return F_iridescence;
}

//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB
vec3 BRDF_lambertianIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float iridescenceFactor, vec3 diffuseColor, float specularWeight, float VdotH)
{
    vec3 iridescenceFresnelMax = vec3(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));
    vec3 schlickFresnel = Schlick_to_F0(f0, f90, VdotH);
    vec3 F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);

    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);
}

vec3 BRDF_specularGGXIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float alphaRoughness, float iridescenceFactor, float specularWeight, float VdotH, float NdotL, float NdotV, float NdotH)
{
    vec3 F = mix(Schlick_to_F0(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);
    float Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
    float D = d_GGX(NdotH, alphaRoughness);

    return specularWeight * F * Vis * D;
}

#endif // RN_USE_IRIDESCENCE





////////////////////////////////////////
// lighting with a punctual light
////////////////////////////////////////
vec3 lightingWithPunctualLight(
  Light light,
  vec3 normal_inWorld,
  vec3 viewDirection,
  float NdotV,
  vec3 albedo,
  float perceptualRoughness,
  float metallic,
  vec3 F0,
  vec3 F90,
  float ior,
  float transmission,
  float clearcoat,
  float clearcoatRoughness,
  vec3 clearcoatNormal_inWorld,
  float VdotNc,
  vec3 attenuationColor,
  float attenuationDistance,
  float anisotropy,
  vec3 anisotropicT,
  vec3 anisotropicB,
  float BdotV,
  float TdotV,
  vec3 sheenColor,
  float sheenRoughness,
  float albedoSheenScalingNdotV,
  float iridescenceFactor,
  vec3 iridescenceFresnel,
  float specularWeight
  )
{
  float alphaRoughness = perceptualRoughness * perceptualRoughness;

  // Fresnel
  vec3 halfVector = normalize(light.direction + viewDirection);
  float VdotH = dot(viewDirection, halfVector);
  vec3 F = fresnel(F0, F90, VdotH);

  float NdotL = saturateEpsilonToOne(dot(normal_inWorld, light.direction));

  // Diffuse
#ifdef RN_USE_IRIDESCENCE
  vec3 diffuseBrdf = BRDF_lambertianIridescence(F0, F90, iridescenceFresnel, iridescenceFactor, albedo, specularWeight, VdotH);
#else
  vec3 diffuseBrdf = BRDF_lambertian(albedo, F, specularWeight);
#endif

  vec3 pureDiffuse = diffuseBrdf * vec3(NdotL) * light.attenuatedIntensity;

#ifdef RN_USE_TRANSMISSION
  vec3 refractionVector = refract(-viewDirection, normal_inWorld, 1.0 / ior);
  Light transmittedLightFromUnderSurface = light;
  transmittedLightFromUnderSurface.pointToLight -= refractionVector;
  vec3 transmittedLightDirectionFromUnderSurface = normalize(transmittedLightFromUnderSurface.pointToLight);
  transmittedLightFromUnderSurface.direction = transmittedLightDirectionFromUnderSurface;

  vec3 Ht = normalize(viewDirection + transmittedLightFromUnderSurface.direction);
  float NdotHt = saturateEpsilonToOne(dot(normal_inWorld, Ht));
  float NdotLt = saturateEpsilonToOne(dot(normal_inWorld, transmittedLightFromUnderSurface.direction));

  vec3 transmittedContrib = (vec3(1.0) - F) * specular_btdf(alphaRoughness, NdotLt, NdotV, NdotHt) * albedo * transmittedLightFromUnderSurface.attenuatedIntensity;

#ifdef RN_USE_VOLUME
  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittedLightFromUnderSurface.pointToLight));
#endif // RN_USE_VOLUME

  vec3 diffuseContrib = mix(pureDiffuse, vec3(transmittedContrib), transmission);
#else
  vec3 diffuseContrib = pureDiffuse;
#endif // RN_USE_TRANSMISSION

  // Specular
  float NdotH = saturateEpsilonToOne(dot(normal_inWorld, halfVector));

#ifdef RN_USE_IRIDESCENCE
  vec3 specularContrib = BRDF_specularGGXIridescence(F0, F90, iridescenceFresnel, alphaRoughness, iridescenceFactor, specularWeight, VdotH, NdotL, NdotV, NdotH) * vec3(NdotL) * light.attenuatedIntensity;
#elif defined(RN_USE_ANISOTROPY)
  float TdotL = dot(anisotropicT, light.direction);
  float BdotL = dot(anisotropicB, light.direction);
  float TdotH = dot(anisotropicT, halfVector);
  float BdotH = dot(anisotropicB, halfVector);
  vec3 specularContrib = BRDF_specularAnisotropicGGX(F, alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3(NdotL) * light.attenuatedIntensity;
#else
  vec3 specularContrib = cook_torrance_specular_brdf(NdotH, NdotL, NdotV, F, alphaRoughness, specularWeight) * vec3(NdotL) * light.attenuatedIntensity;
#endif // RN_USE_ANISOTROPY

  // Base Layer
  vec3 baseLayer = diffuseContrib + specularContrib;

#ifdef RN_USE_SHEEN
  // Sheen
  vec3 sheenContrib = sheen_brdf(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;
  float albedoSheenScaling = min(
    albedoSheenScalingNdotV,
    1.0 - max3(sheenColor) * texture(u_sheenLutTexture, vec2(NdotL, sheenRoughness)).r);
  vec3 color = sheenContrib + baseLayer * albedoSheenScaling;
#else
  vec3 color = baseLayer;
  float albedoSheenScaling = 1.0;
#endif // RN_USE_SHEEN

#ifdef RN_USE_CLEARCOAT
  // Clear Coat Layer
  float NdotHc = saturateEpsilonToOne(dot(clearcoatNormal_inWorld, halfVector));
  float LdotNc = saturateEpsilonToOne(dot(light.direction, clearcoatNormal_inWorld));
  vec3 coated = coated_material_s(color, perceptualRoughness,
    clearcoatRoughness, clearcoat, VdotNc, LdotNc, NdotHc);
  vec3 finalColor = coated;
#else
  vec3 finalColor = color;
#endif // RN_USE_CLEARCOAT

  return finalColor;
}


/* shaderity: @{matricesGetters} */

vec3 get_irradiance(vec3 normal_forEnv, float materialSID, ivec2 hdriFormat) {
  vec4 diffuseTexel = texture(u_diffuseEnvTexture, normal_forEnv);

  vec3 irradiance;
  if (hdriFormat.x == 0) {
    // LDR_SRGB
    irradiance = srgbToLinear(diffuseTexel.rgb);
  }
  else if (hdriFormat.x == 3) {
    // RGBE
    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  }
  else {
    irradiance = diffuseTexel.rgb;
  }

  return irradiance;
}

float scaleForLod(float perceptualRoughness, float ior)
{
  // Scale roughness to the range [0, 1],
  // ior=1.0 will be scale 0,
  // ior=1.5 will be scale 1.0,
  // ior=2 will be scale 1.0 (clamped)
  //

  float scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);
  return perceptualRoughness * scale;
}

#ifdef RN_USE_TRANSMISSION
vec3 get_sample_from_backbuffer(float materialSID, vec2 sampleCoord, float perceptualRoughness, float ior) {
  ivec2 vrState = get_vrState(0.0, 0);
  vec2 backBufferTextureSize = vec2(textureSize(u_backBufferTexture, 0));
  float backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);

#ifdef WEBGL2_MULTI_VIEW
  // For VR
  backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
  sampleCoord.x = sampleCoord.x * 0.5;
  if (v_displayIdx == 1.0) { // For right eye
    sampleCoord.x += 0.5;
  }
#else
  if (vrState.x == 1) { // For VR
    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
    sampleCoord.x = sampleCoord.x * 0.5;
    if (vrState.y == 1) { // For right eye
      sampleCoord.x += 0.5;
    }
  }
#endif

  float framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);

  #ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
    vec3 transmittedLight = texture2DLodEXT(u_backBufferTexture, sampleCoord, framebufferLod).rgb;
  #elif defined(GLSL_ES3)
    vec3 transmittedLight = textureLod(u_backBufferTexture, sampleCoord, framebufferLod).rgb;
  #else
    vec3 transmittedLight = texture(u_backBufferTexture, sampleCoord).rgb;
  #endif

  return transmittedLight;
}
#endif

vec3 get_radiance(vec3 reflection, float lod, ivec2 hdriFormat) {
  #ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
    vec4 specularTexel = textureCubeLodEXT(u_specularEnvTexture, reflection, lod);
  #elif defined(GLSL_ES3)
    vec4 specularTexel = textureLod(u_specularEnvTexture, reflection, lod);
  #else
    vec4 specularTexel = texture(u_specularEnvTexture, reflection);
  #endif

// #pragma shaderity: require(./../common/fetchCubeTexture.glsl)

  vec3 radiance;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer
vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior)
{
  vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);
  mat4 worldMatrix = get_worldMatrix(v_instanceInfo);

  vec3 modelScale;
  modelScale.x = length(vec3(worldMatrix[0].xyz));
  modelScale.y = length(vec3(worldMatrix[1].xyz));
  modelScale.z = length(vec3(worldMatrix[2].xyz));

  return normalize(refractionVector) * thickness * modelScale;
}

struct IblResult
{
  vec3 specular;
  vec3 diffuse;
  vec3 FssEss;
};

#ifdef RN_USE_IRIDESCENCE
IblResult getIBLRadianceGGXWithIridescence(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,
  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,
  vec3 normal_forEnv, vec3 reflection, vec3 iridescenceFresnel, float iridescence, float specularWeight)
{
  // get radiance
  float mipCount = iblParameter.x;
  float lod = (perceptualRoughness * (mipCount - 1.0));
  vec3 radiance = get_radiance(reflection, lod, hdriFormat);

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughnessWithIridescence(F0, NdotV, perceptualRoughness, iridescenceFresnel, iridescence);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = kS * f_ab.x + f_ab.y;
  IblResult result;
  result.FssEss = FssEss;

  // Specular IBL
  vec3 specular = FssEss * radiance * specularWeight;

  // scale with user parameters
  float IBLSpecularContribution = iblParameter.z;
  specular *= IBLSpecularContribution;

  result.specular = specular;

  return result;
}

IblResult getIBLRadianceLambertianWithIridescence(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,
  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,
  vec3 normal_forEnv, vec3 reflection, vec3 iridescenceF0, float iridescence, float specularWeight)
{
  // get irradiance
  vec3 irradiance = get_irradiance(normal_forEnv, materialSID, hdriFormat);

  // Use the maximum component of the iridescence Fresnel color
  // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF
  vec3 iridescenceF0Max = vec3(max(max(iridescenceF0.r, iridescenceF0.g), iridescenceF0.b));

  // Blend between base F0 and iridescence F0
  vec3 mixedF0 = mix(F0, iridescenceF0Max, iridescence);

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughness(mixedF0, NdotV, perceptualRoughness);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = specularWeight * kS * f_ab.x + f_ab.y;
  IblResult result;
  result.FssEss = FssEss;

  // Multiple scattering, Fdez-Aguera's approach
  float Ems = (1.0 - (f_ab.x + f_ab.y));
  vec3 F_avg = specularWeight * (mixedF0 + (1.0 - mixedF0) / 21.0);
  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);
  vec3 k_D = albedo * (1.0 - FssEss - FmsEms);

  // Diffuse IBL
  vec3 diffuse = (FmsEms + k_D) * irradiance;

  // scale with user parameters
  float IBLDiffuseContribution = iblParameter.y;
  diffuse *= IBLDiffuseContribution;

  result.diffuse = diffuse;

  return result;
}
#endif // RN_USE_IRIDESCENCE

IblResult getIBLRadianceLambertian(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,
  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,
  vec3 normal_forEnv, vec3 reflection, float specularWeight)
{
  // get irradiance
  vec3 irradiance = get_irradiance(normal_forEnv, materialSID, hdriFormat);

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = specularWeight * kS * f_ab.x + f_ab.y;
  IblResult result;
  result.FssEss = FssEss;

  // Multiple scattering, Fdez-Aguera's approach
  float Ems = (1.0 - (f_ab.x + f_ab.y));
  vec3 F_avg = specularWeight * (F0 + (1.0 - F0) / 21.0);
  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);
  vec3 k_D = albedo * (1.0 - FssEss - FmsEms);

  // Diffuse IBL
  vec3 diffuse = (FmsEms + k_D) * irradiance;

  // scale with user parameters
  float IBLDiffuseContribution = iblParameter.y;
  diffuse *= IBLDiffuseContribution;

  result.diffuse = diffuse;

  return result;
}

IblResult getIBLRadianceGGX(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,
  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,
  vec3 normal_forEnv, vec3 reflection, float specularWeight)
{
  // get radiance
  float mipCount = iblParameter.x;
  float lod = (perceptualRoughness * (mipCount - 1.0));
  vec3 radiance = get_radiance(reflection, lod, hdriFormat);

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = kS * f_ab.x + f_ab.y;
  IblResult result;
  result.FssEss = FssEss;

  // Specular IBL
  vec3 specular = FssEss * radiance * specularWeight;

  // scale with user parameters
  float IBLSpecularContribution = iblParameter.z;
  specular *= IBLSpecularContribution;

  result.specular = specular;

  return result;
}

#ifdef RN_USE_SHEEN
vec3 sheenIBL(float NdotV, float sheenPerceptualRoughness, vec3 sheenColor, vec4 iblParameter, vec3 reflection, ivec2 hdriFormat)
{
  float mipCount = iblParameter.x;
  float lod = (sheenPerceptualRoughness * (mipCount - 1.0));

  vec2 sheenLutUV = vec2(NdotV, sheenPerceptualRoughness);
  float brdf = texture(u_sheenLutTexture, sheenLutUV).b;
  vec3 sheenLight = get_radiance(reflection, lod, hdriFormat);
  float IBLSpecularContribution = iblParameter.z;
  sheenLight *= IBLSpecularContribution;

  return sheenLight * sheenColor * brdf;
}
#endif

vec3 getNormalForEnv(mat3 rotEnvMatrix, vec3 normal_inWorld, float materialSID) {
  vec3 normal_forEnv = rotEnvMatrix * normal_inWorld;
  if (get_inverseEnvironment(materialSID, 0)) {
    normal_forEnv.x *= -1.0;
  }
  return normal_forEnv;
}

vec3 getReflection(mat3 rotEnvMatrix, vec3 viewDirection, vec3 normal_inWorld, float materialSID, float perceptualRoughness, float anisotropy, vec3 anisotropyDirection) {
#ifdef RN_USE_ANISOTROPY

  float tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);
  vec3  anisotropicTangent  = cross(anisotropyDirection, viewDirection);
  vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);
  float bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);
  float bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;
  vec3  bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));
  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);
#else
  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);
#endif
  if (get_inverseEnvironment(materialSID, 0)) {
    reflection.x *= -1.0;
  }
  return reflection;
}

vec3 IBLContribution(float materialSID, vec3 normal_inWorld, float NdotV, vec3 viewDirection,
  vec3 albedo, vec3 F0, float perceptualRoughness, float clearcoatRoughness, vec3 clearcoatNormal_inWorld,
  float clearcoat, float VdotNc, vec3 geomNormal_inWorld, float cameraSID, float transmission, vec3 v_position_inWorld,
  float thickness, vec3 sheenColor, float sheenRoughness, float albedoSheenScalingNdotV, float ior,
  vec3 iridescenceFresnel, vec3 iridescenceF0, float iridescence, float anisotropy, vec3 anisotropyDirection,
  float specularWeight)
{
  vec4 iblParameter = get_iblParameter(materialSID, 0);
  float rot = iblParameter.w;
  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);

  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  vec3 reflection = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);

  // IBL
  #ifdef RN_USE_IRIDESCENCE
    IblResult baseRadianceResult = getIBLRadianceGGXWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,
      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceFresnel, iridescence, specularWeight);
    IblResult baseLambertianResult = getIBLRadianceLambertianWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,
      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceF0, iridescence, specularWeight);
  #else
    IblResult baseRadianceResult = getIBLRadianceGGX(materialSID, NdotV, viewDirection, albedo, F0,
      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);
    IblResult baseLambertianResult = getIBLRadianceLambertian(materialSID, NdotV, viewDirection, albedo, F0,
      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);
  #endif

#ifdef RN_USE_TRANSMISSION
  vec3 refractedRay = getVolumeTransmissionRay(geomNormal_inWorld, viewDirection, thickness, ior);
  vec3 refractedRayFromVPosition = v_position_inWorld + refractedRay;
  vec4 ndcPoint = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4(refractedRayFromVPosition, 1.0);
  vec2 refractionCoords = ndcPoint.xy / ndcPoint.w;
  refractionCoords += 1.0;
  refractionCoords /= 2.0;
  vec3 transmittedLight = get_sample_from_backbuffer(materialSID, refractionCoords, perceptualRoughness, ior);

#ifdef RN_USE_VOLUME
  vec3 attenuationColor = get_attenuationColor(materialSID, 0);
  float attenuationDistance = get_attenuationDistance(materialSID, 0);
  transmittedLight = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, length(refractedRay));
#endif

  vec3 transmissionComp = (vec3(1.0) - baseRadianceResult.FssEss) * transmittedLight * albedo;
  vec3 diffuse = mix(baseLambertianResult.diffuse, transmissionComp, transmission);
  vec3 base = diffuse + baseRadianceResult.specular;
#else
  vec3 base = baseLambertianResult.diffuse + baseRadianceResult.specular;
#endif

#ifdef RN_USE_SHEEN
  vec3 sheen = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);
  vec3 color = sheen + base * albedoSheenScalingNdotV;
#else
  vec3 color = base;
#endif

#ifdef RN_USE_CLEARCOAT
  float VdotNg = dot(geomNormal_inWorld, viewDirection);
  vec3 clearcoatNormal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  IblResult coatResult = getIBLRadianceGGX(materialSID, VdotNc, viewDirection, vec3(0.0), F0,
    clearcoatRoughness, iblParameter, hdriFormat, rotEnvMatrix, clearcoatNormal_forEnv, reflection, specularWeight);
  vec3 coatLayer = coatResult.specular;

  float clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);
  vec3 coated = color * vec3(1.0 - clearcoat * clearcoatFresnel) + vec3(coatLayer * clearcoat);
  return coated;
#else
  return color;
#endif

}


uniform bool u_inverseEnvironment; // initialValue=false
uniform vec4 u_iblParameter; // initialValue=(1,1,1,1), isInternalSetting=true
uniform ivec2 u_hdriFormat; // initialValue=(0,0), isInternalSetting=true

uniform samplerCube u_diffuseEnvTexture; // initialValue=(5,black), isInternalSetting=true
uniform samplerCube u_specularEnvTexture; // initialValue=(6,black), isInternalSetting=true


float edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {
  vec3 d = fwidth(bary3);
  vec3 x = bary3+vec3(1.0 - wireframeWidthInner)*d;
  vec3 a3 = smoothstep(vec3(0.0), d, x);
  float factor = min(min(a3.x, a3.y), a3.z);

  return clamp((1.0 - factor), 0.0, 1.0);
}

const float PI_2 = 6.28318530718;

vec2 uvAnimation(vec2 origUv, float time, float uvAnimationMask, float uvAnimationScrollXSpeedFactor, float uvAnimationScrollYSpeedFactor, float uvAnimationRotationSpeedFactor) {
  float uvAnim = uvAnimationMask * time;
  vec2 uv = origUv;
  uv += vec2(uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor) * uvAnim;
  float rotateRad = uvAnimationRotationSpeedFactor * PI_2 * uvAnim;
  const vec2 rotatePivot = vec2(0.5);
  uv = mat2(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (uv - rotatePivot) + rotatePivot;
  return uv;
}

#ifdef RN_USE_TANGENT
  mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {
    vec3 tangent_inWorld = normalize(v_tangent_inWorld);
    vec3 binormal_inWorld = normalize(v_binormal_inWorld);
    mat3 tbnMat_tangent_to_world = mat3(tangent_inWorld, binormal_inWorld, normal_inWorld);

    return tbnMat_tangent_to_world;
  }
#else
    // This is based on http://www.thetenthplanet.de/archives/1180
    mat3 cotangent_frame(vec3 normal_inWorld, vec3 position, vec2 uv) {
      uv = gl_FrontFacing ? uv : -uv;

      // get edge vectors of the pixel triangle
      vec3 dp1 = dFdx(position);
      vec3 dp2 = dFdy(position);
      vec2 duv1 = dFdx(uv);
      vec2 duv2 = dFdy(uv);

      // solve the linear system
      vec3 dp2perp = cross(dp2, normal_inWorld);
      vec3 dp1perp = cross(normal_inWorld, dp1);
      vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;
      vec3 bitangent = dp2perp * duv1.y + dp1perp * duv2.y;
      bitangent *= -1.0;

      // construct a scale-invariant frame
      float invMat = inversesqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));
      return mat3(tangent * invMat, bitangent * invMat, normal_inWorld);
    }

    mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {
      mat3 tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord);

      return tbnMat_tangent_to_world;
    }
#endif


void main (){
  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_NONE
      discard;
    #endif
  #endif

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  // uv animation
  float uvAnimationMaskTexture = texture(u_uvAnimationMaskTexture, v_texcoord_0).r;
  float uvAnimationScrollXSpeedFactor = get_uvAnimationScrollXSpeedFactor(materialSID, 0);
  float uvAnimationScrollYSpeedFactor = get_uvAnimationScrollYSpeedFactor(materialSID, 0);
  float uvAnimationRotationSpeedFactor = get_uvAnimationRotationSpeedFactor(materialSID, 0);
  float time = get_time(0.0, 0);
  vec2 mainUv = uvAnimation(v_texcoord_0, time, uvAnimationMaskTexture, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);

  // main color
  vec4 litTextureColor = texture(u_litColorTexture, mainUv);
  vec4 litColorFactor = get_litColor(materialSID, 0);

  // alpha
  float alpha = 1.0;

  #ifdef RN_ALPHATEST_ON
    alpha = litTextureColor.a * litColorFactor.a;
    float cutoff = get_cutoff(materialSID, 0);
    if(alpha < cutoff) discard;
  #elif defined(RN_ALPHABLEND_ON)
    alpha = litTextureColor.a * litColorFactor.a;
  #endif

  if (alpha < 0.01) {
    discard;
  }else{
    rt0.w = alpha;
  }


  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_COLOR_FIXED
      vec3 outlineColor = get_outlineColor(materialSID, 0);
      rt0.xyz = outlineColor;

      rt0.xyz = srgbToLinear(rt0.xyz);
/* shaderity: @{renderTargetEnd} */

      return;
    #endif
  #endif

  // view vector
  vec3 viewPosition = get_viewPosition(cameraSID, 0);
  vec3 viewVector = viewPosition - v_position_inWorld.xyz;
  vec3 viewDirection = normalize(viewVector);

  // Normal
  vec3 normal_inWorld = normalize(v_normal_inWorld);
  #ifdef RN_MTOON_HAS_BUMPMAP
    vec3 normal = texture(u_normalTexture, mainUv).xyz * 2.0 - 1.0;
    mat3 TBN = getTBN(normal_inWorld, viewDirection, mainUv);
    normal_inWorld = normalize(TBN * normal);
  #endif

  #ifdef RN_MTOON_IS_OUTLINE
    normal_inWorld *= -1.0;
  #endif


  // Lighting, Direct Light

  float shadowAttenuation = 1.0;
  // TODO: shadowmap computation

  float receiveShadowRate = get_receiveShadowRate(materialSID, 0);
  float lightAttenuation = shadowAttenuation * mix(1.0, shadowAttenuation, receiveShadowRate * texture(u_receiveShadowTexture, mainUv).r);

  float shadingGradeRate = get_shadingGradeRate(materialSID, 0);
  float shadingGrade = 1.0 - shadingGradeRate * (1.0 - texture(u_shadingGradeTexture, mainUv).r);
  float lightColorAttenuation = get_lightColorAttenuation(materialSID, 0);

  vec3 shadeColorFactor = get_shadeColor(materialSID, 0);
  vec3 shadeColor = shadeColorFactor * srgbToLinear(texture(u_shadeColorTexture, mainUv).xyz);

  vec3 litColor = litColorFactor.xyz * srgbToLinear(litTextureColor.xyz);

  float shadeShift = get_shadeShift(materialSID, 0);
  float shadeToony = get_shadeToony(materialSID, 0);

  vec3 lightings[/* shaderity: @{Config.maxLightNumberInShader} */];
  #ifdef RN_MTOON_DEBUG_LITSHADERATE
    float lightIntensities[/* shaderity: @{Config.maxLightNumberInShader} */];
  #endif
  for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {
    if (i >= lightNumber) {
      break;
    }

    // Light
    Light light = getLight(i, v_position_inWorld.xyz);

    // lightAttenuation *= distanceAttenuation * spotEffect;
    float dotNL = dot(light.direction, normal_inWorld);
    float lightIntensity = dotNL * 0.5 + 0.5; // from [-1, +1] to [0, 1]
    lightIntensity = lightIntensity * lightAttenuation; // TODO: receive shadow
    lightIntensity = lightIntensity * shadingGrade; // darker
    lightIntensity = lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]

    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]
    float maxIntensityThreshold = mix(1.0, shadeShift, shadeToony);
    float minIntensityThreshold = shadeShift;
    lightIntensity = clamp((lightIntensity - minIntensityThreshold) / max(EPS_COL, (maxIntensityThreshold - minIntensityThreshold)), 0.0, 1.0);
    #ifdef RN_MTOON_DEBUG_LITSHADERATE
      lightIntensities[i] = lightIntensity;
    #endif

    // Albedo color
    vec3 col = mix(shadeColor, litColor, lightIntensity);

    // Direct Light
    vec3 lighting = light.attenuatedIntensity;
    lighting = mix(lighting, vec3(max(EPS_COL, max(lighting.x, max(lighting.y, lighting.z)))), lightColorAttenuation); // color atten


    if(i > 0){
      lighting *= 0.5; // darken if additional light.
      lighting *= min(0.0, dotNL) + 1.0; // darken dotNL < 0 area by using half lambert
      // lighting *= shadowAttenuation; // darken if receiving shadow
      #ifdef RN_ALPHABLEND_ON
        lighting *= step(0.0, dotNL); // darken if transparent. Because Unity's transparent material can't receive shadowAttenuation.
      #endif
    }

    col *= lighting * RECIPROCAL_PI;
    lightings[i] = lighting;

    rt0.xyz += col;

    lightAttenuation = 1.0;
  }


  // Indirect Light
  float indirectLightIntensity = get_indirectLightIntensity(materialSID, 0);
  vec3 worldUpVector = vec3(0.0, 1.0, 0.0);
  vec3 worldDownVector = vec3(0.0, -1.0, 0.0);
  vec4 iblParameter = get_iblParameter(materialSID, 0);
  float rot = iblParameter.w;
  float IBLDiffuseContribution = iblParameter.y;
  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);
  vec3 rawGiUp = get_irradiance(worldUpVector, materialSID, hdriFormat) * IBLDiffuseContribution;
  vec3 rawGiDown = get_irradiance(worldDownVector, materialSID, hdriFormat) * IBLDiffuseContribution;
  vec3 rawGiNormal = get_irradiance(normal_forEnv, materialSID, hdriFormat) * IBLDiffuseContribution;
  vec3 uniformedGi = (rawGiUp + rawGiDown) / 2.0;
  vec3 passthroughGi = rawGiNormal;
  vec3 indirectLighting = mix(uniformedGi, passthroughGi, indirectLightIntensity);
  indirectLighting = mix(indirectLighting, vec3(max(EPS_COL, max(indirectLighting.x, max(indirectLighting.y, indirectLighting.z)))), lightColorAttenuation); // color atten

  rt0.xyz += indirectLighting * litColor * RECIPROCAL_PI;
  // rt0.xyz = min(rt0.xyz, litColor); // comment out if you want to PBR absolutely.


  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_COLOR_MIXED
      vec3 outlineColor = get_outlineColor(materialSID, 0);
      // outlineColor = srgbToLinear(outlineColor);
      float outlineLightingMix = get_outlineLightingMix(materialSID, 0);
      rt0.xyz = outlineColor * mix(vec3(1.0), rt0.xyz, outlineLightingMix);
    #endif
  #else
    float rimFresnelPower = get_rimFresnelPower(materialSID, 0);
    float rimLift = get_rimLift(materialSID, 0);
    vec3 rimColorFactor = get_rimColor(materialSID, 0);
    vec3 rimTextureColor = texture(u_rimTexture, mainUv).xyz;
    vec3 rimColor = rimColorFactor * srgbToLinear(rimTextureColor);
    vec3 rim = pow(clamp(1.0 - dot(normal_inWorld, viewDirection) + rimLift, 0.0, 1.0), rimFresnelPower) * rimColor;

    float staticRimLighting = 1.0;
    float rimLightingMix = get_rimLightingMix(materialSID, 0);
    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {
      if (i >= lightNumber) break;

      if(i > 0) staticRimLighting = 0.0;

      vec3 rimLighting = mix(vec3(staticRimLighting), lightings[i], vec3(rimLightingMix));
      rt0.xyz += rim * rimLighting;
    }

    // additive matcap
    vec3 cameraUp = get_cameraUp(0.0, 0); //solo datum
    vec3 worldViewUp = normalize(cameraUp - viewDirection * dot(viewDirection, cameraUp));
    vec3 worldViewRight = normalize(cross(viewDirection, worldViewUp));
    vec2 matcapUv = vec2(dot(worldViewRight, normal_inWorld), dot(worldViewUp, normal_inWorld)) * 0.5 + 0.5;
    vec3 matCapColor = srgbToLinear(texture(u_matCapTexture, matcapUv).xyz);
    rt0.xyz += matCapColor;


    // Emission
    vec3 emissionColor = get_emissionColor(materialSID, 0);
    vec3 emission = srgbToLinear(texture(u_emissionTexture, mainUv).xyz) * emissionColor;
    rt0.xyz += emission;
  #endif


  // debug
  #ifdef RN_MTOON_DEBUG_NORMAL
    rt0 = vec4(normal_inWorld * 0.5 + 0.5, alpha);

    rt0.xyz = srgbToLinear(rt0.xyz);
/* shaderity: @{renderTargetEnd} */

    return;
  #elif defined(RN_MTOON_DEBUG_LITSHADERATE)
    rt0 = vec4(0.0);
    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {
      if (i >= lightNumber) break;
      rt0 += vec4(lightIntensities[i] * lightings[i], alpha);
    }

    rt0.xyz = srgbToLinear(rt0.xyz);
/* shaderity: @{renderTargetEnd} */

    return;
  #endif


  // Wireframe
  float threshold = 0.001;
  vec3 wireframe = get_wireframe(materialSID, 0);
  float wireframeWidthInner = wireframe.z;
  float wireframeWidthRelativeScale = 1.0;
  if (wireframe.x > 0.5 && wireframe.y < 0.5) {
    rt0.a = 0.0;
  }
  vec4 wireframeResult = rt0;
  vec4 wireframeColor = vec4(0.2, 0.75, 0.0, 1.0);
  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);
  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);
  // if r0.a is 0.0, it is wireframe not on shaded
  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified);
  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));

  if (wireframe.x > 0.5) {
    rt0 = wireframeResult;
    if (wireframe.y < 0.5 && rt0.a == 0.0) {
      discard;
    }
  }

float makeOutputSrgb = float(get_makeOutputSrgb(materialSID, 0));
rt0.rgb = mix(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb);


/* shaderity: @{renderTargetEnd} */

}
`, shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/MToon0xSingleShader/MToon0xSingleShader.vert.wgsl
var MToon0xSingleShader_vert_default2;
var init_MToon0xSingleShader_vert2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/MToon0xSingleShader/MToon0xSingleShader.vert.wgsl"() {
    MToon0xSingleShader_vert_default2 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n// This shader is based on https://github.com/Santarh/MToon\n\n\n#ifdef RN_IS_SKINNING\n\nfn createMatrixFromQuaternionTranslationScale( quaternion: vec4<f32>, translation: vec3<f32>, scale: vec3<f32> ) -> mat4x4<f32> {\n  let q = quaternion;\n  let t = translation;\n\n  let sx = q.x * q.x;\n  let sy = q.y * q.y;\n  let sz = q.z * q.z;\n  let cx = q.y * q.z;\n  let cy = q.x * q.z;\n  let cz = q.x * q.y;\n  let wx = q.w * q.x;\n  let wy = q.w * q.y;\n  let wz = q.w * q.z;\n\n  let mat = mat4x4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  let uniformScaleMat = mat4x4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  let mat44 = mat*uniformScaleMat;\n  return mat44;\n\n}\n\nfn unpackedVec2ToNormalizedVec4(vec_xy: vec2<f32>, criteria: f32) -> vec4<f32> {\n\n  var r: f32;\n  var g: f32;\n  var b: f32;\n  var a: f32;\n\n  let ix = floor(vec_xy.x * criteria);\n  let v1x = ix / criteria;\n  let v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  let iy = floor( vec_xy.y * criteria);\n  let v2x = iy / criteria;\n  let v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4<f32>(r, g, b, a);\n}\n\nfn get_boneMatrixAsMat4x4(skeletalComponentSID: u32, joint: u32) -> mat4x4<f32> {\n  let mat43: mat4x3<f32> = get_boneMatrix(skeletalComponentSID, joint);\n  return mat4x4<f32>(\n    vec4<f32>(mat43[0], 0.0),\n    vec4<f32>(mat43[1], 0.0),\n    vec4<f32>(mat43[2], 0.0),\n    vec4<f32>(mat43[3], 1.0)\n  );\n}\n\nfn getSkinMatrix(skeletalComponentSID: u32, joint: vec4<u32>, weight: vec4<f32>) -> mat4x4<f32> {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  var skinMat: mat4x4<f32> = weight.x * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.x);\n  skinMat += weight.y * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.y);\n  skinMat += weight.z * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.z);\n  skinMat += weight.w * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.w);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  let criteria = vec2<f32>(4096.0, 4096.0);\n\n  let tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, joint.x);\n  let sq_x = get_boneScalePackedQuat(skeletalComponentSID, joint.x);\n  var quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  let tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, joint.y);\n  let sq_y = get_boneScalePackedQuat(skeletalComponentSID, joint.y);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  let tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, joint.z);\n  let sq_z = get_boneScalePackedQuat(skeletalComponentSID, joint.z);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  let tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, joint.w);\n  let sq_w = get_boneScalePackedQuat(skeletalComponentSID, joint.w);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  let ts_x = get_boneTranslateScale(skeletalComponentSID, joint.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = get_boneTranslateScale(skeletalComponentSID, joint.y);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.y), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = get_boneTranslateScale(skeletalComponentSID, joint.z);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.z), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = get_boneTranslateScale(skeletalComponentSID, joint.w);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.w), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  let boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, joint.x);\n  let boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, joint.y);\n  let boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, joint.z);\n  let boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, joint.w);\n\n  let criteria = vec2<f32>(4096.0, 4096.0);\n  let boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  let ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\nfn toNormalMatrix(m: mat4x4<f32>) -> mat3x3<f32> {\n  let a00 = m[0][0];\n  let a01 = m[0][1];\n  let a02 = m[0][2];\n  let a03 = m[0][3];\n  let a10 = m[1][0];\n  let a11 = m[1][1];\n  let a12 = m[1][2];\n  let a13 = m[1][3];\n  let a20 = m[2][0];\n  let a21 = m[2][1];\n  let a22 = m[2][2];\n  let a23 = m[2][3];\n  let a30 = m[3][0];\n  let a31 = m[3][1];\n  let a32 = m[3][2];\n  let a33 = m[3][3];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  let determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3x3<f32>(\n    (a11 * b11 - a12 * b10 + a13 * b09) / determinantVal,\n    (a12 * b08 - a10 * b11 - a13 * b07) / determinantVal,\n    (a10 * b10 - a11 * b08 + a13 * b06) / determinantVal,\n    (a02 * b10 - a01 * b11 - a03 * b09) / determinantVal,\n    (a00 * b11 - a02 * b08 + a03 * b07) / determinantVal,\n    (a01 * b08 - a00 * b10 - a03 * b06) / determinantVal,\n    (a31 * b05 - a32 * b04 + a33 * b03) / determinantVal,\n    (a32 * b02 - a30 * b05 - a33 * b01) / determinantVal,\n    (a30 * b04 - a31 * b02 + a33 * b00) / determinantVal\n  );\n}\n\nstruct GeometoryOutput {\n  normalMatrix: mat3x3<f32>,\n  position_inWorld: vec4<f32>,\n  normal_inWorld: vec3<f32>,\n  isSkinning: bool,\n}\n\n#ifdef RN_IS_SKINNING\nfn skinning(\n  skeletalComponentSID: u32,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n  ) -> GeometoryOutput\n{\n  var output: GeometoryOutput;\n  let skinMat = getSkinMatrix(skeletalComponentSID, joint, weight);\n  output.position_inWorld = skinMat * vec4<f32>(inPosition_inLocal, 1.0);\n  output.normalMatrix = toNormalMatrix(skinMat);\n  output.normal_inWorld = normalize(output.normalMatrix * inNormal_inLocal);\n  output.isSkinning = true;\n\n  return output;\n}\n#endif\n\n\nfn processGeometryWithMorphingAndSkinning(\n  skeletalComponentSID: i32,\n  blendShapeComponentSID: u32,\n  worldMatrix: mat4x4<f32>,\n  viewMatrix: mat4x4<f32>,\n  isBillboard: bool,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  baryCentricCoord: vec4<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n) -> GeometoryOutput {\n  var output: GeometoryOutput;\n\n  var position_inLocal: vec3<f32>;\n#ifdef RN_IS_MORPHING\n  if (uniformDrawParameters.morphTargetNumber == 0u) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    let vertexIdx = u32(baryCentricCoord.w);\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal, blendShapeComponentSID);\n  }\n#endif\n\n  var worldMatrixInner = worldMatrix;\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0) {\n    output = skinning(u32(skeletalComponentSID), inNormalMatrix, position_inLocal, inNormal_inLocal, joint, weight);\n  } else {\n#endif\n    output.normalMatrix = inNormalMatrix;\n    output.position_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    output.normal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n    output.isSkinning = false;\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return output;\n}\n\n\n@vertex\nfn main(\n#ifdef RN_USE_INSTANCE\n  @location(8) instance_ids: vec4<f32>,\n#endif\n\n\n#ifdef RN_USE_POSITION_FLOAT\n  @location(0) position: vec3<f32>,\n#endif\n#ifdef RN_USE_POSITION_INT\n  @location(0) position: vec3<i32>,\n#endif\n#ifdef RN_USE_POSITION_UINT\n  @location(0) position: vec3<u32>,\n#endif\n\n#ifdef RN_USE_NORMAL\n  @location(1) normal: vec3<f32>,\n#endif\n#ifdef RN_USE_TANGENT\n  @location(2) tangent: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_0\n  @location(3) texcoord_0: vec2<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  @location(4) texcoord_1: vec2<f32>,\n#endif\n\n#ifdef RN_USE_COLOR_0_FLOAT\n  @location(5) color_0: vec4<f32>,\n#endif\n#ifdef RN_USE_COLOR_0_INT\n  @location(5) color_0: vec4<i32>,\n#endif\n#ifdef RN_USE_COLOR_0_UINT\n  @location(5) color_0: vec4<u32>,\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  @location(6) joints_0: vec4<u32>,\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  @location(7) weights_0: vec4<f32>,\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  @location(10) baryCentricCoord: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  @location(11) texcoord_2: vec2<f32>,\n#endif\n  @builtin(vertex_index) vertexIdx : u32,\n\n\n) -> VertexOutput {\n  var output : VertexOutput;\n  #ifdef RN_MTOON_IS_OUTLINE\n    #ifdef RN_MTOON_OUTLINE_NONE\n      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      return output;\n    #endif\n  #endif\n\n#ifdef RN_USE_NORMAL\n#else\n  let normal = vec3<f32>(0.0, 0.0, 0.0);\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  let joint = joints_0;\n#else\n  let joint = vec4<u32>(0, 0, 0, 0);\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  let weight = weights_0;\n#else\n  let weight = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n#else\n  let baryCentricCoord = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  let instanceId = u32(instance_ids.x);\n  let worldMatrix = get_worldMatrix(instanceId);\n  let normalMatrix = get_normalMatrix(instanceId);\n  let viewMatrix = get_viewMatrix(cameraSID, 0);\n  let skeletalComponentSID = i32(instance_ids.y);\n  let blendShapeComponentSID = u32(instance_ids.z);\n  let geom = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    blendShapeComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    position,\n    normal,\n    baryCentricCoord,\n    joint,\n    weight\n  );\n\n  let projectionMatrix = get_projectionMatrix(cameraSID, 0);\n\n  output.position_inWorld = geom.position_inWorld.xyz;\n  output.normal_inWorld = geom.normal_inWorld;\n  output.normal_inView = (viewMatrix * vec4(geom.normal_inWorld, 0.0)).xyz;\n\n  #ifdef RN_MTOON_IS_OUTLINE\n    #ifdef RN_MTOON_HAS_OUTLINE_WIDTH_TEXTURE\n      let textureSize = textureDimensions(outlineWidthTexture, 0);\n      let outlineTex = textureLoad(outlineWidthTexture, vec2u(vec2f(textureSize) * texcoord_0), 0).r;\n    #else\n      let outlineTex = 1.0;\n    #endif\n\n    #ifdef RN_MTOON_OUTLINE_WIDTH_WORLD\n      let outlineWidth: f32 = get_outlineWidth(materialSID, 0);\n      let outlineOffset: vec3f = 0.01 * outlineWidth * outlineTex * normal;\n      let worldOutlineOffset: vec4f = worldMatrix * vec4f(outlineOffset, 0.0);\n      output.position = projectionMatrix * viewMatrix * (geom.position_inWorld + worldOutlineOffset);\n\n    #elif defined(RN_MTOON_OUTLINE_WIDTH_SCREEN)\n      var vertex: vec4f = projectionMatrix * viewMatrix * geom.position_inWorld;\n\n      let clipNormal: vec3f = (projectionMatrix * vec4f(output.normal_inView, 1.0)).xyz;\n      var projectedNormal: vec2f = normalize(clipNormal.xy);\n      let outlineScaledMaxDistance: f32 = get_outlineScaledMaxDistance(materialSID, 0);\n      projectedNormal *= min(vertex.w, outlineScaledMaxDistance);\n      let aspect: f32 = abs(get_aspect(0, 0)); //solo datum\n      projectedNormal.x *= aspect;\n\n      let outlineWidth: f32 = get_outlineWidth(materialSID, 0);\n      vertex += vec4f(0.01 * outlineWidth * outlineTex * projectedNormal * clamp(1.0 - abs(output.normal_inView.z), 0.0, 1.0), 0.0, 0.0); // ignore offset when normal toward camera\n\n      output.position = vertex;\n    #else\n      output.position = projectionMatrix * viewMatrix * geom.position_inWorld;\n    #endif\n  #else\n    output.position = projectionMatrix * viewMatrix * geom.position_inWorld;\n  #endif\n\n  #ifdef RN_USE_TANGENT\n    output.tangent_inWorld = normalMatrix * tangent.xyz;\n    output.binormal_inWorld = cross(geom.normal_inWorld, output.tangent_inWorld) * tangent.w;\n  #endif\n\n  output.texcoord_0 = texcoord_0;\n  output.baryCentricCoord = baryCentricCoord.xyz;\n\n  return output;\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/MToon0xSingleShader/MToon0xSingleShader.frag.wgsl
var MToon0xSingleShader_frag_default2;
var init_MToon0xSingleShader_frag2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/MToon0xSingleShader/MToon0xSingleShader.frag.wgsl"() {
    MToon0xSingleShader_frag_default2 = { code: `/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) shadowCoord : vec4<f32>,
  @location(10) instanceInfo : f32,
  @location(11) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturateEpsilonToOne(x: f32) -> f32 {
  let Epsilon = 0.0000001;
  return clamp(x, Epsilon, 1.0);
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

const EPS_COL: f32 = 0.00001;

fn edge_ratio(bary3: vec3f, wireframeWidthInner: f32, wireframeWidthRelativeScale: f32) -> f32 {
  let d: vec3f = fwidth(bary3);
  let x: vec3f = bary3 + vec3f(1.0 - wireframeWidthInner) * d;
  let a3: vec3f = smoothstep(vec3f(0.0), d, x);
  let factor = min(min(a3.x, a3.y), a3.z);

  return clamp((1.0 - factor), 0.0, 1.0);
}

struct Light {
  lightType: i32, // 0 = directional, 1 = point, 2 = spot
  position: vec3<f32>,
  intensity: vec3<f32>,
  attenuatedIntensity: vec3<f32>,
  directionOfLightObject: vec3<f32>,
  direction: vec3<f32>, // direction of light vector, equal to normalize(light.pointToLight)
  pointToLight: vec3<f32>, // not normalized
  spotAngleScale: f32,
  spotAngleOffset: f32,
  effectiveRange: f32,
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
fn getRangeAttenuation(light: Light) -> f32
{
  let distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
fn getSpotAttenuation(light: Light) -> f32
{

  let cd = dot(light.directionOfLightObject, light.direction);
  let angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);
  return angularAttenuation;
}

fn getLightAttenuated(light: Light) -> Light {
  var newLight: Light = light;
  newLight.attenuatedIntensity = light.intensity;
  // if (light.lightType == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light
  if (light.lightType == 1)
  {
    newLight.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot light
  if (light.lightType == 2)
  {
    newLight.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return newLight;
}

fn getLight(lightIdx: u32, v_position_inWorld: vec3<f32>) -> Light {
  let lightPosition: vec3<f32> = get_lightPosition(0u, lightIdx);
  let direction_and_w_of_LightObject: vec3<f32> = get_lightDirection(0u, lightIdx);
  let lightIntensity: vec3<f32> = get_lightIntensity(0u, lightIdx);
  let lightProperty: vec4<f32> = get_lightProperty(0u, lightIdx);
  var light: Light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  let lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.spotAngleScale = lightProperty.z;
  light.spotAngleOffset = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3f(0.0);
    light.lightType = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.lightType = 1;
  } else { // is Directional Light
    light.lightType = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.lightType = 2;
  }

  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  let newLight = getLightAttenuated(light);

  return newLight;
}

#ifdef RN_USE_TANGENT
  fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
    let tangent_inWorld = normalize(input.tangent_inWorld);
    let binormal_inWorld = normalize(input.binormal_inWorld);
    let tbnMat_tangent_to_world = mat3x3<f32>(tangent_inWorld, binormal_inWorld, normal_inWorld);

    return tbnMat_tangent_to_world;
  }
#else
    // This is based on http://www.thetenthplanet.de/archives/1180
    fn cotangent_frame(normal_inWorld: vec3f, position: vec3f, uv_: vec2f, isFront: bool) -> mat3x3<f32> {
      var uv: vec2f;
      if (isFront) {
        uv = uv_;
      } else {
        uv = -uv_;
      }

      // get edge vectors of the pixel triangle
      let dp1 = dpdx(position);
      let dp2 = dpdy(position);
      let duv1 = dpdx(uv);
      let duv2 = dpdy(uv);

      // solve the linear system
      let dp2perp = cross(dp2, normal_inWorld);
      let dp1perp = cross(normal_inWorld, dp1);
      let tangent = dp2perp * duv1.x + dp1perp * duv2.x;
      var bitangent = dp2perp * duv1.y + dp1perp * duv2.y;
      bitangent *= -1.0;

      // construct a scale-invariant frame
      let invMat = 1.0 / sqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));
      return mat3x3<f32>(tangent * invMat, bitangent * invMat, normal_inWorld);
    }

    fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
      let tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord, isFront);

      return tbnMat_tangent_to_world;
    }
#endif

fn srgbToLinear(srgbColor: vec3f) -> vec3f {
  return pow(srgbColor, vec3f(2.2));
}

fn linearToSrgb(linearColor: vec3f) -> vec3f {
  return pow(linearColor, vec3f(1.0/2.2));
}

// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66
fn Schlick_to_F0_F90(f: vec3f, f90: vec3f, VdotH: f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0_F90_F32(f: f32, f90: f32, VdotH: f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0(f: vec3f, VdotH: f32) -> vec3f {
    return Schlick_to_F0_F90(f, vec3(1.0), VdotH);
}

fn Schlick_to_F0_F32(f: f32, VdotH: f32) -> f32 {
    return Schlick_to_F0_F90_F32(f, 1.0, VdotH);
}


// The Schlick Approximation to Fresnel
fn fresnel(f0 : vec3f, f90 : vec3f, VdotH : f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnelF32(f0 : f32, f90 : f32, VdotH : f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnel2(f0: vec3f, VdotH: f32) -> vec3f
{
  let f90 = vec3f(1.0); //clamp(50.0 * f0, 0.0, 1.0);
  return fresnel(f0, f90, VdotH);
}

fn fresnel2F32(f0: f32, VdotH: f32) -> f32
{
  let f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelF32(f0, f90, VdotH);
}

// Roughness Dependent Fresnel
// https://www.jcgt.org/published/0008/01/03/paper.pdf
fn fresnelSchlickRoughness(F0: vec3f, cosTheta: f32, roughness: f32) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);
  return k_S;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf
fn BRDF_lambertian(albedo: vec3f, F: vec3f, specularWeight: f32) -> vec3f
{
  return (vec3f(1.0) - specularWeight * F) * albedo * RECIPROCAL_PI;
}


// GGX NDF
fn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {
  let roughnessSqr = alphaRoughness * alphaRoughness;
  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
fn v_GGXCorrelated(NL: f32, NV: f32, alphaRoughness: f32) -> f32 {
  let a2 = alphaRoughness * alphaRoughness;
  let GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  let GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  return 0.5 / (GGXV + GGXL);
}

fn BRDF_specularGGX(NH: f32, NL: f32, NV: f32, F: vec3f, alphaRoughness: f32, specularWeight: f32) -> vec3f {
  let D = d_GGX(NH, alphaRoughness);
  let V = v_GGXCorrelated(NL, NV, alphaRoughness);
  return vec3f(D) * vec3f(V) * F * specularWeight;
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
fn envBRDFApprox( Roughness: f32, NoV: f32 ) -> vec2f {
  let c0 = vec4f(-1, -0.0275, -0.572, 0.022 );
  let c1 = vec4f(1, 0.0425, 1.04, -0.04 );
  let r = Roughness * c0 + c1;
  let a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  let AB = vec2f( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}


// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering
fn coated_material_s(base: vec3f, perceptualRoughness: f32, clearcoatRoughness: f32, clearcoat: f32, VdotNc: f32, LdotNc: f32, NdotHc: f32) -> vec3f {
  let clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);
  let clearcoatAlpha = clearcoatRoughness * clearcoatRoughness;
  let alphaRoughness = perceptualRoughness * perceptualRoughness;
  let D = d_GGX(NdotHc, clearcoatAlpha);
  let V = v_GGXCorrelated(LdotNc, VdotNc, clearcoatAlpha);
  let f_clearcoat = clearcoatFresnel * D * V;

  // base = (f_diffuse + f_specular) in https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering
  return base * vec3f(1.0 - clearcoat * clearcoatFresnel) + vec3f(f_clearcoat * clearcoat);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes
fn specular_btdf(alphaRoughness: f32, NdotL: f32, NdotV: f32, NdotHt: f32) -> f32 {
  let V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  let D = d_GGX(NdotHt, alphaRoughness);
  return V * D;
}


////////////////////////////////////////
// glTF KHR_materials_volume
////////////////////////////////////////

#ifdef RN_USE_VOLUME
// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
fn volumeAttenuation(attenuationColor: vec3f, attenuationDistance: f32, intensity: vec3f, transmissionDistance: f32) -> vec3f
{
  if (attenuationDistance == 0.0) { // means Infinite distance
    return intensity; // No attenuation
  } else {
    let attenuationCo: vec3f = -log(attenuationColor) / attenuationDistance;
    let attenuatedTransmittance: vec3f = exp(-attenuationCo * transmissionDistance);
    return intensity * attenuatedTransmittance;
  }
}
#endif


////////////////////////////////////////
// glTF KHR_materials_anisotropy
////////////////////////////////////////
#ifdef RN_USE_ANISOTROPY
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
fn D_GGX_anisotropic(NdotH: f32, TdotH: f32, BdotH: f32, at: f32, ab: f32) -> f32
{
    let a2 = at * ab;
    let f = vec3f(ab * TdotH, at * BdotH, a2 * NdotH);
    let w2 = a2 / dot(f, f);
    return a2 * w2 * w2 / M_PI;
}

fn V_GGX_anisotropic(NdotL: f32, NdotV: f32, BdotV: f32, TdotV: f32, TdotL: f32, BdotL: f32,
    at: f32, ab: f32) -> f32
{
    let GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));
    let GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));
    let v = 0.5 / (GGXV + GGXL);
    return clamp(v, 0.0, 1.0);
}

fn BRDF_specularAnisotropicGGX(F: vec3f, alphaRoughness: f32,
    VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32, BdotV: f32, TdotV: f32,
    TdotL: f32, BdotL: f32, TdotH: f32, BdotH: f32, anisotropy: f32) -> vec3f
{
    let at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
    let ab = alphaRoughness;

    let V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);
    let D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);

    return F * V * D;
}
#endif

////////////////////////////////////////
// glTF KHR_materials_sheen
////////////////////////////////////////

#ifdef RN_USE_SHEEN
fn d_Charlie(sheenPerceptualRoughness: f32, NoH: f32) -> f32 {
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;
  let invAlpha  = 1.0 / alphaG;
  let cos2h = NoH * NoH;
  let sin2h = 1.0 - cos2h;
  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * M_PI);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn sheenSimpleVisibility(NdotL: f32, NdotV: f32) -> f32 {
  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn charlieL(x: f32, alphaG: f32) -> f32 {
  let oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
  let a = mix(21.5473, 25.3245, oneMinusAlphaSq);
  let b = mix(3.82987, 3.32435, oneMinusAlphaSq);
  let c = mix(0.19823, 0.16801, oneMinusAlphaSq);
  let d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
  let e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
  return a / (1.0 + b * pow(x, c)) + d * x + e;
}

fn lambdaSheen(cosTheta: f32, alphaG: f32) -> f32
{
  return select(exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG)), exp(charlieL(cosTheta, alphaG)), abs(cosTheta) < 0.5);
}

fn sheenCharlieVisibility(NdotL: f32, NdotV: f32, sheenPerceptualRoughness: f32) -> f32 {
  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;
  let sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));
  return sheenVisibility;
}

fn sheen_brdf(sheenColor: vec3f, sheenPerceptualRoughness: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f {
  let sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);
  let sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);
  return sheenColor * sheenDistribution * sheenVisibility;
}
#endif // RN_USE_SHEEN

////////////////////////////////////////
// glTF KHR_materials_irirdescence
////////////////////////////////////////

#ifdef RN_USE_IRIDESCENCE
// XYZ to REC709(sRGB) conversion matrix
const XYZ_TO_REC709 = mat3x3<f32>(
     3.2404542, -0.9692660,  0.0556434,
    -1.5371385,  1.8760108, -0.2040259,
    -0.4985314,  0.0415560,  1.0572252
);

fn fresnelSchlickRoughnessWithIridescence(
  F0: vec3f, cosTheta: f32, roughness: f32,
  iridescenceFresnel: vec3f, iridescence: f32
  ) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);
  return k_S;
}

// Assume air interface for top
fn Fresnel0ToIor(F0: vec3f) -> vec3f {
    let sqrtF0 = sqrt(F0);
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// Conversion from IOR to F0
// ior is a value between 1.0 and 3.0. 1.0 is air interface
fn IorToFresnel0Vec3f(transmittedIor: vec3f, incidentIor: f32) -> vec3f {
    return sqVec3f((transmittedIor - vec3f(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
fn IorToFresnel0F32(transmittedIor: f32, incidentIor: f32) -> f32 {
    return sqF32((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration
 */
fn evalSensitivity(OPD: f32, shift: vec3f) -> vec3f {
    let phase = 2.0 * M_PI * OPD * 1.0e-9;
    let val = vec3f(5.4856e-13, 4.4201e-13, 5.2481e-13);
    let pos = vec3f(1.6810e+06, 1.7953e+06, 2.2084e+06);
    let var_ = vec3f(4.3278e+09, 9.3046e+09, 6.6121e+09);

    var xyz = val * sqrt(2.0 * M_PI * var_) * cos(pos * phase + shift) * exp(-(phase * phase) * var_);
    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));
    xyz /= 1.0685e-7;

    let rgb = XYZ_TO_REC709 * xyz;
    return rgb;
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel
 */
fn calcIridescence(outsideIor: f32, eta2: f32, cosTheta1: f32, thinFilmThickness: f32, baseF0: vec3f) -> vec3f {


  // iridescenceIor is the index of refraction of the thin-film layer
  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
  let iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));

  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)
  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.
  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.
  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):
  let sinTheta2Sq = sqF32(outsideIor / iridescenceIor) * (1.0 - sqF32(cosTheta1));
  let cosTheta2Sq = 1.0 - sinTheta2Sq;

  // Handle total internal reflection
  if (cosTheta2Sq < 0.0) {
      return vec3f(1.0);
  }

  let cosTheta2 = sqrt(cosTheta2Sq);

  /// Material Interfaces
  // The iridescence model defined by Belcour/Barla models two material interfaces
  // - one from the outside to the thin-film layer
  // and another one from the thin-film to the base material. These two interfaces are defined as follows:

  // First interface (from the outside to the thin-film layer)
  let R0 = IorToFresnel0F32(iridescenceIor, outsideIor);
  let R12 = fresnel2F32(R0, cosTheta1);
  let R21 = R12;
  let T121 = 1.0 - R12;

  // Second interface (from the thin-film to the base material)
  let baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0
  let R1 = IorToFresnel0Vec3f(baseIor, iridescenceIor);
  let R23 = fresnel2(R1, cosTheta2);

  // phi12 and phi23 define the base phases per interface and are approximated with 0.0
  // if the IOR of the hit material (iridescenceIor or baseIor) is higher
  // than the IOR of the previous material (outsideIor or iridescenceIor) and \u03C0 otherwise.
  // Also here, polarization is ignored.  float phi12 = 0.0;

  // First interface (from the outside to the thin-film layer)
  var phi12 = 0.0;
  if (iridescenceIor < outsideIor) { phi12 = M_PI; }
  let phi21 = M_PI - phi12;

  // Second interface (from the thin-film to the base material)
  var phi23 = vec3f(0.0);
  if (baseIor[0] < iridescenceIor) { phi23[0] = M_PI; }
  if (baseIor[1] < iridescenceIor) { phi23[1] = M_PI; }
  if (baseIor[2] < iridescenceIor) { phi23[2] = M_PI; }

  // OPD (optical path difference)
  let OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
  // Phase shift
  let phi = vec3f(phi21) + phi23;

  // Compound terms
  let R123 = clamp(R12 * R23, vec3f(1e-5), vec3f(0.9999));
  let r123 = sqrt(R123);
  let Rs = (T121 * T121) * R23 / (vec3f(1.0) - R123);

  // Reflectance term for m = 0 (DC term amplitude)
  let C0 = R12 + Rs;
  var I = C0;

  // Reflectance term for m > 0 (pairs of diracs)
  var Cm = Rs - T121;
  for (var m = 1; m <= 2; m++)
  {
      Cm *= r123;
      let Sm = 2.0 * evalSensitivity(f32(m) * OPD, f32(m) * phi);
      I += Cm * Sm;
  }

  let F_iridescence = max(I, vec3f(0.0));

  return F_iridescence;
}

//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB
fn BRDF_lambertianIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, iridescenceFactor: f32, diffuseColor: vec3f, specularWeight: f32, VdotH: f32) -> vec3f
{
    let iridescenceFresnelMax = vec3f(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));

    let schlickFresnel = Schlick_to_F0_F90(f0, f90, VdotH);

    let F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);

    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);
}

fn BRDF_specularGGXIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, alphaRoughness: f32, iridescenceFactor: f32, specularWeight: f32, VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f
{
    let F = mix(Schlick_to_F0_F90(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);
    let Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
    let D = d_GGX(NdotH, alphaRoughness);

    return specularWeight * F * Vis * D;
}

#endif // RN_USE_IRIDESCENCE


////////////////////////////////////////
// lighting with a punctual light
////////////////////////////////////////
fn lightingWithPunctualLight(
  light: Light,
  normal_inWorld: vec3f,
  viewDirection: vec3f,
  NdotV: f32,
  albedo: vec3f,
  perceptualRoughness: f32,
  F0: vec3f,
  F90: vec3f,
  transmission: f32,
  ior: f32,
  clearcoat: f32,
  clearcoatRoughness: f32,
  clearcoatNormal_inWorld: vec3f,
  VdotNc: f32,
  attenuationColor: vec3f,
  attenuationDistance: f32,
  anisotropy: f32,
  anisotropicT: vec3f,
  anisotropicB: vec3f,
  BdotV: f32,
  TdotV: f32,
  sheenColor: vec3f,
  sheenRoughness: f32,
  albedoSheenScalingNdotV: f32,
  iridescenceFactor: f32,
  iridescenceFresnel: vec3f,
  specularWeight: f32,
  ) -> vec3f
{
  let alphaRoughness = perceptualRoughness * perceptualRoughness;

  // Fresnel
  let halfVector = normalize(light.direction + viewDirection);
  let VdotH = dot(viewDirection, halfVector);
  let F = fresnel(F0, F90, VdotH);

  let NdotL = clamp(dot(normal_inWorld, light.direction), Epsilon, 1.0);

  // Diffuse
#ifdef RN_USE_IRIDESCENCE
  let diffuseBrdf = BRDF_lambertianIridescence(F0, F90, iridescenceFresnel, iridescenceFactor, albedo, specularWeight, VdotH);
#else
  let diffuseBrdf = BRDF_lambertian(albedo, F, specularWeight);
#endif
  let pureDiffuse = diffuseBrdf * vec3f(NdotL) * light.attenuatedIntensity;

#ifdef RN_USE_TRANSMISSION
  let refractionVector = refract(-viewDirection, normal_inWorld, 1.0 / ior);
  var transmittedLightFromUnderSurface: Light = light;
  transmittedLightFromUnderSurface.pointToLight -= refractionVector;
  let transmittedLightDirectionFromUnderSurface = normalize(transmittedLightFromUnderSurface.pointToLight);
  transmittedLightFromUnderSurface.direction = transmittedLightDirectionFromUnderSurface;

  let Ht = normalize(viewDirection + transmittedLightFromUnderSurface.direction);
  let NdotHt = saturateEpsilonToOne(dot(normal_inWorld, Ht));
  let NdotLt = saturateEpsilonToOne(dot(normal_inWorld, transmittedLightFromUnderSurface.direction));

  var transmittedContrib = (vec3f(1.0) - F) * specular_btdf(alphaRoughness, NdotLt, NdotV, NdotHt) * albedo * transmittedLightFromUnderSurface.attenuatedIntensity;

#ifdef RN_USE_VOLUME
  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittedLightFromUnderSurface.pointToLight));
#endif // RN_USE_VOLUME

  let diffuseContrib = mix(pureDiffuse, vec3f(transmittedContrib), transmission);
#else
  let diffuseContrib = pureDiffuse;
#endif // RN_USE_TRANSMISSION

  // Specular
  let NdotH = saturateEpsilonToOne(dot(normal_inWorld, halfVector));


#ifdef RN_USE_IRIDESCENCE
  let specularContrib = BRDF_specularGGXIridescence(F0, F90, iridescenceFresnel, alphaRoughness, iridescenceFactor, specularWeight, VdotH, NdotL, NdotV, NdotH) * vec3f(NdotL) * light.attenuatedIntensity;
#elif defined(RN_USE_ANISOTROPY)
  let TdotL = dot(anisotropicT, light.direction);
  let BdotL = dot(anisotropicB, light.direction);
  let TdotH = dot(anisotropicT, halfVector);
  let BdotH = dot(anisotropicB, halfVector);
  let specularContrib = BRDF_specularAnisotropicGGX(F, alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3f(NdotL) * light.attenuatedIntensity;
#else
  let specularContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, F, alphaRoughness, specularWeight) * vec3f(NdotL) * light.attenuatedIntensity;
#endif

  // Base Layer
  let baseLayer = diffuseContrib + specularContrib;

#ifdef RN_USE_SHEEN
  // Sheen
  let sheenContrib = sheen_brdf(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;
  let albedoSheenScaling = min(
    albedoSheenScalingNdotV,
    1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotL, sheenRoughness)).r);
  let color = sheenContrib + baseLayer * albedoSheenScaling;
#else
  let color = baseLayer;
  let albedoSheenScaling = 1.0;
#endif // RN_USE_SHEEN

#ifdef RN_USE_CLEARCOAT
  // Clear Coat Layer
  let NdotHc = saturateEpsilonToOne(dot(clearcoatNormal_inWorld, halfVector));
  let LdotNc = saturateEpsilonToOne(dot(light.direction, clearcoatNormal_inWorld));
  let coated = coated_material_s(color, perceptualRoughness,
    clearcoatRoughness, clearcoat, VdotNc, LdotNc, NdotHc);
  let finalColor = coated;
#else
  let finalColor = color;
#endif // RN_USE_CLEARCOAT

  return finalColor;
}

fn IsotropicNDFFiltering(normal: vec3f, roughness2: f32) -> f32 {
  let SIGMA2 = 0.15915494;
  let KAPPA = 0.18;
  let dndu  = dpdx(normal);
  let dndv = dpdy(normal);
  let kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));
  let clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);
  let filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);
  return filteredRoughness2;
}


@group(1) @binding(16) var diffuseEnvTexture: texture_cube<f32>; // initialValue=black
@group(2) @binding(16) var diffuseEnvSampler: sampler;
@group(1) @binding(17) var specularEnvTexture: texture_cube<f32>; // initialValue=black
@group(2) @binding(17) var specularEnvSampler: sampler;

// #param inverseEnvironment: bool; // initialValue=false
// #param iblParameter: vec4<f32>; // initialValue=(1,1,1,1), isInternalSetting=true
// #param hdriFormat: vec2<i32>; // initialValue=(0,0), isInternalSetting=true

fn get_irradiance(normal_forEnv: vec3f, hdriFormat: vec2<i32>) -> vec3f {
  let diffuseTexel: vec4f = textureSample(diffuseEnvTexture, diffuseEnvSampler, normal_forEnv);

  var irradiance: vec3f;
  if (hdriFormat.x == 0) {
    // LDR_SRGB
    irradiance = srgbToLinear(diffuseTexel.rgb);
  }
  else if (hdriFormat.x == 3) {
    // RGBE
    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  }
  else {
    irradiance = diffuseTexel.rgb;
  }

  return irradiance;
}

fn get_radiance(reflection: vec3f, lod: f32, hdriFormat: vec2<i32>) -> vec3f {
  let specularTexel = textureSampleLevel(specularEnvTexture, specularEnvSampler, reflection, lod);

  var radiance: vec3f;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

#ifdef RN_USE_SHEEN
fn sheenIBL(NdotV: f32, sheenPerceptualRoughness: f32, sheenColor: vec3f, iblParameter: vec4f, reflection: vec3f, hdriFormat: vec2i) -> vec3f
{
  let mipCount = iblParameter.x;
  let lod = (sheenPerceptualRoughness * (mipCount - 1.0));

  let sheenLutUV = vec2f(NdotV, sheenPerceptualRoughness);
  let brdf = textureSample(sheenLutTexture, sheenLutSampler, sheenLutUV).b;
  var sheenLight = get_radiance(reflection, lod, hdriFormat);
  let IBLSpecularContribution = iblParameter.z;
  sheenLight *= IBLSpecularContribution;

  return sheenLight * sheenColor * brdf;
}
#endif

fn getNormalForEnv(rotEnvMatrix: mat3x3<f32>, normal_inWorld: vec3f, materialSID: u32) -> vec3f {
  var normal_forEnv = rotEnvMatrix * normal_inWorld;
  if (get_inverseEnvironment(materialSID, 0)) {
    normal_forEnv.x *= -1.0;
  }
  return normal_forEnv;
}

fn getReflection(rotEnvMatrix: mat3x3<f32>, viewDirection: vec3f, normal_inWorld: vec3f,
  materialSID: u32, perceptualRoughness: f32,
  anisotropy: f32, anisotropyDirection: vec3f
  ) -> vec3f {
#ifdef RN_USE_ANISOTROPY
  let tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);
  let anisotropicTangent  = cross(anisotropyDirection, viewDirection);
  let anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);
  let bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);
  let bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;
  let bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));
  var reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);
#else
  var reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);
#endif
  if (get_inverseEnvironment(materialSID, 0)) {
    reflection.x *= -1.0;
  }
  return reflection;
}

fn scaleForLod(perceptualRoughness: f32, ior: f32) -> f32
{
  // Scale roughness to the range [0, 1],
  // ior=1.0 will be scale 0,
  // ior=1.5 will be scale 1.0,
  // ior=2 will be scale 1.0 (clamped)
  //

  let scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);
  return perceptualRoughness * scale;
}

#ifdef RN_USE_TRANSMISSION
fn get_sample_from_backbuffer(materialSID: u32, sampleCoord: vec2f, perceptualRoughness: f32, ior: f32) -> vec3f {
  let vrState: vec2<i32> = get_vrState(0, 0);
  let backBufferTextureSize = vec2f(textureDimensions(backBufferTexture, 0));
  var backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);
  var newSampleCoord = sampleCoord;
  newSampleCoord.y = 1.0 - newSampleCoord.y;
  if (vrState.x == 1) { // For VR
    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
    newSampleCoord.x = sampleCoord.x * 0.5;
    if (vrState.y == 1) { // For right eye
      newSampleCoord.x += 0.5;
    }
  }
  let framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);

  let transmittedLight = textureSampleLevel(backBufferTexture, backBufferSampler, newSampleCoord, framebufferLod).rgb;

  return transmittedLight;
}

// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer
fn getVolumeTransmissionRay(n: vec3f, v: vec3f, thickness: f32, ior: f32, instanceInfo: u32) -> vec3f
{
  let refractionVector = refract(-v, normalize(n), 1.0 / ior);
  let worldMatrix = get_worldMatrix(instanceInfo);

  var modelScale: vec3f;
  modelScale.x = length(vec3f(worldMatrix[0].xyz));
  modelScale.y = length(vec3f(worldMatrix[1].xyz));
  modelScale.z = length(vec3f(worldMatrix[2].xyz));

  return normalize(refractionVector) * thickness * modelScale;
}
#endif // RN_USE_TRANSMISSION

struct IblResult
{
  specular: vec3f,
  diffuse: vec3f,
  FssEss: vec3f,
};


#ifdef RN_USE_IRIDESCENCE
fn getIBLRadianceGGXWithIridescence(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,
  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2i, rotEnvMatrix: mat3x3<f32>,
  normal_forEnv: vec3f, reflection: vec3f, iridescenceFresnel: vec3f, iridescence: f32, specularWeight: f32) -> IblResult
{
  // get radiance
  let mipCount = iblParameter.x;
  let lod = (perceptualRoughness * (mipCount - 1.0));
  let radiance = get_radiance(reflection, lod, hdriFormat);

  // Roughness dependent fresnel
  let kS = fresnelSchlickRoughnessWithIridescence(F0, NdotV, perceptualRoughness, iridescenceFresnel, iridescence);
  let f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss = kS * f_ab.x + f_ab.y;
  var result: IblResult;
  result.FssEss = FssEss;

  // Specular IBL
  var specular = FssEss * radiance * specularWeight;

  // scale with user parameters
  let IBLSpecularContribution = iblParameter.z;
  specular *= IBLSpecularContribution;

  result.specular = specular;

  return result;
}

fn getIBLRadianceLambertianWithIridescence(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,
  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2i, rotEnvMatrix: mat3x3<f32>,
  normal_forEnv: vec3f, reflection: vec3f, iridescenceF0: vec3f, iridescence: f32, specularWeight: f32) -> IblResult
{
  // get irradiance
  let irradiance = get_irradiance(normal_forEnv, hdriFormat);

  // Use the maximum component of the iridescence Fresnel color
  // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF
  let iridescenceF0Max = vec3f(max(max(iridescenceF0.r, iridescenceF0.g), iridescenceF0.b));

  // Blend between base F0 and iridescence F0
  let mixedF0 = mix(F0, iridescenceF0Max, iridescence);

  // Roughness dependent fresnel
  let kS = fresnelSchlickRoughness(mixedF0, NdotV, perceptualRoughness);
  let f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss = specularWeight * kS * f_ab.x + f_ab.y;
  var result: IblResult;
  result.FssEss = FssEss;

  // Multiple scattering, Fdez-Aguera's approach
  let Ems = (1.0 - (f_ab.x + f_ab.y));
  let F_avg = specularWeight * (mixedF0 + (1.0 - mixedF0) / 21.0);
  let FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);
  let k_D = albedo * (1.0 - FssEss - FmsEms);

  // Diffuse IBL
  var diffuse = (FmsEms + k_D) * irradiance;

  // scale with user parameters
  let IBLDiffuseContribution = iblParameter.y;
  diffuse *= IBLDiffuseContribution;

  result.diffuse = diffuse;

  return result;
}
#endif // RN_USE_IRIDESCENCE

fn getIBLRadianceLambertian(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,
  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, rotEnvMatrix: mat3x3<f32>,
  normal_forEnv: vec3f, reflection: vec3f, specularWeight: f32) -> IblResult
{
  // get irradiance
  let irradiance: vec3f = get_irradiance(normal_forEnv, hdriFormat);

  // Roughness dependent fresnel
  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss: vec3f = specularWeight * kS * f_ab.x + f_ab.y;
  var result: IblResult;
  result.FssEss = FssEss;

  // Multiple scattering, Fdez-Aguera's approach
  let Ems = (1.0 - (f_ab.x + f_ab.y));
  let F_avg: vec3f = specularWeight * (F0 + (1.0 - F0) / 21.0);
  let FmsEms: vec3f = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);
  let k_D: vec3f = albedo * (1.0 - FssEss - FmsEms);

  // Diffuse IBL
  var diffuse: vec3f = (FmsEms + k_D) * irradiance;

  // scale with user parameters
  let IBLDiffuseContribution = iblParameter.y;
  diffuse *= IBLDiffuseContribution;

  result.diffuse = diffuse;

  return result;
}

fn getIBLRadianceGGX(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,
  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, rotEnvMatrix: mat3x3<f32>,
  normal_forEnv: vec3f, reflection: vec3f, specularWeight: f32) -> IblResult
{
  // get radiance
  let mipCount = iblParameter.x;
  let lod = (perceptualRoughness * (mipCount - 1.0));
  let radiance: vec3f = get_radiance(reflection, lod, hdriFormat);

  // Roughness dependent fresnel
  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss: vec3f = kS * f_ab.x + f_ab.y;
  var result: IblResult;
  result.FssEss = FssEss;

  // Specular IBL
  var specular: vec3f = FssEss * radiance * specularWeight;

  // scale with user parameters
  let IBLSpecularContribution = iblParameter.z;
  specular *= IBLSpecularContribution;

  result.specular = specular;

  return result;
}

fn IBLContribution(materialSID: u32, cameraSID: u32, normal_inWorld: vec3f, NdotV: f32, viewDirection: vec3f,
  albedo: vec3f, F0: vec3f, perceptualRoughness: f32,
  clearcoatRoughness: f32, clearcoatNormal_inWorld: vec3f, clearcoat: f32, VdotNc: f32, geomNormal_inWorld: vec3f,
  transmission: f32, v_position_inWorld: vec3f, instanceInfo: u32, thickness: f32, ior: f32,
  sheenColor: vec3f, sheenRoughness: f32, albedoSheenScalingNdotV: f32,
  iridescenceFresnel: vec3f, iridescenceF0: vec3f, iridescence: f32,
  anisotropy: f32, anisotropyDirection: vec3f, specularWeight: f32
  ) -> vec3f
{
  let iblParameter: vec4f = get_iblParameter(materialSID, 0);
  let rot = iblParameter.w;
  let rotEnvMatrix = mat3x3<f32>(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  let hdriFormat: vec2<i32> = get_hdriFormat(materialSID, 0);

  let normal_forEnv: vec3f = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  let reflection: vec3f = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);

  // IBL
#ifdef RN_USE_IRIDESCENCE
  let baseRadianceResult: IblResult = getIBLRadianceGGXWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,
    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceFresnel, iridescence, specularWeight);
  let baseLambertianResult: IblResult = getIBLRadianceLambertianWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,
    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceF0, iridescence, specularWeight);
#else
  let baseRadianceResult: IblResult = getIBLRadianceGGX(materialSID, NdotV, viewDirection, albedo, F0,
    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);
  let baseLambertianResult: IblResult = getIBLRadianceLambertian(materialSID, NdotV, viewDirection, albedo, F0,
    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);
#endif

#ifdef RN_USE_TRANSMISSION
  let refractedRay = getVolumeTransmissionRay(geomNormal_inWorld, viewDirection, thickness, ior, instanceInfo);
  let refractedRayFromVPosition = v_position_inWorld + refractedRay;
  let ndcPoint = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4f(refractedRayFromVPosition, 1.0);
  var refractionCoords = ndcPoint.xy / ndcPoint.w;
  refractionCoords += 1.0;
  refractionCoords /= 2.0;
  var transmittedLight = get_sample_from_backbuffer(materialSID, refractionCoords, perceptualRoughness, ior);

#ifdef RN_USE_VOLUME
  let attenuationColor = get_attenuationColor(materialSID, 0);
  let attenuationDistance = get_attenuationDistance(materialSID, 0);
  transmittedLight = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, length(refractedRay));
#endif

  let transmissionComp = (vec3f(1.0) - baseRadianceResult.FssEss) * transmittedLight * albedo;
  let diffuse = mix(baseLambertianResult.diffuse, transmissionComp, transmission);
  let base = diffuse + baseRadianceResult.specular;
#else
  let base: vec3f = baseLambertianResult.diffuse + baseRadianceResult.specular;
#endif

#ifdef RN_USE_SHEEN
  let sheen = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);
  let color = sheen + base * albedoSheenScalingNdotV;
#else
  let color = base;
#endif

#ifdef RN_USE_CLEARCOAT
  let VdotNg = dot(geomNormal_inWorld, viewDirection);
  let clearcoatNormal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  let coatResult: IblResult = getIBLRadianceGGX(materialSID, VdotNc, viewDirection, vec3f(0.0), F0,
    clearcoatRoughness, iblParameter, hdriFormat, rotEnvMatrix, clearcoatNormal_forEnv, reflection, specularWeight);
  let coatLayer = coatResult.specular;

  let clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);
  let coated = color * vec3f(1.0 - clearcoat * clearcoatFresnel) + vec3f(coatLayer * clearcoat);
  return coated;
#else
  return color;
#endif
}



const PI_2: f32 = 6.28318530718;

fn uvAnimation(origUv: vec2f, time: f32, uvAnimationMask: f32, uvAnimationScrollXSpeedFactor: f32, uvAnimationScrollYSpeedFactor: f32, uvAnimationRotationSpeedFactor: f32) -> vec2f {
  let uvAnim = uvAnimationMask * time;
  var uv = origUv;
  uv += vec2f(uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor) * uvAnim;
  let rotateRad = uvAnimationRotationSpeedFactor * PI_2 * uvAnim;
  let rotatePivot = vec2f(0.5);
  uv = mat2x2f(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (uv - rotatePivot) + rotatePivot;
  return uv;
}

@fragment
fn main (
  input: VertexOutput,
  @builtin(front_facing) isFront: bool
) -> @location(0) vec4<f32> {
  var rt0 = vec4f(0.0, 0.0, 0.0, 1.0);

  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_NONE
      discard;
    #endif
  #endif

let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  // uv animation
  let uvAnimationMaskTexture = textureSample(uvAnimationMaskTexture, uvAnimationMaskSampler, input.texcoord_0).r;
  let uvAnimationScrollXSpeedFactor = get_uvAnimationScrollXSpeedFactor(materialSID, 0);
  let uvAnimationScrollYSpeedFactor = get_uvAnimationScrollYSpeedFactor(materialSID, 0);
  let uvAnimationRotationSpeedFactor = get_uvAnimationRotationSpeedFactor(materialSID, 0);
  let time = get_time(0, 0);
  let mainUv = uvAnimation(input.texcoord_0, time, uvAnimationMaskTexture, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);

  // main color
  let litTextureColor: vec4f = textureSample(litColorTexture, litColorSampler, mainUv);
  let litColorFactor: vec4f = get_litColor(materialSID, 0);

  // alpha
  var alpha = 1.0;

  #ifdef RN_ALPHATEST_ON
    alpha = litTextureColor.a * litColorFactor.a;
    let cutoff: f32 = get_cutoff(materialSID, 0);
    if (alpha < cutoff) { discard; }
  #elif defined(RN_ALPHABLEND_ON)
    alpha = litTextureColor.a * litColorFactor.a;
  #endif

  if (alpha < 0.01) {
    discard;
  } else {
    rt0.w = alpha;
  }


  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_COLOR_FIXED
      let outlineColor: vec3f = get_outlineColor(materialSID, 0);
      rt0 = vec4f(outlineColor, rt0.w);

      rt0 = vec4(srgbToLinear(rt0.xyz), rt0.w);
      return rt0;
    #endif
  #endif

  // view vector
  let viewPosition: vec3f = get_viewPosition(cameraSID, 0);
  let viewVector: vec3f = viewPosition - input.position_inWorld.xyz;
  let viewDirection: vec3f = normalize(viewVector);

  // Normal
  var normal_inWorld: vec3f = normalize(input.normal_inWorld);
  #ifdef RN_MTOON_HAS_BUMPMAP
    let normal: vec3f = textureSample(normalTexture, normalSampler, mainUv).xyz * 2.0 - 1.0;
    let TBN: mat3x3<f32> = getTBN(normal_inWorld, input, viewDirection, mainUv, isFront);
    normal_inWorld = normalize(TBN * normal);
  #endif

  #ifdef RN_MTOON_IS_OUTLINE
    normal_inWorld *= -1.0;
  #endif


  // Lighting, Direct Light

  let shadowAttenuation = 1.0;
  // TODO: shadowmap computation

  let receiveShadowRate: f32 = get_receiveShadowRate(materialSID, 0);
  var lightAttenuation: f32 = shadowAttenuation * mix(1.0, shadowAttenuation, receiveShadowRate * textureSample(receiveShadowTexture, receiveShadowSampler, mainUv).r);

  let shadingGradeRate: f32 = get_shadingGradeRate(materialSID, 0);
  let shadingGrade: f32 = 1.0 - shadingGradeRate * (1.0 - textureSample(shadingGradeTexture, shadingGradeSampler, mainUv).r);
  let lightColorAttenuation: f32 = get_lightColorAttenuation(materialSID, 0);

  let shadeColorFactor: vec3f = get_shadeColor(materialSID, 0);
  var shadeColor: vec3f = shadeColorFactor * srgbToLinear(textureSample(shadeColorTexture, shadeColorSampler, mainUv).xyz);

  var litColor: vec3f = litColorFactor.xyz * srgbToLinear(litTextureColor.xyz);

  let shadeShift: f32 = get_shadeShift(materialSID, 0);
  let shadeToony: f32 = get_shadeToony(materialSID, 0);

  var lightings: array<vec3<f32>, /* shaderity: @{Config.maxLightNumberInShader} */>;
  #ifdef RN_MTOON_DEBUG_LITSHADERATE
    var lightIntensities[/* shaderity: @{Config.maxLightNumberInShader} */]: array<f32>;
  #endif
  let lightNumber = u32(get_lightNumber(0u, 0u));
  for (var i = 0u; i < /* shaderity: @{Config.maxLightNumberInShader} */; i++) {
    if (i >= lightNumber) {
      break;
    }

    // Light
    let light: Light = getLight(i, input.position_inWorld.xyz);

    // lightAttenuation *= distanceAttenuation * spotEffect;
    let dotNL: f32 = dot(light.direction, normal_inWorld);
    var lightIntensity: f32 = dotNL * 0.5 + 0.5; // from [-1, +1] to [0, 1]
    lightIntensity = lightIntensity * lightAttenuation; // TODO: receive shadow
    lightIntensity = lightIntensity * shadingGrade; // darker
    lightIntensity = lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]

    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]
    let maxIntensityThreshold: f32 = mix(1.0, shadeShift, shadeToony);
    let minIntensityThreshold: f32 = shadeShift;
    lightIntensity = clamp((lightIntensity - minIntensityThreshold) / max(EPS_COL, (maxIntensityThreshold - minIntensityThreshold)), 0.0, 1.0);
    #ifdef RN_MTOON_DEBUG_LITSHADERATE
      lightIntensities[i] = lightIntensity;
    #endif

    // Albedo color
    var col: vec3f = mix(shadeColor, litColor, lightIntensity);

    // Direct Light
    var lighting: vec3f = light.attenuatedIntensity;
    lighting = mix(lighting, vec3(max(EPS_COL, max(lighting.x, max(lighting.y, lighting.z)))), lightColorAttenuation); // color atten


    if(i > 0){
      lighting *= 0.5; // darken if additional light.
      lighting *= min(0.0, dotNL) + 1.0; // darken dotNL < 0 area by using half lambert
      // lighting *= shadowAttenuation; // darken if receiving shadow
      #ifdef RN_ALPHABLEND_ON
        lighting *= step(0.0, dotNL); // darken if transparent. Because Unity's transparent material can't receive shadowAttenuation.
      #endif
    }

    col *= lighting * RECIPROCAL_PI;
    lightings[i] = lighting;

    rt0 += vec4f(col, 0.0);

    lightAttenuation = 1.0;
  }


  // Indirect Light
  let indirectLightIntensity = get_indirectLightIntensity(materialSID, 0);
  let worldUpVector = vec3f(0.0, 1.0, 0.0);
  let worldDownVector = vec3f(0.0, -1.0, 0.0);
  let iblParameter = get_iblParameter(materialSID, 0);
  let rot = iblParameter.w;
  let IBLDiffuseContribution = iblParameter.y;
  let rotEnvMatrix = mat3x3f(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  let normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  let hdriFormat = get_hdriFormat(materialSID, 0);
  let rawGiUp = get_irradiance(worldUpVector, hdriFormat) * IBLDiffuseContribution;
  let rawGiDown = get_irradiance(worldDownVector, hdriFormat) * IBLDiffuseContribution;
  let rawGiNormal = get_irradiance(normal_forEnv, hdriFormat) * IBLDiffuseContribution;
  let uniformedGi = (rawGiUp + rawGiDown) / 2.0;
  let passthroughGi = rawGiNormal;
  var indirectLighting = mix(uniformedGi, passthroughGi, indirectLightIntensity);
  indirectLighting = mix(indirectLighting, vec3f(max(EPS_COL, max(indirectLighting.x, max(indirectLighting.y, indirectLighting.z)))), lightColorAttenuation); // color atten
  rt0 += vec4f(indirectLighting * litColor * RECIPROCAL_PI, 0.0);
  // rt0 = vec4f(min(rt0.xyz, litColor), rt0.w); // comment out if you want to PBR absolutely.


  #ifdef RN_MTOON_IS_OUTLINE
    #ifdef RN_MTOON_OUTLINE_COLOR_MIXED
      var outlineColor: vec3f = get_outlineColor(materialSID, 0);
      // outlineColor = srgbToLinear(outlineColor);
      let outlineLightingMix: f32 = get_outlineLightingMix(materialSID, 0);
      rt0 = vec4f(outlineColor * mix(vec3f(1.0), rt0.xyz, outlineLightingMix), rt0.w);
    #endif
  #else
    let rimFresnelPower: f32 = get_rimFresnelPower(materialSID, 0);
    let rimLift: f32 = get_rimLift(materialSID, 0);
    let rimColorFactor: vec3f = get_rimColor(materialSID, 0);
    let rimTextureColor: vec3f = textureSample(rimTexture, rimSampler, mainUv).xyz;
    let rimColor: vec3f = rimColorFactor * srgbToLinear(rimTextureColor);
    let rim: vec3f = pow(clamp(1.0 - dot(normal_inWorld, viewDirection) + rimLift, 0.0, 1.0), rimFresnelPower) * rimColor;

    var staticRimLighting = 1.0;
    let rimLightingMix: f32 = get_rimLightingMix(materialSID, 0);
    for (var i = 0u; i < /* shaderity: @{Config.maxLightNumberInShader} */u; i++) {
      if (i >= lightNumber) { break; }

      if (i > 0) { staticRimLighting = 0.0; }

      let rimLighting: vec3f = mix(vec3f(staticRimLighting), lightings[i], vec3f(rimLightingMix));
      rt0 += vec4f(rim * rimLighting, 0.0);
    }

    // additive matcap
    let cameraUp: vec3f = get_cameraUp(0u, 0u); //solo datum
    let worldViewUp: vec3f = normalize(cameraUp - viewDirection * dot(viewDirection, cameraUp));
    let worldViewRight: vec3f = normalize(cross(viewDirection, worldViewUp));
    let matcapUv: vec2f = vec2f(dot(worldViewRight, normal_inWorld), dot(worldViewUp, normal_inWorld)) * 0.5 + 0.5;
    let matCapColor: vec3f = srgbToLinear(textureSample(matCapTexture, matCapSampler, matcapUv).xyz);
    rt0 += vec4f(matCapColor, 0.0);


    // Emission
    let emissionColor: vec3f = get_emissionColor(materialSID, 0);
    let emission: vec3f = srgbToLinear(textureSample(emissionTexture, emissionSampler, mainUv).xyz) * emissionColor;
    rt0 += vec4f(emission, 0.0);
  #endif


  // debug
  #ifdef RN_MTOON_DEBUG_NORMAL
    rt0 = vec4f(normal_inWorld * 0.5 + 0.5, alpha);

    rt0 = vec4f(srgbToLinear(rt0.xyz), rt0.w);
    return rt0;
  #elif defined(RN_MTOON_DEBUG_LITSHADERATE)
    rt0 = vec4f(0.0);
    for (var i = 0u; i < /* shaderity: @{Config.maxLightNumberInShader} */u; i++) {
      if (i >= lightNumber) { break; }
      rt0 += vec4f(lightIntensities[i] * lightings[i], alpha);
    }

    rt0 = vec4f(srgbToLinear(rt0.xyz), rt0.w);
    return rt0;
  #endif


  // Wireframe
  let threshold = 0.001;
  let wireframe: vec3f = get_wireframe(materialSID, 0);
  let wireframeWidthInner = wireframe.z;
  let wireframeWidthRelativeScale = 1.0;
  if (wireframe.x > 0.5 && wireframe.y < 0.5) {
    rt0.a = 0.0;
  }
  var wireframeResult = rt0;
  let wireframeColor = vec4f(0.2, 0.75, 0.0, 1.0);
  let edgeRatio: f32 = edge_ratio(input.baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);
  let edgeRatioModified: f32 = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);
  // if r0.a is 0.0, it is wireframe not on shaded
  wireframeResult = vec4f(wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified), wireframeResult.a);
  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));

  if (wireframe.x > 0.5) {
    rt0 = wireframeResult;
    if (wireframe.y < 0.5 && rt0.a == 0.0) {
      discard;
    }
  }

  let makeOutputSrgb = get_makeOutputSrgb(materialSID, 0);
  rt0 = vec4f(select(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb), rt0.w);

  return rt0;
}
`, shaderStage: "fragment", isFragmentShader: true };
  }
});

// src/foundation/definitions/Blend.ts
function from30(index) {
  return _from({
    typeList: typeList30,
    index
  });
}
var _a34, BlendClass, EquationFuncAdd, Zero, One, SrcAlpha, OneMinusSrcAlpha, Min, Max, typeList30, Blend2;
var init_Blend = __esm({
  "src/foundation/definitions/Blend.ts"() {
    "use strict";
    init_EnumIO();
    BlendClass = (_a34 = class extends EnumClass {
      constructor({ index, str, webgpu }) {
        super({
          index,
          str
        });
        __publicField(this, "__webgpu");
        this.__webgpu = webgpu;
      }
      get webgpu() {
        if (this.__webgpu === void 0) {
          throw new Error(`does not support ${this.str}`);
        }
        return this.__webgpu;
      }
    }, __name(_a34, "BlendClass"), _a34);
    EquationFuncAdd = new BlendClass({
      index: 32774,
      str: "Equation_FUNC_ADD",
      webgpu: "add"
    });
    Zero = new BlendClass({
      index: 0,
      str: "ZERO",
      webgpu: "zero"
    });
    One = new BlendClass({
      index: 1,
      str: "ONE",
      webgpu: "one"
    });
    SrcAlpha = new BlendClass({
      index: 770,
      str: "SRC_ALPHA",
      webgpu: "src-alpha"
    });
    OneMinusSrcAlpha = new BlendClass({
      index: 771,
      str: "ONE_MINUS_SRC_ALPHA",
      webgpu: "one-minus-src-alpha"
    });
    Min = new BlendClass({
      index: 32775,
      str: "Equation_FUNC_MIN",
      webgpu: "min"
    });
    Max = new BlendClass({
      index: 32776,
      str: "Equation_FUNC_MAX",
      webgpu: "max"
    });
    typeList30 = [
      EquationFuncAdd,
      Zero,
      One,
      SrcAlpha,
      OneMinusSrcAlpha,
      Min,
      Max
    ];
    __name(from30, "from");
    Blend2 = Object.freeze({
      EquationFuncAdd,
      Zero,
      One,
      SrcAlpha,
      OneMinusSrcAlpha,
      Min,
      Max,
      from: from30
    });
  }
});

// src/foundation/materials/contents/MToon0xMaterialContent.ts
var _MToon0xMaterialContent, MToon0xMaterialContent;
var init_MToon0xMaterialContent = __esm({
  "src/foundation/materials/contents/MToon0xMaterialContent.ts"() {
    "use strict";
    init_AbstractMaterialContent();
    init_AlphaMode();
    init_CameraComponent();
    init_CGAPIResourceRepository();
    init_ComponentRepository();
    init_ComponentType();
    init_CompositionType();
    init_Config();
    init_Scalar();
    init_ShaderSemantics();
    init_ShaderType();
    init_Vector3();
    init_Vector4();
    init_VectorN();
    init_MToon0xSingleShader_vert();
    init_MToon0xSingleShader_frag();
    init_MToon0xSingleShader_vert2();
    init_MToon0xSingleShader_frag2();
    init_types();
    init_Sampler();
    init_Blend();
    init_DummyTextures();
    init_SystemState();
    init_definitions();
    init_WellKnownComponentTIDs();
    init_MutableVector4();
    init_MutableVector2();
    _MToon0xMaterialContent = class _MToon0xMaterialContent extends AbstractMaterialContent {
      constructor(isOutline, materialProperties, textures, samplers, isMorphing, isSkinning, isLighting, useTangentAttribute, debugMode, makeOutputSrgb, materialName) {
        var _a40, _b, _c;
        super(materialName, {
          isMorphing,
          isSkinning,
          isLighting
        });
        __publicField(this, "__OutlineWidthModeIsScreen", false);
        __publicField(this, "__floatProperties", {});
        __publicField(this, "__vectorProperties", {});
        __publicField(this, "__textureProperties", {});
        const shaderSemanticsInfoArray = this.doShaderReflection(MToon0xSingleShader_vert_default, MToon0xSingleShader_frag_default, MToon0xSingleShader_vert_default2, MToon0xSingleShader_frag_default2);
        if (!_MToon0xMaterialContent.__diffuseIblCubeMapSampler.created) {
          _MToon0xMaterialContent.__diffuseIblCubeMapSampler.create();
        }
        if (!_MToon0xMaterialContent.__specularIblCubeMapSampler.created) {
          _MToon0xMaterialContent.__specularIblCubeMapSampler.create();
        }
        if (materialProperties != null) {
          this.__floatProperties = materialProperties.floatProperties;
          this.__vectorProperties = materialProperties.vectorProperties;
          this.__textureProperties = JSON.parse(JSON.stringify(materialProperties.textureProperties));
        } else {
          this.__floatProperties._BlendMode = 0;
          this.__floatProperties._BumpScale = 1;
          this.__floatProperties._CullMode = 2;
          this.__floatProperties._Cutoff = 0.5;
          this.__floatProperties._DebugMode = 0;
          this.__floatProperties._DstBlend = 0;
          this.__floatProperties._IndirectLightIntensity = 0.1;
          this.__floatProperties._LightColorAttenuation = 0;
          this.__floatProperties._OutlineColorMode = 0;
          this.__floatProperties._OutlineCullMode = 1;
          this.__floatProperties._OutlineLightingMix = 1;
          this.__floatProperties._OutlineScaledMaxDistance = 1;
          this.__floatProperties._OutlineWidth = 0.5;
          this.__floatProperties._OutlineWidthMode = 0;
          this.__floatProperties._ReceiveShadowRate = 1;
          this.__floatProperties._RimFresnelPower = 1;
          this.__floatProperties._RimLift = 0;
          this.__floatProperties._RimLightingMix = 0;
          this.__floatProperties._ShadeShift = 0;
          this.__floatProperties._ShadeToony = 0.9;
          this.__floatProperties._ShadingGradeRate = 1;
          this.__floatProperties._SrcBlend = 1;
          this.__floatProperties._ZWrite = 1;
          this.__floatProperties._UvAnimScrollX = 0;
          this.__floatProperties._UvAnimScrollY = 0;
          this.__floatProperties._UvAnimRotation = 0;
          this.__vectorProperties._Color = [
            1,
            1,
            1,
            1
          ];
          this.__vectorProperties._EmissionColor = [
            0,
            0,
            0
          ];
          this.__vectorProperties._OutlineColor = [
            0,
            0,
            0,
            1
          ];
          this.__vectorProperties._ShadeColor = [
            0.97,
            0.81,
            0.86,
            1
          ];
          this.__vectorProperties._RimColor = [
            0,
            0,
            0
          ];
        }
        if (debugMode) {
          this.__floatProperties._DebugMode = debugMode;
        }
        shaderSemanticsInfoArray.push({
          semantic: "cutoff",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.PixelShader,
          initialValue: Scalar2.fromCopyNumber(this.__floatProperties._Cutoff),
          min: 0,
          max: 1
        }, {
          semantic: "litColor",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Vec4,
          stage: ShaderType.PixelShader,
          initialValue: Vector4.fromCopyArray(this.__vectorProperties._Color),
          min: 0,
          max: 1
        }, {
          semantic: "shadeColor",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Vec3,
          stage: ShaderType.PixelShader,
          initialValue: Vector3.fromCopyArray(this.__vectorProperties._ShadeColor),
          min: 0,
          max: 1
        }, {
          semantic: "bumpScale",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.PixelShader,
          initialValue: Scalar2.fromCopyNumber(this.__floatProperties._BumpScale),
          min: 0,
          max: 1
        }, {
          semantic: "receiveShadowRate",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.PixelShader,
          initialValue: Scalar2.fromCopyNumber(this.__floatProperties._ReceiveShadowRate),
          min: 0,
          max: 1
        }, {
          semantic: "shadingGradeRate",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.PixelShader,
          initialValue: Scalar2.fromCopyNumber(this.__floatProperties._ShadingGradeRate),
          min: 0,
          max: 1
        }, {
          semantic: "shadeShift",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.PixelShader,
          initialValue: Scalar2.fromCopyNumber(this.__floatProperties._ShadeShift),
          min: 0,
          max: 1
        }, {
          semantic: "shadeToony",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.PixelShader,
          initialValue: Scalar2.fromCopyNumber(this.__floatProperties._ShadeToony),
          min: 0,
          max: 1
        }, {
          semantic: "lightColorAttenuation",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.PixelShader,
          initialValue: Scalar2.fromCopyNumber(this.__floatProperties._LightColorAttenuation),
          min: 0,
          max: 1
        }, {
          semantic: "indirectLightIntensity",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.PixelShader,
          initialValue: Scalar2.fromCopyNumber(this.__floatProperties._IndirectLightIntensity),
          min: 0,
          max: 1
        }, {
          semantic: "rimColor",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Vec3,
          stage: ShaderType.PixelShader,
          initialValue: Vector3.fromCopyArray(this.__vectorProperties._RimColor),
          min: 0,
          max: 1
        }, {
          semantic: "rimLightingMix",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.PixelShader,
          initialValue: Scalar2.fromCopyNumber(this.__floatProperties._RimLightingMix),
          min: 0,
          max: 1
        }, {
          semantic: "rimFresnelPower",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.PixelShader,
          initialValue: Scalar2.fromCopyNumber(this.__floatProperties._RimFresnelPower),
          min: 0,
          max: 1
        }, {
          semantic: "rimLift",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.PixelShader,
          initialValue: Scalar2.fromCopyNumber(this.__floatProperties._RimLift),
          min: 0,
          max: 1
        }, {
          semantic: "cameraUp",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Vec3,
          stage: ShaderType.PixelShader,
          soloDatum: true,
          initialValue: Vector3.fromCopyArray([
            0,
            1,
            0
          ]),
          min: 0,
          max: 1
        }, {
          semantic: "emissionColor",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Vec3,
          stage: ShaderType.PixelShader,
          initialValue: Vector3.fromCopyArray(this.__vectorProperties._EmissionColor),
          min: 0,
          max: 1
        }, {
          semantic: "uvAnimationScrollXSpeedFactor",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.PixelShader,
          isInternalSetting: false,
          initialValue: Scalar2.fromCopyNumber((_a40 = this.__floatProperties._UvAnimScrollX) != null ? _a40 : 0),
          min: 0,
          max: 1
        }, {
          semantic: "uvAnimationScrollYSpeedFactor",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.PixelShader,
          isInternalSetting: false,
          initialValue: Scalar2.fromCopyNumber((_b = this.__floatProperties._UvAnimScrollY) != null ? _b : 0),
          min: 0,
          max: 1
        }, {
          semantic: "uvAnimationRotationSpeedFactor",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.PixelShader,
          isInternalSetting: false,
          initialValue: Scalar2.fromCopyNumber((_c = this.__floatProperties._UvAnimRotation) != null ? _c : 0),
          min: 0,
          max: 1
        }, {
          semantic: "wireframe",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Vec3,
          stage: ShaderType.PixelShader,
          initialValue: Vector3.fromCopyArray([
            0,
            0,
            1
          ]),
          min: 0,
          max: 10
        }, {
          semantic: "makeOutputSrgb",
          compositionType: CompositionType.Scalar,
          componentType: ComponentType.Bool,
          stage: ShaderType.PixelShader,
          min: 0,
          max: 1,
          initialValue: Scalar2.fromCopyNumber(makeOutputSrgb ? 1 : 0)
        });
        switch (this.__floatProperties._DebugMode) {
          case 1:
            this.__definitions += "#define RN_MTOON_DEBUG_NORMAL\n";
            break;
          case 2:
            this.__definitions += "#define RN_MTOON_DEBUG_LITSHADERATE\n";
            break;
        }
        if (isOutline) {
          this.__definitions += "#define RN_MTOON_IS_OUTLINE\n";
          switch (this.__floatProperties._OutlineWidthMode) {
            case 0:
              this.__definitions += "#define RN_MTOON_OUTLINE_NONE\n";
              break;
            case 1:
              this.__definitions += "#define RN_MTOON_OUTLINE_WIDTH_WORLD\n";
              break;
            case 2:
              this.__definitions += "#define RN_MTOON_OUTLINE_WIDTH_SCREEN\n";
              this.__OutlineWidthModeIsScreen = true;
              break;
          }
          switch (this.__floatProperties._OutlineColorMode) {
            case 0:
              this.__definitions += "#define RN_MTOON_OUTLINE_COLOR_FIXED\n";
              break;
            case 1:
              this.__definitions += "#define RN_MTOON_OUTLINE_COLOR_MIXED\n";
              break;
          }
          shaderSemanticsInfoArray.push({
            semantic: "outlineWidth",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.VertexShader,
            initialValue: Scalar2.fromCopyNumber(this.__floatProperties._OutlineWidth),
            min: 0,
            max: 1
          }, {
            semantic: "outlineScaledMaxDistance",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.VertexShader,
            initialValue: Scalar2.fromCopyNumber(this.__floatProperties._OutlineScaledMaxDistance),
            min: 0,
            max: 1
          }, {
            semantic: "outlineColor",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Vec3,
            stage: ShaderType.PixelShader,
            initialValue: Vector3.fromCopyArray(this.__vectorProperties._OutlineColor),
            min: 0,
            max: 1
          }, {
            semantic: "outlineLightingMix",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(this.__floatProperties._OutlineLightingMix),
            min: 0,
            max: 1
          }, {
            semantic: "aspect",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.VertexShader,
            isInternalSetting: true,
            soloDatum: true,
            initialValue: Scalar2.fromCopyNumber(1),
            min: 0,
            max: 1
          });
        }
        if (isLighting) {
          this.__definitions += "#define RN_IS_LIGHTING\n";
        }
        if (isSkinning) {
          this.__definitions += "#define RN_IS_SKINNING\n";
        }
        if (isMorphing) {
          this.__definitions += "#define RN_IS_MORPHING\n";
          shaderSemanticsInfoArray.push({
            semantic: "dataTextureMorphOffsetPosition",
            componentType: ComponentType.Int,
            compositionType: CompositionType.ScalarArray,
            arrayLength: Config.maxVertexMorphNumberInShader,
            stage: ShaderType.VertexShader,
            isInternalSetting: true,
            initialValue: new VectorN(new Int32Array(Config.maxVertexMorphNumberInShader)),
            min: -Number.MAX_VALUE,
            max: Number.MAX_VALUE,
            needUniformInDataTextureMode: true
          }, {
            semantic: "morphWeights",
            componentType: ComponentType.Float,
            compositionType: CompositionType.ScalarArray,
            arrayLength: Config.maxVertexMorphNumberInShader,
            stage: ShaderType.VertexShader,
            isInternalSetting: true,
            initialValue: new VectorN(new Float32Array(Config.maxVertexMorphNumberInShader)),
            min: -Number.MAX_VALUE,
            max: Number.MAX_VALUE,
            needUniformInDataTextureMode: true
          });
        }
        if (useTangentAttribute) {
          this.__definitions += "#define RN_USE_TANGENT_ATTRIBUTE\n";
        }
        if (this.__textureProperties._BumpMap >= 0) {
          this.__definitions += "#define RN_MTOON_HAS_BUMPMAP\n";
        }
        if (this.__textureProperties._OutlineWidthTexture >= 0) {
          this.__definitions += "#define RN_MTOON_HAS_OUTLINE_WIDTH_TEXTURE\n";
        }
        textures = [
          dummyWhiteTexture,
          dummyBlackTexture
        ];
        this.__textureProperties._BumpMap = 0;
        this.__textureProperties._EmissionMap = 1;
        this.__textureProperties._MainTex = 0;
        this.__textureProperties._OutlineWidthTexture = 0;
        this.__textureProperties._UvAnimMaskTexture = 0;
        this.__textureProperties._ReceiveShadowTexture = 0;
        this.__textureProperties._RimTexture = 1;
        this.__textureProperties._ShadeTexture = 0;
        this.__textureProperties._ShadingGradeTexture = 0;
        this.__textureProperties._SphereAdd = 1;
        this.__setDummyTextures(textures, samplers, shaderSemanticsInfoArray, isOutline);
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
      }
      __setDummyTextures(textures, samplers, shaderSemanticsInfoArray, isOutline) {
        shaderSemanticsInfoArray.push({
          semantic: "litColorTexture",
          componentType: ComponentType.Int,
          compositionType: CompositionType.Texture2D,
          stage: ShaderType.PixelShader,
          initialValue: [
            0,
            textures[this.__textureProperties._MainTex],
            samplers[this.__textureProperties._MainTex]
          ],
          min: 0,
          max: Number.MAX_SAFE_INTEGER
        }, {
          semantic: "shadeColorTexture",
          componentType: ComponentType.Int,
          compositionType: CompositionType.Texture2D,
          stage: ShaderType.PixelShader,
          initialValue: [
            1,
            textures[this.__textureProperties._ShadeTexture],
            samplers[this.__textureProperties._ShadeTexture]
          ],
          min: 0,
          max: Number.MAX_SAFE_INTEGER
        }, {
          semantic: "receiveShadowTexture",
          componentType: ComponentType.Int,
          compositionType: CompositionType.Texture2D,
          stage: ShaderType.PixelShader,
          initialValue: [
            2,
            textures[this.__textureProperties._ReceiveShadowTexture],
            samplers[this.__textureProperties._ReceiveShadowTexture]
          ],
          min: 0,
          max: Number.MAX_SAFE_INTEGER
        }, {
          semantic: "shadingGradeTexture",
          componentType: ComponentType.Int,
          compositionType: CompositionType.Texture2D,
          stage: ShaderType.PixelShader,
          initialValue: [
            3,
            textures[this.__textureProperties._ShadingGradeTexture],
            samplers[this.__textureProperties._ShadingGradeTexture]
          ],
          min: 0,
          max: Number.MAX_SAFE_INTEGER
        }, {
          semantic: "rimTexture",
          componentType: ComponentType.Int,
          compositionType: CompositionType.Texture2D,
          stage: ShaderType.PixelShader,
          initialValue: [
            4,
            textures[this.__textureProperties._RimTexture],
            samplers[this.__textureProperties._RimTexture]
          ],
          min: 0,
          max: Number.MAX_SAFE_INTEGER
        }, {
          semantic: "matCapTexture",
          componentType: ComponentType.Int,
          compositionType: CompositionType.Texture2D,
          stage: ShaderType.PixelShader,
          initialValue: [
            8,
            textures[this.__textureProperties._SphereAdd],
            samplers[this.__textureProperties._SphereAdd]
          ],
          min: 0,
          max: Number.MAX_SAFE_INTEGER
        }, {
          semantic: "emissionTexture",
          componentType: ComponentType.Int,
          compositionType: CompositionType.Texture2D,
          stage: ShaderType.PixelShader,
          initialValue: [
            9,
            textures[this.__textureProperties._EmissionMap],
            samplers[this.__textureProperties._EmissionMap]
          ],
          min: 0,
          max: Number.MAX_SAFE_INTEGER
        });
        shaderSemanticsInfoArray.push({
          // number 7 of texture is the data Texture
          semantic: "normalTexture",
          componentType: ComponentType.Int,
          compositionType: CompositionType.Texture2D,
          stage: ShaderType.PixelShader,
          initialValue: [
            10,
            textures[this.__textureProperties._BumpMap],
            samplers[this.__textureProperties._BumpMap]
          ],
          min: 0,
          max: Number.MAX_SAFE_INTEGER
        }, {
          semantic: "uvAnimationMaskTexture",
          componentType: ComponentType.Int,
          compositionType: CompositionType.Texture2D,
          stage: ShaderType.PixelShader,
          initialValue: [
            11,
            textures[this.__textureProperties._UvAnimMaskTexture],
            samplers[this.__textureProperties._UvAnimMaskTexture]
          ],
          min: 0,
          max: Number.MAX_SAFE_INTEGER
        });
        if (isOutline) {
          shaderSemanticsInfoArray.push({
            semantic: "outlineWidthTexture",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Texture2D,
            stage: ShaderType.VertexShader,
            initialValue: [
              12,
              textures[this.__textureProperties._OutlineWidthTexture],
              samplers[this.__textureProperties._OutlineWidthTexture]
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          });
        }
      }
      setMaterialParameters(material, isOutline) {
        if (_MToon0xMaterialContent.usableBlendEquationModeAlpha == null) {
          _MToon0xMaterialContent.__initializeUsableBlendEquationModeAlpha();
        }
        if (this.__floatProperties._BlendMode !== 0) {
          switch (this.__floatProperties._BlendMode) {
            case 1:
              this.__definitions += "#define RN_ALPHATEST_ON\n";
              material.alphaMode = AlphaMode.Mask;
              break;
            case 2:
              this.__definitions += "#define RN_ALPHABLEND_ON\n";
              material.alphaMode = AlphaMode.Blend;
              break;
            case 3:
              this.__definitions += "#define RN_ALPHABLEND_ON\n";
              material.alphaMode = AlphaMode.Blend;
              break;
          }
          const blendEquationMode = 32774;
          const blendEquationModeAlpha = _MToon0xMaterialContent.usableBlendEquationModeAlpha;
          const blendFuncSrcFactor = _MToon0xMaterialContent.unityBlendEnumCorrespondence(this.__floatProperties._SrcBlend);
          const blendFuncDstFactor = _MToon0xMaterialContent.unityBlendEnumCorrespondence(this.__floatProperties._DstBlend);
          material.setBlendEquationMode(Blend2.from(blendEquationMode), blendEquationModeAlpha != null ? Blend2.from(blendEquationModeAlpha) : void 0);
          material.setBlendFuncFactor(Blend2.from(blendFuncSrcFactor), Blend2.from(blendFuncDstFactor));
        }
        if (isOutline) {
          switch (this.__floatProperties._OutlineCullMode) {
            case 0:
              material.cullFace = false;
              break;
            case 1:
              material.cullFace = true;
              material.cullFaceBack = false;
              break;
            case 2:
              material.cullFace = true;
              material.cullFaceBack = true;
              break;
          }
        } else {
          switch (this.__floatProperties._CullMode) {
            case 0:
              material.cullFace = false;
              break;
            case 1:
              material.cullFace = true;
              material.cullFaceBack = false;
              break;
            case 2:
              material.cullFace = true;
              material.cullFaceBack = true;
              break;
          }
        }
        material.zWriteWhenBlend = this.__floatProperties._ZWrite === 1;
      }
      static __initializeUsableBlendEquationModeAlpha() {
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          _MToon0xMaterialContent.usableBlendEquationModeAlpha = 32776;
        } else {
          const webGLResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
          const glw = webGLResourceRepository.currentWebGLContextWrapper;
          const gl = glw.getRawContextAsWebGL2();
          if (glw.isWebGL2) {
            _MToon0xMaterialContent.usableBlendEquationModeAlpha = gl.MAX;
          } else if (glw.webgl1ExtBM) {
            _MToon0xMaterialContent.usableBlendEquationModeAlpha = glw.webgl1ExtBM.MAX_EXT;
          } else {
            _MToon0xMaterialContent.usableBlendEquationModeAlpha = gl.FUNC_ADD;
          }
        }
      }
      _setInternalSettingParametersToGpuWebGpu({ material, args }) {
        let cameraComponent = ComponentRepository.getComponentFromComponentTID(WellKnownComponentTIDs.CameraComponentTID, args.cameraComponentSid);
        material.setParameter("cameraUp", cameraComponent.upInner);
        if (this.__OutlineWidthModeIsScreen) {
          material.setParameter("aspect", cameraComponent.aspect);
        }
        const { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType } = _MToon0xMaterialContent.__setupHdriParameters(args);
        const tmp_vector4 = AbstractMaterialContent.__tmp_vector4;
        tmp_vector4.x = mipmapLevelNumber;
        tmp_vector4.y = meshRenderComponent.diffuseCubeMapContribution;
        tmp_vector4.z = meshRenderComponent.specularCubeMapContribution;
        tmp_vector4.w = meshRenderComponent.rotationOfCubeMap;
        material.setParameter("iblParameter", tmp_vector4);
        const tmp_vector2 = AbstractMaterialContent.__tmp_vector2;
        tmp_vector2.x = diffuseHdriType;
        tmp_vector2.y = specularHdriType;
        material.setParameter("hdriFormat", tmp_vector2);
        const meshRendererComponent = args.entity.tryToGetMeshRenderer();
        if (meshRendererComponent != null && meshRendererComponent.diffuseCubeMap != null && meshRendererComponent.specularCubeMap != null) {
          const iblParameterVec4 = MutableVector4.zero();
          const hdriFormatVec2 = MutableVector2.zero();
          iblParameterVec4.x = meshRendererComponent.specularCubeMap.mipmapLevelNumber;
          iblParameterVec4.y = meshRendererComponent.diffuseCubeMapContribution;
          iblParameterVec4.z = meshRendererComponent.specularCubeMapContribution;
          iblParameterVec4.w = meshRendererComponent.rotationOfCubeMap;
          material.setParameter("iblParameter", iblParameterVec4);
          hdriFormatVec2.x = meshRendererComponent.diffuseCubeMap.hdriFormat.index;
          hdriFormatVec2.y = meshRendererComponent.specularCubeMap.hdriFormat.index;
          material.setParameter("hdriFormat", hdriFormatVec2);
        }
      }
      _setInternalSettingParametersToGpuWebGL({ material, shaderProgram, firstTime, args }) {
        let cameraComponent = args.renderPass.cameraComponent;
        if (cameraComponent == null) {
          cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
        }
        if (args.setUniform) {
          this.setWorldMatrix(shaderProgram, args.worldMatrix);
          this.setNormalMatrix(shaderProgram, args.normalMatrix);
          this.setViewInfo(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          this.setProjection(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          const skeletalComponent = args.entity.tryToGetSkeletal();
          this.setSkinning(shaderProgram, args.setUniform, skeletalComponent);
          this.setLightsInfo(shaderProgram, args.lightComponents, material, args.setUniform);
          shaderProgram._gl.uniform3fv(shaderProgram.cameraUp, cameraComponent.upInner._v);
          if (this.__OutlineWidthModeIsScreen) {
            shaderProgram._gl.uniform1f(shaderProgram.aspect, cameraComponent.aspect);
          }
        } else {
          material.setParameter("cameraUp", cameraComponent.upInner);
          if (this.__OutlineWidthModeIsScreen) {
            material.setParameter("aspect", cameraComponent.aspect);
          }
        }
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        if (args.diffuseCube && args.diffuseCube.isTextureReady) {
          webglResourceRepository.setUniform1iForTexture(shaderProgram, ShaderSemantics.DiffuseEnvTexture.str, [
            5,
            args.diffuseCube,
            _MToon0xMaterialContent.__diffuseIblCubeMapSampler
          ]);
        } else {
          webglResourceRepository.setUniform1iForTexture(shaderProgram, ShaderSemantics.DiffuseEnvTexture.str, [
            5,
            dummyBlackCubeTexture
          ]);
        }
        if (args.specularCube && args.specularCube.isTextureReady) {
          webglResourceRepository.setUniform1iForTexture(shaderProgram, ShaderSemantics.SpecularEnvTexture.str, [
            6,
            args.specularCube,
            _MToon0xMaterialContent.__specularIblCubeMapSampler
          ]);
        } else {
          webglResourceRepository.setUniform1iForTexture(shaderProgram, ShaderSemantics.SpecularEnvTexture.str, [
            6,
            dummyBlackCubeTexture
          ]);
        }
        if (args.setUniform) {
          if (firstTime) {
            const { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType } = _MToon0xMaterialContent.__setupHdriParameters(args);
            webglResourceRepository.setUniformValue(shaderProgram, ShaderSemantics.IBLParameter.str, firstTime, {
              x: mipmapLevelNumber,
              y: meshRenderComponent.diffuseCubeMapContribution,
              z: meshRenderComponent.specularCubeMapContribution,
              w: meshRenderComponent.rotationOfCubeMap
            });
            webglResourceRepository.setUniformValue(shaderProgram, ShaderSemantics.HDRIFormat.str, firstTime, {
              x: diffuseHdriType,
              y: specularHdriType
            });
          }
        } else {
          const { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType } = _MToon0xMaterialContent.__setupHdriParameters(args);
          const tmp_vector4 = AbstractMaterialContent.__tmp_vector4;
          tmp_vector4.x = mipmapLevelNumber;
          tmp_vector4.y = meshRenderComponent.diffuseCubeMapContribution;
          tmp_vector4.z = meshRenderComponent.specularCubeMapContribution;
          tmp_vector4.w = meshRenderComponent.rotationOfCubeMap;
          material.setParameter("iblParameter", tmp_vector4);
          const tmp_vector2 = AbstractMaterialContent.__tmp_vector2;
          tmp_vector2.x = diffuseHdriType;
          tmp_vector2.y = specularHdriType;
          material.setParameter("hdriFormat", tmp_vector2);
        }
        const blendShapeComponent = args.entity.tryToGetBlendShape();
        this.setMorphInfo(shaderProgram, args.entity.getMesh(), args.primitive, blendShapeComponent);
      }
      static unityBlendEnumCorrespondence(enumNumber) {
        let result = GL_ZERO;
        switch (enumNumber) {
          case 0:
            result = GL_ZERO;
            break;
          case 1:
            result = GL_ONE;
            break;
          case 2:
            result = GL_DST_COLOR;
            break;
          case 3:
            result = GL_SRC_COLOR;
            break;
          case 4:
            result = GL_ONE_MINUS_DST_COLOR;
            break;
          case 5:
            result = GL_SRC_ALPHA;
            break;
          case 6:
            result = GL_ONE_MINUS_SRC_COLOR;
            break;
          case 7:
            result = GL_DST_ALPHA;
            break;
          case 8:
            result = GL_ONE_MINUS_DST_ALPHA;
            break;
          case 9:
            result = GL_SRC_ALPHA_SATURATE;
            break;
          case 10:
            result = GL_ONE_MINUS_SRC_ALPHA;
            break;
        }
        return result;
      }
      static __setupHdriParameters(args) {
        let mipmapLevelNumber = 1;
        if (args.specularCube) {
          mipmapLevelNumber = args.specularCube.mipmapLevelNumber;
        }
        const meshRenderComponent = args.entity.getMeshRenderer();
        let diffuseHdriType = HdriFormat.LDR_SRGB.index;
        let specularHdriType = HdriFormat.LDR_SRGB.index;
        if (meshRenderComponent.diffuseCubeMap) {
          diffuseHdriType = meshRenderComponent.diffuseCubeMap.hdriFormat.index;
        }
        if (meshRenderComponent.specularCubeMap) {
          specularHdriType = meshRenderComponent.specularCubeMap.hdriFormat.index;
        }
        return {
          mipmapLevelNumber,
          meshRenderComponent,
          diffuseHdriType,
          specularHdriType
        };
      }
    };
    __name(_MToon0xMaterialContent, "MToon0xMaterialContent");
    __publicField(_MToon0xMaterialContent, "__diffuseIblCubeMapSampler", new Sampler({
      minFilter: TextureParameter.Linear,
      magFilter: TextureParameter.Linear,
      wrapS: TextureParameter.ClampToEdge,
      wrapT: TextureParameter.ClampToEdge,
      wrapR: TextureParameter.ClampToEdge
    }));
    __publicField(_MToon0xMaterialContent, "__specularIblCubeMapSampler", new Sampler({
      minFilter: TextureParameter.LinearMipmapLinear,
      magFilter: TextureParameter.Linear,
      wrapS: TextureParameter.ClampToEdge,
      wrapT: TextureParameter.ClampToEdge,
      wrapR: TextureParameter.ClampToEdge
    }));
    __publicField(_MToon0xMaterialContent, "_Cutoff", new ShaderSemanticsClass({
      str: "cutoff"
    }));
    __publicField(_MToon0xMaterialContent, "_Color", new ShaderSemanticsClass({
      str: "litColor"
    }));
    __publicField(_MToon0xMaterialContent, "_ShadeColor", new ShaderSemanticsClass({
      str: "shadeColor"
    }));
    __publicField(_MToon0xMaterialContent, "_litColorTexture", new ShaderSemanticsClass({
      str: "litColorTexture"
    }));
    __publicField(_MToon0xMaterialContent, "_shadeColorTexture", new ShaderSemanticsClass({
      str: "shadeColorTexture"
    }));
    __publicField(_MToon0xMaterialContent, "_BumpScale", new ShaderSemanticsClass({
      str: "normalScale"
    }));
    __publicField(_MToon0xMaterialContent, "_normalTexture", new ShaderSemanticsClass({
      str: "normalTexture"
    }));
    __publicField(_MToon0xMaterialContent, "_ReceiveShadowRate", new ShaderSemanticsClass({
      str: "receiveShadowRate"
    }));
    __publicField(_MToon0xMaterialContent, "_receiveShadowTexture", new ShaderSemanticsClass({
      str: "receiveShadowTexture"
    }));
    __publicField(_MToon0xMaterialContent, "_ShadingGradeRate", new ShaderSemanticsClass({
      str: "shadingGradeRate"
    }));
    __publicField(_MToon0xMaterialContent, "_shadingGradeTexture", new ShaderSemanticsClass({
      str: "shadingGradeTexture"
    }));
    __publicField(_MToon0xMaterialContent, "_ShadeShift", new ShaderSemanticsClass({
      str: "shadeShift"
    }));
    __publicField(_MToon0xMaterialContent, "_ShadeToony", new ShaderSemanticsClass({
      str: "shadeToony"
    }));
    __publicField(_MToon0xMaterialContent, "_LightColorAttenuation", new ShaderSemanticsClass({
      str: "lightColorAttenuation"
    }));
    __publicField(_MToon0xMaterialContent, "_AmbientColor", new ShaderSemanticsClass({
      str: "ambientColor"
    }));
    __publicField(_MToon0xMaterialContent, "_IndirectLightIntensity", new ShaderSemanticsClass({
      str: "indirectLightIntensity"
    }));
    __publicField(_MToon0xMaterialContent, "_rimTexture", new ShaderSemanticsClass({
      str: "rimTexture"
    }));
    __publicField(_MToon0xMaterialContent, "_RimColor", new ShaderSemanticsClass({
      str: "rimColor"
    }));
    __publicField(_MToon0xMaterialContent, "_RimLightingMix", new ShaderSemanticsClass({
      str: "rimLightingMix"
    }));
    __publicField(_MToon0xMaterialContent, "_RimFresnelPower", new ShaderSemanticsClass({
      str: "rimFresnelPower"
    }));
    __publicField(_MToon0xMaterialContent, "_RimLift", new ShaderSemanticsClass({
      str: "rimLift"
    }));
    __publicField(_MToon0xMaterialContent, "_matCapTexture", new ShaderSemanticsClass({
      str: "matCapTexture"
    }));
    __publicField(_MToon0xMaterialContent, "_EmissionColor", new ShaderSemanticsClass({
      str: "emissionColor"
    }));
    __publicField(_MToon0xMaterialContent, "_emissionTexture", new ShaderSemanticsClass({
      str: "emissionTexture"
    }));
    __publicField(_MToon0xMaterialContent, "_OutlineWidthTexture", new ShaderSemanticsClass({
      str: "outlineWidthTexture"
    }));
    __publicField(_MToon0xMaterialContent, "_OutlineWidth", new ShaderSemanticsClass({
      str: "outlineWidth"
    }));
    __publicField(_MToon0xMaterialContent, "_OutlineScaledMaxDistance", new ShaderSemanticsClass({
      str: "outlineScaledMaxDistance"
    }));
    __publicField(_MToon0xMaterialContent, "_OutlineColor", new ShaderSemanticsClass({
      str: "outlineColor"
    }));
    __publicField(_MToon0xMaterialContent, "_OutlineLightingMix", new ShaderSemanticsClass({
      str: "outlineLightingMix"
    }));
    __publicField(_MToon0xMaterialContent, "Aspect", new ShaderSemanticsClass({
      str: "aspect"
    }));
    __publicField(_MToon0xMaterialContent, "CameraUp", new ShaderSemanticsClass({
      str: "cameraUp"
    }));
    __publicField(_MToon0xMaterialContent, "usableBlendEquationModeAlpha");
    MToon0xMaterialContent = _MToon0xMaterialContent;
  }
});

// src/foundation/materials/contents/CustomMaterialContent.ts
var _CustomMaterialContent, CustomMaterialContent;
var init_CustomMaterialContent = __esm({
  "src/foundation/materials/contents/CustomMaterialContent.ts"() {
    "use strict";
    init_ShaderSemantics();
    init_AbstractMaterialContent();
    init_ComponentRepository();
    init_CameraComponent();
    init_HdriFormat();
    init_GlobalDataRepository();
    init_DummyTextures();
    init_MutableVector4();
    init_MutableVector2();
    init_CGAPIResourceRepository();
    init_Sampler();
    init_TextureParameter();
    _CustomMaterialContent = class _CustomMaterialContent extends AbstractMaterialContent {
      constructor({ name, isMorphing, isSkinning, isLighting, vertexShader, pixelShader, additionalShaderSemanticInfo, vertexShaderWebGpu, pixelShaderWebGpu }) {
        super(name, {
          isMorphing,
          isSkinning,
          isLighting
        });
        const shaderSemanticsInfoArray = this.doShaderReflection(vertexShader, pixelShader, vertexShaderWebGpu, pixelShaderWebGpu);
        if (!_CustomMaterialContent.__diffuseIblCubeMapSampler.created) {
          _CustomMaterialContent.__diffuseIblCubeMapSampler.create();
        }
        if (!_CustomMaterialContent.__specularIblCubeMapSampler.created) {
          _CustomMaterialContent.__specularIblCubeMapSampler.create();
        }
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray.concat(additionalShaderSemanticInfo));
      }
      _setInternalSettingParametersToGpuWebGpu({ material, args }) {
        const { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType } = _CustomMaterialContent.__setupHdriParameters(args);
        const tmp_vector4 = AbstractMaterialContent.__tmp_vector4;
        tmp_vector4.x = mipmapLevelNumber;
        tmp_vector4.y = meshRenderComponent.diffuseCubeMapContribution;
        tmp_vector4.z = meshRenderComponent.specularCubeMapContribution;
        tmp_vector4.w = meshRenderComponent.rotationOfCubeMap;
        material.setParameter("iblParameter", tmp_vector4);
        const tmp_vector2 = AbstractMaterialContent.__tmp_vector2;
        tmp_vector2.x = diffuseHdriType;
        tmp_vector2.y = specularHdriType;
        material.setParameter("hdriFormat", tmp_vector2);
        const meshRendererComponent = args.entity.tryToGetMeshRenderer();
        if (meshRendererComponent != null && meshRendererComponent.diffuseCubeMap != null && meshRendererComponent.specularCubeMap != null) {
          const iblParameterVec4 = MutableVector4.zero();
          const hdriFormatVec2 = MutableVector2.zero();
          iblParameterVec4.x = meshRendererComponent.specularCubeMap.mipmapLevelNumber;
          iblParameterVec4.y = meshRendererComponent.diffuseCubeMapContribution;
          iblParameterVec4.z = meshRendererComponent.specularCubeMapContribution;
          iblParameterVec4.w = meshRendererComponent.rotationOfCubeMap;
          material.setParameter("iblParameter", iblParameterVec4);
          hdriFormatVec2.x = meshRendererComponent.diffuseCubeMap.hdriFormat.index;
          hdriFormatVec2.y = meshRendererComponent.specularCubeMap.hdriFormat.index;
          material.setParameter("hdriFormat", hdriFormatVec2);
        }
      }
      _setInternalSettingParametersToGpuWebGL({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
          this.setWorldMatrix(shaderProgram, args.worldMatrix);
          this.setNormalMatrix(shaderProgram, args.normalMatrix);
          this.setIsBillboard(shaderProgram, args.isBillboard);
          if (firstTime || args.isVr) {
            let cameraComponent = args.renderPass.cameraComponent;
            if (cameraComponent == null) {
              cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
            }
            this.setViewInfo(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
            this.setProjection(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          }
          this.setLightsInfo(shaderProgram, args.lightComponents, material, args.setUniform);
          const skeletalComponent = args.entity.tryToGetSkeletal();
          this.setSkinning(shaderProgram, args.setUniform, skeletalComponent);
        }
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        if (args.diffuseCube && args.diffuseCube.isTextureReady) {
          webglResourceRepository.setUniform1iForTexture(shaderProgram, ShaderSemantics.DiffuseEnvTexture.str, [
            5,
            args.diffuseCube,
            _CustomMaterialContent.__diffuseIblCubeMapSampler
          ]);
        } else {
          webglResourceRepository.setUniform1iForTexture(shaderProgram, ShaderSemantics.DiffuseEnvTexture.str, [
            5,
            dummyBlackCubeTexture
          ]);
        }
        if (args.specularCube && args.specularCube.isTextureReady) {
          webglResourceRepository.setUniform1iForTexture(shaderProgram, ShaderSemantics.SpecularEnvTexture.str, [
            6,
            args.specularCube,
            _CustomMaterialContent.__specularIblCubeMapSampler
          ]);
        } else {
          webglResourceRepository.setUniform1iForTexture(shaderProgram, ShaderSemantics.SpecularEnvTexture.str, [
            6,
            dummyBlackCubeTexture
          ]);
        }
        if (args.setUniform) {
          if (firstTime) {
            const { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType } = _CustomMaterialContent.__setupHdriParameters(args);
            webglResourceRepository.setUniformValue(shaderProgram, ShaderSemantics.IBLParameter.str, firstTime, {
              x: mipmapLevelNumber,
              y: meshRenderComponent.diffuseCubeMapContribution,
              z: meshRenderComponent.specularCubeMapContribution,
              w: meshRenderComponent.rotationOfCubeMap
            });
            webglResourceRepository.setUniformValue(shaderProgram, ShaderSemantics.HDRIFormat.str, firstTime, {
              x: diffuseHdriType,
              y: specularHdriType
            });
          }
        } else {
          const { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType } = _CustomMaterialContent.__setupHdriParameters(args);
          const tmp_vector4 = AbstractMaterialContent.__tmp_vector4;
          tmp_vector4.x = mipmapLevelNumber;
          tmp_vector4.y = meshRenderComponent.diffuseCubeMapContribution;
          tmp_vector4.z = meshRenderComponent.specularCubeMapContribution;
          tmp_vector4.w = meshRenderComponent.rotationOfCubeMap;
          material.setParameter("iblParameter", tmp_vector4);
          const tmp_vector2 = AbstractMaterialContent.__tmp_vector2;
          tmp_vector2.x = diffuseHdriType;
          tmp_vector2.y = specularHdriType;
          material.setParameter("hdriFormat", tmp_vector2);
        }
      }
      _setInternalSettingParametersToGpuWebGLPerPrimitive({ material, shaderProgram, firstTime, args }) {
        const blendShapeComponent = args.entity.tryToGetBlendShape();
        this.setMorphInfo(shaderProgram, args.entity.getMesh(), args.primitive, blendShapeComponent);
      }
      static __setupHdriParameters(args) {
        let mipmapLevelNumber = 1;
        if (args.specularCube) {
          mipmapLevelNumber = args.specularCube.mipmapLevelNumber;
        }
        const meshRenderComponent = args.entity.getMeshRenderer();
        let diffuseHdriType = HdriFormat.LDR_SRGB.index;
        let specularHdriType = HdriFormat.LDR_SRGB.index;
        if (meshRenderComponent.diffuseCubeMap) {
          diffuseHdriType = meshRenderComponent.diffuseCubeMap.hdriFormat.index;
        }
        if (meshRenderComponent.specularCubeMap) {
          specularHdriType = meshRenderComponent.specularCubeMap.hdriFormat.index;
        }
        return {
          mipmapLevelNumber,
          meshRenderComponent,
          diffuseHdriType,
          specularHdriType
        };
      }
    };
    __name(_CustomMaterialContent, "CustomMaterialContent");
    __publicField(_CustomMaterialContent, "__globalDataRepository", GlobalDataRepository.getInstance());
    __publicField(_CustomMaterialContent, "__diffuseIblCubeMapSampler", new Sampler({
      minFilter: TextureParameter.Linear,
      magFilter: TextureParameter.Linear,
      wrapS: TextureParameter.ClampToEdge,
      wrapT: TextureParameter.ClampToEdge,
      wrapR: TextureParameter.ClampToEdge
    }));
    __publicField(_CustomMaterialContent, "__specularIblCubeMapSampler", new Sampler({
      minFilter: TextureParameter.LinearMipmapLinear,
      magFilter: TextureParameter.Linear,
      wrapS: TextureParameter.ClampToEdge,
      wrapT: TextureParameter.ClampToEdge,
      wrapR: TextureParameter.ClampToEdge
    }));
    CustomMaterialContent = _CustomMaterialContent;
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/FurnaceTestShader/FurnaceTestShader.vert
var FurnaceTestShader_default;
var init_FurnaceTestShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/FurnaceTestShader/FurnaceTestShader.vert"() {
    FurnaceTestShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord;\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_joint;\nin vec4 a_weight;\n\nout vec2 v_texcoord;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\nmat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\nmat4 viewMatrix = get_viewMatrix(cameraSID, 0);\nmat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\ngl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4(a_position, 1.0);\n\n\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  v_normal_inWorld = normalMatrix * a_normal;\n  v_position_inWorld = worldMatrix * vec4(a_position, 1.0);\n  v_texcoord = a_texcoord;\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/FurnaceTestShader/FurnaceTestShader.frag
var FurnaceTestShader_default2;
var init_FurnaceTestShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/FurnaceTestShader/FurnaceTestShader.frag"() {
    FurnaceTestShader_default2 = { code: '\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\n\n/* shaderity: @{renderTargetBegin} */\n\n\n\n/* shaderity: @{getters} */\n\n#define MATH_PI 3.141592\n\n// These codes are referenced from https://github.com/knarkowicz/FurnaceTest\nfloat roughnessRemap(float userRoughness) {\n  return userRoughness * userRoughness;\n}\n\n// GGX NDF\nfloat d_ggx(float userRoughness, float NH) {\n  float alphaRoughness = userRoughness * userRoughness;\n  float roughnessSqr = alphaRoughness * alphaRoughness;\n  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;\n  return roughnessSqr / (MATH_PI * f * f);\n}\n\n// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nvec2 envBRDFApprox( float Roughness, float NoV ) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022 );\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );\n  vec4 r = Roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n  return AB;\n}\n\nfloat specularIBL(float userRoughness, float NV, float f0) {\n  /// Use specular BRDF LUT\n  // vec3 brdf = texture(u_brdfLutTexture, vec2(NV, 1.0 - userRoughness)).rgb;\n  // float specular = 1.0 * (f0 * brdf.x + brdf.y);\n\n  /// Use specular BRDF Approx\n  vec2 f_ab = envBRDFApprox(userRoughness, NV);\n  vec3 specular = vec3(f0) * f_ab.x + f_ab.y;\n  return specular.x;\n}\n\n// The Schlick Approximation to Fresnel\nfloat fresnel(float f0, float VH) {\n  return f0 + (1.0 - f0) * pow(1.0 - VH, 5.0);\n}\n\nfloat smithG1(float roughness, float NoV)\n{\n	float a = roughnessRemap( roughness );\n	float a2 = a * a;\n	float NoV2 = NoV * NoV;\n	float lambda = (-1.0 + sqrt(1.0 + a2 * (1.0 - NoV2) / NoV2)) * 0.5;\n	return 1.0 / (1.0 + lambda);\n}\n\nfloat smithG(float roughness, float NoV, float NoL)\n{\n	float a = roughnessRemap( roughness );\n	float a2 = a * a;\n	float NoV2 = NoV * NoV;\n	float NoL2 = NoL * NoL;\n	float lambdaV = (-1.0 + sqrt(1.0 + a2 * (1.0 - NoV2) / NoV2)) * 0.5;\n	float lambdaL = (-1.0 + sqrt(1.0 + a2 * (1.0 - NoL2) / NoL2)) * 0.5;\n	return 1.0 / (1.0 + lambdaV + lambdaL);\n}\n\nfloat g_shieldingForWeak(float alphaRoughness, float NV, float NL) {\n  float r = alphaRoughness;\n\n  // Local Masking using "Schlick-Smith" Masking Function\n  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));\n\n  return localMasking;\n}\n\n\nfloat g_shielding(float roughness, float NV, float NL) {\n  float a = roughnessRemap( roughness );\n  float r = a;\n\n  // Local Shadowing using "Schlick-Smith" Masking Function\n  float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));\n\n  // Local Masking using "Schlick-Smith" Masking Function\n  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));\n\n  return localShadowing * localMasking;\n}\n\nfloat v_GGXCorrelatedForWeak(float roughness, float NV, float NL) {\n  float a = roughnessRemap( roughness );\n  float a2 = a * a;\n  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);\n  return 0.5 / (GGXV);\n}\n\nfloat v_GGXCorrelated(float roughness, float NV, float NL) {\n  float a = roughnessRemap( roughness );\n  float a2 = a * a;\n  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);\n  float GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);\n  return 0.5 / (GGXV + GGXL);\n}\n\n// this is from https://learnopengl.com/PBR/IBL/Specular-IBL\nfloat vanDerCorpus(int n, int base)\n{\n    float invBase = 1.0 / float(base);\n    float denom   = 1.0;\n    float result  = 0.0;\n\n    for(int i = 0; i < 32; ++i)\n    {\n        if(n > 0)\n        {\n            denom   = mod(float(n), 2.0);\n            result += denom * invBase;\n            invBase = invBase / 2.0;\n            n       = int(float(n) / 2.0);\n        }\n    }\n\n    return result;\n}\n\nvec2 hammersleyNoBitOps(int i, int N)\n{\n  return vec2(float(i)/float(N), vanDerCorpus(i, 2));\n}\n\nfloat radicalInverse_VdC(uint bits)\n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 hammersley(uint i, uint N)\n{\n    return vec2(float(i)/float(N), radicalInverse_VdC(i));\n}\n\nvec3 sampleHemisphereGGX(vec2 Xi, float roughness) {\n  float a = roughnessRemap(roughness);\n	float a2 = a * a;\n\n  float phi = 2.0 * MATH_PI * Xi.x;\n  float cosPhi = cos(phi);\n  float sinPhi = sin(phi);\n  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a2 - 1.0) * Xi.y)); // GGX\n  float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n  return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\nfloat weakWhiteFurnaceTest(float roughness, float NoV, float f0, int g_type, int disable_fresnel)\n{\n	float vx = sqrt(1.0 - NoV * NoV);\n	float vy = 0.0;\n	float vz = NoV;\n\n	float integral = 0.0;\n	const uint sampleNum = 2048u;\n	for (uint i = 0u; i < sampleNum; ++i)\n	{\n    vec2 Xi = hammersley(i, sampleNum);\n\n    vec3 hvec = sampleHemisphereGGX(Xi, roughness);\n\n		float VoHUnsat = vx * hvec.x + vy * hvec.y + vz * hvec.z;\n\n    float lz = 2.0 * VoHUnsat * hvec.z - vz;\n\n    float NoL = max(lz, 0.0);\n		float NoH = max(hvec.z, 0.0);\n		float VoH = max(VoHUnsat, 0.0);\n\n    float f = fresnel(f0, VoH);\n\n    float g1 = 0.0;\n    if (g_type == 0) {\n      g1 = smithG1(roughness, NoV);\n    } else if (g_type == 1) {\n      g1 = g_shieldingForWeak(roughness, NoV, NoL);\n    } else if (g_type == 2) {\n      g1 = v_GGXCorrelatedForWeak(roughness, NoV, NoL) * 4.0 * NoV * NoL;\n    }\n\n    float pdf = 4.0 * VoH / NoH;\n    float integralValue = (g1 * pdf) / (4.0 * NoV);\n    if (disable_fresnel == 0) {\n      integralValue *= f;\n    }\n    // integralValue *= 0.5; // Set furnace color 0.5\n\n    integral += integralValue;\n\n	}\n	integral /= float(sampleNum);\n	return clamp(integral, 0.0, 1.0);\n}\n\nfloat whiteFurnaceTest(float roughness, float NoV, float f0, int g_type, int disable_fresnel)\n{\n	float vx = sqrt(1.0 - NoV * NoV);\n	float vy = 0.0;\n	float vz = NoV;\n\n	float integral = 0.0;\n	const uint sampleNum = 4096u;\n	for (uint i = 0u; i < sampleNum; ++i)\n	{\n\n    vec2 Xi = hammersley(i, sampleNum);\n\n    vec3 hvec = sampleHemisphereGGX(Xi, roughness);\n\n		float VoHUnsat = vx * hvec.x + vy * hvec.y + vz * hvec.z;\n		float lx = 2.0 * VoHUnsat * hvec.x - vx;\n		float ly = 2.0 * VoHUnsat * hvec.y - vy;\n		float lz = 2.0 * VoHUnsat * hvec.z - vz;\n\n		float NoL = max(lz, 0.0);\n		float NoH = max(hvec.z, 0.0);\n    float VoH = max(VoHUnsat, 0.0);\n\n    float f = fresnel(f0, VoH);\n\n    float g = 0.0;\n    if (g_type == 0) {\n      g = smithG(roughness, NoV, NoL);\n    } else if (g_type == 1){\n      g = g_shielding(roughness, NoV, NoL);\n    } else if (g_type == 2){\n      g = v_GGXCorrelated(roughness, NoV, NoL) * (4.0 * NoV * NoL);\n    } else if (g_type == 3) {\n      g = 0.0;\n    }\n\n    float pdf = 4.0 * VoH / NoH;\n    float integralValue = (g * pdf) / (4.0 * NoV);\n    if (disable_fresnel == 0 && g_type != 3) {\n      integralValue *= f;\n    }\n    // integralValue *= 0.5; // Set furnace color 0.5\n    integral += integralValue;\n	}\n  integral /= float(sampleNum);\n  if (g_type == 3) {\n    integral = specularIBL(roughness, NoV, f0);\n  }\n	return clamp(integral, 0.0, 1.0);\n}\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  vec2 quadSizeInPixel = get_screenInfo(materialSID, 0);\n  float roughness = 0.0;\n  float NoV = 0.0; // normal dot view vector\n\n  // 2D mode\n  int mode = get_mode(materialSID, 0);\n  if (mode == 0) {\n    roughness = (gl_FragCoord.y) / quadSizeInPixel.y;\n    NoV = (gl_FragCoord.x) / quadSizeInPixel.x;\n  } else {\n    // object mode\n    // Roughness\n    const float c_MinRoughness = 0.04;\n    vec2 metallicRoughnessFactor = get_metallicRoughnessFactor(materialSID, 0);\n    float userRoughness = metallicRoughnessFactor.y;\n    float metallic = metallicRoughnessFactor.x;\n\n    vec4 ormTexel = texture(u_metallicRoughnessTexture, v_texcoord);\n    userRoughness = ormTexel.g * userRoughness;\n    userRoughness = clamp(userRoughness, c_MinRoughness, 1.0);\n    roughness = userRoughness;\n\n    // vec3 viewVector = normalize(vec3(0.0, 0.0, 10.0) - v_position_inWorld.xyz);\n    // vec3 viewVector = normalize(u_viewPosition - v_position_inWorld.xyz);\n    vec3 viewVector = vec3(0.0, 0.0, 1.0);\n    NoV = dot(v_normal_inWorld, viewVector);\n  }\n\n  int debugView = get_debugView(materialSID, 0);\n  float f0 = get_f0(materialSID, 0);\n  int g_type = get_g_type(materialSID, 0);\n  int disable_fresnel = get_disable_fresnel(materialSID, 0);\n\n  if (debugView == 0) {\n    float whiteFurnaceResult = whiteFurnaceTest(roughness, NoV, f0, g_type, disable_fresnel);\n    rt0 = vec4(whiteFurnaceResult, whiteFurnaceResult, whiteFurnaceResult, 1.0);\n\n  } else if (debugView == 1) {\n    float weakWhiteFurnaceResult = weakWhiteFurnaceTest(roughness, NoV, f0, g_type, disable_fresnel);\n    rt0 = vec4(weakWhiteFurnaceResult, weakWhiteFurnaceResult, weakWhiteFurnaceResult, 1.0);\n\n  } else if (debugView == 2){\n    float nn = NoV*0.5+0.5;\n    rt0 = vec4(nn, nn, nn, 1.0);\n\n  } else if (debugView == 3){\n    rt0 = vec4(v_normal_inWorld.xyz, 1.0);\n\n  } else if (debugView == 4){\n    float whiteFurnaceResult = whiteFurnaceTest(roughness, NoV, f0, g_type, disable_fresnel);\n    float weakWhiteFurnaceResult = weakWhiteFurnaceTest(roughness, NoV, f0, g_type, disable_fresnel);\n    rt0 = vec4(whiteFurnaceResult, weakWhiteFurnaceResult, 0.0, 1.0);\n\n  } else if (debugView == 5){\n    rt0 = vec4(roughness, NoV, 0.0, 1.0);\n\n  } else {\n    rt0 = vec4(1.0, 1.0, 1.0, 1.0);\n  }\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n', shaderStage: "fragment", isFragmentShader: true };
  }
});

// src/foundation/materials/contents/FurnaceTestMaterialContent.ts
var _FurnaceTestMaterialContent, FurnaceTestMaterialContent;
var init_FurnaceTestMaterialContent = __esm({
  "src/foundation/materials/contents/FurnaceTestMaterialContent.ts"() {
    "use strict";
    init_ComponentType();
    init_CompositionType();
    init_Scalar();
    init_ShaderSemantics();
    init_ShaderType();
    init_Vector2();
    init_AbstractMaterialContent();
    init_ComponentRepository();
    init_CameraComponent();
    init_FurnaceTestShader();
    init_FurnaceTestShader2();
    init_DummyTextures();
    _FurnaceTestMaterialContent = class _FurnaceTestMaterialContent extends AbstractMaterialContent {
      constructor(materialName) {
        super(materialName, {}, FurnaceTestShader_default, FurnaceTestShader_default2);
        const shaderSemanticsInfoArray = [
          {
            semantic: "debugView",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(0),
            min: 0,
            max: 1
          },
          {
            semantic: "disable_fresnel",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(0),
            min: 0,
            max: 1
          },
          {
            semantic: "f0",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(1),
            min: 0,
            max: 1
          },
          {
            semantic: "g_type",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(0),
            min: 0,
            max: 3
          },
          {
            semantic: "mode",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(0),
            min: 0,
            max: 1
          },
          {
            semantic: "screenInfo",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Vec2,
            stage: ShaderType.PixelShader,
            initialValue: Vector2.fromCopyArray2([
              0,
              0
            ]),
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "metallicRoughnessFactor",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Vec2,
            stage: ShaderType.PixelShader,
            initialValue: Vector2.fromCopyArray2([
              1,
              1
            ]),
            min: 0,
            max: 2
          },
          {
            semantic: "metallicRoughnessTexture",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Texture2D,
            stage: ShaderType.PixelShader,
            initialValue: [
              1,
              dummyWhiteTexture
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          }
        ];
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
      }
      _setInternalSettingParametersToGpuWebGL({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
          this.setWorldMatrix(shaderProgram, args.worldMatrix);
          this.setNormalMatrix(shaderProgram, args.normalMatrix);
          if (firstTime) {
            let cameraComponent = args.renderPass.cameraComponent;
            if (cameraComponent == null) {
              cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
            }
            this.setViewInfo(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
            this.setProjection(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
            this.setLightsInfo(shaderProgram, args.lightComponents, material, args.setUniform);
          }
        }
      }
    };
    __name(_FurnaceTestMaterialContent, "FurnaceTestMaterialContent");
    __publicField(_FurnaceTestMaterialContent, "mode", new ShaderSemanticsClass({
      str: "mode"
    }));
    __publicField(_FurnaceTestMaterialContent, "debugView", new ShaderSemanticsClass({
      str: "debugView"
    }));
    __publicField(_FurnaceTestMaterialContent, "g_type", new ShaderSemanticsClass({
      str: "g_type"
    }));
    __publicField(_FurnaceTestMaterialContent, "disable_fresnel", new ShaderSemanticsClass({
      str: "disable_fresnel"
    }));
    __publicField(_FurnaceTestMaterialContent, "f0", new ShaderSemanticsClass({
      str: "f0"
    }));
    FurnaceTestMaterialContent = _FurnaceTestMaterialContent;
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/DetectHighLuminanceAndCorrectShader/DetectHighLuminanceAndCorrectShader.vert
var DetectHighLuminanceAndCorrectShader_default;
var init_DetectHighLuminanceAndCorrectShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/DetectHighLuminanceAndCorrectShader/DetectHighLuminanceAndCorrectShader.vert"() {
    DetectHighLuminanceAndCorrectShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\nin vec4 a_instanceInfo;\nin vec3 a_position;\nin vec2 a_texcoord_0;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/DetectHighLuminanceAndCorrectShader/DetectHighLuminanceAndCorrectShader.frag
var DetectHighLuminanceAndCorrectShader_default2;
var init_DetectHighLuminanceAndCorrectShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/DetectHighLuminanceAndCorrectShader/DetectHighLuminanceAndCorrectShader.frag"() {
    DetectHighLuminanceAndCorrectShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{renderTargetBegin} */\n\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\nin vec2 v_texcoord_0;\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  vec4 baseColor = texture(u_baseColorTexture, v_texcoord_0);\n\n  float luminance = dot(baseColor.rgb, vec3(0.2126, 0.7152, 0.0722));\n\n  float luminanceCriterion = get_luminanceCriterion(materialSID, 0);\n\n  baseColor.rgb = mix(vec3(0.0), baseColor.rgb, (luminance - luminanceCriterion) / luminanceCriterion);\n  baseColor.a = 1.0;\n\n  rt0 = baseColor;\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/DetectHighLuminanceAndCorrectShader/DetectHighLuminanceAndCorrectShader.vert
var DetectHighLuminanceAndCorrectShader_default3;
var init_DetectHighLuminanceAndCorrectShader3 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/DetectHighLuminanceAndCorrectShader/DetectHighLuminanceAndCorrectShader.vert"() {
    DetectHighLuminanceAndCorrectShader_default3 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n  @builtin(vertex_index) vertexIdx : u32,\n) -> VertexOutput {\n  var output : VertexOutput;\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\nlet x = f32((vertexIdx & 1u) << 2u);\nlet y = f32((vertexIdx & 2u) << 1u);\noutput.texcoord_0.x = x * 0.5;\noutput.texcoord_0.y = y * 0.5;\noutput.texcoord_0.y = 1.0 - output.texcoord_0.y;\noutput.position = vec4f(x - 1.0, y - 1.0, 0, 1);\n\n\n  return output;\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/DetectHighLuminanceAndCorrectShader/DetectHighLuminanceAndCorrectShader.frag
var DetectHighLuminanceAndCorrectShader_default4;
var init_DetectHighLuminanceAndCorrectShader4 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/DetectHighLuminanceAndCorrectShader/DetectHighLuminanceAndCorrectShader.frag"() {
    DetectHighLuminanceAndCorrectShader_default4 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n@fragment\nfn main (\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var baseColor = textureSampleLevel(baseColorTexture, baseColorSampler, input.texcoord_0, 0.0);\n\n  let luminance = dot(baseColor.rgb, vec3f(0.2126, 0.7152, 0.0722));\n\n  let luminanceCriterion: f32 = get_luminanceCriterion(materialSID, 0);\n  baseColor = vec4f(mix(vec3f(0.0), baseColor.rgb, (luminance - luminanceCriterion) / luminanceCriterion), 1.0);\n\n  return baseColor;\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// src/foundation/materials/contents/DetectHighLuminanceMaterialContent.ts
var _DetectHighLuminanceMaterialContent, DetectHighLuminanceMaterialContent;
var init_DetectHighLuminanceMaterialContent = __esm({
  "src/foundation/materials/contents/DetectHighLuminanceMaterialContent.ts"() {
    "use strict";
    init_ShaderSemantics();
    init_CompositionType();
    init_ComponentType();
    init_ShaderType();
    init_ComponentRepository();
    init_CameraComponent();
    init_Scalar();
    init_AbstractMaterialContent();
    init_DetectHighLuminanceAndCorrectShader();
    init_DetectHighLuminanceAndCorrectShader2();
    init_DetectHighLuminanceAndCorrectShader3();
    init_DetectHighLuminanceAndCorrectShader4();
    init_SystemState();
    init_ProcessApproach();
    init_Sampler();
    init_definitions();
    _DetectHighLuminanceMaterialContent = class _DetectHighLuminanceMaterialContent extends AbstractMaterialContent {
      // static LuminanceReduce: ShaderSemanticsEnum = new ShaderSemanticsClass({
      //   str: 'luminanceReduce',
      // });
      constructor(materialName, textureToDetectHighLuminance) {
        super(materialName, {});
        const sampler = new Sampler({
          wrapS: TextureParameter.ClampToEdge,
          wrapT: TextureParameter.ClampToEdge,
          minFilter: TextureParameter.Linear,
          magFilter: TextureParameter.Linear
        });
        sampler.create();
        const shaderSemanticsInfoArray = [
          {
            semantic: "luminanceCriterion",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(2),
            min: 0,
            max: Number.MAX_VALUE
          },
          // {
          //   semantic: DetectHighLuminanceMaterialContent.LuminanceReduce,
          //   componentType: ComponentType.Float,
          //   compositionType: CompositionType.Scalar,
          //   stage: ShaderType.PixelShader,
          //   initialValue: Scalar.fromCopyNumber(0.25),
          //   min: 0,
          //   max: 1,
          // },
          {
            semantic: "baseColorTexture",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Texture2D,
            stage: ShaderType.PixelShader,
            initialValue: [
              0,
              textureToDetectHighLuminance,
              sampler
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          }
        ];
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          this.__vertexShaderityObject = DetectHighLuminanceAndCorrectShader_default3;
          this.__pixelShaderityObject = DetectHighLuminanceAndCorrectShader_default4;
        } else {
          this.__vertexShaderityObject = DetectHighLuminanceAndCorrectShader_default;
          this.__pixelShaderityObject = DetectHighLuminanceAndCorrectShader_default2;
        }
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
      }
      _setInternalSettingParametersToGpuWebGL({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
          this.setWorldMatrix(shaderProgram, args.worldMatrix);
          let cameraComponent = args.renderPass.cameraComponent;
          if (cameraComponent == null) {
            cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
          }
          if (cameraComponent) {
            this.setViewInfo(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
            this.setProjection(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          }
        }
      }
    };
    __name(_DetectHighLuminanceMaterialContent, "DetectHighLuminanceMaterialContent");
    __publicField(_DetectHighLuminanceMaterialContent, "LuminanceCriterion", new ShaderSemanticsClass({
      str: "luminanceCriterion"
    }));
    DetectHighLuminanceMaterialContent = _DetectHighLuminanceMaterialContent;
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/SynthesizeHDRTextureShader/SynthesizeHDRTextureShader.vert
var SynthesizeHDRTextureShader_default;
var init_SynthesizeHDRTextureShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/SynthesizeHDRTextureShader/SynthesizeHDRTextureShader.vert"() {
    SynthesizeHDRTextureShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\nin vec4 a_instanceInfo;\nin vec3 a_position;\nin vec2 a_texcoord_0;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/SynthesizeHDRTextureShader/SynthesizeHDRTextureShader.frag
var SynthesizeHDRTextureShader_default2;
var init_SynthesizeHDRTextureShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/SynthesizeHDRTextureShader/SynthesizeHDRTextureShader.frag"() {
    SynthesizeHDRTextureShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{renderTargetBegin} */\n\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\nin vec2 v_texcoord_0;\n\nfloat edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {\n  vec3 d = fwidth(bary3);\n  vec3 x = bary3 + vec3(1.0 - wireframeWidthInner) * d;\n  vec3 a3 = smoothstep(vec3(0.0), d, x);\n  float factor = min(min(a3.x, a3.y), a3.z);\n\n  return clamp((1.0 - factor), 0.0, 1.0);\n}\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  float synthesizeCoefficient0 = u_synthesizeCoefficient[0];\n  vec3 color = synthesizeCoefficient0 * texture(u_synthesizeTexture0, v_texcoord_0).rgb;\n\n  float synthesizeCoefficient1 = u_synthesizeCoefficient[1];\n  float synthesizeCoefficient2 = u_synthesizeCoefficient[2];\n  float synthesizeCoefficient3 = u_synthesizeCoefficient[3];\n  float synthesizeCoefficient4 = u_synthesizeCoefficient[4];\n  float synthesizeCoefficient5 = u_synthesizeCoefficient[5];\n\n  color += synthesizeCoefficient1 * texture(u_synthesizeTexture1, v_texcoord_0).rgb;\n  color += synthesizeCoefficient2 * texture(u_synthesizeTexture2, v_texcoord_0).rgb;\n  color += synthesizeCoefficient3 * texture(u_synthesizeTexture3, v_texcoord_0).rgb;\n  color += synthesizeCoefficient4 * texture(u_synthesizeTexture4, v_texcoord_0).rgb;\n  color += synthesizeCoefficient5 * texture(u_synthesizeTexture5, v_texcoord_0).rgb;\n\n  rt0 = vec4(color, 1.0);\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/SynthesizeHDRTextureShader/SynthesizeHDRTextureShader.vert
var SynthesizeHDRTextureShader_default3;
var init_SynthesizeHDRTextureShader3 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/SynthesizeHDRTextureShader/SynthesizeHDRTextureShader.vert"() {
    SynthesizeHDRTextureShader_default3 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n  @builtin(vertex_index) vertexIdx : u32,\n) -> VertexOutput {\n  var output : VertexOutput;\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\nlet x = f32((vertexIdx & 1u) << 2u);\nlet y = f32((vertexIdx & 2u) << 1u);\noutput.texcoord_0.x = x * 0.5;\noutput.texcoord_0.y = y * 0.5;\noutput.texcoord_0.y = 1.0 - output.texcoord_0.y;\noutput.position = vec4f(x - 1.0, y - 1.0, 0, 1);\n\n\n  return output;\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/SynthesizeHDRTextureShader/SynthesizeHDRTextureShader.frag
var SynthesizeHDRTextureShader_default4;
var init_SynthesizeHDRTextureShader4 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/SynthesizeHDRTextureShader/SynthesizeHDRTextureShader.frag"() {
    SynthesizeHDRTextureShader_default4 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n@fragment\nfn main (\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  let synthesizeCoefficient0 = get_synthesizeCoefficient(materialSID, 0);\n  var color: vec3f = synthesizeCoefficient0 * textureSample(synthesizeTexture0, synthesizeSampler0, input.texcoord_0).rgb;\n\n  let synthesizeCoefficient1 = get_synthesizeCoefficient(materialSID, 1);\n  let synthesizeCoefficient2 = get_synthesizeCoefficient(materialSID, 2);\n  let synthesizeCoefficient3 = get_synthesizeCoefficient(materialSID, 3);\n  let synthesizeCoefficient4 = get_synthesizeCoefficient(materialSID, 4);\n  let synthesizeCoefficient5 = get_synthesizeCoefficient(materialSID, 5);\n\n  color += synthesizeCoefficient1 * textureSample(synthesizeTexture1, synthesizeSampler0, input.texcoord_0).rgb;\n  color += synthesizeCoefficient2 * textureSample(synthesizeTexture2, synthesizeSampler0, input.texcoord_0).rgb;\n  color += synthesizeCoefficient3 * textureSample(synthesizeTexture3, synthesizeSampler0, input.texcoord_0).rgb;\n  color += synthesizeCoefficient4 * textureSample(synthesizeTexture4, synthesizeSampler0, input.texcoord_0).rgb;\n  color += synthesizeCoefficient5 * textureSample(synthesizeTexture5, synthesizeSampler0, input.texcoord_0).rgb;\n\n  let rt0 = vec4f(color, 1.0);\n\n  return rt0;\n}\n\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// src/foundation/materials/contents/SynthesizeHdrMaterialContent.ts
var _SynthesizeHdrMaterialContent, SynthesizeHdrMaterialContent;
var init_SynthesizeHdrMaterialContent = __esm({
  "src/foundation/materials/contents/SynthesizeHdrMaterialContent.ts"() {
    "use strict";
    init_CameraComponent();
    init_ComponentRepository();
    init_ComponentType();
    init_CompositionType();
    init_ShaderSemantics();
    init_ShaderType();
    init_AbstractMaterialContent();
    init_VectorN();
    init_SynthesizeHDRTextureShader();
    init_SynthesizeHDRTextureShader2();
    init_SynthesizeHDRTextureShader3();
    init_SynthesizeHDRTextureShader4();
    init_DummyTextures();
    init_Sampler();
    init_TextureParameter();
    init_SystemState();
    init_ProcessApproach();
    _SynthesizeHdrMaterialContent = class _SynthesizeHdrMaterialContent extends AbstractMaterialContent {
      /**
      * This material node uses for the glare effect and so on.
      *
      * If the targetRegionTexture is not specified, the shader synthesizes all the
      * synthesizeTextures with all the pixels weighted by the synthesizeCoefficient.
      *
      * If the targetRegionTexture is specified, the shader synthesizes all the
      * synthesizeTextures with weights only for the non-white pixels of
      * targetRegionTexture (where the color is not (1.0, 1.0, 1.0, 1.0)). On the other
      * hand, in the white area, the output value is the product of the value of each
      * pixel in synthesizeTextures[0] and synthesizeCoefficient[0].
      *
      * @synthesizeTextures Textures to be synthesized. The shader supports up to six texture syntheses.
      * @targetRegionTexture Texture to specify the area where the texture will be synthesized
      */
      constructor(materialName, synthesizeTextures) {
        var _a40, _b, _c, _d, _e, _f;
        super(materialName, {});
        __publicField(this, "textureNumber");
        this.textureNumber = synthesizeTextures.length;
        const sampler = new Sampler({
          wrapS: TextureParameter.ClampToEdge,
          wrapT: TextureParameter.ClampToEdge,
          minFilter: TextureParameter.Linear,
          magFilter: TextureParameter.Linear
        });
        sampler.create();
        const shaderSemanticsInfoArray = [
          {
            semantic: "synthesizeCoefficient",
            componentType: ComponentType.Float,
            compositionType: CompositionType.ScalarArray,
            arrayLength: 6,
            stage: ShaderType.PixelShader,
            initialValue: new VectorN(new Float32Array(6)),
            min: 0,
            max: 1,
            needUniformInDataTextureMode: true
          },
          {
            semantic: "synthesizeTexture0",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Texture2D,
            stage: ShaderType.PixelShader,
            initialValue: [
              0,
              (_a40 = synthesizeTextures[0]) != null ? _a40 : dummyBlackTexture,
              sampler
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "synthesizeTexture1",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Texture2D,
            stage: ShaderType.PixelShader,
            initialValue: [
              1,
              (_b = synthesizeTextures[1]) != null ? _b : dummyBlackTexture,
              sampler
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "synthesizeTexture2",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Texture2D,
            stage: ShaderType.PixelShader,
            initialValue: [
              2,
              (_c = synthesizeTextures[2]) != null ? _c : dummyBlackTexture,
              sampler
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "synthesizeTexture3",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Texture2D,
            stage: ShaderType.PixelShader,
            initialValue: [
              3,
              (_d = synthesizeTextures[3]) != null ? _d : dummyBlackTexture,
              sampler
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "synthesizeTexture4",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Texture2D,
            stage: ShaderType.PixelShader,
            initialValue: [
              4,
              (_e = synthesizeTextures[4]) != null ? _e : dummyBlackTexture,
              sampler
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "synthesizeTexture5",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Texture2D,
            stage: ShaderType.PixelShader,
            initialValue: [
              5,
              (_f = synthesizeTextures[5]) != null ? _f : dummyBlackTexture,
              sampler
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          }
        ];
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          this.__vertexShaderityObject = SynthesizeHDRTextureShader_default3;
          this.__pixelShaderityObject = SynthesizeHDRTextureShader_default4;
        } else {
          this.__vertexShaderityObject = SynthesizeHDRTextureShader_default;
          this.__pixelShaderityObject = SynthesizeHDRTextureShader_default2;
        }
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
      }
      _setInternalSettingParametersToGpuWebGL({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
          this.setWorldMatrix(shaderProgram, args.worldMatrix);
          let cameraComponent = args.renderPass.cameraComponent;
          if (cameraComponent == null) {
            cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
          }
          if (cameraComponent) {
            this.setViewInfo(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
            this.setProjection(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          }
        }
        shaderProgram._gl.uniform1fv(shaderProgram.synthesizeCoefficient, material.getParameter("synthesizeCoefficient")._v);
      }
      get synthesizeTextureNumber() {
        return this.textureNumber;
      }
    };
    __name(_SynthesizeHdrMaterialContent, "SynthesizeHdrMaterialContent");
    __publicField(_SynthesizeHdrMaterialContent, "SynthesizeCoefficient", new ShaderSemanticsClass({
      str: "synthesizeCoefficient"
    }));
    __publicField(_SynthesizeHdrMaterialContent, "TargetRegionTexture", new ShaderSemanticsClass({
      str: "targetRegionTexture"
    }));
    __publicField(_SynthesizeHdrMaterialContent, "SynthesizeTexture0", new ShaderSemanticsClass({
      str: "synthesizeTexture0"
    }));
    __publicField(_SynthesizeHdrMaterialContent, "SynthesizeTexture1", new ShaderSemanticsClass({
      str: "synthesizeTexture1"
    }));
    __publicField(_SynthesizeHdrMaterialContent, "SynthesizeTexture2", new ShaderSemanticsClass({
      str: "synthesizeTexture2"
    }));
    __publicField(_SynthesizeHdrMaterialContent, "SynthesizeTexture3", new ShaderSemanticsClass({
      str: "synthesizeTexture3"
    }));
    __publicField(_SynthesizeHdrMaterialContent, "SynthesizeTexture4", new ShaderSemanticsClass({
      str: "synthesizeTexture4"
    }));
    __publicField(_SynthesizeHdrMaterialContent, "SynthesizeTexture5", new ShaderSemanticsClass({
      str: "synthesizeTexture5"
    }));
    SynthesizeHdrMaterialContent = _SynthesizeHdrMaterialContent;
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ColorGradingUsingLUTsShader/ColorGradingUsingLUTsShader.vert
var ColorGradingUsingLUTsShader_default;
var init_ColorGradingUsingLUTsShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ColorGradingUsingLUTsShader/ColorGradingUsingLUTsShader.vert"() {
    ColorGradingUsingLUTsShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord;\nin vec3 a_position;\n\nout vec2 v_texcoord;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\nmat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\nmat4 viewMatrix = get_viewMatrix(cameraSID, 0);\nmat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\ngl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4(a_position, 1.0);\n\n\n  v_texcoord = a_texcoord;\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ColorGradingUsingLUTsShader/ColorGradingUsingLUTsShader.frag
var ColorGradingUsingLUTsShader_default2;
var init_ColorGradingUsingLUTsShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ColorGradingUsingLUTsShader/ColorGradingUsingLUTsShader.frag"() {
    ColorGradingUsingLUTsShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\nin vec2 v_texcoord;\n\n/* shaderity: @{renderTargetBegin} */\n\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  vec4 textureColor = texture(u_baseColorTexture, v_texcoord);\n\n  float r = textureColor.r;\n  float g = textureColor.g;\n  float b = textureColor.b;\n  float r16 = r * 15.0;\n  float g16 = g * 15.0;\n  float b16 = b * 15.0;\n  float rInt = floor(r16);\n  float gInt = floor(g16);\n  float bInt = floor(b16);\n\n  float rRate, gRate, bRate;\n  float rIntAdjust, gIntAdjust, bIntAdjust;\n\n  vec3 newColor = vec3(0.0);\n  for(int i=0; i<8; i++){\n    rRate = 1.0 - fract(r16);\n    gRate = 1.0 - fract(g16);\n    bRate = 1.0 - fract(b16);\n    rIntAdjust = rInt;\n    gIntAdjust = gInt;\n    bIntAdjust = bInt;\n\n    if(fract(float(i) / 2.0) != 0.0){\n      rIntAdjust += 1.0;\n      rRate = 1.0 - rRate;\n    }\n    if(fract(float(i / 2) / 2.0) != 0.0){\n      gIntAdjust += 1.0;\n      gRate = 1.0 - gRate;\n    }\n    if(fract(float(i / 4) / 2.0) != 0.0){\n      bIntAdjust += 1.0;\n      bRate = 1.0 - bRate;\n    }\n\n    if( rRate * gRate * bRate != 0.0){\n      newColor += texture(u_lookupTableTexture, vec2(rIntAdjust / 256.0 + bIntAdjust / 16.0  + 1.0 / 512.0, gIntAdjust / 16.0 + 1.0 / 32.0)).rgb * rRate * gRate * bRate;\n    }\n  }\n\n  rt0 = vec4(newColor, 1.0);\n/* shaderity: @{renderTargetEnd} */\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// src/foundation/materials/contents/ColorGradingUsingLUTsMaterialContent.ts
var _ColorGradingUsingLUTsMaterialContent, ColorGradingUsingLUTsMaterialContent;
var init_ColorGradingUsingLUTsMaterialContent = __esm({
  "src/foundation/materials/contents/ColorGradingUsingLUTsMaterialContent.ts"() {
    "use strict";
    init_AbstractTexture();
    init_CameraComponent();
    init_CompositionType();
    init_ComponentRepository();
    init_ComponentType();
    init_ShaderSemantics();
    init_ShaderType();
    init_Texture();
    init_TextureParameter();
    init_AbstractMaterialContent();
    init_ColorGradingUsingLUTsShader();
    init_ColorGradingUsingLUTsShader2();
    init_Sampler();
    init_DummyTextures();
    init_Logger();
    _ColorGradingUsingLUTsMaterialContent = class _ColorGradingUsingLUTsMaterialContent extends AbstractMaterialContent {
      constructor(materialName, targetRenderPass, colorAttachmentsNumber, uri, texture) {
        super(materialName, {}, ColorGradingUsingLUTsShader_default, ColorGradingUsingLUTsShader_default2);
        let targetTexture;
        const framebuffer = targetRenderPass.getFramebuffer();
        if (framebuffer != null && framebuffer.colorAttachments[colorAttachmentsNumber] != null) {
          targetTexture = framebuffer.colorAttachments[colorAttachmentsNumber];
        } else {
          targetTexture = dummyBlackTexture;
          if (framebuffer != null) {
            Logger.warn("renderPass does not have framebuffer.colorAttachments[" + colorAttachmentsNumber + "]");
          } else {
            Logger.warn("renderPass does not have framebuffer");
          }
        }
        let lookupTableTexture;
        if (typeof uri === "string") {
          lookupTableTexture = new Texture2();
          (async function(uri2) {
            lookupTableTexture.generateTextureFromUri(uri2, {
              type: ComponentType.UnsignedByte
            });
            await lookupTableTexture.loadFromUrlLazy();
          })(uri);
        } else if (texture instanceof AbstractTexture) {
          lookupTableTexture = texture;
        } else {
          Logger.warn("no LUT texture is specified");
          lookupTableTexture = dummyBlackTexture;
        }
        const sampler = new Sampler({
          minFilter: TextureParameter.Nearest,
          magFilter: TextureParameter.Nearest,
          wrapS: TextureParameter.ClampToEdge,
          wrapT: TextureParameter.ClampToEdge,
          anisotropy: false
        });
        sampler.create();
        const shaderSemanticsInfoArray = [
          {
            semantic: "baseColorTexture",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Texture2D,
            stage: ShaderType.PixelShader,
            initialValue: [
              0,
              targetTexture
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "lookupTableTexture",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Texture2D,
            stage: ShaderType.PixelShader,
            initialValue: [
              1,
              lookupTableTexture,
              sampler
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          }
        ];
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
      }
      _setInternalSettingParametersToGpuWebGL({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
          this.setWorldMatrix(shaderProgram, args.worldMatrix);
        }
        let cameraComponent = args.renderPass.cameraComponent;
        if (cameraComponent == null) {
          cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
        }
        if (cameraComponent) {
          this.setViewInfo(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          this.setProjection(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
        }
      }
    };
    __name(_ColorGradingUsingLUTsMaterialContent, "ColorGradingUsingLUTsMaterialContent");
    __publicField(_ColorGradingUsingLUTsMaterialContent, "lookupTableTexture", new ShaderSemanticsClass({
      str: "lookupTableTexture"
    }));
    ColorGradingUsingLUTsMaterialContent = _ColorGradingUsingLUTsMaterialContent;
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/MatCapShader/MatCapShader.vert
var MatCapShader_default;
var init_MatCapShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/MatCapShader/MatCapShader.vert"() {
    MatCapShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec3 a_baryCentricCoord;\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_joint;\nin vec4 a_weight;\n\nout vec3 v_baryCentricCoord;\nout vec3 v_normal_inView;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n\n  bool isSkinning = false;\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n  v_normal_inView = vec3(viewMatrix * vec4(normalMatrix * a_normal, 0.0));\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n  v_baryCentricCoord = a_baryCentricCoord;\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/MatCapShader/MatCapShader.frag
var MatCapShader_default2;
var init_MatCapShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/MatCapShader/MatCapShader.frag"() {
    MatCapShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\nin vec3 v_baryCentricCoord;\nin vec3 v_normal_inView;\n\n/* shaderity: @{renderTargetBegin} */\n\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\nfloat edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {\n  vec3 d = fwidth(bary3);\n  vec3 x = bary3+vec3(1.0 - wireframeWidthInner)*d;\n  vec3 a3 = smoothstep(vec3(0.0), d, x);\n  float factor = min(min(a3.x, a3.y), a3.z);\n\n  return clamp((1.0 - factor), 0.0, 1.0);\n}\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  vec3 normal_inView = normalize(v_normal_inView);\n  normal_inView.y *= -1.0;\n  vec2 normalUVCordinate = normal_inView.xy * 0.5 + 0.5;\n  vec4 matCapColor = texture(u_matCapTexture, normalUVCordinate);\n  rt0 = matCapColor;\n\n  // Wireframe\n  float threshold = 0.001;\n  vec3 wireframe = get_wireframe(materialSID, 0);\n  float wireframeWidthInner = wireframe.z;\n  float wireframeWidthRelativeScale = 1.0;\n  if (wireframe.x > 0.5 && wireframe.y < 0.5) {\n    rt0.a = 0.0;\n  }\n  vec4 wireframeResult = rt0;\n  vec4 wireframeColor = vec4(0.2, 0.75, 0.0, 1.0);\n  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);\n  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);\n  // if r0.a is 0.0, it is wireframe not on shaded\n  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified);\n  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));\n\n  if (wireframe.x > 0.5) {\n    rt0 = wireframeResult;\n    if (wireframe.y < 0.5 && rt0.a == 0.0) {\n      discard;\n    }\n  }\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// src/foundation/materials/contents/MatCapMaterialContent.ts
var _MatCapMaterialContent, MatCapMaterialContent;
var init_MatCapMaterialContent = __esm({
  "src/foundation/materials/contents/MatCapMaterialContent.ts"() {
    "use strict";
    init_AbstractTexture();
    init_CameraComponent();
    init_ComponentRepository();
    init_ComponentType();
    init_CompositionType();
    init_Scalar();
    init_ShaderSemantics();
    init_ShaderType();
    init_Texture();
    init_Vector3();
    init_AbstractMaterialContent();
    init_MatCapShader();
    init_MatCapShader2();
    init_DummyTextures();
    init_Logger();
    _MatCapMaterialContent = class _MatCapMaterialContent extends AbstractMaterialContent {
      constructor(materialName, isSkinning, uri, texture, sampler) {
        super(materialName, {
          isSkinning
        }, MatCapShader_default, MatCapShader_default2);
        let matCapTexture;
        if (typeof uri === "string") {
          matCapTexture = new Texture2();
          (async function(uri2) {
            matCapTexture.generateTextureFromUri(uri2, {
              type: ComponentType.UnsignedByte
            });
            await matCapTexture.loadFromUrlLazy();
          })(uri);
        } else if (texture instanceof AbstractTexture) {
          matCapTexture = texture;
        } else {
          Logger.warn("no matcap texture");
          matCapTexture = dummyBlackTexture;
        }
        const shaderSemanticsInfoArray = [];
        shaderSemanticsInfoArray.push({
          semantic: "wireframe",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Vec3,
          stage: ShaderType.PixelShader,
          initialValue: Vector3.fromCopyArray([
            0,
            0,
            1
          ]),
          min: 0,
          max: 10
        });
        shaderSemanticsInfoArray.push({
          semantic: "pointSize",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.VertexShader,
          soloDatum: true,
          initialValue: Scalar2.fromCopyNumber(30),
          min: 0,
          max: 100
        }, {
          semantic: "pointDistanceAttenuation",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Vec3,
          stage: ShaderType.VertexShader,
          soloDatum: true,
          initialValue: Vector3.fromCopyArray([
            0,
            0.1,
            0.01
          ]),
          min: 0,
          max: 1
        });
        shaderSemanticsInfoArray.push({
          semantic: "matCapTexture",
          componentType: ComponentType.Int,
          compositionType: CompositionType.Texture2D,
          stage: ShaderType.PixelShader,
          initialValue: [
            0,
            matCapTexture,
            sampler
          ],
          min: 0,
          max: Number.MAX_SAFE_INTEGER
        });
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
      }
      _setInternalSettingParametersToGpuWebGL({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
          this.setWorldMatrix(shaderProgram, args.worldMatrix);
          this.setNormalMatrix(shaderProgram, args.normalMatrix);
          let cameraComponent = args.renderPass.cameraComponent;
          if (cameraComponent == null) {
            cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
          }
          this.setViewInfo(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          this.setProjection(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          const skeletalComponent = args.entity.tryToGetSkeletal();
          this.setSkinning(shaderProgram, args.setUniform, skeletalComponent);
        }
      }
    };
    __name(_MatCapMaterialContent, "MatCapMaterialContent");
    __publicField(_MatCapMaterialContent, "MatCapTexture", new ShaderSemanticsClass({
      str: "matCapTexture"
    }));
    MatCapMaterialContent = _MatCapMaterialContent;
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/VarianceShadowMapDecodeClassicShader/VarianceShadowMapDecodeClassicShader.vert
var VarianceShadowMapDecodeClassicShader_default;
var init_VarianceShadowMapDecodeClassicShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/VarianceShadowMapDecodeClassicShader/VarianceShadowMapDecodeClassicShader.vert"() {
    VarianceShadowMapDecodeClassicShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout vec4 v_texcoord_1;\nout vec4 v_projPosition_from_light;\nout vec3 v_baryCentricCoord;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n\n  bool isSkinning = false;\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n  v_color = a_color;\n  v_texcoord_0 = a_texcoord_0;\n\n  // Shadow mapping\n  mat4 lightViewProjectionMatrix = get_lightViewProjectionMatrix(materialSID, 0);\n  v_projPosition_from_light = lightViewProjectionMatrix * v_position_inWorld;\n\n  // Following tMatrix is based on https://wgld.org/d/webgl/w051.html\n  mat4 tMatrix = mat4(\n    0.5, 0.0, 0.0, 0.0,\n    0.0, 0.5, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.5, 0.5, 0.0, 1.0\n  );\n  v_texcoord_1 = tMatrix * v_projPosition_from_light;\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/VarianceShadowMapDecodeClassicShader/VarianceShadowMapDecodeClassicShader.frag
var VarianceShadowMapDecodeClassicShader_default2;
var init_VarianceShadowMapDecodeClassicShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/VarianceShadowMapDecodeClassicShader/VarianceShadowMapDecodeClassicShader.frag"() {
    VarianceShadowMapDecodeClassicShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin vec2 v_texcoord_0;\nin vec4 v_texcoord_1;\nin vec4 v_projPosition_from_light;\nin vec3 v_baryCentricCoord;\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nstruct Light {\n  int type; // 0 = directional, 1 = point, 2 = spot\n  vec3 position;\n  vec3 intensity;\n  vec3 attenuatedIntensity;\n  vec3 directionOfLightObject;\n  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)\n  vec3 pointToLight; // not normalized\n  float spotAngleScale;\n  float spotAngleOffset;\n  float effectiveRange;\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(Light light)\n{\n  float distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(Light light)\n{\n\n  float cd = dot(light.directionOfLightObject, light.direction);\n  float angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nvoid getLightAttenuated(Light light) {\n  light.attenuatedIntensity = light.intensity;\n  // if (light.type == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.type == 1)\n  {\n    light.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.type == 2)\n  {\n    light.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n}\n\nLight getLight(int lightIdx, vec3 v_position_inWorld) {\n  vec3 lightPosition = get_lightPosition(0.0, lightIdx);\n  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);\n  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);\n  vec4 lightProperty = get_lightProperty(0.0, lightIdx);\n  Light light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  float lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3(0.0);\n    light.type = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.type = 1;\n  } else { // is Directional Light\n    light.type = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.type = 2;\n  }\n\n  const float M_PI = 3.141592653589793;\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  getLightAttenuated(light);\n\n  return light;\n}\n\n\nfloat edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {\n  vec3 d = fwidth(bary3);\n  vec3 x = bary3+vec3(1.0 - wireframeWidthInner)*d;\n  vec3 a3 = smoothstep(vec3(0.0), d, x);\n  float factor = min(min(a3.x, a3.y), a3.z);\n\n  return clamp((1.0 - factor), 0.0, 1.0);\n}\n\nfloat decodeRGBAToDepth(vec4 RGBA){\n  const float rMask = 1.0;\n  const float gMask = 1.0 / 255.0;\n  const float bMask = 1.0 / (255.0 * 255.0);\n  const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n  float depth = dot(RGBA, vec4(rMask, gMask, bMask, aMask));\n  return depth;\n}\n\nfloat linstep(float min,float max,float v){\n  return clamp((v-min)/(max-min),0.0,1.0);\n}\n\nfloat reduceLightBleeding(float p_max, float parameter){\n  return linstep(parameter,1.0,p_max);\n}\n\nfloat chebyshevUpperBound(float materialSID){\n  float textureDepth = decodeRGBAToDepth(textureProj(u_depthTexture, v_texcoord_1));\n  float textureSquareDepth = decodeRGBAToDepth(textureProj(u_squareDepthTexture, v_texcoord_1));\n  if(textureDepth == 1.0 || textureSquareDepth == 1.0){\n    return 1.0;\n  }\n\n  float nonShadowProb = 1.0;\n\n  if(v_projPosition_from_light.w > 0.0){\n    float measureDepth;\n    bool isPointLight = get_isPointLight(materialSID, 0);\n    if(isPointLight){\n      float zNear = get_zNearInner(materialSID, 0);\n      float zFar = get_zFarInner(materialSID, 0);\n      float normalizationCoefficient = 1.0 / (zFar - zNear);\n      measureDepth = normalizationCoefficient * length(v_projPosition_from_light);\n    }else{\n      measureDepth = (v_projPosition_from_light / v_projPosition_from_light.w).z;\n    }\n\n    float depthAdjustment = get_depthAdjustment(materialSID, 0);\n    measureDepth += depthAdjustment;\n\n    float textureDepthAdjustment = get_textureDepthAdjustment(materialSID, 0);\n    textureDepth += textureDepthAdjustment;\n\n    float d = measureDepth - textureDepth;\n    if(d < 0.0) return 1.0;\n\n    float variance = textureSquareDepth - textureDepth * textureDepth;\n    float minimumVariance = get_minimumVariance(materialSID, 0);\n    variance = max(variance, minimumVariance);\n\n    nonShadowProb = variance / (variance + d * d);\n\n\n    float lightBleedingParameter = get_lightBleedingParameter(materialSID, 0);\n    nonShadowProb = reduceLightBleeding(nonShadowProb, lightBleedingParameter);\n  }\n  return nonShadowProb;\n}\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n\n  // diffuseColor\n  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n  float alpha = 1.0;\n\n  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);\n  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {\n    diffuseColor = v_color * diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (v_color == diffuseColor) {\n    diffuseColor = diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (diffuseColorFactor.rgb == diffuseColor) {\n    diffuseColor = v_color;\n  } else {\n    diffuseColor = vec3(1.0, 1.0, 1.0);\n  }\n\n  // diffuseColorTexture\n  vec4 textureColor = texture(u_diffuseColorTexture, v_texcoord_0);\n  if (textureColor.r > 0.05) {\n    diffuseColor *= textureColor.rgb;\n    alpha *= textureColor.a;\n  }\n\n  // shadow mapping\n  vec4 shadowColor = get_shadowColor(materialSID, 0);\n\n  float nonShadowProb = chebyshevUpperBound(materialSID);\n  diffuseColor = nonShadowProb * diffuseColor + (1.0 - nonShadowProb) * shadowColor.rgb;\n  alpha = nonShadowProb * alpha + (1.0 - nonShadowProb) * shadowColor.a;\n\n  // Lighting\n  vec3 shadingColor = vec3(0.0, 0.0, 0.0);\n\n  int shadingModel = get_shadingModel(materialSID, 0);\n  if (shadingModel > 0) {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    int lightNumber = get_lightNumber(materialSID, 0);\n    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */ ; i++) {\n      if (i >= lightNumber) {\n        break;\n      }\n\n      // Light\n      Light light = getLight(i, v_position_inWorld.xyz);\n\n      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, light.direction)) * light.attenuatedIntensity;\n\n      vec3 viewPosition = get_viewPosition(materialSID, 0);\n      float shininess = get_shininess(materialSID, 0);\n      if (shadingModel == 2) {// BLINN\n        // ViewDirection\n        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n        vec3 halfVector = normalize(light.direction + viewDirection);\n        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), shininess);\n      } else if (shadingModel == 3) { // PHONG\n        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n        vec3 R = reflect(light.direction, normal_inWorld);\n        specular += pow(max(0.0, dot(R, viewDirection)), shininess);\n      }\n\n    }\n\n    shadingColor = diffuse + specular;\n  } else {\n    shadingColor = diffuseColor;\n  }\n\n  rt0 = vec4(shadingColor, alpha);\n\n  // Wireframe\n  float threshold = 0.001;\n  vec3 wireframe = get_wireframe(materialSID, 0);\n  float wireframeWidthInner = wireframe.z;\n  float wireframeWidthRelativeScale = 1.0;\n  if (wireframe.x > 0.5 && wireframe.y < 0.5) {\n    rt0.a = 0.0;\n  }\n  vec4 wireframeResult = rt0;\n  vec4 wireframeColor = vec4(0.2, 0.75, 0.0, 1.0);\n  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);\n  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);\n  // if r0.a is 0.0, it is wireframe not on shaded\n  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified);\n  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));\n\n  if (wireframe.x > 0.5) {\n    rt0 = wireframeResult;\n    if (wireframe.y < 0.5 && rt0.a == 0.0) {\n      discard;\n    }\n  }\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// src/foundation/materials/contents/VarianceShadowMapDecodeClassicMaterialContent.ts
var _VarianceShadowMapDecodeClassicMaterialContent, VarianceShadowMapDecodeClassicMaterialContent;
var init_VarianceShadowMapDecodeClassicMaterialContent = __esm({
  "src/foundation/materials/contents/VarianceShadowMapDecodeClassicMaterialContent.ts"() {
    "use strict";
    init_ShaderSemantics();
    init_AbstractMaterialContent();
    init_CompositionType();
    init_ComponentType();
    init_Vector4();
    init_Vector3();
    init_ShadingModel();
    init_ShaderType();
    init_ComponentRepository();
    init_CameraComponent();
    init_VectorN();
    init_Scalar();
    init_Config();
    init_CGAPIResourceRepository();
    init_MutableMatrix44();
    init_VarianceShadowMapDecodeClassicShader();
    init_VarianceShadowMapDecodeClassicShader2();
    init_DummyTextures();
    init_Logger();
    _VarianceShadowMapDecodeClassicMaterialContent = class _VarianceShadowMapDecodeClassicMaterialContent extends AbstractMaterialContent {
      /**
      * The constructor of the VarianceShadowMapDecodeClassicMaterialContent
      * @param isMorphing True if the morphing is to be applied
      * @param isSkinning True if the skeleton is to be applied
      * @param isLighting True if the lighting is to be applied. When isLighting is false, the Shader draws the original color of the material, except for the shadow area.
      * @param isDebugging True if the shader displays the DebugColorFactor color in areas outside of the depth map.
      *
      *
      *
      *
      * @param colorAttachmentsNumber The index of colorAttachment in a framebuffer. The colorAttachment must have depth information drawn by the DepthEncodeMaterialContent.
      * @param encodedDepthRenderPass The render pass where the depth information from the DepthEncodeMaterialContent is drawn to the frame buffer
      */
      constructor(materialName, { isMorphing, isSkinning, isLighting, isDebugging, colorAttachmentsNumberDepth, colorAttachmentsNumberSquareDepth, depthCameraComponent }, encodedDepthRenderPasses) {
        super(materialName, {
          isMorphing,
          isSkinning,
          isLighting
        }, VarianceShadowMapDecodeClassicShader_default, VarianceShadowMapDecodeClassicShader_default2);
        __publicField(this, "__depthCameraComponent");
        if (encodedDepthRenderPasses.length !== 2) {
          Logger.error("invalid length of renderPasses");
        }
        if (depthCameraComponent == null) {
          Logger.warn("need to set depth camera component");
        } else {
          this.__depthCameraComponent = depthCameraComponent;
        }
        for (const encodedDepthRenderPass of encodedDepthRenderPasses) {
          const viewport = encodedDepthRenderPass.getViewport();
          viewport.setComponents(1, 1, viewport.z - 1, viewport.w - 1);
          encodedDepthRenderPass.setViewport(viewport);
        }
        let depthTexture;
        const depthFramebuffer = encodedDepthRenderPasses[0].getFramebuffer();
        if (depthFramebuffer) {
          depthTexture = depthFramebuffer.colorAttachments[colorAttachmentsNumberDepth];
        } else {
          Logger.warn("renderPass of depth does not have framebuffer");
          depthTexture = dummyBlackTexture;
        }
        let squareDepthTexture;
        const squareDepthFramebuffer = encodedDepthRenderPasses[1].getFramebuffer();
        if (squareDepthFramebuffer) {
          squareDepthTexture = squareDepthFramebuffer.colorAttachments[colorAttachmentsNumberSquareDepth];
        } else {
          Logger.warn("renderPass of square depth does not have framebuffer");
          squareDepthTexture = dummyBlackTexture;
        }
        const shaderSemanticsInfoArray = [
          {
            semantic: "lightViewProjectionMatrix",
            compositionType: CompositionType.Mat4,
            componentType: ComponentType.Float,
            stage: ShaderType.VertexShader,
            isInternalSetting: true,
            initialValue: MutableMatrix44.zero(),
            min: -Number.MAX_VALUE,
            max: Number.MAX_VALUE
          },
          {
            semantic: "shadingModel",
            compositionType: CompositionType.Scalar,
            componentType: ComponentType.Int,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(ShadingModel2.Constant.index),
            min: 0,
            max: 3
          },
          {
            semantic: "shininess",
            compositionType: CompositionType.Scalar,
            componentType: ComponentType.Float,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(5),
            min: 0,
            max: Number.MAX_VALUE
          },
          {
            semantic: "allowableDepthError",
            compositionType: CompositionType.Scalar,
            componentType: ComponentType.Float,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(1e-4),
            min: 0,
            max: 1
          },
          {
            semantic: "shadowColor",
            compositionType: CompositionType.Vec4,
            componentType: ComponentType.Float,
            stage: ShaderType.PixelShader,
            initialValue: Vector4.fromCopyArray([
              0.5,
              0.5,
              0.5,
              1
            ]),
            min: 0,
            max: 1
          },
          {
            semantic: "diffuseColorFactor",
            compositionType: CompositionType.Vec4,
            componentType: ComponentType.Float,
            stage: ShaderType.PixelShader,
            initialValue: Vector4.fromCopyArray([
              1,
              1,
              1,
              1
            ]),
            min: 0,
            max: 2
          },
          {
            semantic: "zNearInner",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            isInternalSetting: true,
            initialValue: Scalar2.fromCopyNumber(0.1),
            min: 1e-4,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "zFarInner",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            isInternalSetting: true,
            initialValue: Scalar2.fromCopyNumber(1e4),
            min: 1e-4,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "isPointLight",
            componentType: ComponentType.Bool,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(1),
            min: 0,
            max: 1
          },
          {
            semantic: "wireframe",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Vec3,
            stage: ShaderType.PixelShader,
            initialValue: Vector3.fromCopyArray([
              0,
              0,
              1
            ]),
            min: 0,
            max: 10
          },
          {
            semantic: "depthAdjustment",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(0),
            min: 0,
            max: 1
          },
          {
            semantic: "lightBleedingParameter",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(0),
            min: 0,
            max: 1
          },
          {
            semantic: "minimumVariance",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(1e-7),
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "textureDepthAdjustment",
            componentType: ComponentType.Float,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.PixelShader,
            initialValue: Scalar2.fromCopyNumber(0),
            min: 0,
            max: 1
          },
          {
            semantic: "normalTexture",
            compositionType: CompositionType.Texture2D,
            componentType: ComponentType.Int,
            stage: ShaderType.PixelShader,
            initialValue: [
              0,
              dummyBlueTexture
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "diffuseColorTexture",
            compositionType: CompositionType.Texture2D,
            componentType: ComponentType.Int,
            stage: ShaderType.PixelShader,
            initialValue: [
              1,
              dummyWhiteTexture
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "depthTexture",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Texture2D,
            stage: ShaderType.PixelShader,
            initialValue: [
              2,
              depthTexture
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          },
          {
            semantic: "squareDepthTexture",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Texture2D,
            stage: ShaderType.PixelShader,
            initialValue: [
              3,
              squareDepthTexture
            ],
            min: 0,
            max: Number.MAX_SAFE_INTEGER
          }
        ];
        shaderSemanticsInfoArray.push({
          semantic: "pointSize",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Scalar,
          stage: ShaderType.VertexShader,
          soloDatum: true,
          initialValue: Scalar2.fromCopyNumber(30),
          min: 0,
          max: 100
        }, {
          semantic: "pointDistanceAttenuation",
          componentType: ComponentType.Float,
          compositionType: CompositionType.Vec3,
          stage: ShaderType.VertexShader,
          soloDatum: true,
          initialValue: Vector3.fromCopyArray([
            0,
            0.1,
            0.01
          ]),
          min: 0,
          max: 1
        });
        if (isMorphing) {
          shaderSemanticsInfoArray.push({
            semantic: "morphTargetNumber",
            componentType: ComponentType.Int,
            compositionType: CompositionType.Scalar,
            stage: ShaderType.VertexShader,
            isInternalSetting: true,
            soloDatum: true,
            initialValue: Scalar2.fromCopyNumber(0),
            min: 0,
            max: Config.maxVertexMorphNumberInShader,
            needUniformInDataTextureMode: true
          }, {
            semantic: "dataTextureMorphOffsetPosition",
            componentType: ComponentType.Int,
            compositionType: CompositionType.ScalarArray,
            arrayLength: Config.maxVertexMorphNumberInShader,
            stage: ShaderType.VertexShader,
            isInternalSetting: true,
            soloDatum: true,
            initialValue: new VectorN(new Int32Array(Config.maxVertexMorphNumberInShader)),
            min: -Number.MAX_VALUE,
            max: Number.MAX_VALUE,
            needUniformInDataTextureMode: true
          }, {
            semantic: "morphWeights",
            componentType: ComponentType.Float,
            compositionType: CompositionType.ScalarArray,
            arrayLength: Config.maxVertexMorphNumberInShader,
            stage: ShaderType.VertexShader,
            isInternalSetting: true,
            soloDatum: true,
            initialValue: new VectorN(new Float32Array(Config.maxVertexMorphNumberInShader)),
            min: -Number.MAX_VALUE,
            max: Number.MAX_VALUE,
            needUniformInDataTextureMode: true
          });
        }
        if (isDebugging) {
          shaderSemanticsInfoArray.push({
            semantic: "debugColorFactor",
            compositionType: CompositionType.Vec4,
            componentType: ComponentType.Float,
            stage: ShaderType.PixelShader,
            initialValue: Vector4.fromCopyArray([
              1,
              0,
              0,
              1
            ]),
            min: 0,
            max: 2
          });
        }
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
      }
      _setInternalSettingParametersToGpuWebGL({ material, shaderProgram, firstTime, args }) {
        var _a40;
        let cameraComponent = args.renderPass.cameraComponent;
        if (cameraComponent == null) {
          cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
        }
        const encodedDepthCameraComponent = (_a40 = this.__depthCameraComponent) != null ? _a40 : args.renderPass.cameraComponent;
        if (args.setUniform) {
          this.setWorldMatrix(shaderProgram, args.worldMatrix);
          this.setNormalMatrix(shaderProgram, args.normalMatrix);
          this.setViewInfo(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          this.setProjection(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          if (_VarianceShadowMapDecodeClassicMaterialContent.__lastZNear !== encodedDepthCameraComponent.zNearInner) {
            shaderProgram._gl.uniform1f(shaderProgram.zNearInner, encodedDepthCameraComponent.zNearInner);
            _VarianceShadowMapDecodeClassicMaterialContent.__lastZNear = encodedDepthCameraComponent.zNearInner;
          }
          if (_VarianceShadowMapDecodeClassicMaterialContent.__lastZFar !== encodedDepthCameraComponent.zFarInner) {
            shaderProgram._gl.uniform1f(shaderProgram.zFarInner, encodedDepthCameraComponent.zFarInner);
            _VarianceShadowMapDecodeClassicMaterialContent.__lastZFar = encodedDepthCameraComponent.zFarInner;
          }
          const __webglResourceRepository2 = CGAPIResourceRepository.getWebGLResourceRepository();
          __webglResourceRepository2.setUniformValue(shaderProgram, ShaderSemantics.LightViewProjectionMatrix.str, true, encodedDepthCameraComponent.viewProjectionMatrix);
        } else {
          material.setParameter("zNearInner", encodedDepthCameraComponent.zNearInner);
          material.setParameter("zFarInner", encodedDepthCameraComponent.zFarInner);
          material.setParameter("lightViewProjectionMatrix", encodedDepthCameraComponent.viewProjectionMatrix);
        }
        const skeletalComponent = args.entity.tryToGetSkeletal();
        this.setSkinning(shaderProgram, args.setUniform, skeletalComponent);
        this.setLightsInfo(shaderProgram, args.lightComponents, material, args.setUniform);
        const blendShapeComponent = args.entity.tryToGetBlendShape();
        this.setMorphInfo(shaderProgram, args.entity.getMesh(), args.primitive, blendShapeComponent);
        const __webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        __webglResourceRepository.setUniformValue(shaderProgram, ShaderSemantics.LightViewProjectionMatrix.str, true, encodedDepthCameraComponent.viewProjectionMatrix);
      }
      set depthCameraComponent(depthCameraComponent) {
        this.__depthCameraComponent = depthCameraComponent;
      }
    };
    __name(_VarianceShadowMapDecodeClassicMaterialContent, "VarianceShadowMapDecodeClassicMaterialContent");
    __publicField(_VarianceShadowMapDecodeClassicMaterialContent, "IsPointLight", new ShaderSemanticsClass({
      str: "isPointLight"
    }));
    __publicField(_VarianceShadowMapDecodeClassicMaterialContent, "DepthTexture", new ShaderSemanticsClass({
      str: "depthTexture"
    }));
    __publicField(_VarianceShadowMapDecodeClassicMaterialContent, "SquareDepthTexture", new ShaderSemanticsClass({
      str: "squareDepthTexture"
    }));
    __publicField(_VarianceShadowMapDecodeClassicMaterialContent, "DepthAdjustment", new ShaderSemanticsClass({
      str: "depthAdjustment"
    }));
    __publicField(_VarianceShadowMapDecodeClassicMaterialContent, "TextureDepthAdjustment", new ShaderSemanticsClass({
      str: "textureDepthAdjustment"
    }));
    __publicField(_VarianceShadowMapDecodeClassicMaterialContent, "MinimumVariance", new ShaderSemanticsClass({
      str: "minimumVariance"
    }));
    __publicField(_VarianceShadowMapDecodeClassicMaterialContent, "LightBleedingParameter", new ShaderSemanticsClass({
      str: "lightBleedingParameter"
    }));
    __publicField(_VarianceShadowMapDecodeClassicMaterialContent, "ShadowColor", new ShaderSemanticsClass({
      str: "shadowColor"
    }));
    __publicField(_VarianceShadowMapDecodeClassicMaterialContent, "AllowableDepthError", new ShaderSemanticsClass({
      str: "allowableDepthError"
    }));
    __publicField(_VarianceShadowMapDecodeClassicMaterialContent, "zNearInner", new ShaderSemanticsClass({
      str: "zNearInner"
    }));
    __publicField(_VarianceShadowMapDecodeClassicMaterialContent, "zFarInner", new ShaderSemanticsClass({
      str: "zFarInner"
    }));
    __publicField(_VarianceShadowMapDecodeClassicMaterialContent, "DebugColorFactor", new ShaderSemanticsClass({
      str: "debugColorFactor"
    }));
    __publicField(_VarianceShadowMapDecodeClassicMaterialContent, "__lastZNear", 0);
    __publicField(_VarianceShadowMapDecodeClassicMaterialContent, "__lastZFar", 0);
    VarianceShadowMapDecodeClassicMaterialContent = _VarianceShadowMapDecodeClassicMaterialContent;
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ClassicSingleShader/ClassicSingleShader.vert
var ClassicSingleShader_default;
var init_ClassicSingleShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ClassicSingleShader/ClassicSingleShader.vert"() {
    ClassicSingleShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\n#ifdef WEBGL2_MULTI_VIEW\n  layout(num_views=2) in;\n#endif\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout vec3 v_baryCentricCoord;\nout vec4 v_shadowCoord;\n\nuniform float u_pointSize; // initialValue=30\nuniform vec3 u_pointDistanceAttenuation; // initialValue=(0,0.1,0.01)\n\n// BiasMatrix * LightProjectionMatrix * LightViewMatrix, See: http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/#basic-shader\nuniform mat4 u_depthBiasPV; // initialValue=(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  bool isBillboard = get_isBillboard(a_instanceInfo.x);\n\n  // Skeletal\n  processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    isBillboard,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n\n  v_color = a_color;\n  v_normal_inWorld = normalMatrix * a_normal;\n  v_texcoord_0 = a_texcoord_0;\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n\n  bool visibility = get_isVisible(a_instanceInfo.x);\n  if (!visibility)\n  {\n    gl_Position = vec4(0.0);\n  }\n\n  v_shadowCoord = get_depthBiasPV(materialSID, 0) * v_position_inWorld;\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ClassicSingleShader/ClassicSingleShader.frag
var ClassicSingleShader_default2;
var init_ClassicSingleShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ClassicSingleShader/ClassicSingleShader.frag"() {
    ClassicSingleShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin vec2 v_texcoord_0;\nin vec3 v_baryCentricCoord;\nin vec4 v_shadowCoord;\n\nuniform int u_shadingModel; // initialValue=0\nuniform float u_alphaCutoff; // initialValue=0.01\nuniform float u_shininess; // initialValue=5\nuniform vec4 u_diffuseColorFactor; // initialValue=(1,1,1,1)\nuniform sampler2D u_diffuseColorTexture; // initialValue=(0,white)\nuniform sampler2D u_normalTexture; // initialValue=(1,blue)\nuniform vec4 u_diffuseColorTextureTransform; // initialValue=(1,1,0,0)\nuniform float u_diffuseColorTextureRotation; // initialValue=0\nuniform sampler2DShadow u_depthTexture; // initialValue=(2,white)\n\n/* shaderity: @{renderTargetBegin} */\n\n// #pragma shaderity: require(../common/deliot2019SeamlessTexture.glsl)\n// uniform sampler2D u_tInvTexture; // initialValue=(1,white)\n// uniform vec3 u_colorSpaceOrigin;\n// uniform vec3 u_colorSpaceVector1;\n// uniform vec3 u_colorSpaceVector2;\n// uniform vec3 u_colorSpaceVector3;\n// uniform vec4 u_scaleTranslate;\n\n\nvec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {\n  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  mat3 rotationMat = mat3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  mat3 matrix = translationMat * rotationMat * scaleMat;\n  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n\n/* shaderity: @{getters} */\n\nstruct Light {\n  int type; // 0 = directional, 1 = point, 2 = spot\n  vec3 position;\n  vec3 intensity;\n  vec3 attenuatedIntensity;\n  vec3 directionOfLightObject;\n  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)\n  vec3 pointToLight; // not normalized\n  float spotAngleScale;\n  float spotAngleOffset;\n  float effectiveRange;\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(Light light)\n{\n  float distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(Light light)\n{\n\n  float cd = dot(light.directionOfLightObject, light.direction);\n  float angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nvoid getLightAttenuated(Light light) {\n  light.attenuatedIntensity = light.intensity;\n  // if (light.type == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.type == 1)\n  {\n    light.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.type == 2)\n  {\n    light.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n}\n\nLight getLight(int lightIdx, vec3 v_position_inWorld) {\n  vec3 lightPosition = get_lightPosition(0.0, lightIdx);\n  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);\n  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);\n  vec4 lightProperty = get_lightProperty(0.0, lightIdx);\n  Light light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  float lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3(0.0);\n    light.type = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.type = 1;\n  } else { // is Directional Light\n    light.type = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.type = 2;\n  }\n\n  const float M_PI = 3.141592653589793;\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  getLightAttenuated(light);\n\n  return light;\n}\n\n\nvoid main ()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n\n  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);\n\n\n  // diffuseColor (Considered to be premultiplied alpha)\n  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n  float alpha = 1.0;\n  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {\n    diffuseColor = v_color * diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (v_color == diffuseColor) {\n    diffuseColor = diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (diffuseColorFactor.rgb == diffuseColor) {\n    diffuseColor = v_color;\n  } else {\n    diffuseColor = vec3(1.0, 1.0, 1.0);\n  }\n\n  // diffuseColorTexture (Considered to be premultiplied alpha)\n  vec4 diffuseColorTextureTransform = get_diffuseColorTextureTransform(materialSID, 0);\n  float diffuseColorTextureRotation = get_diffuseColorTextureRotation(materialSID, 0);\n  vec2 diffuseColorTexUv = uvTransform(diffuseColorTextureTransform.xy, diffuseColorTextureTransform.zw, diffuseColorTextureRotation, v_texcoord_0);\n  vec4 textureColor = texture(u_diffuseColorTexture, diffuseColorTexUv);\n  diffuseColor *= textureColor.rgb;\n  alpha *= textureColor.a;\n\n#ifdef RN_IS_ALPHA_MODE_MASK\n  float alphaCutoff = get_alphaCutoff(materialSID, 0);\n  if (alpha < alphaCutoff) {\n    discard;\n  }\n#endif\n\n\n  // Lighting\n  vec3 shadingColor = vec3(0.0, 0.0, 0.0);\n#ifdef RN_IS_LIGHTING\n  int shadingModel = get_shadingModel(materialSID, 0);\n  if (shadingModel > 0) {\n\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < /* shaderity: @{Config.maxLightNumberInShader} */ ; i++) {\n      if (i >= lightNumber) {\n        break;\n      }\n\n      // Light\n      Light light = getLight(i, v_position_inWorld.xyz);\n\n      // Diffuse\n      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, light.direction)) * light.attenuatedIntensity;\n\n      float shininess = get_shininess(materialSID, 0);\n      int shadingModel = get_shadingModel(materialSID, 0);\n\n      vec3 viewPosition = get_viewPosition(cameraSID, 0);\n\n      // Specular\n      if (shadingModel == 2) {// BLINN\n        // ViewDirection\n        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n        vec3 halfVector = normalize(light.direction + viewDirection);\n        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), shininess);\n      } else if (shadingModel == 3) { // PHONG\n        vec3 viewDirection = normalize(viewPosition - v_position_inWorld.xyz);\n        vec3 R = reflect(light.direction, normal_inWorld);\n        specular += pow(max(0.0, dot(R, viewDirection)), shininess);\n      }\n\n    }\n\n    shadingColor = diffuse + specular;\n  } else {\n    shadingColor = diffuseColor;\n  }\n#else\n  shadingColor = diffuseColor;\n#endif\n\n  // Shadow\n#ifdef RN_USE_SHADOW_MAPPING\n  float visibility = 1.0;\n  float bias = 0.001;\n\n  // Non PCF\n  // if ( textureProj( u_depthTexture, v_shadowCoord ).r  < (v_shadowCoord.z - bias) / v_shadowCoord.w ) {\n  //   visibility = 0.5;\n  // }\n  // shadingColor *= visibility;\n\n  // Hardware PCF\n  vec4 shadowCoord = v_shadowCoord;\n  shadowCoord.z -= bias;\n  shadingColor *= textureProj( u_depthTexture, shadowCoord ) * 0.5 + 0.5;\n\n  // shadingColor.rgb = texture( u_depthTexture, v_shadowCoord.xy ).rrr;\n  // shadingColor.rgb = vec3(v_shadowCoord.xy, 0.0);\n  // shadingColor.rgb = vec3(diffuseColorTexUv, 0.0);\n  // shadingColor.rgb = vec3(texture( u_depthTexture, diffuseColorTexUv).rrr);\n  // shadingColor.rgb = texture( u_depthTexture, diffuseColorTexUv).rgb;\n  // shadingColor.rgb = vec3(textureProj( u_depthTexture, v_shadowCoord ).z, 0.0, 0.0);\n  alpha = 1.0;\n#endif\n\n#ifdef RN_IS_ALPHA_MODE_BLEND\n#else\n  alpha = 1.0;\n#endif\n\n  rt0 = vec4(shadingColor * alpha, alpha);\n  // rt0 = vec4(u_lightNumber, 0.0, 0.0, 1.0);\n  // rt0 = vec4(1.0, 0.0, 0.0, 1.0);\n  // rt0 = vec4(normal_inWorld*0.5+0.5, 1.0);\n\n/* shaderity: @{renderTargetEnd} */\n\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/ClassicSingleShader/ClassicSingleShader.vert
var ClassicSingleShader_default3;
var init_ClassicSingleShader3 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/ClassicSingleShader/ClassicSingleShader.vert"() {
    ClassicSingleShader_default3 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n\n#ifdef RN_IS_SKINNING\n\nfn createMatrixFromQuaternionTranslationScale( quaternion: vec4<f32>, translation: vec3<f32>, scale: vec3<f32> ) -> mat4x4<f32> {\n  let q = quaternion;\n  let t = translation;\n\n  let sx = q.x * q.x;\n  let sy = q.y * q.y;\n  let sz = q.z * q.z;\n  let cx = q.y * q.z;\n  let cy = q.x * q.z;\n  let cz = q.x * q.y;\n  let wx = q.w * q.x;\n  let wy = q.w * q.y;\n  let wz = q.w * q.z;\n\n  let mat = mat4x4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  let uniformScaleMat = mat4x4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  let mat44 = mat*uniformScaleMat;\n  return mat44;\n\n}\n\nfn unpackedVec2ToNormalizedVec4(vec_xy: vec2<f32>, criteria: f32) -> vec4<f32> {\n\n  var r: f32;\n  var g: f32;\n  var b: f32;\n  var a: f32;\n\n  let ix = floor(vec_xy.x * criteria);\n  let v1x = ix / criteria;\n  let v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  let iy = floor( vec_xy.y * criteria);\n  let v2x = iy / criteria;\n  let v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4<f32>(r, g, b, a);\n}\n\nfn get_boneMatrixAsMat4x4(skeletalComponentSID: u32, joint: u32) -> mat4x4<f32> {\n  let mat43: mat4x3<f32> = get_boneMatrix(skeletalComponentSID, joint);\n  return mat4x4<f32>(\n    vec4<f32>(mat43[0], 0.0),\n    vec4<f32>(mat43[1], 0.0),\n    vec4<f32>(mat43[2], 0.0),\n    vec4<f32>(mat43[3], 1.0)\n  );\n}\n\nfn getSkinMatrix(skeletalComponentSID: u32, joint: vec4<u32>, weight: vec4<f32>) -> mat4x4<f32> {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  var skinMat: mat4x4<f32> = weight.x * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.x);\n  skinMat += weight.y * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.y);\n  skinMat += weight.z * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.z);\n  skinMat += weight.w * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.w);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  let criteria = vec2<f32>(4096.0, 4096.0);\n\n  let tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, joint.x);\n  let sq_x = get_boneScalePackedQuat(skeletalComponentSID, joint.x);\n  var quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  let tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, joint.y);\n  let sq_y = get_boneScalePackedQuat(skeletalComponentSID, joint.y);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  let tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, joint.z);\n  let sq_z = get_boneScalePackedQuat(skeletalComponentSID, joint.z);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  let tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, joint.w);\n  let sq_w = get_boneScalePackedQuat(skeletalComponentSID, joint.w);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  let ts_x = get_boneTranslateScale(skeletalComponentSID, joint.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = get_boneTranslateScale(skeletalComponentSID, joint.y);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.y), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = get_boneTranslateScale(skeletalComponentSID, joint.z);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.z), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = get_boneTranslateScale(skeletalComponentSID, joint.w);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.w), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  let boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, joint.x);\n  let boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, joint.y);\n  let boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, joint.z);\n  let boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, joint.w);\n\n  let criteria = vec2<f32>(4096.0, 4096.0);\n  let boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  let ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\nfn toNormalMatrix(m: mat4x4<f32>) -> mat3x3<f32> {\n  let a00 = m[0][0];\n  let a01 = m[0][1];\n  let a02 = m[0][2];\n  let a03 = m[0][3];\n  let a10 = m[1][0];\n  let a11 = m[1][1];\n  let a12 = m[1][2];\n  let a13 = m[1][3];\n  let a20 = m[2][0];\n  let a21 = m[2][1];\n  let a22 = m[2][2];\n  let a23 = m[2][3];\n  let a30 = m[3][0];\n  let a31 = m[3][1];\n  let a32 = m[3][2];\n  let a33 = m[3][3];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  let determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3x3<f32>(\n    (a11 * b11 - a12 * b10 + a13 * b09) / determinantVal,\n    (a12 * b08 - a10 * b11 - a13 * b07) / determinantVal,\n    (a10 * b10 - a11 * b08 + a13 * b06) / determinantVal,\n    (a02 * b10 - a01 * b11 - a03 * b09) / determinantVal,\n    (a00 * b11 - a02 * b08 + a03 * b07) / determinantVal,\n    (a01 * b08 - a00 * b10 - a03 * b06) / determinantVal,\n    (a31 * b05 - a32 * b04 + a33 * b03) / determinantVal,\n    (a32 * b02 - a30 * b05 - a33 * b01) / determinantVal,\n    (a30 * b04 - a31 * b02 + a33 * b00) / determinantVal\n  );\n}\n\nstruct GeometoryOutput {\n  normalMatrix: mat3x3<f32>,\n  position_inWorld: vec4<f32>,\n  normal_inWorld: vec3<f32>,\n  isSkinning: bool,\n}\n\n#ifdef RN_IS_SKINNING\nfn skinning(\n  skeletalComponentSID: u32,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n  ) -> GeometoryOutput\n{\n  var output: GeometoryOutput;\n  let skinMat = getSkinMatrix(skeletalComponentSID, joint, weight);\n  output.position_inWorld = skinMat * vec4<f32>(inPosition_inLocal, 1.0);\n  output.normalMatrix = toNormalMatrix(skinMat);\n  output.normal_inWorld = normalize(output.normalMatrix * inNormal_inLocal);\n  output.isSkinning = true;\n\n  return output;\n}\n#endif\n\n\nfn processGeometryWithMorphingAndSkinning(\n  skeletalComponentSID: i32,\n  blendShapeComponentSID: u32,\n  worldMatrix: mat4x4<f32>,\n  viewMatrix: mat4x4<f32>,\n  isBillboard: bool,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  baryCentricCoord: vec4<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n) -> GeometoryOutput {\n  var output: GeometoryOutput;\n\n  var position_inLocal: vec3<f32>;\n#ifdef RN_IS_MORPHING\n  if (uniformDrawParameters.morphTargetNumber == 0u) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    let vertexIdx = u32(baryCentricCoord.w);\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal, blendShapeComponentSID);\n  }\n#endif\n\n  var worldMatrixInner = worldMatrix;\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0) {\n    output = skinning(u32(skeletalComponentSID), inNormalMatrix, position_inLocal, inNormal_inLocal, joint, weight);\n  } else {\n#endif\n    output.normalMatrix = inNormalMatrix;\n    output.position_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    output.normal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n    output.isSkinning = false;\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return output;\n}\n\n\n// BiasMatrix * LightProjectionMatrix * LightViewMatrix, See: http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/#basic-shader\n// #param depthBiasPV: mat4x4<f32>; // initialValue=(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)\n\n@vertex\nfn main(\n#ifdef RN_USE_INSTANCE\n  @location(8) instance_ids: vec4<f32>,\n#endif\n\n\n#ifdef RN_USE_POSITION_FLOAT\n  @location(0) position: vec3<f32>,\n#endif\n#ifdef RN_USE_POSITION_INT\n  @location(0) position: vec3<i32>,\n#endif\n#ifdef RN_USE_POSITION_UINT\n  @location(0) position: vec3<u32>,\n#endif\n\n#ifdef RN_USE_NORMAL\n  @location(1) normal: vec3<f32>,\n#endif\n#ifdef RN_USE_TANGENT\n  @location(2) tangent: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_0\n  @location(3) texcoord_0: vec2<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  @location(4) texcoord_1: vec2<f32>,\n#endif\n\n#ifdef RN_USE_COLOR_0_FLOAT\n  @location(5) color_0: vec4<f32>,\n#endif\n#ifdef RN_USE_COLOR_0_INT\n  @location(5) color_0: vec4<i32>,\n#endif\n#ifdef RN_USE_COLOR_0_UINT\n  @location(5) color_0: vec4<u32>,\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  @location(6) joints_0: vec4<u32>,\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  @location(7) weights_0: vec4<f32>,\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  @location(10) baryCentricCoord: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  @location(11) texcoord_2: vec2<f32>,\n#endif\n  @builtin(vertex_index) vertexIdx : u32,\n\n\n) -> VertexOutput {\n\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var output : VertexOutput;\n  let instanceId = u32(instance_ids.x);\n\n  let worldMatrix = get_worldMatrix(instanceId);\n  let viewMatrix = get_viewMatrix(cameraSID, 0);\n  let projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  let normalMatrix = get_normalMatrix(instanceId);\n  // let isBillboard = get_isBillboard(instanceId);\n\n  let skeletalComponentSID = i32(instance_ids.y);\n  let blendShapeComponentSID = u32(instance_ids.z);\n\n\n#ifdef RN_USE_NORMAL\n#else\n  let normal = vec3<f32>(0.0, 0.0, 0.0);\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  let joint = joints_0;\n#else\n  let joint = vec4<u32>(0, 0, 0, 0);\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  let weight = weights_0;\n#else\n  let weight = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n#else\n  let baryCentricCoord = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n\n  // Skeletal\n  let geom = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    blendShapeComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    position,\n    normal,\n    baryCentricCoord,\n    joint,\n    weight\n  );\n\n  output.position = projectionMatrix * viewMatrix * geom.position_inWorld;\n  output.position_inWorld = geom.position_inWorld.xyz;\n\n#ifdef RN_USE_COLOR_0\n  output.color_0 = vec4f(color_0);\n#else\n  output.color_0 = vec4f(1.0, 1.0, 1.0, 1.0);\n#endif\n\n  output.normal_inWorld = normalMatrix * normal;\n\n#ifdef RN_USE_TEXCOORD_0\n  output.texcoord_0 = texcoord_0;\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  output.texcoord_1 = texcoord_1;\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  output.texcoord_2 = texcoord_2;\n#endif\n\n  output.baryCentricCoord = baryCentricCoord.xyz;\n\n  let visibility = get_isVisible(instanceId);\n  if (!visibility)\n  {\n    output.position = vec4f(0.0, 0.0, 0.0, 1.0);\n  }\n\n#ifdef RN_USE_SHADOW_MAPPING\n  output.shadowCoord = get_depthBiasPV(materialSID, 0) * geom.position_inWorld;\n#endif\n\n  return output;\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/ClassicSingleShader/ClassicSingleShader.frag
var ClassicSingleShader_default4;
var init_ClassicSingleShader4 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/ClassicSingleShader/ClassicSingleShader.frag"() {
    ClassicSingleShader_default4 = { code: `/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) shadowCoord : vec4<f32>,
  @location(10) instanceInfo : f32,
  @location(11) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturateEpsilonToOne(x: f32) -> f32 {
  let Epsilon = 0.0000001;
  return clamp(x, Epsilon, 1.0);
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

struct Light {
  lightType: i32, // 0 = directional, 1 = point, 2 = spot
  position: vec3<f32>,
  intensity: vec3<f32>,
  attenuatedIntensity: vec3<f32>,
  directionOfLightObject: vec3<f32>,
  direction: vec3<f32>, // direction of light vector, equal to normalize(light.pointToLight)
  pointToLight: vec3<f32>, // not normalized
  spotAngleScale: f32,
  spotAngleOffset: f32,
  effectiveRange: f32,
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
fn getRangeAttenuation(light: Light) -> f32
{
  let distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
fn getSpotAttenuation(light: Light) -> f32
{

  let cd = dot(light.directionOfLightObject, light.direction);
  let angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);
  return angularAttenuation;
}

fn getLightAttenuated(light: Light) -> Light {
  var newLight: Light = light;
  newLight.attenuatedIntensity = light.intensity;
  // if (light.lightType == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light
  if (light.lightType == 1)
  {
    newLight.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot light
  if (light.lightType == 2)
  {
    newLight.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return newLight;
}

fn getLight(lightIdx: u32, v_position_inWorld: vec3<f32>) -> Light {
  let lightPosition: vec3<f32> = get_lightPosition(0u, lightIdx);
  let direction_and_w_of_LightObject: vec3<f32> = get_lightDirection(0u, lightIdx);
  let lightIntensity: vec3<f32> = get_lightIntensity(0u, lightIdx);
  let lightProperty: vec4<f32> = get_lightProperty(0u, lightIdx);
  var light: Light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  let lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.spotAngleScale = lightProperty.z;
  light.spotAngleOffset = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3f(0.0);
    light.lightType = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.lightType = 1;
  } else { // is Directional Light
    light.lightType = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.lightType = 2;
  }

  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  let newLight = getLightAttenuated(light);

  return newLight;
}

#ifdef RN_USE_TANGENT
  fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
    let tangent_inWorld = normalize(input.tangent_inWorld);
    let binormal_inWorld = normalize(input.binormal_inWorld);
    let tbnMat_tangent_to_world = mat3x3<f32>(tangent_inWorld, binormal_inWorld, normal_inWorld);

    return tbnMat_tangent_to_world;
  }
#else
    // This is based on http://www.thetenthplanet.de/archives/1180
    fn cotangent_frame(normal_inWorld: vec3f, position: vec3f, uv_: vec2f, isFront: bool) -> mat3x3<f32> {
      var uv: vec2f;
      if (isFront) {
        uv = uv_;
      } else {
        uv = -uv_;
      }

      // get edge vectors of the pixel triangle
      let dp1 = dpdx(position);
      let dp2 = dpdy(position);
      let duv1 = dpdx(uv);
      let duv2 = dpdy(uv);

      // solve the linear system
      let dp2perp = cross(dp2, normal_inWorld);
      let dp1perp = cross(normal_inWorld, dp1);
      let tangent = dp2perp * duv1.x + dp1perp * duv2.x;
      var bitangent = dp2perp * duv1.y + dp1perp * duv2.y;
      bitangent *= -1.0;

      // construct a scale-invariant frame
      let invMat = 1.0 / sqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));
      return mat3x3<f32>(tangent * invMat, bitangent * invMat, normal_inWorld);
    }

    fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
      let tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord, isFront);

      return tbnMat_tangent_to_world;
    }
#endif

fn srgbToLinear(srgbColor: vec3f) -> vec3f {
  return pow(srgbColor, vec3f(2.2));
}

fn linearToSrgb(linearColor: vec3f) -> vec3f {
  return pow(linearColor, vec3f(1.0/2.2));
}

// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66
fn Schlick_to_F0_F90(f: vec3f, f90: vec3f, VdotH: f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0_F90_F32(f: f32, f90: f32, VdotH: f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0(f: vec3f, VdotH: f32) -> vec3f {
    return Schlick_to_F0_F90(f, vec3(1.0), VdotH);
}

fn Schlick_to_F0_F32(f: f32, VdotH: f32) -> f32 {
    return Schlick_to_F0_F90_F32(f, 1.0, VdotH);
}


// The Schlick Approximation to Fresnel
fn fresnel(f0 : vec3f, f90 : vec3f, VdotH : f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnelF32(f0 : f32, f90 : f32, VdotH : f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnel2(f0: vec3f, VdotH: f32) -> vec3f
{
  let f90 = vec3f(1.0); //clamp(50.0 * f0, 0.0, 1.0);
  return fresnel(f0, f90, VdotH);
}

fn fresnel2F32(f0: f32, VdotH: f32) -> f32
{
  let f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelF32(f0, f90, VdotH);
}

// Roughness Dependent Fresnel
// https://www.jcgt.org/published/0008/01/03/paper.pdf
fn fresnelSchlickRoughness(F0: vec3f, cosTheta: f32, roughness: f32) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);
  return k_S;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf
fn BRDF_lambertian(albedo: vec3f, F: vec3f, specularWeight: f32) -> vec3f
{
  return (vec3f(1.0) - specularWeight * F) * albedo * RECIPROCAL_PI;
}


// GGX NDF
fn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {
  let roughnessSqr = alphaRoughness * alphaRoughness;
  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
fn v_GGXCorrelated(NL: f32, NV: f32, alphaRoughness: f32) -> f32 {
  let a2 = alphaRoughness * alphaRoughness;
  let GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  let GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  return 0.5 / (GGXV + GGXL);
}

fn BRDF_specularGGX(NH: f32, NL: f32, NV: f32, F: vec3f, alphaRoughness: f32, specularWeight: f32) -> vec3f {
  let D = d_GGX(NH, alphaRoughness);
  let V = v_GGXCorrelated(NL, NV, alphaRoughness);
  return vec3f(D) * vec3f(V) * F * specularWeight;
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
fn envBRDFApprox( Roughness: f32, NoV: f32 ) -> vec2f {
  let c0 = vec4f(-1, -0.0275, -0.572, 0.022 );
  let c1 = vec4f(1, 0.0425, 1.04, -0.04 );
  let r = Roughness * c0 + c1;
  let a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  let AB = vec2f( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}


// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering
fn coated_material_s(base: vec3f, perceptualRoughness: f32, clearcoatRoughness: f32, clearcoat: f32, VdotNc: f32, LdotNc: f32, NdotHc: f32) -> vec3f {
  let clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);
  let clearcoatAlpha = clearcoatRoughness * clearcoatRoughness;
  let alphaRoughness = perceptualRoughness * perceptualRoughness;
  let D = d_GGX(NdotHc, clearcoatAlpha);
  let V = v_GGXCorrelated(LdotNc, VdotNc, clearcoatAlpha);
  let f_clearcoat = clearcoatFresnel * D * V;

  // base = (f_diffuse + f_specular) in https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering
  return base * vec3f(1.0 - clearcoat * clearcoatFresnel) + vec3f(f_clearcoat * clearcoat);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes
fn specular_btdf(alphaRoughness: f32, NdotL: f32, NdotV: f32, NdotHt: f32) -> f32 {
  let V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  let D = d_GGX(NdotHt, alphaRoughness);
  return V * D;
}


////////////////////////////////////////
// glTF KHR_materials_volume
////////////////////////////////////////

#ifdef RN_USE_VOLUME
// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
fn volumeAttenuation(attenuationColor: vec3f, attenuationDistance: f32, intensity: vec3f, transmissionDistance: f32) -> vec3f
{
  if (attenuationDistance == 0.0) { // means Infinite distance
    return intensity; // No attenuation
  } else {
    let attenuationCo: vec3f = -log(attenuationColor) / attenuationDistance;
    let attenuatedTransmittance: vec3f = exp(-attenuationCo * transmissionDistance);
    return intensity * attenuatedTransmittance;
  }
}
#endif


////////////////////////////////////////
// glTF KHR_materials_anisotropy
////////////////////////////////////////
#ifdef RN_USE_ANISOTROPY
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
fn D_GGX_anisotropic(NdotH: f32, TdotH: f32, BdotH: f32, at: f32, ab: f32) -> f32
{
    let a2 = at * ab;
    let f = vec3f(ab * TdotH, at * BdotH, a2 * NdotH);
    let w2 = a2 / dot(f, f);
    return a2 * w2 * w2 / M_PI;
}

fn V_GGX_anisotropic(NdotL: f32, NdotV: f32, BdotV: f32, TdotV: f32, TdotL: f32, BdotL: f32,
    at: f32, ab: f32) -> f32
{
    let GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));
    let GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));
    let v = 0.5 / (GGXV + GGXL);
    return clamp(v, 0.0, 1.0);
}

fn BRDF_specularAnisotropicGGX(F: vec3f, alphaRoughness: f32,
    VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32, BdotV: f32, TdotV: f32,
    TdotL: f32, BdotL: f32, TdotH: f32, BdotH: f32, anisotropy: f32) -> vec3f
{
    let at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
    let ab = alphaRoughness;

    let V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);
    let D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);

    return F * V * D;
}
#endif

////////////////////////////////////////
// glTF KHR_materials_sheen
////////////////////////////////////////

#ifdef RN_USE_SHEEN
fn d_Charlie(sheenPerceptualRoughness: f32, NoH: f32) -> f32 {
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;
  let invAlpha  = 1.0 / alphaG;
  let cos2h = NoH * NoH;
  let sin2h = 1.0 - cos2h;
  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * M_PI);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn sheenSimpleVisibility(NdotL: f32, NdotV: f32) -> f32 {
  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn charlieL(x: f32, alphaG: f32) -> f32 {
  let oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
  let a = mix(21.5473, 25.3245, oneMinusAlphaSq);
  let b = mix(3.82987, 3.32435, oneMinusAlphaSq);
  let c = mix(0.19823, 0.16801, oneMinusAlphaSq);
  let d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
  let e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
  return a / (1.0 + b * pow(x, c)) + d * x + e;
}

fn lambdaSheen(cosTheta: f32, alphaG: f32) -> f32
{
  return select(exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG)), exp(charlieL(cosTheta, alphaG)), abs(cosTheta) < 0.5);
}

fn sheenCharlieVisibility(NdotL: f32, NdotV: f32, sheenPerceptualRoughness: f32) -> f32 {
  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;
  let sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));
  return sheenVisibility;
}

fn sheen_brdf(sheenColor: vec3f, sheenPerceptualRoughness: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f {
  let sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);
  let sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);
  return sheenColor * sheenDistribution * sheenVisibility;
}
#endif // RN_USE_SHEEN

////////////////////////////////////////
// glTF KHR_materials_irirdescence
////////////////////////////////////////

#ifdef RN_USE_IRIDESCENCE
// XYZ to REC709(sRGB) conversion matrix
const XYZ_TO_REC709 = mat3x3<f32>(
     3.2404542, -0.9692660,  0.0556434,
    -1.5371385,  1.8760108, -0.2040259,
    -0.4985314,  0.0415560,  1.0572252
);

fn fresnelSchlickRoughnessWithIridescence(
  F0: vec3f, cosTheta: f32, roughness: f32,
  iridescenceFresnel: vec3f, iridescence: f32
  ) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);
  return k_S;
}

// Assume air interface for top
fn Fresnel0ToIor(F0: vec3f) -> vec3f {
    let sqrtF0 = sqrt(F0);
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// Conversion from IOR to F0
// ior is a value between 1.0 and 3.0. 1.0 is air interface
fn IorToFresnel0Vec3f(transmittedIor: vec3f, incidentIor: f32) -> vec3f {
    return sqVec3f((transmittedIor - vec3f(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
fn IorToFresnel0F32(transmittedIor: f32, incidentIor: f32) -> f32 {
    return sqF32((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration
 */
fn evalSensitivity(OPD: f32, shift: vec3f) -> vec3f {
    let phase = 2.0 * M_PI * OPD * 1.0e-9;
    let val = vec3f(5.4856e-13, 4.4201e-13, 5.2481e-13);
    let pos = vec3f(1.6810e+06, 1.7953e+06, 2.2084e+06);
    let var_ = vec3f(4.3278e+09, 9.3046e+09, 6.6121e+09);

    var xyz = val * sqrt(2.0 * M_PI * var_) * cos(pos * phase + shift) * exp(-(phase * phase) * var_);
    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));
    xyz /= 1.0685e-7;

    let rgb = XYZ_TO_REC709 * xyz;
    return rgb;
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel
 */
fn calcIridescence(outsideIor: f32, eta2: f32, cosTheta1: f32, thinFilmThickness: f32, baseF0: vec3f) -> vec3f {


  // iridescenceIor is the index of refraction of the thin-film layer
  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
  let iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));

  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)
  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.
  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.
  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):
  let sinTheta2Sq = sqF32(outsideIor / iridescenceIor) * (1.0 - sqF32(cosTheta1));
  let cosTheta2Sq = 1.0 - sinTheta2Sq;

  // Handle total internal reflection
  if (cosTheta2Sq < 0.0) {
      return vec3f(1.0);
  }

  let cosTheta2 = sqrt(cosTheta2Sq);

  /// Material Interfaces
  // The iridescence model defined by Belcour/Barla models two material interfaces
  // - one from the outside to the thin-film layer
  // and another one from the thin-film to the base material. These two interfaces are defined as follows:

  // First interface (from the outside to the thin-film layer)
  let R0 = IorToFresnel0F32(iridescenceIor, outsideIor);
  let R12 = fresnel2F32(R0, cosTheta1);
  let R21 = R12;
  let T121 = 1.0 - R12;

  // Second interface (from the thin-film to the base material)
  let baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0
  let R1 = IorToFresnel0Vec3f(baseIor, iridescenceIor);
  let R23 = fresnel2(R1, cosTheta2);

  // phi12 and phi23 define the base phases per interface and are approximated with 0.0
  // if the IOR of the hit material (iridescenceIor or baseIor) is higher
  // than the IOR of the previous material (outsideIor or iridescenceIor) and \u03C0 otherwise.
  // Also here, polarization is ignored.  float phi12 = 0.0;

  // First interface (from the outside to the thin-film layer)
  var phi12 = 0.0;
  if (iridescenceIor < outsideIor) { phi12 = M_PI; }
  let phi21 = M_PI - phi12;

  // Second interface (from the thin-film to the base material)
  var phi23 = vec3f(0.0);
  if (baseIor[0] < iridescenceIor) { phi23[0] = M_PI; }
  if (baseIor[1] < iridescenceIor) { phi23[1] = M_PI; }
  if (baseIor[2] < iridescenceIor) { phi23[2] = M_PI; }

  // OPD (optical path difference)
  let OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
  // Phase shift
  let phi = vec3f(phi21) + phi23;

  // Compound terms
  let R123 = clamp(R12 * R23, vec3f(1e-5), vec3f(0.9999));
  let r123 = sqrt(R123);
  let Rs = (T121 * T121) * R23 / (vec3f(1.0) - R123);

  // Reflectance term for m = 0 (DC term amplitude)
  let C0 = R12 + Rs;
  var I = C0;

  // Reflectance term for m > 0 (pairs of diracs)
  var Cm = Rs - T121;
  for (var m = 1; m <= 2; m++)
  {
      Cm *= r123;
      let Sm = 2.0 * evalSensitivity(f32(m) * OPD, f32(m) * phi);
      I += Cm * Sm;
  }

  let F_iridescence = max(I, vec3f(0.0));

  return F_iridescence;
}

//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB
fn BRDF_lambertianIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, iridescenceFactor: f32, diffuseColor: vec3f, specularWeight: f32, VdotH: f32) -> vec3f
{
    let iridescenceFresnelMax = vec3f(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));

    let schlickFresnel = Schlick_to_F0_F90(f0, f90, VdotH);

    let F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);

    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);
}

fn BRDF_specularGGXIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, alphaRoughness: f32, iridescenceFactor: f32, specularWeight: f32, VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f
{
    let F = mix(Schlick_to_F0_F90(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);
    let Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
    let D = d_GGX(NdotH, alphaRoughness);

    return specularWeight * F * Vis * D;
}

#endif // RN_USE_IRIDESCENCE


////////////////////////////////////////
// lighting with a punctual light
////////////////////////////////////////
fn lightingWithPunctualLight(
  light: Light,
  normal_inWorld: vec3f,
  viewDirection: vec3f,
  NdotV: f32,
  albedo: vec3f,
  perceptualRoughness: f32,
  F0: vec3f,
  F90: vec3f,
  transmission: f32,
  ior: f32,
  clearcoat: f32,
  clearcoatRoughness: f32,
  clearcoatNormal_inWorld: vec3f,
  VdotNc: f32,
  attenuationColor: vec3f,
  attenuationDistance: f32,
  anisotropy: f32,
  anisotropicT: vec3f,
  anisotropicB: vec3f,
  BdotV: f32,
  TdotV: f32,
  sheenColor: vec3f,
  sheenRoughness: f32,
  albedoSheenScalingNdotV: f32,
  iridescenceFactor: f32,
  iridescenceFresnel: vec3f,
  specularWeight: f32,
  ) -> vec3f
{
  let alphaRoughness = perceptualRoughness * perceptualRoughness;

  // Fresnel
  let halfVector = normalize(light.direction + viewDirection);
  let VdotH = dot(viewDirection, halfVector);
  let F = fresnel(F0, F90, VdotH);

  let NdotL = clamp(dot(normal_inWorld, light.direction), Epsilon, 1.0);

  // Diffuse
#ifdef RN_USE_IRIDESCENCE
  let diffuseBrdf = BRDF_lambertianIridescence(F0, F90, iridescenceFresnel, iridescenceFactor, albedo, specularWeight, VdotH);
#else
  let diffuseBrdf = BRDF_lambertian(albedo, F, specularWeight);
#endif
  let pureDiffuse = diffuseBrdf * vec3f(NdotL) * light.attenuatedIntensity;

#ifdef RN_USE_TRANSMISSION
  let refractionVector = refract(-viewDirection, normal_inWorld, 1.0 / ior);
  var transmittedLightFromUnderSurface: Light = light;
  transmittedLightFromUnderSurface.pointToLight -= refractionVector;
  let transmittedLightDirectionFromUnderSurface = normalize(transmittedLightFromUnderSurface.pointToLight);
  transmittedLightFromUnderSurface.direction = transmittedLightDirectionFromUnderSurface;

  let Ht = normalize(viewDirection + transmittedLightFromUnderSurface.direction);
  let NdotHt = saturateEpsilonToOne(dot(normal_inWorld, Ht));
  let NdotLt = saturateEpsilonToOne(dot(normal_inWorld, transmittedLightFromUnderSurface.direction));

  var transmittedContrib = (vec3f(1.0) - F) * specular_btdf(alphaRoughness, NdotLt, NdotV, NdotHt) * albedo * transmittedLightFromUnderSurface.attenuatedIntensity;

#ifdef RN_USE_VOLUME
  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittedLightFromUnderSurface.pointToLight));
#endif // RN_USE_VOLUME

  let diffuseContrib = mix(pureDiffuse, vec3f(transmittedContrib), transmission);
#else
  let diffuseContrib = pureDiffuse;
#endif // RN_USE_TRANSMISSION

  // Specular
  let NdotH = saturateEpsilonToOne(dot(normal_inWorld, halfVector));


#ifdef RN_USE_IRIDESCENCE
  let specularContrib = BRDF_specularGGXIridescence(F0, F90, iridescenceFresnel, alphaRoughness, iridescenceFactor, specularWeight, VdotH, NdotL, NdotV, NdotH) * vec3f(NdotL) * light.attenuatedIntensity;
#elif defined(RN_USE_ANISOTROPY)
  let TdotL = dot(anisotropicT, light.direction);
  let BdotL = dot(anisotropicB, light.direction);
  let TdotH = dot(anisotropicT, halfVector);
  let BdotH = dot(anisotropicB, halfVector);
  let specularContrib = BRDF_specularAnisotropicGGX(F, alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3f(NdotL) * light.attenuatedIntensity;
#else
  let specularContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, F, alphaRoughness, specularWeight) * vec3f(NdotL) * light.attenuatedIntensity;
#endif

  // Base Layer
  let baseLayer = diffuseContrib + specularContrib;

#ifdef RN_USE_SHEEN
  // Sheen
  let sheenContrib = sheen_brdf(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;
  let albedoSheenScaling = min(
    albedoSheenScalingNdotV,
    1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotL, sheenRoughness)).r);
  let color = sheenContrib + baseLayer * albedoSheenScaling;
#else
  let color = baseLayer;
  let albedoSheenScaling = 1.0;
#endif // RN_USE_SHEEN

#ifdef RN_USE_CLEARCOAT
  // Clear Coat Layer
  let NdotHc = saturateEpsilonToOne(dot(clearcoatNormal_inWorld, halfVector));
  let LdotNc = saturateEpsilonToOne(dot(light.direction, clearcoatNormal_inWorld));
  let coated = coated_material_s(color, perceptualRoughness,
    clearcoatRoughness, clearcoat, VdotNc, LdotNc, NdotHc);
  let finalColor = coated;
#else
  let finalColor = color;
#endif // RN_USE_CLEARCOAT

  return finalColor;
}

fn IsotropicNDFFiltering(normal: vec3f, roughness2: f32) -> f32 {
  let SIGMA2 = 0.15915494;
  let KAPPA = 0.18;
  let dndu  = dpdx(normal);
  let dndv = dpdy(normal);
  let kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));
  let clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);
  let filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);
  return filteredRoughness2;
}


// #param shadingModel: u32; // initialValue=0
// #param alphaCutoff: f32; // initialValue=0.01
// #param shininess: f32; // initialValue=5
// #param diffuseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)
@group(1) @binding(0) var diffuseColorTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(0) var diffuseColorSampler: sampler;
@group(1) @binding(1) var normalTexture: texture_2d<f32>; // initialValue=blue
@group(2) @binding(1) var normalSampler: sampler;
// #param diffuseColorTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)
// #param diffuseColorTextureRotation: f32; // initialValue=0
@group(1) @binding(2) var depthTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(2) var depthSampler: sampler;

@fragment
fn main (
  input: VertexOutput,
  @builtin(front_facing) isFront: bool,
) -> @location(0) vec4<f32> {

let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  // Normal
  let normal_inWorld = normalize(input.normal_inWorld);

  let diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);

  // diffuseColor (Considered to be premultiplied alpha)
  var diffuseColor = vec3f(1.0, 1.0, 1.0);
  var alpha = 1.0;
#ifdef RN_USE_COLOR_0
  diffuseColor = input.color_0.rgb;
  alpha = input.color_0.a;
#endif
  diffuseColor *= diffuseColorFactor.rgb;
  alpha *= diffuseColorFactor.a;

#ifdef RN_USE_TEXCOORD_0
  // diffuseColorTexture (Considered to be premultiplied alpha)
  let diffuseColorTextureTransform = get_diffuseColorTextureTransform(materialSID, 0);
  let diffuseColorTextureRotation = get_diffuseColorTextureRotation(materialSID, 0);
  let diffuseColorTexUv = uvTransform(diffuseColorTextureTransform.xy, diffuseColorTextureTransform.zw, diffuseColorTextureRotation, input.texcoord_0);
  let textureColor = textureSample(diffuseColorTexture, diffuseColorSampler, diffuseColorTexUv);
  diffuseColor *= textureColor.rgb;
  alpha *= textureColor.a;
#endif

#ifdef RN_IS_ALPHA_MODE_MASK
  let alphaCutoff = get_alphaCutoff(materialSID, 0);
  if (baseColor.a < alphaCutoff) {
    discard;
  }
#endif


  // Lighting
  var shadingColor = vec3f(0.0, 0.0, 0.0);
#ifdef RN_IS_LIGHTING
  let shadingModel = get_shadingModel(materialSID, 0);
  if (shadingModel > 0) {

    var diffuse = vec3(0.0, 0.0, 0.0);
    var specular = vec3(0.0, 0.0, 0.0);
    let lightNumber = u32(get_lightNumber(0u, 0u));
    for (var i = 0u; i < lightNumber ; i++) {

      // Light
      let light: Light = getLight(i, input.position_inWorld.xyz);

      // Diffuse
      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, light.direction)) * light.attenuatedIntensity;

      let shininess = get_shininess(materialSID, 0);
      let shadingModel = get_shadingModel(materialSID, 0);

      let viewPosition = get_viewPosition(cameraSID, 0);

      // Specular
      if (shadingModel == 2) {// BLINN
        // ViewDirection
        let viewDirection = normalize(viewPosition - input.position_inWorld.xyz);
        let halfVector = normalize(light.direction + viewDirection);
        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), shininess);
      } else if (shadingModel == 3) { // PHONG
        let viewDirection = normalize(viewPosition - input.position_inWorld.xyz);
        let R = reflect(light.direction, normal_inWorld);
        specular += pow(max(0.0, dot(R, viewDirection)), shininess);
      }

    }

    shadingColor = diffuse + specular;
  } else {
    shadingColor = diffuseColor;
  }
#else
  shadingColor = diffuseColor;
#endif

  // Shadow
// #ifdef RN_USE_SHADOW_MAPPING
//   float visibility = 1.0;
//   float bias = 0.001;

// //  Non PCF
//   if ( textureProj( u_depthTexture, v_shadowCoord ).r  < (v_shadowCoord.z - bias) / v_shadowCoord.w ) {
//     visibility = 0.5;
//   }
//   shadingColor *= visibility;

//   // Hardware PCF
//   // vec4 shadowCoord = v_shadowCoord;
//   // shadowCoord.z -= bias;
//   // shadingColor *= textureProj( u_depthTexture, shadowCoord ) * 0.5 + 0.5;

//   alpha = 1.0;
// #endif

#ifdef RN_IS_ALPHA_MODE_BLEND
#else
  alpha = 1.0;
#endif

  var finalColor = vec4f(shadingColor * alpha, alpha);
  // rt0 = vec4(u_lightNumber, 0.0, 0.0, 1.0);
  // rt0 = vec4(1.0, 0.0, 0.0, 1.0);
  // rt0 = vec4(normal_inWorld*0.5+0.5, 1.0);

  return finalColor;
}
`, shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/PbrSingleShader/PbrSingleShader.vert
var PbrSingleShader_default;
var init_PbrSingleShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/PbrSingleShader/PbrSingleShader.vert"() {
    PbrSingleShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\n#ifdef WEBGL2_MULTI_VIEW\n  layout(num_views=2) in;\n#endif\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec2 a_texcoord_1;\nin vec2 a_texcoord_2;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout vec2 v_texcoord_1;\nout vec2 v_texcoord_2;\nout vec3 v_baryCentricCoord;\nout float v_instanceInfo;\nout float v_displayIdx;\n#ifdef RN_USE_TANGENT\n  in vec4 a_tangent;\n  out vec3 v_tangent_inWorld;\n  out vec3 v_binormal_inWorld;\n#endif\n#ifdef RN_USE_SHADOW_MAPPING\n  out vec4 v_shadowCoord;\n#endif\n\nuniform float u_pointSize; // initialValue=30, soloDatum=true\nuniform vec3 u_pointDistanceAttenuation; // initialValue=(0.0, 0.1, 0.01), soloDatum=true\n\n// BiasMatrix * LightProjectionMatrix * LightViewMatrix, See: http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/#basic-shader\nuniform mat4 u_depthBiasPV; // initialValue=(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  bool isBillboard = get_isBillboard(a_instanceInfo.x);\n\n  v_color = a_color;\n\n  bool isSkinning = false;\n\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    isBillboard,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n  v_texcoord_0 = a_texcoord_0;\n  v_texcoord_1 = a_texcoord_1;\n  v_texcoord_2 = a_texcoord_2;\n\n  #ifdef RN_USE_TANGENT\n    v_tangent_inWorld = normalMatrix * a_tangent.xyz;\n    v_binormal_inWorld = cross(v_tangent_inWorld, v_normal_inWorld) * a_tangent.w;\n  #endif\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n\n  v_instanceInfo = a_instanceInfo.x;\n\n#ifdef WEBGL2_MULTI_VIEW\n  v_displayIdx = float(gl_ViewID_OVR);\n#endif\n\n  bool visibility = get_isVisible(a_instanceInfo.x);\n  if (!visibility)\n  {\n    gl_Position = vec4(0.0);\n  }\n\n#ifdef RN_USE_SHADOW_MAPPING\n  v_shadowCoord = get_depthBiasPV(materialSID, 0) * v_position_inWorld;\n#endif\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/PbrSingleShader/PbrSingleShader.frag
var PbrSingleShader_default2;
var init_PbrSingleShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/PbrSingleShader/PbrSingleShader.frag"() {
    PbrSingleShader_default2 = { code: `
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

const float Epsilon = 0.0000001;
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}

float saturate(float t)
{
  return clamp(t, 0.0, 1.0);
}


in vec3 v_color;
in vec3 v_normal_inWorld;
in vec4 v_position_inWorld;
in vec2 v_texcoord_0;
in vec2 v_texcoord_1;
in vec2 v_texcoord_2;
in vec3 v_baryCentricCoord;
in float v_instanceInfo;
in float v_displayIdx;

#ifdef RN_USE_TANGENT
  in vec3 v_tangent_inWorld;
  in vec3 v_binormal_inWorld;
#endif

#ifdef RN_USE_SHADOW_MAPPING
in vec4 v_shadowCoord;
#endif

uniform vec4 u_baseColorFactor; // initialValue=(1,1,1,1)
uniform sampler2D u_baseColorTexture; // initialValue=(0,white)
uniform vec2 u_metallicRoughnessFactor; // initialValue=(1,1)
uniform sampler2D u_metallicRoughnessTexture; // initialValue=(1,white)
uniform sampler2D u_occlusionTexture; // initialValue=(3,white)
uniform vec3 u_emissiveFactor; // initialValue=(0,0,0)
uniform sampler2D u_emissiveTexture; // initialValue=(4,white)
uniform float u_emissiveStrength; // initialValue=1
uniform vec3 u_wireframe; // initialValue=(0,0,1)
uniform bool u_isOutputHDR; // initialValue=0
uniform bool u_makeOutputSrgb; // initialValue=1
uniform vec4 u_iblParameter; // initialValue=(1,1,1,1), isInternalSetting=true
uniform ivec2 u_hdriFormat; // initialValue=(0,0), isInternalSetting=true
uniform samplerCube u_diffuseEnvTexture; // initialValue=(5,black), isInternalSetting=true
uniform samplerCube u_specularEnvTexture; // initialValue=(6,black), isInternalSetting=true
uniform vec4 u_baseColorTextureTransform; // initialValue=(1,1,0,0)
uniform float u_baseColorTextureRotation; // initialValue=0
uniform vec4 u_metallicRoughnessTextureTransform; // initialValue=(1,1,0,0)
uniform float u_metallicRoughnessTextureRotation; // initialValue=0
uniform int u_baseColorTexcoordIndex; // initialValue=0
uniform int u_metallicRoughnessTexcoordIndex; // initialValue=0
uniform int u_occlusionTexcoordIndex; // initialValue=0
uniform vec4 u_occlusionTextureTransform; // initialValue=(1,1,0,0)
uniform float u_occlusionTextureRotation; // initialValue=0
uniform int u_emissiveTexcoordIndex; // initialValue=0
uniform vec4 u_emissiveTextureTransform; // initialValue=(1,1,0,0)
uniform float u_emissiveTextureRotation; // initialValue=0
uniform float u_occlusionStrength; // initialValue=1
uniform bool u_inverseEnvironment; // initialValue=false
uniform float u_ior; // initialValue=1.5

#ifdef RN_USE_NORMAL_TEXTURE
  uniform sampler2D u_normalTexture; // initialValue=(2,black)
  uniform vec4 u_normalTextureTransform; // initialValue=(1,1,0,0)
  uniform float u_normalTextureRotation; // initialValue=(0)
  uniform int u_normalTexcoordIndex; // initialValue=(0)
  uniform float u_normalScale; // initialValue=(1)
#endif

#ifdef RN_USE_CLEARCOAT
  uniform float u_clearCoatFactor; // initialValue=0
  uniform float u_clearCoatRoughnessFactor; // initialValue=0
  uniform vec4 u_clearCoatTextureTransform; // initialValue=(1,1,0,0)
  uniform float u_clearCoatTextureRotation; // initialValue=0
  uniform vec4 u_clearCoatRoughnessTextureTransform; // initialValue=(1,1,0,0)
  uniform float u_clearCoatRoughnessTextureRotation; // initialValue=0
  uniform vec4 u_clearCoatNormalTextureTransform; // initialValue=(1,1,0,0)
  uniform float u_clearCoatNormalTextureRotation; // initialValue=0
  uniform int u_clearCoatTexcoordIndex; // initialValue=(0)
  uniform int u_clearCoatRoughnessTexcoordIndex; // initialValue=(0)
  uniform int u_clearCoatNormalTexcoordIndex; // initialValue=(0)
#endif

#ifdef RN_USE_TRANSMISSION
  uniform float u_transmissionFactor; // initialValue=(0)
#endif

#ifdef RN_USE_VOLUME
  uniform float u_thicknessFactor; // initialValue=(0)
  uniform float u_attenuationDistance; // initialValue=(0.000001)
  uniform vec3 u_attenuationColor; // initialValue=(1,1,1)
#endif

#ifdef RN_USE_SHEEN
  uniform vec3 u_sheenColorFactor; // initialValue=(0,0,0)
  uniform float u_sheenRoughnessFactor; // initialValue=(0)
#endif

#ifdef RN_USE_SPECULAR
  uniform float u_specularFactor; // initialValue=1.0
  uniform vec3 u_specularColorFactor; // initialValue=(1,1,1)
#endif

#ifdef RN_USE_IRIDESCENCE
  uniform float u_iridescenceFactor; // initialValue=0
  uniform float u_iridescenceIor; // initialValue=1.3
  uniform float u_iridescenceThicknessMinimum; // initialValue=100
  uniform float u_iridescenceThicknessMaximum; // initialValue=400
#endif

#ifdef RN_USE_ANISOTROPY
  uniform float u_anisotropyStrength; // initialValue=0
  uniform vec2 u_anisotropyRotation; // initialValue=(1,0)
#endif

uniform float u_alphaCutoff; // initialValue=(0.01)

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

struct Light {
  int type; // 0 = directional, 1 = point, 2 = spot
  vec3 position;
  vec3 intensity;
  vec3 attenuatedIntensity;
  vec3 directionOfLightObject;
  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)
  vec3 pointToLight; // not normalized
  float spotAngleScale;
  float spotAngleOffset;
  float effectiveRange;
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
float getRangeAttenuation(Light light)
{
  float distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
float getSpotAttenuation(Light light)
{

  float cd = dot(light.directionOfLightObject, light.direction);
  float angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);
  return angularAttenuation;
}

void getLightAttenuated(Light light) {
  light.attenuatedIntensity = light.intensity;
  // if (light.type == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light
  if (light.type == 1)
  {
    light.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot light
  if (light.type == 2)
  {
    light.attenuatedIntensity *= getSpotAttenuation(light);
  }
}

Light getLight(int lightIdx, vec3 v_position_inWorld) {
  vec3 lightPosition = get_lightPosition(0.0, lightIdx);
  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);
  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);
  vec4 lightProperty = get_lightProperty(0.0, lightIdx);
  Light light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  float lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.spotAngleScale = lightProperty.z;
  light.spotAngleOffset = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3(0.0);
    light.type = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.type = 1;
  } else { // is Directional Light
    light.type = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.type = 2;
  }

  const float M_PI = 3.141592653589793;
  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  getLightAttenuated(light);

  return light;
}

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

float angular_n_h(float NH) {
  return acos(NH);
}

float d_phong(float NH, float c1) {
  return pow(
    cos(acos(NH))
    , c1
  );
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec2 envBRDFApprox( float Roughness, float NoV ) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022 );
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );
  vec4 r = Roughness * c0 + c1;
  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}

// GGX NDF
float d_GGX(float NH, float alphaRoughness) {
  float roughnessSqr = alphaRoughness * alphaRoughness;
  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

float d_torrance_reiz(float NH, float c3) {
  float CosSquared = NH*NH;
  float TanSquared = (1.0 - CosSquared)/CosSquared;
  //return (1.0/M_PI) * sq(c3/(CosSquared * (c3*c3 + TanSquared)));  // gamma = 2, aka GGX
  return (1.0/sqrt(M_PI)) * (sq(c3)/(CosSquared * (c3*c3 + TanSquared))); // gamma = 1, D_Berry
}

float d_beckmann(float NH, float m) {
  float co = 1.0 / (4.0 * m * m * NH * NH * NH * NH);
  float expx = exp((NH * NH - 1.0) / (m * m * NH * NH));
  return co * expx;
}

// the same as glTF WebGL sample
// https://github.com/KhronosGroup/glTF-WebGL-PBR/blob/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders/pbr-frag.glsl#L188
// That is, Unreal Engine based approach, but modified to use alphaRoughness (squared artist's roughness parameter),
// and based on 'Separable Masking and Shadowing' approximation (propesed by Christophe Schlick)
// https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf
float g_shielding(float NL, float NV, float alphaRoughness) {
  float r = alphaRoughness;

  // Local Shadowing using "Schlick-Smith" Masking Function
  float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));

  // Local Masking using "Schlick-Smith" Masking Function
  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));

  return localShadowing * localMasking;
}

// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
float v_GGXCorrelated(float NL, float NV, float alphaRoughness) {
  float a2 = alphaRoughness * alphaRoughness;
  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  float GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  return 0.5 / (GGXV + GGXL);
}

float v_GGXCorrelatedFast(float NL, float NV, float alphaRoughness) {
  float a = alphaRoughness;
  float GGXV = NL * (NV * (1.0 - a) + a);
  float GGXL = NV * (NL * (1.0 - a) + a);
  return 0.5 / (GGXV + GGXL);
}

// The Schlick Approximation to Fresnel
float fresnel(float f0, float f90, float VdotH) {
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

vec3 fresnel(vec3 f0, vec3 f90, float VdotH) {
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

vec3 fresnel(vec3 f0, float f90, float VdotH)
{
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

float fresnel(float f0, float VdotH)
{
  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnel(f0, f90, VdotH);
}
vec3 fresnel(vec3 f0, float VdotH)
{
  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnel(f0, f90, VdotH);
}

vec3 cook_torrance_specular_brdf(float NH, float NL, float NV, vec3 F, float alphaRoughness, float specularWeight) {
  float D = d_GGX(NH, alphaRoughness);
  float V = v_GGXCorrelated(NL, NV, alphaRoughness);
  return vec3(D) * vec3(V) * F * specularWeight;
//      float G = g_shielding(NL, NV, alphaRoughness);
//      return vec3(D)*vec3(G)*F/vec3(4.0*NL*NV);

}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf
vec3 BRDF_lambertian(vec3 albedo, vec3 F, float specularWeight)
{
  // (1/pi) * diffuseAlbedo
  return (vec3(1.0) - specularWeight * F) * albedo * RECIPROCAL_PI;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#specular-brdf
float specular_brdf(float alphaRoughness, float NdotL, float NdotV, float NdotH) {
  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  float D = d_GGX(NdotH, alphaRoughness);
  return V * D;
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes
float specular_btdf(float alphaRoughness, float NdotL, float NdotV, float NdotHt) {
  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  float D = d_GGX(NdotHt, alphaRoughness);
  return V * D;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel
vec3 conductor_fresnel(vec3 f0, float brdf, float alphaRoughness, float VdotH) {
  return vec3(brdf) * (f0.rgb + (vec3(1.0) - f0.rgb) * vec3(pow(1.0 - abs(VdotH), 5.0)));
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel
vec3 fresnel_mix(float ior, vec3 base, vec3 layer, float VdotH) {
  float f0 = pow((1.0 - ior)/(1.0 + ior), 2.0);
  float fr = f0 + (1.0 - f0) * pow(1.0 - abs(VdotH), 5.0);
  return mix(base, layer, fr);
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf
vec3 metal_brdf(float perceptualRoughness, vec3 baseColor, float NdotL, float NdotV, float NdotH, float VdotH) {
  float alphaRoughness = perceptualRoughness * perceptualRoughness;
  return conductor_fresnel(
    baseColor,
    specular_brdf(alphaRoughness, NdotL, NdotV, NdotH),
    alphaRoughness,
    VdotH
  );
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf
// vec3 dielectric_brdf(float ior, vec3 baseColor, float perceptualRoughness, float NdotL, float NdotV, float NdotH, float VdotH) {
//   vec3 base = BRDF_lambertian(baseColor);
//   float alphaRoughness = perceptualRoughness * perceptualRoughness;
//   vec3 layer = vec3(specular_brdf(alphaRoughness, NdotL, NdotV, NdotH));
//   return fresnel_mix(ior, base, layer, VdotH);
// }

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering
vec3 coated_material_s(vec3 base, float perceptualRoughness, float clearcoatRoughness, float clearcoat, float VdotNc, float LdotNc, float NdotHc) {
  float clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);
  float clearcoatAlpha = clearcoatRoughness * clearcoatRoughness;
  float alphaRoughness = perceptualRoughness * perceptualRoughness;
  float D = d_GGX(NdotHc, clearcoatAlpha);
  float V = v_GGXCorrelated(LdotNc, VdotNc, clearcoatAlpha);
  float f_clearcoat = clearcoatFresnel * D * V;

  // base = (f_diffuse + f_specular) in https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering
  return base * vec3(1.0 - clearcoat * clearcoatFresnel) + vec3(f_clearcoat * clearcoat);
}
vec3 srgbToLinear(vec3 srgbColor) {
  return pow(srgbColor, vec3(2.2));
}

float srgbToLinear(float value) {
  return pow(value, 2.2);
}

vec3 linearToSrgb(vec3 linearColor) {
  return pow(linearColor, vec3(1.0/2.2));
}

float linearToSrgb(float value) {
  return pow(value, 1.0/2.2);
}

// Roughness Dependent Fresnel
// https://www.jcgt.org/published/0008/01/03/paper.pdf
vec3 fresnelSchlickRoughness(vec3 F0, float cosTheta, float roughness)
{
  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;
  vec3 k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);
  return k_S;
}

// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66
vec3 Schlick_to_F0(vec3 f, vec3 f90, float VdotH) {
    float x = clamp(1.0 - VdotH, 0.0, 1.0);
    float x2 = x * x;
    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

float Schlick_to_F0(float f, float f90, float VdotH) {
    float x = clamp(1.0 - VdotH, 0.0, 1.0);
    float x2 = x * x;
    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

vec3 Schlick_to_F0(vec3 f, float VdotH) {
    return Schlick_to_F0(f, vec3(1.0), VdotH);
}

float Schlick_to_F0(float f, float VdotH) {
    return Schlick_to_F0(f, 1.0, VdotH);
}

vec3 normalBlendingUDN(sampler2D baseMap, sampler2D detailMap, vec2 baseUv, vec2 detailUv) {
  vec3 t = texture(baseMap,   baseUv).xyz * 2.0 - 1.0;
  vec3 u = texture(detailMap, detailUv).xyz * 2.0 - 1.0;
  vec3 r = normalize(vec3(t.xy + u.xy, t.z));
  return r;
}

vec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {
  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  mat3 rotationMat = mat3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  mat3 matrix = translationMat * rotationMat * scaleMat;
  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;

  return uvTransformed;
}

float IsotropicNDFFiltering(vec3 normal, float roughness2) {
  float SIGMA2 = 0.15915494;
  float KAPPA = 0.18;
  vec3 dndu = dFdx(normal);
  vec3 dndv = dFdy(normal);
  float kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));
  float clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);
  float filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);
  return filteredRoughness2;
}


////////////////////////////////////////
// glTF KHR_materials_volume
////////////////////////////////////////

#ifdef RN_USE_VOLUME
// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
vec3 volumeAttenuation(vec3 attenuationColor, float attenuationDistance, vec3 intensity, float transmissionDistance)
{
  if (attenuationDistance == 0.0) { // means Infinite distance
    return intensity; // No attenuation
  } else {
    vec3 attenuationCo = -log(attenuationColor) / attenuationDistance;
    vec3 attenuatedTransmittance = exp(-attenuationCo * transmissionDistance);
    return intensity * attenuatedTransmittance;
  }
}
#endif






////////////////////////////////////////
// glTF KHR_materials_anisotropy
////////////////////////////////////////
#ifdef RN_USE_ANISOTROPY
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
float D_GGX_anisotropic(float NdotH, float TdotH, float BdotH, float at, float ab)
{
    float a2 = at * ab;
    vec3 f = vec3(ab * TdotH, at * BdotH, a2 * NdotH);
    float w2 = a2 / dot(f, f);
    return a2 * w2 * w2 / M_PI;
}

float V_GGX_anisotropic(float NdotL, float NdotV, float BdotV, float TdotV, float TdotL, float BdotL,
    float at, float ab)
{
    float GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));
    float GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));
    float v = 0.5 / (GGXV + GGXL);
    return clamp(v, 0.0, 1.0);
}

vec3 BRDF_specularAnisotropicGGX(vec3 F, float alphaRoughness,
    float VdotH, float NdotL, float NdotV, float NdotH, float BdotV, float TdotV,
    float TdotL, float BdotL, float TdotH, float BdotH, float anisotropy)
{
    float at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
    float ab = alphaRoughness;

    float V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);
    float D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);

    return F * V * D;
}
#endif



////////////////////////////////////////
// glTF KHR_materials_sheen
////////////////////////////////////////

#ifdef RN_USE_SHEEN
float d_Charlie(float sheenPerceptualRoughness, float NoH) {
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  float alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;
  float invAlpha  = 1.0 / alphaG;
  float cos2h = NoH * NoH;
  float sin2h = 1.0 - cos2h;
  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
float sheenSimpleVisibility(float NdotL, float NdotV) {
  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
float charlieL(float x, float alphaG) {
  float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
  float a = mix(21.5473, 25.3245, oneMinusAlphaSq);
  float b = mix(3.82987, 3.32435, oneMinusAlphaSq);
  float c = mix(0.19823, 0.16801, oneMinusAlphaSq);
  float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
  float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
  return a / (1.0 + b * pow(x, c)) + d * x + e;
}

float lambdaSheen(float cosTheta, float alphaG)
{
  return abs(cosTheta) < 0.5 ? exp(charlieL(cosTheta, alphaG)) : exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG));
}

float sheenCharlieVisibility(float NdotL, float NdotV, float sheenPerceptualRoughness) {
  float alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;
  float sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));
  return sheenVisibility;
}

vec3 sheen_brdf(vec3 sheenColor, float sheenPerceptualRoughness, float NdotL, float NdotV, float NdotH) {
  float sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);
  float sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);
  return sheenColor * sheenDistribution * sheenVisibility;
}
#endif









////////////////////////////////////////
// glTF KHR_materials_irirdescence
////////////////////////////////////////

#ifdef RN_USE_IRIDESCENCE
// XYZ to REC709(sRGB) conversion matrix
const mat3 XYZ_TO_REC709 = mat3(
     3.2404542, -0.9692660,  0.0556434,
    -1.5371385,  1.8760108, -0.2040259,
    -0.4985314,  0.0415560,  1.0572252
);

vec3 fresnelSchlickRoughnessWithIridescence(
  vec3 F0, float cosTheta, float roughness,
  vec3 iridescenceFresnel, float iridescence
  )
{
  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;
  vec3 k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);
  return k_S;
}

// Assume air interface for top
vec3 Fresnel0ToIor(vec3 F0) {
    vec3 sqrtF0 = sqrt(F0);
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// Conversion from IOR to F0
// ior is a value between 1.0 and 3.0. 1.0 is air interface
vec3 IorToFresnel0(vec3 transmittedIor, float incidentIor) {
    return sq((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
float IorToFresnel0(float transmittedIor, float incidentIor) {
    return sq((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration
 */
vec3 evalSensitivity(float OPD, vec3 shift) {
    float phase = 2.0 * M_PI * OPD * 1.0e-9;
    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);

    vec3 xyz = val * sqrt(2.0 * M_PI * var) * cos(pos * phase + shift) * exp(-(phase * phase) * var);
    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));
    xyz /= 1.0685e-7;

    vec3 rgb = XYZ_TO_REC709 * xyz;
    return rgb;
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel
 */
vec3 calcIridescence(float outsideIor, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {


  // iridescenceIor is the index of refraction of the thin-film layer
  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
  float iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));

  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)
  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.
  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.
  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):
  float sinTheta2Sq = sq(outsideIor / iridescenceIor) * (1.0 - sq(cosTheta1));
  float cosTheta2Sq = 1.0 - sinTheta2Sq;

  // Handle total internal reflection
  if (cosTheta2Sq < 0.0) {
      return vec3(1.0);
  }

  float cosTheta2 = sqrt(cosTheta2Sq);

  /// Material Interfaces
  // The iridescence model defined by Belcour/Barla models two material interfaces
  // - one from the outside to the thin-film layer
  // and another one from the thin-film to the base material. These two interfaces are defined as follows:

  // First interface (from the outside to the thin-film layer)
  float R0 = IorToFresnel0(iridescenceIor, outsideIor);
  float R12 = fresnel(R0, cosTheta1);
  float R21 = R12;
  float T121 = 1.0 - R12;

  // Second interface (from the thin-film to the base material)
  vec3 baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0
  vec3 R1 = IorToFresnel0(baseIor, iridescenceIor);
  vec3 R23 = fresnel(R1, cosTheta2);

  // phi12 and phi23 define the base phases per interface and are approximated with 0.0
  // if the IOR of the hit material (iridescenceIor or baseIor) is higher
  // than the IOR of the previous material (outsideIor or iridescenceIor) and \u03C0 otherwise.
  // Also here, polarization is ignored.  float phi12 = 0.0;

  // First interface (from the outside to the thin-film layer)
  float phi12 = 0.0;
  if (iridescenceIor < outsideIor) phi12 = M_PI;
  float phi21 = M_PI - phi12;

  // Second interface (from the thin-film to the base material)
  vec3 phi23 = vec3(0.0);
  if (baseIor[0] < iridescenceIor) phi23[0] = M_PI;
  if (baseIor[1] < iridescenceIor) phi23[1] = M_PI;
  if (baseIor[2] < iridescenceIor) phi23[2] = M_PI;

  // OPD (optical path difference)
  float OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
  // Phase shift
  vec3 phi = vec3(phi21) + phi23;

  // Compound terms
  vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);
  vec3 r123 = sqrt(R123);
  vec3 Rs = (T121 * T121) * R23 / (vec3(1.0) - R123);

  // Reflectance term for m = 0 (DC term amplitude)
  vec3 C0 = R12 + Rs;
  vec3 I = C0;

  // Reflectance term for m > 0 (pairs of diracs)
  vec3 Cm = Rs - T121;
  for (int m = 1; m <= 2; ++m)
  {
      Cm *= r123;
      vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);
      I += Cm * Sm;
  }

  vec3 F_iridescence = max(I, vec3(0.0));

  return F_iridescence;
}

//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB
vec3 BRDF_lambertianIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float iridescenceFactor, vec3 diffuseColor, float specularWeight, float VdotH)
{
    vec3 iridescenceFresnelMax = vec3(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));
    vec3 schlickFresnel = Schlick_to_F0(f0, f90, VdotH);
    vec3 F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);

    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);
}

vec3 BRDF_specularGGXIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float alphaRoughness, float iridescenceFactor, float specularWeight, float VdotH, float NdotL, float NdotV, float NdotH)
{
    vec3 F = mix(Schlick_to_F0(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);
    float Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
    float D = d_GGX(NdotH, alphaRoughness);

    return specularWeight * F * Vis * D;
}

#endif // RN_USE_IRIDESCENCE





////////////////////////////////////////
// lighting with a punctual light
////////////////////////////////////////
vec3 lightingWithPunctualLight(
  Light light,
  vec3 normal_inWorld,
  vec3 viewDirection,
  float NdotV,
  vec3 albedo,
  float perceptualRoughness,
  float metallic,
  vec3 F0,
  vec3 F90,
  float ior,
  float transmission,
  float clearcoat,
  float clearcoatRoughness,
  vec3 clearcoatNormal_inWorld,
  float VdotNc,
  vec3 attenuationColor,
  float attenuationDistance,
  float anisotropy,
  vec3 anisotropicT,
  vec3 anisotropicB,
  float BdotV,
  float TdotV,
  vec3 sheenColor,
  float sheenRoughness,
  float albedoSheenScalingNdotV,
  float iridescenceFactor,
  vec3 iridescenceFresnel,
  float specularWeight
  )
{
  float alphaRoughness = perceptualRoughness * perceptualRoughness;

  // Fresnel
  vec3 halfVector = normalize(light.direction + viewDirection);
  float VdotH = dot(viewDirection, halfVector);
  vec3 F = fresnel(F0, F90, VdotH);

  float NdotL = saturateEpsilonToOne(dot(normal_inWorld, light.direction));

  // Diffuse
#ifdef RN_USE_IRIDESCENCE
  vec3 diffuseBrdf = BRDF_lambertianIridescence(F0, F90, iridescenceFresnel, iridescenceFactor, albedo, specularWeight, VdotH);
#else
  vec3 diffuseBrdf = BRDF_lambertian(albedo, F, specularWeight);
#endif

  vec3 pureDiffuse = diffuseBrdf * vec3(NdotL) * light.attenuatedIntensity;

#ifdef RN_USE_TRANSMISSION
  vec3 refractionVector = refract(-viewDirection, normal_inWorld, 1.0 / ior);
  Light transmittedLightFromUnderSurface = light;
  transmittedLightFromUnderSurface.pointToLight -= refractionVector;
  vec3 transmittedLightDirectionFromUnderSurface = normalize(transmittedLightFromUnderSurface.pointToLight);
  transmittedLightFromUnderSurface.direction = transmittedLightDirectionFromUnderSurface;

  vec3 Ht = normalize(viewDirection + transmittedLightFromUnderSurface.direction);
  float NdotHt = saturateEpsilonToOne(dot(normal_inWorld, Ht));
  float NdotLt = saturateEpsilonToOne(dot(normal_inWorld, transmittedLightFromUnderSurface.direction));

  vec3 transmittedContrib = (vec3(1.0) - F) * specular_btdf(alphaRoughness, NdotLt, NdotV, NdotHt) * albedo * transmittedLightFromUnderSurface.attenuatedIntensity;

#ifdef RN_USE_VOLUME
  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittedLightFromUnderSurface.pointToLight));
#endif // RN_USE_VOLUME

  vec3 diffuseContrib = mix(pureDiffuse, vec3(transmittedContrib), transmission);
#else
  vec3 diffuseContrib = pureDiffuse;
#endif // RN_USE_TRANSMISSION

  // Specular
  float NdotH = saturateEpsilonToOne(dot(normal_inWorld, halfVector));

#ifdef RN_USE_IRIDESCENCE
  vec3 specularContrib = BRDF_specularGGXIridescence(F0, F90, iridescenceFresnel, alphaRoughness, iridescenceFactor, specularWeight, VdotH, NdotL, NdotV, NdotH) * vec3(NdotL) * light.attenuatedIntensity;
#elif defined(RN_USE_ANISOTROPY)
  float TdotL = dot(anisotropicT, light.direction);
  float BdotL = dot(anisotropicB, light.direction);
  float TdotH = dot(anisotropicT, halfVector);
  float BdotH = dot(anisotropicB, halfVector);
  vec3 specularContrib = BRDF_specularAnisotropicGGX(F, alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3(NdotL) * light.attenuatedIntensity;
#else
  vec3 specularContrib = cook_torrance_specular_brdf(NdotH, NdotL, NdotV, F, alphaRoughness, specularWeight) * vec3(NdotL) * light.attenuatedIntensity;
#endif // RN_USE_ANISOTROPY

  // Base Layer
  vec3 baseLayer = diffuseContrib + specularContrib;

#ifdef RN_USE_SHEEN
  // Sheen
  vec3 sheenContrib = sheen_brdf(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;
  float albedoSheenScaling = min(
    albedoSheenScalingNdotV,
    1.0 - max3(sheenColor) * texture(u_sheenLutTexture, vec2(NdotL, sheenRoughness)).r);
  vec3 color = sheenContrib + baseLayer * albedoSheenScaling;
#else
  vec3 color = baseLayer;
  float albedoSheenScaling = 1.0;
#endif // RN_USE_SHEEN

#ifdef RN_USE_CLEARCOAT
  // Clear Coat Layer
  float NdotHc = saturateEpsilonToOne(dot(clearcoatNormal_inWorld, halfVector));
  float LdotNc = saturateEpsilonToOne(dot(light.direction, clearcoatNormal_inWorld));
  vec3 coated = coated_material_s(color, perceptualRoughness,
    clearcoatRoughness, clearcoat, VdotNc, LdotNc, NdotHc);
  vec3 finalColor = coated;
#else
  vec3 finalColor = color;
#endif // RN_USE_CLEARCOAT

  return finalColor;
}


/* shaderity: @{matricesGetters} */

#ifdef RN_USE_SHADOW_MAPPING
  uniform float u_pointLightFarPlane; // initialValue=1000.0
#endif

#ifdef RN_USE_SHADOW_MAPPING

const float g_minVariance = 0.00001;

float chebyshevUpperBound(vec2 moments, float t) {
  float p = (t <= moments.x) ? 1.0 : 0.0;

  float variance = moments.y - sq(moments.x);
  variance = max(variance, g_minVariance);

  float d = t - moments.x;
  float p_max = variance / (variance + sq(d));

  return max(p, p_max);
}

float varianceShadowContribution(vec2 lightTexCoord, float distanceToLight) {
  vec2 moments = texture(u_depthTexture, lightTexCoord).xy;

  return chebyshevUpperBound(moments, distanceToLight);
}

float varianceShadowContributionParaboloid(vec3 worldPos, vec3 lightPos, float farPlane) {
  vec3 L = worldPos - lightPos;
  float currentDist = length(L);
  vec3 Lnorm = normalize(L);

  // Determine whether it is front or back simply by the sign of the z component
  bool isFront = (Lnorm.z >= 0.0);

  // Denominators for paraboloid projection
  float denom = 1.0 + (isFront ? Lnorm.z : -Lnorm.z);

  // Convert to UV coordinates (normalized)
  // Lnorm.xy / denom is in [-1,1], so map it to [0,1]
  vec2 uv = (Lnorm.xy / denom) * 0.5 + 0.5;

  vec2 storedMoments = isFront
      ? texture(u_paraboloidDepthTexture, uv).rg
      : texture(u_paraboloidDepthTexture, uv).ba;

  float currentDepth = currentDist / farPlane;


  return chebyshevUpperBound(storedMoments, currentDepth);

  // float shadow = (currentDepth > storedMoments.r + 0.00001) ? 0.5 : 1.0;
  // return shadow;
}


#endif


vec3 get_irradiance(vec3 normal_forEnv, float materialSID, ivec2 hdriFormat) {
  vec4 diffuseTexel = texture(u_diffuseEnvTexture, normal_forEnv);

  vec3 irradiance;
  if (hdriFormat.x == 0) {
    // LDR_SRGB
    irradiance = srgbToLinear(diffuseTexel.rgb);
  }
  else if (hdriFormat.x == 3) {
    // RGBE
    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  }
  else {
    irradiance = diffuseTexel.rgb;
  }

  return irradiance;
}

float scaleForLod(float perceptualRoughness, float ior)
{
  // Scale roughness to the range [0, 1],
  // ior=1.0 will be scale 0,
  // ior=1.5 will be scale 1.0,
  // ior=2 will be scale 1.0 (clamped)
  //

  float scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);
  return perceptualRoughness * scale;
}

#ifdef RN_USE_TRANSMISSION
vec3 get_sample_from_backbuffer(float materialSID, vec2 sampleCoord, float perceptualRoughness, float ior) {
  ivec2 vrState = get_vrState(0.0, 0);
  vec2 backBufferTextureSize = vec2(textureSize(u_backBufferTexture, 0));
  float backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);

#ifdef WEBGL2_MULTI_VIEW
  // For VR
  backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
  sampleCoord.x = sampleCoord.x * 0.5;
  if (v_displayIdx == 1.0) { // For right eye
    sampleCoord.x += 0.5;
  }
#else
  if (vrState.x == 1) { // For VR
    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
    sampleCoord.x = sampleCoord.x * 0.5;
    if (vrState.y == 1) { // For right eye
      sampleCoord.x += 0.5;
    }
  }
#endif

  float framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);

  #ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
    vec3 transmittedLight = texture2DLodEXT(u_backBufferTexture, sampleCoord, framebufferLod).rgb;
  #elif defined(GLSL_ES3)
    vec3 transmittedLight = textureLod(u_backBufferTexture, sampleCoord, framebufferLod).rgb;
  #else
    vec3 transmittedLight = texture(u_backBufferTexture, sampleCoord).rgb;
  #endif

  return transmittedLight;
}
#endif

vec3 get_radiance(vec3 reflection, float lod, ivec2 hdriFormat) {
  #ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
    vec4 specularTexel = textureCubeLodEXT(u_specularEnvTexture, reflection, lod);
  #elif defined(GLSL_ES3)
    vec4 specularTexel = textureLod(u_specularEnvTexture, reflection, lod);
  #else
    vec4 specularTexel = texture(u_specularEnvTexture, reflection);
  #endif

// #pragma shaderity: require(./../common/fetchCubeTexture.glsl)

  vec3 radiance;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer
vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior)
{
  vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);
  mat4 worldMatrix = get_worldMatrix(v_instanceInfo);

  vec3 modelScale;
  modelScale.x = length(vec3(worldMatrix[0].xyz));
  modelScale.y = length(vec3(worldMatrix[1].xyz));
  modelScale.z = length(vec3(worldMatrix[2].xyz));

  return normalize(refractionVector) * thickness * modelScale;
}

struct IblResult
{
  vec3 specular;
  vec3 diffuse;
  vec3 FssEss;
};

#ifdef RN_USE_IRIDESCENCE
IblResult getIBLRadianceGGXWithIridescence(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,
  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,
  vec3 normal_forEnv, vec3 reflection, vec3 iridescenceFresnel, float iridescence, float specularWeight)
{
  // get radiance
  float mipCount = iblParameter.x;
  float lod = (perceptualRoughness * (mipCount - 1.0));
  vec3 radiance = get_radiance(reflection, lod, hdriFormat);

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughnessWithIridescence(F0, NdotV, perceptualRoughness, iridescenceFresnel, iridescence);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = kS * f_ab.x + f_ab.y;
  IblResult result;
  result.FssEss = FssEss;

  // Specular IBL
  vec3 specular = FssEss * radiance * specularWeight;

  // scale with user parameters
  float IBLSpecularContribution = iblParameter.z;
  specular *= IBLSpecularContribution;

  result.specular = specular;

  return result;
}

IblResult getIBLRadianceLambertianWithIridescence(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,
  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,
  vec3 normal_forEnv, vec3 reflection, vec3 iridescenceF0, float iridescence, float specularWeight)
{
  // get irradiance
  vec3 irradiance = get_irradiance(normal_forEnv, materialSID, hdriFormat);

  // Use the maximum component of the iridescence Fresnel color
  // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF
  vec3 iridescenceF0Max = vec3(max(max(iridescenceF0.r, iridescenceF0.g), iridescenceF0.b));

  // Blend between base F0 and iridescence F0
  vec3 mixedF0 = mix(F0, iridescenceF0Max, iridescence);

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughness(mixedF0, NdotV, perceptualRoughness);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = specularWeight * kS * f_ab.x + f_ab.y;
  IblResult result;
  result.FssEss = FssEss;

  // Multiple scattering, Fdez-Aguera's approach
  float Ems = (1.0 - (f_ab.x + f_ab.y));
  vec3 F_avg = specularWeight * (mixedF0 + (1.0 - mixedF0) / 21.0);
  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);
  vec3 k_D = albedo * (1.0 - FssEss - FmsEms);

  // Diffuse IBL
  vec3 diffuse = (FmsEms + k_D) * irradiance;

  // scale with user parameters
  float IBLDiffuseContribution = iblParameter.y;
  diffuse *= IBLDiffuseContribution;

  result.diffuse = diffuse;

  return result;
}
#endif // RN_USE_IRIDESCENCE

IblResult getIBLRadianceLambertian(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,
  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,
  vec3 normal_forEnv, vec3 reflection, float specularWeight)
{
  // get irradiance
  vec3 irradiance = get_irradiance(normal_forEnv, materialSID, hdriFormat);

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = specularWeight * kS * f_ab.x + f_ab.y;
  IblResult result;
  result.FssEss = FssEss;

  // Multiple scattering, Fdez-Aguera's approach
  float Ems = (1.0 - (f_ab.x + f_ab.y));
  vec3 F_avg = specularWeight * (F0 + (1.0 - F0) / 21.0);
  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);
  vec3 k_D = albedo * (1.0 - FssEss - FmsEms);

  // Diffuse IBL
  vec3 diffuse = (FmsEms + k_D) * irradiance;

  // scale with user parameters
  float IBLDiffuseContribution = iblParameter.y;
  diffuse *= IBLDiffuseContribution;

  result.diffuse = diffuse;

  return result;
}

IblResult getIBLRadianceGGX(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,
  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,
  vec3 normal_forEnv, vec3 reflection, float specularWeight)
{
  // get radiance
  float mipCount = iblParameter.x;
  float lod = (perceptualRoughness * (mipCount - 1.0));
  vec3 radiance = get_radiance(reflection, lod, hdriFormat);

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = kS * f_ab.x + f_ab.y;
  IblResult result;
  result.FssEss = FssEss;

  // Specular IBL
  vec3 specular = FssEss * radiance * specularWeight;

  // scale with user parameters
  float IBLSpecularContribution = iblParameter.z;
  specular *= IBLSpecularContribution;

  result.specular = specular;

  return result;
}

#ifdef RN_USE_SHEEN
vec3 sheenIBL(float NdotV, float sheenPerceptualRoughness, vec3 sheenColor, vec4 iblParameter, vec3 reflection, ivec2 hdriFormat)
{
  float mipCount = iblParameter.x;
  float lod = (sheenPerceptualRoughness * (mipCount - 1.0));

  vec2 sheenLutUV = vec2(NdotV, sheenPerceptualRoughness);
  float brdf = texture(u_sheenLutTexture, sheenLutUV).b;
  vec3 sheenLight = get_radiance(reflection, lod, hdriFormat);
  float IBLSpecularContribution = iblParameter.z;
  sheenLight *= IBLSpecularContribution;

  return sheenLight * sheenColor * brdf;
}
#endif

vec3 getNormalForEnv(mat3 rotEnvMatrix, vec3 normal_inWorld, float materialSID) {
  vec3 normal_forEnv = rotEnvMatrix * normal_inWorld;
  if (get_inverseEnvironment(materialSID, 0)) {
    normal_forEnv.x *= -1.0;
  }
  return normal_forEnv;
}

vec3 getReflection(mat3 rotEnvMatrix, vec3 viewDirection, vec3 normal_inWorld, float materialSID, float perceptualRoughness, float anisotropy, vec3 anisotropyDirection) {
#ifdef RN_USE_ANISOTROPY

  float tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);
  vec3  anisotropicTangent  = cross(anisotropyDirection, viewDirection);
  vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);
  float bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);
  float bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;
  vec3  bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));
  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);
#else
  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);
#endif
  if (get_inverseEnvironment(materialSID, 0)) {
    reflection.x *= -1.0;
  }
  return reflection;
}

vec3 IBLContribution(float materialSID, vec3 normal_inWorld, float NdotV, vec3 viewDirection,
  vec3 albedo, vec3 F0, float perceptualRoughness, float clearcoatRoughness, vec3 clearcoatNormal_inWorld,
  float clearcoat, float VdotNc, vec3 geomNormal_inWorld, float cameraSID, float transmission, vec3 v_position_inWorld,
  float thickness, vec3 sheenColor, float sheenRoughness, float albedoSheenScalingNdotV, float ior,
  vec3 iridescenceFresnel, vec3 iridescenceF0, float iridescence, float anisotropy, vec3 anisotropyDirection,
  float specularWeight)
{
  vec4 iblParameter = get_iblParameter(materialSID, 0);
  float rot = iblParameter.w;
  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);

  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  vec3 reflection = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);

  // IBL
  #ifdef RN_USE_IRIDESCENCE
    IblResult baseRadianceResult = getIBLRadianceGGXWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,
      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceFresnel, iridescence, specularWeight);
    IblResult baseLambertianResult = getIBLRadianceLambertianWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,
      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceF0, iridescence, specularWeight);
  #else
    IblResult baseRadianceResult = getIBLRadianceGGX(materialSID, NdotV, viewDirection, albedo, F0,
      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);
    IblResult baseLambertianResult = getIBLRadianceLambertian(materialSID, NdotV, viewDirection, albedo, F0,
      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);
  #endif

#ifdef RN_USE_TRANSMISSION
  vec3 refractedRay = getVolumeTransmissionRay(geomNormal_inWorld, viewDirection, thickness, ior);
  vec3 refractedRayFromVPosition = v_position_inWorld + refractedRay;
  vec4 ndcPoint = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4(refractedRayFromVPosition, 1.0);
  vec2 refractionCoords = ndcPoint.xy / ndcPoint.w;
  refractionCoords += 1.0;
  refractionCoords /= 2.0;
  vec3 transmittedLight = get_sample_from_backbuffer(materialSID, refractionCoords, perceptualRoughness, ior);

#ifdef RN_USE_VOLUME
  vec3 attenuationColor = get_attenuationColor(materialSID, 0);
  float attenuationDistance = get_attenuationDistance(materialSID, 0);
  transmittedLight = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, length(refractedRay));
#endif

  vec3 transmissionComp = (vec3(1.0) - baseRadianceResult.FssEss) * transmittedLight * albedo;
  vec3 diffuse = mix(baseLambertianResult.diffuse, transmissionComp, transmission);
  vec3 base = diffuse + baseRadianceResult.specular;
#else
  vec3 base = baseLambertianResult.diffuse + baseRadianceResult.specular;
#endif

#ifdef RN_USE_SHEEN
  vec3 sheen = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);
  vec3 color = sheen + base * albedoSheenScalingNdotV;
#else
  vec3 color = base;
#endif

#ifdef RN_USE_CLEARCOAT
  float VdotNg = dot(geomNormal_inWorld, viewDirection);
  vec3 clearcoatNormal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  IblResult coatResult = getIBLRadianceGGX(materialSID, VdotNc, viewDirection, vec3(0.0), F0,
    clearcoatRoughness, iblParameter, hdriFormat, rotEnvMatrix, clearcoatNormal_forEnv, reflection, specularWeight);
  vec3 coatLayer = coatResult.specular;

  float clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);
  vec3 coated = color * vec3(1.0 - clearcoat * clearcoatFresnel) + vec3(coatLayer * clearcoat);
  return coated;
#else
  return color;
#endif

}


float edge_ratio(vec3 bary3, float wireframeWidthInner, float wireframeWidthRelativeScale) {
  vec3 d = fwidth(bary3);
  vec3 x = bary3+vec3(1.0 - wireframeWidthInner)*d;
  vec3 a3 = smoothstep(vec3(0.0), d, x);
  float factor = min(min(a3.x, a3.y), a3.z);

  return clamp((1.0 - factor), 0.0, 1.0);
}

vec2 getTexcoord(int texcoordIndex) {
  vec2 texcoord;
  if(texcoordIndex == 2){
    texcoord = v_texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = v_texcoord_1;
  }else{
    texcoord = v_texcoord_0;
  }
  return texcoord;
}

#ifdef RN_USE_TANGENT
  mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {
    vec3 tangent_inWorld = normalize(v_tangent_inWorld);
    vec3 binormal_inWorld = normalize(v_binormal_inWorld);
    mat3 tbnMat_tangent_to_world = mat3(tangent_inWorld, binormal_inWorld, normal_inWorld);

    return tbnMat_tangent_to_world;
  }
#else
    // This is based on http://www.thetenthplanet.de/archives/1180
    mat3 cotangent_frame(vec3 normal_inWorld, vec3 position, vec2 uv) {
      uv = gl_FrontFacing ? uv : -uv;

      // get edge vectors of the pixel triangle
      vec3 dp1 = dFdx(position);
      vec3 dp2 = dFdy(position);
      vec2 duv1 = dFdx(uv);
      vec2 duv2 = dFdy(uv);

      // solve the linear system
      vec3 dp2perp = cross(dp2, normal_inWorld);
      vec3 dp1perp = cross(normal_inWorld, dp1);
      vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;
      vec3 bitangent = dp2perp * duv1.y + dp1perp * duv2.y;
      bitangent *= -1.0;

      // construct a scale-invariant frame
      float invMat = inversesqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));
      return mat3(tangent * invMat, bitangent * invMat, normal_inWorld);
    }

    mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {
      mat3 tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord);

      return tbnMat_tangent_to_world;
    }
#endif


void main ()
{

#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  // View direction
  vec3 viewPosition = get_viewPosition(cameraSID, 0);
  vec3 viewVector = viewPosition - v_position_inWorld.xyz;
  vec3 viewDirection = normalize(viewVector);

  // BaseColor
  vec3 baseColor = vec3(0.0, 0.0, 0.0);
  float alpha = 1.0;
  vec4 baseColorFactor = get_baseColorFactor(materialSID, 0);
  if (v_color != baseColor && baseColorFactor.rgb != baseColor) {
    baseColor = v_color * baseColorFactor.rgb;
    alpha = baseColorFactor.a;
  } else if (v_color == baseColor) {
    baseColor = baseColorFactor.rgb;
    alpha = baseColorFactor.a;
  } else if (baseColorFactor.rgb == baseColor) {
    baseColor = v_color;
  } else {
    baseColor = vec3(1.0, 1.0, 1.0);
  }
  vec4 baseColorTextureTransform = get_baseColorTextureTransform(materialSID, 0);
  float baseColorTextureRotation = get_baseColorTextureRotation(materialSID, 0);
  int baseColorTexcoordIndex = get_baseColorTexcoordIndex(materialSID, 0);
  vec2 baseColorTexcoord = getTexcoord(baseColorTexcoordIndex);
  vec2 baseColorTexUv = uvTransform(baseColorTextureTransform.xy, baseColorTextureTransform.zw, baseColorTextureRotation, baseColorTexcoord);
  vec4 textureColor = texture(u_baseColorTexture, baseColorTexUv);
  baseColor *= srgbToLinear(textureColor.rgb);
  alpha *= textureColor.a;

#ifdef RN_IS_ALPHA_MODE_MASK
  float alphaCutoff = get_alphaCutoff(materialSID, 0);
  if (alpha < alphaCutoff) {
    discard;
  }
#endif


  // Normal
  vec3 normal_inWorld = normalize(v_normal_inWorld);
  vec3 geomNormal_inWorld = normal_inWorld;
  #ifdef RN_USE_NORMAL_TEXTURE
    vec4 normalTextureTransform = get_normalTextureTransform(materialSID, 0);
    float normalTextureRotation = get_normalTextureRotation(materialSID, 0);
    int normalTexcoordIndex = get_normalTexcoordIndex(materialSID, 0);
    vec2 normalTexcoord = getTexcoord(normalTexcoordIndex);
    vec2 normalTexUv = uvTransform(normalTextureTransform.xy, normalTextureTransform.zw, normalTextureRotation, normalTexcoord);
    mat3 TBN = getTBN(normal_inWorld, viewVector, normalTexUv);
    vec3 normalTexValue = texture(u_normalTexture, normalTexUv).xyz;
    if(normalTexValue.b >= 128.0 / 255.0) {
      // normal texture is existence
      vec3 normalTex = normalTexValue * 2.0 - 1.0;
      float normalScale = get_normalScale(materialSID, 0);
      vec3 scaledNormal = normalize(normalTex * vec3(normalScale, normalScale, 1.0));
      normal_inWorld = normalize(TBN * scaledNormal);
    }
  #endif

#ifdef RN_IS_LIGHTING
  // Metallic & Roughness
  vec2 metallicRoughnessFactor = get_metallicRoughnessFactor(materialSID, 0);
  float metallic = metallicRoughnessFactor.x;
  vec4 metallicRoughnessTextureTransform = get_metallicRoughnessTextureTransform(materialSID, 0);
  float metallicRoughnessTextureRotation = get_metallicRoughnessTextureRotation(materialSID, 0);
  int metallicRoughnessTexcoordIndex = get_metallicRoughnessTexcoordIndex(materialSID, 0);
  vec2 metallicRoughnessTexcoord = getTexcoord(metallicRoughnessTexcoordIndex);
  vec2 metallicRoughnessTexUv = uvTransform(metallicRoughnessTextureTransform.xy, metallicRoughnessTextureTransform.zw, metallicRoughnessTextureRotation, metallicRoughnessTexcoord);
  vec4 ormTexel = texture(u_metallicRoughnessTexture, metallicRoughnessTexUv);
  float perceptualRoughness = ormTexel.g * metallicRoughnessFactor.y;
  metallic = ormTexel.b * metallic;
  metallic = clamp(metallic, 0.0, 1.0);
  perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
  float alphaRoughness = perceptualRoughness * perceptualRoughness;
    // filter NDF for specular AA --- https://jcgt.org/published/0010/02/02/
  float alphaRoughness2 = alphaRoughness * alphaRoughness;
  float filteredRoughness2 = IsotropicNDFFiltering(normal_inWorld, alphaRoughness2);
  perceptualRoughness = sqrt(sqrt(filteredRoughness2));

  // Albedo
  vec3 black = vec3(0.0);
  vec3 albedo = mix(baseColor.rgb, black, metallic);

  // NdotV
  float NdotV = saturateEpsilonToOne(dot(normal_inWorld, viewDirection));

  #ifdef RN_USE_ANISOTROPY
    float anisotropy = get_anisotropyStrength(materialSID, 0);
    vec2 anisotropyRotation = get_anisotropyRotation(materialSID, 0);
    vec2 direction = anisotropyRotation;
    vec3 anisotropyTex = texture(u_anisotropyTexture, baseColorTexUv).rgb;
    direction = anisotropyTex.rg * 2.0 - vec2(1.0);
    direction = mat2(anisotropyRotation.x, anisotropyRotation.y, -anisotropyRotation.y, anisotropyRotation.x) * normalize(direction);
    anisotropy *= anisotropyTex.b;
    vec3 anisotropicT = normalize(TBN * vec3(direction, 0.0));
    vec3 anisotropicB = normalize(cross(geomNormal_inWorld, anisotropicT));
    float BdotV = dot(anisotropicB, viewDirection);
    float TdotV = dot(anisotropicT, viewDirection);
  #else
    float anisotropy = 0.0;
    vec3 anisotropicT = vec3(0.0, 0.0, 0.0);
    vec3 anisotropicB = vec3(0.0, 0.0, 0.0);
    float BdotV = 0.0;
    float TdotV = 0.0;
  #endif

    // Clearcoat
  #ifdef RN_USE_CLEARCOAT
    float clearcoatFactor = get_clearCoatFactor(materialSID, 0);
    vec4 clearcoatTextureTransform = get_clearCoatTextureTransform(materialSID, 0);
    float clearcoatTextureRotation = get_clearCoatTextureRotation(materialSID, 0);
    int clearCoatTexcoordIndex = get_clearCoatTexcoordIndex(materialSID, 0);
    vec2 clearCoatTexcoord = getTexcoord(clearCoatTexcoordIndex);
    vec2 clearcoatTexUv = uvTransform(clearcoatTextureTransform.xy, clearcoatTextureTransform.zw, clearcoatTextureRotation, clearCoatTexcoord);
    float clearcoatTexture = texture(u_clearCoatTexture, clearcoatTexUv).r;
    float clearcoat = clearcoatFactor * clearcoatTexture;
  #else
    float clearcoat = 0.0;
  #endif // RN_USE_CLEARCOAT

    // Transmission
  #ifdef RN_USE_TRANSMISSION
    float transmissionFactor = get_transmissionFactor(materialSID, 0);
    float transmissionTexture = texture(u_transmissionTexture, baseColorTexUv).r;
    float transmission = transmissionFactor * transmissionTexture;
    // alpha *= transmission;
  #else
    float transmission = 0.0;
  #endif // RN_USE_TRANSMISSION

  #ifdef RN_USE_SPECULAR
    float specularTexture = texture(u_specularTexture, baseColorTexUv).a;
    float specular = get_specularFactor(materialSID, 0) * specularTexture;
    vec3 specularColorTexture = srgbToLinear(texture(u_specularColorTexture, baseColorTexUv).rgb);
    vec3 specularColor = get_specularColorFactor(materialSID, 0) * specularColorTexture;
  #else
    float specular = 1.0;
    vec3 specularColor = vec3(1.0, 1.0, 1.0);
  #endif // RN_USE_SPECULAR

  // F0, F90
  float ior = get_ior(materialSID, 0);
  float outsideIor = 1.0;
  vec3 dielectricSpecularF0 = min(
    ((ior - outsideIor) / (ior + outsideIor)) * ((ior - outsideIor) / (ior + outsideIor)) * specularColor,
    vec3(1.0)
    ) * specular;
  vec3 dielectricSpecularF90 = vec3(specular);
  vec3 F0 = mix(dielectricSpecularF0, baseColor.rgb, metallic);
  vec3 F90 = mix(dielectricSpecularF90, vec3(1.0), metallic);

  // Iridescence
  #ifdef RN_USE_IRIDESCENCE
    float iridescenceFactor = get_iridescenceFactor(materialSID, 0);
    float iridescenceTexture = texture(u_iridescenceTexture, baseColorTexUv).r;
    float iridescence = iridescenceFactor * iridescenceTexture;
    float iridescenceIor = get_iridescenceIor(materialSID, 0);
    float thicknessRatio = texture(u_iridescenceThicknessTexture, baseColorTexUv).r;
    float iridescenceThicknessMinimum = get_iridescenceThicknessMinimum(materialSID, 0);
    float iridescenceThicknessMaximum = get_iridescenceThicknessMaximum(materialSID, 0);
    float iridescenceThickness = mix(iridescenceThicknessMinimum, iridescenceThicknessMaximum, thicknessRatio);
    vec3 iridescenceFresnel = calcIridescence(1.0, iridescenceIor, NdotV, iridescenceThickness, F0);
    vec3 iridescenceF0 = Schlick_to_F0(iridescenceFresnel, NdotV);
  #else
    float iridescence = 0.0;
    vec3 iridescenceFresnel = vec3(0.0);
    vec3 iridescenceF0 = F0;
  #endif // RN_USE_IRIDESCENCE

  #ifdef RN_USE_CLEARCOAT
    // Clearcoat
    float clearcoatRoughnessFactor = get_clearCoatRoughnessFactor(materialSID, 0);
    int clearCoatRoughnessTexcoordIndex = get_clearCoatRoughnessTexcoordIndex(materialSID, 0);
    vec2 clearCoatRoughnessTexcoord = getTexcoord(clearCoatRoughnessTexcoordIndex);
    vec4 clearcoatRoughnessTextureTransform = get_clearCoatRoughnessTextureTransform(materialSID, 0);
    float clearcoatRoughnessTextureRotation = get_clearCoatRoughnessTextureRotation(materialSID, 0);
    vec2 clearcoatRoughnessTexUv = uvTransform(clearcoatRoughnessTextureTransform.xy, clearcoatRoughnessTextureTransform.zw, clearcoatRoughnessTextureRotation, clearCoatRoughnessTexcoord);
    float textureRoughnessTexture = texture(u_clearCoatRoughnessTexture, clearcoatRoughnessTexUv).g;
    float clearcoatRoughness = clearcoatRoughnessFactor * textureRoughnessTexture;

    int clearCoatNormalTexcoordIndex = get_clearCoatNormalTexcoordIndex(materialSID, 0);
    vec2 clearCoatNormalTexcoord = getTexcoord(clearCoatNormalTexcoordIndex);
    vec4 clearcoatNormalTextureTransform = get_clearCoatNormalTextureTransform(materialSID, 0);
    float clearcoatNormalTextureRotation = get_clearCoatNormalTextureRotation(materialSID, 0);
    vec2 clearcoatNormalTexUv = uvTransform(clearcoatNormalTextureTransform.xy, clearcoatNormalTextureTransform.zw, clearcoatNormalTextureRotation, clearCoatNormalTexcoord);
    vec3 textureNormal_tangent = texture(u_clearCoatNormalTexture, clearcoatNormalTexUv).xyz * vec3(2.0) - vec3(1.0);
    vec3 clearcoatNormal_inWorld = normalize(TBN * textureNormal_tangent);
    float VdotNc = saturateEpsilonToOne(dot(viewDirection, clearcoatNormal_inWorld));
  #else
    float clearcoatRoughness = 0.0;
    vec3 clearcoatNormal_inWorld = vec3(0.0);
    float VdotNc = 0.0;
  #endif // RN_USE_CLEARCOAT

  #ifdef RN_USE_VOLUME
    // Volume
    float thicknessFactor = get_thicknessFactor(materialSID, 0);
    float thicknessTexture = texture(u_thicknessTexture, baseColorTexUv).g;
    float attenuationDistance = get_attenuationDistance(materialSID, 0);
    vec3 attenuationColor = get_attenuationColor(materialSID, 0);
    float thickness = thicknessFactor * thicknessTexture;
  #else
    float thickness = 0.0;
    vec3 attenuationColor = vec3(0.0);
    float attenuationDistance = 0.000001;
  #endif // RN_USE_VOLUME

  #ifdef RN_USE_SHEEN
    // Sheen
    vec3 sheenColorFactor = get_sheenColorFactor(materialSID, 0);
    vec3 sheenColorTexture = texture(u_sheenColorTexture, baseColorTexUv).rgb;
    float sheenRoughnessFactor = get_sheenRoughnessFactor(materialSID, 0);
    float sheenRoughnessTexture = texture(u_sheenRoughnessTexture, baseColorTexUv).a;
    vec3 sheenColor = sheenColorFactor * sheenColorTexture;
    float sheenRoughness = clamp(sheenRoughnessFactor * sheenRoughnessTexture, 0.000001, 1.0);
    float albedoSheenScalingNdotV = 1.0 - max3(sheenColor) * texture(u_sheenLutTexture, vec2(NdotV, sheenRoughness)).r;
  #else
    vec3 sheenColor = vec3(0.0);
    float sheenRoughness = 0.000001;
    float albedoSheenScalingNdotV = 1.0;
  #endif // RN_USE_SHEEN

  rt0 = vec4(0.0, 0.0, 0.0, alpha);

  // Lighting
  for (int i = 0; i < lightNumber; i++) {
    Light light = getLight(i, v_position_inWorld.xyz);
    vec3 lighting = lightingWithPunctualLight(light, normal_inWorld, viewDirection, NdotV, albedo,
                        perceptualRoughness, metallic, F0, F90, ior, transmission,
                        clearcoat, clearcoatRoughness, clearcoatNormal_inWorld, VdotNc,
                        attenuationColor, attenuationDistance,
                        anisotropy, anisotropicT, anisotropicB, BdotV, TdotV,
                        sheenColor, sheenRoughness, albedoSheenScalingNdotV,
                        iridescence, iridescenceFresnel, specular);

  #ifdef RN_USE_SHADOW_MAPPING
    if (light.type == 1) { // Point Light
      float pointLightFarPlane = get_pointLightFarPlane(materialSID, 0);
      float shadowContribution = varianceShadowContributionParaboloid(v_position_inWorld.xyz, light.position, pointLightFarPlane);
      lighting *= shadowContribution;
    }
  #endif

    rt0.rgb += lighting;
  }

  #ifdef RN_USE_SHADOW_MAPPING
    // float bias = 0.001;
    // vec2 shadowCoord = v_shadowCoord.xy / v_shadowCoord.w;
    // float shadowContribution = 1.0;
    // if (shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0) {
    //   shadowContribution = varianceShadowContribution(shadowCoord, (v_shadowCoord.z - bias)/v_shadowCoord.w);
    // }
    // // rt0.rgb = rt0.rgb * (0.5 + shadowContribution * 0.5);
    // rt0.rgb = rt0.rgb * shadowContribution;
  #endif

  vec3 ibl = IBLContribution(materialSID, normal_inWorld, NdotV, viewDirection,
    albedo, F0, perceptualRoughness, clearcoatRoughness, clearcoatNormal_inWorld,
    clearcoat, VdotNc, geomNormal_inWorld, cameraSID, transmission, v_position_inWorld.xyz, thickness,
    sheenColor, sheenRoughness, albedoSheenScalingNdotV,
    ior, iridescenceFresnel, iridescenceF0, iridescence,
    anisotropy, anisotropicB, specular);

  int occlusionTexcoordIndex = get_occlusionTexcoordIndex(materialSID, 0);
  vec2 occlusionTexcoord = getTexcoord(occlusionTexcoordIndex);
  vec4 occlusionTextureTransform = get_occlusionTextureTransform(materialSID, 0);
  float occlusionTextureRotation = get_occlusionTextureRotation(materialSID, 0);
  vec2 occlusionTexUv = uvTransform(occlusionTextureTransform.xy, occlusionTextureTransform.zw, occlusionTextureRotation, occlusionTexcoord);
  float occlusion = texture(u_occlusionTexture, occlusionTexUv).r;
  float occlusionStrength = get_occlusionStrength(materialSID, 0);

  // Occlution to Indirect Lights
  rt0.xyz += mix(ibl, ibl * occlusion, occlusionStrength);
#else
  rt0 = vec4(baseColor, alpha);
#endif // RN_IS_LIGHTING

  // Emissive
  vec3 emissiveFactor = get_emissiveFactor(materialSID, 0);
  int emissiveTexcoordIndex = get_emissiveTexcoordIndex(materialSID, 0);
  vec2 emissiveTexcoord = getTexcoord(emissiveTexcoordIndex);
  vec4 emissiveTextureTransform = get_emissiveTextureTransform(materialSID, 0);
  float emissiveTextureRotation = get_emissiveTextureRotation(materialSID, 0);
  vec2 emissiveTexUv = uvTransform(emissiveTextureTransform.xy, emissiveTextureTransform.zw, emissiveTextureRotation, emissiveTexcoord);
  float emissiveStrength = get_emissiveStrength(materialSID, 0);
  vec3 emissive = emissiveFactor * srgbToLinear(texture(u_emissiveTexture, emissiveTexUv).xyz) * emissiveStrength;

#ifdef RN_USE_CLEARCOAT
  vec3 coated_emissive = emissive * mix(vec3(1.0), vec3(0.04 + (1.0 - 0.04) * pow(1.0 - NdotV, 5.0)), clearcoat);
  rt0.xyz += coated_emissive;
#else
  rt0.xyz += emissive;
#endif // RN_USE_CLEARCOAT

  bool isOutputHDR = get_isOutputHDR(materialSID, 0);
  if(isOutputHDR){
/* shaderity: @{renderTargetEnd} */

    return;
  }

  // Wireframe
  float threshold = 0.001;
  vec3 wireframe = get_wireframe(materialSID, 0);
  float wireframeWidthInner = wireframe.z;
  float wireframeWidthRelativeScale = 1.0;
  if (wireframe.x > 0.5 && wireframe.y < 0.5) {
    rt0.a = 0.0;
  }
  vec4 wireframeResult = rt0;
  vec4 wireframeColor = vec4(0.2, 0.75, 0.0, 1.0);
  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);
  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);
  // if r0.a is 0.0, it is wireframe not on shaded
  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + rt0.rgb * (1.0 - edgeRatioModified);
  wireframeResult.a = max(rt0.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));

  if (wireframe.x > 0.5) {
    rt0 = wireframeResult;
    if (wireframe.y < 0.5 && rt0.a == 0.0) {
      discard;
    }
  }


#ifdef RN_IS_ALPHA_MODE_BLEND
#else
  rt0.a = 1.0;
#endif

float makeOutputSrgb = float(get_makeOutputSrgb(materialSID, 0));
rt0.rgb = mix(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb);

rt0.rgb = rt0.rgb * rt0.a; // alpha premultiplied
rt1 = rt0;
rt2 = rt0;
rt3 = rt0;
/* shaderity: @{renderTargetEnd} */


}
`, shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/PbrSingleShader/PbrSingleShader.vert
var PbrSingleShader_default3;
var init_PbrSingleShader3 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/PbrSingleShader/PbrSingleShader.vert"() {
    PbrSingleShader_default3 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n\n#ifdef RN_IS_SKINNING\n\nfn createMatrixFromQuaternionTranslationScale( quaternion: vec4<f32>, translation: vec3<f32>, scale: vec3<f32> ) -> mat4x4<f32> {\n  let q = quaternion;\n  let t = translation;\n\n  let sx = q.x * q.x;\n  let sy = q.y * q.y;\n  let sz = q.z * q.z;\n  let cx = q.y * q.z;\n  let cy = q.x * q.z;\n  let cz = q.x * q.y;\n  let wx = q.w * q.x;\n  let wy = q.w * q.y;\n  let wz = q.w * q.z;\n\n  let mat = mat4x4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  let uniformScaleMat = mat4x4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  let mat44 = mat*uniformScaleMat;\n  return mat44;\n\n}\n\nfn unpackedVec2ToNormalizedVec4(vec_xy: vec2<f32>, criteria: f32) -> vec4<f32> {\n\n  var r: f32;\n  var g: f32;\n  var b: f32;\n  var a: f32;\n\n  let ix = floor(vec_xy.x * criteria);\n  let v1x = ix / criteria;\n  let v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  let iy = floor( vec_xy.y * criteria);\n  let v2x = iy / criteria;\n  let v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4<f32>(r, g, b, a);\n}\n\nfn get_boneMatrixAsMat4x4(skeletalComponentSID: u32, joint: u32) -> mat4x4<f32> {\n  let mat43: mat4x3<f32> = get_boneMatrix(skeletalComponentSID, joint);\n  return mat4x4<f32>(\n    vec4<f32>(mat43[0], 0.0),\n    vec4<f32>(mat43[1], 0.0),\n    vec4<f32>(mat43[2], 0.0),\n    vec4<f32>(mat43[3], 1.0)\n  );\n}\n\nfn getSkinMatrix(skeletalComponentSID: u32, joint: vec4<u32>, weight: vec4<f32>) -> mat4x4<f32> {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  var skinMat: mat4x4<f32> = weight.x * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.x);\n  skinMat += weight.y * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.y);\n  skinMat += weight.z * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.z);\n  skinMat += weight.w * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.w);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  let criteria = vec2<f32>(4096.0, 4096.0);\n\n  let tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, joint.x);\n  let sq_x = get_boneScalePackedQuat(skeletalComponentSID, joint.x);\n  var quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  let tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, joint.y);\n  let sq_y = get_boneScalePackedQuat(skeletalComponentSID, joint.y);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  let tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, joint.z);\n  let sq_z = get_boneScalePackedQuat(skeletalComponentSID, joint.z);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  let tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, joint.w);\n  let sq_w = get_boneScalePackedQuat(skeletalComponentSID, joint.w);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  let ts_x = get_boneTranslateScale(skeletalComponentSID, joint.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = get_boneTranslateScale(skeletalComponentSID, joint.y);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.y), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = get_boneTranslateScale(skeletalComponentSID, joint.z);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.z), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = get_boneTranslateScale(skeletalComponentSID, joint.w);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.w), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  let boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, joint.x);\n  let boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, joint.y);\n  let boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, joint.z);\n  let boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, joint.w);\n\n  let criteria = vec2<f32>(4096.0, 4096.0);\n  let boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  let ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\nfn toNormalMatrix(m: mat4x4<f32>) -> mat3x3<f32> {\n  let a00 = m[0][0];\n  let a01 = m[0][1];\n  let a02 = m[0][2];\n  let a03 = m[0][3];\n  let a10 = m[1][0];\n  let a11 = m[1][1];\n  let a12 = m[1][2];\n  let a13 = m[1][3];\n  let a20 = m[2][0];\n  let a21 = m[2][1];\n  let a22 = m[2][2];\n  let a23 = m[2][3];\n  let a30 = m[3][0];\n  let a31 = m[3][1];\n  let a32 = m[3][2];\n  let a33 = m[3][3];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  let determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3x3<f32>(\n    (a11 * b11 - a12 * b10 + a13 * b09) / determinantVal,\n    (a12 * b08 - a10 * b11 - a13 * b07) / determinantVal,\n    (a10 * b10 - a11 * b08 + a13 * b06) / determinantVal,\n    (a02 * b10 - a01 * b11 - a03 * b09) / determinantVal,\n    (a00 * b11 - a02 * b08 + a03 * b07) / determinantVal,\n    (a01 * b08 - a00 * b10 - a03 * b06) / determinantVal,\n    (a31 * b05 - a32 * b04 + a33 * b03) / determinantVal,\n    (a32 * b02 - a30 * b05 - a33 * b01) / determinantVal,\n    (a30 * b04 - a31 * b02 + a33 * b00) / determinantVal\n  );\n}\n\nstruct GeometoryOutput {\n  normalMatrix: mat3x3<f32>,\n  position_inWorld: vec4<f32>,\n  normal_inWorld: vec3<f32>,\n  isSkinning: bool,\n}\n\n#ifdef RN_IS_SKINNING\nfn skinning(\n  skeletalComponentSID: u32,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n  ) -> GeometoryOutput\n{\n  var output: GeometoryOutput;\n  let skinMat = getSkinMatrix(skeletalComponentSID, joint, weight);\n  output.position_inWorld = skinMat * vec4<f32>(inPosition_inLocal, 1.0);\n  output.normalMatrix = toNormalMatrix(skinMat);\n  output.normal_inWorld = normalize(output.normalMatrix * inNormal_inLocal);\n  output.isSkinning = true;\n\n  return output;\n}\n#endif\n\n\nfn processGeometryWithMorphingAndSkinning(\n  skeletalComponentSID: i32,\n  blendShapeComponentSID: u32,\n  worldMatrix: mat4x4<f32>,\n  viewMatrix: mat4x4<f32>,\n  isBillboard: bool,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  baryCentricCoord: vec4<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n) -> GeometoryOutput {\n  var output: GeometoryOutput;\n\n  var position_inLocal: vec3<f32>;\n#ifdef RN_IS_MORPHING\n  if (uniformDrawParameters.morphTargetNumber == 0u) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    let vertexIdx = u32(baryCentricCoord.w);\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal, blendShapeComponentSID);\n  }\n#endif\n\n  var worldMatrixInner = worldMatrix;\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0) {\n    output = skinning(u32(skeletalComponentSID), inNormalMatrix, position_inLocal, inNormal_inLocal, joint, weight);\n  } else {\n#endif\n    output.normalMatrix = inNormalMatrix;\n    output.position_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    output.normal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n    output.isSkinning = false;\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return output;\n}\n\n\n// BiasMatrix * LightProjectionMatrix * LightViewMatrix, See: http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/#basic-shader\n// #param depthBiasPV: mat4x4<f32>; // initialValue=(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)\n\n@vertex\nfn main(\n#ifdef RN_USE_INSTANCE\n  @location(8) instance_ids: vec4<f32>,\n#endif\n\n\n#ifdef RN_USE_POSITION_FLOAT\n  @location(0) position: vec3<f32>,\n#endif\n#ifdef RN_USE_POSITION_INT\n  @location(0) position: vec3<i32>,\n#endif\n#ifdef RN_USE_POSITION_UINT\n  @location(0) position: vec3<u32>,\n#endif\n\n#ifdef RN_USE_NORMAL\n  @location(1) normal: vec3<f32>,\n#endif\n#ifdef RN_USE_TANGENT\n  @location(2) tangent: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_0\n  @location(3) texcoord_0: vec2<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  @location(4) texcoord_1: vec2<f32>,\n#endif\n\n#ifdef RN_USE_COLOR_0_FLOAT\n  @location(5) color_0: vec4<f32>,\n#endif\n#ifdef RN_USE_COLOR_0_INT\n  @location(5) color_0: vec4<i32>,\n#endif\n#ifdef RN_USE_COLOR_0_UINT\n  @location(5) color_0: vec4<u32>,\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  @location(6) joints_0: vec4<u32>,\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  @location(7) weights_0: vec4<f32>,\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  @location(10) baryCentricCoord: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  @location(11) texcoord_2: vec2<f32>,\n#endif\n  @builtin(vertex_index) vertexIdx : u32,\n\n\n) -> VertexOutput {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var output : VertexOutput;\n  let instanceId = u32(instance_ids.x);\n  let worldMatrix = get_worldMatrix(instanceId);\n  let normalMatrix = get_normalMatrix(instanceId);\n  let viewMatrix = get_viewMatrix(cameraSID, 0);\n  let projectionMatrix = get_projectionMatrix(cameraSID, 0);\n\n  let skeletalComponentSID = i32(instance_ids.y);\n\n#ifdef RN_USE_NORMAL\n#else\n  let normal = vec3<f32>(0.0, 0.0, 0.0);\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  let joint = joints_0;\n#else\n  let joint = vec4<u32>(0, 0, 0, 0);\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  let weight = weights_0;\n#else\n  let weight = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n#else\n  let baryCentricCoord = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n\n  let blendShapeComponentSID = u32(instance_ids.z);\n  let geom = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    blendShapeComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    position,\n    normal,\n    baryCentricCoord,\n    joint,\n    weight\n  );\n\n  output.position = projectionMatrix * viewMatrix * geom.position_inWorld;\n  output.position_inWorld = geom.position_inWorld.xyz;\n  output.normal_inWorld = geom.normal_inWorld;\n\n#ifdef RN_USE_TEXCOORD_0\n  output.texcoord_0 = texcoord_0;\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  output.texcoord_1 = texcoord_1;\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  output.texcoord_2 = texcoord_2;\n#endif\n\n#ifdef RN_USE_COLOR_0\n  output.color_0 = vec4f(color_0);\n#else\n  output.color_0 = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n#endif\n\n#ifdef RN_USE_TANGENT\n  output.tangent_inWorld = normalMatrix * tangent.xyz;\n  output.binormal_inWorld = cross(output.tangent_inWorld, output.normal_inWorld) * tangent.w;\n#endif\n\n  output.instanceInfo = instance_ids.x;\n\n  let visibility = get_isVisible(instanceId);\n  if (!visibility)\n  {\n    output.position = vec4f(0.0, 0.0, 0.0, 1.0);\n  }\n\n#ifdef RN_USE_SHADOW_MAPPING\n  output.shadowCoord = get_depthBiasPV(materialSID, 0) * geom.position_inWorld;\n#endif\n\n  return output;\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/PbrSingleShader/PbrSingleShader.frag
var PbrSingleShader_default4;
var init_PbrSingleShader4 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/PbrSingleShader/PbrSingleShader.frag"() {
    PbrSingleShader_default4 = { code: `/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) shadowCoord : vec4<f32>,
  @location(10) instanceInfo : f32,
  @location(11) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturateEpsilonToOne(x: f32) -> f32 {
  let Epsilon = 0.0000001;
  return clamp(x, Epsilon, 1.0);
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

struct Light {
  lightType: i32, // 0 = directional, 1 = point, 2 = spot
  position: vec3<f32>,
  intensity: vec3<f32>,
  attenuatedIntensity: vec3<f32>,
  directionOfLightObject: vec3<f32>,
  direction: vec3<f32>, // direction of light vector, equal to normalize(light.pointToLight)
  pointToLight: vec3<f32>, // not normalized
  spotAngleScale: f32,
  spotAngleOffset: f32,
  effectiveRange: f32,
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
fn getRangeAttenuation(light: Light) -> f32
{
  let distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
fn getSpotAttenuation(light: Light) -> f32
{

  let cd = dot(light.directionOfLightObject, light.direction);
  let angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);
  return angularAttenuation;
}

fn getLightAttenuated(light: Light) -> Light {
  var newLight: Light = light;
  newLight.attenuatedIntensity = light.intensity;
  // if (light.lightType == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light
  if (light.lightType == 1)
  {
    newLight.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot light
  if (light.lightType == 2)
  {
    newLight.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return newLight;
}

fn getLight(lightIdx: u32, v_position_inWorld: vec3<f32>) -> Light {
  let lightPosition: vec3<f32> = get_lightPosition(0u, lightIdx);
  let direction_and_w_of_LightObject: vec3<f32> = get_lightDirection(0u, lightIdx);
  let lightIntensity: vec3<f32> = get_lightIntensity(0u, lightIdx);
  let lightProperty: vec4<f32> = get_lightProperty(0u, lightIdx);
  var light: Light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  let lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.spotAngleScale = lightProperty.z;
  light.spotAngleOffset = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3f(0.0);
    light.lightType = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.lightType = 1;
  } else { // is Directional Light
    light.lightType = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.lightType = 2;
  }

  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  let newLight = getLightAttenuated(light);

  return newLight;
}

#ifdef RN_USE_TANGENT
  fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
    let tangent_inWorld = normalize(input.tangent_inWorld);
    let binormal_inWorld = normalize(input.binormal_inWorld);
    let tbnMat_tangent_to_world = mat3x3<f32>(tangent_inWorld, binormal_inWorld, normal_inWorld);

    return tbnMat_tangent_to_world;
  }
#else
    // This is based on http://www.thetenthplanet.de/archives/1180
    fn cotangent_frame(normal_inWorld: vec3f, position: vec3f, uv_: vec2f, isFront: bool) -> mat3x3<f32> {
      var uv: vec2f;
      if (isFront) {
        uv = uv_;
      } else {
        uv = -uv_;
      }

      // get edge vectors of the pixel triangle
      let dp1 = dpdx(position);
      let dp2 = dpdy(position);
      let duv1 = dpdx(uv);
      let duv2 = dpdy(uv);

      // solve the linear system
      let dp2perp = cross(dp2, normal_inWorld);
      let dp1perp = cross(normal_inWorld, dp1);
      let tangent = dp2perp * duv1.x + dp1perp * duv2.x;
      var bitangent = dp2perp * duv1.y + dp1perp * duv2.y;
      bitangent *= -1.0;

      // construct a scale-invariant frame
      let invMat = 1.0 / sqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));
      return mat3x3<f32>(tangent * invMat, bitangent * invMat, normal_inWorld);
    }

    fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
      let tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord, isFront);

      return tbnMat_tangent_to_world;
    }
#endif

fn srgbToLinear(srgbColor: vec3f) -> vec3f {
  return pow(srgbColor, vec3f(2.2));
}

fn linearToSrgb(linearColor: vec3f) -> vec3f {
  return pow(linearColor, vec3f(1.0/2.2));
}

// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66
fn Schlick_to_F0_F90(f: vec3f, f90: vec3f, VdotH: f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0_F90_F32(f: f32, f90: f32, VdotH: f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0(f: vec3f, VdotH: f32) -> vec3f {
    return Schlick_to_F0_F90(f, vec3(1.0), VdotH);
}

fn Schlick_to_F0_F32(f: f32, VdotH: f32) -> f32 {
    return Schlick_to_F0_F90_F32(f, 1.0, VdotH);
}


// The Schlick Approximation to Fresnel
fn fresnel(f0 : vec3f, f90 : vec3f, VdotH : f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnelF32(f0 : f32, f90 : f32, VdotH : f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnel2(f0: vec3f, VdotH: f32) -> vec3f
{
  let f90 = vec3f(1.0); //clamp(50.0 * f0, 0.0, 1.0);
  return fresnel(f0, f90, VdotH);
}

fn fresnel2F32(f0: f32, VdotH: f32) -> f32
{
  let f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelF32(f0, f90, VdotH);
}

// Roughness Dependent Fresnel
// https://www.jcgt.org/published/0008/01/03/paper.pdf
fn fresnelSchlickRoughness(F0: vec3f, cosTheta: f32, roughness: f32) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);
  return k_S;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf
fn BRDF_lambertian(albedo: vec3f, F: vec3f, specularWeight: f32) -> vec3f
{
  return (vec3f(1.0) - specularWeight * F) * albedo * RECIPROCAL_PI;
}


// GGX NDF
fn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {
  let roughnessSqr = alphaRoughness * alphaRoughness;
  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
fn v_GGXCorrelated(NL: f32, NV: f32, alphaRoughness: f32) -> f32 {
  let a2 = alphaRoughness * alphaRoughness;
  let GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  let GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  return 0.5 / (GGXV + GGXL);
}

fn BRDF_specularGGX(NH: f32, NL: f32, NV: f32, F: vec3f, alphaRoughness: f32, specularWeight: f32) -> vec3f {
  let D = d_GGX(NH, alphaRoughness);
  let V = v_GGXCorrelated(NL, NV, alphaRoughness);
  return vec3f(D) * vec3f(V) * F * specularWeight;
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
fn envBRDFApprox( Roughness: f32, NoV: f32 ) -> vec2f {
  let c0 = vec4f(-1, -0.0275, -0.572, 0.022 );
  let c1 = vec4f(1, 0.0425, 1.04, -0.04 );
  let r = Roughness * c0 + c1;
  let a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  let AB = vec2f( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}


// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering
fn coated_material_s(base: vec3f, perceptualRoughness: f32, clearcoatRoughness: f32, clearcoat: f32, VdotNc: f32, LdotNc: f32, NdotHc: f32) -> vec3f {
  let clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);
  let clearcoatAlpha = clearcoatRoughness * clearcoatRoughness;
  let alphaRoughness = perceptualRoughness * perceptualRoughness;
  let D = d_GGX(NdotHc, clearcoatAlpha);
  let V = v_GGXCorrelated(LdotNc, VdotNc, clearcoatAlpha);
  let f_clearcoat = clearcoatFresnel * D * V;

  // base = (f_diffuse + f_specular) in https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering
  return base * vec3f(1.0 - clearcoat * clearcoatFresnel) + vec3f(f_clearcoat * clearcoat);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes
fn specular_btdf(alphaRoughness: f32, NdotL: f32, NdotV: f32, NdotHt: f32) -> f32 {
  let V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  let D = d_GGX(NdotHt, alphaRoughness);
  return V * D;
}


////////////////////////////////////////
// glTF KHR_materials_volume
////////////////////////////////////////

#ifdef RN_USE_VOLUME
// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
fn volumeAttenuation(attenuationColor: vec3f, attenuationDistance: f32, intensity: vec3f, transmissionDistance: f32) -> vec3f
{
  if (attenuationDistance == 0.0) { // means Infinite distance
    return intensity; // No attenuation
  } else {
    let attenuationCo: vec3f = -log(attenuationColor) / attenuationDistance;
    let attenuatedTransmittance: vec3f = exp(-attenuationCo * transmissionDistance);
    return intensity * attenuatedTransmittance;
  }
}
#endif


////////////////////////////////////////
// glTF KHR_materials_anisotropy
////////////////////////////////////////
#ifdef RN_USE_ANISOTROPY
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
fn D_GGX_anisotropic(NdotH: f32, TdotH: f32, BdotH: f32, at: f32, ab: f32) -> f32
{
    let a2 = at * ab;
    let f = vec3f(ab * TdotH, at * BdotH, a2 * NdotH);
    let w2 = a2 / dot(f, f);
    return a2 * w2 * w2 / M_PI;
}

fn V_GGX_anisotropic(NdotL: f32, NdotV: f32, BdotV: f32, TdotV: f32, TdotL: f32, BdotL: f32,
    at: f32, ab: f32) -> f32
{
    let GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));
    let GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));
    let v = 0.5 / (GGXV + GGXL);
    return clamp(v, 0.0, 1.0);
}

fn BRDF_specularAnisotropicGGX(F: vec3f, alphaRoughness: f32,
    VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32, BdotV: f32, TdotV: f32,
    TdotL: f32, BdotL: f32, TdotH: f32, BdotH: f32, anisotropy: f32) -> vec3f
{
    let at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
    let ab = alphaRoughness;

    let V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);
    let D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);

    return F * V * D;
}
#endif

////////////////////////////////////////
// glTF KHR_materials_sheen
////////////////////////////////////////

#ifdef RN_USE_SHEEN
fn d_Charlie(sheenPerceptualRoughness: f32, NoH: f32) -> f32 {
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;
  let invAlpha  = 1.0 / alphaG;
  let cos2h = NoH * NoH;
  let sin2h = 1.0 - cos2h;
  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * M_PI);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn sheenSimpleVisibility(NdotL: f32, NdotV: f32) -> f32 {
  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn charlieL(x: f32, alphaG: f32) -> f32 {
  let oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
  let a = mix(21.5473, 25.3245, oneMinusAlphaSq);
  let b = mix(3.82987, 3.32435, oneMinusAlphaSq);
  let c = mix(0.19823, 0.16801, oneMinusAlphaSq);
  let d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
  let e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
  return a / (1.0 + b * pow(x, c)) + d * x + e;
}

fn lambdaSheen(cosTheta: f32, alphaG: f32) -> f32
{
  return select(exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG)), exp(charlieL(cosTheta, alphaG)), abs(cosTheta) < 0.5);
}

fn sheenCharlieVisibility(NdotL: f32, NdotV: f32, sheenPerceptualRoughness: f32) -> f32 {
  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;
  let sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));
  return sheenVisibility;
}

fn sheen_brdf(sheenColor: vec3f, sheenPerceptualRoughness: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f {
  let sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);
  let sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);
  return sheenColor * sheenDistribution * sheenVisibility;
}
#endif // RN_USE_SHEEN

////////////////////////////////////////
// glTF KHR_materials_irirdescence
////////////////////////////////////////

#ifdef RN_USE_IRIDESCENCE
// XYZ to REC709(sRGB) conversion matrix
const XYZ_TO_REC709 = mat3x3<f32>(
     3.2404542, -0.9692660,  0.0556434,
    -1.5371385,  1.8760108, -0.2040259,
    -0.4985314,  0.0415560,  1.0572252
);

fn fresnelSchlickRoughnessWithIridescence(
  F0: vec3f, cosTheta: f32, roughness: f32,
  iridescenceFresnel: vec3f, iridescence: f32
  ) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);
  return k_S;
}

// Assume air interface for top
fn Fresnel0ToIor(F0: vec3f) -> vec3f {
    let sqrtF0 = sqrt(F0);
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// Conversion from IOR to F0
// ior is a value between 1.0 and 3.0. 1.0 is air interface
fn IorToFresnel0Vec3f(transmittedIor: vec3f, incidentIor: f32) -> vec3f {
    return sqVec3f((transmittedIor - vec3f(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
fn IorToFresnel0F32(transmittedIor: f32, incidentIor: f32) -> f32 {
    return sqF32((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration
 */
fn evalSensitivity(OPD: f32, shift: vec3f) -> vec3f {
    let phase = 2.0 * M_PI * OPD * 1.0e-9;
    let val = vec3f(5.4856e-13, 4.4201e-13, 5.2481e-13);
    let pos = vec3f(1.6810e+06, 1.7953e+06, 2.2084e+06);
    let var_ = vec3f(4.3278e+09, 9.3046e+09, 6.6121e+09);

    var xyz = val * sqrt(2.0 * M_PI * var_) * cos(pos * phase + shift) * exp(-(phase * phase) * var_);
    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));
    xyz /= 1.0685e-7;

    let rgb = XYZ_TO_REC709 * xyz;
    return rgb;
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel
 */
fn calcIridescence(outsideIor: f32, eta2: f32, cosTheta1: f32, thinFilmThickness: f32, baseF0: vec3f) -> vec3f {


  // iridescenceIor is the index of refraction of the thin-film layer
  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
  let iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));

  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)
  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.
  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.
  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):
  let sinTheta2Sq = sqF32(outsideIor / iridescenceIor) * (1.0 - sqF32(cosTheta1));
  let cosTheta2Sq = 1.0 - sinTheta2Sq;

  // Handle total internal reflection
  if (cosTheta2Sq < 0.0) {
      return vec3f(1.0);
  }

  let cosTheta2 = sqrt(cosTheta2Sq);

  /// Material Interfaces
  // The iridescence model defined by Belcour/Barla models two material interfaces
  // - one from the outside to the thin-film layer
  // and another one from the thin-film to the base material. These two interfaces are defined as follows:

  // First interface (from the outside to the thin-film layer)
  let R0 = IorToFresnel0F32(iridescenceIor, outsideIor);
  let R12 = fresnel2F32(R0, cosTheta1);
  let R21 = R12;
  let T121 = 1.0 - R12;

  // Second interface (from the thin-film to the base material)
  let baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0
  let R1 = IorToFresnel0Vec3f(baseIor, iridescenceIor);
  let R23 = fresnel2(R1, cosTheta2);

  // phi12 and phi23 define the base phases per interface and are approximated with 0.0
  // if the IOR of the hit material (iridescenceIor or baseIor) is higher
  // than the IOR of the previous material (outsideIor or iridescenceIor) and \u03C0 otherwise.
  // Also here, polarization is ignored.  float phi12 = 0.0;

  // First interface (from the outside to the thin-film layer)
  var phi12 = 0.0;
  if (iridescenceIor < outsideIor) { phi12 = M_PI; }
  let phi21 = M_PI - phi12;

  // Second interface (from the thin-film to the base material)
  var phi23 = vec3f(0.0);
  if (baseIor[0] < iridescenceIor) { phi23[0] = M_PI; }
  if (baseIor[1] < iridescenceIor) { phi23[1] = M_PI; }
  if (baseIor[2] < iridescenceIor) { phi23[2] = M_PI; }

  // OPD (optical path difference)
  let OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
  // Phase shift
  let phi = vec3f(phi21) + phi23;

  // Compound terms
  let R123 = clamp(R12 * R23, vec3f(1e-5), vec3f(0.9999));
  let r123 = sqrt(R123);
  let Rs = (T121 * T121) * R23 / (vec3f(1.0) - R123);

  // Reflectance term for m = 0 (DC term amplitude)
  let C0 = R12 + Rs;
  var I = C0;

  // Reflectance term for m > 0 (pairs of diracs)
  var Cm = Rs - T121;
  for (var m = 1; m <= 2; m++)
  {
      Cm *= r123;
      let Sm = 2.0 * evalSensitivity(f32(m) * OPD, f32(m) * phi);
      I += Cm * Sm;
  }

  let F_iridescence = max(I, vec3f(0.0));

  return F_iridescence;
}

//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB
fn BRDF_lambertianIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, iridescenceFactor: f32, diffuseColor: vec3f, specularWeight: f32, VdotH: f32) -> vec3f
{
    let iridescenceFresnelMax = vec3f(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));

    let schlickFresnel = Schlick_to_F0_F90(f0, f90, VdotH);

    let F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);

    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);
}

fn BRDF_specularGGXIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, alphaRoughness: f32, iridescenceFactor: f32, specularWeight: f32, VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f
{
    let F = mix(Schlick_to_F0_F90(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);
    let Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
    let D = d_GGX(NdotH, alphaRoughness);

    return specularWeight * F * Vis * D;
}

#endif // RN_USE_IRIDESCENCE


////////////////////////////////////////
// lighting with a punctual light
////////////////////////////////////////
fn lightingWithPunctualLight(
  light: Light,
  normal_inWorld: vec3f,
  viewDirection: vec3f,
  NdotV: f32,
  albedo: vec3f,
  perceptualRoughness: f32,
  F0: vec3f,
  F90: vec3f,
  transmission: f32,
  ior: f32,
  clearcoat: f32,
  clearcoatRoughness: f32,
  clearcoatNormal_inWorld: vec3f,
  VdotNc: f32,
  attenuationColor: vec3f,
  attenuationDistance: f32,
  anisotropy: f32,
  anisotropicT: vec3f,
  anisotropicB: vec3f,
  BdotV: f32,
  TdotV: f32,
  sheenColor: vec3f,
  sheenRoughness: f32,
  albedoSheenScalingNdotV: f32,
  iridescenceFactor: f32,
  iridescenceFresnel: vec3f,
  specularWeight: f32,
  ) -> vec3f
{
  let alphaRoughness = perceptualRoughness * perceptualRoughness;

  // Fresnel
  let halfVector = normalize(light.direction + viewDirection);
  let VdotH = dot(viewDirection, halfVector);
  let F = fresnel(F0, F90, VdotH);

  let NdotL = clamp(dot(normal_inWorld, light.direction), Epsilon, 1.0);

  // Diffuse
#ifdef RN_USE_IRIDESCENCE
  let diffuseBrdf = BRDF_lambertianIridescence(F0, F90, iridescenceFresnel, iridescenceFactor, albedo, specularWeight, VdotH);
#else
  let diffuseBrdf = BRDF_lambertian(albedo, F, specularWeight);
#endif
  let pureDiffuse = diffuseBrdf * vec3f(NdotL) * light.attenuatedIntensity;

#ifdef RN_USE_TRANSMISSION
  let refractionVector = refract(-viewDirection, normal_inWorld, 1.0 / ior);
  var transmittedLightFromUnderSurface: Light = light;
  transmittedLightFromUnderSurface.pointToLight -= refractionVector;
  let transmittedLightDirectionFromUnderSurface = normalize(transmittedLightFromUnderSurface.pointToLight);
  transmittedLightFromUnderSurface.direction = transmittedLightDirectionFromUnderSurface;

  let Ht = normalize(viewDirection + transmittedLightFromUnderSurface.direction);
  let NdotHt = saturateEpsilonToOne(dot(normal_inWorld, Ht));
  let NdotLt = saturateEpsilonToOne(dot(normal_inWorld, transmittedLightFromUnderSurface.direction));

  var transmittedContrib = (vec3f(1.0) - F) * specular_btdf(alphaRoughness, NdotLt, NdotV, NdotHt) * albedo * transmittedLightFromUnderSurface.attenuatedIntensity;

#ifdef RN_USE_VOLUME
  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittedLightFromUnderSurface.pointToLight));
#endif // RN_USE_VOLUME

  let diffuseContrib = mix(pureDiffuse, vec3f(transmittedContrib), transmission);
#else
  let diffuseContrib = pureDiffuse;
#endif // RN_USE_TRANSMISSION

  // Specular
  let NdotH = saturateEpsilonToOne(dot(normal_inWorld, halfVector));


#ifdef RN_USE_IRIDESCENCE
  let specularContrib = BRDF_specularGGXIridescence(F0, F90, iridescenceFresnel, alphaRoughness, iridescenceFactor, specularWeight, VdotH, NdotL, NdotV, NdotH) * vec3f(NdotL) * light.attenuatedIntensity;
#elif defined(RN_USE_ANISOTROPY)
  let TdotL = dot(anisotropicT, light.direction);
  let BdotL = dot(anisotropicB, light.direction);
  let TdotH = dot(anisotropicT, halfVector);
  let BdotH = dot(anisotropicB, halfVector);
  let specularContrib = BRDF_specularAnisotropicGGX(F, alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3f(NdotL) * light.attenuatedIntensity;
#else
  let specularContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, F, alphaRoughness, specularWeight) * vec3f(NdotL) * light.attenuatedIntensity;
#endif

  // Base Layer
  let baseLayer = diffuseContrib + specularContrib;

#ifdef RN_USE_SHEEN
  // Sheen
  let sheenContrib = sheen_brdf(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;
  let albedoSheenScaling = min(
    albedoSheenScalingNdotV,
    1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotL, sheenRoughness)).r);
  let color = sheenContrib + baseLayer * albedoSheenScaling;
#else
  let color = baseLayer;
  let albedoSheenScaling = 1.0;
#endif // RN_USE_SHEEN

#ifdef RN_USE_CLEARCOAT
  // Clear Coat Layer
  let NdotHc = saturateEpsilonToOne(dot(clearcoatNormal_inWorld, halfVector));
  let LdotNc = saturateEpsilonToOne(dot(light.direction, clearcoatNormal_inWorld));
  let coated = coated_material_s(color, perceptualRoughness,
    clearcoatRoughness, clearcoat, VdotNc, LdotNc, NdotHc);
  let finalColor = coated;
#else
  let finalColor = color;
#endif // RN_USE_CLEARCOAT

  return finalColor;
}

fn IsotropicNDFFiltering(normal: vec3f, roughness2: f32) -> f32 {
  let SIGMA2 = 0.15915494;
  let KAPPA = 0.18;
  let dndu  = dpdx(normal);
  let dndv = dpdy(normal);
  let kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));
  let clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);
  let filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);
  return filteredRoughness2;
}


// #param makeOutputSrgb: bool; // initialValue=1

// Color
// #param baseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)
@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(0) var baseColorSampler: sampler;
// #param baseColorTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)
// #param baseColorTextureRotation: f32; // initialValue=0
// #param baseColorTexcoordIndex: f32; // initialValue=0

// #param ior: f32; // initialValue=1.5

// #param metallicRoughnessFactor: vec2<f32>; // initialValue=(1,1)
@group(1) @binding(1) var metallicRoughnessTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(1) var metallicRoughnessSampler: sampler;
// #param metallicRoughnessTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)
// #param metallicRoughnessTextureRotation: f32; // initialValue=0
// #param metallicRoughnessTexcoordIndex: f32; // initialValue=0

#ifdef RN_USE_NORMAL_TEXTURE
  @group(1) @binding(2) var normalTexture: texture_2d<f32>; // initialValue=black
  @group(2) @binding(2) var normalSampler: sampler;
  // #param normalTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)
  // #param normalTextureRotation: f32; // initialValue=(0)
  // #param normalTexcoordIndex: f32; // initialValue=(0)
  // #param normalScale: f32; // initialValue=(1)
#endif

@group(1) @binding(3) var occlusionTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(3) var occlusionSampler: sampler;
// #param occlusionTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)
// #param occlusionTextureRotation: f32; // initialValue=0
// #param occlusionTexcoordIndex: u32; // initialValue=0
// #param occlusionStrength: f32; // initialValue=1

// #param emissiveFactor: vec3<f32>; // initialValue=(0,0,0)
// #param emissiveTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)
// #param emissiveTextureRotation: f32; // initialValue=0
// #param emissiveTexcoordIndex: u32; // initialValue=0
@group(1) @binding(4) var emissiveTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(4) var emissiveSampler: sampler;
// #param emissiveStrength: f32; // initialValue=1

#ifdef RN_USE_CLEARCOAT
// #param clearCoatFactor: f32; // initialValue=0
// #param clearCoatRoughnessFactor: f32; // initialValue=0
// #param clearCoatTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)
// #param clearCoatTextureRotation: f32; // initialValue=0
// #param clearCoatRoughnessTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)
// #param clearCoatRoughnessTextureRotation: f32; // initialValue=0
// #param clearCoatNormalTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)
// #param clearCoatNormalTextureRotation: f32; // initialValue=0
// #param clearCoatTexcoordIndex: u32; // initialValue=(0)
// #param clearCoatRoughnessTexcoordIndex: u32; // initialValue=(0)
// #param clearCoatNormalTexcoordIndex: u32; // initialValue=(0)
#endif // RN_USE_CLEARCOAT


#ifdef RN_USE_TRANSMISSION
// #param transmissionFactor: f32; // initialValue=(0)
#endif // RN_USE_TRANSMISSION

#ifdef RN_USE_VOLUME
// #param thicknessFactor: f32; // initialValue=(0)
// #param attenuationDistance: f32; // initialValue=(0.000001)
// #param attenuationColor: vec3<f32>; // initialValue=(1,1,1)
#endif

#ifdef RN_USE_SHEEN
// #param sheenColorFactor: vec3<f32>; // initialValue=(0,0,0)
// #param sheenRoughnessFactor: f32; // initialValue=(0)
#endif

#ifdef RN_USE_SPECULAR
// #param specularFactor: f32; // initialValue=1.0
// #param specularColorFactor: vec3<f32>; // initialValue=(1,1,1)
#endif

#ifdef RN_USE_IRIDESCENCE
// #param iridescenceFactor: f32; // initialValue=0
// #param iridescenceIor: f32; // initialValue=1.3
// #param iridescenceThicknessMinimum: f32; // initialValue=100
// #param iridescenceThicknessMaximum: f32; // initialValue=400
#endif

#ifdef RN_USE_ANISOTROPY
// #param anisotropyStrength: f32; // initialValue=0
// #param anisotropyRotation: vec2<f32>; // initialValue=(1,0)
#endif

// #param alphaCutoff: f32; // initialValue=0.01

@group(1) @binding(16) var diffuseEnvTexture: texture_cube<f32>; // initialValue=black
@group(2) @binding(16) var diffuseEnvSampler: sampler;
@group(1) @binding(17) var specularEnvTexture: texture_cube<f32>; // initialValue=black
@group(2) @binding(17) var specularEnvSampler: sampler;


// #param iblParameter: vec4<f32>; // initialValue=(1,1,1,1), isInternalSetting=true
// #param hdriFormat: vec2<i32>; // initialValue=(0,0), isInternalSetting=true
// #param inverseEnvironment: bool; // initialValue=false
fn get_irradiance(normal_forEnv: vec3f, hdriFormat: vec2<i32>) -> vec3f {
  let diffuseTexel: vec4f = textureSample(diffuseEnvTexture, diffuseEnvSampler, normal_forEnv);

  var irradiance: vec3f;
  if (hdriFormat.x == 0) {
    // LDR_SRGB
    irradiance = srgbToLinear(diffuseTexel.rgb);
  }
  else if (hdriFormat.x == 3) {
    // RGBE
    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  }
  else {
    irradiance = diffuseTexel.rgb;
  }

  return irradiance;
}

fn get_radiance(reflection: vec3f, lod: f32, hdriFormat: vec2<i32>) -> vec3f {
  let specularTexel = textureSampleLevel(specularEnvTexture, specularEnvSampler, reflection, lod);

  var radiance: vec3f;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

#ifdef RN_USE_SHEEN
fn sheenIBL(NdotV: f32, sheenPerceptualRoughness: f32, sheenColor: vec3f, iblParameter: vec4f, reflection: vec3f, hdriFormat: vec2i) -> vec3f
{
  let mipCount = iblParameter.x;
  let lod = (sheenPerceptualRoughness * (mipCount - 1.0));

  let sheenLutUV = vec2f(NdotV, sheenPerceptualRoughness);
  let brdf = textureSample(sheenLutTexture, sheenLutSampler, sheenLutUV).b;
  var sheenLight = get_radiance(reflection, lod, hdriFormat);
  let IBLSpecularContribution = iblParameter.z;
  sheenLight *= IBLSpecularContribution;

  return sheenLight * sheenColor * brdf;
}
#endif

fn getNormalForEnv(rotEnvMatrix: mat3x3<f32>, normal_inWorld: vec3f, materialSID: u32) -> vec3f {
  var normal_forEnv = rotEnvMatrix * normal_inWorld;
  if (get_inverseEnvironment(materialSID, 0)) {
    normal_forEnv.x *= -1.0;
  }
  return normal_forEnv;
}

fn getReflection(rotEnvMatrix: mat3x3<f32>, viewDirection: vec3f, normal_inWorld: vec3f,
  materialSID: u32, perceptualRoughness: f32,
  anisotropy: f32, anisotropyDirection: vec3f
  ) -> vec3f {
#ifdef RN_USE_ANISOTROPY
  let tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);
  let anisotropicTangent  = cross(anisotropyDirection, viewDirection);
  let anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);
  let bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);
  let bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;
  let bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));
  var reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);
#else
  var reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);
#endif
  if (get_inverseEnvironment(materialSID, 0)) {
    reflection.x *= -1.0;
  }
  return reflection;
}

fn scaleForLod(perceptualRoughness: f32, ior: f32) -> f32
{
  // Scale roughness to the range [0, 1],
  // ior=1.0 will be scale 0,
  // ior=1.5 will be scale 1.0,
  // ior=2 will be scale 1.0 (clamped)
  //

  let scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);
  return perceptualRoughness * scale;
}

#ifdef RN_USE_TRANSMISSION
fn get_sample_from_backbuffer(materialSID: u32, sampleCoord: vec2f, perceptualRoughness: f32, ior: f32) -> vec3f {
  let vrState: vec2<i32> = get_vrState(0, 0);
  let backBufferTextureSize = vec2f(textureDimensions(backBufferTexture, 0));
  var backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);
  var newSampleCoord = sampleCoord;
  newSampleCoord.y = 1.0 - newSampleCoord.y;
  if (vrState.x == 1) { // For VR
    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
    newSampleCoord.x = sampleCoord.x * 0.5;
    if (vrState.y == 1) { // For right eye
      newSampleCoord.x += 0.5;
    }
  }
  let framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);

  let transmittedLight = textureSampleLevel(backBufferTexture, backBufferSampler, newSampleCoord, framebufferLod).rgb;

  return transmittedLight;
}

// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer
fn getVolumeTransmissionRay(n: vec3f, v: vec3f, thickness: f32, ior: f32, instanceInfo: u32) -> vec3f
{
  let refractionVector = refract(-v, normalize(n), 1.0 / ior);
  let worldMatrix = get_worldMatrix(instanceInfo);

  var modelScale: vec3f;
  modelScale.x = length(vec3f(worldMatrix[0].xyz));
  modelScale.y = length(vec3f(worldMatrix[1].xyz));
  modelScale.z = length(vec3f(worldMatrix[2].xyz));

  return normalize(refractionVector) * thickness * modelScale;
}
#endif // RN_USE_TRANSMISSION

struct IblResult
{
  specular: vec3f,
  diffuse: vec3f,
  FssEss: vec3f,
};


#ifdef RN_USE_IRIDESCENCE
fn getIBLRadianceGGXWithIridescence(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,
  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2i, rotEnvMatrix: mat3x3<f32>,
  normal_forEnv: vec3f, reflection: vec3f, iridescenceFresnel: vec3f, iridescence: f32, specularWeight: f32) -> IblResult
{
  // get radiance
  let mipCount = iblParameter.x;
  let lod = (perceptualRoughness * (mipCount - 1.0));
  let radiance = get_radiance(reflection, lod, hdriFormat);

  // Roughness dependent fresnel
  let kS = fresnelSchlickRoughnessWithIridescence(F0, NdotV, perceptualRoughness, iridescenceFresnel, iridescence);
  let f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss = kS * f_ab.x + f_ab.y;
  var result: IblResult;
  result.FssEss = FssEss;

  // Specular IBL
  var specular = FssEss * radiance * specularWeight;

  // scale with user parameters
  let IBLSpecularContribution = iblParameter.z;
  specular *= IBLSpecularContribution;

  result.specular = specular;

  return result;
}

fn getIBLRadianceLambertianWithIridescence(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,
  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2i, rotEnvMatrix: mat3x3<f32>,
  normal_forEnv: vec3f, reflection: vec3f, iridescenceF0: vec3f, iridescence: f32, specularWeight: f32) -> IblResult
{
  // get irradiance
  let irradiance = get_irradiance(normal_forEnv, hdriFormat);

  // Use the maximum component of the iridescence Fresnel color
  // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF
  let iridescenceF0Max = vec3f(max(max(iridescenceF0.r, iridescenceF0.g), iridescenceF0.b));

  // Blend between base F0 and iridescence F0
  let mixedF0 = mix(F0, iridescenceF0Max, iridescence);

  // Roughness dependent fresnel
  let kS = fresnelSchlickRoughness(mixedF0, NdotV, perceptualRoughness);
  let f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss = specularWeight * kS * f_ab.x + f_ab.y;
  var result: IblResult;
  result.FssEss = FssEss;

  // Multiple scattering, Fdez-Aguera's approach
  let Ems = (1.0 - (f_ab.x + f_ab.y));
  let F_avg = specularWeight * (mixedF0 + (1.0 - mixedF0) / 21.0);
  let FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);
  let k_D = albedo * (1.0 - FssEss - FmsEms);

  // Diffuse IBL
  var diffuse = (FmsEms + k_D) * irradiance;

  // scale with user parameters
  let IBLDiffuseContribution = iblParameter.y;
  diffuse *= IBLDiffuseContribution;

  result.diffuse = diffuse;

  return result;
}
#endif // RN_USE_IRIDESCENCE

fn getIBLRadianceLambertian(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,
  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, rotEnvMatrix: mat3x3<f32>,
  normal_forEnv: vec3f, reflection: vec3f, specularWeight: f32) -> IblResult
{
  // get irradiance
  let irradiance: vec3f = get_irradiance(normal_forEnv, hdriFormat);

  // Roughness dependent fresnel
  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss: vec3f = specularWeight * kS * f_ab.x + f_ab.y;
  var result: IblResult;
  result.FssEss = FssEss;

  // Multiple scattering, Fdez-Aguera's approach
  let Ems = (1.0 - (f_ab.x + f_ab.y));
  let F_avg: vec3f = specularWeight * (F0 + (1.0 - F0) / 21.0);
  let FmsEms: vec3f = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);
  let k_D: vec3f = albedo * (1.0 - FssEss - FmsEms);

  // Diffuse IBL
  var diffuse: vec3f = (FmsEms + k_D) * irradiance;

  // scale with user parameters
  let IBLDiffuseContribution = iblParameter.y;
  diffuse *= IBLDiffuseContribution;

  result.diffuse = diffuse;

  return result;
}

fn getIBLRadianceGGX(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,
  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, rotEnvMatrix: mat3x3<f32>,
  normal_forEnv: vec3f, reflection: vec3f, specularWeight: f32) -> IblResult
{
  // get radiance
  let mipCount = iblParameter.x;
  let lod = (perceptualRoughness * (mipCount - 1.0));
  let radiance: vec3f = get_radiance(reflection, lod, hdriFormat);

  // Roughness dependent fresnel
  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss: vec3f = kS * f_ab.x + f_ab.y;
  var result: IblResult;
  result.FssEss = FssEss;

  // Specular IBL
  var specular: vec3f = FssEss * radiance * specularWeight;

  // scale with user parameters
  let IBLSpecularContribution = iblParameter.z;
  specular *= IBLSpecularContribution;

  result.specular = specular;

  return result;
}

fn IBLContribution(materialSID: u32, cameraSID: u32, normal_inWorld: vec3f, NdotV: f32, viewDirection: vec3f,
  albedo: vec3f, F0: vec3f, perceptualRoughness: f32,
  clearcoatRoughness: f32, clearcoatNormal_inWorld: vec3f, clearcoat: f32, VdotNc: f32, geomNormal_inWorld: vec3f,
  transmission: f32, v_position_inWorld: vec3f, instanceInfo: u32, thickness: f32, ior: f32,
  sheenColor: vec3f, sheenRoughness: f32, albedoSheenScalingNdotV: f32,
  iridescenceFresnel: vec3f, iridescenceF0: vec3f, iridescence: f32,
  anisotropy: f32, anisotropyDirection: vec3f, specularWeight: f32
  ) -> vec3f
{
  let iblParameter: vec4f = get_iblParameter(materialSID, 0);
  let rot = iblParameter.w;
  let rotEnvMatrix = mat3x3<f32>(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  let hdriFormat: vec2<i32> = get_hdriFormat(materialSID, 0);

  let normal_forEnv: vec3f = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  let reflection: vec3f = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);

  // IBL
#ifdef RN_USE_IRIDESCENCE
  let baseRadianceResult: IblResult = getIBLRadianceGGXWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,
    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceFresnel, iridescence, specularWeight);
  let baseLambertianResult: IblResult = getIBLRadianceLambertianWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,
    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceF0, iridescence, specularWeight);
#else
  let baseRadianceResult: IblResult = getIBLRadianceGGX(materialSID, NdotV, viewDirection, albedo, F0,
    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);
  let baseLambertianResult: IblResult = getIBLRadianceLambertian(materialSID, NdotV, viewDirection, albedo, F0,
    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);
#endif

#ifdef RN_USE_TRANSMISSION
  let refractedRay = getVolumeTransmissionRay(geomNormal_inWorld, viewDirection, thickness, ior, instanceInfo);
  let refractedRayFromVPosition = v_position_inWorld + refractedRay;
  let ndcPoint = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4f(refractedRayFromVPosition, 1.0);
  var refractionCoords = ndcPoint.xy / ndcPoint.w;
  refractionCoords += 1.0;
  refractionCoords /= 2.0;
  var transmittedLight = get_sample_from_backbuffer(materialSID, refractionCoords, perceptualRoughness, ior);

#ifdef RN_USE_VOLUME
  let attenuationColor = get_attenuationColor(materialSID, 0);
  let attenuationDistance = get_attenuationDistance(materialSID, 0);
  transmittedLight = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, length(refractedRay));
#endif

  let transmissionComp = (vec3f(1.0) - baseRadianceResult.FssEss) * transmittedLight * albedo;
  let diffuse = mix(baseLambertianResult.diffuse, transmissionComp, transmission);
  let base = diffuse + baseRadianceResult.specular;
#else
  let base: vec3f = baseLambertianResult.diffuse + baseRadianceResult.specular;
#endif

#ifdef RN_USE_SHEEN
  let sheen = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);
  let color = sheen + base * albedoSheenScalingNdotV;
#else
  let color = base;
#endif

#ifdef RN_USE_CLEARCOAT
  let VdotNg = dot(geomNormal_inWorld, viewDirection);
  let clearcoatNormal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  let coatResult: IblResult = getIBLRadianceGGX(materialSID, VdotNc, viewDirection, vec3f(0.0), F0,
    clearcoatRoughness, iblParameter, hdriFormat, rotEnvMatrix, clearcoatNormal_forEnv, reflection, specularWeight);
  let coatLayer = coatResult.specular;

  let clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);
  let coated = color * vec3f(1.0 - clearcoat * clearcoatFresnel) + vec3f(coatLayer * clearcoat);
  return coated;
#else
  return color;
#endif
}



@fragment
fn main(
  input: VertexOutput,
  @builtin(front_facing) isFront: bool,
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;

  let viewPosition = get_viewPosition(cameraSID, 0);
  let viewVector = viewPosition - input.position_inWorld.xyz;
  let viewDirection = normalize(viewVector);

// BaseColor
  var baseColor = vec4<f32>(1, 1, 1, 1);
  var baseColorFactor = get_baseColorFactor(materialSID, 0u);

#ifdef RN_USE_COLOR_0
  baseColor = input.color_0;
#endif

  baseColor *= baseColorFactor;

#ifdef RN_USE_TEXCOORD_0
  let baseColorTextureTransform: vec4f = get_baseColorTextureTransform(materialSID, 0);
  let baseColorTextureRotation: f32 = get_baseColorTextureRotation(materialSID, 0);
  let baseColorTexcoordIndex: u32 = u32(get_baseColorTexcoordIndex(materialSID, 0));
  let baseColorTexcoord = getTexcoord(baseColorTexcoordIndex, input);
  let baseColorTexUv = uvTransform(baseColorTextureTransform.xy, baseColorTextureTransform.zw, baseColorTextureRotation, baseColorTexcoord);
  let textureColor = textureSample(baseColorTexture, baseColorSampler, baseColorTexUv);
  baseColor *= vec4(srgbToLinear(textureColor.rgb), textureColor.a);
#else
  let baseColorTexUv = vec2f(0.0, 0.0);
#endif

#ifdef RN_IS_ALPHA_MODE_MASK
  let alphaCutoff = get_alphaCutoff(materialSID, 0);
  if (baseColor.a < alphaCutoff) {
    discard;
  }
#endif



// Normal
  var normal_inWorld = normalize(input.normal_inWorld);
  let geomNormal_inWorld = normal_inWorld;
  let normalTextureTransform: vec4f = get_normalTextureTransform(materialSID, 0);
  let normalTextureRotation: f32 = get_normalTextureRotation(materialSID, 0);
  let normalTexcoordIndex: u32 = u32(get_normalTexcoordIndex(materialSID, 0));
  let normalTexcoord: vec2f = getTexcoord(normalTexcoordIndex, input);
  let normalTexUv: vec2f = uvTransform(normalTextureTransform.xy, normalTextureTransform.zw, normalTextureRotation, normalTexcoord);
  let TBN: mat3x3<f32> = getTBN(normal_inWorld, input, viewVector, normalTexUv, isFront);
  #ifdef RN_USE_NORMAL_TEXTURE
    let normalTexValue: vec3f = textureSample(normalTexture, normalSampler, normalTexUv).xyz;
    if(normalTexValue.b >= 128.0 / 255.0) {
      // normal texture is existence
      let normalTex = normalTexValue * 2.0 - 1.0;
      let normalScale = get_normalScale(materialSID, 0);
      let scaledNormal = normalize(normalTex * vec3(normalScale, normalScale, 1.0));
      normal_inWorld = normalize(TBN * scaledNormal);
    }
  #endif

#ifdef RN_IS_LIGHTING
  // Metallic & Roughness
  let metallicRoughnessFactor: vec2f = get_metallicRoughnessFactor(materialSID, 0);
  var metallic = metallicRoughnessFactor.x;
  let metallicRoughnessTextureTransform = get_metallicRoughnessTextureTransform(materialSID, 0);
  let metallicRoughnessTextureRotation = get_metallicRoughnessTextureRotation(materialSID, 0);
  let metallicRoughnessTexcoordIndex = u32(get_metallicRoughnessTexcoordIndex(materialSID, 0));
  let metallicRoughnessTexcoord = getTexcoord(metallicRoughnessTexcoordIndex, input);
  let metallicRoughnessTexUv = uvTransform(metallicRoughnessTextureTransform.xy, metallicRoughnessTextureTransform.zw, metallicRoughnessTextureRotation, metallicRoughnessTexcoord);
  let ormTexel = textureSample(metallicRoughnessTexture, metallicRoughnessSampler, metallicRoughnessTexUv);
  var perceptualRoughness = ormTexel.g * metallicRoughnessFactor.y;
  metallic = ormTexel.b * metallic;
  metallic = clamp(metallic, 0.0, 1.0);
  perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
  let alphaRoughness = perceptualRoughness * perceptualRoughness;
    // filter NDF for specular AA --- https://jcgt.org/published/0010/02/02/
  let alphaRoughness2 = alphaRoughness * alphaRoughness;
  let filteredRoughness2 = IsotropicNDFFiltering(normal_inWorld, alphaRoughness2);
  perceptualRoughness = sqrt(sqrt(filteredRoughness2));

  // Albedo
  let black = vec3f(0.0);
  let albedo = mix(baseColor.rgb, black, metallic);

  // NdotV
  let NdotV = clamp(dot(normal_inWorld, viewDirection), Epsilon, 1.0);

#ifdef RN_USE_ANISOTROPY
  // Anisotropy
  var anisotropy: f32 = get_anisotropyStrength(materialSID, 0);
  let anisotropyRotation: vec2f = get_anisotropyRotation(materialSID, 0);
  var direction: vec2f = anisotropyRotation;
  let anisotropyTex: vec3f = textureSample(anisotropyTexture, anisotropySampler, baseColorTexUv).rgb;
  direction = anisotropyTex.rg * 2.0 - vec2f(1.0);
  direction = mat2x2<f32>(anisotropyRotation.x, anisotropyRotation.y, -anisotropyRotation.y, anisotropyRotation.x) * normalize(direction);
  anisotropy *= anisotropyTex.b;
  let anisotropicT: vec3f = normalize(TBN * vec3f(direction, 0.0));
  let anisotropicB: vec3f = normalize(cross(geomNormal_inWorld, anisotropicT));
  let BdotV: f32 = dot(anisotropicB, viewDirection);
  let TdotV: f32 = dot(anisotropicT, viewDirection);
#else
  let anisotropy = 0.0;
  let anisotropicT = vec3f(0.0, 0.0, 0.0);
  let anisotropicB = vec3f(0.0, 0.0, 0.0);
  let BdotV = 0.0;
  let TdotV = 0.0;
#endif

  // Clearcoat
#ifdef RN_USE_CLEARCOAT
  let clearcoatFactor = get_clearCoatFactor(materialSID, 0);
  let clearcoatTextureTransform = get_clearCoatTextureTransform(materialSID, 0);
  let clearcoatTextureRotation = get_clearCoatTextureRotation(materialSID, 0);
  let clearCoatTexcoordIndex = get_clearCoatTexcoordIndex(materialSID, 0);
  let clearCoatTexcoord = getTexcoord(clearCoatTexcoordIndex, input);
  let clearcoatTexUv = uvTransform(clearcoatTextureTransform.xy, clearcoatTextureTransform.zw, clearcoatTextureRotation, clearCoatTexcoord);
  let clearcoatTexture = textureSample(clearCoatTexture, clearCoatSampler, clearcoatTexUv).r;
  let clearcoat = clearcoatFactor * clearcoatTexture;
#else
  let clearcoat = 0.0;
#endif // RN_USE_CLEARCOAT

  // Transmission
#ifdef RN_USE_TRANSMISSION
  let transmissionFactor = get_transmissionFactor(materialSID, 0);
  let transmissionTexture = textureSample(transmissionTexture, transmissionSampler, baseColorTexUv).r;
  let transmission = transmissionFactor * transmissionTexture;
    // alpha *= transmission;
#else
  let transmission = 0.0;
#endif // RN_USE_TRANSMISSION

#ifdef RN_USE_SPECULAR
  let specularTexture: f32 = textureSample(specularTexture, specularSampler, baseColorTexUv).a;
  let specular: f32 = get_specularFactor(materialSID, 0) * specularTexture;
  let specularColorTexture: vec3f = srgbToLinear(textureSample(specularColorTexture, specularColorSampler, baseColorTexUv).rgb);
  let specularColor: vec3f = get_specularColorFactor(materialSID, 0) * specularColorTexture;
#else
  let specular = 1.0;
  let specularColor = vec3f(1.0, 1.0, 1.0);
#endif // RN_USE_SPECULAR

  // F0, F90
  let ior = get_ior(materialSID, 0);
  let outsideIor = 1.0;
  let dielectricSpecularF0 = min(
    ((ior - outsideIor) / (ior + outsideIor)) * ((ior - outsideIor) / (ior + outsideIor)) * specularColor,
    vec3f(1.0)
    ) * specular;
  let dielectricSpecularF90 = vec3f(specular);
  let F0 = mix(dielectricSpecularF0, baseColor.rgb, metallic);
  let F90 = mix(dielectricSpecularF90, vec3f(1.0), metallic);

// Iridescence
#ifdef RN_USE_IRIDESCENCE
  let iridescenceFactor: f32 = get_iridescenceFactor(materialSID, 0);
  let iridescenceTexture: f32 = textureSample(iridescenceTexture, iridescenceSampler, baseColorTexUv).r;
  let iridescence: f32 = iridescenceFactor * iridescenceTexture;
  let iridescenceIor: f32 = get_iridescenceIor(materialSID, 0);
  let thicknessRatio: f32 = textureSample(iridescenceThicknessTexture, iridescenceThicknessSampler, baseColorTexUv).r;
  let iridescenceThicknessMinimum: f32 = get_iridescenceThicknessMinimum(materialSID, 0);
  let iridescenceThicknessMaximum: f32 = get_iridescenceThicknessMaximum(materialSID, 0);
  let iridescenceThickness: f32 = mix(iridescenceThicknessMinimum, iridescenceThicknessMaximum, thicknessRatio);
  let iridescenceFresnel: vec3f = calcIridescence(1.0, iridescenceIor, NdotV, iridescenceThickness, F0);
  let iridescenceF0: vec3f = Schlick_to_F0(iridescenceFresnel, NdotV);
#else
  let iridescence = 0.0;
  let iridescenceFresnel = vec3f(0.0);
  let iridescenceF0: vec3f = F0;
#endif // RN_USE_IRIDESCENCE

// Clearcoat
#ifdef RN_USE_CLEARCOAT
  let clearcoatRoughnessFactor = get_clearCoatRoughnessFactor(materialSID, 0);
  let clearCoatRoughnessTexcoordIndex = get_clearCoatRoughnessTexcoordIndex(materialSID, 0);
  let clearCoatRoughnessTexcoord = getTexcoord(clearCoatRoughnessTexcoordIndex, input);
  let clearcoatRoughnessTextureTransform = get_clearCoatRoughnessTextureTransform(materialSID, 0);
  let clearcoatRoughnessTextureRotation = get_clearCoatRoughnessTextureRotation(materialSID, 0);
  let clearcoatRoughnessTexUv = uvTransform(clearcoatRoughnessTextureTransform.xy, clearcoatRoughnessTextureTransform.zw, clearcoatRoughnessTextureRotation, clearCoatRoughnessTexcoord);
  let textureRoughnessTexture = textureSample(clearCoatRoughnessTexture, clearCoatRoughnessSampler, clearcoatRoughnessTexUv).g;
  let clearcoatRoughness = clearcoatRoughnessFactor * textureRoughnessTexture;

  let clearCoatNormalTexcoordIndex = get_clearCoatNormalTexcoordIndex(materialSID, 0);
  let clearCoatNormalTexcoord = getTexcoord(clearCoatNormalTexcoordIndex, input);
  let clearcoatNormalTextureTransform = get_clearCoatNormalTextureTransform(materialSID, 0);
  let clearcoatNormalTextureRotation = get_clearCoatNormalTextureRotation(materialSID, 0);
  let clearcoatNormalTexUv = uvTransform(clearcoatNormalTextureTransform.xy, clearcoatNormalTextureTransform.zw, clearcoatNormalTextureRotation, clearCoatNormalTexcoord);
  let textureNormal_tangent = textureSample(clearCoatNormalTexture, clearCoatNormalSampler, clearcoatNormalTexUv).xyz * vec3(2.0) - vec3(1.0);
  let clearcoatNormal_inWorld = normalize(TBN * textureNormal_tangent);
  let VdotNc = saturateEpsilonToOne(dot(viewDirection, clearcoatNormal_inWorld));
#else
  let clearcoatRoughness = 0.0;
  let clearcoatNormal_inWorld = vec3f(0.0);
  let VdotNc = 0.0;
#endif // RN_USE_CLEARCOAT


#ifdef RN_USE_VOLUME
  // Volume
  let thicknessFactor: f32 = get_thicknessFactor(materialSID, 0);
  let thicknessTexture: f32 = textureSample(thicknessTexture, thicknessSampler, baseColorTexUv).g;
  let attenuationDistance: f32 = get_attenuationDistance(materialSID, 0);
  let attenuationColor: vec3f = get_attenuationColor(materialSID, 0);
  let thickness: f32 = thicknessFactor * thicknessTexture;
#else
  let thickness = 0.0;
  let attenuationColor = vec3f(0.0);
  let attenuationDistance = 0.000001;
#endif // RN_USE_VOLUME

#ifdef RN_USE_SHEEN
  // Sheen
  let sheenColorFactor: vec3f = get_sheenColorFactor(materialSID, 0);
  let sheenColorTexture: vec3f = textureSample(sheenColorTexture, sheenColorSampler, baseColorTexUv).rgb;
  let sheenRoughnessFactor: f32 = get_sheenRoughnessFactor(materialSID, 0);
  let sheenRoughnessTexture: f32 = textureSample(sheenRoughnessTexture, sheenRoughnessSampler, baseColorTexUv).a;
  let sheenColor: vec3f = sheenColorFactor * sheenColorTexture;
  let sheenRoughness: f32 = clamp(sheenRoughnessFactor * sheenRoughnessTexture, 0.000001, 1.0);
  let albedoSheenScalingNdotV: f32 = 1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotV, sheenRoughness)).r;
#else
  let sheenColor = vec3f(0.0);
  let sheenRoughness = 0.000001;
  let albedoSheenScalingNdotV = 1.0;
#endif // RN_USE_SHEEN

  var resultColor = vec3<f32>(0, 0, 0);
  var resultAlpha = baseColor.a;

  // Lighting
  let lightNumber = u32(get_lightNumber(0u, 0u));
  for (var i = 0u; i < lightNumber; i++) {
    let light: Light = getLight(i, input.position_inWorld);
    resultColor += lightingWithPunctualLight(light, normal_inWorld, viewDirection,
                            NdotV, albedo, perceptualRoughness, F0, F90,
                            transmission, ior,
                            clearcoat, clearcoatRoughness, clearcoatNormal_inWorld, VdotNc,
                            attenuationColor, attenuationDistance,
                            anisotropy, anisotropicT, anisotropicB, BdotV, TdotV,
                            sheenColor, sheenRoughness, albedoSheenScalingNdotV,
                            iridescence, iridescenceFresnel, specular
                            );
  }

  let ibl: vec3f = IBLContribution(materialSID, cameraSID, normal_inWorld, NdotV, viewDirection,
    albedo, F0, perceptualRoughness,
    clearcoatRoughness, clearcoatNormal_inWorld, clearcoat, VdotNc, geomNormal_inWorld,
    transmission, input.position_inWorld.xyz, u32(input.instanceInfo), thickness, ior,
    sheenColor, sheenRoughness, albedoSheenScalingNdotV,
    iridescenceFresnel, iridescenceF0, iridescence,
    anisotropy, anisotropicB, specular
  );

  let occlusionTexcoordIndex = get_occlusionTexcoordIndex(materialSID, 0);
  let occlusionTexcoord = getTexcoord(occlusionTexcoordIndex, input);
  let occlusionTextureTransform = get_occlusionTextureTransform(materialSID, 0);
  let occlusionTextureRotation = get_occlusionTextureRotation(materialSID, 0);
  let occlusionTexUv = uvTransform(occlusionTextureTransform.xy, occlusionTextureTransform.zw, occlusionTextureRotation, occlusionTexcoord);
  let occlusion = textureSample(occlusionTexture, occlusionSampler, occlusionTexUv).r;
  let occlusionStrength = get_occlusionStrength(materialSID, 0);

  // Occlution to Indirect Lights
  resultColor += mix(ibl, ibl * occlusion, occlusionStrength);
#else
  var resultColor = baseColor.rgb;
  var resultAlpha = baseColor.a;
#endif // RN_IS_LIGHTING

  // Emissive
  let emissiveFactor = get_emissiveFactor(materialSID, 0);
  let emissiveTexcoordIndex = get_emissiveTexcoordIndex(materialSID, 0);
  let emissiveTexcoord = getTexcoord(emissiveTexcoordIndex, input);
  let emissiveTextureTransform = get_emissiveTextureTransform(materialSID, 0);
  let emissiveTextureRotation = get_emissiveTextureRotation(materialSID, 0);
  let emissiveTexUv = uvTransform(emissiveTextureTransform.xy, emissiveTextureTransform.zw, emissiveTextureRotation, emissiveTexcoord);
  let emissiveStrength = get_emissiveStrength(materialSID, 0);
  let emissive = emissiveFactor * srgbToLinear(textureSample(emissiveTexture, emissiveSampler, emissiveTexUv).xyz) * emissiveStrength;

#ifdef RN_USE_CLEARCOAT
  let coated_emissive = emissive * mix(vec3f(1.0), vec3f(0.04 + (1.0 - 0.04) * pow(1.0 - NdotV, 5.0)), clearcoat);
  resultColor += coated_emissive;
#else
  resultColor += emissive;
#endif // RN_USE_CLEARCOAT

#ifdef RN_IS_ALPHA_MODE_BLEND
#else
  resultAlpha = 1.0;
#endif

let makeOutputSrgb = get_makeOutputSrgb(materialSID, 0);
resultColor = select(resultColor.rgb, linearToSrgb(resultColor.rgb), makeOutputSrgb);

  return vec4f(resultColor * resultAlpha, resultAlpha);
}
`, shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/EnvConstantSingleShader/EnvConstantSingleShader.vert
var EnvConstantSingleShader_default;
var init_EnvConstantSingleShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/EnvConstantSingleShader/EnvConstantSingleShader.vert"() {
    EnvConstantSingleShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\n#ifdef WEBGL2_MULTI_VIEW\n  layout(num_views=2) in;\n#endif\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\n\nout vec2 v_texcoord_0;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec3 v_position_inWorld;\n\nuniform bool u_enableViewMatrix; // initialValue=true\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n\n  if (get_enableViewMatrix(materialSID, 0)) {\n    mat4 rotateMatrix = viewMatrix;\n    rotateMatrix[3][0] = 0.0;\n    rotateMatrix[3][1] = 0.0;\n    rotateMatrix[3][2] = 0.0;\n    gl_Position = projectionMatrix * rotateMatrix * worldMatrix * vec4(a_position, 1.0);\n  } else {\n    gl_Position = projectionMatrix * worldMatrix * vec4(a_position, 1.0);\n  }\n\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  v_normal_inWorld = normalMatrix * a_normal;\n\n  v_color = a_color;\n  v_position_inWorld = (worldMatrix * vec4(a_position, 1.0)).xyz;\n  v_texcoord_0 = a_texcoord_0;\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/EnvConstantSingleShader/EnvConstantSingleShader.frag
var EnvConstantSingleShader_default2;
var init_EnvConstantSingleShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/EnvConstantSingleShader/EnvConstantSingleShader.frag"() {
    EnvConstantSingleShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord_0;\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec3 v_position_inWorld;\n\nuniform int u_envHdriFormat; // initialValue=0\nuniform float u_envRotation; // initialValue=0\nuniform vec4 u_diffuseColorFactor; // initialValue=(1,1,1,1)\nuniform samplerCube u_colorEnvTexture; // initialValue=(0,black)\nuniform bool u_makeOutputSrgb; // initialValue=true\nuniform bool u_inverseEnvironment; // initialValue=false\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nvec3 linearToSrgb(vec3 linearColor) {\n  return pow(linearColor, vec3(1.0/2.2));\n}\n\nvec3 srgbToLinear(vec3 srgbColor) {\n  return pow(srgbColor, vec3(2.2));\n}\n\nvoid main() {\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  // diffuseColor\n  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n  float alpha = 1.0;\n  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);\n  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {\n    diffuseColor = v_color * diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (v_color == diffuseColor) {\n    diffuseColor = diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (diffuseColorFactor.rgb == diffuseColor) {\n    diffuseColor = v_color;\n  } else {\n    diffuseColor = vec3(1.0, 1.0, 1.0);\n  }\n\n  // diffuseColorTexture\n\n  // adapt OpenGL (RenderMan) CubeMap convention\n  float envRotation = get_envRotation(materialSID, 0);\n  float rot = envRotation;\n  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  vec3 envNormal = normalize(rotEnvMatrix * v_position_inWorld);\n\n  if (get_inverseEnvironment(materialSID, 0)) {\n    envNormal.x *= -1.0;\n  }\n\n  vec4 diffuseTexel = texture(u_colorEnvTexture, envNormal);\n  vec3 textureColor;\n  int EnvHdriFormat = get_envHdriFormat(materialSID, 0);\n  if (EnvHdriFormat == 0) { // LDR_SRGB\n    textureColor = srgbToLinear(diffuseTexel.rgb);\n  } else if (EnvHdriFormat == 3) { // RGBE\n    textureColor = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);\n  } else {\n    textureColor = diffuseTexel.rgb;\n  }\n  diffuseColor *= textureColor;\n\n  rt0 = vec4(diffuseColor, alpha);\n\nfloat makeOutputSrgb = float(get_makeOutputSrgb(materialSID, 0));\nrt0.rgb = mix(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb);\n\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/EnvConstantSingleShader/EnvConstantSingleShader.vert
var EnvConstantSingleShader_default3;
var init_EnvConstantSingleShader3 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/EnvConstantSingleShader/EnvConstantSingleShader.vert"() {
    EnvConstantSingleShader_default3 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n// #param enableViewMatrix: bool; // initialValue=true\n\n@vertex\nfn main(\n#ifdef RN_USE_INSTANCE\n  @location(8) instance_ids: vec4<f32>,\n#endif\n\n\n#ifdef RN_USE_POSITION_FLOAT\n  @location(0) position: vec3<f32>,\n#endif\n#ifdef RN_USE_POSITION_INT\n  @location(0) position: vec3<i32>,\n#endif\n#ifdef RN_USE_POSITION_UINT\n  @location(0) position: vec3<u32>,\n#endif\n\n#ifdef RN_USE_NORMAL\n  @location(1) normal: vec3<f32>,\n#endif\n#ifdef RN_USE_TANGENT\n  @location(2) tangent: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_0\n  @location(3) texcoord_0: vec2<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  @location(4) texcoord_1: vec2<f32>,\n#endif\n\n#ifdef RN_USE_COLOR_0_FLOAT\n  @location(5) color_0: vec4<f32>,\n#endif\n#ifdef RN_USE_COLOR_0_INT\n  @location(5) color_0: vec4<i32>,\n#endif\n#ifdef RN_USE_COLOR_0_UINT\n  @location(5) color_0: vec4<u32>,\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  @location(6) joints_0: vec4<u32>,\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  @location(7) weights_0: vec4<f32>,\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  @location(10) baryCentricCoord: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  @location(11) texcoord_2: vec2<f32>,\n#endif\n  @builtin(vertex_index) vertexIdx : u32,\n\n\n) -> VertexOutput {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var output : VertexOutput;\n\n  let worldMatrix = get_worldMatrix(u32(instance_ids.x));\n  let viewMatrix = get_viewMatrix(cameraSID, 0u);\n  let projectionMatrix = get_projectionMatrix(cameraSID, 0u);\n\n  if (get_enableViewMatrix(materialSID, 0u)) {\n    var rotateMatrix = viewMatrix;\n    rotateMatrix[3][0] = 0.0;\n    rotateMatrix[3][1] = 0.0;\n    rotateMatrix[3][2] = 0.0;\n    output.position = projectionMatrix * rotateMatrix * worldMatrix * vec4f(position, 1.0);\n  } else {\n    output.position = projectionMatrix * worldMatrix * vec4f(position, 1.0);\n  }\n\n  let normalMatrix = get_normalMatrix(u32(instance_ids.x));\n  output.normal_inWorld = normalMatrix * normal;\n\n#ifdef RN_USE_COLOR_0\n  output.color_0 = color_0;\n#endif\n  output.position_inWorld = (worldMatrix * vec4f(position, 1.0)).xyz;\n  output.texcoord_0 = texcoord_0;\n\n  return output;\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/EnvConstantSingleShader/EnvConstantSingleShader.frag
var EnvConstantSingleShader_default4;
var init_EnvConstantSingleShader4 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/EnvConstantSingleShader/EnvConstantSingleShader.frag"() {
    EnvConstantSingleShader_default4 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n// #param envHdriFormat: i32; // initialValue=0\n// #param envRotation: f32; // initialValue=0\n// #param diffuseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)\n@group(1) @binding(0) var colorEnvTexture: texture_cube<f32>; // initialValue=black\n@group(2) @binding(0) var colorEnvSampler: sampler;\n// #param makeOutputSrgb: bool; // initialValue=1\n// #param inverseEnvironment: bool; // initialValue=false\n\nfn linearToSrgb(linearColor: vec3f) -> vec3f {\n  return pow(linearColor, vec3f(1.0/2.2));\n}\n\nfn srgbToLinear(srgbColor: vec3f) -> vec3f {\n  return pow(srgbColor, vec3f(2.2));\n}\n\n\n@fragment\nfn main(\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var diffuseColor = vec4<f32>(1, 1, 1, 1);\n#ifdef RN_USE_COLOR_0\n  diffuseColor = input.color_0;\n#endif\n  let diffuseColorFactor = get_diffuseColorFactor(materialSID, 0u);\n  diffuseColor *= diffuseColorFactor;\n\n  let envRotation: f32 = get_envRotation(materialSID, 0u);\n  let rot = envRotation;\n  let rotEnvMatrix = mat3x3<f32>(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));\n  var envNormal: vec3f = normalize(rotEnvMatrix * input.position_inWorld);\n\n  if (get_inverseEnvironment(materialSID, 0)) {\n    envNormal.x *= -1.0;\n  }\n\n  let diffuseTexel = textureSampleLevel(colorEnvTexture, colorEnvSampler, envNormal, 0.0);\n  var textureColor: vec3f;\n  let EnvHdriFormat: i32 = get_envHdriFormat(materialSID, 0);\n  if (EnvHdriFormat == 0) { // LDR_SRGB\n    textureColor = srgbToLinear(diffuseTexel.rgb);\n  } else if (EnvHdriFormat == 3) { // RGBE\n    textureColor = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);\n  } else {\n    textureColor = diffuseTexel.rgb;\n  }\n  diffuseColor *= vec4f(textureColor, 1.0);\n\n  var resultColor = diffuseColor.rgb;\n  let resultAlpha = diffuseColor.a;\n\nlet makeOutputSrgb = get_makeOutputSrgb(materialSID, 0);\nresultColor = select(resultColor.rgb, linearToSrgb(resultColor.rgb), makeOutputSrgb);\n\n\n  return vec4f(resultColor, resultAlpha);\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/FXAA3QualityShader/FXAA3QualitySingleShader.vert
var FXAA3QualitySingleShader_default;
var init_FXAA3QualitySingleShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/FXAA3QualityShader/FXAA3QualitySingleShader.vert"() {
    FXAA3QualitySingleShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nout vec2 v_texcoord_0;\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/FXAA3QualityShader/FXAA3QualitySingleShader.frag
var FXAA3QualitySingleShader_default2;
var init_FXAA3QualitySingleShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/FXAA3QualityShader/FXAA3QualitySingleShader.frag"() {
    FXAA3QualitySingleShader_default2 = { code: `
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/**
 * This file contains source code provided by NVIDIA Corporation.
 * FXAA antialiasing is developed by NVIDIA.
 * The codes of this file is modified from original code to work on WebGL1.
 * The modification for GLSL 100 is referred from Three.js, https://github.com/mrdoob/three.js/blob/5ba4c25bcb74577e1b1e14906f345135610a94f3/examples/js/shaders/FXAAShader.js
 * The original FXAA code is https://github.com/NVIDIAGameWorks/GraphicsSamples/blob/80e8ba8f5e8935821513207033490735dd3279d8/samples/es3-kepler/FXAA/FXAA3_11.h
 */

//----------------------------------------------------------------------------------
// File:        es3-kepler\\FXAA/FXAA3_11.h
// SDK Version: v3.00
// Email:       gameworks@nvidia.com
// Site:        http://developer.nvidia.com/
//
// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name of NVIDIA CORPORATION nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS 'AS IS' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//----------------------------------------------------------------------------------
/*============================================================================
                    NVIDIA FXAA 3.11 by TIMOTHY LOTTES
============================================================================*/


/* shaderity: @{definitions} */

const float Epsilon = 0.0000001;
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}

float saturate(float t)
{
  return clamp(t, 0.0, 1.0);
}


in vec2 v_texcoord_0;

uniform sampler2D u_baseColorTexture; // initialValue=(0,white)

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */



  #define FXAA_PC 1
  #define FXAA_QUALITYPRESET 39
  #define FXAA_GREEN_AS_LUMA 0
  #define FXAA_GLSL_100 1

  /*============================================================================
                                INTEGRATION KNOBS
  ============================================================================*/
  //
  // FXAA_PS3 and FXAA_360 choose the console algorithm (FXAA3 CONSOLE).
  // FXAA_360_OPT is a prototype for the new optimized 360 version.
  //
  // 1 = Use API.
  // 0 = Don't use API.
  //
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_PS3
  #define FXAA_PS3 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_360
  #define FXAA_360 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_360_OPT
  #define FXAA_360_OPT 0
  #endif
  /*==========================================================================*/
  #ifndef FXAA_PC
  //
  // FXAA Quality
  // The high quality PC algorithm.
  //
  #define FXAA_PC 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_PC_CONSOLE
  //
  // The console algorithm for PC is included
  // for developers targeting really low spec machines.
  // Likely better to just run FXAA_PC, and use a really low preset.
  //
  #define FXAA_PC_CONSOLE 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_GLSL_120
  #define FXAA_GLSL_120 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_GLSL_130
  #define FXAA_GLSL_130 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_HLSL_3
  #define FXAA_HLSL_3 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_HLSL_4
  #define FXAA_HLSL_4 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_HLSL_5
  #define FXAA_HLSL_5 0
  #endif
  /*==========================================================================*/
  #ifndef FXAA_GREEN_AS_LUMA
  //
  // For those using non-linear color,
  // and either not able to get luma in alpha, or not wanting to,
  // this enables FXAA to run using green as a proxy for luma.
  // So with this enabled, no need to pack luma in alpha.
  //
  // This will turn off AA on anything which lacks some amount of green.
  // Pure red and blue or combination of only R and B, will get no AA.
  //
  // Might want to lower the settings for both,
  //    fxaaConsoleEdgeThresholdMin
  //    fxaaQualityEdgeThresholdMin
  // In order to insure AA does not get turned off on colors
  // which contain a minor amount of green.
  //
  // 1 = On.
  // 0 = Off.
  //
  #define FXAA_GREEN_AS_LUMA 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_EARLY_EXIT
  //
  // Controls algorithm's early exit path.
  // On PS3 turning this ON adds 2 cycles to the shader.
  // On 360 turning this OFF adds 10ths of a millisecond to the shader.
  // Turning this off on console will result in a more blurry image.
  // So this defaults to on.
  //
  // 1 = On.
  // 0 = Off.
  //
  #define FXAA_EARLY_EXIT 1
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_DISCARD
  //
  // Only valid for PC OpenGL currently.
  // Probably will not work when FXAA_GREEN_AS_LUMA = 1.
  //
  // 1 = Use discard on pixels which don't need AA.
  //     For APIs which enable concurrent TEX+ROP from same surface.
  // 0 = Return unchanged color on pixels which don't need AA.
  //
  #define FXAA_DISCARD 0
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_FAST_PIXEL_OFFSET
  //
  // Used for GLSL 120 only.
  //
  // 1 = GL API supports fast pixel offsets
  // 0 = do not use fast pixel offsets
  //
  #ifdef GLEXT_gpu_shader4
  #define FXAA_FAST_PIXEL_OFFSET 1
  #endif
  #ifdef GLNV_gpu_shader5
  #define FXAA_FAST_PIXEL_OFFSET 1
  #endif
  #ifdef GLARB_gpu_shader5
  #define FXAA_FAST_PIXEL_OFFSET 1
  #endif
  #ifndef FXAA_FAST_PIXEL_OFFSET
  #define FXAA_FAST_PIXEL_OFFSET 0
  #endif
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_GATHER4_ALPHA
  //
  // 1 = API supports gather4 on alpha channel.
  // 0 = API does not support gather4 on alpha channel.
  //
  #if (FXAA_HLSL_5 == 1)
  #define FXAA_GATHER4_ALPHA 1
  #endif
  #ifdef GLARB_gpu_shader5
  #define FXAA_GATHER4_ALPHA 1
  #endif
  #ifdef GLNV_gpu_shader5
  #define FXAA_GATHER4_ALPHA 1
  #endif
  #ifndef FXAA_GATHER4_ALPHA
  #define FXAA_GATHER4_ALPHA 0
  #endif
  #endif

  /*============================================================================
                        FXAA CONSOLE PS3 - TUNING KNOBS
  ============================================================================*/
  #ifndef FXAA_CONSOLEPS3_EDGE_SHARPNESS
  //
  // Consoles the sharpness of edges on PS3 only.
  // Non-PS3 tuning is done with shader input.
  //
  // Due to the PS3 being ALU bound,
  // there are only two safe values here: 4 and 8.
  // These options use the shaders ability to a free *|/ by 2|4|8.
  //
  // 8.0 is sharper
  // 4.0 is softer
  // 2.0 is really soft (good for vector graphics inputs)
  //
  #if 1
  #define FXAA_CONSOLEPS3_EDGE_SHARPNESS 8.0
  #endif
  #if 0
  #define FXAA_CONSOLEPS3_EDGE_SHARPNESS 4.0
  #endif
  #if 0
  #define FXAA_CONSOLEPS3_EDGE_SHARPNESS 2.0
  #endif
  #endif
  /*--------------------------------------------------------------------------*/
  #ifndef FXAA_CONSOLEPS3_EDGE_THRESHOLD
  //
  // Only effects PS3.
  // Non-PS3 tuning is done with shader input.
  //
  // The minimum amount of local contrast required to apply algorithm.
  // The console setting has a different mapping than the quality setting.
  //
  // This only applies when FXAA_EARLY_EXIT is 1.
  //
  // Due to the PS3 being ALU bound,
  // there are only two safe values here: 0.25 and 0.125.
  // These options use the shaders ability to a free *|/ by 2|4|8.
  //
  // 0.125 leaves less aliasing, but is softer
  // 0.25 leaves more aliasing, and is sharper
  //
  #if 1
  #define FXAA_CONSOLEPS3_EDGE_THRESHOLD 0.125
  #else
  #define FXAA_CONSOLEPS3_EDGE_THRESHOLD 0.25
  #endif
  #endif

  /*============================================================================
                          FXAA QUALITY - TUNING KNOBS
  ------------------------------------------------------------------------------
  NOTE the other tuning knobs are now in the shader function inputs!
  ============================================================================*/
  #ifndef FXAA_QUALITYPRESET
  //
  // Choose the quality preset.
  // This needs to be compiled into the shader as it effects code.
  // Best option to include multiple presets is to
  // in each shader define the preset, then include this file.
  //
  // OPTIONS
  // -----------------------------------------------------------------------
  // 10 to 15 - default medium dither (10=fastest, 15=highest quality)
  // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)
  // 39       - no dither, very expensive
  //
  // NOTES
  // -----------------------------------------------------------------------
  // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)
  // 13 = about same speed as FXAA 3.9 and better than 12
  // 23 = closest to FXAA 3.9 visually and performance wise
  //  _ = the lowest digit is directly related to performance
  // _  = the highest digit is directly related to style
  //
  #define FXAA_QUALITYPRESET 12
  #endif


  /*============================================================================
                             FXAA QUALITY - PRESETS
  ============================================================================*/

  /*============================================================================
                       FXAA QUALITY - MEDIUM DITHER PRESETS
  ============================================================================*/
  #if(FXAA_QUALITYPRESET == 10)
#define FXAA_QUALITYPS 3
#define FXAA_QUALITYP0 1.5
#define FXAA_QUALITYP1 3.0
#define FXAA_QUALITYP2 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 11)
#define FXAA_QUALITYPS 4
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 3.0
#define FXAA_QUALITYP3 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 12)
#define FXAA_QUALITYPS 5
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 4.0
#define FXAA_QUALITYP4 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 13)
#define FXAA_QUALITYPS 6
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 4.0
#define FXAA_QUALITYP5 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 14)
#define FXAA_QUALITYPS 7
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 4.0
#define FXAA_QUALITYP6 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 15)
#define FXAA_QUALITYPS 8
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 2.0
#define FXAA_QUALITYP6 4.0
#define FXAA_QUALITYP7 12.0
#endif

/*============================================================================
                     FXAA QUALITY - LOW DITHER PRESETS
============================================================================*/
#if (FXAA_QUALITYPRESET == 20)
#define FXAA_QUALITYPS 3
#define FXAA_QUALITYP0 1.5
#define FXAA_QUALITYP1 2.0
#define FXAA_QUALITYP2 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 21)
#define FXAA_QUALITYPS 4
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 22)
#define FXAA_QUALITYPS 5
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 23)
#define FXAA_QUALITYPS 6
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 24)
#define FXAA_QUALITYPS 7
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 3.0
#define FXAA_QUALITYP6 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 25)
#define FXAA_QUALITYPS 8
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 2.0
#define FXAA_QUALITYP6 4.0
#define FXAA_QUALITYP7 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 26)
#define FXAA_QUALITYPS 9
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 2.0
#define FXAA_QUALITYP6 2.0
#define FXAA_QUALITYP7 4.0
#define FXAA_QUALITYP8 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 27)
#define FXAA_QUALITYPS 10
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 2.0
#define FXAA_QUALITYP6 2.0
#define FXAA_QUALITYP7 2.0
#define FXAA_QUALITYP8 4.0
#define FXAA_QUALITYP9 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 28)
#define FXAA_QUALITYPS 11
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 2.0
#define FXAA_QUALITYP6 2.0
#define FXAA_QUALITYP7 2.0
#define FXAA_QUALITYP8 2.0
#define FXAA_QUALITYP9 4.0
#define FXAA_QUALITYP10 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITYPRESET == 29)
#define FXAA_QUALITYPS 12
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.5
#define FXAA_QUALITYP2 2.0
#define FXAA_QUALITYP3 2.0
#define FXAA_QUALITYP4 2.0
#define FXAA_QUALITYP5 2.0
#define FXAA_QUALITYP6 2.0
#define FXAA_QUALITYP7 2.0
#define FXAA_QUALITYP8 2.0
#define FXAA_QUALITYP9 2.0
#define FXAA_QUALITYP10 4.0
#define FXAA_QUALITYP11 8.0
#endif

/*============================================================================
                     FXAA QUALITY - EXTREME QUALITY
============================================================================*/
#if (FXAA_QUALITYPRESET == 39)
#define FXAA_QUALITYPS 12
#define FXAA_QUALITYP0 1.0
#define FXAA_QUALITYP1 1.0
#define FXAA_QUALITYP2 1.0
#define FXAA_QUALITYP3 1.0
#define FXAA_QUALITYP4 1.0
#define FXAA_QUALITYP5 1.5
#define FXAA_QUALITYP6 2.0
#define FXAA_QUALITYP7 2.0
#define FXAA_QUALITYP8 2.0
#define FXAA_QUALITYP9 2.0
#define FXAA_QUALITYP10 4.0
#define FXAA_QUALITYP11 8.0
#endif



/*============================================================================
                                API PORTING
============================================================================*/
#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)
#define FxaaBool bool
#define FxaaDiscard discard
#define FxaaFloat float
#define FxaaFloat2 vec2
#define FxaaFloat3 vec3
#define FxaaFloat4 vec4
#define FxaaHalf float
#define FxaaHalf2 vec2
#define FxaaHalf3 vec3
#define FxaaHalf4 vec4
#define FxaaInt2 ivec2
#define FxaaSat(x) clamp(x, 0.0, 1.0)
#define FxaaTex sampler2D
#else
#define FxaaBool bool
#define FxaaDiscard clip(-1)
#define FxaaFloat float
#define FxaaFloat2 float2
#define FxaaFloat3 float3
#define FxaaFloat4 float4
#define FxaaHalf half
#define FxaaHalf2 half2
#define FxaaHalf3 half3
#define FxaaHalf4 half4
#define FxaaSat(x) saturate(x)
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_GLSL_100 == 1)
#define FxaaTexTop(t, p) texture(t, p, 0.0)
#define FxaaTexOff(t, p, o, r) texture(t, p + (o * r), 0.0)
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_GLSL_120 == 1)
// Requires,
//  #version 120
// And at least,
//  #extension GLEXT_gpu_shader4 : enable
//  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)
#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)
#if (FXAA_FAST_PIXEL_OFFSET == 1)
#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)
#else
#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)
#endif
#if (FXAA_GATHER4_ALPHA == 1)
// use #extension GLARB_gpu_shader5 : enable
#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
#define FxaaTexGreen4(t, p) textureGather(t, p, 1)
#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
#endif
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_GLSL_130 == 1)
// Requires "#version 130" or better
#define FxaaTexTop(t, p) textureLod(t, p, 0.0)
#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)
#if (FXAA_GATHER4_ALPHA == 1)
// use #extension GLARB_gpu_shader5 : enable
#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
#define FxaaTexGreen4(t, p) textureGather(t, p, 1)
#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
#endif
#endif


/*============================================================================
                   GREEN AS LUMA OPTION SUPPORT FUNCTION
============================================================================*/
#if (FXAA_GREEN_AS_LUMA == 0)
  FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return dot(rgba.rgb, vec3(0.298912, 0.586611, 0.114478)); }
  // FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }
#else
  FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }
#endif









/*============================================================================
                             FXAA3 QUALITY - PC
============================================================================*/
#if (FXAA_PC == 1)
  /*--------------------------------------------------------------------------*/
  FxaaFloat4 FxaaPixelShader(
    //
    // Use noperspective interpolation here (turn off perspective interpolation).
    // {xy} = center of pixel
    FxaaFloat2 pos,
    //
    // Used only for FXAA Console, and not used on the 360 version.
    // Use noperspective interpolation here (turn off perspective interpolation).
    // {xy} = upper left of pixel
    // {zw} = lower right of pixel
    FxaaFloat4 fxaaConsolePosPos,
    //
    // Input color texture.
    // {rgb_} = color in linear or perceptual color space
    // if (FXAA_GREEN_AS_LUMA == 0)
    //     {_a} = luma in perceptual color space (not linear)
    FxaaTex tex,
    //
    // Only used on the optimized 360 version of FXAA Console.
    // For everything but 360, just use the same input here as for "tex".
    // For 360, same texture, just alias with a 2nd sampler.
    // This sampler needs to have an exponent bias of -1.
    FxaaTex fxaaConsole360TexExpBiasNegOne,
    //
    // Only used on the optimized 360 version of FXAA Console.
    // For everything but 360, just use the same input here as for "tex".
    // For 360, same texture, just alias with a 3nd sampler.
    // This sampler needs to have an exponent bias of -2.
    FxaaTex fxaaConsole360TexExpBiasNegTwo,
    //
    // Only used on FXAA Quality.
    // This must be from a constant/uniform.
    // {x_} = 1.0/screenWidthInPixels
    // {_y} = 1.0/screenHeightInPixels
    FxaaFloat2 fxaaQualityRcpFrame,
    //
    // Only used on FXAA Console.
    // This must be from a constant/uniform.
    // This effects sub-pixel AA quality and inversely sharpness.
    //   Where N ranges between,
    //     N = 0.50 (default)
    //     N = 0.33 (sharper)
    // {x_} = -N/screenWidthInPixels
    // {_y} = -N/screenHeightInPixels
    // {z_} =  N/screenWidthInPixels
    // {_w} =  N/screenHeightInPixels
    FxaaFloat4 fxaaConsoleRcpFrameOpt,
    //
    // Only used on FXAA Console.
    // Not used on 360, but used on PS3 and PC.
    // This must be from a constant/uniform.
    // {x_} = -2.0/screenWidthInPixels
    // {_y} = -2.0/screenHeightInPixels
    // {z_} =  2.0/screenWidthInPixels
    // {_w} =  2.0/screenHeightInPixels
    FxaaFloat4 fxaaConsoleRcpFrameOpt2,
    //
    // Only used on FXAA Console.
    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.
    // This must be from a constant/uniform.
    // {x_} =  8.0/screenWidthInPixels
    // {_y} =  8.0/screenHeightInPixels
    // {z_} = -4.0/screenWidthInPixels
    // {_w} = -4.0/screenHeightInPixels
    FxaaFloat4 fxaaConsole360RcpFrameOpt2,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITYSUBPIX define.
    // It is here now to allow easier tuning.
    // Choose the amount of sub-pixel aliasing removal.
    // This can effect sharpness.
    //   1.00 - upper limit (softer)
    //   0.75 - default amount of filtering
    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)
    //   0.25 - almost off
    //   0.00 - completely off
    FxaaFloat fxaaQualitySubpix,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITYEDGE_THRESHOLD define.
    // It is here now to allow easier tuning.
    // The minimum amount of local contrast required to apply algorithm.
    //   0.333 - too little (faster)
    //   0.250 - low quality
    //   0.166 - default
    //   0.125 - high quality
    //   0.063 - overkill (slower)
    FxaaFloat fxaaQualityEdgeThreshold,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITYEDGE_THRESHOLD_MIN define.
    // It is here now to allow easier tuning.
    // Trims the algorithm from processing darks.
    //   0.0833 - upper limit (default, the start of visible unfiltered edges)
    //   0.0625 - high quality (faster)
    //   0.0312 - visible limit (slower)
    // Special notes when using FXAA_GREEN_AS_LUMA,
    //   Likely want to set this to zero.
    //   As colors that are mostly not-green
    //   will appear very dark in the green channel!
    //   Tune by looking at mostly non-green content,
    //   then start at zero and increase until aliasing is a problem.
    FxaaFloat fxaaQualityEdgeThresholdMin,
    //
    // Only used on FXAA Console.
    // This used to be the FXAA_CONSOLEEDGE_SHARPNESS define.
    // It is here now to allow easier tuning.
    // This does not effect PS3, as this needs to be compiled in.
    //   Use FXAA_CONSOLEPS3_EDGE_SHARPNESS for PS3.
    //   Due to the PS3 being ALU bound,
    //   there are only three safe values here: 2 and 4 and 8.
    //   These options use the shaders ability to a free *|/ by 2|4|8.
    // For all other platforms can be a non-power of two.
    //   8.0 is sharper (default!!!)
    //   4.0 is softer
    //   2.0 is really soft (good only for vector graphics inputs)
    FxaaFloat fxaaConsoleEdgeSharpness,
    //
    // Only used on FXAA Console.
    // This used to be the FXAA_CONSOLEEDGE_THRESHOLD define.
    // It is here now to allow easier tuning.
    // This does not effect PS3, as this needs to be compiled in.
    //   Use FXAA_CONSOLEPS3_EDGE_THRESHOLD for PS3.
    //   Due to the PS3 being ALU bound,
    //   there are only two safe values here: 1/4 and 1/8.
    //   These options use the shaders ability to a free *|/ by 2|4|8.
    // The console setting has a different mapping than the quality setting.
    // Other platforms can use other values.
    //   0.125 leaves less aliasing, but is softer (default!!!)
    //   0.25 leaves more aliasing, and is sharper
    FxaaFloat fxaaConsoleEdgeThreshold,
    //
    // Only used on FXAA Console.
    // This used to be the FXAA_CONSOLEEDGE_THRESHOLD_MIN define.
    // It is here now to allow easier tuning.
    // Trims the algorithm from processing darks.
    // The console setting has a different mapping than the quality setting.
    // This only applies when FXAA_EARLY_EXIT is 1.
    // This does not apply to PS3,
    // PS3 was simplified to avoid more shader instructions.
    //   0.06 - faster but more aliasing in darks
    //   0.05 - default
    //   0.04 - slower and less aliasing in darks
    // Special notes when using FXAA_GREEN_AS_LUMA,
    //   Likely want to set this to zero.
    //   As colors that are mostly not-green
    //   will appear very dark in the green channel!
    //   Tune by looking at mostly non-green content,
    //   then start at zero and increase until aliasing is a problem.
    FxaaFloat fxaaConsoleEdgeThresholdMin,
    //
    // Extra constants for 360 FXAA Console only.
    // Use zeros or anything else for other platforms.
    // These must be in physical constant registers and NOT immedates.
    // Immedates will result in compiler un-optimizing.
    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)
    FxaaFloat4 fxaaConsole360ConstDir
  ) {
  /*--------------------------------------------------------------------------*/
  FxaaFloat2 posM;
  posM.x = pos.x;
  posM.y = pos.y;
  #if (FXAA_GATHER4_ALPHA == 1)
  #if (FXAA_DISCARD == 0)
    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
  #if (FXAA_GREEN_AS_LUMA == 0)
  #define lumaM rgbyM.w
  #else
  #define lumaM rgbyM.y
  #endif
  #endif
  #if (FXAA_GREEN_AS_LUMA == 0)
    FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);
  FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));
  #else
  FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);
  FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));
  #endif
  #if (FXAA_DISCARD == 1)
  #define lumaM luma4A.w
  #endif
  #define lumaE luma4A.z
  #define lumaS luma4A.x
  #define lumaSE luma4A.y
  #define lumaNW luma4B.w
  #define lumaN luma4B.z
  #define lumaW luma4B.x
  #else
  FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
  #if (FXAA_GREEN_AS_LUMA == 0)
  #define lumaM rgbyM.w
  #else
  #define lumaM rgbyM.y
  #endif
  #if (FXAA_GLSL_100 == 1)
    FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0, 1.0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 0.0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0, -1.0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));
  #else
  FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, 1), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, -1), fxaaQualityRcpFrame.xy));
  #endif
  #endif
  /*--------------------------------------------------------------------------*/
  FxaaFloat maxSM = max(lumaS, lumaM);
  FxaaFloat minSM = min(lumaS, lumaM);
  FxaaFloat maxESM = max(lumaE, maxSM);
  FxaaFloat minESM = min(lumaE, minSM);
  FxaaFloat maxWN = max(lumaN, lumaW);
  FxaaFloat minWN = min(lumaN, lumaW);
  FxaaFloat rangeMax = max(maxWN, maxESM);
  FxaaFloat rangeMin = min(minWN, minESM);
  FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
  FxaaFloat range = rangeMax - rangeMin;
  FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
  FxaaBool earlyExit = range < rangeMaxClamped;
  /*--------------------------------------------------------------------------*/
  if (earlyExit)
  #if (FXAA_DISCARD == 1)
    FxaaDiscard;
  #else
  return rgbyM;
  #endif
  /*--------------------------------------------------------------------------*/
  #if (FXAA_GATHER4_ALPHA == 0)
  #if (FXAA_GLSL_100 == 1)
    FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, -1.0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 1.0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, -1.0), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));
  #else
  FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, -1), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 1), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
  #endif
  #else
  FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));
  FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
  #endif
  /*--------------------------------------------------------------------------*/
  FxaaFloat lumaNS = lumaN + lumaS;
  FxaaFloat lumaWE = lumaW + lumaE;
  FxaaFloat subpixRcpRange = 1.0 / range;
  FxaaFloat subpixNSWE = lumaNS + lumaWE;
  FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;
  FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;
  /*--------------------------------------------------------------------------*/
  FxaaFloat lumaNESE = lumaNE + lumaSE;
  FxaaFloat lumaNWNE = lumaNW + lumaNE;
  FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
  FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
  /*--------------------------------------------------------------------------*/
  FxaaFloat lumaNWSW = lumaNW + lumaSW;
  FxaaFloat lumaSWSE = lumaSW + lumaSE;
  FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
  FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
  FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
  FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
  FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;
  FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;
  /*--------------------------------------------------------------------------*/
  FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;
  FxaaFloat lengthSign = fxaaQualityRcpFrame.x;
  FxaaBool horzSpan = edgeHorz >= edgeVert;
  FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
  /*--------------------------------------------------------------------------*/
  if (!horzSpan) lumaN = lumaW;
  if (!horzSpan) lumaS = lumaE;
  if (horzSpan) lengthSign = fxaaQualityRcpFrame.y;
  FxaaFloat subpixB = (subpixA * (1.0 / 12.0)) - lumaM;
  /*--------------------------------------------------------------------------*/
  FxaaFloat gradientN = lumaN - lumaM;
  FxaaFloat gradientS = lumaS - lumaM;
  FxaaFloat lumaNN = lumaN + lumaM;
  FxaaFloat lumaSS = lumaS + lumaM;
  FxaaBool pairN = abs(gradientN) >= abs(gradientS);
  FxaaFloat gradient = max(abs(gradientN), abs(gradientS));
  if (pairN) lengthSign = -lengthSign;
  FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
  /*--------------------------------------------------------------------------*/
  FxaaFloat2 posB;
  posB.x = posM.x;
  posB.y = posM.y;
  FxaaFloat2 offNP;
  offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
  offNP.y = (horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
  if (!horzSpan) posB.x += lengthSign * 0.5;
  if (horzSpan) posB.y += lengthSign * 0.5;
  /*--------------------------------------------------------------------------*/
  FxaaFloat2 posN;
  posN.x = posB.x - offNP.x * FXAA_QUALITYP0;
  posN.y = posB.y - offNP.y * FXAA_QUALITYP0;
  FxaaFloat2 posP;
  posP.x = posB.x + offNP.x * FXAA_QUALITYP0;
  posP.y = posB.y + offNP.y * FXAA_QUALITYP0;
  FxaaFloat subpixD = ((-2.0) * subpixC) + 3.0;
  FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));
  FxaaFloat subpixE = subpixC * subpixC;
  FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));
  /*--------------------------------------------------------------------------*/
  if (!pairN) lumaNN = lumaSS;
  FxaaFloat gradientScaled = gradient * 1.0 / 4.0;
  FxaaFloat lumaMM = lumaM - lumaNN * 0.5;
  FxaaFloat subpixF = subpixD * subpixE;
  FxaaBool lumaMLTZero = lumaMM < 0.0;
  /*--------------------------------------------------------------------------*/
  lumaEndN -= lumaNN * 0.5;
  lumaEndP -= lumaNN * 0.5;
  FxaaBool doneN = abs(lumaEndN) >= gradientScaled;
  FxaaBool doneP = abs(lumaEndP) >= gradientScaled;
  if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP1;
  if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP1;
  FxaaBool doneNP = (!doneN) || (!doneP);
  if (!doneP) posP.x += offNP.x * FXAA_QUALITYP1;
  if (!doneP) posP.y += offNP.y * FXAA_QUALITYP1;
  /*--------------------------------------------------------------------------*/
  if (doneNP) {
    if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
    if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
    if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
    if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
    doneN = abs(lumaEndN) >= gradientScaled;
    doneP = abs(lumaEndP) >= gradientScaled;
    if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP2;
    if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP2;
    doneNP = (!doneN) || (!doneP);
    if (!doneP) posP.x += offNP.x * FXAA_QUALITYP2;
    if (!doneP) posP.y += offNP.y * FXAA_QUALITYP2;
    /*--------------------------------------------------------------------------*/
    #if (FXAA_QUALITYPS > 3)
      if (doneNP) {
        if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
        if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
        if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
        if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
        doneN = abs(lumaEndN) >= gradientScaled;
        doneP = abs(lumaEndP) >= gradientScaled;
        if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP3;
        if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP3;
        doneNP = (!doneN) || (!doneP);
        if (!doneP) posP.x += offNP.x * FXAA_QUALITYP3;
        if (!doneP) posP.y += offNP.y * FXAA_QUALITYP3;
        /*--------------------------------------------------------------------------*/
        #if (FXAA_QUALITYPS > 4)
          if (doneNP) {
            if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
            if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
            if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
            if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
            doneN = abs(lumaEndN) >= gradientScaled;
            doneP = abs(lumaEndP) >= gradientScaled;
            if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP4;
            if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP4;
            doneNP = (!doneN) || (!doneP);
            if (!doneP) posP.x += offNP.x * FXAA_QUALITYP4;
            if (!doneP) posP.y += offNP.y * FXAA_QUALITYP4;
            /*--------------------------------------------------------------------------*/
            #if (FXAA_QUALITYPS > 5)
              if (doneNP) {
                if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                doneN = abs(lumaEndN) >= gradientScaled;
                doneP = abs(lumaEndP) >= gradientScaled;
                if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP5;
                if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP5;
                doneNP = (!doneN) || (!doneP);
                if (!doneP) posP.x += offNP.x * FXAA_QUALITYP5;
                if (!doneP) posP.y += offNP.y * FXAA_QUALITYP5;
                /*--------------------------------------------------------------------------*/
                #if (FXAA_QUALITYPS > 6)
                  if (doneNP) {
                    if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                    if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                    if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                    if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                    doneN = abs(lumaEndN) >= gradientScaled;
                    doneP = abs(lumaEndP) >= gradientScaled;
                    if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP6;
                    if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP6;
                    doneNP = (!doneN) || (!doneP);
                    if (!doneP) posP.x += offNP.x * FXAA_QUALITYP6;
                    if (!doneP) posP.y += offNP.y * FXAA_QUALITYP6;
                    /*--------------------------------------------------------------------------*/
                    #if (FXAA_QUALITYPS > 7)
                      if (doneNP) {
                        if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                        if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                        if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                        if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                        doneN = abs(lumaEndN) >= gradientScaled;
                        doneP = abs(lumaEndP) >= gradientScaled;
                        if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP7;
                        if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP7;
                        doneNP = (!doneN) || (!doneP);
                        if (!doneP) posP.x += offNP.x * FXAA_QUALITYP7;
                        if (!doneP) posP.y += offNP.y * FXAA_QUALITYP7;
                        /*--------------------------------------------------------------------------*/
                        #if (FXAA_QUALITYPS > 8)
                          if (doneNP) {
                            if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                            if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                            if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                            if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                            doneN = abs(lumaEndN) >= gradientScaled;
                            doneP = abs(lumaEndP) >= gradientScaled;
                            if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP8;
                            if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP8;
                            doneNP = (!doneN) || (!doneP);
                            if (!doneP) posP.x += offNP.x * FXAA_QUALITYP8;
                            if (!doneP) posP.y += offNP.y * FXAA_QUALITYP8;
                            /*--------------------------------------------------------------------------*/
                            #if (FXAA_QUALITYPS > 9)
                              if (doneNP) {
                                if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                doneN = abs(lumaEndN) >= gradientScaled;
                                doneP = abs(lumaEndP) >= gradientScaled;
                                if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP9;
                                if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP9;
                                doneNP = (!doneN) || (!doneP);
                                if (!doneP) posP.x += offNP.x * FXAA_QUALITYP9;
                                if (!doneP) posP.y += offNP.y * FXAA_QUALITYP9;
                                /*--------------------------------------------------------------------------*/
                                #if (FXAA_QUALITYPS > 10)
                                  if (doneNP) {
                                    if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                    if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                    if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                    if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                    doneN = abs(lumaEndN) >= gradientScaled;
                                    doneP = abs(lumaEndP) >= gradientScaled;
                                    if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP10;
                                    if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP10;
                                    doneNP = (!doneN) || (!doneP);
                                    if (!doneP) posP.x += offNP.x * FXAA_QUALITYP10;
                                    if (!doneP) posP.y += offNP.y * FXAA_QUALITYP10;
                                    /*--------------------------------------------------------------------------*/
                                    #if (FXAA_QUALITYPS > 11)
                                      if (doneNP) {
                                        if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                        if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                        if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                        if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                        doneN = abs(lumaEndN) >= gradientScaled;
                                        doneP = abs(lumaEndP) >= gradientScaled;
                                        if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP11;
                                        if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP11;
                                        doneNP = (!doneN) || (!doneP);
                                        if (!doneP) posP.x += offNP.x * FXAA_QUALITYP11;
                                        if (!doneP) posP.y += offNP.y * FXAA_QUALITYP11;
                                        /*--------------------------------------------------------------------------*/
                                        #if (FXAA_QUALITYPS > 12)
                                          if (doneNP) {
                                            if (!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                                            if (!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                                            if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                                            if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                                            doneN = abs(lumaEndN) >= gradientScaled;
                                            doneP = abs(lumaEndP) >= gradientScaled;
                                            if (!doneN) posN.x -= offNP.x * FXAA_QUALITYP12;
                                            if (!doneN) posN.y -= offNP.y * FXAA_QUALITYP12;
                                            doneNP = (!doneN) || (!doneP);
                                            if (!doneP) posP.x += offNP.x * FXAA_QUALITYP12;
                                            if (!doneP) posP.y += offNP.y * FXAA_QUALITYP12;
                                            /*--------------------------------------------------------------------------*/
                                          }
                                        #endif
                                        /*--------------------------------------------------------------------------*/
                                      }
                                    #endif
                                    /*--------------------------------------------------------------------------*/
                                  }
                                #endif
                                /*--------------------------------------------------------------------------*/
                              }
                            #endif
                            /*--------------------------------------------------------------------------*/
                          }
                        #endif
                        /*--------------------------------------------------------------------------*/
                      }
                    #endif
                    /*--------------------------------------------------------------------------*/
                  }
                #endif
                /*--------------------------------------------------------------------------*/
              }
            #endif
            /*--------------------------------------------------------------------------*/
          }
        #endif
        /*--------------------------------------------------------------------------*/
      }
    #endif
    /*--------------------------------------------------------------------------*/
  }
  /*--------------------------------------------------------------------------*/
  FxaaFloat dstN = posM.x - posN.x;
  FxaaFloat dstP = posP.x - posM.x;
  if (!horzSpan) dstN = posM.y - posN.y;
  if (!horzSpan) dstP = posP.y - posM.y;
  /*--------------------------------------------------------------------------*/
  FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
  FxaaFloat spanLength = (dstP + dstN);
  FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
  FxaaFloat spanLengthRcp = 1.0 / spanLength;
  /*--------------------------------------------------------------------------*/
  FxaaBool directionN = dstN < dstP;
  FxaaFloat dst = min(dstN, dstP);
  FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;
  FxaaFloat subpixG = subpixF * subpixF;
  FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
  FxaaFloat subpixH = subpixG * fxaaQualitySubpix;
  /*--------------------------------------------------------------------------*/
  FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
  FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
  if (!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
  if (horzSpan) posM.y += pixelOffsetSubpix * lengthSign;
  #if (FXAA_DISCARD == 1)
    return FxaaTexTop(tex, posM);
  #else
  return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);
  #endif
}
/*==========================================================================*/
#endif


void main(){
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  vec2 screenInfo = vec2(textureSize(u_baseColorTexture, 0));
  rt0 = FxaaPixelShader(
      v_texcoord_0,
      vec4(0.0),
      u_baseColorTexture,
      u_baseColorTexture,
      u_baseColorTexture,
      1.0 / screenInfo,
      vec4(0.0),
      vec4(0.0),
      vec4(0.0),
      0.75,
      0.166,
      0.0833,
      0.0,
      0.0,
      0.0,
      vec4(0.0)
  );
  rt0.a = 1.0;

/* shaderity: @{renderTargetEnd} */


}
`, shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.vert
var GammaCorrectionShader_default;
var init_GammaCorrectionShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.vert"() {
    GammaCorrectionShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.frag
var GammaCorrectionShader_default2;
var init_GammaCorrectionShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.frag"() {
    GammaCorrectionShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord_0;\n\nuniform sampler2D u_baseColorTexture; // initialValue=(0,white)\nuniform bool u_enableLinearToSrgb; // initialValue=true\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nvec3 linearToSrgb(vec3 linearColor) {\n  return pow(linearColor, vec3(1.0/2.2));\n}\n\nvec3 srgbToLinear(vec3 srgbColor) {\n  return pow(srgbColor, vec3(2.2));\n}\n\n\nvoid main ()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\nvec4 baseColor = texture(u_baseColorTexture, v_texcoord_0);\n\nif (get_enableLinearToSrgb(materialSID, 0)) {\n  baseColor.rgb = linearToSrgb(baseColor.rgb);\n}\n\nrt0 = baseColor;\n\n/* shaderity: @{renderTargetEnd} */\n\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.vert
var GammaCorrectionShader_default3;
var init_GammaCorrectionShader3 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.vert"() {
    GammaCorrectionShader_default3 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n  @builtin(vertex_index) vertexIdx : u32,\n) -> VertexOutput {\n  var output : VertexOutput;\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\nlet x = f32((vertexIdx & 1u) << 2u);\nlet y = f32((vertexIdx & 2u) << 1u);\noutput.texcoord_0.x = x * 0.5;\noutput.texcoord_0.y = y * 0.5;\noutput.texcoord_0.y = 1.0 - output.texcoord_0.y;\noutput.position = vec4f(x - 1.0, y - 1.0, 0, 1);\n\n\n  return output;\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.frag
var GammaCorrectionShader_default4;
var init_GammaCorrectionShader4 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/GammaCorrectionShader/GammaCorrectionShader.frag"() {
    GammaCorrectionShader_default4 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(0) var baseColorSampler: sampler;\n\n// #param enableLinearToSrgb: bool; // initialValue=true\n\nfn linearToSrgb(linearColor: vec3f) -> vec3f {\n  return pow(linearColor, vec3f(1.0/2.2));\n}\n\nfn srgbToLinear(srgbColor: vec3f) -> vec3f {\n  return pow(srgbColor, vec3f(2.2));\n}\n\n\n@fragment\nfn main (\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var baseColor = textureSampleLevel(baseColorTexture, baseColorSampler, input.texcoord_0, 0.0);\n\n  if (get_enableLinearToSrgb(materialSID, 0)) {\n    baseColor = vec4f(linearToSrgb(baseColor.rgb), baseColor.a);\n  }\n\n  return baseColor;\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ToneMappingShader/ToneMappingShader.vert
var ToneMappingShader_default;
var init_ToneMappingShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ToneMappingShader/ToneMappingShader.vert"() {
    ToneMappingShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ToneMappingShader/ToneMappingShader.frag
var ToneMappingShader_default2;
var init_ToneMappingShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ToneMappingShader/ToneMappingShader.frag"() {
    ToneMappingShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord_0;\n\nuniform sampler2D u_baseColorTexture; // initialValue=(0,white)\nuniform bool u_enableLinearToSrgb; // initialValue=true\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nvec3 linearToSrgb(vec3 linearColor) {\n  return pow(linearColor, vec3(1.0/2.2));\n}\n\nvec3 srgbToLinear(vec3 srgbColor) {\n  return pow(srgbColor, vec3(2.2));\n}\n\n\n#ifdef RN_USE_KHRONOS_PBR_NEUTRAL\n// Input color is non-negative and resides in the Linear Rec. 709 color space.\n// Output color is also Linear Rec. 709, but in the [0, 1] range.\n// See: https://github.com/KhronosGroup/ToneMapping/tree/main/PBR_Neutral\nvec3 PBRNeutralToneMapping( vec3 color ) {\n  const float startCompression = 0.8 - 0.04;\n  const float desaturation = 0.15;\n\n  float x = min(color.r, min(color.g, color.b));\n  float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n  color -= offset;\n\n  float peak = max(color.r, max(color.g, color.b));\n  if (peak < startCompression) return color;\n\n  const float d = 1. - startCompression;\n  float newPeak = 1. - d * d / (peak + d - startCompression);\n  color *= newPeak / peak;\n\n  float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n  return mix(color, newPeak * vec3(1, 1, 1), g);\n}\n#endif\n\n#ifdef RN_USE_REINHARD\nvec3 ReinhardToneMapping( vec3 color ) {\n  return color / (vec3(1.0) + color);\n}\n#endif\n\n#ifdef RN_USE_ACES_NARKOWICZ\n// ACES tone map (faster approximation)\n// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACES_Narkowicz_ToneMapping(vec3 color)\n{\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return clamp((color * (A * color + B)) / (color * (C * color + D) + E), 0.0, 1.0);\n}\n#endif\n\n#if defined(RN_USE_ACES_HILL) || defined(RN_USE_ACES_HILL_EXPOSURE_BOOST)\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3\n(\n  0.59719, 0.07600, 0.02840,\n  0.35458, 0.90834, 0.13383,\n  0.04823, 0.01566, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3\n(\n  1.60475, -0.10208, -0.00327,\n  -0.53108,  1.10813, -0.07276,\n  -0.07367, -0.00605,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n  vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n  vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n  return a / b;\n}\n\nvec3 ACES_Hill_ToneMapping(vec3 color)\n{\n  color = ACESInputMat * color;\n\n  // Apply RRT and ODT\n  color = RRTAndODTFit(color);\n\n  color = ACESOutputMat * color;\n\n  // Clamp to [0, 1]\n  color = clamp(color, 0.0, 1.0);\n\n  return color;\n}\n#endif\n\n#ifdef RN_USE_GT_TONEMAP\nfloat W_f(float x, float e0, float e1) {\n  if (x <= e0)\n    return 0.;\n  if (x >= e1)\n    return 1.;\n  float a = (x - e0) / (e1 - e0);\n  return a * a * (3. - 2. * a);\n}\nfloat H_f(float x, float e0, float e1) {\n  if (x <= e0)\n    return 0.;\n  if (x >= e1)\n    return 1.;\n  return (x - e0) / (e1 - e0);\n}\n\nconst float e = 2.71828;\n\nfloat GT_ToneMaping(float x) {\n  float P = 1.; // peak luminance\n  float a = 1.; // contrast parameter\n  float m = 0.22; // beginning of the linear part\n  float l = 0.4; // length of the linear part\n  float c = 1.33; // parameter of black color\n  float b = 0.; // parameter of black color\n  float l0 = (P - m) * l / a;\n  float T_x = m * pow(x / m, c) + b;\n  float L_x = m + a * (x - m);\n  float S0 = m + l0;\n  float S1 = m + a * l0;\n  float C2 = a * P / (P - S1);\n  float S_x = P - (P - S1) * pow(e, -(C2 * (x - S0) / P));\n  float w0_x = 1. - W_f(x, 0., m);\n  float w2_x = H_f(x, m + l0, m + l0);\n  float w1_x = 1. - w0_x - w2_x;\n  float f_x = T_x * w0_x + L_x * w1_x + S_x * w2_x;\n  return f_x;\n}\n#endif\n\nvoid main ()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\nvec4 baseColor = texture(u_baseColorTexture, v_texcoord_0);\n\n// Apply Tone Mapping\n#ifdef RN_USE_KHRONOS_PBR_NEUTRAL\nbaseColor.rgb = PBRNeutralToneMapping(baseColor.rgb);\n#endif\n\n#ifdef RN_USE_REINHARD\nbaseColor.rgb = ReinhardToneMapping(baseColor.rgb);\n#endif\n\n#ifdef RN_USE_ACES_NARKOWICZ\nbaseColor.rgb = ACES_Narkowicz_ToneMapping(baseColor.rgb);\n#endif\n\n#ifdef RN_USE_ACES_HILL\nbaseColor.rgb = ACES_Hill_ToneMapping(baseColor.rgb);\n#endif\n\n#ifdef RN_USE_ACES_HILL_EXPOSURE_BOOST\nbaseColor.rgb /= 0.6;\nbaseColor.rgb = ACES_Hill_ToneMapping(baseColor.rgb);\n#endif\n\n#ifdef RN_USE_GT_TONEMAP\nbaseColor.r = GT_ToneMaping(baseColor.r);\nbaseColor.g = GT_ToneMaping(baseColor.g);\nbaseColor.b = GT_ToneMaping(baseColor.b);\n#endif\n\n\n// Convert linear color to sRGB color space.\nif (get_enableLinearToSrgb(materialSID, 0)) {\n  baseColor.rgb = linearToSrgb(baseColor.rgb);\n}\n\nrt0 = baseColor;\n\n/* shaderity: @{renderTargetEnd} */\n\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/ToneMappingShader/ToneMappingShader.vert.wgsl
var ToneMappingShader_vert_default;
var init_ToneMappingShader_vert = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/ToneMappingShader/ToneMappingShader.vert.wgsl"() {
    ToneMappingShader_vert_default = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n  @builtin(vertex_index) vertexIdx : u32,\n) -> VertexOutput {\n  var output : VertexOutput;\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\nlet x = f32((vertexIdx & 1u) << 2u);\nlet y = f32((vertexIdx & 2u) << 1u);\noutput.texcoord_0.x = x * 0.5;\noutput.texcoord_0.y = y * 0.5;\noutput.texcoord_0.y = 1.0 - output.texcoord_0.y;\noutput.position = vec4f(x - 1.0, y - 1.0, 0, 1);\n\n\n  return output;\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/ToneMappingShader/ToneMappingShader.frag.wgsl
var ToneMappingShader_frag_default;
var init_ToneMappingShader_frag = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/ToneMappingShader/ToneMappingShader.frag.wgsl"() {
    ToneMappingShader_frag_default = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(0) var baseColorSampler: sampler;\n\n// #param enableLinearToSrgb: bool; // initialValue=true\n\nfn linearToSrgb(linearColor: vec3f) -> vec3f {\n  return pow(linearColor, vec3f(1.0/2.2));\n}\n\nfn srgbToLinear(srgbColor: vec3f) -> vec3f {\n  return pow(srgbColor, vec3f(2.2));\n}\n\n\n#ifdef RN_USE_KHRONOS_PBR_NEUTRAL\n// Input color is non-negative and resides in the Linear Rec. 709 color space.\n// Output color is also Linear Rec. 709, but in the [0, 1] range.\n// See: https://github.com/KhronosGroup/ToneMapping/tree/main/PBR_Neutral\nfn PBRNeutralToneMapping( inColor: vec3f ) -> vec3f {\n  let startCompression = 0.8 - 0.04;\n  let desaturation = 0.15;\n\n  let x = min(inColor.r, min(inColor.g, inColor.b));\n  let offset = select(0.04, x - 6.25 * x * x, x < 0.08);\n  var color = inColor - offset;\n\n  let peak = max(color.r, max(color.g, color.b));\n  if (peak < startCompression) {\n    return color;\n  }\n\n  let d = 1.0 - startCompression;\n  let newPeak = 1.0 - d * d / (peak + d - startCompression);\n  color *= newPeak / peak;\n\n  let g = 1.0 - 1.0 / (desaturation * (peak - newPeak) + 1.0);\n  return mix(color, newPeak * vec3f(1.0, 1.0, 1.0), g);\n}\n#endif\n\n#ifdef RN_USE_REINHARD\nfn ReinhardToneMapping(color: vec3<f32> ) -> vec3<f32> {\n  return color / (vec3<f32>(1.0) + color);\n}\n#endif\n\n#ifdef RN_USE_ACES_NARKOWICZ\n// ACES tone map (faster approximation)\n// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nfn ACES_Narkowicz_ToneMapping(color: vec3<f32>) -> vec3<f32>\n{\n    const A = 2.51;\n    const B = 0.03;\n    const C = 2.43;\n    const D = 0.59;\n    const E = 0.14;\n    return clamp((color * (A * color + B)) / (color * (C * color + D) + E), vec3<f32>(0.0), vec3<f32>(1.0));\n}\n#endif\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst ACESInputMat = mat3x3<f32>\n(\n  0.59719, 0.07600, 0.02840,\n  0.35458, 0.90834, 0.13383,\n  0.04823, 0.01566, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst ACESOutputMat = mat3x3<f32>\n(\n  1.60475, -0.10208, -0.00327,\n  -0.53108,  1.10813, -0.07276,\n  -0.07367, -0.00605,  1.07602\n);\n\nfn RRTAndODTFit(v: vec3<f32>) -> vec3<f32>\n{\n  let a = v * (v + 0.0245786f) - 0.000090537f;\n  let b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n  return a / b;\n}\n\nfn ACES_Hill_ToneMapping(inColor: vec3<f32>) -> vec3<f32>\n{\n  var color = ACESInputMat * inColor;\n\n  // Apply RRT and ODT\n  color = RRTAndODTFit(color);\n\n  color = ACESOutputMat * color;\n\n  // Clamp to [0, 1]\n  color = saturate(color);\n\n  return color;\n}\n\n#ifdef RN_USE_GT_TONEMAP\n  fn W_f(x: f32, e0: f32, e1: f32) -> f32 {\n    if (x <= e0) { return 0.; }\n    if (x >= e1) { return 1.; }\n    let a = (x - e0) / (e1 - e0);\n    return a * a * (3. - 2. * a);\n  }\n  fn H_f(x: f32, e0: f32, e1: f32) -> f32 {\n    if (x <= e0) { return 0.; }\n    if (x >= e1) { return 1.; }\n    return (x - e0) / (e1 - e0);\n  }\n\n  const e = 2.71828;\n\n  fn GT_ToneMaping(x: f32) -> f32 {\n    let P = 1.; // peak luminance\n    let a = 1.; // contrast parameter\n    let m = 0.22; // beginning of the linear part\n    let l = 0.4; // length of the linear part\n    let c = 1.33; // parameter of black color\n    let b = 0.; // parameter of black color\n    let l0 = (P - m) * l / a;\n    let T_x = m * pow(x / m, c) + b;\n    let L_x = m + a * (x - m);\n    let S0 = m + l0;\n    let S1 = m + a * l0;\n    let C2 = a * P / (P - S1);\n    let S_x = P - (P - S1) * pow(e, -(C2 * (x - S0) / P));\n    let w0_x = 1. - W_f(x, 0., m);\n    let w2_x = H_f(x, m + l0, m + l0);\n    let w1_x = 1. - w0_x - w2_x;\n    let f_x = T_x * w0_x + L_x * w1_x + S_x * w2_x;\n    return f_x;\n  }\n#endif\n\n@fragment\nfn main (\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var baseColor = textureSample(baseColorTexture, baseColorSampler, input.texcoord_0);\n\n#ifdef RN_USE_KHRONOS_PBR_NEUTRAL\n  baseColor = vec4f(PBRNeutralToneMapping(baseColor.rgb), baseColor.a);\n#endif\n\n#ifdef RN_USE_REINHARD\n  baseColor = vec4f(ReinhardToneMapping(baseColor.rgb), baseColor.a);\n#endif\n\n#ifdef RN_USE_ACES_NARKOWICZ\n  baseColor = vec4f(ACES_Narkowicz_ToneMapping(baseColor.rgb), baseColor.a);\n#endif\n\n#ifdef RN_USE_ACES_HILL\n  baseColor = vec4f(ACES_Hill_ToneMapping(baseColor.rgb), baseColor.a);\n#endif\n\n#ifdef RN_USE_ACES_HILL_EXPOSURE_BOOST\n  baseColor /= 0.6;\n  baseColor = vec4f(ACES_Hill_ToneMapping(baseColor.rgb), baseColor.a);\n#endif\n\n\n#ifdef RN_USE_GT_TONEMAP\n  baseColor.r = GT_ToneMaping(baseColor.r);\n  baseColor.g = GT_ToneMaping(baseColor.g);\n  baseColor.b = GT_ToneMaping(baseColor.b);\n#endif\n\n  if (get_enableLinearToSrgb(materialSID, 0)) {\n    baseColor = vec4f(linearToSrgb(baseColor.rgb), baseColor.a);\n  }\n\n  return baseColor;\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/SummedAreaTableShader/SummedAreaTableShader.vert
var SummedAreaTableShader_default;
var init_SummedAreaTableShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/SummedAreaTableShader/SummedAreaTableShader.vert"() {
    SummedAreaTableShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\nmat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\nmat4 viewMatrix = get_viewMatrix(cameraSID, 0);\nmat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\ngl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4(a_position, 1.0);\n\n\nv_texcoord_0 = a_texcoord_0;\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/SummedAreaTableShader/SummedAreaTableShader.frag
var SummedAreaTableShader_default2;
var init_SummedAreaTableShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/SummedAreaTableShader/SummedAreaTableShader.frag"() {
    SummedAreaTableShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord_0;\n\nuniform sampler2DRect u_baseColorTexture; // initialValue=(0,white)\nuniform float u_count; // initialValue=0.0\nuniform float u_direction; // initialValue=0.0\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nvoid main ()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\nfloat i = get_count(materialSID, 0);\nfloat dir = get_direction(materialSID, 0);\n\nrt0 = texture(u_baseColorTexture, gl_FragCoord.xy);\n\nif (dir > 0.0) {\n  // horizontal\n  rt0 += texture(u_baseColorTexture, vec2(gl_FragCoord.x + pow(2.0, i), gl_FragCoord.y));\n} else {\n  // virtical\n  rt0 += texture(u_baseColorTexture, vec2(gl_FragCoord.x, gl_FragCoord.y + pow(2.0, i)));\n}\n\n/* shaderity: @{renderTargetEnd} */\n\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/FlatSingleShader/FlatSingleShader.vert
var FlatSingleShader_default;
var init_FlatSingleShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/FlatSingleShader/FlatSingleShader.vert"() {
    FlatSingleShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout vec3 v_baryCentricCoord;\n\nuniform float u_pointSize; // initialValue=30\nuniform vec3 u_pointDistanceAttenuation; // initialValue=(0,0.1,0.01)\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  bool isBillboard = get_isBillboard(a_instanceInfo.x);\n\n  // Skeletal\n  processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    isBillboard,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n\n  v_color = a_color;\n  v_normal_inWorld = normalMatrix * a_normal;\n  v_texcoord_0 = a_texcoord_0;\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n\n  bool visibility = get_isVisible(a_instanceInfo.x);\n  if (!visibility)\n  {\n    gl_Position = vec4(0.0);\n  }\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/FlatSingleShader/FlatSingleShader.frag
var FlatSingleShader_default2;
var init_FlatSingleShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/FlatSingleShader/FlatSingleShader.frag"() {
    FlatSingleShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\nin vec2 v_texcoord_0;\nin vec3 v_baryCentricCoord;\n\nuniform int u_shadingModel; // initialValue=0\nuniform float u_alphaCutoff; // initialValue=0.01\nuniform vec4 u_diffuseColorFactor; // initialValue=(1,1,1,1)\nuniform sampler2D u_diffuseColorTexture; // initialValue=(0,white)\nuniform sampler2D u_normalTexture; // initialValue=(1,blue)\nuniform vec4 u_diffuseColorTextureTransform; // initialValue=(1,1,0,0)\nuniform float u_diffuseColorTextureRotation; // initialValue=0\n\n/* shaderity: @{renderTargetBegin} */\n\n\n\nvec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {\n  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  mat3 rotationMat = mat3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  mat3 matrix = translationMat * rotationMat * scaleMat;\n  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n\n/* shaderity: @{getters} */\n\nstruct Light {\n  int type; // 0 = directional, 1 = point, 2 = spot\n  vec3 position;\n  vec3 intensity;\n  vec3 attenuatedIntensity;\n  vec3 directionOfLightObject;\n  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)\n  vec3 pointToLight; // not normalized\n  float spotAngleScale;\n  float spotAngleOffset;\n  float effectiveRange;\n};\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property\nfloat getRangeAttenuation(Light light)\n{\n  float distance = length(light.pointToLight);\n  // means no range limit\n  if (light.effectiveRange <= 0.0)\n  {\n    return 1.0 / pow(distance, 2.0);\n  }\n  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles\nfloat getSpotAttenuation(Light light)\n{\n\n  float cd = dot(light.directionOfLightObject, light.direction);\n  float angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);\n  return angularAttenuation;\n}\n\nvoid getLightAttenuated(Light light) {\n  light.attenuatedIntensity = light.intensity;\n  // if (light.type == 0) { // Directional Light\n    // Directional Light don't attenuate geometically\n  // }\n\n  // Point Light\n  if (light.type == 1)\n  {\n    light.attenuatedIntensity *= getRangeAttenuation(light);\n  }\n  // Spot light\n  if (light.type == 2)\n  {\n    light.attenuatedIntensity *= getSpotAttenuation(light);\n  }\n}\n\nLight getLight(int lightIdx, vec3 v_position_inWorld) {\n  vec3 lightPosition = get_lightPosition(0.0, lightIdx);\n  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);\n  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);\n  vec4 lightProperty = get_lightProperty(0.0, lightIdx);\n  Light light;\n  light.directionOfLightObject = direction_and_w_of_LightObject;\n  float lightType = lightProperty.x;\n  light.effectiveRange = lightProperty.y;\n  light.spotAngleScale = lightProperty.z;\n  light.spotAngleOffset = lightProperty.w;\n\n  light.intensity = lightIntensity;\n  light.position = lightPosition;\n  if (lightType < -0.5) { // disabled light\n    light.intensity = vec3(0.0);\n    light.type = -1;\n  } else if (0.75 < lightType) { // is pointlight or spotlight\n    light.pointToLight = lightPosition - v_position_inWorld;\n    light.direction = normalize(light.pointToLight);\n    light.type = 1;\n  } else { // is Directional Light\n    light.type = 0;\n    light.direction = normalize(light.directionOfLightObject * -1.0);\n  }\n\n  if (lightType > 1.75) { // is spotlight\n    light.type = 2;\n  }\n\n  const float M_PI = 3.141592653589793;\n  light.intensity *= M_PI; // Punctual Light\n\n  // Attenuation\n  light.attenuatedIntensity = light.intensity;\n  getLightAttenuated(light);\n\n  return light;\n}\n\n\nvoid main ()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n#ifdef RN_IS_ALPHA_MODE_MASK\n  float alphaCutoff = get_alphaCutoff(materialSID, 0);\n  if (alpha < alphaCutoff) {\n    discard;\n  }\n#endif\n\n\n  // Normal\n  vec3 normal_inWorld = normalize(v_normal_inWorld);\n\n  vec4 diffuseColorFactor = get_diffuseColorFactor(materialSID, 0);\n\n\n  // diffuseColor (Considered to be premultiplied alpha)\n  vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n  float alpha = 1.0;\n  if (v_color != diffuseColor && diffuseColorFactor.rgb != diffuseColor) {\n    diffuseColor = v_color * diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (v_color == diffuseColor) {\n    diffuseColor = diffuseColorFactor.rgb;\n    alpha = diffuseColorFactor.a;\n  } else if (diffuseColorFactor.rgb == diffuseColor) {\n    diffuseColor = v_color;\n  } else {\n    diffuseColor = vec3(1.0, 1.0, 1.0);\n  }\n\n  // diffuseColorTexture (Considered to be premultiplied alpha)\n  vec4 diffuseColorTextureTransform = get_diffuseColorTextureTransform(materialSID, 0);\n  float diffuseColorTextureRotation = get_diffuseColorTextureRotation(materialSID, 0);\n  vec2 diffuseColorTexUv = uvTransform(diffuseColorTextureTransform.xy, diffuseColorTextureTransform.zw, diffuseColorTextureRotation, v_texcoord_0);\n  vec4 textureColor = texture(u_diffuseColorTexture, diffuseColorTexUv);\n  diffuseColor *= textureColor.rgb;\n  alpha *= textureColor.a;\n\n\n#ifdef RN_IS_ALPHA_MODE_BLEND\n#else\n  alpha = 1.0;\n#endif\n\n  rt0 = vec4(diffuseColor * alpha, alpha);\n\n/* shaderity: @{renderTargetEnd} */\n\n\n}\n\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/FlatSingleShader/FlatSingleShader.vert
var FlatSingleShader_default3;
var init_FlatSingleShader3 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/FlatSingleShader/FlatSingleShader.vert"() {
    FlatSingleShader_default3 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n#ifdef RN_USE_INSTANCE\n  @location(8) instance_ids: vec4<f32>,\n#endif\n\n\n#ifdef RN_USE_POSITION_FLOAT\n  @location(0) position: vec3<f32>,\n#endif\n#ifdef RN_USE_POSITION_INT\n  @location(0) position: vec3<i32>,\n#endif\n#ifdef RN_USE_POSITION_UINT\n  @location(0) position: vec3<u32>,\n#endif\n\n#ifdef RN_USE_NORMAL\n  @location(1) normal: vec3<f32>,\n#endif\n#ifdef RN_USE_TANGENT\n  @location(2) tangent: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_0\n  @location(3) texcoord_0: vec2<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  @location(4) texcoord_1: vec2<f32>,\n#endif\n\n#ifdef RN_USE_COLOR_0_FLOAT\n  @location(5) color_0: vec4<f32>,\n#endif\n#ifdef RN_USE_COLOR_0_INT\n  @location(5) color_0: vec4<i32>,\n#endif\n#ifdef RN_USE_COLOR_0_UINT\n  @location(5) color_0: vec4<u32>,\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  @location(6) joints_0: vec4<u32>,\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  @location(7) weights_0: vec4<f32>,\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  @location(10) baryCentricCoord: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  @location(11) texcoord_2: vec2<f32>,\n#endif\n  @builtin(vertex_index) vertexIdx : u32,\n\n\n) -> VertexOutput {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var output : VertexOutput;\n\n  let worldMatrix = get_worldMatrix(u32(instance_ids.x));\n  let viewMatrix = get_viewMatrix(cameraSID, 0u);\n  let projectionMatrix = get_projectionMatrix(cameraSID, 0u);\n\n  output.position = projectionMatrix * viewMatrix * worldMatrix * vec4<f32>(position, 1.0);\n\n#ifdef RN_USE_NORMAL\n  output.normal_inWorld = normalize((worldMatrix * vec4<f32>(normal, 0.0)).xyz);\n#endif\n\n#ifdef RN_USE_TEXCOORD_0\n  output.texcoord_0 = texcoord_0;\n#endif\n\n  // output.Position = vec4<f32>(position, 1.0);\n\n  return output;\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/FlatSingleShader/FlatSingleShader.frag
var FlatSingleShader_default4;
var init_FlatSingleShader4 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/FlatSingleShader/FlatSingleShader.frag"() {
    FlatSingleShader_default4 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n// #param diffuseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)\n\n@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=blue\n@group(2) @binding(0) var baseColorSampler: sampler;\n\n@fragment\nfn main(\n  input: VertexOutput\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  var Normal = input.normal_inWorld * 0.5 + 0.5;\n  // return vec4<f32>(Normal.x, Normal.y, Normal.z, 1);\n\n#ifdef RN_USE_TEXCOORD_0\n  var baseColor = textureSample(baseColorTexture, baseColorSampler, input.texcoord_0);\n  return baseColor;\n#else\n  return vec4<f32>(1, 0, 0, 1);\n#endif\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/DepthMomentEncodeShader/DepthMomentEncodeShader.vert
var DepthMomentEncodeShader_default;
var init_DepthMomentEncodeShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/DepthMomentEncodeShader/DepthMomentEncodeShader.vert"() {
    DepthMomentEncodeShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec2 a_texcoord_1;\nin vec2 a_texcoord_2;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\n\nuniform float u_pointSize; // initialValue=30, soloDatum=true\nuniform vec3 u_pointDistanceAttenuation; // initialValue=(0.0, 0.1, 0.01), soloDatum=true\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  bool isBillboard = get_isBillboard(a_instanceInfo.x);\n\n  v_color = a_color;\n\n  bool isSkinning = false;\n\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    isBillboard,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n  bool visibility = get_isVisible(a_instanceInfo.x);\n  if (!visibility)\n  {\n    gl_Position = vec4(0.0);\n  }\n\n// #ifdef RN_IS_POINTSPRITE\n\nvec4 position_inWorld = worldMatrix * vec4(a_position, 1.0);\nvec3 viewPosition = get_viewPosition(cameraSID, 0);\nfloat distanceFromCamera = length(position_inWorld.xyz - viewPosition);\nvec3 pointDistanceAttenuation = get_pointDistanceAttenuation(materialSID, 0);\nfloat distanceAttenuationFactor = sqrt(1.0/(pointDistanceAttenuation.x + pointDistanceAttenuation.y * distanceFromCamera + pointDistanceAttenuation.z * distanceFromCamera * distanceFromCamera));\nfloat maxPointSize = get_pointSize(materialSID, 0);\ngl_PointSize = clamp(distanceAttenuationFactor * maxPointSize, 0.0, maxPointSize);\n\n// #endif\n\n\n}\n\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/DepthMomentEncodeShader/DepthMomentEncodeShader.frag
var DepthMomentEncodeShader_default2;
var init_DepthMomentEncodeShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/DepthMomentEncodeShader/DepthMomentEncodeShader.frag"() {
    DepthMomentEncodeShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\n\nvoid main (){\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  float depth = gl_FragCoord.z;\n  float dx = dFdx(depth);\n  float dy = dFdy(depth);\n\n  rt0.x = depth; // M1\n  rt0.y = sq(depth) + 0.25 * (sq(dx) + sq(dy)); // M2\n  rt0.z = 0.0;\n  rt0.w = 1.0;\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ParaboloidDepthMomentEncodeShader/ParaboloidDepthMomentEncodeShader.vert.glsl
var ParaboloidDepthMomentEncodeShader_vert_default;
var init_ParaboloidDepthMomentEncodeShader_vert = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ParaboloidDepthMomentEncodeShader/ParaboloidDepthMomentEncodeShader.vert.glsl"() {
    ParaboloidDepthMomentEncodeShader_vert_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec2 a_texcoord_1;\nin vec2 a_texcoord_2;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\n\nuniform bool u_frontHemisphere; // initialValue=true\nuniform int u_lightIndex; // initialValue=0\nuniform float u_farPlane; // initialValue=1000.0\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nvoid main()\n{\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  bool visibility = get_isVisible(a_instanceInfo.x);\n  if (!visibility)\n  {\n    gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\n    return;\n  }\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  bool isBillboard = get_isBillboard(a_instanceInfo.x);\n\n  v_color = a_color;\n\n  bool isSkinning = false;\n\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    isBillboard,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  int lightIndex = get_lightIndex(materialSID, 0);\n  vec3 lightPosition = get_lightPosition(0.0, lightIndex);\n  vec3 L = v_position_inWorld.xyz - lightPosition;\n  float dist = length(L);\n  L = normalize(L);\n\n  bool frontHemisphere = get_frontHemisphere(materialSID, 0);\n  float signHemisphere = frontHemisphere ? 1.0 : -1.0;\n  float denom = 1.0 + signHemisphere * L.z;\n\n  vec2 uv = L.xy / denom;\n\n  if (abs(denom) < 1e-6) {\n    gl_Position = vec4(0.0, 0.0, -1000000.0, 1.0);\n    return;\n  }\n  // if ((u_frontHemisphere && L.z < 0.0) ||\n  //      (!u_frontHemisphere && L.z > 0.0))\n  // {\n  //   gl_Position = vec4(0.0, 0.0, -1000000.0, 1.0);\n  //   return;\n  // }\n\n  float farPlane = get_farPlane(materialSID, 0);\n  gl_Position = vec4(uv, dist / farPlane, 1.0);\n  v_position_inWorld = vec4(uv, dist / farPlane, signHemisphere * L.z);\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ParaboloidDepthMomentEncodeShader/ParaboloidDepthMomentEncodeShader.frag.glsl
var ParaboloidDepthMomentEncodeShader_frag_default;
var init_ParaboloidDepthMomentEncodeShader_frag = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/ParaboloidDepthMomentEncodeShader/ParaboloidDepthMomentEncodeShader.frag.glsl"() {
    ParaboloidDepthMomentEncodeShader_frag_default = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec3 v_color;\nin vec3 v_normal_inWorld;\nin vec4 v_position_inWorld;\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nuniform bool u_frontHemisphere; // initialValue=true\n\nvoid main (){\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  float denom = v_position_inWorld.w;\n  if (denom < 0.0) {\n    discard;\n  }\n\n  float depth = v_position_inWorld.z;\n  float dx = dFdx(depth);\n  float dy = dFdy(depth);\n\n  bool frontHemisphere = get_frontHemisphere(materialSID, 0);\n  if (frontHemisphere) {\n    rt0.r = depth; // M1\n    rt0.g = sq(depth) + 0.25 * (sq(dx) + sq(dy)); // M2\n    rt0.b = 1.0;\n    rt0.a = 1.0;\n  } else {\n    rt0.r = 1.0;\n    rt0.g = 1.0;\n    rt0.b = depth; // M1\n    rt0.a = sq(depth) + 0.25 * (sq(dx) + sq(dy)); // M2\n  }\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// src/foundation/materials/core/ShaderHandler.ts
function _createProgramAsSingleOperationByUpdatedSources(material, primitive, materialNode, updatedShaderSources, onError) {
  const { attributeNames, attributeSemantics } = _getAttributeInfo(materialNode);
  const [shaderProgramUid, newOne] = ShaderHandler._createShaderProgramWithCache(material, primitive, updatedShaderSources.vertex, updatedShaderSources.pixel, attributeNames, attributeSemantics, onError);
  return [
    shaderProgramUid,
    newOne
  ];
}
function _getAttributeInfo(materialNode) {
  const reflection = ShaderityUtilityWebGL.getAttributeReflection(materialNode.vertexShaderityObject);
  const attributeNames = reflection.names;
  const attributeSemantics = reflection.semantics;
  return {
    attributeNames,
    attributeSemantics
  };
}
function _outputVertexAttributeBindingInfo(attributeNames, attributeSemantics) {
  let vertexAttributesBinding = "\n// Vertex Attributes Binding Info\n";
  for (let i2 = 0; i2 < attributeNames.length; i2++) {
    vertexAttributesBinding += `// ${attributeNames[i2]}: ${attributeSemantics[i2].str} 
`;
  }
  return vertexAttributesBinding;
}
function _createProgramAsSingleOperationWebGL(material, primitive, vertexPropertiesStr, pixelPropertiesStr, vertexShaderMethodDefinitions_uniform, isWebGL2) {
  const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
  const materialNode = material._materialContent;
  let definitions = materialNode.getDefinitions();
  const shaderDefines = material.getShaderDefines();
  for (const shaderDefine of shaderDefines) {
    definitions += `#define ${shaderDefine}
`;
  }
  const vertexAttributeDefines = defineAttributes(primitive);
  definitions += vertexAttributeDefines;
  let vertexShader = _setupGlobalShaderDefinitionWebGL(material.__materialTypeName, primitive);
  vertexShader += "#define RN_IS_VERTEX_SHADER\n";
  let pixelShader = _setupGlobalShaderDefinitionWebGL(material.__materialTypeName, primitive);
  pixelShader += "#define RN_IS_PIXEL_SHADER\n";
  if (material.isBlend()) {
    pixelShader += "#define RN_IS_ALPHA_MODE_BLEND\n";
  }
  if (material.isMask()) {
    pixelShader += "#define RN_IS_ALPHA_MODE_MASK\n";
  }
  const vertexShaderityObject = ShaderityUtilityWebGL.fillTemplate(materialNode.vertexShaderityObject, {
    getters: vertexPropertiesStr,
    definitions,
    dataUBODefinition: webglResourceRepository.getGlslDataUBODefinitionString(),
    dataUBOVec4Size: webglResourceRepository.getGlslDataUBOVec4SizeString(),
    matricesGetters: vertexShaderMethodDefinitions_uniform
  });
  const pixelShaderityObject = ShaderityUtilityWebGL.fillTemplate(materialNode.pixelShaderityObject, {
    renderTargetBegin: webglResourceRepository.getGlslRenderTargetBeginString(4),
    getters: pixelPropertiesStr,
    definitions,
    dataUBODefinition: webglResourceRepository.getGlslDataUBODefinitionString(),
    dataUBOVec4Size: webglResourceRepository.getGlslDataUBOVec4SizeString(),
    matricesGetters: vertexShaderMethodDefinitions_uniform,
    renderTargetEnd: webglResourceRepository.getGlslRenderTargetEndString(4)
  });
  vertexShader += vertexShaderityObject.code.replace(/#version\s+(100|300\s+es)/, "");
  pixelShader += pixelShaderityObject.code.replace(/#version\s+(100|300\s+es)/, "");
  const { attributeNames, attributeSemantics } = _getAttributeInfo(materialNode);
  const vertexAttributesBinding = _outputVertexAttributeBindingInfo(attributeNames, attributeSemantics);
  vertexShader += vertexAttributesBinding;
  const [shaderProgramUid, newOne] = ShaderHandler._createShaderProgramWithCache(material, primitive, vertexShader, pixelShader, attributeNames, attributeSemantics);
  return [
    shaderProgramUid,
    newOne
  ];
}
function _setupGlobalShaderDefinitionWebGL(materialTypeName, primitive) {
  let definitions = "";
  const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
  const glw = webglResourceRepository.currentWebGLContextWrapper;
  if (glw.isWebGL2) {
    definitions += "#version 300 es\n#define GLSL_ES3\n";
    if (Config.isUboEnabled) {
      definitions += "#define RN_IS_UBO_ENABLED\n";
    }
  }
  definitions += `#define RN_MATERIAL_TYPE_NAME ${materialTypeName}
`;
  if (ProcessApproach.isDataTextureApproach(SystemState.currentProcessApproach)) {
    definitions += "#define RN_IS_DATATEXTURE_MODE\n";
  } else {
    definitions += "#define RN_IS_UNIFORM_MODE\n";
  }
  const rnXRModule = ModuleManager.getInstance().getModule("xr");
  const webXRSystem = rnXRModule == null ? void 0 : rnXRModule.WebXRSystem.getInstance();
  if (Is.exist(webXRSystem) && webXRSystem.isWebXRMode && webglResourceRepository.isSupportMultiViewVRRendering()) {
    definitions += "#define WEBGL2_MULTI_VIEW\n";
  }
  if (glw.isWebGL2 || glw.webgl1ExtDRV) {
    definitions += "#define RN_IS_SUPPORTING_STANDARD_DERIVATIVES\n";
  }
  if (Config.boneDataType === BoneDataType.Mat43x1) {
    definitions += "#define RN_BONE_DATA_TYPE_Mat43x1\n";
  } else if (Config.boneDataType === BoneDataType.Vec4x2) {
    definitions += "#define RN_BONE_DATA_TYPE_VEC4X2\n";
  } else if (Config.boneDataType === BoneDataType.Vec4x2Old) {
    definitions += "#define RN_BONE_DATA_TYPE_VEC4X2_OLD\n";
  } else if (Config.boneDataType === BoneDataType.Vec4x1) {
    definitions += "#define RN_BONE_DATA_TYPE_VEC4X1\n";
  }
  return definitions;
}
function _createProgramAsSingleOperationWebGpu(material, primitive, vertexShaderMethodDefinitions, vertexPropertiesStr, pixelPropertiesStr) {
  const materialNode = material._materialContent;
  let definitions = `// Material Type: ${material.materialTypeName}
`;
  definitions += materialNode.getDefinitions();
  const shaderDefines = material.getShaderDefines();
  for (const shaderDefine of shaderDefines) {
    definitions += `#define ${shaderDefine}
`;
  }
  const vertexAttributeDefines = defineAttributes(primitive);
  definitions += vertexAttributeDefines;
  if (Config.boneDataType === BoneDataType.Mat43x1) {
    definitions += "#define RN_BONE_DATA_TYPE_Mat43x1\n";
  } else if (Config.boneDataType === BoneDataType.Vec4x2) {
    definitions += "#define RN_BONE_DATA_TYPE_VEC4X2\n";
  } else if (Config.boneDataType === BoneDataType.Vec4x2Old) {
    definitions += "#define RN_BONE_DATA_TYPE_VEC4X2_OLD\n";
  } else if (Config.boneDataType === BoneDataType.Vec4x1) {
    definitions += "#define RN_BONE_DATA_TYPE_VEC4X1\n";
  }
  const vertexShaderityObject = ShaderityUtilityWebGL.fillTemplate(materialNode.vertexShaderityObject, {
    getters: vertexPropertiesStr,
    definitions: "// RN_IS_VERTEX_SHADER\n#define RN_IS_VERTEX_SHADER\n" + definitions,
    matricesGetters: vertexShaderMethodDefinitions,
    maxMorphDataNumber: "" + Math.ceil(Config.maxVertexPrimitiveNumberInShader * Config.maxVertexMorphNumberInShader / 4)
  });
  let alphaMode = "";
  if (material.isBlend()) {
    alphaMode += "#define RN_IS_ALPHA_MODE_BLEND\n";
  }
  if (material.isMask()) {
    alphaMode += "#define RN_IS_ALPHA_MODE_MASK\n";
  }
  const pixelShaderityObject = ShaderityUtilityWebGL.fillTemplate(materialNode.pixelShaderityObject, {
    getters: pixelPropertiesStr,
    definitions: "// RN_IS_PIXEL_SHADER\n#define RN_IS_PIXEL_SHADER\n" + definitions + alphaMode,
    matricesGetters: vertexShaderMethodDefinitions,
    maxMorphDataNumber: "" + Math.ceil(Config.maxVertexPrimitiveNumberInShader * Config.maxVertexMorphNumberInShader / 4)
  });
  const preprocessedVertex = Shaderity3.processPragma(vertexShaderityObject);
  const preprocessedPixel = Shaderity3.processPragma(pixelShaderityObject);
  const [programUid, newOne] = ShaderHandler._createShaderProgramWithCache(material, primitive, preprocessedVertex.code, preprocessedPixel.code, [], []);
  return programUid;
}
function defineAttributes(primitive) {
  let vertexAttributeDefines = "";
  const attributeSemantics = primitive.attributeSemantics;
  for (const attributeSemantic of attributeSemantics) {
    if (attributeSemantic.indexOf("POSITION") !== -1) {
      vertexAttributeDefines += `#define RN_USE_POSITION
`;
      const accessor = primitive.getAttribute(attributeSemantic);
      if (accessor.componentType.isFloatingPoint()) {
        vertexAttributeDefines += `#define RN_USE_POSITION_FLOAT
`;
      } else if (accessor.componentType.isInteger()) {
        vertexAttributeDefines += `#define RN_USE_POSITION_INT
`;
      } else {
        vertexAttributeDefines += `#define RN_USE_POSITION_UINT
`;
      }
    }
    if (attributeSemantic.indexOf("NORMAL") !== -1) {
      vertexAttributeDefines += `#define RN_USE_NORMAL
`;
    }
    if (attributeSemantic.indexOf("TANGENT") !== -1) {
      vertexAttributeDefines += `#define RN_USE_TANGENT
`;
    }
    if (attributeSemantic.indexOf("TEXCOORD_0") !== -1) {
      vertexAttributeDefines += `#define RN_USE_TEXCOORD_0
`;
    }
    if (attributeSemantic.indexOf("TEXCOORD_1") !== -1) {
      vertexAttributeDefines += `#define RN_USE_TEXCOORD_1
`;
    }
    if (attributeSemantic.indexOf("COLOR_0") !== -1) {
      vertexAttributeDefines += `#define RN_USE_COLOR_0
`;
      const accessor = primitive.getAttribute(attributeSemantic);
      if (accessor.componentType.isFloatingPoint()) {
        vertexAttributeDefines += `#define RN_USE_COLOR_0_FLOAT
`;
      } else if (accessor.componentType.isInteger()) {
        vertexAttributeDefines += `#define RN_USE_COLOR_0_INT
`;
      } else {
        vertexAttributeDefines += `#define RN_USE_COLOR_0_UINT
`;
      }
    }
    if (attributeSemantic.indexOf("JOINTS_0") !== -1) {
      vertexAttributeDefines += `#define RN_USE_JOINTS_0
`;
    }
    if (attributeSemantic.indexOf("WEIGHTS_0") !== -1) {
      vertexAttributeDefines += `#define RN_USE_WEIGHTS_0
`;
    }
    if (attributeSemantic.indexOf("FACE_NORMAL") !== -1) {
      vertexAttributeDefines += `#define RN_USE_FACE_NORMAL
`;
    }
    if (attributeSemantic.indexOf("BARY_CENTRIC_COORD") !== -1) {
      vertexAttributeDefines += `#define RN_USE_BARY_CENTRIC_COORD
`;
    }
    if (attributeSemantic.indexOf("TEXCOORD_2") !== -1) {
      vertexAttributeDefines += `#define RN_USE_TEXCOORD_2
`;
    }
  }
  if (primitive.targets != null && primitive.targets.length > 0) {
    vertexAttributeDefines += "#define RN_IS_MORPHING\n";
  }
  vertexAttributeDefines += `#define RN_USE_INSTANCE
`;
  return vertexAttributeDefines;
}
var import_shaderity3, Shaderity3, _ShaderHandler, ShaderHandler;
var init_ShaderHandler = __esm({
  "src/foundation/materials/core/ShaderHandler.ts"() {
    "use strict";
    import_shaderity3 = __toESM(require_esm(), 1);
    init_Config();
    init_BoneDataType();
    init_ProcessApproach();
    init_CGAPIResourceRepository();
    init_SystemState();
    init_ShaderityUtilityWebGL();
    init_ModuleManager();
    init_Is();
    Shaderity3 = import_shaderity3.default.default || import_shaderity3.default;
    _ShaderHandler = class _ShaderHandler {
      /**
      * Create a shader program Or Get a shader program from cache
      * @param material
      * @param primitive
      * @param vertexShader
      * @param pixelShader
      * @param attributeNames
      * @param attributeSemantics
      * @param onError
      * @returns
      */
      static _createShaderProgramWithCache(material, primitive, vertexShader, pixelShader, attributeNames, attributeSemantics, onError) {
        const wholeShaderText = vertexShader + pixelShader;
        let shaderProgramUid = this.__shaderStringMap.get(wholeShaderText);
        if (shaderProgramUid) {
          return [
            shaderProgramUid,
            false
          ];
        }
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        shaderProgramUid = cgApiResourceRepository.createShaderProgram({
          material,
          primitive,
          vertexShaderStr: vertexShader,
          fragmentShaderStr: pixelShader,
          attributeNames,
          attributeSemantics,
          onError
        });
        this.__shaderStringMap.set(wholeShaderText, shaderProgramUid);
        return [
          shaderProgramUid,
          true
        ];
      }
    };
    __name(_ShaderHandler, "ShaderHandler");
    __publicField(_ShaderHandler, "__shaderStringMap", /* @__PURE__ */ new Map());
    ShaderHandler = _ShaderHandler;
    __name(_createProgramAsSingleOperationByUpdatedSources, "_createProgramAsSingleOperationByUpdatedSources");
    __name(_getAttributeInfo, "_getAttributeInfo");
    __name(_outputVertexAttributeBindingInfo, "_outputVertexAttributeBindingInfo");
    __name(_createProgramAsSingleOperationWebGL, "_createProgramAsSingleOperationWebGL");
    __name(_setupGlobalShaderDefinitionWebGL, "_setupGlobalShaderDefinitionWebGL");
    __name(_createProgramAsSingleOperationWebGpu, "_createProgramAsSingleOperationWebGpu");
    __name(defineAttributes, "defineAttributes");
  }
});

// src/foundation/materials/core/Material.ts
var _Material, Material;
var init_Material = __esm({
  "src/foundation/materials/core/Material.ts"() {
    "use strict";
    init_RnObject();
    init_AlphaMode();
    init_CompositionType();
    init_MathClassUtil();
    init_CGAPIResourceRepository();
    init_ShaderType();
    init_GlobalDataRepository();
    init_Blend();
    init_ShaderHandler();
    init_Logger();
    _Material = class _Material extends RnObject {
      constructor(materialTid, materialUid, materialSid, materialTypeName, materialNode) {
        super();
        // Internal Resources
        __publicField(this, "__materialTypeName");
        __publicField(this, "_materialContent");
        __publicField(this, "_allFieldVariables", /* @__PURE__ */ new Map());
        __publicField(this, "_autoFieldVariablesOnly", /* @__PURE__ */ new Map());
        __publicField(this, "_allFieldsInfo", /* @__PURE__ */ new Map());
        __publicField(this, "__belongPrimitives", /* @__PURE__ */ new Map());
        // Ids
        __publicField(this, "_shaderProgramUidMap", /* @__PURE__ */ new Map());
        __publicField(this, "__materialUid", -1);
        __publicField(this, "__materialTid");
        __publicField(this, "__materialSid", -1);
        // Common Rendering States
        __publicField(this, "__alphaMode", AlphaMode.Opaque);
        __publicField(this, "zWriteWhenBlend", false);
        __publicField(this, "colorWriteMask", [
          true,
          true,
          true,
          true
        ]);
        __publicField(this, "isTranslucent", false);
        __publicField(this, "cullFace", true);
        __publicField(this, "cullFrontFaceCCW", true);
        __publicField(this, "cullFaceBack", true);
        __publicField(this, "__alphaToCoverage", false);
        __publicField(this, "__blendEquationMode", Blend2.EquationFuncAdd);
        __publicField(this, "__blendEquationModeAlpha", Blend2.EquationFuncAdd);
        __publicField(this, "__blendFuncSrcFactor", Blend2.One);
        __publicField(this, "__blendFuncDstFactor", Blend2.OneMinusSrcAlpha);
        __publicField(this, "__blendFuncAlphaSrcFactor", Blend2.One);
        __publicField(this, "__blendFuncAlphaDstFactor", Blend2.OneMinusSrcAlpha);
        __publicField(this, "__stateVersion", 0);
        __publicField(this, "__fingerPrint", "");
        __publicField(this, "__shaderDefines", /* @__PURE__ */ new Set());
        this._materialContent = materialNode;
        this.__materialTid = materialTid;
        this.__materialUid = materialUid;
        this.__materialSid = materialSid;
        this.__materialTypeName = materialTypeName;
      }
      addShaderDefine(define) {
        this.__shaderDefines.add(define);
        this.makeShadersInvalidate();
      }
      removeShaderDefine(define) {
        this.__shaderDefines.delete(define);
        this.makeShadersInvalidate();
      }
      getShaderDefines() {
        return this.__shaderDefines;
      }
      calcFingerPrint() {
        let str = "";
        str += this.alphaMode.index;
        str += this.blendFuncSrcFactor.webgpu;
        str += this.blendFuncDstFactor.webgpu;
        str += this.blendFuncAlphaSrcFactor.webgpu;
        str += this.blendFuncAlphaDstFactor.webgpu;
        str += this.blendEquationMode.webgpu;
        str += this.blendEquationModeAlpha.webgpu;
        str += this.cullFace ? "1" : "0";
        str += this.cullFrontFaceCCW ? "1" : "0";
        str += this.cullFaceBack ? "1" : "0";
        this.__fingerPrint = str;
      }
      _getFingerPrint() {
        return this.__fingerPrint;
      }
      static get stateVersion() {
        return _Material.__stateVersion;
      }
      ///
      /// Parameter Setters
      ///
      setParameter(shaderSemanticName, value) {
        const info = this._allFieldsInfo.get(shaderSemanticName);
        if (info != null) {
          let valueObj;
          if (info.soloDatum) {
            valueObj = _Material._soloDatumFields.get(this.__materialTypeName).get(shaderSemanticName);
          } else {
            valueObj = this._allFieldVariables.get(shaderSemanticName);
          }
          const updated = MathClassUtil._setForce(valueObj.value, value);
          if (updated) {
            this.__stateVersion++;
            _Material.__stateVersion++;
            this.calcFingerPrint();
          }
        }
      }
      setTextureParameter(shaderSemantic, texture, sampler) {
        if (!sampler.created) {
          sampler.create();
        }
        if (this._allFieldsInfo.has(shaderSemantic)) {
          const setter = /* @__PURE__ */ __name(async () => {
            if (typeof texture.loadFromUrlLazy !== "undefined") {
              await texture.loadFromUrlLazy();
              await texture.loadFromImgLazy();
            }
            const array = this._allFieldVariables.get(shaderSemantic);
            const shaderVariable = {
              value: [
                array.value[0],
                texture,
                sampler
              ],
              info: array.info
            };
            this._allFieldVariables.set(shaderSemantic, shaderVariable);
            if (!array.info.isInternalSetting) {
              this._autoFieldVariablesOnly.set(shaderSemantic, shaderVariable);
            }
            if (shaderSemantic === "diffuseColorTexture" || shaderSemantic === "baseColorTexture") {
              if (texture.isTransparent) {
                this.alphaMode = AlphaMode.Blend;
              }
            }
            this.__stateVersion++;
            _Material.__stateVersion++;
            this.calcFingerPrint();
          }, "setter");
          if (typeof texture.hasDataToLoadLazy !== "undefined") {
            if (texture.hasDataToLoadLazy) {
              setTimeout(setter, 0);
            } else {
              setter();
            }
          } else {
            setter();
          }
        }
      }
      getTextureParameter(shaderSemantic) {
        if (this._allFieldsInfo.has(shaderSemantic)) {
          const array = this._allFieldVariables.get(shaderSemantic);
          return array.value[1];
        }
        return void 0;
      }
      setTextureParameterAsPromise(shaderSemantic, promise) {
        promise.then((texture) => {
          if (this._allFieldsInfo.has(shaderSemantic)) {
            const array = this._allFieldVariables.get(shaderSemantic);
            const shaderVariable = {
              value: [
                array.value[0],
                texture
              ],
              info: array.info
            };
            this._allFieldVariables.set(shaderSemantic, shaderVariable);
            if (!array.info.isInternalSetting) {
              this._autoFieldVariablesOnly.set(shaderSemantic, shaderVariable);
            }
            if (shaderSemantic === "diffuseColorTexture" || shaderSemantic === "baseColorTexture") {
              if (texture.isTransparent) {
                this.alphaMode = AlphaMode.Blend;
              }
            }
          }
          this.__stateVersion++;
          _Material.__stateVersion++;
          this.calcFingerPrint();
        });
      }
      getParameter(shaderSemantic) {
        var _a40, _b;
        const info = this._allFieldsInfo.get(shaderSemantic);
        if (info != null) {
          if (info.soloDatum) {
            return (_a40 = _Material._soloDatumFields.get(this.__materialTypeName).get(shaderSemantic)) == null ? void 0 : _a40.value;
          } else {
            return (_b = this._allFieldVariables.get(shaderSemantic)) == null ? void 0 : _b.value;
          }
        }
        return void 0;
      }
      /**
      * return whether the shader program ready or not
      * @returns is shader program ready or not
      */
      isShaderProgramReady(primitive) {
        return this._shaderProgramUidMap.has(primitive._getFingerPrint());
      }
      /**
      * @internal
      * called from WebGLStrategyDataTexture and WebGLStrategyUniform only
      * @param isUniformOnlyMode
      */
      _setUniformLocationsOfMaterialNodes(isUniformOnlyMode, primitive) {
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        let array = [];
        if (this._materialContent != null) {
          const semanticsInfoArray = this._materialContent._semanticsInfoArray;
          array = array.concat(semanticsInfoArray);
        }
        const shaderProgramUid = this._shaderProgramUidMap.get(primitive._getFingerPrint());
        webglResourceRepository.setupUniformLocations(shaderProgramUid, array, isUniformOnlyMode);
      }
      getShaderProgramUid(primitive) {
        var _a40;
        const primitiveFingerPrint = primitive._getFingerPrint();
        return (_a40 = this._shaderProgramUidMap.get(primitiveFingerPrint)) != null ? _a40 : -1;
      }
      /**
      * @internal
      * called from Primitive class only
      * @param primitive
      */
      _addBelongPrimitive(primitive) {
        this.__belongPrimitives.set(primitive.primitiveUid, primitive);
      }
      /**
      * @internal
      * called from WebGLStrategyDataTexture and WebGLStrategyUniform
      * @param vertexShaderMethodDefinitions_uniform
      * @param propertySetter
      * @param isWebGL2
      * @returns
      */
      _createProgramWebGL(vertexShaderMethodDefinitions_uniform, propertySetter, primitive, isWebGL2) {
        const { vertexPropertiesStr, pixelPropertiesStr } = this._getProperties(propertySetter, isWebGL2);
        const [programUid, newOne] = _createProgramAsSingleOperationWebGL(this, primitive, vertexPropertiesStr, pixelPropertiesStr, vertexShaderMethodDefinitions_uniform, isWebGL2);
        this._shaderProgramUidMap.set(primitive._getFingerPrint(), programUid);
        _Material.__stateVersion++;
        return [
          programUid,
          newOne
        ];
      }
      _createProgramWebGpu(primitive, vertexShaderMethodDefinitions, propertySetter) {
        const { vertexPropertiesStr, pixelPropertiesStr } = this._getProperties(propertySetter, true);
        const programUid = _createProgramAsSingleOperationWebGpu(this, primitive, vertexShaderMethodDefinitions, vertexPropertiesStr, pixelPropertiesStr);
        this._shaderProgramUidMap.set(primitive._getFingerPrint(), programUid);
        _Material.__stateVersion++;
      }
      /**
      * create program by updated shader source code
      * @internal
      * called from WebGLStrategyDataTexture and WebGLStrategyUniform
      *
      * @param updatedShaderSources - updated shader source code
      * @param onError
      * @returns
      */
      _createProgramByUpdatedSources(updatedShaderSources, primitive, onError) {
        const [programUid, newOne] = _createProgramAsSingleOperationByUpdatedSources(this, primitive, this._materialContent, updatedShaderSources, onError);
        this._shaderProgramUidMap.set(primitive._getFingerPrint(), programUid);
        if (programUid > 0) {
        }
        _Material.__stateVersion++;
        return [
          programUid,
          newOne
        ];
      }
      /**
      * @internal
      * called WebGLStrategyDataTexture and WebGLStrategyUniform only
      */
      _setupBasicUniformsLocations(primitive) {
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        const primitiveFingerPrint = primitive._getFingerPrint();
        const shaderProgramUid = this._shaderProgramUidMap.get(primitiveFingerPrint);
        webglResourceRepository.setupBasicUniformLocations(shaderProgramUid);
      }
      /**
      * @internal
      * called WebGLStrategyDataTexture and WebGLStrategyUniform only
      */
      _setupAdditionalUniformLocations(shaderSemantics, isUniformOnlyMode, primitive) {
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        const primitiveFingerPrint = primitive._getFingerPrint();
        const shaderProgramUid = this._shaderProgramUidMap.get(primitiveFingerPrint);
        webglResourceRepository.setupUniformLocations(shaderProgramUid, shaderSemantics, isUniformOnlyMode);
      }
      _setInternalSettingParametersToGpuWebGpu({ material, args }) {
        this._materialContent._setInternalSettingParametersToGpuWebGpu({
          material,
          args
        });
      }
      /**
      * @internal
      * called from WebGLStrategyDataTexture and WebGLStrategyUniform only
      */
      _setParametersToGpuWebGL({ material, shaderProgram, firstTime, args }) {
        this.__setAutoParametersToGpuWebGL(args.setUniform, firstTime, shaderProgram);
        this._materialContent._setInternalSettingParametersToGpuWebGL({
          material,
          shaderProgram,
          firstTime,
          args
        });
        this.__setSoloDatumParametersToGpuWebGL({
          shaderProgram,
          firstTime,
          isUniformMode: args.setUniform
        });
      }
      _setParametersToGpuWebGLPerPrimitive({ material, shaderProgram, firstTime, args }) {
        this._materialContent._setInternalSettingParametersToGpuWebGLPerPrimitive({
          material,
          shaderProgram,
          firstTime,
          args
        });
      }
      _setParametersToGpuWebGLWithOutInternalSetting({ shaderProgram, firstTime, isUniformMode }) {
        this.__setAutoParametersToGpuWebGL(isUniformMode, firstTime, shaderProgram);
        this.__setSoloDatumParametersToGpuWebGL({
          shaderProgram,
          firstTime,
          isUniformMode
        });
      }
      /**
      * @internal
      * @param propertySetter
      */
      _getProperties(propertySetter, isWebGL2) {
        let vertexPropertiesStr = "";
        let pixelPropertiesStr = "";
        this._allFieldsInfo.forEach((info) => {
          if (info.stage === ShaderType.VertexShader || info.stage === ShaderType.VertexAndPixelShader) {
            vertexPropertiesStr += propertySetter(this.__materialTypeName, info, false, isWebGL2);
          }
          if (info.stage === ShaderType.PixelShader || info.stage === ShaderType.VertexAndPixelShader) {
            pixelPropertiesStr += propertySetter(this.__materialTypeName, info, false, isWebGL2);
          }
        });
        const globalDataRepository = GlobalDataRepository.getInstance();
        [vertexPropertiesStr, pixelPropertiesStr] = globalDataRepository._addPropertiesStr(vertexPropertiesStr, pixelPropertiesStr, propertySetter, isWebGL2);
        return {
          vertexPropertiesStr,
          pixelPropertiesStr
        };
      }
      __setAutoParametersToGpuWebGL(isUniformMode, firstTime, shaderProgram) {
        if (_Material.__webglResourceRepository == null) {
          _Material.__webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        }
        const webglResourceRepository = _Material.__webglResourceRepository;
        if (isUniformMode) {
          this._autoFieldVariablesOnly.forEach((value) => {
            const info = value.info;
            webglResourceRepository.setUniformValue(shaderProgram, info.semantic, firstTime, value.value);
          });
        } else {
          for (const [key, value] of this._autoFieldVariablesOnly) {
            const info = value.info;
            if (CompositionType.isTexture(info.compositionType)) {
              if (firstTime) {
                webglResourceRepository.setUniform1iForTexture(shaderProgram, info.semantic, value.value);
              } else {
                webglResourceRepository.bindTexture(info, value.value);
              }
            } else if (info.needUniformInDataTextureMode) {
              webglResourceRepository.setUniformValue(shaderProgram, info.semantic, firstTime, value.value);
            }
          }
        }
      }
      __setSoloDatumParametersToGpuWebGL({ shaderProgram, firstTime, isUniformMode }) {
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        const materialTypeName = this.__materialTypeName;
        const map = _Material._soloDatumFields.get(materialTypeName);
        if (map == null) return;
        const values = map.values();
        for (const value of values) {
          const info = value.info;
          if (isUniformMode || CompositionType.isTexture(info.compositionType)) {
            if (!info.isInternalSetting) {
              if (firstTime) {
                webglResourceRepository.setUniformValue(shaderProgram, info.semantic, firstTime, value.value);
              } else {
                webglResourceRepository.bindTexture(info, value.value);
              }
            }
          }
        }
      }
      /**
      * Change the blendEquations
      * This method works only if this alphaMode is the blend
      * @param blendEquationMode the argument of gl.blendEquation of the first argument of gl.blendEquationSeparate such as gl.FUNC_ADD
      * @param blendEquationModeAlpha the second argument of gl.blendEquationSeparate
      */
      setBlendEquationMode(blendEquationMode, blendEquationModeAlpha) {
        this.__blendEquationMode = blendEquationMode;
        this.__blendEquationModeAlpha = blendEquationModeAlpha != null ? blendEquationModeAlpha : blendEquationMode;
        this.__treatForMinMax();
        this.__stateVersion++;
        _Material.__stateVersion++;
        this.calcFingerPrint();
      }
      __treatForMinMax() {
        if (this.__blendEquationMode === Blend2.Min || this.__blendEquationMode === Blend2.Max) {
          this.__blendFuncDstFactor = Blend2.One;
          this.__blendFuncSrcFactor = Blend2.One;
        }
        if (this.__blendEquationModeAlpha === Blend2.Min || this.__blendEquationModeAlpha === Blend2.Max) {
          this.__blendFuncAlphaDstFactor = Blend2.One;
          this.__blendFuncAlphaSrcFactor = Blend2.One;
        }
      }
      /**
      * Change the blendFuncSeparateFactors
      * This method works only if this alphaMode is the blend
      */
      setBlendFuncSeparateFactor(blendFuncSrcFactor, blendFuncDstFactor, blendFuncAlphaSrcFactor, blendFuncAlphaDstFactor) {
        this.__blendFuncSrcFactor = blendFuncSrcFactor;
        this.__blendFuncDstFactor = blendFuncDstFactor;
        this.__blendFuncAlphaSrcFactor = blendFuncAlphaSrcFactor;
        this.__blendFuncAlphaDstFactor = blendFuncAlphaDstFactor;
        this.__treatForMinMax();
        this.__stateVersion++;
        _Material.__stateVersion++;
        this.calcFingerPrint();
      }
      /**
      * Change the blendFuncFactors
      * This method works only if this alphaMode is the blend
      */
      setBlendFuncFactor(blendFuncSrcFactor, blendFuncDstFactor) {
        this.__blendFuncSrcFactor = blendFuncSrcFactor;
        this.__blendFuncDstFactor = blendFuncDstFactor;
        this.__blendFuncAlphaSrcFactor = blendFuncSrcFactor;
        this.__blendFuncAlphaDstFactor = blendFuncDstFactor;
        this.__treatForMinMax();
        this.__stateVersion++;
        _Material.__stateVersion++;
        this.calcFingerPrint();
      }
      // setMaterialNode(materialNode: AbstractMaterialNode) {
      //   this.__materialNode = materialNode;
      // }
      ///
      /// Getters
      ///
      isBlend() {
        if (this.alphaMode === AlphaMode.Blend) {
          return true;
        } else {
          return false;
        }
      }
      /**
      *
      * @returns return true if (alphaMode is Opaque or Mask) and translucent
      */
      isTranslucentOpaque() {
        if (this.alphaMode !== AlphaMode.Blend && this.isTranslucent) {
          return true;
        } else {
          return false;
        }
      }
      isBlendOrTranslucent() {
        if (this.alphaMode === AlphaMode.Blend || this.isTranslucent) {
          return true;
        } else {
          return false;
        }
      }
      isOpaque() {
        return this.alphaMode === AlphaMode.Opaque;
      }
      isMask() {
        return this.alphaMode === AlphaMode.Mask;
      }
      /**
      * NOTE: To apply the alphaToCoverage, the output alpha value must not be fixed to constant value.
      * However, some shaders in the Rhodonite fixes the output alpha value to 1 by setAlphaIfNotInAlphaBlendMode.
      * So we need to improve the shader to use the alphaToCoverage.
      * @param alphaToCoverage apply alphaToCoverage to this material or not
      */
      set alphaToCoverage(alphaToCoverage) {
        if (alphaToCoverage && this.alphaMode === AlphaMode.Blend) {
          Logger.warn("If you set alphaToCoverage = true on a material whose AlphaMode is Translucent, you may get drawing problems.");
        }
        this.__alphaToCoverage = alphaToCoverage;
        this.makeShadersInvalidate();
        this.calcFingerPrint();
      }
      get alphaToCoverage() {
        return this.__alphaToCoverage;
      }
      /**
      * Gets materialTID.
      */
      get materialTID() {
        return this.__materialTid;
      }
      get fieldsInfoArray() {
        return Array.from(this._allFieldsInfo.values());
      }
      get blendEquationMode() {
        return this.__blendEquationMode;
      }
      get blendEquationModeAlpha() {
        return this.__blendEquationModeAlpha;
      }
      get blendFuncSrcFactor() {
        return this.__blendFuncSrcFactor;
      }
      get blendFuncDstFactor() {
        return this.__blendFuncDstFactor;
      }
      get blendFuncAlphaSrcFactor() {
        return this.__blendFuncAlphaSrcFactor;
      }
      get blendFuncAlphaDstFactor() {
        return this.__blendFuncAlphaDstFactor;
      }
      get alphaMode() {
        return this.__alphaMode;
      }
      set alphaMode(mode) {
        this.__alphaMode = mode;
        this.makeShadersInvalidate();
      }
      get materialUID() {
        return this.__materialUid;
      }
      get materialSID() {
        return this.__materialSid;
      }
      get isSkinning() {
        return this._materialContent.isSkinning;
      }
      get isMorphing() {
        return this._materialContent.isMorphing;
      }
      get isLighting() {
        return this._materialContent.isLighting;
      }
      get materialTypeName() {
        return this.__materialTypeName;
      }
      get stateVersion() {
        return this.__stateVersion;
      }
      makeShadersInvalidate() {
        this._shaderProgramUidMap.clear();
        this.__stateVersion++;
        _Material.__stateVersion++;
      }
    };
    __name(_Material, "Material");
    __publicField(_Material, "__stateVersion", 0);
    __publicField(_Material, "__webglResourceRepository");
    // static fields
    __publicField(_Material, "_soloDatumFields", /* @__PURE__ */ new Map());
    Material = _Material;
  }
});

// src/foundation/materials/core/MaterialRepository.ts
var _MaterialRepository, MaterialRepository;
var init_MaterialRepository = __esm({
  "src/foundation/materials/core/MaterialRepository.ts"() {
    "use strict";
    init_Config();
    init_MemoryManager();
    init_BufferUse();
    init_ComponentType();
    init_CompositionType();
    init_ShaderSemanticsInfo();
    init_MathClassUtil();
    init_Is();
    init_Logger();
    init_Material();
    _MaterialRepository = class _MaterialRepository {
      /**
      * Registers the material type.
      * @param materialTypeName The type name of the material.
      * @param materialNodes The material nodes to register.
      * @param maxInstancesNumber The maximum number to create the material instances.
      */
      static registerMaterial(materialTypeName, materialNode, maxInstanceNumber = Config.maxMaterialInstanceForEachType) {
        if (!_MaterialRepository.__materialNodes.has(materialTypeName)) {
          _MaterialRepository.__registerInner(materialTypeName, materialNode, maxInstanceNumber);
          return true;
        } else {
          return false;
        }
      }
      static forceRegisterMaterial(materialTypeName, materialNode, maxInstanceNumber = Config.maxMaterialInstanceForEachType) {
        this.__registerInner(materialTypeName, materialNode, maxInstanceNumber);
        return true;
      }
      static isRegisteredMaterialType(materialTypeName) {
        return _MaterialRepository.__materialNodes.has(materialTypeName);
      }
      static getMaterialByMaterialUid(materialUid) {
        var _a40;
        return (_a40 = this.__materialMap.get(materialUid)) == null ? void 0 : _a40.deref();
      }
      static getAllMaterials() {
        return Array.from(_MaterialRepository.__materialMap.values());
      }
      /**
      * Creates an instance of this Material class.
      * @param materialTypeName The material type to create.
      * @param materialNodes_ The material nodes to add to the created material.
      */
      static createMaterial(materialTypeName, materialNode) {
        let countOfThisType = _MaterialRepository.__materialInstanceCountOfType.get(materialTypeName);
        const material = new Material(_MaterialRepository.__materialTids.get(materialTypeName), ++_MaterialRepository.__materialUidCount, countOfThisType++, materialTypeName, materialNode);
        this.__initializeMaterial(material, countOfThisType);
        return material;
      }
      static isFullOrOverOfThisMaterialType(materialTypeName) {
        const countOfThisType = _MaterialRepository.__materialInstanceCountOfType.get(materialTypeName);
        if (Is.not.exist(countOfThisType)) {
          return false;
        }
        const maxCountOfThisType = _MaterialRepository.__maxInstances.get(materialTypeName);
        if (Is.not.exist(maxCountOfThisType)) {
          return false;
        }
        return countOfThisType >= maxCountOfThisType;
      }
      static isMaterialCompatible(currentMaterial, newMaterialNode) {
        var _a40;
        const existingMaterial = (_a40 = _MaterialRepository.__materialMap.get(currentMaterial.materialUID)) == null ? void 0 : _a40.deref();
        if (Is.not.exist(existingMaterial)) {
          return false;
        }
        const existingShaderSemanticsInfoList = Array.from(existingMaterial._allFieldsInfo.values());
        const newShaderSemanticsInfoList = newMaterialNode._semanticsInfoArray;
        if (JSON.stringify(existingShaderSemanticsInfoList) !== JSON.stringify(newShaderSemanticsInfoList)) {
          return false;
        }
        return true;
      }
      /**
      * Initialize Material Method
      */
      static __initializeMaterial(material, countOfThisType) {
        material.tryToSetUniqueName(material.__materialTypeName, true);
        {
          _MaterialRepository.__materialMap.set(material.materialUID, new WeakRef(material));
          let map = _MaterialRepository.__instances.get(material.__materialTypeName);
          if (Is.not.exist(map)) {
            map = /* @__PURE__ */ new Map();
            _MaterialRepository.__instances.set(material.materialTypeName, map);
          }
          map.set(material.materialSID, new WeakRef(material));
          _MaterialRepository.__materialInstanceCountOfType.set(material.materialTypeName, countOfThisType);
        }
        if (Is.exist(material._materialContent)) {
          const semanticsInfoArray = material._materialContent._semanticsInfoArray;
          const accessorMap = _MaterialRepository.__accessors.get(material.materialTypeName);
          semanticsInfoArray.forEach((semanticsInfo) => {
            material._allFieldsInfo.set(semanticsInfo.semantic, semanticsInfo);
            if (!semanticsInfo.soloDatum) {
              const accessor = accessorMap.get(semanticsInfo.semantic);
              const typedArray = accessor.takeOne();
              const shaderVariable = {
                info: semanticsInfo,
                value: MathClassUtil.initWithFloat32Array(semanticsInfo.initialValue, semanticsInfo.initialValue, typedArray, semanticsInfo.compositionType)
              };
              material._allFieldVariables.set(semanticsInfo.semantic, shaderVariable);
              if (!semanticsInfo.isInternalSetting) {
                material._autoFieldVariablesOnly.set(semanticsInfo.semantic, shaderVariable);
              }
            }
          });
        }
      }
      static getLocationOffsetOfMemberOfMaterial(materialTypeName, propertyName) {
        const map = _MaterialRepository.__instances.get(materialTypeName);
        const materialRef = Array.from(map.values()).find((m) => m.deref() !== void 0);
        if (Is.not.exist(materialRef == null ? void 0 : materialRef.deref())) {
          Logger.warn(`Material is not found. getLocationOffsetOfMemberOfMaterial returns invalid 0 value. materialTypeName: ${materialTypeName}`);
          return 0;
        }
        const material = materialRef.deref();
        const info = material._allFieldsInfo.get(propertyName);
        if (info.soloDatum) {
          const value = Material._soloDatumFields.get(material.materialTypeName).get(propertyName);
          return value.value._v.byteOffset / 4 / 4;
        } else {
          const properties = this.__accessors.get(materialTypeName);
          const accessor = properties.get(propertyName);
          return accessor.byteOffsetInBuffer / 4 / 4;
        }
      }
      static __registerInner(materialTypeName, materialNode, maxInstanceNumber) {
        const materialTid = ++_MaterialRepository.__materialTidCount;
        _MaterialRepository.__materialNodes.set(materialTypeName, materialNode);
        _MaterialRepository.__materialTids.set(materialTypeName, materialTid);
        _MaterialRepository.__maxInstances.set(materialTypeName, maxInstanceNumber);
        _MaterialRepository.__allocateBufferView(materialTypeName, materialNode);
        _MaterialRepository.__materialInstanceCountOfType.set(materialTypeName, 0);
      }
      static __allocateBufferView(materialTypeName, materialNode) {
        let totalByteLength = 0;
        const alignedByteLengthAndSemanticInfoArray = [];
        for (const semanticInfo of materialNode._semanticsInfoArray) {
          const alignedByteLength = calcAlignedByteLength(semanticInfo);
          let dataCount = 1;
          if (!semanticInfo.soloDatum) {
            dataCount = _MaterialRepository.__maxInstances.get(materialTypeName);
          }
          totalByteLength += alignedByteLength * dataCount;
          alignedByteLengthAndSemanticInfoArray.push({
            alignedByte: alignedByteLength,
            semanticInfo
          });
        }
        if (!this.__accessors.has(materialTypeName)) {
          this.__accessors.set(materialTypeName, /* @__PURE__ */ new Map());
        }
        const buffer = MemoryManager.getInstance().createOrGetBuffer(BufferUse.GPUInstanceData);
        let bufferView;
        if (this.__bufferViews.has(materialTypeName)) {
          bufferView = this.__bufferViews.get(materialTypeName);
        } else {
          const result = buffer.takeBufferView({
            byteLengthToNeed: totalByteLength,
            byteStride: 0
          });
          bufferView = result.unwrapForce();
          this.__bufferViews.set(materialTypeName, bufferView);
        }
        for (let i2 = 0; i2 < alignedByteLengthAndSemanticInfoArray.length; i2++) {
          const alignedByte = alignedByteLengthAndSemanticInfoArray[i2].alignedByte;
          const semanticInfo = alignedByteLengthAndSemanticInfoArray[i2].semanticInfo;
          let count = 1;
          if (!semanticInfo.soloDatum) {
            count = _MaterialRepository.__maxInstances.get(materialTypeName);
          }
          let maxArrayLength = semanticInfo.arrayLength;
          if (CompositionType.isArray(semanticInfo.compositionType) && maxArrayLength == null) {
            maxArrayLength = 100;
          }
          const accessor = bufferView.takeAccessor({
            compositionType: semanticInfo.compositionType,
            componentType: ComponentType.Float,
            count,
            byteStride: alignedByte,
            arrayLength: maxArrayLength
          }).unwrapForce();
          if (semanticInfo.soloDatum) {
            const typedArray = accessor.takeOne();
            let map = Material._soloDatumFields.get(materialTypeName);
            if (map == null) {
              map = /* @__PURE__ */ new Map();
              Material._soloDatumFields.set(materialTypeName, map);
            }
            map.set(semanticInfo.semantic, {
              info: semanticInfo,
              value: MathClassUtil.initWithFloat32Array(semanticInfo.initialValue, semanticInfo.initialValue, typedArray, semanticInfo.compositionType)
            });
          } else {
            const properties = this.__accessors.get(materialTypeName);
            properties.set(semanticInfo.semantic, accessor);
          }
        }
        return bufferView;
      }
      static _makeShaderInvalidateToAllMaterials() {
        var _a40;
        for (const material of _MaterialRepository.__materialMap.values()) {
          (_a40 = material.deref()) == null ? void 0 : _a40.makeShadersInvalidate();
        }
      }
    };
    __name(_MaterialRepository, "MaterialRepository");
    ///
    /// static members
    ///
    __publicField(_MaterialRepository, "__materialMap", /* @__PURE__ */ new Map());
    __publicField(_MaterialRepository, "__instances", /* @__PURE__ */ new Map());
    __publicField(_MaterialRepository, "__materialTids", /* @__PURE__ */ new Map());
    __publicField(_MaterialRepository, "__materialInstanceCountOfType", /* @__PURE__ */ new Map());
    __publicField(_MaterialRepository, "__materialNodes", /* @__PURE__ */ new Map());
    __publicField(_MaterialRepository, "__maxInstances", /* @__PURE__ */ new Map());
    __publicField(_MaterialRepository, "__bufferViews", /* @__PURE__ */ new Map());
    __publicField(_MaterialRepository, "__accessors", /* @__PURE__ */ new Map());
    __publicField(_MaterialRepository, "__materialTidCount", -1);
    __publicField(_MaterialRepository, "__materialUidCount", -1);
    MaterialRepository = _MaterialRepository;
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/GaussianBlurShader/GaussianBlurShader.vert
var GaussianBlurShader_default;
var init_GaussianBlurShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/GaussianBlurShader/GaussianBlurShader.vert"() {
    GaussianBlurShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec3 a_position;\nin vec2 a_texcoord_0;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/GaussianBlurShader/GaussianBlurShader.frag
var GaussianBlurShader_default2;
var init_GaussianBlurShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/GaussianBlurShader/GaussianBlurShader.frag"() {
    GaussianBlurShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\nin vec2 v_texcoord_0;\n\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  vec2 offset = gl_FragCoord.st;\n  ivec2 vrState = get_vrState(0.0, 0);\n  vec2 framebufferSize = get_framebufferSize(materialSID, 0);\n  vec2 blurDirection;\n  bool isHorizontal = get_isHorizontal(materialSID, 0);\n  if (isHorizontal) {\n    blurDirection = vec2(1.0, 0.0);\n  } else { // vertical\n    blurDirection = vec2(0.0, 1.0);\n  }\n	vec2 tFrag = 1.0 / framebufferSize;\n\n  vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n  int gaussianKernelSize = get_gaussianKernelSize(materialSID, 0);\n  float minStrideLength = -float(gaussianKernelSize - 1) / 2.0;\n\n  for(int i = 0; i < gaussianKernelSize; i++) {\n    float strideLength = minStrideLength + float(i);\n    vec2 stride = strideLength * blurDirection;\n    float gaussianRatio = get_gaussianRatio(materialSID, i);\n    vec2 uv = (offset + stride) * tFrag;\n    if (vrState.x == 1 && isHorizontal) { // if in VR mode and horizontal blur\n      if (gl_FragCoord.x < framebufferSize.x / 2.0) { // left eye\n        uv.x = min(uv.x, 0.5);\n      } else { // right eye\n        uv.x = max(uv.x, 0.5);\n      }\n    }\n    color.rgb += texture(u_baseColorTexture, uv).rgb * gaussianRatio;\n  }\n\n  rt0 = color;\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/GaussianBlurShader/GaussianBlurShader.vert
var GaussianBlurShader_default3;
var init_GaussianBlurShader3 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/GaussianBlurShader/GaussianBlurShader.vert"() {
    GaussianBlurShader_default3 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n  @builtin(vertex_index) vertexIdx : u32,\n) -> VertexOutput {\n  var output : VertexOutput;\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\nlet x = f32((vertexIdx & 1u) << 2u);\nlet y = f32((vertexIdx & 2u) << 1u);\noutput.texcoord_0.x = x * 0.5;\noutput.texcoord_0.y = y * 0.5;\noutput.texcoord_0.y = 1.0 - output.texcoord_0.y;\noutput.position = vec4f(x - 1.0, y - 1.0, 0, 1);\n\n\n  return output;\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/GaussianBlurShader/GaussianBlurShader.frag
var GaussianBlurShader_default4;
var init_GaussianBlurShader4 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/GaussianBlurShader/GaussianBlurShader.frag"() {
    GaussianBlurShader_default4 = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n@fragment\nfn main(\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  let offset = input.position.xy;\n\n  let framebufferSize: vec2f = get_framebufferSize(materialSID, 0);\n  var blurDirection: vec2f;\n  let isHorizontal: bool = get_isHorizontal(materialSID, 0);\n  if (isHorizontal) {\n    blurDirection = vec2f(1.0, 0.0);\n  } else { // vertical\n    blurDirection = vec2f(0.0, 1.0);\n  }\n	let tFrag: vec2f = 1.0 / framebufferSize;\n\n  var color = vec4f(0.0, 0.0, 0.0, 1.0);\n  let gaussianKernelSize: i32 = get_gaussianKernelSize(materialSID, 0);\n  let minStrideLength = - f32(gaussianKernelSize - 1) / 2.0;\n\n  for (var i=0u; i < u32(gaussianKernelSize); i++) {\n\n    let strideLength = minStrideLength + f32(i);\n    let stride: vec2f = strideLength * blurDirection;\n\n    let gaussianRatio = get_gaussianRatio(materialSID, i);\n    var uv = (offset + stride) * tFrag;\n    // uv.y = 1.0 - uv.y;\n    color += vec4f(textureSampleLevel(baseColorTexture, baseColorSampler, uv, 0.0).rgb, 1.0) * gaussianRatio;\n  }\n\n  return color;\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/GaussianBlurForEncodedDepthShader/GaussianBlurForEncodedDepthShader.vert
var GaussianBlurForEncodedDepthShader_default;
var init_GaussianBlurForEncodedDepthShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/GaussianBlurForEncodedDepthShader/GaussianBlurForEncodedDepthShader.vert"() {
    GaussianBlurForEncodedDepthShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec3 a_position;\nin vec2 a_texcoord_0;\nout vec2 v_texcoord_0;\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main(){\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n}\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/GaussianBlurForEncodedDepthShader/GaussianBlurForEncodedDepthShader.frag
var GaussianBlurForEncodedDepthShader_default2;
var init_GaussianBlurForEncodedDepthShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/GaussianBlurForEncodedDepthShader/GaussianBlurForEncodedDepthShader.frag"() {
    GaussianBlurForEncodedDepthShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\nfloat decodeRGBAToDepth(vec4 RGBA){\n  const float rMask = 1.0;\n  const float gMask = 1.0 / 255.0;\n  const float bMask = 1.0 / (255.0 * 255.0);\n  const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n  float depth = dot(RGBA, vec4(rMask, gMask, bMask, aMask));\n  return depth;\n}\n\nvec4 encodeDepthToRGBA(float depth){\n  float r = depth;\n  float g = fract(r * 255.0);\n  float b = fract(g * 255.0);\n  float a = fract(b * 255.0);\n  float coef = 1.0 / 255.0;\n  r -= g * coef;\n  g -= b * coef;\n  b -= a * coef;\n  return vec4(r, g, b, a);\n}\n\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  float framebufferSize;\n  vec2 offset = gl_FragCoord.st;\n\n  vec2 blurDirection;\n  bool isHorizontal = get_isHorizontal(materialSID, 0);\n  if(isHorizontal){\n    framebufferSize = get_framebufferSize(materialSID, 0).x;\n    blurDirection = vec2(1.0,0.0);\n  }else{\n    framebufferSize = get_framebufferSize(materialSID, 0).y;\n    blurDirection = vec2(0.0,1.0);\n  }\n	float tFrag = 1.0 / framebufferSize;\n\n  float depth = 0.0;\n  int gaussianKernelSize = get_gaussianKernelSize(materialSID, 0);\n  float minStrideLength = -float(gaussianKernelSize - 1) / 2.0;\n\n  for(int i=0; i < 30; i++) {\n    if(gaussianKernelSize == i) {\n      break;\n    }\n\n    float strideLength = minStrideLength + float(i);\n    vec2 stride = strideLength * blurDirection;\n    float depthData = decodeRGBAToDepth(texture(u_baseColorTexture, (offset + stride) * tFrag));\n    if(depthData > 1.0) depthData = 1.0;\n\n    float gaussianRatio = u_gaussianRatio[i];\n    depth +=  depthData * gaussianRatio;\n  }\n\n  rt0 = encodeDepthToRGBA(depth);\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/PanoramaToCubeShader/PanoramaToCubeShader.vert
var PanoramaToCubeShader_default;
var init_PanoramaToCubeShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/PanoramaToCubeShader/PanoramaToCubeShader.vert"() {
    PanoramaToCubeShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main()\n{\n  \n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n  \n}\n\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/PanoramaToCubeShader/PanoramaToCubeShader.frag
var PanoramaToCubeShader_default2;
var init_PanoramaToCubeShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/PanoramaToCubeShader/PanoramaToCubeShader.frag"() {
    PanoramaToCubeShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord_0;\n\nuniform sampler2D u_baseColorTexture; // initialValue=(0,white)\nuniform int u_cubeMapFaceId; // initialValue=0\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nvec2 dirToPanoramaUV(vec3 dir)\n{\n	return vec2(\n		0.5f + 0.5f * atan(dir.z, dir.x) / PI,\n		1.f - acos(dir.y) / PI);\n}\n\nvec3 uvToDirection(int faceId, vec2 uv)\n{\n	if(faceId == 0)\n		return vec3(1.f, uv.y, -uv.x);\n	else if(faceId == 1)\n		return vec3(-1.f, uv.y, uv.x);\n	else if(faceId == 2)\n		return vec3(+uv.x, -1.f, +uv.y);\n	else if(faceId == 3)\n		return vec3(+uv.x, 1.f, -uv.y);\n	else if(faceId == 4)\n		return vec3(+uv.x, uv.y, 1.f);\n	else\n    return vec3(-uv.x, +uv.y, -1.f);\n}\n\n// learned a lot from https://github.com/KhronosGroup/glTF-Sample-Viewer\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n	vec2 uv = v_texcoord_0 * 2.0 - 1.0;\n	vec3 direction = normalize(uvToDirection(get_cubeMapFaceId(materialSID, 0), uv));\n	vec2 panoramaUv = dirToPanoramaUV(direction);\n	rt0 = vec4(texture(u_baseColorTexture, panoramaUv).rgb, 1.0);\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/PanoramaToCubeShader/PanoramaToCubeShader.vert.wgsl
var PanoramaToCubeShader_vert_default;
var init_PanoramaToCubeShader_vert = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/PanoramaToCubeShader/PanoramaToCubeShader.vert.wgsl"() {
    PanoramaToCubeShader_vert_default = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n  @builtin(vertex_index) vertexIdx : u32,\n) -> VertexOutput {\n  var output : VertexOutput;\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\nlet x = f32((vertexIdx & 1u) << 2u);\nlet y = f32((vertexIdx & 2u) << 1u);\noutput.texcoord_0.x = x * 0.5;\noutput.texcoord_0.y = y * 0.5;\noutput.texcoord_0.y = 1.0 - output.texcoord_0.y;\noutput.position = vec4f(x - 1.0, y - 1.0, 0, 1);\n\n\n  return output;\n\n}\n\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/PanoramaToCubeShader/PanoramaToCubeShader.frag.wgsl
var PanoramaToCubeShader_frag_default;
var init_PanoramaToCubeShader_frag = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/PanoramaToCubeShader/PanoramaToCubeShader.frag.wgsl"() {
    PanoramaToCubeShader_frag_default = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n@group(1) @binding(0) var baseColorTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(0) var baseColorSampler: sampler;\n\n// #param cubeMapFaceId: i32; // initialValue=0\n\nfn dirToPanoramaUV(dir: vec3f) -> vec2f\n{\n	return vec2f(\n		0.5f + 0.5f * atan2(dir.z, dir.x) / M_PI,\n		1.f - acos(dir.y) / M_PI);\n}\n\nfn uvToDirection(faceId: i32, uv: vec2f) -> vec3f\n{\n	if (faceId == 0) {\n		return vec3f(1.f, uv.y, -uv.x);\n  } else if(faceId == 1) {\n		return vec3f(-1.f, uv.y, uv.x);\n  } else if(faceId == 2) {\n		return vec3f(uv.x, -1.f, uv.y);\n  } else if(faceId == 3) {\n		return vec3f(uv.x, 1.f, -uv.y);\n  } else if(faceId == 4) {\n		return vec3f(uv.x, uv.y, 1.f);\n  } else {\n    return vec3f(-uv.x, uv.y, -1.f);\n  }\n}\n\n// learned a lot from https://github.com/KhronosGroup/glTF-Sample-Viewer\n@fragment\nfn main (\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n	let uv: vec2f = input.texcoord_0 * 2.0 - 1.0;\n	let direction: vec3f = normalize(uvToDirection(get_cubeMapFaceId(materialSID, 0), uv));\n  let panoramaUv: vec2f = dirToPanoramaUV(direction);\n	let rt0: vec4f = vec4f(textureSampleLevel(baseColorTexture, baseColorSampler, panoramaUv, 0.0).rgb, 1.0);\n  return rt0;\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/PrefilterIBLShader/PrefilterIBLShader.vert
var PrefilterIBLShader_default;
var init_PrefilterIBLShader = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/PrefilterIBLShader/PrefilterIBLShader.vert"() {
    PrefilterIBLShader_default = { code: "\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec3 a_position;\nout vec2 v_texcoord_0;\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nvoid main()\n{\n  \n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\nfloat x = float((gl_VertexID & 1) << 2);\nfloat y = float((gl_VertexID & 2) << 1);\nv_texcoord_0.x = x * 0.5;\nv_texcoord_0.y = y * 0.5;\ngl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n\n  \n}\n\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/PrefilterIBLShader/PrefilterIBLShader.frag
var PrefilterIBLShader_default2;
var init_PrefilterIBLShader2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/PrefilterIBLShader/PrefilterIBLShader.frag"() {
    PrefilterIBLShader_default2 = { code: "\n#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : require\n#endif\n\n#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES\n#extension GL_OES_standard_derivatives : require\n#endif\n\n#ifdef WEBGL1_EXT_DRAW_BUFFERS\n#extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\nin vec2 v_texcoord_0;\n\nuniform samplerCube u_baseColorTexture; // initialValue=(0,white)\nuniform int u_cubeMapFaceId; // initialValue=0\nuniform int u_distributionType; // initialValue=0\nuniform float u_roughness; // initialValue=0.0\nuniform int u_sampleCount; // initialValue=1024\n\n/* shaderity: @{renderTargetBegin} */\n\n\n/* shaderity: @{getters} */\n\nconst int cLambertian = 0;\nconst int cGGX = 1;\n\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\nfloat radicalInverse_VdC(uint bits)\n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 hammersley2d(int i, int N) {\n    return vec2(float(i)/float(N), radicalInverse_VdC(uint(i)));\n}\n\nmat3 createTBN(vec3 normal)\n{\n    vec3 bitangent = vec3(0.0, 1.0, 0.0);\n    float NdotUp = dot(normal, vec3(0.0, 1.0, 0.0));\n    float epsilon = 0.0000001;\n    if (1.0 - abs(NdotUp) <= epsilon)\n    {\n      bitangent = (NdotUp > 0.0) ? vec3(0.0, 0.0, 1.0) : vec3(0.0, 0.0, -1.0);\n    }\n    vec3 tangent = normalize(cross(bitangent, normal));\n    bitangent = cross(normal, tangent);\n    return mat3(tangent, bitangent, normal);\n}\n\nvec4 getImportanceSampleLambertian(int sampleIndex, vec3 N, float roughness, float materialSID)\n{\n    vec2 xi = hammersley2d(sampleIndex, get_sampleCount(materialSID, 0));\n\n    float sinTheta = sqrt(1.0 - xi.y);\n    float cosTheta = sqrt(xi.y);\n    float phi = 2.0 * PI * xi.x;\n    float pdf = cosTheta / PI;\n\n    vec3 localDirection = normalize(vec3(\n        sinTheta * cos(phi),\n        sinTheta * sin(phi),\n        cosTheta\n    ));\n    vec3 direction = createTBN(N) * localDirection;\n\n    return vec4(direction, pdf);\n}\n\n// GGX NDF\nfloat d_GGX(float NH, float alphaRoughness) {\n  float roughnessSqr = alphaRoughness * alphaRoughness;\n  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;\n  return roughnessSqr / (PI * f * f);\n}\n\n// We learnd a lot from the following resources\n// https://bruop.github.io/ibl/\nvec4 getImportanceSampleGGX(int sampleIndex, vec3 N, float roughness, float materialSID)\n{\n    vec2 xi = hammersley2d(sampleIndex, get_sampleCount(materialSID, 0));\n\n    float alpha = roughness * roughness;\n    float cosTheta = clamp(sqrt((1.0 - xi.y) / (1.0 + (alpha * alpha - 1.0) * xi.y)), 0.0, 1.0);\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    float phi = 2.0 * PI * xi.x;\n    float pdf = d_GGX(cosTheta, alpha);\n    pdf /= 4.0;\n\n    vec3 localDirection = normalize(vec3(\n        sinTheta * cos(phi),\n        sinTheta * sin(phi),\n        cosTheta\n    ));\n    vec3 direction = createTBN(N) * localDirection;\n\n    return vec4(direction, pdf);\n}\n\n// We learnd a lot from the following resources\n// https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling\n// https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf\n// https://google.github.io/filament/Filament.html#annex/importancesamplingfortheibl/pre-filteredimportancesampling\nfloat computeLod(float pdf, int width, int sampleCount)\n{\n    // 6.0 is the number of faces of the cubemap\n    // log4 = 0.5 * log2\n    // We don't use the constant K in the filament document\n    return 0.5 * log2( 6.0 * float(width) * float(width) / (float(sampleCount) * pdf));\n}\n\nvec3 prefilter(vec3 N, float materialSID)\n{\n    vec3 color = vec3(0.f);\n    float weight = 0.0f;\n    int sampleCount = get_sampleCount(materialSID, 0);\n\n    ivec2 texSize = textureSize(u_baseColorTexture, 0);\n\n    for(int i = 0; i < get_sampleCount(materialSID, 0); ++i)\n    {\n        vec4 importanceSample;\n\n        int distributionType = get_distributionType(materialSID, 0);\n        if(distributionType == cLambertian) {\n            importanceSample = getImportanceSampleLambertian(i, N, get_roughness(materialSID, 0), materialSID);\n        } else {\n            importanceSample = getImportanceSampleGGX(i, N, get_roughness(materialSID, 0), materialSID);\n        }\n\n        vec3 H = vec3(importanceSample.xyz);\n        float pdf = importanceSample.w;\n        float lod = computeLod(pdf, texSize.x, sampleCount);\n\n        if(distributionType == cLambertian)\n        {\n            vec3 lambertian = textureLod(u_baseColorTexture, H, lod).rgb;\n            color += lambertian;\n        }\n        else if(distributionType == cGGX)\n        {\n            vec3 V = N;\n            vec3 L = normalize(reflect(-V, H));\n            float NdotL = dot(N, L);\n\n            if (NdotL > 0.0)\n            {\n                vec3 sampleColor = textureLod(u_baseColorTexture, L, lod).rgb;\n                color += sampleColor * NdotL;\n                weight += NdotL;\n            }\n        }\n    }\n\n    if(weight != 0.0f)\n    {\n        color /= weight;\n    }\n    else\n    {\n        color /= float(sampleCount);\n    }\n\n    return color.rgb;\n}\n\nvec3 uvToDir(int faceId, vec2 uv)\n{\n	if(faceId == 0)\n		return vec3(1.f, uv.y, -uv.x);\n	else if(faceId == 1)\n		return vec3(-1.f, uv.y, uv.x);\n	else if(faceId == 2)\n		return vec3(+uv.x, -1.f, +uv.y);\n	else if(faceId == 3)\n		return vec3(+uv.x, 1.f, -uv.y);\n	else if(faceId == 4)\n		return vec3(+uv.x, uv.y, 1.f);\n	else\n    return vec3(-uv.x, +uv.y, -1.f);\n}\n\n// learned a lot from https://github.com/KhronosGroup/glTF-Sample-Viewer\nvoid main ()\n{\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  vec2 uv = v_texcoord_0 * 2.0 - 1.0;\n  vec3 scan = uvToDir(get_cubeMapFaceId(materialSID, 0), uv);\n  vec3 direction = normalize(scan);\n  direction.y = -direction.y;\n\n  rt0 = vec4(prefilter(direction, materialSID), 1.0);\n\n/* shaderity: @{renderTargetEnd} */\n\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/PrefilterIBLShader/PrefilterIBLShader.vert.wgsl
var PrefilterIBLShader_vert_default;
var init_PrefilterIBLShader_vert = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/PrefilterIBLShader/PrefilterIBLShader.vert.wgsl"() {
    PrefilterIBLShader_vert_default = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n@vertex\nfn main(\n  @builtin(vertex_index) vertexIdx : u32,\n) -> VertexOutput {\n  var output : VertexOutput;\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\nlet x = f32((vertexIdx & 1u) << 2u);\nlet y = f32((vertexIdx & 2u) << 1u);\noutput.texcoord_0.x = x * 0.5;\noutput.texcoord_0.y = y * 0.5;\noutput.texcoord_0.y = 1.0 - output.texcoord_0.y;\noutput.position = vec4f(x - 1.0, y - 1.0, 0, 1);\n\n\n  return output;\n\n}\n\n\n", shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/PrefilterIBLShader/PrefilterIBLShader.frag.wgsl
var PrefilterIBLShader_frag_default;
var init_PrefilterIBLShader_frag = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/PrefilterIBLShader/PrefilterIBLShader.frag.wgsl"() {
    PrefilterIBLShader_frag_default = { code: "/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n\n\n@group(1) @binding(0) var baseColorTexture: texture_cube<f32>; // initialValue=white\n@group(2) @binding(0) var baseColorSampler: sampler;\n// #param cubeMapFaceId: i32; // initialValue=0\n// #param distributionType: i32; // initialValue=0\n// #param roughness: f32; // initialValue=0.0\n// #param sampleCount: i32; // initialValue=1024\n\nconst cLambertian: i32 = 0;\nconst cGGX: i32 = 1;\n\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\nfn radicalInverse_VdC(_bits: u32) -> f32\n{\n    var bits = (_bits << 16u) | (_bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return f32(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nfn hammersley2d(i: i32, N: i32) -> vec2f {\n    return vec2f(f32(i)/f32(N), radicalInverse_VdC(u32(i)));\n}\n\nfn createTBN(normal: vec3f) -> mat3x3<f32>\n{\n    var bitangent = vec3f(0.0, 1.0, 0.0);\n    let NdotUp = dot(normal, vec3f(0.0, 1.0, 0.0));\n    let epsilon = 0.0000001;\n    if (1.0 - abs(NdotUp) <= epsilon)\n    {\n      bitangent = select(vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, 1.0), NdotUp > 0.0);\n    }\n    let tangent = normalize(cross(bitangent, normal));\n    bitangent = cross(normal, tangent);\n    return mat3x3<f32>(tangent, bitangent, normal);\n}\n\nfn getImportanceSampleLambertian(sampleIndex: i32, N: vec3f, roughness: f32, materialSID: u32) -> vec4f\n{\n    let xi = hammersley2d(sampleIndex, get_sampleCount(materialSID, 0));\n\n    let sinTheta = sqrt(1.0 - xi.y);\n    let cosTheta = sqrt(xi.y);\n    let phi = 2.0 * M_PI * xi.x;\n    let pdf = cosTheta / M_PI;\n\n    let localDirection = normalize(vec3f(\n        sinTheta * cos(phi),\n        sinTheta * sin(phi),\n        cosTheta\n    ));\n    let direction = createTBN(N) * localDirection;\n\n    return vec4f(direction, pdf);\n}\n\n// GGX NDF\nfn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {\n  let roughnessSqr = alphaRoughness * alphaRoughness;\n  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;\n  return roughnessSqr / (M_PI * f * f);\n}\n\n// We learnd a lot from the following resources\n// https://bruop.github.io/ibl/\nfn getImportanceSampleGGX(sampleIndex: i32, N: vec3f, roughness: f32, materialSID: u32) -> vec4f\n{\n    let xi = hammersley2d(sampleIndex, get_sampleCount(materialSID, 0));\n\n    let alpha = roughness * roughness;\n    let cosTheta = clamp(sqrt((1.0 - xi.y) / (1.0 + (alpha * alpha - 1.0) * xi.y)), 0.0, 1.0);\n    let sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    let phi = 2.0 * M_PI * xi.x;\n    var pdf = d_GGX(cosTheta, alpha);\n    pdf /= 4.0;\n\n    let localDirection = normalize(vec3f(\n        sinTheta * cos(phi),\n        sinTheta * sin(phi),\n        cosTheta\n    ));\n    let direction = createTBN(N) * localDirection;\n\n    return vec4f(direction, pdf);\n}\n\n// We learnd a lot from the following resources\n// https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling\n// https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf\n// https://google.github.io/filament/Filament.html#annex/importancesamplingfortheibl/pre-filteredimportancesampling\nfn computeLod(pdf: f32, width: u32, sampleCount: i32) -> f32\n{\n    // 6.0 is the number of faces of the cubemap\n    // log4 = 0.5 * log2\n    // We don't use the constant K in the filament document\n    return 0.5 * log2( 6.0 * f32(width) * f32(width) / (f32(sampleCount) * pdf));\n}\n\nfn prefilter(N: vec3f, materialSID: u32) -> vec3f\n{\n    var color = vec3f(0.f);\n    var weight = 0.0f;\n    let sampleCount = get_sampleCount(materialSID, 0);\n\n    let texSize: vec2<u32> = textureDimensions(baseColorTexture, 0);\n\n    for(var i = 0; i < get_sampleCount(materialSID, 0); i++)\n    {\n        var importanceSample: vec4<f32>;\n\n        let distributionType = get_distributionType(materialSID, 0);\n        if(distributionType == cLambertian) {\n            importanceSample = getImportanceSampleLambertian(i, N, get_roughness(materialSID, 0), materialSID);\n        } else {\n            importanceSample = getImportanceSampleGGX(i, N, get_roughness(materialSID, 0), materialSID);\n        }\n\n        let H = vec3f(importanceSample.xyz);\n        let pdf = importanceSample.w;\n        let lod = computeLod(pdf, texSize.x, sampleCount);\n\n        if(distributionType == cLambertian)\n        {\n            let lambertian = textureSampleLevel(baseColorTexture, baseColorSampler, H, lod).rgb;\n            color += lambertian;\n        }\n        else if(distributionType == cGGX)\n        {\n            let V = N;\n            let L = normalize(reflect(-V, H));\n            let NdotL = dot(N, L);\n\n            if (NdotL > 0.0)\n            {\n                let sampleColor = textureSampleLevel(baseColorTexture, baseColorSampler, L, lod).rgb;\n                color += sampleColor * NdotL;\n                weight += NdotL;\n            }\n        }\n    }\n\n    if(weight != 0.0f)\n    {\n        color /= weight;\n    }\n    else\n    {\n        color /= f32(sampleCount);\n    }\n\n    return color.rgb;\n}\n\nfn uvToDir(faceId: i32, uv: vec2f) -> vec3f\n{\n	if (faceId == 0) {\n		return vec3f(1.f, uv.y, -uv.x);\n  } else if(faceId == 1) {\n		return vec3f(-1.f, uv.y, uv.x);\n  } else if(faceId == 2) {\n		return vec3f(uv.x, -1.f, uv.y);\n  } else if(faceId == 3) {\n		return vec3f(uv.x, 1.f, -uv.y);\n  } else if(faceId == 4) {\n		return vec3f(uv.x, uv.y, 1.f);\n  } else {\n    return vec3f(-uv.x, uv.y, -1.f);\n  }\n}\n\n// learned a lot from https://github.com/KhronosGroup/glTF-Sample-Viewer\n@fragment\nfn main (\n  input: VertexOutput,\n) -> @location(0) vec4<f32> {\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  let uv = input.texcoord_0 * 2.0 - 1.0;\n  let scan = uvToDir(get_cubeMapFaceId(materialSID, 0), uv);\n  var direction = normalize(scan);\n  direction.y = -direction.y;\n\n  let rt0 = vec4f(prefilter(direction, materialSID), 1.0);\n\n  return rt0;\n}\n", shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/MToon1SingleShader/MToon1SingleShader.vert.glsl
var MToon1SingleShader_vert_default;
var init_MToon1SingleShader_vert = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/MToon1SingleShader/MToon1SingleShader.vert.glsl"() {
    MToon1SingleShader_vert_default = { code: '\n#ifdef WEBGL2_MULTI_VIEW\n#extension GL_OVR_multiview2 : require\n#endif\n\nprecision highp float;\nprecision highp int;\n\n\n/* shaderity: @{definitions} */\n\nin vec4 a_instanceInfo;\nin vec2 a_texcoord_0;\nin vec2 a_texcoord_1;\nin vec2 a_texcoord_2;\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_baryCentricCoord;\nin vec4 a_joint;\nin vec4 a_weight;\n\nout vec2 v_texcoord_0;\nout vec2 v_texcoord_1;\nout vec2 v_texcoord_2;\nout vec3 v_baryCentricCoord;\nout vec3 v_normal_inView;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout float v_instanceInfo;\n\n#ifdef RN_USE_TANGENT\nin vec4 a_tangent;\nout vec3 v_tangent_inWorld;\nout vec3 v_binormal_inWorld; // bitangent_inWorld\n#endif\n\nconst float Epsilon = 0.0000001;\n#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)\n\n#ifdef RN_IS_MORPHING\nuniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true\n// uniform int u_dataTextureMorphOffsetPosition[];\n// uniform int u_morphWeights[]; //\n#endif\n\nuniform int u_isMainVr; // skipProcess=true\nuniform highp sampler2D u_dataTexture; // skipProcess=true\n/* shaderity: @{widthOfDataTexture} */\n/* shaderity: @{heightOfDataTexture} */\n\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n/* shaderity: @{dataUBOVec4Size} */\n/* shaderity: @{dataUBODefinition} */\n#endif\n\n\nhighp vec4 fetchElement(int vec4_idx) {\n#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)\n  if (vec4_idx < dataUBOVec4Size) {\n    return fetchVec4FromVec4Block(vec4_idx);\n  } else {\n    int idxOnDataTex = vec4_idx - dataUBOVec4Size;\n    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);\n    return texelFetch( u_dataTexture, uv, 0 );\n  }\n#elif defined(GLSL_ES3)\n  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);\n  return texelFetch( u_dataTexture, uv, 0 );\n#else\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  #ifdef GLSL_ES3\n  return texture( u_dataTexture, vec2(x, y));\n  #else\n  return texture( u_dataTexture, vec2(x, y));\n  #endif\n#endif\n}\n\nvec2 fetchVec2No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xy;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec2(val0.yz);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.zw);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec2(val0.w, val1.x);\n  }\n}\n\nvec3 fetchVec3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    return vec3(val0.yzw);\n  } else if (posIn4bytes == 2) {\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    vec4 val0 = fetchElement(basePosIn16bytes);\n    vec4 val1 = fetchElement(basePosIn16bytes+1);\n    return vec3(val0.w, val1.xy);\n  }\n}\n\nvec4 fetchVec4(int vec4_idx) {\n  return fetchElement(vec4_idx);\n}\n\nfloat fetchScalarNo16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  vec4 val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0) {\n    return val.x;\n  } else if (posIn4bytes == 1) {\n    return val.y;\n  } else if (posIn4bytes == 2) {\n    return val.z;\n  } else if (posIn4bytes == 3) {\n    return val.w;\n  }\n}\n\nmat2 fetchMat2No16BytesAligned(int scalar_idx) {\n  int vec4_idx = scalar_idx*4;\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat2 fetchMat2(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n\n  mat2 val = mat2(\n    col0.x, col0.y,\n    col0.z, col0.w\n    );\n\n  return val;\n}\n\nmat3 fetchMat3No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    mat3 val = mat3(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n\n}\n\nmat3 fetchMat3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat3 val = mat3(\n    col0.x, col0.y, col0.z,\n    col0.w, col1.x, col1.y,\n    col1.z, col1.w, col2.x\n    );\n\n  return val;\n}\n\nmat4 fetchMat4No16BytesAligned(int scalar_idx) {\n#ifdef GLSL_ES3\n  int posIn4bytes = scalar_idx % 4;\n#else\n  int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n#endif\n\n  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;\n  if (posIn4bytes == 0) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    mat4 val = mat4(\n      col0.x, col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z, col2.w,\n      col3.x, col3.y, col3.z, col3.w\n      );\n    return val;\n  } else if (posIn4bytes == 1) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.y, col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w, col3.x,\n      col3.y, col3.z, col3.w, col4.x\n      );\n    return val;\n  } else if (posIn4bytes == 2) {\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.z, col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x, col2.y,\n      col2.z, col2.w, col3.x, col3.y,\n      col3.z, col3.w, col4.x, col4.y\n      );\n    return val;\n  } else { // posIn4bytes == 3\n    vec4 col0 = fetchElement(basePosIn16bytes);\n    vec4 col1 = fetchElement(basePosIn16bytes + 1);\n    vec4 col2 = fetchElement(basePosIn16bytes + 2);\n    vec4 col3 = fetchElement(basePosIn16bytes + 3);\n    vec4 col4 = fetchElement(basePosIn16bytes + 4);\n    mat4 val = mat4(\n      col0.w, col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y, col2.z,\n      col2.w, col3.x, col3.y, col3.z,\n      col3.w, col4.x, col4.y, col4.z\n      );\n    return val;\n  }\n}\n\nmat4 fetchMat4(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n  vec4 col3 = fetchElement(vec4_idx + 3);\n\n  mat4 val = mat4(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\nmat4x3 fetchMat4x3(int vec4_idx) {\n  vec4 col0 = fetchElement(vec4_idx);\n  vec4 col1 = fetchElement(vec4_idx + 1);\n  vec4 col2 = fetchElement(vec4_idx + 2);\n\n  mat4x3 val = mat4x3(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n  return val;\n}\n\nfloat rand(const vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 descramble(vec3 v) {\n  float seed = 0.0;\n  v.x -= sin(fract(v.y*20.0));\n  v.z -= cos(fract(-v.y*10.0));\n  return v;\n}\n\nconst float PI = 3.14159265358979323846;\nconst float RECIPROCAL_PI = 0.3183098861837907;\n\nfloat max3(vec3 v)\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sq(float t)\n{\n  return t * t;\n}\n\nvec2 sq(vec2 t)\n{\n  return t * t;\n}\n\nvec3 sq(vec3 t)\n{\n  return t * t;\n}\n\nvec4 sq(vec4 t)\n{\n  return t * t;\n}\n\nfloat saturate(float t)\n{\n  return clamp(t, 0.0, 1.0);\n}\n\n\n/* shaderity: @{getters} */\n\n/* shaderity: @{matricesGetters} */\n\nmat3 toNormalMatrix(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n  a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n  a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n  a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n\n  float b00 = a00 * a11 - a01 * a10,\n  b01 = a00 * a12 - a02 * a10,\n  b02 = a00 * a13 - a03 * a10,\n  b03 = a01 * a12 - a02 * a11,\n  b04 = a01 * a13 - a03 * a11,\n  b05 = a02 * a13 - a03 * a12,\n  b06 = a20 * a31 - a21 * a30,\n  b07 = a20 * a32 - a22 * a30,\n  b08 = a20 * a33 - a23 * a30,\n  b09 = a21 * a32 - a22 * a31,\n  b10 = a21 * a33 - a23 * a31,\n  b11 = a22 * a33 - a23 * a32;\n\n  float determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3(\n    a11 * b11 - a12 * b10 + a13 * b09, a12 * b08 - a10 * b11 - a13 * b07, a10 * b10 - a11 * b08 + a13 * b06,\n    a02 * b10 - a01 * b11 - a03 * b09, a00 * b11 - a02 * b08 + a03 * b07, a01 * b08 - a00 * b10 - a03 * b06,\n    a31 * b05 - a32 * b04 + a33 * b03, a32 * b02 - a30 * b05 - a33 * b01, a30 * b04 - a31 * b02 + a33 * b00) / determinantVal;\n}\n\n\n\n#ifdef RN_IS_SKINNING\n\nhighp mat4 createMatrixFromQuaternionTranslationScale( highp vec4 quaternion, highp vec3 translation, highp vec3 scale ) {\n  highp vec4 q = quaternion;\n  highp vec3 t = translation;\n\n  highp float sx = q.x * q.x;\n  highp float sy = q.y * q.y;\n  highp float sz = q.z * q.z;\n  highp float cx = q.y * q.z;\n  highp float cy = q.x * q.z;\n  highp float cz = q.x * q.y;\n  highp float wx = q.w * q.x;\n  highp float wy = q.w * q.y;\n  highp float wz = q.w * q.z;\n\n  highp mat4 mat = mat4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  highp mat4 uniformScaleMat = mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  return mat*uniformScaleMat;\n}\n\nhighp vec4 unpackedVec2ToNormalizedVec4(highp vec2 vec_xy, highp float criteria){\n\n  highp float r;\n  highp float g;\n  highp float b;\n  highp float a;\n\n  highp float ix = floor(vec_xy.x * criteria);\n  highp float v1x = ix / criteria;\n  highp float v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  highp float iy = floor( vec_xy.y * criteria);\n  highp float v2x = iy / criteria;\n  highp float v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4(r, g, b, a);\n}\n\nmat4 getSkinMatrix(float skeletalComponentSID) {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  mat4 skinMat = a_weight.x * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.x)));\n  skinMat += a_weight.y * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.y)));\n  skinMat += a_weight.z * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.z)));\n  skinMat += a_weight.w * mat4(get_boneMatrix(skeletalComponentSID, int(a_joint.w)));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  vec2 criteria = vec2(4096.0, 4096.0);\n\n  vec4 tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 sq_x = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.x));\n  vec4 quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  vec4 tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.y));\n  vec4 sq_y = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.y));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  vec4 tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.z));\n  vec4 sq_z = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.z));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  vec4 tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, int(a_joint.w));\n  vec4 sq_w = get_boneScalePackedQuat(skeletalComponentSID, int(a_joint.w));\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  vec4 ts_x = get_boneTranslateScale(skeletalComponentSID, int(a_joint.x));\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.x)), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = get_boneTranslateScale(skeletalComponentSID, int(a_joint.y));\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.y)), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = get_boneTranslateScale(skeletalComponentSID, int(a_joint.z));\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.z)), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = get_boneTranslateScale(skeletalComponentSID, int(a_joint.w));\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, int(a_joint.w)), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  vec4 boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.x));\n  vec4 boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.y));\n  vec4 boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.z));\n  vec4 boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, int(a_joint.w));\n\n  vec2 criteria = vec2(4096.0, 4096.0);\n  vec4 boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  vec4 ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  mat4 skinMat = a_weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  vec4 ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  vec4 ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  vec4 ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += a_weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\n\n\n#ifdef RN_IS_SKINNING\nbool skinning(\n  float skeletalComponentSID,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n  )\n{\n  mat4 skinMat = getSkinMatrix(skeletalComponentSID);\n  outPosition_inWorld = skinMat * vec4(inPosition_inLocal, 1.0);\n  outNormalMatrix = toNormalMatrix(skinMat);\n  outNormal_inWorld = normalize(outNormalMatrix * inNormal_inLocal);\n\n  return true;\n}\n#endif\n\nbool processGeometryWithMorphingAndSkinning(\n  float skeletalComponentSID,\n  in mat4 worldMatrix,\n  in mat4 viewMatrix,\n  in bool isBillboard,\n  in mat3 inNormalMatrix,\n  out mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  bool isSkinning = false;\n\n  vec3 position_inLocal;\n#ifdef RN_IS_MORPHING\n  if (u_morphTargetNumber == 0) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    float vertexIdx = a_baryCentricCoord.w;\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n  }\n#endif\n\n  mat4 worldMatrixInner = worldMatrix;\n  if (isBillboard) {\n    mat4 inverseViewMatrix = inverse(viewMatrix);\n    inverseViewMatrix[3][0] = 0.0;//worldMatrix[3][0];\n    inverseViewMatrix[3][1] = 0.0;//worldMatrix[3][1];\n    inverseViewMatrix[3][2] = 0.0;//worldMatrix[3][2];\n    worldMatrixInner = inverseViewMatrix * worldMatrix;\n  }\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0.0) {\n    isSkinning = skinning(skeletalComponentSID, inNormalMatrix, outNormalMatrix, position_inLocal, outPosition_inWorld, inNormal_inLocal, outNormal_inWorld);\n  } else {\n#endif\n    outNormalMatrix = inNormalMatrix;\n    outPosition_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return isSkinning;\n}\n\n\nuniform int u_outlineWidthMode; // initialValue=0\nuniform float u_outlineWidthFactor; // initialValue=0.0008\nuniform sampler2D u_outlineWidthMultiplyTexture; // initialValue=(0,white)\n\nvoid main(){\n\n#ifdef RN_IS_DATATEXTURE_MODE\n  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    #ifdef RN_IS_VERTEX_SHADER\n      skeletalComponentSID = a_instanceInfo.y;\n    #else\n      skeletalComponentSID = -1.0;\n    #endif\n  #endif\n\n#else // RN_IS_UNIFORM_MODE\n\n  float materialSID = -1.0; // materialSID is not used in Uniform mode\n\n  int lightNumber = 0;\n  #ifdef RN_IS_LIGHTING\n    lightNumber = get_lightNumber(0.0, 0);\n  #endif\n\n  float skeletalComponentSID = -1.0;\n  #ifdef RN_IS_SKINNING\n    skeletalComponentSID = float(get_skinningMode(0.0, 0));\n  #endif\n\n#endif\n\nfloat cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];\n\n#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)\n// if (u_isMainVr == 1) {\n  cameraSID += float(gl_ViewID_OVR);\n// }\n#endif\n\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceInfo.x);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceInfo.x);\n  bool isSkinning = false;\n  isSkinning = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n\n  v_normal_inView = vec3(viewMatrix * vec4(v_normal_inWorld, 0.0));\n\n#ifdef RN_MTOON_IS_OUTLINE\n  int outlineWidthType = get_outlineWidthMode(materialSID, 0);\n  if (outlineWidthType == 0) { // 0 ("none")\n    gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n  } else {\n    float worldNormalLength = length(normalMatrix * a_normal);\n    float outlineWidthFactor = get_outlineWidthFactor(materialSID, 0);\n    vec3 outlineOffset = outlineWidthFactor * worldNormalLength * v_normal_inWorld;\n\n    float outlineWidthMultiply = texture(u_outlineWidthMultiplyTexture, a_texcoord_0).g;\n    outlineOffset *= outlineWidthMultiply;\n\n    if (outlineWidthType == 2) { // "screenCoordinates"\n      vec4 vViewPosition = viewMatrix * v_position_inWorld;\n      outlineOffset *= abs(vViewPosition.z) / projectionMatrix[1].y;\n    }\n    gl_Position = projectionMatrix * viewMatrix * vec4(v_position_inWorld.xyz + outlineOffset, 1.0);\n    gl_Position.z += 0.000001 * gl_Position.w;\n  }\n#else\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n#endif\n\n#ifdef RN_USE_TANGENT\n  v_tangent_inWorld = normalMatrix * a_tangent.xyz;\n  v_binormal_inWorld = cross(v_normal_inWorld, v_tangent_inWorld) * a_tangent.w;\n#endif\n\n  v_texcoord_0 = a_texcoord_0;\n  v_texcoord_1 = a_texcoord_1;\n  v_texcoord_2 = a_texcoord_2;\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n  v_instanceInfo = a_instanceInfo.x;\n}\n', shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/MToon1SingleShader/MToon1SingleShader.frag.glsl
var MToon1SingleShader_frag_default;
var init_MToon1SingleShader_frag = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/MToon1SingleShader/MToon1SingleShader.frag.glsl"() {
    MToon1SingleShader_frag_default = { code: `
#ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
#extension GL_EXT_shader_texture_lod : require
#endif

#ifdef WEBGL1_EXT_STANDARD_DERIVATIVES
#extension GL_OES_standard_derivatives : require
#endif

#ifdef WEBGL1_EXT_DRAW_BUFFERS
#extension GL_EXT_draw_buffers : require
#endif

precision highp float;
precision highp int;


/* shaderity: @{definitions} */

const float Epsilon = 0.0000001;
#define saturateEpsilonToOne(x) clamp(x, Epsilon, 1.0)

#ifdef RN_IS_MORPHING
uniform int u_morphTargetNumber; // initialValue=0, isInternalSetting=true, soloDatum=false, needUniformInDataTextureMode=true
// uniform int u_dataTextureMorphOffsetPosition[];
// uniform int u_morphWeights[]; //
#endif

uniform int u_isMainVr; // skipProcess=true
uniform highp sampler2D u_dataTexture; // skipProcess=true
/* shaderity: @{widthOfDataTexture} */
/* shaderity: @{heightOfDataTexture} */

#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
/* shaderity: @{dataUBOVec4Size} */
/* shaderity: @{dataUBODefinition} */
#endif


highp vec4 fetchElement(int vec4_idx) {
#if defined(GLSL_ES3) && defined(RN_IS_DATATEXTURE_MODE) && defined(RN_IS_UBO_ENABLED)
  if (vec4_idx < dataUBOVec4Size) {
    return fetchVec4FromVec4Block(vec4_idx);
  } else {
    int idxOnDataTex = vec4_idx - dataUBOVec4Size;
    highp ivec2 uv = ivec2(idxOnDataTex % widthOfDataTexture, idxOnDataTex / widthOfDataTexture);
    return texelFetch( u_dataTexture, uv, 0 );
  }
#elif defined(GLSL_ES3)
  highp ivec2 uv = ivec2(vec4_idx % widthOfDataTexture, vec4_idx / widthOfDataTexture);
  return texelFetch( u_dataTexture, uv, 0 );
#else
  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885
  highp vec2 invSize = vec2(1.0/float(widthOfDataTexture), 1.0/float(heightOfDataTexture));
  highp float t = (float(vec4_idx) + 0.5) * invSize.x;
  highp float x = fract(t);
  highp float y = (floor(t) + 0.5) * invSize.y;
  #ifdef GLSL_ES3
  return texture( u_dataTexture, vec2(x, y));
  #else
  return texture( u_dataTexture, vec2(x, y));
  #endif
#endif
}

vec2 fetchVec2No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xy;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec2(val0.yz);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.zw);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec2(val0.w, val1.x);
  }
}

vec3 fetchVec3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    return vec3(val0.yzw);
  } else if (posIn4bytes == 2) {
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    vec4 val0 = fetchElement(basePosIn16bytes);
    vec4 val1 = fetchElement(basePosIn16bytes+1);
    return vec3(val0.w, val1.xy);
  }
}

vec4 fetchVec4(int vec4_idx) {
  return fetchElement(vec4_idx);
}

float fetchScalarNo16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif
  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  vec4 val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0) {
    return val.x;
  } else if (posIn4bytes == 1) {
    return val.y;
  } else if (posIn4bytes == 2) {
    return val.z;
  } else if (posIn4bytes == 3) {
    return val.w;
  }
}

mat2 fetchMat2No16BytesAligned(int scalar_idx) {
  int vec4_idx = scalar_idx*4;
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat2 fetchMat2(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);

  mat2 val = mat2(
    col0.x, col0.y,
    col0.z, col0.w
    );

  return val;
}

mat3 fetchMat3No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    mat3 val = mat3(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }

}

mat3 fetchMat3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat3 val = mat3(
    col0.x, col0.y, col0.z,
    col0.w, col1.x, col1.y,
    col1.z, col1.w, col2.x
    );

  return val;
}

mat4 fetchMat4No16BytesAligned(int scalar_idx) {
#ifdef GLSL_ES3
  int posIn4bytes = scalar_idx % 4;
#else
  int posIn4bytes = int(mod(float(scalar_idx), 4.0));
#endif

  int basePosIn16bytes = (scalar_idx - posIn4bytes) / 4;
  if (posIn4bytes == 0) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    mat4 val = mat4(
      col0.x, col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z, col2.w,
      col3.x, col3.y, col3.z, col3.w
      );
    return val;
  } else if (posIn4bytes == 1) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.y, col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w, col3.x,
      col3.y, col3.z, col3.w, col4.x
      );
    return val;
  } else if (posIn4bytes == 2) {
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.z, col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x, col2.y,
      col2.z, col2.w, col3.x, col3.y,
      col3.z, col3.w, col4.x, col4.y
      );
    return val;
  } else { // posIn4bytes == 3
    vec4 col0 = fetchElement(basePosIn16bytes);
    vec4 col1 = fetchElement(basePosIn16bytes + 1);
    vec4 col2 = fetchElement(basePosIn16bytes + 2);
    vec4 col3 = fetchElement(basePosIn16bytes + 3);
    vec4 col4 = fetchElement(basePosIn16bytes + 4);
    mat4 val = mat4(
      col0.w, col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y, col2.z,
      col2.w, col3.x, col3.y, col3.z,
      col3.w, col4.x, col4.y, col4.z
      );
    return val;
  }
}

mat4 fetchMat4(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);
  vec4 col3 = fetchElement(vec4_idx + 3);

  mat4 val = mat4(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}

mat4x3 fetchMat4x3(int vec4_idx) {
  vec4 col0 = fetchElement(vec4_idx);
  vec4 col1 = fetchElement(vec4_idx + 1);
  vec4 col2 = fetchElement(vec4_idx + 2);

  mat4x3 val = mat4x3(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);
  return val;
}

float rand(const vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 descramble(vec3 v) {
  float seed = 0.0;
  v.x -= sin(fract(v.y*20.0));
  v.z -= cos(fract(-v.y*10.0));
  return v;
}

const float PI = 3.14159265358979323846;
const float RECIPROCAL_PI = 0.3183098861837907;

float max3(vec3 v)
{
  return max(max(v.x, v.y), v.z);
}

float sq(float t)
{
  return t * t;
}

vec2 sq(vec2 t)
{
  return t * t;
}

vec3 sq(vec3 t)
{
  return t * t;
}

vec4 sq(vec4 t)
{
  return t * t;
}

float saturate(float t)
{
  return clamp(t, 0.0, 1.0);
}


in vec2 v_texcoord_0;
in vec2 v_texcoord_1;
in vec2 v_texcoord_2;
in vec3 v_baryCentricCoord;
in vec3 v_normal_inView;
in vec3 v_normal_inWorld;
in vec4 v_position_inWorld;
in float v_instanceInfo;
#ifdef RN_USE_TANGENT
  in vec3 v_tangent_inWorld;
  in vec3 v_binormal_inWorld; // bitangent_inWorld
#endif

/* shaderity: @{renderTargetBegin} */


/* shaderity: @{getters} */

struct Light {
  int type; // 0 = directional, 1 = point, 2 = spot
  vec3 position;
  vec3 intensity;
  vec3 attenuatedIntensity;
  vec3 directionOfLightObject;
  vec3 direction; // direction of light vector, equal to normalize(light.pointToLight)
  vec3 pointToLight; // not normalized
  float spotAngleScale;
  float spotAngleOffset;
  float effectiveRange;
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
float getRangeAttenuation(Light light)
{
  float distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
float getSpotAttenuation(Light light)
{

  float cd = dot(light.directionOfLightObject, light.direction);
  float angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);
  return angularAttenuation;
}

void getLightAttenuated(Light light) {
  light.attenuatedIntensity = light.intensity;
  // if (light.type == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light
  if (light.type == 1)
  {
    light.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot light
  if (light.type == 2)
  {
    light.attenuatedIntensity *= getSpotAttenuation(light);
  }
}

Light getLight(int lightIdx, vec3 v_position_inWorld) {
  vec3 lightPosition = get_lightPosition(0.0, lightIdx);
  vec3 direction_and_w_of_LightObject = get_lightDirection(0.0, lightIdx);
  vec3 lightIntensity = get_lightIntensity(0.0, lightIdx);
  vec4 lightProperty = get_lightProperty(0.0, lightIdx);
  Light light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  float lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.spotAngleScale = lightProperty.z;
  light.spotAngleOffset = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3(0.0);
    light.type = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.type = 1;
  } else { // is Directional Light
    light.type = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.type = 2;
  }

  const float M_PI = 3.141592653589793;
  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  getLightAttenuated(light);

  return light;
}

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

float angular_n_h(float NH) {
  return acos(NH);
}

float d_phong(float NH, float c1) {
  return pow(
    cos(acos(NH))
    , c1
  );
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec2 envBRDFApprox( float Roughness, float NoV ) {
  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022 );
  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04 );
  vec4 r = Roughness * c0 + c1;
  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}

// GGX NDF
float d_GGX(float NH, float alphaRoughness) {
  float roughnessSqr = alphaRoughness * alphaRoughness;
  float f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

float d_torrance_reiz(float NH, float c3) {
  float CosSquared = NH*NH;
  float TanSquared = (1.0 - CosSquared)/CosSquared;
  //return (1.0/M_PI) * sq(c3/(CosSquared * (c3*c3 + TanSquared)));  // gamma = 2, aka GGX
  return (1.0/sqrt(M_PI)) * (sq(c3)/(CosSquared * (c3*c3 + TanSquared))); // gamma = 1, D_Berry
}

float d_beckmann(float NH, float m) {
  float co = 1.0 / (4.0 * m * m * NH * NH * NH * NH);
  float expx = exp((NH * NH - 1.0) / (m * m * NH * NH));
  return co * expx;
}

// the same as glTF WebGL sample
// https://github.com/KhronosGroup/glTF-WebGL-PBR/blob/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders/pbr-frag.glsl#L188
// That is, Unreal Engine based approach, but modified to use alphaRoughness (squared artist's roughness parameter),
// and based on 'Separable Masking and Shadowing' approximation (propesed by Christophe Schlick)
// https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf
float g_shielding(float NL, float NV, float alphaRoughness) {
  float r = alphaRoughness;

  // Local Shadowing using "Schlick-Smith" Masking Function
  float localShadowing = 2.0 * NL / (NL + sqrt(r * r + (1.0 - r * r) * (NL * NL)));

  // Local Masking using "Schlick-Smith" Masking Function
  float localMasking = 2.0 * NV / (NV + sqrt(r * r + (1.0 - r * r) * (NV * NV)));

  return localShadowing * localMasking;
}

// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
float v_GGXCorrelated(float NL, float NV, float alphaRoughness) {
  float a2 = alphaRoughness * alphaRoughness;
  float GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  float GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  return 0.5 / (GGXV + GGXL);
}

float v_GGXCorrelatedFast(float NL, float NV, float alphaRoughness) {
  float a = alphaRoughness;
  float GGXV = NL * (NV * (1.0 - a) + a);
  float GGXL = NV * (NL * (1.0 - a) + a);
  return 0.5 / (GGXV + GGXL);
}

// The Schlick Approximation to Fresnel
float fresnel(float f0, float f90, float VdotH) {
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

vec3 fresnel(vec3 f0, vec3 f90, float VdotH) {
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

vec3 fresnel(vec3 f0, float f90, float VdotH)
{
  float x = clamp(1.0 - VdotH, 0.0, 1.0);
  float x2 = x * x;
  float x5 = x * x2 * x2;
  return f0 + (f90 - f0) * x5;
}

float fresnel(float f0, float VdotH)
{
  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnel(f0, f90, VdotH);
}
vec3 fresnel(vec3 f0, float VdotH)
{
  float f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnel(f0, f90, VdotH);
}

vec3 cook_torrance_specular_brdf(float NH, float NL, float NV, vec3 F, float alphaRoughness, float specularWeight) {
  float D = d_GGX(NH, alphaRoughness);
  float V = v_GGXCorrelated(NL, NV, alphaRoughness);
  return vec3(D) * vec3(V) * F * specularWeight;
//      float G = g_shielding(NL, NV, alphaRoughness);
//      return vec3(D)*vec3(G)*F/vec3(4.0*NL*NV);

}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf
vec3 BRDF_lambertian(vec3 albedo, vec3 F, float specularWeight)
{
  // (1/pi) * diffuseAlbedo
  return (vec3(1.0) - specularWeight * F) * albedo * RECIPROCAL_PI;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#specular-brdf
float specular_brdf(float alphaRoughness, float NdotL, float NdotV, float NdotH) {
  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  float D = d_GGX(NdotH, alphaRoughness);
  return V * D;
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes
float specular_btdf(float alphaRoughness, float NdotL, float NdotV, float NdotHt) {
  float V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  float D = d_GGX(NdotHt, alphaRoughness);
  return V * D;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel
vec3 conductor_fresnel(vec3 f0, float brdf, float alphaRoughness, float VdotH) {
  return vec3(brdf) * (f0.rgb + (vec3(1.0) - f0.rgb) * vec3(pow(1.0 - abs(VdotH), 5.0)));
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#fresnel
vec3 fresnel_mix(float ior, vec3 base, vec3 layer, float VdotH) {
  float f0 = pow((1.0 - ior)/(1.0 + ior), 2.0);
  float fr = f0 + (1.0 - f0) * pow(1.0 - abs(VdotH), 5.0);
  return mix(base, layer, fr);
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf
vec3 metal_brdf(float perceptualRoughness, vec3 baseColor, float NdotL, float NdotV, float NdotH, float VdotH) {
  float alphaRoughness = perceptualRoughness * perceptualRoughness;
  return conductor_fresnel(
    baseColor,
    specular_brdf(alphaRoughness, NdotL, NdotV, NdotH),
    alphaRoughness,
    VdotH
  );
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#metal-brdf-and-dielectric-brdf
// vec3 dielectric_brdf(float ior, vec3 baseColor, float perceptualRoughness, float NdotL, float NdotV, float NdotH, float VdotH) {
//   vec3 base = BRDF_lambertian(baseColor);
//   float alphaRoughness = perceptualRoughness * perceptualRoughness;
//   vec3 layer = vec3(specular_brdf(alphaRoughness, NdotL, NdotV, NdotH));
//   return fresnel_mix(ior, base, layer, VdotH);
// }

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering
vec3 coated_material_s(vec3 base, float perceptualRoughness, float clearcoatRoughness, float clearcoat, float VdotNc, float LdotNc, float NdotHc) {
  float clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);
  float clearcoatAlpha = clearcoatRoughness * clearcoatRoughness;
  float alphaRoughness = perceptualRoughness * perceptualRoughness;
  float D = d_GGX(NdotHc, clearcoatAlpha);
  float V = v_GGXCorrelated(LdotNc, VdotNc, clearcoatAlpha);
  float f_clearcoat = clearcoatFresnel * D * V;

  // base = (f_diffuse + f_specular) in https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering
  return base * vec3(1.0 - clearcoat * clearcoatFresnel) + vec3(f_clearcoat * clearcoat);
}
vec3 srgbToLinear(vec3 srgbColor) {
  return pow(srgbColor, vec3(2.2));
}

float srgbToLinear(float value) {
  return pow(value, 2.2);
}

vec3 linearToSrgb(vec3 linearColor) {
  return pow(linearColor, vec3(1.0/2.2));
}

float linearToSrgb(float value) {
  return pow(value, 1.0/2.2);
}

// Roughness Dependent Fresnel
// https://www.jcgt.org/published/0008/01/03/paper.pdf
vec3 fresnelSchlickRoughness(vec3 F0, float cosTheta, float roughness)
{
  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;
  vec3 k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);
  return k_S;
}

// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66
vec3 Schlick_to_F0(vec3 f, vec3 f90, float VdotH) {
    float x = clamp(1.0 - VdotH, 0.0, 1.0);
    float x2 = x * x;
    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

float Schlick_to_F0(float f, float f90, float VdotH) {
    float x = clamp(1.0 - VdotH, 0.0, 1.0);
    float x2 = x * x;
    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

vec3 Schlick_to_F0(vec3 f, float VdotH) {
    return Schlick_to_F0(f, vec3(1.0), VdotH);
}

float Schlick_to_F0(float f, float VdotH) {
    return Schlick_to_F0(f, 1.0, VdotH);
}

vec3 normalBlendingUDN(sampler2D baseMap, sampler2D detailMap, vec2 baseUv, vec2 detailUv) {
  vec3 t = texture(baseMap,   baseUv).xyz * 2.0 - 1.0;
  vec3 u = texture(detailMap, detailUv).xyz * 2.0 - 1.0;
  vec3 r = normalize(vec3(t.xy + u.xy, t.z));
  return r;
}

vec2 uvTransform(vec2 scale, vec2 offset, float rotation, vec2 uv) {
  mat3 translationMat = mat3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  mat3 rotationMat = mat3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  mat3 scaleMat = mat3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  mat3 matrix = translationMat * rotationMat * scaleMat;
  vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;

  return uvTransformed;
}

float IsotropicNDFFiltering(vec3 normal, float roughness2) {
  float SIGMA2 = 0.15915494;
  float KAPPA = 0.18;
  vec3 dndu = dFdx(normal);
  vec3 dndv = dFdy(normal);
  float kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));
  float clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);
  float filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);
  return filteredRoughness2;
}


////////////////////////////////////////
// glTF KHR_materials_volume
////////////////////////////////////////

#ifdef RN_USE_VOLUME
// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
vec3 volumeAttenuation(vec3 attenuationColor, float attenuationDistance, vec3 intensity, float transmissionDistance)
{
  if (attenuationDistance == 0.0) { // means Infinite distance
    return intensity; // No attenuation
  } else {
    vec3 attenuationCo = -log(attenuationColor) / attenuationDistance;
    vec3 attenuatedTransmittance = exp(-attenuationCo * transmissionDistance);
    return intensity * attenuatedTransmittance;
  }
}
#endif






////////////////////////////////////////
// glTF KHR_materials_anisotropy
////////////////////////////////////////
#ifdef RN_USE_ANISOTROPY
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
float D_GGX_anisotropic(float NdotH, float TdotH, float BdotH, float at, float ab)
{
    float a2 = at * ab;
    vec3 f = vec3(ab * TdotH, at * BdotH, a2 * NdotH);
    float w2 = a2 / dot(f, f);
    return a2 * w2 * w2 / M_PI;
}

float V_GGX_anisotropic(float NdotL, float NdotV, float BdotV, float TdotV, float TdotL, float BdotL,
    float at, float ab)
{
    float GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));
    float GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));
    float v = 0.5 / (GGXV + GGXL);
    return clamp(v, 0.0, 1.0);
}

vec3 BRDF_specularAnisotropicGGX(vec3 F, float alphaRoughness,
    float VdotH, float NdotL, float NdotV, float NdotH, float BdotV, float TdotV,
    float TdotL, float BdotL, float TdotH, float BdotH, float anisotropy)
{
    float at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
    float ab = alphaRoughness;

    float V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);
    float D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);

    return F * V * D;
}
#endif



////////////////////////////////////////
// glTF KHR_materials_sheen
////////////////////////////////////////

#ifdef RN_USE_SHEEN
float d_Charlie(float sheenPerceptualRoughness, float NoH) {
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  float alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;
  float invAlpha  = 1.0 / alphaG;
  float cos2h = NoH * NoH;
  float sin2h = 1.0 - cos2h;
  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
float sheenSimpleVisibility(float NdotL, float NdotV) {
  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
float charlieL(float x, float alphaG) {
  float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
  float a = mix(21.5473, 25.3245, oneMinusAlphaSq);
  float b = mix(3.82987, 3.32435, oneMinusAlphaSq);
  float c = mix(0.19823, 0.16801, oneMinusAlphaSq);
  float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
  float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
  return a / (1.0 + b * pow(x, c)) + d * x + e;
}

float lambdaSheen(float cosTheta, float alphaG)
{
  return abs(cosTheta) < 0.5 ? exp(charlieL(cosTheta, alphaG)) : exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG));
}

float sheenCharlieVisibility(float NdotL, float NdotV, float sheenPerceptualRoughness) {
  float alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;
  float sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));
  return sheenVisibility;
}

vec3 sheen_brdf(vec3 sheenColor, float sheenPerceptualRoughness, float NdotL, float NdotV, float NdotH) {
  float sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);
  float sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);
  return sheenColor * sheenDistribution * sheenVisibility;
}
#endif









////////////////////////////////////////
// glTF KHR_materials_irirdescence
////////////////////////////////////////

#ifdef RN_USE_IRIDESCENCE
// XYZ to REC709(sRGB) conversion matrix
const mat3 XYZ_TO_REC709 = mat3(
     3.2404542, -0.9692660,  0.0556434,
    -1.5371385,  1.8760108, -0.2040259,
    -0.4985314,  0.0415560,  1.0572252
);

vec3 fresnelSchlickRoughnessWithIridescence(
  vec3 F0, float cosTheta, float roughness,
  vec3 iridescenceFresnel, float iridescence
  )
{
  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;
  vec3 k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);
  return k_S;
}

// Assume air interface for top
vec3 Fresnel0ToIor(vec3 F0) {
    vec3 sqrtF0 = sqrt(F0);
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// Conversion from IOR to F0
// ior is a value between 1.0 and 3.0. 1.0 is air interface
vec3 IorToFresnel0(vec3 transmittedIor, float incidentIor) {
    return sq((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
float IorToFresnel0(float transmittedIor, float incidentIor) {
    return sq((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration
 */
vec3 evalSensitivity(float OPD, vec3 shift) {
    float phase = 2.0 * M_PI * OPD * 1.0e-9;
    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);

    vec3 xyz = val * sqrt(2.0 * M_PI * var) * cos(pos * phase + shift) * exp(-(phase * phase) * var);
    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));
    xyz /= 1.0685e-7;

    vec3 rgb = XYZ_TO_REC709 * xyz;
    return rgb;
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel
 */
vec3 calcIridescence(float outsideIor, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {


  // iridescenceIor is the index of refraction of the thin-film layer
  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
  float iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));

  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)
  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.
  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.
  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):
  float sinTheta2Sq = sq(outsideIor / iridescenceIor) * (1.0 - sq(cosTheta1));
  float cosTheta2Sq = 1.0 - sinTheta2Sq;

  // Handle total internal reflection
  if (cosTheta2Sq < 0.0) {
      return vec3(1.0);
  }

  float cosTheta2 = sqrt(cosTheta2Sq);

  /// Material Interfaces
  // The iridescence model defined by Belcour/Barla models two material interfaces
  // - one from the outside to the thin-film layer
  // and another one from the thin-film to the base material. These two interfaces are defined as follows:

  // First interface (from the outside to the thin-film layer)
  float R0 = IorToFresnel0(iridescenceIor, outsideIor);
  float R12 = fresnel(R0, cosTheta1);
  float R21 = R12;
  float T121 = 1.0 - R12;

  // Second interface (from the thin-film to the base material)
  vec3 baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0
  vec3 R1 = IorToFresnel0(baseIor, iridescenceIor);
  vec3 R23 = fresnel(R1, cosTheta2);

  // phi12 and phi23 define the base phases per interface and are approximated with 0.0
  // if the IOR of the hit material (iridescenceIor or baseIor) is higher
  // than the IOR of the previous material (outsideIor or iridescenceIor) and \u03C0 otherwise.
  // Also here, polarization is ignored.  float phi12 = 0.0;

  // First interface (from the outside to the thin-film layer)
  float phi12 = 0.0;
  if (iridescenceIor < outsideIor) phi12 = M_PI;
  float phi21 = M_PI - phi12;

  // Second interface (from the thin-film to the base material)
  vec3 phi23 = vec3(0.0);
  if (baseIor[0] < iridescenceIor) phi23[0] = M_PI;
  if (baseIor[1] < iridescenceIor) phi23[1] = M_PI;
  if (baseIor[2] < iridescenceIor) phi23[2] = M_PI;

  // OPD (optical path difference)
  float OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
  // Phase shift
  vec3 phi = vec3(phi21) + phi23;

  // Compound terms
  vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);
  vec3 r123 = sqrt(R123);
  vec3 Rs = (T121 * T121) * R23 / (vec3(1.0) - R123);

  // Reflectance term for m = 0 (DC term amplitude)
  vec3 C0 = R12 + Rs;
  vec3 I = C0;

  // Reflectance term for m > 0 (pairs of diracs)
  vec3 Cm = Rs - T121;
  for (int m = 1; m <= 2; ++m)
  {
      Cm *= r123;
      vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);
      I += Cm * Sm;
  }

  vec3 F_iridescence = max(I, vec3(0.0));

  return F_iridescence;
}

//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB
vec3 BRDF_lambertianIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float iridescenceFactor, vec3 diffuseColor, float specularWeight, float VdotH)
{
    vec3 iridescenceFresnelMax = vec3(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));
    vec3 schlickFresnel = Schlick_to_F0(f0, f90, VdotH);
    vec3 F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);

    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);
}

vec3 BRDF_specularGGXIridescence(vec3 f0, vec3 f90, vec3 iridescenceFresnel, float alphaRoughness, float iridescenceFactor, float specularWeight, float VdotH, float NdotL, float NdotV, float NdotH)
{
    vec3 F = mix(Schlick_to_F0(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);
    float Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
    float D = d_GGX(NdotH, alphaRoughness);

    return specularWeight * F * Vis * D;
}

#endif // RN_USE_IRIDESCENCE





////////////////////////////////////////
// lighting with a punctual light
////////////////////////////////////////
vec3 lightingWithPunctualLight(
  Light light,
  vec3 normal_inWorld,
  vec3 viewDirection,
  float NdotV,
  vec3 albedo,
  float perceptualRoughness,
  float metallic,
  vec3 F0,
  vec3 F90,
  float ior,
  float transmission,
  float clearcoat,
  float clearcoatRoughness,
  vec3 clearcoatNormal_inWorld,
  float VdotNc,
  vec3 attenuationColor,
  float attenuationDistance,
  float anisotropy,
  vec3 anisotropicT,
  vec3 anisotropicB,
  float BdotV,
  float TdotV,
  vec3 sheenColor,
  float sheenRoughness,
  float albedoSheenScalingNdotV,
  float iridescenceFactor,
  vec3 iridescenceFresnel,
  float specularWeight
  )
{
  float alphaRoughness = perceptualRoughness * perceptualRoughness;

  // Fresnel
  vec3 halfVector = normalize(light.direction + viewDirection);
  float VdotH = dot(viewDirection, halfVector);
  vec3 F = fresnel(F0, F90, VdotH);

  float NdotL = saturateEpsilonToOne(dot(normal_inWorld, light.direction));

  // Diffuse
#ifdef RN_USE_IRIDESCENCE
  vec3 diffuseBrdf = BRDF_lambertianIridescence(F0, F90, iridescenceFresnel, iridescenceFactor, albedo, specularWeight, VdotH);
#else
  vec3 diffuseBrdf = BRDF_lambertian(albedo, F, specularWeight);
#endif

  vec3 pureDiffuse = diffuseBrdf * vec3(NdotL) * light.attenuatedIntensity;

#ifdef RN_USE_TRANSMISSION
  vec3 refractionVector = refract(-viewDirection, normal_inWorld, 1.0 / ior);
  Light transmittedLightFromUnderSurface = light;
  transmittedLightFromUnderSurface.pointToLight -= refractionVector;
  vec3 transmittedLightDirectionFromUnderSurface = normalize(transmittedLightFromUnderSurface.pointToLight);
  transmittedLightFromUnderSurface.direction = transmittedLightDirectionFromUnderSurface;

  vec3 Ht = normalize(viewDirection + transmittedLightFromUnderSurface.direction);
  float NdotHt = saturateEpsilonToOne(dot(normal_inWorld, Ht));
  float NdotLt = saturateEpsilonToOne(dot(normal_inWorld, transmittedLightFromUnderSurface.direction));

  vec3 transmittedContrib = (vec3(1.0) - F) * specular_btdf(alphaRoughness, NdotLt, NdotV, NdotHt) * albedo * transmittedLightFromUnderSurface.attenuatedIntensity;

#ifdef RN_USE_VOLUME
  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittedLightFromUnderSurface.pointToLight));
#endif // RN_USE_VOLUME

  vec3 diffuseContrib = mix(pureDiffuse, vec3(transmittedContrib), transmission);
#else
  vec3 diffuseContrib = pureDiffuse;
#endif // RN_USE_TRANSMISSION

  // Specular
  float NdotH = saturateEpsilonToOne(dot(normal_inWorld, halfVector));

#ifdef RN_USE_IRIDESCENCE
  vec3 specularContrib = BRDF_specularGGXIridescence(F0, F90, iridescenceFresnel, alphaRoughness, iridescenceFactor, specularWeight, VdotH, NdotL, NdotV, NdotH) * vec3(NdotL) * light.attenuatedIntensity;
#elif defined(RN_USE_ANISOTROPY)
  float TdotL = dot(anisotropicT, light.direction);
  float BdotL = dot(anisotropicB, light.direction);
  float TdotH = dot(anisotropicT, halfVector);
  float BdotH = dot(anisotropicB, halfVector);
  vec3 specularContrib = BRDF_specularAnisotropicGGX(F, alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3(NdotL) * light.attenuatedIntensity;
#else
  vec3 specularContrib = cook_torrance_specular_brdf(NdotH, NdotL, NdotV, F, alphaRoughness, specularWeight) * vec3(NdotL) * light.attenuatedIntensity;
#endif // RN_USE_ANISOTROPY

  // Base Layer
  vec3 baseLayer = diffuseContrib + specularContrib;

#ifdef RN_USE_SHEEN
  // Sheen
  vec3 sheenContrib = sheen_brdf(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;
  float albedoSheenScaling = min(
    albedoSheenScalingNdotV,
    1.0 - max3(sheenColor) * texture(u_sheenLutTexture, vec2(NdotL, sheenRoughness)).r);
  vec3 color = sheenContrib + baseLayer * albedoSheenScaling;
#else
  vec3 color = baseLayer;
  float albedoSheenScaling = 1.0;
#endif // RN_USE_SHEEN

#ifdef RN_USE_CLEARCOAT
  // Clear Coat Layer
  float NdotHc = saturateEpsilonToOne(dot(clearcoatNormal_inWorld, halfVector));
  float LdotNc = saturateEpsilonToOne(dot(light.direction, clearcoatNormal_inWorld));
  vec3 coated = coated_material_s(color, perceptualRoughness,
    clearcoatRoughness, clearcoat, VdotNc, LdotNc, NdotHc);
  vec3 finalColor = coated;
#else
  vec3 finalColor = color;
#endif // RN_USE_CLEARCOAT

  return finalColor;
}


/* shaderity: @{matricesGetters} */

vec3 get_irradiance(vec3 normal_forEnv, float materialSID, ivec2 hdriFormat) {
  vec4 diffuseTexel = texture(u_diffuseEnvTexture, normal_forEnv);

  vec3 irradiance;
  if (hdriFormat.x == 0) {
    // LDR_SRGB
    irradiance = srgbToLinear(diffuseTexel.rgb);
  }
  else if (hdriFormat.x == 3) {
    // RGBE
    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  }
  else {
    irradiance = diffuseTexel.rgb;
  }

  return irradiance;
}

float scaleForLod(float perceptualRoughness, float ior)
{
  // Scale roughness to the range [0, 1],
  // ior=1.0 will be scale 0,
  // ior=1.5 will be scale 1.0,
  // ior=2 will be scale 1.0 (clamped)
  //

  float scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);
  return perceptualRoughness * scale;
}

#ifdef RN_USE_TRANSMISSION
vec3 get_sample_from_backbuffer(float materialSID, vec2 sampleCoord, float perceptualRoughness, float ior) {
  ivec2 vrState = get_vrState(0.0, 0);
  vec2 backBufferTextureSize = vec2(textureSize(u_backBufferTexture, 0));
  float backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);

#ifdef WEBGL2_MULTI_VIEW
  // For VR
  backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
  sampleCoord.x = sampleCoord.x * 0.5;
  if (v_displayIdx == 1.0) { // For right eye
    sampleCoord.x += 0.5;
  }
#else
  if (vrState.x == 1) { // For VR
    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
    sampleCoord.x = sampleCoord.x * 0.5;
    if (vrState.y == 1) { // For right eye
      sampleCoord.x += 0.5;
    }
  }
#endif

  float framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);

  #ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
    vec3 transmittedLight = texture2DLodEXT(u_backBufferTexture, sampleCoord, framebufferLod).rgb;
  #elif defined(GLSL_ES3)
    vec3 transmittedLight = textureLod(u_backBufferTexture, sampleCoord, framebufferLod).rgb;
  #else
    vec3 transmittedLight = texture(u_backBufferTexture, sampleCoord).rgb;
  #endif

  return transmittedLight;
}
#endif

vec3 get_radiance(vec3 reflection, float lod, ivec2 hdriFormat) {
  #ifdef WEBGL1_EXT_SHADER_TEXTURE_LOD
    vec4 specularTexel = textureCubeLodEXT(u_specularEnvTexture, reflection, lod);
  #elif defined(GLSL_ES3)
    vec4 specularTexel = textureLod(u_specularEnvTexture, reflection, lod);
  #else
    vec4 specularTexel = texture(u_specularEnvTexture, reflection);
  #endif

// #pragma shaderity: require(./../common/fetchCubeTexture.glsl)

  vec3 radiance;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer
vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior)
{
  vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);
  mat4 worldMatrix = get_worldMatrix(v_instanceInfo);

  vec3 modelScale;
  modelScale.x = length(vec3(worldMatrix[0].xyz));
  modelScale.y = length(vec3(worldMatrix[1].xyz));
  modelScale.z = length(vec3(worldMatrix[2].xyz));

  return normalize(refractionVector) * thickness * modelScale;
}

struct IblResult
{
  vec3 specular;
  vec3 diffuse;
  vec3 FssEss;
};

#ifdef RN_USE_IRIDESCENCE
IblResult getIBLRadianceGGXWithIridescence(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,
  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,
  vec3 normal_forEnv, vec3 reflection, vec3 iridescenceFresnel, float iridescence, float specularWeight)
{
  // get radiance
  float mipCount = iblParameter.x;
  float lod = (perceptualRoughness * (mipCount - 1.0));
  vec3 radiance = get_radiance(reflection, lod, hdriFormat);

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughnessWithIridescence(F0, NdotV, perceptualRoughness, iridescenceFresnel, iridescence);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = kS * f_ab.x + f_ab.y;
  IblResult result;
  result.FssEss = FssEss;

  // Specular IBL
  vec3 specular = FssEss * radiance * specularWeight;

  // scale with user parameters
  float IBLSpecularContribution = iblParameter.z;
  specular *= IBLSpecularContribution;

  result.specular = specular;

  return result;
}

IblResult getIBLRadianceLambertianWithIridescence(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,
  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,
  vec3 normal_forEnv, vec3 reflection, vec3 iridescenceF0, float iridescence, float specularWeight)
{
  // get irradiance
  vec3 irradiance = get_irradiance(normal_forEnv, materialSID, hdriFormat);

  // Use the maximum component of the iridescence Fresnel color
  // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF
  vec3 iridescenceF0Max = vec3(max(max(iridescenceF0.r, iridescenceF0.g), iridescenceF0.b));

  // Blend between base F0 and iridescence F0
  vec3 mixedF0 = mix(F0, iridescenceF0Max, iridescence);

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughness(mixedF0, NdotV, perceptualRoughness);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = specularWeight * kS * f_ab.x + f_ab.y;
  IblResult result;
  result.FssEss = FssEss;

  // Multiple scattering, Fdez-Aguera's approach
  float Ems = (1.0 - (f_ab.x + f_ab.y));
  vec3 F_avg = specularWeight * (mixedF0 + (1.0 - mixedF0) / 21.0);
  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);
  vec3 k_D = albedo * (1.0 - FssEss - FmsEms);

  // Diffuse IBL
  vec3 diffuse = (FmsEms + k_D) * irradiance;

  // scale with user parameters
  float IBLDiffuseContribution = iblParameter.y;
  diffuse *= IBLDiffuseContribution;

  result.diffuse = diffuse;

  return result;
}
#endif // RN_USE_IRIDESCENCE

IblResult getIBLRadianceLambertian(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,
  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,
  vec3 normal_forEnv, vec3 reflection, float specularWeight)
{
  // get irradiance
  vec3 irradiance = get_irradiance(normal_forEnv, materialSID, hdriFormat);

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = specularWeight * kS * f_ab.x + f_ab.y;
  IblResult result;
  result.FssEss = FssEss;

  // Multiple scattering, Fdez-Aguera's approach
  float Ems = (1.0 - (f_ab.x + f_ab.y));
  vec3 F_avg = specularWeight * (F0 + (1.0 - F0) / 21.0);
  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);
  vec3 k_D = albedo * (1.0 - FssEss - FmsEms);

  // Diffuse IBL
  vec3 diffuse = (FmsEms + k_D) * irradiance;

  // scale with user parameters
  float IBLDiffuseContribution = iblParameter.y;
  diffuse *= IBLDiffuseContribution;

  result.diffuse = diffuse;

  return result;
}

IblResult getIBLRadianceGGX(float materialSID, float NdotV, vec3 viewDirection, vec3 albedo, vec3 F0,
  float perceptualRoughness, vec4 iblParameter, ivec2 hdriFormat, mat3 rotEnvMatrix,
  vec3 normal_forEnv, vec3 reflection, float specularWeight)
{
  // get radiance
  float mipCount = iblParameter.x;
  float lod = (perceptualRoughness * (mipCount - 1.0));
  vec3 radiance = get_radiance(reflection, lod, hdriFormat);

  // Roughness dependent fresnel
  vec3 kS = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  vec2 f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  vec3 FssEss = kS * f_ab.x + f_ab.y;
  IblResult result;
  result.FssEss = FssEss;

  // Specular IBL
  vec3 specular = FssEss * radiance * specularWeight;

  // scale with user parameters
  float IBLSpecularContribution = iblParameter.z;
  specular *= IBLSpecularContribution;

  result.specular = specular;

  return result;
}

#ifdef RN_USE_SHEEN
vec3 sheenIBL(float NdotV, float sheenPerceptualRoughness, vec3 sheenColor, vec4 iblParameter, vec3 reflection, ivec2 hdriFormat)
{
  float mipCount = iblParameter.x;
  float lod = (sheenPerceptualRoughness * (mipCount - 1.0));

  vec2 sheenLutUV = vec2(NdotV, sheenPerceptualRoughness);
  float brdf = texture(u_sheenLutTexture, sheenLutUV).b;
  vec3 sheenLight = get_radiance(reflection, lod, hdriFormat);
  float IBLSpecularContribution = iblParameter.z;
  sheenLight *= IBLSpecularContribution;

  return sheenLight * sheenColor * brdf;
}
#endif

vec3 getNormalForEnv(mat3 rotEnvMatrix, vec3 normal_inWorld, float materialSID) {
  vec3 normal_forEnv = rotEnvMatrix * normal_inWorld;
  if (get_inverseEnvironment(materialSID, 0)) {
    normal_forEnv.x *= -1.0;
  }
  return normal_forEnv;
}

vec3 getReflection(mat3 rotEnvMatrix, vec3 viewDirection, vec3 normal_inWorld, float materialSID, float perceptualRoughness, float anisotropy, vec3 anisotropyDirection) {
#ifdef RN_USE_ANISOTROPY

  float tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);
  vec3  anisotropicTangent  = cross(anisotropyDirection, viewDirection);
  vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);
  float bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);
  float bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;
  vec3  bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));
  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);
#else
  vec3 reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);
#endif
  if (get_inverseEnvironment(materialSID, 0)) {
    reflection.x *= -1.0;
  }
  return reflection;
}

vec3 IBLContribution(float materialSID, vec3 normal_inWorld, float NdotV, vec3 viewDirection,
  vec3 albedo, vec3 F0, float perceptualRoughness, float clearcoatRoughness, vec3 clearcoatNormal_inWorld,
  float clearcoat, float VdotNc, vec3 geomNormal_inWorld, float cameraSID, float transmission, vec3 v_position_inWorld,
  float thickness, vec3 sheenColor, float sheenRoughness, float albedoSheenScalingNdotV, float ior,
  vec3 iridescenceFresnel, vec3 iridescenceF0, float iridescence, float anisotropy, vec3 anisotropyDirection,
  float specularWeight)
{
  vec4 iblParameter = get_iblParameter(materialSID, 0);
  float rot = iblParameter.w;
  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);

  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  vec3 reflection = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);

  // IBL
  #ifdef RN_USE_IRIDESCENCE
    IblResult baseRadianceResult = getIBLRadianceGGXWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,
      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceFresnel, iridescence, specularWeight);
    IblResult baseLambertianResult = getIBLRadianceLambertianWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,
      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceF0, iridescence, specularWeight);
  #else
    IblResult baseRadianceResult = getIBLRadianceGGX(materialSID, NdotV, viewDirection, albedo, F0,
      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);
    IblResult baseLambertianResult = getIBLRadianceLambertian(materialSID, NdotV, viewDirection, albedo, F0,
      perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);
  #endif

#ifdef RN_USE_TRANSMISSION
  vec3 refractedRay = getVolumeTransmissionRay(geomNormal_inWorld, viewDirection, thickness, ior);
  vec3 refractedRayFromVPosition = v_position_inWorld + refractedRay;
  vec4 ndcPoint = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4(refractedRayFromVPosition, 1.0);
  vec2 refractionCoords = ndcPoint.xy / ndcPoint.w;
  refractionCoords += 1.0;
  refractionCoords /= 2.0;
  vec3 transmittedLight = get_sample_from_backbuffer(materialSID, refractionCoords, perceptualRoughness, ior);

#ifdef RN_USE_VOLUME
  vec3 attenuationColor = get_attenuationColor(materialSID, 0);
  float attenuationDistance = get_attenuationDistance(materialSID, 0);
  transmittedLight = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, length(refractedRay));
#endif

  vec3 transmissionComp = (vec3(1.0) - baseRadianceResult.FssEss) * transmittedLight * albedo;
  vec3 diffuse = mix(baseLambertianResult.diffuse, transmissionComp, transmission);
  vec3 base = diffuse + baseRadianceResult.specular;
#else
  vec3 base = baseLambertianResult.diffuse + baseRadianceResult.specular;
#endif

#ifdef RN_USE_SHEEN
  vec3 sheen = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);
  vec3 color = sheen + base * albedoSheenScalingNdotV;
#else
  vec3 color = base;
#endif

#ifdef RN_USE_CLEARCOAT
  float VdotNg = dot(geomNormal_inWorld, viewDirection);
  vec3 clearcoatNormal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  IblResult coatResult = getIBLRadianceGGX(materialSID, VdotNc, viewDirection, vec3(0.0), F0,
    clearcoatRoughness, iblParameter, hdriFormat, rotEnvMatrix, clearcoatNormal_forEnv, reflection, specularWeight);
  vec3 coatLayer = coatResult.specular;

  float clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);
  vec3 coated = color * vec3(1.0 - clearcoat * clearcoatFresnel) + vec3(coatLayer * clearcoat);
  return coated;
#else
  return color;
#endif

}


uniform vec4 u_baseColorFactor; // initialValue=(1,1,1,1)
uniform sampler2D u_baseColorTexture; // initialValue=(1,white)
uniform int u_baseColorTexcoordIndex; // initialValue=0
uniform vec4 u_baseColorTextureTransform; // initialValue=(1,1,0,0)
uniform float u_baseColorTextureRotation; // initialValue=0

uniform sampler2D u_normalTexture; // initialValue=(2,black)
uniform vec4 u_normalTextureTransform; // initialValue=(1,1,0,0)
uniform float u_normalTextureRotation; // initialValue=(0)
uniform int u_normalTexcoordIndex; // initialValue=(0)
uniform float u_normalScale; // initialValue=(1)

uniform float u_shadingShiftFactor; // initialValue=0.0
uniform sampler2D u_shadingShiftTexture; // initialValue=(3,black)
uniform int u_shadingShiftTexcoordIndex; // initialValue=0
uniform float u_shadingShiftTextureScale; // initialValue=1.0

uniform float u_shadingToonyFactor; // initialValue=0.9
uniform vec3 u_shadeColorFactor; // initialValue=(0,0,0)
uniform sampler2D u_shadeMultiplyTexture; // initialValue=(4,white)
uniform int u_shadeMultiplyTexcoordIndex; // initialValue=0

uniform samplerCube u_diffuseEnvTexture; // initialValue=(5,black), isInternalSetting=true
uniform samplerCube u_specularEnvTexture; // initialValue=(6,black), isInternalSetting=true

uniform float u_giEqualizationFactor; // initialValue=0.9

uniform sampler2D u_matcapTexture; // initialValue=(8,black)
uniform vec3 u_matcapFactor; // initialValue=(1,1,1)
uniform vec3 u_parametricRimColorFactor; // initialValue=(0,0,0)
uniform float u_parametricRimFresnelPowerFactor; // initialValue=5.0
uniform float u_parametricRimLiftFactor; // initialValue=0.0
uniform sampler2D u_rimMultiplyTexture; // initialValue=(9,white)
uniform int u_rimMultiplyTexcoordIndex; // initialValue=0
uniform float u_rimLightingMixFactor; // initialValue=1.0

uniform vec3 u_emissiveFactor; // initialValue=(0,0,0)
uniform sampler2D u_emissiveTexture; // initialValue=(10,white)
uniform int u_emissiveTexcoordIndex; // initialValue=0

uniform vec3 u_outlineColorFactor; // initialValue=(0,0,0)
uniform float u_outlineLightingMixFactor; // initialValue=1.0

uniform sampler2D u_uvAnimationMaskTexture; // initialValue=(11,white)
uniform int u_uvAnimationMaskTexcoordIndex; // initialValue=0
uniform float u_uvAnimationScrollXSpeedFactor; // initialValue=0.0
uniform float u_uvAnimationScrollYSpeedFactor; // initialValue=0.0
uniform float u_uvAnimationRotationSpeedFactor; // initialValue=0.0

uniform bool u_inverseEnvironment; // initialValue=false
uniform vec4 u_iblParameter; // initialValue=(1,1,1,1), isInternalSetting=true
uniform ivec2 u_hdriFormat; // initialValue=(0,0), isInternalSetting=true
uniform float u_alphaCutoff; // initialValue=0.5
uniform bool u_makeOutputSrgb; // initialValue=false

float linearstep(float a, float b, float t) {
  return clamp((t - a) / (b - a), 0.0, 1.0);
}

vec2 getTexcoord(int texcoordIndex) {
  vec2 texcoord;
  if(texcoordIndex == 2){
    texcoord = v_texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = v_texcoord_1;
  }else{
    texcoord = v_texcoord_0;
  }
  return texcoord;
}

vec2 uvAnimation(vec2 origUv, float time, float uvAnimMask, float uvAnimationScrollXSpeedFactor, float uvAnimationScrollYSpeedFactor, float uvAnimationRotationSpeedFactor) {
  float scrollX = uvAnimationScrollXSpeedFactor * time;
  float scrollY = uvAnimationScrollYSpeedFactor * time;
  float rotation = uvAnimationRotationSpeedFactor * time;
  float rotationCos = cos(rotation * uvAnimMask);
  float rotationSin = sin(rotation * uvAnimMask);
  vec2 uv = mat2(rotationCos, -rotationSin, rotationSin, rotationCos) * (origUv - vec2(0.5)) + vec2(0.5);
  uv += vec2(scrollX, scrollY) * uvAnimMask;
  return uv;
}

#ifdef RN_USE_TANGENT
  mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {
    vec3 tangent_inWorld = normalize(v_tangent_inWorld);
    vec3 binormal_inWorld = normalize(v_binormal_inWorld);
    mat3 tbnMat_tangent_to_world = mat3(tangent_inWorld, binormal_inWorld, normal_inWorld);

    return tbnMat_tangent_to_world;
  }
#else
    // This is based on http://www.thetenthplanet.de/archives/1180
    mat3 cotangent_frame(vec3 normal_inWorld, vec3 position, vec2 uv) {
      uv = gl_FrontFacing ? uv : -uv;

      // get edge vectors of the pixel triangle
      vec3 dp1 = dFdx(position);
      vec3 dp2 = dFdy(position);
      vec2 duv1 = dFdx(uv);
      vec2 duv2 = dFdy(uv);

      // solve the linear system
      vec3 dp2perp = cross(dp2, normal_inWorld);
      vec3 dp1perp = cross(normal_inWorld, dp1);
      vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;
      vec3 bitangent = dp2perp * duv1.y + dp1perp * duv2.y;
      bitangent *= -1.0;

      // construct a scale-invariant frame
      float invMat = inversesqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));
      return mat3(tangent * invMat, bitangent * invMat, normal_inWorld);
    }

    mat3 getTBN(vec3 normal_inWorld, vec3 viewVector, vec2 texcoord) {
      mat3 tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord);

      return tbnMat_tangent_to_world;
    }
#endif


void main() {
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    #ifdef RN_IS_VERTEX_SHADER
      skeletalComponentSID = a_instanceInfo.y;
    #else
      skeletalComponentSID = -1.0;
    #endif
  #endif

#else // RN_IS_UNIFORM_MODE

  float materialSID = -1.0; // materialSID is not used in Uniform mode

  int lightNumber = 0;
  #ifdef RN_IS_LIGHTING
    lightNumber = get_lightNumber(0.0, 0);
  #endif

  float skeletalComponentSID = -1.0;
  #ifdef RN_IS_SKINNING
    skeletalComponentSID = float(get_skinningMode(0.0, 0));
  #endif

#endif

float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID} */];

#if defined(WEBGL2_MULTI_VIEW) && defined(RN_IS_VERTEX_SHADER)
// if (u_isMainVr == 1) {
  cameraSID += float(gl_ViewID_OVR);
// }
#endif


  rt0 = vec4(0.0, 0.0, 0.0, 1.0);

  // uv animation
  float uvAnimationScrollXSpeedFactor = get_uvAnimationScrollXSpeedFactor(materialSID, 0);
  float uvAnimationScrollYSpeedFactor = get_uvAnimationScrollYSpeedFactor(materialSID, 0);
  float uvAnimationRotationSpeedFactor = get_uvAnimationRotationSpeedFactor(materialSID, 0);
  int uvAnimationMaskTexcoordIndex = get_uvAnimationMaskTexcoordIndex(materialSID, 0);
  vec2 uvAnimationMaskTexcoord = getTexcoord(uvAnimationMaskTexcoordIndex);
  float uvAnimMask = texture(u_uvAnimationMaskTexture, uvAnimationMaskTexcoord).b;
  float time = get_time(0.0, 0);

  // base color
  vec4 baseColorTextureTransform = get_baseColorTextureTransform(materialSID, 0);
  float baseColorTextureRotation = get_baseColorTextureRotation(materialSID, 0);
  int baseColorTexcoordIndex = get_baseColorTexcoordIndex(materialSID, 0);
  vec2 baseColorTexcoord = getTexcoord(baseColorTexcoordIndex);
  baseColorTexcoord = uvAnimation(baseColorTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  vec2 baseColorTexUv = uvTransform(baseColorTextureTransform.xy, baseColorTextureTransform.zw, baseColorTextureRotation, baseColorTexcoord);
  vec4 baseColorTexture = texture(u_baseColorTexture, baseColorTexUv);
  baseColorTexture.rgb = srgbToLinear(baseColorTexture.rgb);
  vec4 baseColorFactor = get_baseColorFactor(materialSID, 0);
  vec3 baseColorTerm = baseColorTexture.rgb * baseColorFactor.rgb;

  // shade color
  vec3 shadeColorFactor = get_shadeColorFactor(materialSID, 0);
  int shadeMultiplyTexcoordIndex = get_shadeMultiplyTexcoordIndex(materialSID, 0);
  vec2 shadeMultiplyTexcoord = getTexcoord(shadeMultiplyTexcoordIndex);
  shadeMultiplyTexcoord = uvAnimation(shadeMultiplyTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  vec4 shadeMultiplyTexture = texture(u_shadeMultiplyTexture, shadeMultiplyTexcoord);
  shadeMultiplyTexture.rgb = srgbToLinear(shadeMultiplyTexture.rgb);
  vec3 shadeColorTerm = shadeColorFactor * shadeMultiplyTexture.rgb;

  // shading shift
  int shadingShiftTexcoordIndex = get_shadingShiftTexcoordIndex(materialSID, 0);
  vec2 shadingShiftTexcoord = getTexcoord(shadingShiftTexcoordIndex);
  shadingShiftTexcoord = uvAnimation(shadingShiftTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  float shadingShiftTexture = texture(u_shadingShiftTexture, shadingShiftTexcoord).r;
  float shadingShiftTextureScale = get_shadingShiftTextureScale(materialSID, 0);

  // emissive
  vec3 emissiveFactor = get_emissiveFactor(materialSID, 0);
  int emissiveTexcoordIndex = get_emissiveTexcoordIndex(materialSID, 0);
  vec2 emissiveTexcoord = getTexcoord(emissiveTexcoordIndex);
  emissiveTexcoord = uvAnimation(emissiveTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  vec4 emissiveTexture = texture(u_emissiveTexture, emissiveTexcoord);
  emissiveTexture.rgb = srgbToLinear(emissiveTexture.rgb);
  vec3 emissive = emissiveFactor * emissiveTexture.rgb;

  // alpha
  float alpha = baseColorTexture.a * baseColorFactor.a;
#ifdef RN_ALPHATEST_ON
  float cutoff = get_alphaCutoff(materialSID, 0);
  if(alpha < cutoff) discard;
#endif

  // view vector
  vec3 viewPosition = get_viewPosition(cameraSID, 0);
  vec3 viewVector = viewPosition - v_position_inWorld.xyz;
  vec3 viewDirection = normalize(viewVector);

  // Normal
  vec3 normal_inWorld = normalize(v_normal_inWorld);
#ifdef RN_USE_NORMAL_TEXTURE
  vec4 normalTextureTransform = get_normalTextureTransform(materialSID, 0);
  float normalTextureRotation = get_normalTextureRotation(materialSID, 0);
  int normalTexcoordIndex = get_normalTexcoordIndex(materialSID, 0);
  vec2 normalTexcoord = getTexcoord(normalTexcoordIndex);
  normalTexcoord = uvAnimation(normalTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  vec2 normalTexUv = uvTransform(normalTextureTransform.xy, normalTextureTransform.zw, normalTextureRotation, normalTexcoord);
  vec3 normal = texture(u_normalTexture, normalTexUv).xyz * 2.0 - 1.0;
  mat3 TBN = getTBN(normal_inWorld, viewDirection, normalTexUv);
  normal_inWorld = normalize(TBN * normal);
#endif

#ifdef RN_MTOON_IS_OUTLINE
  normal_inWorld *= -1.0;
#endif

  // direct lighting
  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation
  vec3 directLighting = vec3(0.0);
  for (int i = 0; i < lightNumber; i++) {
    Light light = getLight(i, v_position_inWorld.xyz);
    float shading = dot(light.direction, normal_inWorld);
    float shadingShiftFactor = get_shadingShiftFactor(materialSID, 0);
    shading += shadingShiftFactor + shadingShiftTexture * shadingShiftTextureScale;
    float shadingToonyFactor = get_shadingToonyFactor(materialSID, 0);
    shading = linearstep(-1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading);

    vec3 color = mix(shadeColorTerm, baseColorTerm, shading);
    color = color * light.attenuatedIntensity * RECIPROCAL_PI;
    directLighting += light.attenuatedIntensity;
    rt0.xyz += color;
  }

  // indirect lighting
  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation-1
  float giEqualizationFactor = get_giEqualizationFactor(materialSID, 0);
  vec3 worldUpVector = vec3(0.0, 1.0, 0.0);
  vec3 worldDownVector = vec3(0.0, -1.0, 0.0);
  vec4 iblParameter = get_iblParameter(materialSID, 0);
  float rot = iblParameter.w;
  float IBLDiffuseContribution = iblParameter.y;
  mat3 rotEnvMatrix = mat3(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  vec3 normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  ivec2 hdriFormat = get_hdriFormat(materialSID, 0);
  vec3 rawGiUp = get_irradiance(worldUpVector, materialSID, hdriFormat) * IBLDiffuseContribution;
  vec3 rawGiDown = get_irradiance(worldDownVector, materialSID, hdriFormat) * IBLDiffuseContribution;
  vec3 rawGiNormal = get_irradiance(normal_forEnv, materialSID, hdriFormat) * IBLDiffuseContribution;
  vec3 uniformedGi = (rawGiUp + rawGiDown) / 2.0;
  vec3 passthroughGi = rawGiNormal;
  vec3 gi = mix(uniformedGi, passthroughGi, giEqualizationFactor);
  rt0.xyz += gi * baseColorTerm * RECIPROCAL_PI;

  // rim lighting
  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation-2
  vec3 rim = vec3(0.0);
  vec3 worldViewX = normalize(vec3(viewDirection.z, 0.0, -viewDirection.x));
  vec3 worldViewY = cross(viewDirection, worldViewX);
  vec2 matcapUv = vec2( dot(worldViewX, normal_inWorld), dot(worldViewY, normal_inWorld)) * 0.495 + 0.5;
  float epsilon = 0.00001;
  vec3 matcapFactor = srgbToLinear(get_matcapFactor(materialSID, 0));
  rim = matcapFactor * texture(u_matcapTexture, matcapUv).rgb;
  float parametricRimLiftFactor = get_parametricRimLiftFactor(materialSID, 0);
  float parametricRim = clamp( 1.0 - dot(normal_inWorld, viewVector) + parametricRimLiftFactor, 0.0, 1.0);
  float parametricRimFresnelPowerFactor = get_parametricRimFresnelPowerFactor(materialSID, 0);
  parametricRim = pow(parametricRim, max(parametricRimFresnelPowerFactor, epsilon));
  vec3 parametricRimColorFactor = get_parametricRimColorFactor(materialSID, 0);
  rim += parametricRim * parametricRimColorFactor;
  int rimMultiplyTexcoordIndex = get_rimMultiplyTexcoordIndex(materialSID, 0);
  vec2 rimMultiplyTexcoord = getTexcoord(rimMultiplyTexcoordIndex);
  rimMultiplyTexcoord = uvAnimation(rimMultiplyTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  rim *= srgbToLinear(texture(u_rimMultiplyTexture, rimMultiplyTexcoord).rgb);
  float rimLightingMixFactor = get_rimLightingMixFactor(materialSID, 0);
  rim *= mix(vec3(1.0), directLighting + gi, rimLightingMixFactor);
  rt0.xyz += rim;

  // emissive
  rt0.xyz += emissive;

#ifdef RN_MTOON_IS_OUTLINE
  vec3 outlineColorFactor = get_outlineColorFactor(materialSID, 0);
  float outlineLightingMixFactor = get_outlineLightingMixFactor(materialSID, 0);
  rt0.xyz = outlineColorFactor * mix(vec3(1.0), rt0.xyz, outlineLightingMixFactor);
#endif

float makeOutputSrgb = float(get_makeOutputSrgb(materialSID, 0));
rt0.rgb = mix(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb);


  // alpha
  rt0.w = alpha;
  rt0.xyz *= alpha; // premultiplied alpha
  // rt0.xyz = vec3(alpha, 0.0, 0.0);

/* shaderity: @{renderTargetEnd} */

}
`, shaderStage: "fragment", isFragmentShader: true };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/MToon1SingleShader/MToon1SingleShader.vert.wgsl
var MToon1SingleShader_vert_default2;
var init_MToon1SingleShader_vert2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/MToon1SingleShader/MToon1SingleShader.vert.wgsl"() {
    MToon1SingleShader_vert_default2 = { code: '/* shaderity: @{definitions} */\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) position_inWorld : vec3<f32>,\n  @location(1) normal_inWorld : vec3<f32>,\n  @location(2) texcoord_0 : vec2<f32>,\n  @location(3) color_0 : vec4<f32>,\n  @location(4) texcoord_1 : vec2<f32>,\n  @location(5) texcoord_2 : vec2<f32>,\n  @location(6) tangent_inWorld : vec3<f32>,\n  @location(7) binormal_inWorld : vec3<f32>,\n  @location(8) baryCentricCoord: vec3<f32>,\n  @location(9) shadowCoord : vec4<f32>,\n  @location(10) instanceInfo : f32,\n  @location(11) normal_inView : vec3<f32>,\n}\n\nstruct StorageData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(0) var<storage> storageData: StorageData;\nstruct BlendShapeData {\n  data: array<vec4<f32>>,\n}\n@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;\nstruct UniformMorphOffsets {\n  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;\nstruct UniformMorphWeights {\n  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,\n}\n@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;\n\nstruct UniformDrawParameters {\n  materialSid: u32,\n  cameraSID: u32,\n  currentPrimitiveIdx: u32,\n  morphTargetNumber: u32,\n}\n\n@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;\n\nconst M_PI: f32 = 3.141592653589793;\nconst RECIPROCAL_PI: f32 = 0.3183098861837907;\nconst Epsilon: f32 = 0.0000001;\nconst c_MinRoughness: f32 = 0.04;\n\nfn fetchElement(vec4_idx: u32) -> vec4<f32>\n{\n  return storageData.data[vec4_idx];\n}\n\nfn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>\n{\n  return blendShapeData.data[vec4_idx];\n}\n\nfn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElement(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElement(basePosIn16bytes);\n    let val1 = fetchElement(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return val.xyz;\n  } else if (posIn4bytes == 1u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    return vec3<f32>(val0.yzw);\n  } else if (posIn4bytes == 2u) {\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.zw, val1.x);\n  } else { // posIn4bytes == 3\n    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);\n    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);\n    return vec3<f32>(val0.w, val1.xy);\n  }\n}\n\nfn fetchVec4(vec4_idx: u32) -> vec4<f32> {\n  return fetchElement(vec4_idx);\n}\n\nfn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {\n  let posIn4bytes = scalar_idx % 4u;\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  let val = fetchElement(basePosIn16bytes);\n  if (posIn4bytes == 0u) {\n    return val.x;\n  } else if (posIn4bytes == 1u) {\n    return val.y;\n  } else if (posIn4bytes == 2u) {\n    return val.z;\n  } else { // posIn4bytes == 3u\n    return val.w;\n  }\n}\n\n\n\n\nfn fetchMat4(vec4_idx: u32) -> mat4x4<f32>\n{\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n  let col3 = fetchElement(vec4_idx + 3u);\n\n  let val = mat4x4<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w,\n    col3.x, col3.y, col3.z, col3.w\n    );\n\n  return val;\n}\n\n\nfn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {\n  let col0 = fetchElement(vec4_idx);\n  let col1 = fetchElement(vec4_idx + 1u);\n  let col2 = fetchElement(vec4_idx + 2u);\n\n  let val = mat4x3<f32>(\n    col0.x, col0.y, col0.z, col0.w,\n    col1.x, col1.y, col1.z, col1.w,\n    col2.x, col2.y, col2.z, col2.w);\n\n  return val;\n}\n\n\nfn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {\n  let posIn4bytes = scalar_idx % 4u;\n\n  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;\n  if (posIn4bytes == 0u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.x, col0.y, col0.z,\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x\n      );\n    return val;\n  } else if (posIn4bytes == 1u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.y, col0.z, col0.w,\n      col1.x, col1.y, col1.z,\n      col1.w, col2.x, col2.y\n      );\n    return val;\n  } else if (posIn4bytes == 2u) {\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.z, col0.w, col1.x,\n      col1.y, col1.z, col1.w,\n      col2.x, col2.y, col2.z\n      );\n    return val;\n  } else { // posIn4bytes == 3u\n    let col0 = fetchElement(basePosIn16bytes);\n    let col1 = fetchElement(basePosIn16bytes + 1u);\n    let col2 = fetchElement(basePosIn16bytes + 2u);\n    let val = mat3x3<f32>(\n      col0.w, col1.x, col1.y,\n      col1.z, col1.w, col2.x,\n      col2.y, col2.z, col2.w\n      );\n    return val;\n  }\n}\n\nfn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {\n  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);\n  let rotationMat = mat3x3(\n      cos(rotation), -sin(rotation), 0,\n      sin(rotation), cos(rotation), 0,\n                  0,             0, 1\n  );\n  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);\n\n  let matrix = translationMat * rotationMat * scaleMat;\n  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;\n\n  return uvTransformed;\n}\n\n#ifdef RN_IS_NODE_SHADER\n#else\nfn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {\n  var texcoord: vec2f;\n  if(texcoordIndex == 2){\n    texcoord = input.texcoord_2;\n  } else if(texcoordIndex == 1){\n    texcoord = input.texcoord_1;\n  }else{\n    texcoord = input.texcoord_0;\n  }\n  return texcoord;\n}\n#endif\n\nfn saturateEpsilonToOne(x: f32) -> f32 {\n  let Epsilon = 0.0000001;\n  return clamp(x, Epsilon, 1.0);\n}\n\nfn max3(v: vec3f) -> f32\n{\n  return max(max(v.x, v.y), v.z);\n}\n\nfn sqF32(t: f32) -> f32\n{\n  return t * t;\n}\n\nfn sqVec2f(t: vec2f) -> vec2f\n{\n  return t * t;\n}\n\nfn sqVec3f(t: vec3f) -> vec3f\n{\n  return t * t;\n}\n\nfn sqVec4f(t: vec4f) -> vec4f\n{\n  return t * t;\n}\n\n\n/* shaderity: @{getters} */\n/* shaderity: @{matricesGetters} */\n\n// This shader is based on https://github.com/Santarh/MToon\n\n\n#ifdef RN_IS_SKINNING\n\nfn createMatrixFromQuaternionTranslationScale( quaternion: vec4<f32>, translation: vec3<f32>, scale: vec3<f32> ) -> mat4x4<f32> {\n  let q = quaternion;\n  let t = translation;\n\n  let sx = q.x * q.x;\n  let sy = q.y * q.y;\n  let sz = q.z * q.z;\n  let cx = q.y * q.z;\n  let cy = q.x * q.z;\n  let cz = q.x * q.y;\n  let wx = q.w * q.x;\n  let wy = q.w * q.y;\n  let wz = q.w * q.z;\n\n  let mat = mat4x4(\n    1.0 - 2.0 * (sy + sz), 2.0 * (cz + wz), 2.0 * (cy - wy), 0.0,\n    2.0 * (cz - wz), 1.0 - 2.0 * (sx + sz), 2.0 * (cx + wx), 0.0,\n    2.0 * (cy + wy), 2.0 * (cx - wx), 1.0 - 2.0 * (sx + sy), 0.0,\n    t.x, t.y, t.z, 1.0\n  );\n\n  let uniformScaleMat = mat4x4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  let mat44 = mat*uniformScaleMat;\n  return mat44;\n\n}\n\nfn unpackedVec2ToNormalizedVec4(vec_xy: vec2<f32>, criteria: f32) -> vec4<f32> {\n\n  var r: f32;\n  var g: f32;\n  var b: f32;\n  var a: f32;\n\n  let ix = floor(vec_xy.x * criteria);\n  let v1x = ix / criteria;\n  let v1y = ix - floor(v1x) * criteria;\n\n  r = ( v1x + 1.0 ) / (criteria-1.0);\n  g = ( v1y + 1.0 ) / (criteria-1.0);\n\n  let iy = floor( vec_xy.y * criteria);\n  let v2x = iy / criteria;\n  let v2y = iy - floor(v2x) * criteria;\n\n  b = ( v2x + 1.0 ) / (criteria-1.0);\n  a = ( v2y + 1.0 ) / (criteria-1.0);\n\n  r -= 1.0/criteria;\n  g -= 1.0/criteria;\n  b -= 1.0/criteria;\n  a -= 1.0/criteria;\n\n  r = r*2.0-1.0;\n  g = g*2.0-1.0;\n  b = b*2.0-1.0;\n  a = a*2.0-1.0;\n\n  return vec4<f32>(r, g, b, a);\n}\n\nfn get_boneMatrixAsMat4x4(skeletalComponentSID: u32, joint: u32) -> mat4x4<f32> {\n  let mat43: mat4x3<f32> = get_boneMatrix(skeletalComponentSID, joint);\n  return mat4x4<f32>(\n    vec4<f32>(mat43[0], 0.0),\n    vec4<f32>(mat43[1], 0.0),\n    vec4<f32>(mat43[2], 0.0),\n    vec4<f32>(mat43[3], 1.0)\n  );\n}\n\nfn getSkinMatrix(skeletalComponentSID: u32, joint: vec4<u32>, weight: vec4<f32>) -> mat4x4<f32> {\n\n#ifdef RN_BONE_DATA_TYPE_Mat43x1\n  var skinMat: mat4x4<f32> = weight.x * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.x);\n  skinMat += weight.y * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.y);\n  skinMat += weight.z * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.z);\n  skinMat += weight.w * get_boneMatrixAsMat4x4(skeletalComponentSID, joint.w);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2)\n  let criteria = vec2<f32>(4096.0, 4096.0);\n\n  let tq_x = get_boneTranslatePackedQuat(skeletalComponentSID, joint.x);\n  let sq_x = get_boneScalePackedQuat(skeletalComponentSID, joint.x);\n  var quat = unpackedVec2ToNormalizedVec4(vec2(tq_x.w, sq_x.w), criteria.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(quat, tq_x.xyz, sq_x.xyz);\n\n  let tq_y = get_boneTranslatePackedQuat(skeletalComponentSID, joint.y);\n  let sq_y = get_boneScalePackedQuat(skeletalComponentSID, joint.y);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_y.w, sq_y.w), criteria.x);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(quat, tq_y.xyz, sq_y.xyz);\n\n  let tq_z = get_boneTranslatePackedQuat(skeletalComponentSID, joint.z);\n  let sq_z = get_boneScalePackedQuat(skeletalComponentSID, joint.z);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_z.w, sq_z.w), criteria.x);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(quat, tq_z.xyz, sq_z.xyz);\n\n  let tq_w = get_boneTranslatePackedQuat(skeletalComponentSID, joint.w);\n  let sq_w = get_boneScalePackedQuat(skeletalComponentSID, joint.w);\n  quat = unpackedVec2ToNormalizedVec4(vec2(tq_w.w, sq_w.w), criteria.x);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(quat, tq_w.xyz, sq_w.xyz);\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X2_OLD)\n  let ts_x = get_boneTranslateScale(skeletalComponentSID, joint.x);\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = get_boneTranslateScale(skeletalComponentSID, joint.y);\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.y), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = get_boneTranslateScale(skeletalComponentSID, joint.z);\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.z), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = get_boneTranslateScale(skeletalComponentSID, joint.w);\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    get_boneQuaternion(skeletalComponentSID, joint.w), ts_w.xyz, vec3(ts_w.w));\n\n#elif defined(RN_BONE_DATA_TYPE_VEC4X1)\n  let boneCompressedChunksX = get_boneCompressedChunk(skeletalComponentSID, joint.x);\n  let boneCompressedChunksY = get_boneCompressedChunk(skeletalComponentSID, joint.y);\n  let boneCompressedChunksZ = get_boneCompressedChunk(skeletalComponentSID, joint.z);\n  let boneCompressedChunksW = get_boneCompressedChunk(skeletalComponentSID, joint.w);\n\n  let criteria = vec2<f32>(4096.0, 4096.0);\n  let boneCompressedInfo = get_boneCompressedInfo(0.0, 0);\n\n  let ts_x = unpackedVec2ToNormalizedVec4(boneCompressedChunksX.zw, criteria.y)*boneCompressedInfo;\n  var skinMat: mat4x4<f32> = weight.x * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksX.xy, criteria.x), ts_x.xyz, vec3(ts_x.w));\n  let ts_y = unpackedVec2ToNormalizedVec4(boneCompressedChunksY.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.y * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksY.xy, criteria.x), ts_y.xyz, vec3(ts_y.w));\n  let ts_z = unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.z * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksZ.xy, criteria.x), ts_z.xyz, vec3(ts_z.w));\n  let ts_w = unpackedVec2ToNormalizedVec4(boneCompressedChunksW.zw, criteria.y)*boneCompressedInfo;\n  skinMat += weight.w * createMatrixFromQuaternionTranslationScale(\n    unpackedVec2ToNormalizedVec4(boneCompressedChunksW.xy, criteria.x), ts_w.xyz, vec3(ts_w.w));\n#endif\n  return skinMat;\n}\n#endif\n\nfn toNormalMatrix(m: mat4x4<f32>) -> mat3x3<f32> {\n  let a00 = m[0][0];\n  let a01 = m[0][1];\n  let a02 = m[0][2];\n  let a03 = m[0][3];\n  let a10 = m[1][0];\n  let a11 = m[1][1];\n  let a12 = m[1][2];\n  let a13 = m[1][3];\n  let a20 = m[2][0];\n  let a21 = m[2][1];\n  let a22 = m[2][2];\n  let a23 = m[2][3];\n  let a30 = m[3][0];\n  let a31 = m[3][1];\n  let a32 = m[3][2];\n  let a33 = m[3][3];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  let determinantVal = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat3x3<f32>(\n    (a11 * b11 - a12 * b10 + a13 * b09) / determinantVal,\n    (a12 * b08 - a10 * b11 - a13 * b07) / determinantVal,\n    (a10 * b10 - a11 * b08 + a13 * b06) / determinantVal,\n    (a02 * b10 - a01 * b11 - a03 * b09) / determinantVal,\n    (a00 * b11 - a02 * b08 + a03 * b07) / determinantVal,\n    (a01 * b08 - a00 * b10 - a03 * b06) / determinantVal,\n    (a31 * b05 - a32 * b04 + a33 * b03) / determinantVal,\n    (a32 * b02 - a30 * b05 - a33 * b01) / determinantVal,\n    (a30 * b04 - a31 * b02 + a33 * b00) / determinantVal\n  );\n}\n\nstruct GeometoryOutput {\n  normalMatrix: mat3x3<f32>,\n  position_inWorld: vec4<f32>,\n  normal_inWorld: vec3<f32>,\n  isSkinning: bool,\n}\n\n#ifdef RN_IS_SKINNING\nfn skinning(\n  skeletalComponentSID: u32,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n  ) -> GeometoryOutput\n{\n  var output: GeometoryOutput;\n  let skinMat = getSkinMatrix(skeletalComponentSID, joint, weight);\n  output.position_inWorld = skinMat * vec4<f32>(inPosition_inLocal, 1.0);\n  output.normalMatrix = toNormalMatrix(skinMat);\n  output.normal_inWorld = normalize(output.normalMatrix * inNormal_inLocal);\n  output.isSkinning = true;\n\n  return output;\n}\n#endif\n\n\nfn processGeometryWithMorphingAndSkinning(\n  skeletalComponentSID: i32,\n  blendShapeComponentSID: u32,\n  worldMatrix: mat4x4<f32>,\n  viewMatrix: mat4x4<f32>,\n  isBillboard: bool,\n  inNormalMatrix: mat3x3<f32>,\n  inPosition_inLocal: vec3<f32>,\n  inNormal_inLocal: vec3<f32>,\n  baryCentricCoord: vec4<f32>,\n  joint: vec4<u32>,\n  weight: vec4<f32>,\n) -> GeometoryOutput {\n  var output: GeometoryOutput;\n\n  var position_inLocal: vec3<f32>;\n#ifdef RN_IS_MORPHING\n  if (uniformDrawParameters.morphTargetNumber == 0u) {\n#endif\n    position_inLocal = inPosition_inLocal;\n#ifdef RN_IS_MORPHING\n  } else {\n    let vertexIdx = u32(baryCentricCoord.w);\n    position_inLocal = get_position(vertexIdx, inPosition_inLocal, blendShapeComponentSID);\n  }\n#endif\n\n  var worldMatrixInner = worldMatrix;\n\n#ifdef RN_IS_SKINNING\n  if (skeletalComponentSID >= 0) {\n    output = skinning(u32(skeletalComponentSID), inNormalMatrix, position_inLocal, inNormal_inLocal, joint, weight);\n  } else {\n#endif\n    output.normalMatrix = inNormalMatrix;\n    output.position_inWorld = worldMatrixInner * vec4(position_inLocal, 1.0);\n    output.normal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n    output.isSkinning = false;\n#ifdef RN_IS_SKINNING\n  }\n#endif\n\n  return output;\n}\n\n\n// #param outlineWidthMode: i32; // initialValue=0\n// #param outlineWidthFactor: f32; // initialValue=0.0008\n@group(1) @binding(0) var outlineWidthTexture: texture_2d<f32>; // initialValue=white\n@group(2) @binding(0) var outlineWidthSampler: sampler;\n\n@vertex\nfn main(\n#ifdef RN_USE_INSTANCE\n  @location(8) instance_ids: vec4<f32>,\n#endif\n\n\n#ifdef RN_USE_POSITION_FLOAT\n  @location(0) position: vec3<f32>,\n#endif\n#ifdef RN_USE_POSITION_INT\n  @location(0) position: vec3<i32>,\n#endif\n#ifdef RN_USE_POSITION_UINT\n  @location(0) position: vec3<u32>,\n#endif\n\n#ifdef RN_USE_NORMAL\n  @location(1) normal: vec3<f32>,\n#endif\n#ifdef RN_USE_TANGENT\n  @location(2) tangent: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_0\n  @location(3) texcoord_0: vec2<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  @location(4) texcoord_1: vec2<f32>,\n#endif\n\n#ifdef RN_USE_COLOR_0_FLOAT\n  @location(5) color_0: vec4<f32>,\n#endif\n#ifdef RN_USE_COLOR_0_INT\n  @location(5) color_0: vec4<i32>,\n#endif\n#ifdef RN_USE_COLOR_0_UINT\n  @location(5) color_0: vec4<u32>,\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  @location(6) joints_0: vec4<u32>,\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  @location(7) weights_0: vec4<f32>,\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  @location(10) baryCentricCoord: vec4<f32>,\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  @location(11) texcoord_2: vec2<f32>,\n#endif\n  @builtin(vertex_index) vertexIdx : u32,\n\n\n) -> VertexOutput {\n  var output : VertexOutput;\n  #ifdef RN_MTOON_IS_OUTLINE\n    #ifdef RN_MTOON_OUTLINE_NONE\n      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      return output;\n    #endif\n  #endif\n\n#ifdef RN_USE_NORMAL\n#else\n  let normal = vec3<f32>(0.0, 0.0, 0.0);\n#endif\n\n#ifdef RN_USE_JOINTS_0\n  let joint = joints_0;\n#else\n  let joint = vec4<u32>(0, 0, 0, 0);\n#endif\n#ifdef RN_USE_WEIGHTS_0\n  let weight = weights_0;\n#else\n  let weight = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n#ifdef RN_USE_BARY_CENTRIC_COORD\n#else\n  let baryCentricCoord = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n#endif\n\nlet materialSID = uniformDrawParameters.materialSid;\nlet currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;\nlet morphTargetNumber = uniformDrawParameters.morphTargetNumber;\nlet cameraSID = uniformDrawParameters.cameraSID;\n\n\n  let instanceId = u32(instance_ids.x);\n  let worldMatrix = get_worldMatrix(instanceId);\n  let normalMatrix = get_normalMatrix(instanceId);\n  let viewMatrix = get_viewMatrix(cameraSID, 0);\n  let skeletalComponentSID = i32(instance_ids.y);\n  let blendShapeComponentSID = u32(instance_ids.z);\n  let geom = processGeometryWithMorphingAndSkinning(\n    skeletalComponentSID,\n    blendShapeComponentSID,\n    worldMatrix,\n    viewMatrix,\n    false,\n    normalMatrix,\n    position,\n    normal,\n    baryCentricCoord,\n    joint,\n    weight\n  );\n\n  let projectionMatrix = get_projectionMatrix(cameraSID, 0);\n\n  output.position_inWorld = geom.position_inWorld.xyz;\n  output.normal_inWorld = geom.normal_inWorld;\n  output.normal_inView = (viewMatrix * vec4(geom.normal_inWorld, 0.0)).xyz;\n\n#ifdef RN_MTOON_IS_OUTLINE\n  let outlineWidthType = get_outlineWidthMode(materialSID, 0);\n  if (outlineWidthType == 0) { // 0 ("none")\n    output.position = projectionMatrix * viewMatrix * geom.position_inWorld;\n  } else {\n    let worldNormalLength = length(normalMatrix * normal);\n    let outlineWidthFactor = get_outlineWidthFactor(materialSID, 0);\n    var outlineOffset = outlineWidthFactor * worldNormalLength * geom.normal_inWorld;\n\n    let textureSize = textureDimensions(outlineWidthTexture, 0);\n    let outlineWidthMultiply = textureLoad(outlineWidthTexture, vec2u(vec2f(textureSize) * texcoord_0), 0).r;\n    outlineOffset *= outlineWidthMultiply;\n\n    if (outlineWidthType == 2) { // "screenCoordinates"\n      let vViewPosition = viewMatrix * geom.position_inWorld;\n      outlineOffset *= abs(vViewPosition.z) / projectionMatrix[1].y;\n    }\n    output.position = projectionMatrix * viewMatrix * vec4(geom.position_inWorld.xyz + outlineOffset, 1.0);\n    output.position.z += 0.000001 * output.position.w;\n  }\n#else\n  output.position = projectionMatrix * viewMatrix * geom.position_inWorld;\n#endif\n\n#ifdef RN_USE_TANGENT\n  output.tangent_inWorld = normalMatrix * tangent.xyz;\n  output.binormal_inWorld = cross(geom.normal_inWorld, output.tangent_inWorld) * tangent.w;\n#endif\n\n#ifdef RN_USE_TEXCOORD_0\n  output.texcoord_0 = texcoord_0;\n#endif\n#ifdef RN_USE_TEXCOORD_1\n  output.texcoord_1 = texcoord_1;\n#endif\n#ifdef RN_USE_TEXCOORD_2\n  output.texcoord_2 = texcoord_2;\n#endif\n\n#ifdef RN_USE_BARY_CENTRIC_COORD\n  output.baryCentricCoord = baryCentricCoord.xyz;\n#endif\n\n  output.instanceInfo = instance_ids.x;\n\n  return output;\n}\n', shaderStage: "vertex", isFragmentShader: false };
  }
});

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/MToon1SingleShader/MToon1SingleShader.frag.wgsl
var MToon1SingleShader_frag_default2;
var init_MToon1SingleShader_frag2 = __esm({
  "shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/MToon1SingleShader/MToon1SingleShader.frag.wgsl"() {
    MToon1SingleShader_frag_default2 = { code: `/* shaderity: @{definitions} */
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) position_inWorld : vec3<f32>,
  @location(1) normal_inWorld : vec3<f32>,
  @location(2) texcoord_0 : vec2<f32>,
  @location(3) color_0 : vec4<f32>,
  @location(4) texcoord_1 : vec2<f32>,
  @location(5) texcoord_2 : vec2<f32>,
  @location(6) tangent_inWorld : vec3<f32>,
  @location(7) binormal_inWorld : vec3<f32>,
  @location(8) baryCentricCoord: vec3<f32>,
  @location(9) shadowCoord : vec4<f32>,
  @location(10) instanceInfo : f32,
  @location(11) normal_inView : vec3<f32>,
}

struct StorageData {
  data: array<vec4<f32>>,
}
@group(0) @binding(0) var<storage> storageData: StorageData;
struct BlendShapeData {
  data: array<vec4<f32>>,
}
@group(0) @binding(1) var<storage> blendShapeData: BlendShapeData;
struct UniformMorphOffsets {
  data: array<vec4<u32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(2) var<uniform> uniformMorphOffsets: UniformMorphOffsets;
struct UniformMorphWeights {
  data: array<vec4<f32>, /* shaderity: @{maxMorphDataNumber} */ >,
}
@group(0) @binding(3) var<uniform> uniformMorphWeights: UniformMorphWeights;

struct UniformDrawParameters {
  materialSid: u32,
  cameraSID: u32,
  currentPrimitiveIdx: u32,
  morphTargetNumber: u32,
}

@group(3) @binding(0) var<uniform> uniformDrawParameters: UniformDrawParameters;

const M_PI: f32 = 3.141592653589793;
const RECIPROCAL_PI: f32 = 0.3183098861837907;
const Epsilon: f32 = 0.0000001;
const c_MinRoughness: f32 = 0.04;

fn fetchElement(vec4_idx: u32) -> vec4<f32>
{
  return storageData.data[vec4_idx];
}

fn fetchElementFromBlendShapeBuffer(vec4_idx: u32) -> vec4<f32>
{
  return blendShapeData.data[vec4_idx];
}

fn fetchVec3No16BytesAligned(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElement(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElement(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElement(basePosIn16bytes);
    let val1 = fetchElement(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec3No16BytesAlignedFromBlendShapeBuffer(scalar_idx: u32) -> vec3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let val = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return val.xyz;
  } else if (posIn4bytes == 1u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    return vec3<f32>(val0.yzw);
  } else if (posIn4bytes == 2u) {
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.zw, val1.x);
  } else { // posIn4bytes == 3
    let val0 = fetchElementFromBlendShapeBuffer(basePosIn16bytes);
    let val1 = fetchElementFromBlendShapeBuffer(basePosIn16bytes+1u);
    return vec3<f32>(val0.w, val1.xy);
  }
}

fn fetchVec4(vec4_idx: u32) -> vec4<f32> {
  return fetchElement(vec4_idx);
}

fn fetchScalarNo16BytesAligned(scalar_idx: u32) -> f32 {
  let posIn4bytes = scalar_idx % 4u;
  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  let val = fetchElement(basePosIn16bytes);
  if (posIn4bytes == 0u) {
    return val.x;
  } else if (posIn4bytes == 1u) {
    return val.y;
  } else if (posIn4bytes == 2u) {
    return val.z;
  } else { // posIn4bytes == 3u
    return val.w;
  }
}




fn fetchMat4(vec4_idx: u32) -> mat4x4<f32>
{
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);
  let col3 = fetchElement(vec4_idx + 3u);

  let val = mat4x4<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w,
    col3.x, col3.y, col3.z, col3.w
    );

  return val;
}


fn fetchMat4x3(vec4_idx: u32) -> mat4x3<f32> {
  let col0 = fetchElement(vec4_idx);
  let col1 = fetchElement(vec4_idx + 1u);
  let col2 = fetchElement(vec4_idx + 2u);

  let val = mat4x3<f32>(
    col0.x, col0.y, col0.z, col0.w,
    col1.x, col1.y, col1.z, col1.w,
    col2.x, col2.y, col2.z, col2.w);

  return val;
}


fn fetchMat3No16BytesAligned(scalar_idx: u32) -> mat3x3<f32> {
  let posIn4bytes = scalar_idx % 4u;

  let basePosIn16bytes = (scalar_idx - posIn4bytes) / 4u;
  if (posIn4bytes == 0u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.x, col0.y, col0.z,
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x
      );
    return val;
  } else if (posIn4bytes == 1u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.y, col0.z, col0.w,
      col1.x, col1.y, col1.z,
      col1.w, col2.x, col2.y
      );
    return val;
  } else if (posIn4bytes == 2u) {
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.z, col0.w, col1.x,
      col1.y, col1.z, col1.w,
      col2.x, col2.y, col2.z
      );
    return val;
  } else { // posIn4bytes == 3u
    let col0 = fetchElement(basePosIn16bytes);
    let col1 = fetchElement(basePosIn16bytes + 1u);
    let col2 = fetchElement(basePosIn16bytes + 2u);
    let val = mat3x3<f32>(
      col0.w, col1.x, col1.y,
      col1.z, col1.w, col2.x,
      col2.y, col2.z, col2.w
      );
    return val;
  }
}

fn uvTransform(scale: vec2f, offset: vec2f, rotation: f32, uv: vec2f) -> vec2f {
  let translationMat = mat3x3(1,0,0, 0,1,0, offset.x, offset.y, 1);
  let rotationMat = mat3x3(
      cos(rotation), -sin(rotation), 0,
      sin(rotation), cos(rotation), 0,
                  0,             0, 1
  );
  let scaleMat = mat3x3(scale.x,0,0, 0,scale.y,0, 0,0,1);

  let matrix = translationMat * rotationMat * scaleMat;
  let uvTransformed = ( matrix * vec3f(uv.xy, 1) ).xy;

  return uvTransformed;
}

#ifdef RN_IS_NODE_SHADER
#else
fn getTexcoord(texcoordIndex: u32, input: VertexOutput) -> vec2<f32> {
  var texcoord: vec2f;
  if(texcoordIndex == 2){
    texcoord = input.texcoord_2;
  } else if(texcoordIndex == 1){
    texcoord = input.texcoord_1;
  }else{
    texcoord = input.texcoord_0;
  }
  return texcoord;
}
#endif

fn saturateEpsilonToOne(x: f32) -> f32 {
  let Epsilon = 0.0000001;
  return clamp(x, Epsilon, 1.0);
}

fn max3(v: vec3f) -> f32
{
  return max(max(v.x, v.y), v.z);
}

fn sqF32(t: f32) -> f32
{
  return t * t;
}

fn sqVec2f(t: vec2f) -> vec2f
{
  return t * t;
}

fn sqVec3f(t: vec3f) -> vec3f
{
  return t * t;
}

fn sqVec4f(t: vec4f) -> vec4f
{
  return t * t;
}


/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */

const EPS_COL: f32 = 0.00001;

struct Light {
  lightType: i32, // 0 = directional, 1 = point, 2 = spot
  position: vec3<f32>,
  intensity: vec3<f32>,
  attenuatedIntensity: vec3<f32>,
  directionOfLightObject: vec3<f32>,
  direction: vec3<f32>, // direction of light vector, equal to normalize(light.pointToLight)
  pointToLight: vec3<f32>, // not normalized
  spotAngleScale: f32,
  spotAngleOffset: f32,
  effectiveRange: f32,
};

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
fn getRangeAttenuation(light: Light) -> f32
{
  let distance = length(light.pointToLight);
  // means no range limit
  if (light.effectiveRange <= 0.0)
  {
    return 1.0 / pow(distance, 2.0);
  }
  return max(min(1.0 - pow(distance / light.effectiveRange, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
fn getSpotAttenuation(light: Light) -> f32
{

  let cd = dot(light.directionOfLightObject, light.direction);
  let angularAttenuation = clamp(cd * light.spotAngleScale + light.spotAngleOffset, 0.0, 1.0);
  return angularAttenuation;
}

fn getLightAttenuated(light: Light) -> Light {
  var newLight: Light = light;
  newLight.attenuatedIntensity = light.intensity;
  // if (light.lightType == 0) { // Directional Light
    // Directional Light don't attenuate geometically
  // }

  // Point Light
  if (light.lightType == 1)
  {
    newLight.attenuatedIntensity *= getRangeAttenuation(light);
  }
  // Spot light
  if (light.lightType == 2)
  {
    newLight.attenuatedIntensity *= getSpotAttenuation(light);
  }

  return newLight;
}

fn getLight(lightIdx: u32, v_position_inWorld: vec3<f32>) -> Light {
  let lightPosition: vec3<f32> = get_lightPosition(0u, lightIdx);
  let direction_and_w_of_LightObject: vec3<f32> = get_lightDirection(0u, lightIdx);
  let lightIntensity: vec3<f32> = get_lightIntensity(0u, lightIdx);
  let lightProperty: vec4<f32> = get_lightProperty(0u, lightIdx);
  var light: Light;
  light.directionOfLightObject = direction_and_w_of_LightObject;
  let lightType = lightProperty.x;
  light.effectiveRange = lightProperty.y;
  light.spotAngleScale = lightProperty.z;
  light.spotAngleOffset = lightProperty.w;

  light.intensity = lightIntensity;
  light.position = lightPosition;
  if (lightType < -0.5) { // disabled light
    light.intensity = vec3f(0.0);
    light.lightType = -1;
  } else if (0.75 < lightType) { // is pointlight or spotlight
    light.pointToLight = lightPosition - v_position_inWorld;
    light.direction = normalize(light.pointToLight);
    light.lightType = 1;
  } else { // is Directional Light
    light.lightType = 0;
    light.direction = normalize(light.directionOfLightObject * -1.0);
  }

  if (lightType > 1.75) { // is spotlight
    light.lightType = 2;
  }

  light.intensity *= M_PI; // Punctual Light

  // Attenuation
  light.attenuatedIntensity = light.intensity;
  let newLight = getLightAttenuated(light);

  return newLight;
}

#ifdef RN_USE_TANGENT
  fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
    let tangent_inWorld = normalize(input.tangent_inWorld);
    let binormal_inWorld = normalize(input.binormal_inWorld);
    let tbnMat_tangent_to_world = mat3x3<f32>(tangent_inWorld, binormal_inWorld, normal_inWorld);

    return tbnMat_tangent_to_world;
  }
#else
    // This is based on http://www.thetenthplanet.de/archives/1180
    fn cotangent_frame(normal_inWorld: vec3f, position: vec3f, uv_: vec2f, isFront: bool) -> mat3x3<f32> {
      var uv: vec2f;
      if (isFront) {
        uv = uv_;
      } else {
        uv = -uv_;
      }

      // get edge vectors of the pixel triangle
      let dp1 = dpdx(position);
      let dp2 = dpdy(position);
      let duv1 = dpdx(uv);
      let duv2 = dpdy(uv);

      // solve the linear system
      let dp2perp = cross(dp2, normal_inWorld);
      let dp1perp = cross(normal_inWorld, dp1);
      let tangent = dp2perp * duv1.x + dp1perp * duv2.x;
      var bitangent = dp2perp * duv1.y + dp1perp * duv2.y;
      bitangent *= -1.0;

      // construct a scale-invariant frame
      let invMat = 1.0 / sqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));
      return mat3x3<f32>(tangent * invMat, bitangent * invMat, normal_inWorld);
    }

    fn getTBN(normal_inWorld: vec3f, input: VertexOutput, viewVector: vec3f, texcoord: vec2f, isFront: bool) -> mat3x3<f32> {
      let tbnMat_tangent_to_world = cotangent_frame(normal_inWorld, -viewVector, texcoord, isFront);

      return tbnMat_tangent_to_world;
    }
#endif

fn srgbToLinear(srgbColor: vec3f) -> vec3f {
  return pow(srgbColor, vec3f(2.2));
}

fn linearToSrgb(linearColor: vec3f) -> vec3f {
  return pow(linearColor, vec3f(1.0/2.2));
}

// From: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2c7b8c8bd12916c1a387cd41f9ef061edc718df/source/Renderer/shaders/brdf.glsl#L44-L66
fn Schlick_to_F0_F90(f: vec3f, f90: vec3f, VdotH: f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0_F90_F32(f: f32, f90: f32, VdotH: f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = clamp(x * x2 * x2, 0.0, 0.9999);

    return (f - f90 * x5) / (1.0 - x5);
}

fn Schlick_to_F0(f: vec3f, VdotH: f32) -> vec3f {
    return Schlick_to_F0_F90(f, vec3(1.0), VdotH);
}

fn Schlick_to_F0_F32(f: f32, VdotH: f32) -> f32 {
    return Schlick_to_F0_F90_F32(f, 1.0, VdotH);
}


// The Schlick Approximation to Fresnel
fn fresnel(f0 : vec3f, f90 : vec3f, VdotH : f32) -> vec3f {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnelF32(f0 : f32, f90 : f32, VdotH : f32) -> f32 {
    let x = clamp(1.0 - VdotH, 0.0, 1.0);
    let x2 = x * x;
    let x5 = x * x2 * x2;
    return f0 + (f90 - f0) * x5;
}

fn fresnel2(f0: vec3f, VdotH: f32) -> vec3f
{
  let f90 = vec3f(1.0); //clamp(50.0 * f0, 0.0, 1.0);
  return fresnel(f0, f90, VdotH);
}

fn fresnel2F32(f0: f32, VdotH: f32) -> f32
{
  let f90 = 1.0; //clamp(50.0 * f0, 0.0, 1.0);
  return fresnelF32(f0, f90, VdotH);
}

// Roughness Dependent Fresnel
// https://www.jcgt.org/published/0008/01/03/paper.pdf
fn fresnelSchlickRoughness(F0: vec3f, cosTheta: f32, roughness: f32) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = F0 + Fr * pow(1.0 - cosTheta, 5.0);
  return k_S;
}

// https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#diffuse-brdf
fn BRDF_lambertian(albedo: vec3f, F: vec3f, specularWeight: f32) -> vec3f
{
  return (vec3f(1.0) - specularWeight * F) * albedo * RECIPROCAL_PI;
}


// GGX NDF
fn d_GGX(NH: f32, alphaRoughness: f32) -> f32 {
  let roughnessSqr = alphaRoughness * alphaRoughness;
  let f = (roughnessSqr - 1.0) * NH * NH + 1.0;
  return roughnessSqr / (M_PI * f * f);
}

// The code from https://google.github.io/filament/Filament.html#listing_approximatedspecularv
// The idea is from [Heitz14] Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs.
fn v_GGXCorrelated(NL: f32, NV: f32, alphaRoughness: f32) -> f32 {
  let a2 = alphaRoughness * alphaRoughness;
  let GGXV = NL * sqrt(NV * NV * (1.0 - a2) + a2);
  let GGXL = NV * sqrt(NL * NL * (1.0 - a2) + a2);
  return 0.5 / (GGXV + GGXL);
}

fn BRDF_specularGGX(NH: f32, NL: f32, NV: f32, F: vec3f, alphaRoughness: f32, specularWeight: f32) -> vec3f {
  let D = d_GGX(NH, alphaRoughness);
  let V = v_GGXCorrelated(NL, NV, alphaRoughness);
  return vec3f(D) * vec3f(V) * F * specularWeight;
}

// this is from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
fn envBRDFApprox( Roughness: f32, NoV: f32 ) -> vec2f {
  let c0 = vec4f(-1, -0.0275, -0.572, 0.022 );
  let c1 = vec4f(1, 0.0425, 1.04, -0.04 );
  let r = Roughness * c0 + c1;
  let a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
  let AB = vec2f( -1.04, 1.04 ) * a004 + r.zw;

  return AB;
}


// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering
fn coated_material_s(base: vec3f, perceptualRoughness: f32, clearcoatRoughness: f32, clearcoat: f32, VdotNc: f32, LdotNc: f32, NdotHc: f32) -> vec3f {
  let clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);
  let clearcoatAlpha = clearcoatRoughness * clearcoatRoughness;
  let alphaRoughness = perceptualRoughness * perceptualRoughness;
  let D = d_GGX(NdotHc, clearcoatAlpha);
  let V = v_GGXCorrelated(LdotNc, VdotNc, clearcoatAlpha);
  let f_clearcoat = clearcoatFresnel * D * V;

  // base = (f_diffuse + f_specular) in https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat#layering
  return base * vec3f(1.0 - clearcoat * clearcoatFresnel) + vec3f(f_clearcoat * clearcoat);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission#implementation-notes
fn specular_btdf(alphaRoughness: f32, NdotL: f32, NdotV: f32, NdotHt: f32) -> f32 {
  let V = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
  let D = d_GGX(NdotHt, alphaRoughness);
  return V * D;
}


////////////////////////////////////////
// glTF KHR_materials_volume
////////////////////////////////////////

#ifdef RN_USE_VOLUME
// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation
fn volumeAttenuation(attenuationColor: vec3f, attenuationDistance: f32, intensity: vec3f, transmissionDistance: f32) -> vec3f
{
  if (attenuationDistance == 0.0) { // means Infinite distance
    return intensity; // No attenuation
  } else {
    let attenuationCo: vec3f = -log(attenuationColor) / attenuationDistance;
    let attenuatedTransmittance: vec3f = exp(-attenuationCo * transmissionDistance);
    return intensity * attenuatedTransmittance;
  }
}
#endif


////////////////////////////////////////
// glTF KHR_materials_anisotropy
////////////////////////////////////////
#ifdef RN_USE_ANISOTROPY
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy
fn D_GGX_anisotropic(NdotH: f32, TdotH: f32, BdotH: f32, at: f32, ab: f32) -> f32
{
    let a2 = at * ab;
    let f = vec3f(ab * TdotH, at * BdotH, a2 * NdotH);
    let w2 = a2 / dot(f, f);
    return a2 * w2 * w2 / M_PI;
}

fn V_GGX_anisotropic(NdotL: f32, NdotV: f32, BdotV: f32, TdotV: f32, TdotL: f32, BdotL: f32,
    at: f32, ab: f32) -> f32
{
    let GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));
    let GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));
    let v = 0.5 / (GGXV + GGXL);
    return clamp(v, 0.0, 1.0);
}

fn BRDF_specularAnisotropicGGX(F: vec3f, alphaRoughness: f32,
    VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32, BdotV: f32, TdotV: f32,
    TdotL: f32, BdotL: f32, TdotH: f32, BdotH: f32, anisotropy: f32) -> vec3f
{
    let at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
    let ab = alphaRoughness;

    let V = V_GGX_anisotropic(NdotL, NdotV, BdotV, TdotV, TdotL, BdotL, at, ab);
    let D = D_GGX_anisotropic(NdotH, TdotH, BdotH, at, ab);

    return F * V * D;
}
#endif

////////////////////////////////////////
// glTF KHR_materials_sheen
////////////////////////////////////////

#ifdef RN_USE_SHEEN
fn d_Charlie(sheenPerceptualRoughness: f32, NoH: f32) -> f32 {
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;
  let invAlpha  = 1.0 / alphaG;
  let cos2h = NoH * NoH;
  let sin2h = 1.0 - cos2h;
  return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * M_PI);
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn sheenSimpleVisibility(NdotL: f32, NdotV: f32) -> f32 {
  return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));
}

// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen#sheen-visibility
fn charlieL(x: f32, alphaG: f32) -> f32 {
  let oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
  let a = mix(21.5473, 25.3245, oneMinusAlphaSq);
  let b = mix(3.82987, 3.32435, oneMinusAlphaSq);
  let c = mix(0.19823, 0.16801, oneMinusAlphaSq);
  let d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
  let e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
  return a / (1.0 + b * pow(x, c)) + d * x + e;
}

fn lambdaSheen(cosTheta: f32, alphaG: f32) -> f32
{
  return select(exp(2.0 * charlieL(0.5, alphaG) - charlieL(1.0 - cosTheta, alphaG)), exp(charlieL(cosTheta, alphaG)), abs(cosTheta) < 0.5);
}

fn sheenCharlieVisibility(NdotL: f32, NdotV: f32, sheenPerceptualRoughness: f32) -> f32 {
  let alphaG = sheenPerceptualRoughness * sheenPerceptualRoughness;
  let sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));
  return sheenVisibility;
}

fn sheen_brdf(sheenColor: vec3f, sheenPerceptualRoughness: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f {
  let sheenDistribution = d_Charlie(sheenPerceptualRoughness, NdotH);
  let sheenVisibility = sheenCharlieVisibility(NdotL, NdotV, sheenPerceptualRoughness);
  return sheenColor * sheenDistribution * sheenVisibility;
}
#endif // RN_USE_SHEEN

////////////////////////////////////////
// glTF KHR_materials_irirdescence
////////////////////////////////////////

#ifdef RN_USE_IRIDESCENCE
// XYZ to REC709(sRGB) conversion matrix
const XYZ_TO_REC709 = mat3x3<f32>(
     3.2404542, -0.9692660,  0.0556434,
    -1.5371385,  1.8760108, -0.2040259,
    -0.4985314,  0.0415560,  1.0572252
);

fn fresnelSchlickRoughnessWithIridescence(
  F0: vec3f, cosTheta: f32, roughness: f32,
  iridescenceFresnel: vec3f, iridescence: f32
  ) -> vec3f
{
  let Fr = max(vec3f(1.0 - roughness), F0) - F0;
  let k_S = mix(F0 + Fr * pow(1.0 - cosTheta, 5.0), iridescenceFresnel, iridescence);
  return k_S;
}

// Assume air interface for top
fn Fresnel0ToIor(F0: vec3f) -> vec3f {
    let sqrtF0 = sqrt(F0);
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

// Conversion from IOR to F0
// ior is a value between 1.0 and 3.0. 1.0 is air interface
fn IorToFresnel0Vec3f(transmittedIor: vec3f, incidentIor: f32) -> vec3f {
    return sqVec3f((transmittedIor - vec3f(incidentIor)) / (transmittedIor + vec3(incidentIor)));
}
fn IorToFresnel0F32(transmittedIor: f32, incidentIor: f32) -> f32 {
    return sqF32((transmittedIor - incidentIor) / (transmittedIor + incidentIor));
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#analytic-spectral-integration
 */
fn evalSensitivity(OPD: f32, shift: vec3f) -> vec3f {
    let phase = 2.0 * M_PI * OPD * 1.0e-9;
    let val = vec3f(5.4856e-13, 4.4201e-13, 5.2481e-13);
    let pos = vec3f(1.6810e+06, 1.7953e+06, 2.2084e+06);
    let var_ = vec3f(4.3278e+09, 9.3046e+09, 6.6121e+09);

    var xyz = val * sqrt(2.0 * M_PI * var_) * cos(pos * phase + shift) * exp(-(phase * phase) * var_);
    xyz.x += 9.7470e-14 * sqrt(2.0 * M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * (phase * phase));
    xyz /= 1.0685e-7;

    let rgb = XYZ_TO_REC709 * xyz;
    return rgb;
}

/**
 * From: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence#iridescence-fresnel
 */
fn calcIridescence(outsideIor: f32, eta2: f32, cosTheta1: f32, thinFilmThickness: f32, baseF0: vec3f) -> vec3f {


  // iridescenceIor is the index of refraction of the thin-film layer
  // Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0
  let iridescenceIor = mix(outsideIor, eta2, smoothstep(0.0, 0.03, thinFilmThickness));

  // To calculate the reflectances R12 and R23 at the viewing angles (angle hitting the thin-film layer)
  // and (angle after refraction in the thin-film) Schlick Fresnel is again used.
  // This approximation allows to eliminate the split into S and P polarization for the exact Fresnel equations.
  // can be calculated using Snell's law (with  being outsideIor and being iridescenceIor):
  let sinTheta2Sq = sqF32(outsideIor / iridescenceIor) * (1.0 - sqF32(cosTheta1));
  let cosTheta2Sq = 1.0 - sinTheta2Sq;

  // Handle total internal reflection
  if (cosTheta2Sq < 0.0) {
      return vec3f(1.0);
  }

  let cosTheta2 = sqrt(cosTheta2Sq);

  /// Material Interfaces
  // The iridescence model defined by Belcour/Barla models two material interfaces
  // - one from the outside to the thin-film layer
  // and another one from the thin-film to the base material. These two interfaces are defined as follows:

  // First interface (from the outside to the thin-film layer)
  let R0 = IorToFresnel0F32(iridescenceIor, outsideIor);
  let R12 = fresnel2F32(R0, cosTheta1);
  let R21 = R12;
  let T121 = 1.0 - R12;

  // Second interface (from the thin-film to the base material)
  let baseIor = Fresnel0ToIor(baseF0 + 0.0001); // guard against 1.0
  let R1 = IorToFresnel0Vec3f(baseIor, iridescenceIor);
  let R23 = fresnel2(R1, cosTheta2);

  // phi12 and phi23 define the base phases per interface and are approximated with 0.0
  // if the IOR of the hit material (iridescenceIor or baseIor) is higher
  // than the IOR of the previous material (outsideIor or iridescenceIor) and \u03C0 otherwise.
  // Also here, polarization is ignored.  float phi12 = 0.0;

  // First interface (from the outside to the thin-film layer)
  var phi12 = 0.0;
  if (iridescenceIor < outsideIor) { phi12 = M_PI; }
  let phi21 = M_PI - phi12;

  // Second interface (from the thin-film to the base material)
  var phi23 = vec3f(0.0);
  if (baseIor[0] < iridescenceIor) { phi23[0] = M_PI; }
  if (baseIor[1] < iridescenceIor) { phi23[1] = M_PI; }
  if (baseIor[2] < iridescenceIor) { phi23[2] = M_PI; }

  // OPD (optical path difference)
  let OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;
  // Phase shift
  let phi = vec3f(phi21) + phi23;

  // Compound terms
  let R123 = clamp(R12 * R23, vec3f(1e-5), vec3f(0.9999));
  let r123 = sqrt(R123);
  let Rs = (T121 * T121) * R23 / (vec3f(1.0) - R123);

  // Reflectance term for m = 0 (DC term amplitude)
  let C0 = R12 + Rs;
  var I = C0;

  // Reflectance term for m > 0 (pairs of diracs)
  var Cm = Rs - T121;
  for (var m = 1; m <= 2; m++)
  {
      Cm *= r123;
      let Sm = 2.0 * evalSensitivity(f32(m) * OPD, f32(m) * phi);
      I += Cm * Sm;
  }

  let F_iridescence = max(I, vec3f(0.0));

  return F_iridescence;
}

//https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#acknowledgments AppendixB
fn BRDF_lambertianIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, iridescenceFactor: f32, diffuseColor: vec3f, specularWeight: f32, VdotH: f32) -> vec3f
{
    let iridescenceFresnelMax = vec3f(max(max(iridescenceFresnel.r, iridescenceFresnel.g), iridescenceFresnel.b));

    let schlickFresnel = Schlick_to_F0_F90(f0, f90, VdotH);

    let F = mix(schlickFresnel, iridescenceFresnelMax, iridescenceFactor);

    // see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
    return (1.0 - specularWeight * F) * (diffuseColor / M_PI);
}

fn BRDF_specularGGXIridescence(f0: vec3f, f90: vec3f, iridescenceFresnel: vec3f, alphaRoughness: f32, iridescenceFactor: f32, specularWeight: f32, VdotH: f32, NdotL: f32, NdotV: f32, NdotH: f32) -> vec3f
{
    let F = mix(Schlick_to_F0_F90(f0, f90, VdotH), iridescenceFresnel, iridescenceFactor);
    let Vis = v_GGXCorrelated(NdotL, NdotV, alphaRoughness);
    let D = d_GGX(NdotH, alphaRoughness);

    return specularWeight * F * Vis * D;
}

#endif // RN_USE_IRIDESCENCE


////////////////////////////////////////
// lighting with a punctual light
////////////////////////////////////////
fn lightingWithPunctualLight(
  light: Light,
  normal_inWorld: vec3f,
  viewDirection: vec3f,
  NdotV: f32,
  albedo: vec3f,
  perceptualRoughness: f32,
  F0: vec3f,
  F90: vec3f,
  transmission: f32,
  ior: f32,
  clearcoat: f32,
  clearcoatRoughness: f32,
  clearcoatNormal_inWorld: vec3f,
  VdotNc: f32,
  attenuationColor: vec3f,
  attenuationDistance: f32,
  anisotropy: f32,
  anisotropicT: vec3f,
  anisotropicB: vec3f,
  BdotV: f32,
  TdotV: f32,
  sheenColor: vec3f,
  sheenRoughness: f32,
  albedoSheenScalingNdotV: f32,
  iridescenceFactor: f32,
  iridescenceFresnel: vec3f,
  specularWeight: f32,
  ) -> vec3f
{
  let alphaRoughness = perceptualRoughness * perceptualRoughness;

  // Fresnel
  let halfVector = normalize(light.direction + viewDirection);
  let VdotH = dot(viewDirection, halfVector);
  let F = fresnel(F0, F90, VdotH);

  let NdotL = clamp(dot(normal_inWorld, light.direction), Epsilon, 1.0);

  // Diffuse
#ifdef RN_USE_IRIDESCENCE
  let diffuseBrdf = BRDF_lambertianIridescence(F0, F90, iridescenceFresnel, iridescenceFactor, albedo, specularWeight, VdotH);
#else
  let diffuseBrdf = BRDF_lambertian(albedo, F, specularWeight);
#endif
  let pureDiffuse = diffuseBrdf * vec3f(NdotL) * light.attenuatedIntensity;

#ifdef RN_USE_TRANSMISSION
  let refractionVector = refract(-viewDirection, normal_inWorld, 1.0 / ior);
  var transmittedLightFromUnderSurface: Light = light;
  transmittedLightFromUnderSurface.pointToLight -= refractionVector;
  let transmittedLightDirectionFromUnderSurface = normalize(transmittedLightFromUnderSurface.pointToLight);
  transmittedLightFromUnderSurface.direction = transmittedLightDirectionFromUnderSurface;

  let Ht = normalize(viewDirection + transmittedLightFromUnderSurface.direction);
  let NdotHt = saturateEpsilonToOne(dot(normal_inWorld, Ht));
  let NdotLt = saturateEpsilonToOne(dot(normal_inWorld, transmittedLightFromUnderSurface.direction));

  var transmittedContrib = (vec3f(1.0) - F) * specular_btdf(alphaRoughness, NdotLt, NdotV, NdotHt) * albedo * transmittedLightFromUnderSurface.attenuatedIntensity;

#ifdef RN_USE_VOLUME
  transmittedContrib = volumeAttenuation(attenuationColor, attenuationDistance, transmittedContrib, length(transmittedLightFromUnderSurface.pointToLight));
#endif // RN_USE_VOLUME

  let diffuseContrib = mix(pureDiffuse, vec3f(transmittedContrib), transmission);
#else
  let diffuseContrib = pureDiffuse;
#endif // RN_USE_TRANSMISSION

  // Specular
  let NdotH = saturateEpsilonToOne(dot(normal_inWorld, halfVector));


#ifdef RN_USE_IRIDESCENCE
  let specularContrib = BRDF_specularGGXIridescence(F0, F90, iridescenceFresnel, alphaRoughness, iridescenceFactor, specularWeight, VdotH, NdotL, NdotV, NdotH) * vec3f(NdotL) * light.attenuatedIntensity;
#elif defined(RN_USE_ANISOTROPY)
  let TdotL = dot(anisotropicT, light.direction);
  let BdotL = dot(anisotropicB, light.direction);
  let TdotH = dot(anisotropicT, halfVector);
  let BdotH = dot(anisotropicB, halfVector);
  let specularContrib = BRDF_specularAnisotropicGGX(F, alphaRoughness, VdotH, NdotL, NdotV, NdotH, BdotV, TdotV, TdotL, BdotL, TdotH, BdotH, anisotropy) * vec3f(NdotL) * light.attenuatedIntensity;
#else
  let specularContrib = BRDF_specularGGX(NdotH, NdotL, NdotV, F, alphaRoughness, specularWeight) * vec3f(NdotL) * light.attenuatedIntensity;
#endif

  // Base Layer
  let baseLayer = diffuseContrib + specularContrib;

#ifdef RN_USE_SHEEN
  // Sheen
  let sheenContrib = sheen_brdf(sheenColor, sheenRoughness, NdotL, NdotV, NdotH) * NdotL * light.attenuatedIntensity;
  let albedoSheenScaling = min(
    albedoSheenScalingNdotV,
    1.0 - max3(sheenColor) * textureSample(sheenLutTexture, sheenLutSampler, vec2(NdotL, sheenRoughness)).r);
  let color = sheenContrib + baseLayer * albedoSheenScaling;
#else
  let color = baseLayer;
  let albedoSheenScaling = 1.0;
#endif // RN_USE_SHEEN

#ifdef RN_USE_CLEARCOAT
  // Clear Coat Layer
  let NdotHc = saturateEpsilonToOne(dot(clearcoatNormal_inWorld, halfVector));
  let LdotNc = saturateEpsilonToOne(dot(light.direction, clearcoatNormal_inWorld));
  let coated = coated_material_s(color, perceptualRoughness,
    clearcoatRoughness, clearcoat, VdotNc, LdotNc, NdotHc);
  let finalColor = coated;
#else
  let finalColor = color;
#endif // RN_USE_CLEARCOAT

  return finalColor;
}

fn IsotropicNDFFiltering(normal: vec3f, roughness2: f32) -> f32 {
  let SIGMA2 = 0.15915494;
  let KAPPA = 0.18;
  let dndu  = dpdx(normal);
  let dndv = dpdy(normal);
  let kernelRoughness2 = SIGMA2 * (dot(dndu, dndu) + dot(dndv, dndv));
  let clampedKernelRoughness2 = min(kernelRoughness2, KAPPA);
  let filteredRoughness2 = saturate(roughness2 + clampedKernelRoughness2);
  return filteredRoughness2;
}


// #param baseColorFactor: vec4<f32>; // initialValue=(1,1,1,1)
@group(1) @binding(1) var baseColorTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(1) var baseColorSampler: sampler;
// #param baseColorTexcoordIndex: f32; // initialValue=0
// #param baseColorTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)
// #param baseColorTextureRotation: f32; // initialValue=0

@group(1) @binding(2) var normalTexture: texture_2d<f32>; // initialValue=black
@group(2) @binding(2) var normalSampler: sampler;
// #param normalTexcoordIndex: f32; // initialValue=0
// #param normalTextureTransform: vec4<f32>; // initialValue=(1,1,0,0)
// #param normalTextureRotation: f32; // initialValue=0
// #param normalScale: f32; // initialValue=1

// #param shadingShiftFactor: f32; // initialValue=0.0
@group(1) @binding(3) var shadingShiftTexture: texture_2d<f32>; // initialValue=black
@group(2) @binding(3) var shadingShiftSampler: sampler;
// #param shadingShiftTexcoordIndex: f32; // initialValue=0
// #param shadingShiftTextureScale: f32; // initialValue=1.0

// #param shadingToonyFactor: f32; // initialValue=0.9
// #param shadeColorFactor: vec3<f32>; // initialValue=(0,0,0)
@group(1) @binding(4) var shadeMultiplyTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(4) var shadeMultiplySampler: sampler;
// #param shadeMultiplyTexcoordIndex: f32; // initialValue=0

@group(1) @binding(16) var diffuseEnvTexture: texture_cube<f32>; // initialValue=black
@group(2) @binding(16) var diffuseEnvSampler: sampler;
@group(1) @binding(17) var specularEnvTexture: texture_cube<f32>; // initialValue=black
@group(2) @binding(17) var specularEnvSampler: sampler;

// #param giEqualizationFactor: f32; // initialValue=0.9

@group(1) @binding(5) var matcapTexture: texture_2d<f32>; // initialValue=black
@group(2) @binding(5) var matcapSampler: sampler;
// #param matcapFactor: vec3<f32>; // initialValue=(1,1,1)
// #param parametricRimColorFactor: vec3<f32>; // initialValue=(0,0,0)
// #param parametricRimFresnelPowerFactor: f32; // initialValue=5.0
// #param parametricRimLiftFactor: f32; // initialValue=0.0
@group(1) @binding(6) var rimMultiplyTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(6) var rimMultiplySampler: sampler;
// #param rimMultiplyTexcoordIndex: f32; // initialValue=0
// #param rimLightingMixFactor: f32; // initialValue=1.0

// #param emissiveFactor: vec3<f32>; // initialValue=(0,0,0)
@group(1) @binding(7) var emissiveTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(7) var emissiveSampler: sampler;
// #param emissiveTexcoordIndex: f32; // initialValue=0

// #param outlineColorFactor: vec3<f32>; // initialValue=(0,0,0)
// #param outlineLightingMixFactor: f32; // initialValue=1.0

@group(1) @binding(8) var uvAnimationMaskTexture: texture_2d<f32>; // initialValue=white
@group(2) @binding(8) var uvAnimationMaskSampler: sampler;
// #param uvAnimationMaskTexcoordIndex: f32; // initialValue=0
// #param uvAnimationScrollXSpeedFactor: f32; // initialValue=0.0
// #param uvAnimationScrollYSpeedFactor: f32; // initialValue=0.0
// #param uvAnimationRotationSpeedFactor: f32; // initialValue=0.0

// #param inverseEnvironment: bool; // initialValue=false
// #param iblParameter: vec4<f32>; // initialValue=(1,1,1,1), isInternalSetting=true
// #param hdriFormat: vec2<i32>; // initialValue=(0,0), isInternalSetting=true
// #param alphaCutoff: f32; // initialValue=0.5
// #param makeOutputSrgb: bool; // initialValue=false

fn get_irradiance(normal_forEnv: vec3f, hdriFormat: vec2<i32>) -> vec3f {
  let diffuseTexel: vec4f = textureSample(diffuseEnvTexture, diffuseEnvSampler, normal_forEnv);

  var irradiance: vec3f;
  if (hdriFormat.x == 0) {
    // LDR_SRGB
    irradiance = srgbToLinear(diffuseTexel.rgb);
  }
  else if (hdriFormat.x == 3) {
    // RGBE
    irradiance = diffuseTexel.rgb * pow(2.0, diffuseTexel.a*255.0-128.0);
  }
  else {
    irradiance = diffuseTexel.rgb;
  }

  return irradiance;
}

fn get_radiance(reflection: vec3f, lod: f32, hdriFormat: vec2<i32>) -> vec3f {
  let specularTexel = textureSampleLevel(specularEnvTexture, specularEnvSampler, reflection, lod);

  var radiance: vec3f;
  if (hdriFormat.y == 0) {
    // LDR_SRGB
    radiance = srgbToLinear(specularTexel.rgb);
  }
  else if (hdriFormat.y == 3) {
    // RGBE
    radiance = specularTexel.rgb * pow(2.0, specularTexel.a*255.0-128.0);
  }
  else {
    radiance = specularTexel.rgb;
  }

  return radiance;
}

#ifdef RN_USE_SHEEN
fn sheenIBL(NdotV: f32, sheenPerceptualRoughness: f32, sheenColor: vec3f, iblParameter: vec4f, reflection: vec3f, hdriFormat: vec2i) -> vec3f
{
  let mipCount = iblParameter.x;
  let lod = (sheenPerceptualRoughness * (mipCount - 1.0));

  let sheenLutUV = vec2f(NdotV, sheenPerceptualRoughness);
  let brdf = textureSample(sheenLutTexture, sheenLutSampler, sheenLutUV).b;
  var sheenLight = get_radiance(reflection, lod, hdriFormat);
  let IBLSpecularContribution = iblParameter.z;
  sheenLight *= IBLSpecularContribution;

  return sheenLight * sheenColor * brdf;
}
#endif

fn getNormalForEnv(rotEnvMatrix: mat3x3<f32>, normal_inWorld: vec3f, materialSID: u32) -> vec3f {
  var normal_forEnv = rotEnvMatrix * normal_inWorld;
  if (get_inverseEnvironment(materialSID, 0)) {
    normal_forEnv.x *= -1.0;
  }
  return normal_forEnv;
}

fn getReflection(rotEnvMatrix: mat3x3<f32>, viewDirection: vec3f, normal_inWorld: vec3f,
  materialSID: u32, perceptualRoughness: f32,
  anisotropy: f32, anisotropyDirection: vec3f
  ) -> vec3f {
#ifdef RN_USE_ANISOTROPY
  let tangentRoughness = mix(perceptualRoughness, 1.0, anisotropy * anisotropy);
  let anisotropicTangent  = cross(anisotropyDirection, viewDirection);
  let anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);
  let bendFactor          = 1.0 - anisotropy * (1.0 - perceptualRoughness);
  let bendFactorPow4      = bendFactor * bendFactor * bendFactor * bendFactor;
  let bentNormal          = normalize(mix(anisotropicNormal, normal_inWorld, bendFactorPow4));
  var reflection = rotEnvMatrix * reflect(-viewDirection, bentNormal);
#else
  var reflection = rotEnvMatrix * reflect(-viewDirection, normal_inWorld);
#endif
  if (get_inverseEnvironment(materialSID, 0)) {
    reflection.x *= -1.0;
  }
  return reflection;
}

fn scaleForLod(perceptualRoughness: f32, ior: f32) -> f32
{
  // Scale roughness to the range [0, 1],
  // ior=1.0 will be scale 0,
  // ior=1.5 will be scale 1.0,
  // ior=2 will be scale 1.0 (clamped)
  //

  let scale = clamp(ior * 2.0 - 2.0, 0.0, 1.0);
  return perceptualRoughness * scale;
}

#ifdef RN_USE_TRANSMISSION
fn get_sample_from_backbuffer(materialSID: u32, sampleCoord: vec2f, perceptualRoughness: f32, ior: f32) -> vec3f {
  let vrState: vec2<i32> = get_vrState(0, 0);
  let backBufferTextureSize = vec2f(textureDimensions(backBufferTexture, 0));
  var backBufferTextureLength = max(backBufferTextureSize.x, backBufferTextureSize.y);
  var newSampleCoord = sampleCoord;
  newSampleCoord.y = 1.0 - newSampleCoord.y;
  if (vrState.x == 1) { // For VR
    backBufferTextureLength = max(backBufferTextureSize.x / 2.0, backBufferTextureSize.y);
    newSampleCoord.x = sampleCoord.x * 0.5;
    if (vrState.y == 1) { // For right eye
      newSampleCoord.x += 0.5;
    }
  }
  let framebufferLod = log2(backBufferTextureLength) * scaleForLod(perceptualRoughness, ior);

  let transmittedLight = textureSampleLevel(backBufferTexture, backBufferSampler, newSampleCoord, framebufferLod).rgb;

  return transmittedLight;
}

// from glTF Sample Viewer: https://github.com/KhronosGroup/glTF-Sample-Viewer
fn getVolumeTransmissionRay(n: vec3f, v: vec3f, thickness: f32, ior: f32, instanceInfo: u32) -> vec3f
{
  let refractionVector = refract(-v, normalize(n), 1.0 / ior);
  let worldMatrix = get_worldMatrix(instanceInfo);

  var modelScale: vec3f;
  modelScale.x = length(vec3f(worldMatrix[0].xyz));
  modelScale.y = length(vec3f(worldMatrix[1].xyz));
  modelScale.z = length(vec3f(worldMatrix[2].xyz));

  return normalize(refractionVector) * thickness * modelScale;
}
#endif // RN_USE_TRANSMISSION

struct IblResult
{
  specular: vec3f,
  diffuse: vec3f,
  FssEss: vec3f,
};


#ifdef RN_USE_IRIDESCENCE
fn getIBLRadianceGGXWithIridescence(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,
  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2i, rotEnvMatrix: mat3x3<f32>,
  normal_forEnv: vec3f, reflection: vec3f, iridescenceFresnel: vec3f, iridescence: f32, specularWeight: f32) -> IblResult
{
  // get radiance
  let mipCount = iblParameter.x;
  let lod = (perceptualRoughness * (mipCount - 1.0));
  let radiance = get_radiance(reflection, lod, hdriFormat);

  // Roughness dependent fresnel
  let kS = fresnelSchlickRoughnessWithIridescence(F0, NdotV, perceptualRoughness, iridescenceFresnel, iridescence);
  let f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss = kS * f_ab.x + f_ab.y;
  var result: IblResult;
  result.FssEss = FssEss;

  // Specular IBL
  var specular = FssEss * radiance * specularWeight;

  // scale with user parameters
  let IBLSpecularContribution = iblParameter.z;
  specular *= IBLSpecularContribution;

  result.specular = specular;

  return result;
}

fn getIBLRadianceLambertianWithIridescence(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,
  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2i, rotEnvMatrix: mat3x3<f32>,
  normal_forEnv: vec3f, reflection: vec3f, iridescenceF0: vec3f, iridescence: f32, specularWeight: f32) -> IblResult
{
  // get irradiance
  let irradiance = get_irradiance(normal_forEnv, hdriFormat);

  // Use the maximum component of the iridescence Fresnel color
  // Maximum is used instead of the RGB value to not get inverse colors for the diffuse BRDF
  let iridescenceF0Max = vec3f(max(max(iridescenceF0.r, iridescenceF0.g), iridescenceF0.b));

  // Blend between base F0 and iridescence F0
  let mixedF0 = mix(F0, iridescenceF0Max, iridescence);

  // Roughness dependent fresnel
  let kS = fresnelSchlickRoughness(mixedF0, NdotV, perceptualRoughness);
  let f_ab = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss = specularWeight * kS * f_ab.x + f_ab.y;
  var result: IblResult;
  result.FssEss = FssEss;

  // Multiple scattering, Fdez-Aguera's approach
  let Ems = (1.0 - (f_ab.x + f_ab.y));
  let F_avg = specularWeight * (mixedF0 + (1.0 - mixedF0) / 21.0);
  let FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);
  let k_D = albedo * (1.0 - FssEss - FmsEms);

  // Diffuse IBL
  var diffuse = (FmsEms + k_D) * irradiance;

  // scale with user parameters
  let IBLDiffuseContribution = iblParameter.y;
  diffuse *= IBLDiffuseContribution;

  result.diffuse = diffuse;

  return result;
}
#endif // RN_USE_IRIDESCENCE

fn getIBLRadianceLambertian(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,
  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, rotEnvMatrix: mat3x3<f32>,
  normal_forEnv: vec3f, reflection: vec3f, specularWeight: f32) -> IblResult
{
  // get irradiance
  let irradiance: vec3f = get_irradiance(normal_forEnv, hdriFormat);

  // Roughness dependent fresnel
  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss: vec3f = specularWeight * kS * f_ab.x + f_ab.y;
  var result: IblResult;
  result.FssEss = FssEss;

  // Multiple scattering, Fdez-Aguera's approach
  let Ems = (1.0 - (f_ab.x + f_ab.y));
  let F_avg: vec3f = specularWeight * (F0 + (1.0 - F0) / 21.0);
  let FmsEms: vec3f = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);
  let k_D: vec3f = albedo * (1.0 - FssEss - FmsEms);

  // Diffuse IBL
  var diffuse: vec3f = (FmsEms + k_D) * irradiance;

  // scale with user parameters
  let IBLDiffuseContribution = iblParameter.y;
  diffuse *= IBLDiffuseContribution;

  result.diffuse = diffuse;

  return result;
}

fn getIBLRadianceGGX(materialSID: u32, NdotV: f32, viewDirection: vec3f, albedo: vec3f, F0: vec3f,
  perceptualRoughness: f32, iblParameter: vec4f, hdriFormat: vec2<i32>, rotEnvMatrix: mat3x3<f32>,
  normal_forEnv: vec3f, reflection: vec3f, specularWeight: f32) -> IblResult
{
  // get radiance
  let mipCount = iblParameter.x;
  let lod = (perceptualRoughness * (mipCount - 1.0));
  let radiance: vec3f = get_radiance(reflection, lod, hdriFormat);

  // Roughness dependent fresnel
  let kS: vec3f = fresnelSchlickRoughness(F0, NdotV, perceptualRoughness);
  let f_ab: vec2f = envBRDFApprox(perceptualRoughness, NdotV);
  let FssEss: vec3f = kS * f_ab.x + f_ab.y;
  var result: IblResult;
  result.FssEss = FssEss;

  // Specular IBL
  var specular: vec3f = FssEss * radiance * specularWeight;

  // scale with user parameters
  let IBLSpecularContribution = iblParameter.z;
  specular *= IBLSpecularContribution;

  result.specular = specular;

  return result;
}

fn IBLContribution(materialSID: u32, cameraSID: u32, normal_inWorld: vec3f, NdotV: f32, viewDirection: vec3f,
  albedo: vec3f, F0: vec3f, perceptualRoughness: f32,
  clearcoatRoughness: f32, clearcoatNormal_inWorld: vec3f, clearcoat: f32, VdotNc: f32, geomNormal_inWorld: vec3f,
  transmission: f32, v_position_inWorld: vec3f, instanceInfo: u32, thickness: f32, ior: f32,
  sheenColor: vec3f, sheenRoughness: f32, albedoSheenScalingNdotV: f32,
  iridescenceFresnel: vec3f, iridescenceF0: vec3f, iridescence: f32,
  anisotropy: f32, anisotropyDirection: vec3f, specularWeight: f32
  ) -> vec3f
{
  let iblParameter: vec4f = get_iblParameter(materialSID, 0);
  let rot = iblParameter.w;
  let rotEnvMatrix = mat3x3<f32>(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  let hdriFormat: vec2<i32> = get_hdriFormat(materialSID, 0);

  let normal_forEnv: vec3f = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  let reflection: vec3f = getReflection(rotEnvMatrix, viewDirection, normal_inWorld, materialSID, perceptualRoughness, anisotropy, anisotropyDirection);

  // IBL
#ifdef RN_USE_IRIDESCENCE
  let baseRadianceResult: IblResult = getIBLRadianceGGXWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,
    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceFresnel, iridescence, specularWeight);
  let baseLambertianResult: IblResult = getIBLRadianceLambertianWithIridescence(materialSID, NdotV, viewDirection, albedo, F0,
    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, iridescenceF0, iridescence, specularWeight);
#else
  let baseRadianceResult: IblResult = getIBLRadianceGGX(materialSID, NdotV, viewDirection, albedo, F0,
    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);
  let baseLambertianResult: IblResult = getIBLRadianceLambertian(materialSID, NdotV, viewDirection, albedo, F0,
    perceptualRoughness, iblParameter, hdriFormat, rotEnvMatrix, normal_forEnv, reflection, specularWeight);
#endif

#ifdef RN_USE_TRANSMISSION
  let refractedRay = getVolumeTransmissionRay(geomNormal_inWorld, viewDirection, thickness, ior, instanceInfo);
  let refractedRayFromVPosition = v_position_inWorld + refractedRay;
  let ndcPoint = get_projectionMatrix(cameraSID, 0) * get_viewMatrix(cameraSID, 0) * vec4f(refractedRayFromVPosition, 1.0);
  var refractionCoords = ndcPoint.xy / ndcPoint.w;
  refractionCoords += 1.0;
  refractionCoords /= 2.0;
  var transmittedLight = get_sample_from_backbuffer(materialSID, refractionCoords, perceptualRoughness, ior);

#ifdef RN_USE_VOLUME
  let attenuationColor = get_attenuationColor(materialSID, 0);
  let attenuationDistance = get_attenuationDistance(materialSID, 0);
  transmittedLight = volumeAttenuation(attenuationColor, attenuationDistance, transmittedLight, length(refractedRay));
#endif

  let transmissionComp = (vec3f(1.0) - baseRadianceResult.FssEss) * transmittedLight * albedo;
  let diffuse = mix(baseLambertianResult.diffuse, transmissionComp, transmission);
  let base = diffuse + baseRadianceResult.specular;
#else
  let base: vec3f = baseLambertianResult.diffuse + baseRadianceResult.specular;
#endif

#ifdef RN_USE_SHEEN
  let sheen = sheenIBL(NdotV, sheenRoughness, sheenColor, iblParameter, reflection, hdriFormat);
  let color = sheen + base * albedoSheenScalingNdotV;
#else
  let color = base;
#endif

#ifdef RN_USE_CLEARCOAT
  let VdotNg = dot(geomNormal_inWorld, viewDirection);
  let clearcoatNormal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  let coatResult: IblResult = getIBLRadianceGGX(materialSID, VdotNc, viewDirection, vec3f(0.0), F0,
    clearcoatRoughness, iblParameter, hdriFormat, rotEnvMatrix, clearcoatNormal_forEnv, reflection, specularWeight);
  let coatLayer = coatResult.specular;

  let clearcoatFresnel = 0.04 + (1.0 - 0.04) * pow(1.0 - abs(VdotNc), 5.0);
  let coated = color * vec3f(1.0 - clearcoat * clearcoatFresnel) + vec3f(coatLayer * clearcoat);
  return coated;
#else
  return color;
#endif
}



fn linearstep(a: f32, b: f32, t: f32) -> f32 {
  return clamp((t - a) / (b - a), 0.0, 1.0);
}

fn uvAnimation(origUv: vec2f, time: f32, uvAnimMask: f32, uvAnimationScrollXSpeedFactor: f32, uvAnimationScrollYSpeedFactor: f32, uvAnimationRotationSpeedFactor: f32) -> vec2f {
  let scrollX = uvAnimationScrollXSpeedFactor * time;
  let scrollY = uvAnimationScrollYSpeedFactor * time;
  let rotation = uvAnimationRotationSpeedFactor * time;
  let rotationCos = cos(rotation * uvAnimMask);
  let rotationSin = sin(rotation * uvAnimMask);
  var uv = mat2x2f(rotationCos, -rotationSin, rotationSin, rotationCos) * (origUv - vec2f(0.5)) + vec2f(0.5);
  uv += vec2f(scrollX, scrollY) * uvAnimMask;
  return uv;
}

@fragment
fn main (
  input: VertexOutput,
  @builtin(front_facing) isFront: bool
) -> @location(0) vec4<f32> {
let materialSID = uniformDrawParameters.materialSid;
let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
let morphTargetNumber = uniformDrawParameters.morphTargetNumber;
let cameraSID = uniformDrawParameters.cameraSID;


  // uv animation
  let uvAnimationScrollXSpeedFactor = get_uvAnimationScrollXSpeedFactor(materialSID, 0);
  let uvAnimationScrollYSpeedFactor = get_uvAnimationScrollYSpeedFactor(materialSID, 0);
  let uvAnimationRotationSpeedFactor = get_uvAnimationRotationSpeedFactor(materialSID, 0);
  let uvAnimationMaskTexcoordIndex = u32(get_uvAnimationMaskTexcoordIndex(materialSID, 0));
  let uvAnimationMaskTexcoord = getTexcoord(uvAnimationMaskTexcoordIndex, input);
  let uvAnimMask = textureSample(uvAnimationMaskTexture, uvAnimationMaskSampler, uvAnimationMaskTexcoord).b;
  let time = get_time(0, 0);

  // base color
  let baseColorTextureTransform = get_baseColorTextureTransform(materialSID, 0);
  let baseColorTextureRotation = get_baseColorTextureRotation(materialSID, 0);
  let baseColorTexcoordIndex = u32(get_baseColorTexcoordIndex(materialSID, 0));
  var baseColorTexcoord = getTexcoord(baseColorTexcoordIndex, input);
  baseColorTexcoord = uvAnimation(baseColorTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  let baseColorTexUv = uvTransform(baseColorTextureTransform.xy, baseColorTextureTransform.zw, baseColorTextureRotation, baseColorTexcoord);
  var baseColorTexture = textureSample(baseColorTexture, baseColorSampler, baseColorTexUv);
  baseColorTexture = vec4(srgbToLinear(baseColorTexture.rgb), baseColorTexture.a);
  let baseColorFactor = get_baseColorFactor(materialSID, 0);
  let baseColorTerm = baseColorTexture.rgb * baseColorFactor.rgb;

  // shade color
  let shadeColorFactor = get_shadeColorFactor(materialSID, 0);
  let shadeMultiplyTexcoordIndex = u32(get_shadeMultiplyTexcoordIndex(materialSID, 0));
  var shadeMultiplyTexcoord = getTexcoord(shadeMultiplyTexcoordIndex, input);
  shadeMultiplyTexcoord = uvAnimation(shadeMultiplyTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  var shadeMultiplyTexture = textureSample(shadeMultiplyTexture, shadeMultiplySampler, shadeMultiplyTexcoord);
  shadeMultiplyTexture = vec4(srgbToLinear(shadeMultiplyTexture.rgb), shadeMultiplyTexture.a);
  let shadeColorTerm = shadeColorFactor * shadeMultiplyTexture.rgb;

  // shading shift
  let shadingShiftTexcoordIndex = u32(get_shadingShiftTexcoordIndex(materialSID, 0));
  var shadingShiftTexcoord = getTexcoord(shadingShiftTexcoordIndex, input);
  shadingShiftTexcoord = uvAnimation(shadingShiftTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  var shadingShiftTexture = textureSample(shadingShiftTexture, shadingShiftSampler, shadingShiftTexcoord).r;
  let shadingShiftTextureScale = get_shadingShiftTextureScale(materialSID, 0);

  // emissive
  let emissiveFactor = get_emissiveFactor(materialSID, 0);
  let emissiveTexcoordIndex = u32(get_emissiveTexcoordIndex(materialSID, 0));
  var emissiveTexcoord = getTexcoord(emissiveTexcoordIndex, input);
  emissiveTexcoord = uvAnimation(emissiveTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  var emissiveTexture = textureSample(emissiveTexture, emissiveSampler, emissiveTexcoord);
  emissiveTexture = vec4(srgbToLinear(emissiveTexture.rgb), emissiveTexture.a);
  let emissive = emissiveFactor * emissiveTexture.rgb;

  // alpha
  let alpha = baseColorTexture.a * baseColorFactor.a;
#ifdef RN_ALPHATEST_ON
  let cutoff = get_alphaCutoff(materialSID, 0);
  if(alpha < cutoff) { discard; }
#endif

  // view vector
  let viewPosition = get_viewPosition(cameraSID, 0);
  let viewVector = viewPosition - input.position_inWorld.xyz;
  let viewDirection = normalize(viewVector);

  // Normal
  var normal_inWorld = normalize(input.normal_inWorld);
#ifdef RN_USE_NORMAL_TEXTURE
  let normalTextureTransform = get_normalTextureTransform(materialSID, 0);
  let normalTextureRotation = get_normalTextureRotation(materialSID, 0);
  let normalTexcoordIndex = u32(get_normalTexcoordIndex(materialSID, 0));
  var normalTexcoord = getTexcoord(normalTexcoordIndex, input);
  normalTexcoord = uvAnimation(normalTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  let normalTexUv = uvTransform(normalTextureTransform.xy, normalTextureTransform.zw, normalTextureRotation, normalTexcoord);
  let normal: vec3f = textureSample(normalTexture, normalSampler, normalTexUv).xyz * 2.0 - 1.0;
  let TBN: mat3x3<f32> = getTBN(normal_inWorld, input, viewDirection, normalTexUv, isFront);
  normal_inWorld = normalize(TBN * normal);
#endif

#ifdef RN_MTOON_IS_OUTLINE
  normal_inWorld *= -1.0;
#endif

  // direct lighting
  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation
  var rt0 = vec4f(0.0, 0.0, 0.0, 1.0);
  var directLighting = vec3f(0.0);
  let lightNumber = u32(get_lightNumber(0u, 0u));
  for (var i = 0u; i < lightNumber; i++) {
    let light: Light = getLight(i, input.position_inWorld.xyz);
    var shading = dot(light.direction, normal_inWorld);
    let shadingShiftFactor = get_shadingShiftFactor(materialSID, 0);
    shading += shadingShiftFactor + shadingShiftTexture * shadingShiftTextureScale;
    let shadingToonyFactor = get_shadingToonyFactor(materialSID, 0);
    shading = linearstep(-1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading);

    var color = mix(shadeColorTerm, baseColorTerm, shading);
    color = color * light.attenuatedIntensity * RECIPROCAL_PI;
    directLighting += light.attenuatedIntensity;
    rt0 += vec4f(color, rt0.a);
  }

  // indirect lighting
  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation-1
  let giEqualizationFactor = get_giEqualizationFactor(materialSID, 0);
  let worldUpVector = vec3f(0.0, 1.0, 0.0);
  let worldDownVector = vec3f(0.0, -1.0, 0.0);
  let iblParameter = get_iblParameter(materialSID, 0);
  let rot = iblParameter.w;
  let IBLDiffuseContribution = iblParameter.y;
  let rotEnvMatrix = mat3x3f(cos(rot), 0.0, -sin(rot), 0.0, 1.0, 0.0, sin(rot), 0.0, cos(rot));
  let normal_forEnv = getNormalForEnv(rotEnvMatrix, normal_inWorld, materialSID);
  let hdriFormat = get_hdriFormat(materialSID, 0);
  let rawGiUp = get_irradiance(worldUpVector, hdriFormat) * IBLDiffuseContribution;
  let rawGiDown = get_irradiance(worldDownVector, hdriFormat) * IBLDiffuseContribution;
  let rawGiNormal = get_irradiance(normal_forEnv, hdriFormat) * IBLDiffuseContribution;
  let uniformedGi = (rawGiUp + rawGiDown) / 2.0;
  let passthroughGi = rawGiNormal;
  let gi = mix(uniformedGi, passthroughGi, giEqualizationFactor);
  rt0 += vec4f(gi * baseColorTerm * RECIPROCAL_PI, rt0.a);

  // rim lighting
  // https://github.com/vrm-c/vrm-specification/blob/282edef7b8de6044d782afdab12b14bd8ccf0630/specification/VRMC_materials_mtoon-1.0/README.ja.md#implementation-2
  var rim = vec3f(0.0);
  let worldViewX = normalize(vec3f(viewDirection.z, 0.0, -viewDirection.x));
  let worldViewY = cross(viewDirection, worldViewX);
  let matcapUv = vec2f( dot(worldViewX, normal_inWorld), dot(worldViewY, normal_inWorld)) * 0.495 + 0.5;
  let epsilon = 0.00001;
  let matcapFactor = srgbToLinear(get_matcapFactor(materialSID, 0));
  rim = matcapFactor * textureSample(matcapTexture, matcapSampler, matcapUv).rgb;
  let parametricRimLiftFactor = get_parametricRimLiftFactor(materialSID, 0);
  var parametricRim = clamp( 1.0 - dot(normal_inWorld, viewVector) + parametricRimLiftFactor, 0.0, 1.0);
  let parametricRimFresnelPowerFactor = get_parametricRimFresnelPowerFactor(materialSID, 0);
  parametricRim = pow(parametricRim, max(parametricRimFresnelPowerFactor, epsilon));
  let parametricRimColorFactor = get_parametricRimColorFactor(materialSID, 0);
  rim += parametricRim * parametricRimColorFactor;
  let rimMultiplyTexcoordIndex = u32(get_rimMultiplyTexcoordIndex(materialSID, 0));
  var rimMultiplyTexcoord = getTexcoord(rimMultiplyTexcoordIndex, input);
  rimMultiplyTexcoord = uvAnimation(rimMultiplyTexcoord, time, uvAnimMask, uvAnimationScrollXSpeedFactor, uvAnimationScrollYSpeedFactor, uvAnimationRotationSpeedFactor);
  rim *= srgbToLinear(textureSample(rimMultiplyTexture, rimMultiplySampler, rimMultiplyTexcoord).rgb);
  let rimLightingMixFactor = get_rimLightingMixFactor(materialSID, 0);
  rim *= mix(vec3(1.0), directLighting + gi, rimLightingMixFactor);
  rt0 += vec4f(rim, rt0.a);

  // emissive
  rt0 += vec4f(emissive, rt0.a);

#ifdef RN_MTOON_IS_OUTLINE
  let outlineColorFactor = get_outlineColorFactor(materialSID, 0);
  let outlineLightingMixFactor = get_outlineLightingMixFactor(materialSID, 0);
  rt0 = vec4f(outlineColorFactor * mix(vec3f(1.0), rt0.xyz, outlineLightingMixFactor), rt0.a);
#endif

  let makeOutputSrgb = get_makeOutputSrgb(materialSID, 0);
  rt0 = vec4f(select(rt0.rgb, linearToSrgb(rt0.rgb), makeOutputSrgb), rt0.a);

  rt0.a = alpha;
  rt0 *= vec4f(alpha, alpha, alpha, 1.0);

  return rt0;
}
`, shaderStage: "fragment", isFragmentShader: true };
  }
});

// src/foundation/materials/contents/MToon1MaterialContent.ts
var _MToon1MaterialContent, MToon1MaterialContent;
var init_MToon1MaterialContent = __esm({
  "src/foundation/materials/contents/MToon1MaterialContent.ts"() {
    "use strict";
    init_AbstractMaterialContent();
    init_MToon1SingleShader_vert();
    init_MToon1SingleShader_frag();
    init_MToon1SingleShader_vert2();
    init_MToon1SingleShader_frag2();
    init_ComponentRepository();
    init_CameraComponent();
    init_ComponentType();
    init_CompositionType();
    init_Config();
    init_ShaderType();
    init_VectorN();
    init_CGAPIResourceRepository();
    init_ShaderSemantics();
    init_Sampler();
    init_TextureParameter();
    init_DummyTextures();
    init_HdriFormat();
    init_MutableVector4();
    init_MutableVector2();
    _MToon1MaterialContent = class _MToon1MaterialContent extends AbstractMaterialContent {
      constructor(materialName, isMorphing, isSkinning, isLighting, isOutline) {
        super(materialName, {
          isMorphing,
          isSkinning,
          isLighting
        });
        const shaderSemanticsInfoArray = this.doShaderReflection(MToon1SingleShader_vert_default, MToon1SingleShader_frag_default, MToon1SingleShader_vert_default2, MToon1SingleShader_frag_default2);
        if (!_MToon1MaterialContent.__diffuseIblCubeMapSampler.created) {
          _MToon1MaterialContent.__diffuseIblCubeMapSampler.create();
        }
        if (!_MToon1MaterialContent.__specularIblCubeMapSampler.created) {
          _MToon1MaterialContent.__specularIblCubeMapSampler.create();
        }
        if (isLighting) {
          this.__definitions += "#define RN_IS_LIGHTING\n";
        }
        if (isSkinning) {
          this.__definitions += "#define RN_IS_SKINNING\n";
        }
        if (isMorphing) {
          this.__definitions += "#define RN_IS_MORPHING\n";
          shaderSemanticsInfoArray.push({
            semantic: "dataTextureMorphOffsetPosition",
            componentType: ComponentType.Int,
            compositionType: CompositionType.ScalarArray,
            arrayLength: Config.maxVertexMorphNumberInShader,
            stage: ShaderType.VertexShader,
            isInternalSetting: true,
            initialValue: new VectorN(new Int32Array(Config.maxVertexMorphNumberInShader)),
            min: -Number.MAX_VALUE,
            max: Number.MAX_VALUE,
            needUniformInDataTextureMode: true
          }, {
            semantic: "morphWeights",
            componentType: ComponentType.Float,
            compositionType: CompositionType.ScalarArray,
            arrayLength: Config.maxVertexMorphNumberInShader,
            stage: ShaderType.VertexShader,
            isInternalSetting: true,
            initialValue: new VectorN(new Float32Array(Config.maxVertexMorphNumberInShader)),
            min: -Number.MAX_VALUE,
            max: Number.MAX_VALUE,
            needUniformInDataTextureMode: true
          });
        }
        if (isOutline) {
          this.__definitions += "#define RN_MTOON_IS_OUTLINE\n";
        }
        this.setShaderSemanticsInfoArray(shaderSemanticsInfoArray);
      }
      setMaterialParameters(material, isOutline, materialJson) {
        if (isOutline) {
          material.cullFace = true;
          material.cullFaceBack = false;
        } else {
          if (materialJson.doubleSided) {
            material.cullFace = false;
          } else {
            material.cullFace = true;
            material.cullFaceBack = true;
          }
        }
        if (materialJson.alphaMode === "MASK") {
          this.__definitions += "#define RN_ALPHATEST_ON\n";
        }
      }
      _setInternalSettingParametersToGpuWebGpu({ material, args }) {
        const { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType } = _MToon1MaterialContent.__setupHdriParameters(args);
        const tmp_vector4 = AbstractMaterialContent.__tmp_vector4;
        tmp_vector4.x = mipmapLevelNumber;
        tmp_vector4.y = meshRenderComponent.diffuseCubeMapContribution;
        tmp_vector4.z = meshRenderComponent.specularCubeMapContribution;
        tmp_vector4.w = meshRenderComponent.rotationOfCubeMap;
        material.setParameter("iblParameter", tmp_vector4);
        const tmp_vector2 = AbstractMaterialContent.__tmp_vector2;
        tmp_vector2.x = diffuseHdriType;
        tmp_vector2.y = specularHdriType;
        material.setParameter("hdriFormat", tmp_vector2);
        const meshRendererComponent = args.entity.tryToGetMeshRenderer();
        if (meshRendererComponent != null && meshRendererComponent.diffuseCubeMap != null && meshRendererComponent.specularCubeMap != null) {
          const iblParameterVec4 = MutableVector4.zero();
          const hdriFormatVec2 = MutableVector2.zero();
          iblParameterVec4.x = meshRendererComponent.specularCubeMap.mipmapLevelNumber;
          iblParameterVec4.y = meshRendererComponent.diffuseCubeMapContribution;
          iblParameterVec4.z = meshRendererComponent.specularCubeMapContribution;
          iblParameterVec4.w = meshRendererComponent.rotationOfCubeMap;
          material.setParameter("iblParameter", iblParameterVec4);
          hdriFormatVec2.x = meshRendererComponent.diffuseCubeMap.hdriFormat.index;
          hdriFormatVec2.y = meshRendererComponent.specularCubeMap.hdriFormat.index;
          material.setParameter("hdriFormat", hdriFormatVec2);
        }
      }
      _setInternalSettingParametersToGpuWebGL({ material, shaderProgram, firstTime, args }) {
        if (args.setUniform) {
          this.setWorldMatrix(shaderProgram, args.worldMatrix);
          this.setNormalMatrix(shaderProgram, args.normalMatrix);
          this.setIsBillboard(shaderProgram, args.isBillboard);
          if (firstTime || args.isVr) {
            let cameraComponent = args.renderPass.cameraComponent;
            if (cameraComponent == null) {
              cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
            }
            this.setViewInfo(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
            this.setProjection(shaderProgram, cameraComponent, args.isVr, args.displayIdx);
          }
          if (firstTime) {
            this.setLightsInfo(shaderProgram, args.lightComponents, material, args.setUniform);
          }
          const skeletalComponent = args.entity.tryToGetSkeletal();
          this.setSkinning(shaderProgram, args.setUniform, skeletalComponent);
        }
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        if (args.diffuseCube && args.diffuseCube.isTextureReady) {
          webglResourceRepository.setUniform1iForTexture(shaderProgram, ShaderSemantics.DiffuseEnvTexture.str, [
            5,
            args.diffuseCube,
            _MToon1MaterialContent.__diffuseIblCubeMapSampler
          ]);
        } else {
          webglResourceRepository.setUniform1iForTexture(shaderProgram, ShaderSemantics.DiffuseEnvTexture.str, [
            5,
            dummyBlackCubeTexture
          ]);
        }
        if (args.specularCube && args.specularCube.isTextureReady) {
          webglResourceRepository.setUniform1iForTexture(shaderProgram, ShaderSemantics.SpecularEnvTexture.str, [
            6,
            args.specularCube,
            _MToon1MaterialContent.__specularIblCubeMapSampler
          ]);
        } else {
          webglResourceRepository.setUniform1iForTexture(shaderProgram, ShaderSemantics.SpecularEnvTexture.str, [
            6,
            dummyBlackCubeTexture
          ]);
        }
        if (args.setUniform) {
          if (firstTime) {
            const { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType } = _MToon1MaterialContent.__setupHdriParameters(args);
            webglResourceRepository.setUniformValue(shaderProgram, ShaderSemantics.IBLParameter.str, firstTime, {
              x: mipmapLevelNumber,
              y: meshRenderComponent.diffuseCubeMapContribution,
              z: meshRenderComponent.specularCubeMapContribution,
              w: meshRenderComponent.rotationOfCubeMap
            });
            webglResourceRepository.setUniformValue(shaderProgram, ShaderSemantics.HDRIFormat.str, firstTime, {
              x: diffuseHdriType,
              y: specularHdriType
            });
          }
        } else {
          const { mipmapLevelNumber, meshRenderComponent, diffuseHdriType, specularHdriType } = _MToon1MaterialContent.__setupHdriParameters(args);
          const tmp_vector4 = AbstractMaterialContent.__tmp_vector4;
          tmp_vector4.x = mipmapLevelNumber;
          tmp_vector4.y = meshRenderComponent.diffuseCubeMapContribution;
          tmp_vector4.z = meshRenderComponent.specularCubeMapContribution;
          tmp_vector4.w = meshRenderComponent.rotationOfCubeMap;
          material.setParameter("iblParameter", tmp_vector4);
          const tmp_vector2 = AbstractMaterialContent.__tmp_vector2;
          tmp_vector2.x = diffuseHdriType;
          tmp_vector2.y = specularHdriType;
          material.setParameter("hdriFormat", tmp_vector2);
        }
        const blendShapeComponent = args.entity.tryToGetBlendShape();
        this.setMorphInfo(shaderProgram, args.entity.getMesh(), args.primitive, blendShapeComponent);
      }
      static __setupHdriParameters(args) {
        let mipmapLevelNumber = 1;
        if (args.specularCube) {
          mipmapLevelNumber = args.specularCube.mipmapLevelNumber;
        }
        const meshRenderComponent = args.entity.getMeshRenderer();
        let diffuseHdriType = HdriFormat.LDR_SRGB.index;
        let specularHdriType = HdriFormat.LDR_SRGB.index;
        if (meshRenderComponent.diffuseCubeMap) {
          diffuseHdriType = meshRenderComponent.diffuseCubeMap.hdriFormat.index;
        }
        if (meshRenderComponent.specularCubeMap) {
          specularHdriType = meshRenderComponent.specularCubeMap.hdriFormat.index;
        }
        return {
          mipmapLevelNumber,
          meshRenderComponent,
          diffuseHdriType,
          specularHdriType
        };
      }
    };
    __name(_MToon1MaterialContent, "MToon1MaterialContent");
    __publicField(_MToon1MaterialContent, "__diffuseIblCubeMapSampler", new Sampler({
      minFilter: TextureParameter.Linear,
      magFilter: TextureParameter.Linear,
      wrapS: TextureParameter.ClampToEdge,
      wrapT: TextureParameter.ClampToEdge,
      wrapR: TextureParameter.ClampToEdge
    }));
    __publicField(_MToon1MaterialContent, "__specularIblCubeMapSampler", new Sampler({
      minFilter: TextureParameter.LinearMipmapLinear,
      magFilter: TextureParameter.Linear,
      wrapS: TextureParameter.ClampToEdge,
      wrapT: TextureParameter.ClampToEdge,
      wrapR: TextureParameter.ClampToEdge
    }));
    MToon1MaterialContent = _MToon1MaterialContent;
  }
});

// src/foundation/helpers/MaterialHelper.ts
function createMaterial(materialContent, maxInstancesNumber) {
  let group = 0;
  let isFull = false;
  do {
    const actualMaterialTypeName = materialContent.getMaterialSemanticsVariantName() + `__group${group}`;
    isFull = MaterialRepository.isFullOrOverOfThisMaterialType(actualMaterialTypeName);
    if (!isFull) {
      MaterialRepository.registerMaterial(actualMaterialTypeName, materialContent, maxInstancesNumber);
      const material = MaterialRepository.createMaterial(actualMaterialTypeName, materialContent);
      return material;
    }
    group++;
  } while (isFull);
  throw new Error("Failed to create material");
}
function reuseOrRecreateMaterial(currentMaterial, materialContent, maxInstancesNumber) {
  let material = currentMaterial;
  if (MaterialRepository.isMaterialCompatible(material, materialContent)) {
    material._materialContent = materialContent;
    material.makeShadersInvalidate();
    return material;
  } else {
    const materialSemanticsVariantName = materialContent.getMaterialSemanticsVariantName();
    MaterialRepository.registerMaterial(materialSemanticsVariantName, materialContent, maxInstancesNumber);
    material = MaterialRepository.createMaterial(materialSemanticsVariantName, materialContent);
    return material;
  }
}
function recreateMaterial(materialContent, maxInstancesNumber) {
  const materialSemanticsVariantName = materialContent.getMaterialSemanticsVariantName();
  MaterialRepository.forceRegisterMaterial(materialSemanticsVariantName, materialContent, maxInstancesNumber);
  const material = MaterialRepository.createMaterial(materialSemanticsVariantName, materialContent);
  return material;
}
function createPbrUberMaterial({ additionalName = "", isMorphing = true, isSkinning = true, isLighting = true, isClearCoat = false, isTransmission = false, isVolume = false, isSheen = false, isSpecular = false, isIridescence = false, isAnisotropy = false, isShadow = false, useTangentAttribute = false, useNormalTexture = true, maxInstancesNumber = Config.maxMaterialInstanceForEachType } = {}) {
  const materialName = `PbrUber_${additionalName}_`;
  let additionalShaderSemanticInfo = [];
  if (true) {
    additionalShaderSemanticInfo = [
      {
        semantic: "dataTextureMorphOffsetPosition",
        componentType: ComponentType.Int,
        compositionType: CompositionType.ScalarArray,
        arrayLength: Config.maxVertexMorphNumberInShader,
        stage: ShaderType.VertexShader,
        isInternalSetting: true,
        soloDatum: true,
        initialValue: new VectorN(new Int32Array(Config.maxVertexMorphNumberInShader)),
        min: -Number.MAX_VALUE,
        max: Number.MAX_VALUE,
        needUniformInDataTextureMode: true
      },
      {
        semantic: "morphWeights",
        componentType: ComponentType.Float,
        compositionType: CompositionType.ScalarArray,
        arrayLength: Config.maxVertexMorphNumberInShader,
        stage: ShaderType.VertexShader,
        isInternalSetting: true,
        soloDatum: true,
        initialValue: new VectorN(new Float32Array(Config.maxVertexMorphNumberInShader)),
        min: -Number.MAX_VALUE,
        max: Number.MAX_VALUE,
        needUniformInDataTextureMode: true
      }
    ];
  }
  const sampler = new Sampler({
    minFilter: TextureParameter.Linear,
    magFilter: TextureParameter.Linear,
    wrapS: TextureParameter.ClampToEdge,
    wrapT: TextureParameter.ClampToEdge
  });
  let textureSlotIdx = 8;
  if (isClearCoat) {
    additionalShaderSemanticInfo.push({
      semantic: "clearCoatTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyWhiteTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
    additionalShaderSemanticInfo.push({
      semantic: "clearCoatRoughnessTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyWhiteTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
    additionalShaderSemanticInfo.push({
      semantic: "clearCoatNormalTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyBlueTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
  }
  if (isTransmission) {
    additionalShaderSemanticInfo.push({
      semantic: "transmissionTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyWhiteTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
    additionalShaderSemanticInfo.push({
      semantic: "backBufferTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyBlackTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
  }
  if (isVolume) {
    additionalShaderSemanticInfo.push({
      semantic: "thicknessTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyWhiteTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
  }
  if (isSheen) {
    additionalShaderSemanticInfo.push({
      semantic: "sheenColorTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyWhiteTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
    additionalShaderSemanticInfo.push({
      semantic: "sheenRoughnessTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyWhiteTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
    additionalShaderSemanticInfo.push({
      semantic: "sheenLutTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        sheenLutTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
  }
  if (isSpecular) {
    additionalShaderSemanticInfo.push({
      semantic: "specularTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyWhiteTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
    additionalShaderSemanticInfo.push({
      semantic: "specularColorTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyWhiteTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
  }
  if (isIridescence) {
    additionalShaderSemanticInfo.push({
      semantic: "iridescenceTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyWhiteTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
    additionalShaderSemanticInfo.push({
      semantic: "iridescenceThicknessTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyWhiteTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
  }
  if (isAnisotropy) {
    additionalShaderSemanticInfo.push({
      semantic: "anisotropyTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyAnisotropyTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
  }
  if (isShadow) {
    additionalShaderSemanticInfo.push({
      semantic: "depthTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyWhiteTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
    additionalShaderSemanticInfo.push({
      semantic: "paraboloidDepthTexture",
      componentType: ComponentType.Int,
      compositionType: CompositionType.Texture2D,
      stage: ShaderType.PixelShader,
      initialValue: [
        textureSlotIdx++,
        dummyWhiteTexture,
        sampler
      ],
      min: 0,
      max: Number.MAX_VALUE
    });
  }
  const materialContent = new CustomMaterialContent({
    name: materialName,
    isSkinning,
    isLighting,
    isMorphing,
    vertexShader: PbrSingleShader_default,
    pixelShader: PbrSingleShader_default2,
    vertexShaderWebGpu: PbrSingleShader_default3,
    pixelShaderWebGpu: PbrSingleShader_default4,
    additionalShaderSemanticInfo
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  if (isLighting) {
    material.addShaderDefine("RN_IS_LIGHTING");
  }
  if (isShadow) {
    material.addShaderDefine("RN_USE_SHADOW_MAPPING");
  }
  if (useNormalTexture) {
    material.addShaderDefine("RN_USE_NORMAL_TEXTURE");
  }
  if (isClearCoat) {
    material.addShaderDefine("RN_USE_CLEARCOAT");
  }
  if (isTransmission) {
    material.addShaderDefine("RN_USE_TRANSMISSION");
  }
  if (isVolume) {
    material.addShaderDefine("RN_USE_VOLUME");
  }
  if (isSheen) {
    material.addShaderDefine("RN_USE_SHEEN");
  }
  if (isSpecular) {
    material.addShaderDefine("RN_USE_SPECULAR");
  }
  if (isIridescence) {
    material.addShaderDefine("RN_USE_IRIDESCENCE");
  }
  if (isAnisotropy) {
    material.addShaderDefine("RN_USE_ANISOTROPY");
  }
  material.addShaderDefine("RN_IS_SKINNING");
  return material;
}
function createClassicUberMaterial({ additionalName = "", isSkinning = true, isLighting = false, isMorphing = false, isShadow = false, maxInstancesNumber = Config.maxMaterialInstanceForEachType } = {}) {
  const materialName = `ClassicUber_${additionalName}_`;
  const additionalShaderSemanticInfo = [
    {
      semantic: "dataTextureMorphOffsetPosition",
      componentType: ComponentType.Int,
      compositionType: CompositionType.ScalarArray,
      arrayLength: Config.maxVertexMorphNumberInShader,
      stage: ShaderType.VertexShader,
      isInternalSetting: true,
      soloDatum: true,
      initialValue: new VectorN(new Int32Array(Config.maxVertexMorphNumberInShader)),
      min: -Number.MAX_VALUE,
      max: Number.MAX_VALUE,
      needUniformInDataTextureMode: true
    },
    {
      semantic: "morphWeights",
      componentType: ComponentType.Float,
      compositionType: CompositionType.ScalarArray,
      arrayLength: Config.maxVertexMorphNumberInShader,
      stage: ShaderType.VertexShader,
      isInternalSetting: true,
      soloDatum: true,
      initialValue: new VectorN(new Float32Array(Config.maxVertexMorphNumberInShader)),
      min: -Number.MAX_VALUE,
      max: Number.MAX_VALUE,
      needUniformInDataTextureMode: true
    }
  ];
  const materialContent = new CustomMaterialContent({
    name: materialName,
    isSkinning,
    isLighting,
    isMorphing,
    vertexShader: ClassicSingleShader_default,
    pixelShader: ClassicSingleShader_default2,
    vertexShaderWebGpu: ClassicSingleShader_default3,
    pixelShaderWebGpu: ClassicSingleShader_default4,
    additionalShaderSemanticInfo
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  if (isLighting) {
    material.addShaderDefine("RN_IS_LIGHTING");
  }
  if (isShadow) {
    material.addShaderDefine("RN_USE_SHADOW_MAPPING");
  }
  material.addShaderDefine("RN_USE_NORMAL_TEXTURE");
  material.addShaderDefine("RN_IS_SKINNING");
  return material;
}
function createParaboloidDepthMomentEncodeMaterial({ additionalName = "", isSkinning = true, isMorphing = false, maxInstancesNumber = Config.maxMaterialInstanceForEachType } = {}) {
  const materialName = `ParaboloidDepthMomentEncode_${additionalName}_`;
  const additionalShaderSemanticInfo = [
    {
      semantic: "dataTextureMorphOffsetPosition",
      componentType: ComponentType.Int,
      compositionType: CompositionType.ScalarArray,
      arrayLength: Config.maxVertexMorphNumberInShader,
      stage: ShaderType.VertexShader,
      isInternalSetting: true,
      soloDatum: true,
      initialValue: new VectorN(new Int32Array(Config.maxVertexMorphNumberInShader)),
      min: -Number.MAX_VALUE,
      max: Number.MAX_VALUE,
      needUniformInDataTextureMode: true
    },
    {
      semantic: "morphWeights",
      componentType: ComponentType.Float,
      compositionType: CompositionType.ScalarArray,
      arrayLength: Config.maxVertexMorphNumberInShader,
      stage: ShaderType.VertexShader,
      isInternalSetting: true,
      soloDatum: true,
      initialValue: new VectorN(new Float32Array(Config.maxVertexMorphNumberInShader)),
      min: -Number.MAX_VALUE,
      max: Number.MAX_VALUE,
      needUniformInDataTextureMode: true
    }
  ];
  const materialContent = new CustomMaterialContent({
    name: materialName,
    isSkinning,
    isLighting: true,
    isMorphing,
    vertexShader: ParaboloidDepthMomentEncodeShader_vert_default,
    pixelShader: ParaboloidDepthMomentEncodeShader_frag_default,
    additionalShaderSemanticInfo
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  material.addShaderDefine("RN_IS_SKINNING");
  return material;
}
function createDepthMomentEncodeMaterial({ additionalName = "", isSkinning = true, isMorphing = false, maxInstancesNumber = Config.maxMaterialInstanceForEachType } = {}) {
  const materialName = `DepthMomentEncode_${additionalName}_`;
  const additionalShaderSemanticInfo = [
    {
      semantic: "dataTextureMorphOffsetPosition",
      componentType: ComponentType.Int,
      compositionType: CompositionType.ScalarArray,
      arrayLength: Config.maxVertexMorphNumberInShader,
      stage: ShaderType.VertexShader,
      isInternalSetting: true,
      soloDatum: true,
      initialValue: new VectorN(new Int32Array(Config.maxVertexMorphNumberInShader)),
      min: -Number.MAX_VALUE,
      max: Number.MAX_VALUE,
      needUniformInDataTextureMode: true
    },
    {
      semantic: "morphWeights",
      componentType: ComponentType.Float,
      compositionType: CompositionType.ScalarArray,
      arrayLength: Config.maxVertexMorphNumberInShader,
      stage: ShaderType.VertexShader,
      isInternalSetting: true,
      soloDatum: true,
      initialValue: new VectorN(new Float32Array(Config.maxVertexMorphNumberInShader)),
      min: -Number.MAX_VALUE,
      max: Number.MAX_VALUE,
      needUniformInDataTextureMode: true
    }
  ];
  const materialContent = new CustomMaterialContent({
    name: materialName,
    isSkinning,
    isLighting: false,
    isMorphing,
    vertexShader: DepthMomentEncodeShader_default,
    pixelShader: DepthMomentEncodeShader_default2,
    additionalShaderSemanticInfo
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  material.addShaderDefine("RN_IS_SKINNING");
  return material;
}
function createFlatMaterial({ additionalName = "", isSkinning = true, isMorphing = false, maxInstancesNumber = Config.maxMaterialInstanceForEachType } = {}) {
  const materialName = `Flat_${additionalName}_`;
  const materialContent = new CustomMaterialContent({
    name: materialName,
    isSkinning,
    isLighting: false,
    isMorphing,
    vertexShader: FlatSingleShader_default,
    pixelShader: FlatSingleShader_default2,
    additionalShaderSemanticInfo: [],
    vertexShaderWebGpu: FlatSingleShader_default3,
    pixelShaderWebGpu: FlatSingleShader_default4
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  material.addShaderDefine("RN_IS_SKINNING");
  return material;
}
function createEnvConstantMaterial({ additionalName = "", maxInstancesNumber = 5, makeOutputSrgb = true } = {}) {
  const materialName = `EnvConstant_${additionalName}`;
  const materialContent = new CustomMaterialContent({
    name: materialName,
    isSkinning: false,
    isLighting: false,
    isMorphing: false,
    vertexShader: EnvConstantSingleShader_default,
    pixelShader: EnvConstantSingleShader_default2,
    vertexShaderWebGpu: EnvConstantSingleShader_default3,
    pixelShaderWebGpu: EnvConstantSingleShader_default4,
    additionalShaderSemanticInfo: []
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  material.setParameter("makeOutputSrgb", makeOutputSrgb ? 1 : 0);
  return material;
}
function createFXAA3QualityMaterial({ additionalName = "", maxInstancesNumber = 1 } = {}) {
  const materialName = `FXAA3Quality_${additionalName}`;
  const materialContent = new CustomMaterialContent({
    name: materialName,
    isSkinning: false,
    isLighting: false,
    isMorphing: false,
    vertexShader: FXAA3QualitySingleShader_default,
    pixelShader: FXAA3QualitySingleShader_default2,
    additionalShaderSemanticInfo: []
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  return material;
}
function createFurnaceTestMaterial({ additionalName = "", maxInstancesNumber = 1 } = {}) {
  const materialName = `FurnaceTest_${additionalName}`;
  const materialContent = new FurnaceTestMaterialContent(materialName);
  const material = createMaterial(materialContent, maxInstancesNumber);
  return material;
}
function createDepthEncodeMaterial({ additionalName = "", isSkinning = false, depthPow = 1, maxInstancesNumber = 10 } = {}) {
  const materialName = `DepthEncode_${additionalName}_`;
  const materialContent = new DepthEncodeMaterialContent(materialName, depthPow, {
    isSkinning
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  if (isSkinning) {
    material.addShaderDefine("RN_IS_SKINNING");
  }
  return material;
}
function createShadowMapDecodeClassicSingleMaterial({ additionalName = "", isMorphing = false, isSkinning = false, isLighting = true, isDebugging = false, colorAttachmentsNumber = 0, maxInstancesNumber = 20 } = {}, depthEncodeRenderPass) {
  const materialName = `ShadowMapDecodeClassic_${additionalName}_`;
  const materialContent = new ShadowMapDecodeClassicMaterialContent(materialName, {
    isMorphing,
    isSkinning,
    isLighting,
    isDebugging,
    colorAttachmentsNumber
  }, depthEncodeRenderPass);
  const material = createMaterial(materialContent, maxInstancesNumber);
  if (isSkinning) {
    material.addShaderDefine("RN_IS_SKINNING");
  }
  if (isMorphing) {
    material.addShaderDefine("RN_IS_MORPHING");
  }
  if (isLighting) {
    material.addShaderDefine("RN_IS_LIGHTING");
  }
  if (isDebugging) {
    material.addShaderDefine("RN_IS_DEBUGGING");
  }
  return material;
}
function createGaussianBlurForEncodedDepthMaterial({ additionalName = "", maxInstancesNumber = 10 } = {}) {
  const materialName = `GaussianBlurForEncodedDepth_${additionalName}`;
  const additionalShaderSemanticInfo = [];
  const gaussianRatio = new Float32Array(30);
  additionalShaderSemanticInfo.push({
    semantic: "isHorizontal",
    componentType: ComponentType.Bool,
    compositionType: CompositionType.Scalar,
    stage: ShaderType.PixelShader,
    initialValue: Scalar2.fromCopyNumber(1),
    min: 0,
    max: 1
  }, {
    semantic: "gaussianRatio",
    componentType: ComponentType.Float,
    compositionType: CompositionType.ScalarArray,
    arrayLength: 30,
    stage: ShaderType.PixelShader,
    initialValue: new VectorN(gaussianRatio),
    min: 0,
    max: 1,
    needUniformInDataTextureMode: true
  }, {
    semantic: "gaussianKernelSize",
    componentType: ComponentType.Int,
    compositionType: CompositionType.Scalar,
    stage: ShaderType.PixelShader,
    initialValue: Scalar2.fromCopyNumber(1),
    min: 1,
    max: 30
  }, {
    semantic: "framebufferSize",
    componentType: ComponentType.Float,
    compositionType: CompositionType.Vec2,
    stage: ShaderType.PixelShader,
    initialValue: Vector2.fromCopy2(1, 1),
    min: 0,
    max: Number.MAX_SAFE_INTEGER
  }, {
    semantic: "baseColorTexture",
    componentType: ComponentType.Int,
    compositionType: CompositionType.Texture2D,
    stage: ShaderType.PixelShader,
    initialValue: [
      0,
      dummyBlackTexture
    ],
    min: 0,
    max: Number.MAX_SAFE_INTEGER
  });
  const materialContent = new CustomMaterialContent({
    name: materialName,
    isSkinning: false,
    isLighting: false,
    isMorphing: false,
    vertexShader: GaussianBlurForEncodedDepthShader_default,
    pixelShader: GaussianBlurForEncodedDepthShader_default2,
    additionalShaderSemanticInfo
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  return material;
}
function createVarianceShadowMapDecodeClassicSingleMaterial({ additionalName = "", isMorphing = false, isSkinning = false, isDebugging = false, isLighting = true, colorAttachmentsNumberDepth = 0, colorAttachmentsNumberSquareDepth = 0, depthCameraComponent = void 0, maxInstancesNumber = 10 }, encodedDepthRenderPasses) {
  const materialName = `VarianceShadowMapDecodeClassic_${additionalName}_`;
  const materialContent = new VarianceShadowMapDecodeClassicMaterialContent(materialName, {
    isMorphing,
    isSkinning,
    isLighting,
    isDebugging,
    colorAttachmentsNumberDepth,
    colorAttachmentsNumberSquareDepth,
    depthCameraComponent
  }, encodedDepthRenderPasses);
  const material = createMaterial(materialContent, maxInstancesNumber);
  if (isSkinning) {
    material.addShaderDefine("RN_IS_SKINNING");
  }
  if (isLighting) {
    material.addShaderDefine("RN_IS_LIGHTING");
  }
  if (isMorphing) {
    material.addShaderDefine("RN_IS_MORPHING");
  }
  if (isDebugging) {
    material.addShaderDefine("RN_IS_DEBUGGING");
  }
  return material;
}
function createDetectHighLuminanceMaterial({ additionalName = "", maxInstancesNumber = 5 } = {}, textureToDetectHighLuminance) {
  const materialName = `DetectHighLuminance_${additionalName}_`;
  const materialContent = new DetectHighLuminanceMaterialContent(materialName, textureToDetectHighLuminance);
  const material = createMaterial(materialContent, maxInstancesNumber);
  return material;
}
function createGaussianBlurMaterial({ additionalName = "", maxInstancesNumber = 10 } = {}) {
  const materialName = `GaussianBlur_${additionalName}`;
  const additionalShaderSemanticInfo = [];
  const gaussianRatio = new Float32Array(30);
  additionalShaderSemanticInfo.push({
    semantic: "isHorizontal",
    componentType: ComponentType.Bool,
    compositionType: CompositionType.Scalar,
    stage: ShaderType.PixelShader,
    initialValue: Scalar2.fromCopyNumber(1),
    min: 0,
    max: 1
  }, {
    semantic: "gaussianRatio",
    componentType: ComponentType.Float,
    compositionType: CompositionType.ScalarArray,
    arrayLength: 30,
    stage: ShaderType.PixelShader,
    initialValue: new VectorN(gaussianRatio),
    min: 0,
    max: 1
  }, {
    semantic: "gaussianKernelSize",
    componentType: ComponentType.Int,
    compositionType: CompositionType.Scalar,
    stage: ShaderType.PixelShader,
    initialValue: Scalar2.fromCopyNumber(1),
    min: 1,
    max: 30
  }, {
    semantic: "framebufferSize",
    componentType: ComponentType.Float,
    compositionType: CompositionType.Vec2,
    stage: ShaderType.PixelShader,
    initialValue: Vector2.fromCopy2(1, 1),
    min: 0,
    max: Number.MAX_SAFE_INTEGER
  }, {
    semantic: "baseColorTexture",
    componentType: ComponentType.Int,
    compositionType: CompositionType.Texture2D,
    stage: ShaderType.PixelShader,
    initialValue: [
      0,
      dummyBlackTexture
    ],
    min: 0,
    max: Number.MAX_SAFE_INTEGER
  });
  const materialContent = new CustomMaterialContent({
    name: materialName,
    isSkinning: false,
    isLighting: false,
    isMorphing: false,
    vertexShader: GaussianBlurShader_default,
    pixelShader: GaussianBlurShader_default2,
    vertexShaderWebGpu: GaussianBlurShader_default3,
    pixelShaderWebGpu: GaussianBlurShader_default4,
    additionalShaderSemanticInfo
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  return material;
}
function createSynthesizeHDRMaterial({ additionalName = "", maxInstancesNumber = 1 }, synthesizeTextures) {
  const materialName = `SynthesizeHDR_${additionalName}`;
  const materialContent = new SynthesizeHdrMaterialContent(materialName, synthesizeTextures);
  const material = createMaterial(materialContent, maxInstancesNumber);
  return material;
}
function createColorGradingUsingLUTsMaterial({ additionalName = "", colorAttachmentsNumber = 0, uri, texture, maxInstancesNumber = 1 }, targetRenderPass) {
  const materialName = `ColorGradingUsingLUTs_${additionalName}`;
  const materialContent = new ColorGradingUsingLUTsMaterialContent(materialName, targetRenderPass, colorAttachmentsNumber, uri, texture);
  const material = createMaterial(materialContent, maxInstancesNumber);
  return material;
}
function createGammaCorrectionMaterial({ additionalName = "", maxInstancesNumber = 1 } = {}) {
  const materialName = `GammaCorrection_${additionalName}`;
  const materialContent = new CustomMaterialContent({
    name: materialName,
    isSkinning: false,
    isLighting: false,
    isMorphing: false,
    vertexShader: GammaCorrectionShader_default,
    pixelShader: GammaCorrectionShader_default2,
    vertexShaderWebGpu: GammaCorrectionShader_default3,
    pixelShaderWebGpu: GammaCorrectionShader_default4,
    additionalShaderSemanticInfo: []
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  return material;
}
function createToneMappingMaterial({ additionalName = "", maxInstancesNumber = 1 } = {}) {
  const materialName = `ToneMapping_${additionalName}`;
  const materialContent = new CustomMaterialContent({
    name: materialName,
    isSkinning: false,
    isLighting: false,
    isMorphing: false,
    vertexShader: ToneMappingShader_default,
    pixelShader: ToneMappingShader_default2,
    vertexShaderWebGpu: ToneMappingShader_vert_default,
    pixelShaderWebGpu: ToneMappingShader_frag_default,
    additionalShaderSemanticInfo: []
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  material.addShaderDefine("RN_USE_GT_TONEMAP");
  return material;
}
function createSummedAreaTableMaterial({ additionalName = "", maxInstancesNumber = 1 } = {}) {
  const materialName = `SummedAreaTable_${additionalName}`;
  const materialContent = new CustomMaterialContent({
    name: materialName,
    isSkinning: false,
    isLighting: false,
    isMorphing: false,
    vertexShader: SummedAreaTableShader_default,
    pixelShader: SummedAreaTableShader_default2,
    additionalShaderSemanticInfo: []
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  return material;
}
function createPanoramaToCubeMaterial({ additionalName = "", maxInstancesNumber = 1 } = {}) {
  const materialName = `PanoramaToCube_${additionalName}`;
  const materialContent = new CustomMaterialContent({
    name: materialName,
    isSkinning: false,
    isLighting: false,
    isMorphing: false,
    vertexShader: PanoramaToCubeShader_default,
    pixelShader: PanoramaToCubeShader_default2,
    vertexShaderWebGpu: PanoramaToCubeShader_vert_default,
    pixelShaderWebGpu: PanoramaToCubeShader_frag_default,
    additionalShaderSemanticInfo: []
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  return material;
}
function createPrefilterIBLMaterial({ additionalName = "", maxInstancesNumber = 1 } = {}) {
  const materialName = `PrefilterIBL_${additionalName}`;
  const materialContent = new CustomMaterialContent({
    name: materialName,
    isSkinning: false,
    isLighting: false,
    isMorphing: false,
    vertexShader: PrefilterIBLShader_default,
    pixelShader: PrefilterIBLShader_default2,
    vertexShaderWebGpu: PrefilterIBLShader_vert_default,
    pixelShaderWebGpu: PrefilterIBLShader_frag_default,
    additionalShaderSemanticInfo: []
  });
  const material = createMaterial(materialContent, maxInstancesNumber);
  return material;
}
function createMatCapMaterial({ additionalName = "", isSkinning = false, uri, texture, sampler, maxInstancesNumber = 10 }) {
  const materialName = `MatCap_${additionalName}`;
  const materialContent = new MatCapMaterialContent(materialName, isSkinning, uri, texture, sampler);
  const material = createMaterial(materialContent, maxInstancesNumber);
  if (isSkinning) {
    material.addShaderDefine("RN_IS_SKINNING");
  }
  return material;
}
function createEntityUIDOutputMaterial({ additionalName = "", maxInstancesNumber = 10 } = {}) {
  const materialName = `EntityUIDOutput_${additionalName}`;
  const materialContent = new EntityUIDOutputMaterialContent(materialName);
  const material = createMaterial(materialContent, maxInstancesNumber);
  material.addShaderDefine("RN_IS_SKINNING");
  return material;
}
function createMToon0xMaterial({ additionalName = "", isMorphing = false, isSkinning = false, isLighting = true, useTangentAttribute = false, isOutline = false, materialProperties, textures, samplers, debugMode, maxInstancesNumber = Config.maxMaterialInstanceForEachType, makeOutputSrgb = true }) {
  const materialName = `MToon0x_${additionalName}_`;
  const materialContent = new MToon0xMaterialContent(isOutline, materialProperties, textures, samplers, isMorphing, isSkinning, isLighting, useTangentAttribute, debugMode, makeOutputSrgb, materialName);
  const material = createMaterial(materialContent, maxInstancesNumber);
  materialContent.setMaterialParameters(material, isOutline);
  return material;
}
function createMToon1Material({ additionalName = "", isMorphing = false, isSkinning = false, isLighting = true, useTangentAttribute = false, isOutline = false, materialJson, textures, samplers, debugMode, maxInstancesNumber = Config.maxMaterialInstanceForEachType, makeOutputSrgb = true }) {
  const materialName = `MToon1_${additionalName}_`;
  const materialContent = new MToon1MaterialContent(materialName, isMorphing, isSkinning, isLighting, isOutline);
  const material = createMaterial(materialContent, maxInstancesNumber);
  materialContent.setMaterialParameters(material, isOutline, materialJson);
  material.setParameter("makeOutputSrgb", Scalar2.fromCopyNumber(makeOutputSrgb ? 1 : 0));
  material.zWriteWhenBlend = materialJson.extensions.VRMC_materials_mtoon.transparentWithZWrite;
  if (materialJson.normalTexture != null) {
    material.addShaderDefine("RN_USE_NORMAL_TEXTURE");
  }
  return material;
}
function reuseOrRecreateCustomMaterial(currentMaterial, vertexShaderStr, pixelShaderStr, { additionalName = "", isSkinning = true, isLighting = false, isMorphing = false, maxInstancesNumber = Config.maxMaterialInstanceForEachType } = {}) {
  const materialName = `Custom_${additionalName}_`;
  let materialContent;
  if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
    materialContent = new CustomMaterialContent({
      name: materialName,
      isSkinning,
      isLighting,
      isMorphing,
      vertexShaderWebGpu: {
        code: vertexShaderStr,
        shaderStage: "vertex",
        isFragmentShader: false
      },
      pixelShaderWebGpu: {
        code: pixelShaderStr,
        shaderStage: "fragment",
        isFragmentShader: true
      },
      additionalShaderSemanticInfo: []
    });
  } else {
    materialContent = new CustomMaterialContent({
      name: materialName,
      isSkinning,
      isLighting,
      isMorphing,
      vertexShader: {
        code: vertexShaderStr,
        shaderStage: "vertex",
        isFragmentShader: false
      },
      pixelShader: {
        code: pixelShaderStr,
        shaderStage: "fragment",
        isFragmentShader: true
      },
      additionalShaderSemanticInfo: []
    });
  }
  const material = reuseOrRecreateMaterial(currentMaterial, materialContent, maxInstancesNumber);
  material.addShaderDefine("RN_IS_SKINNING");
  return material;
}
function changeMaterial(entity, primitive, material) {
  const meshRendererComponent = entity.getMeshRenderer();
  primitive.material = material;
  meshRendererComponent.moveStageTo(ProcessStage.Load);
}
var MaterialHelper;
var init_MaterialHelper = __esm({
  "src/foundation/helpers/MaterialHelper.ts"() {
    "use strict";
    init_Config();
    init_DepthEncodeMaterialContent();
    init_ShadowMapDecodeClassicMaterialContent();
    init_EntityUIDOutputMaterialContent();
    init_MToon0xMaterialContent();
    init_CustomMaterialContent();
    init_ProcessStage();
    init_FurnaceTestMaterialContent();
    init_DetectHighLuminanceMaterialContent();
    init_SynthesizeHdrMaterialContent();
    init_ColorGradingUsingLUTsMaterialContent();
    init_MatCapMaterialContent();
    init_VarianceShadowMapDecodeClassicMaterialContent();
    init_ComponentType();
    init_CompositionType();
    init_ShaderType();
    init_VectorN();
    init_ClassicSingleShader();
    init_ClassicSingleShader2();
    init_ClassicSingleShader3();
    init_ClassicSingleShader4();
    init_PbrSingleShader();
    init_PbrSingleShader2();
    init_PbrSingleShader3();
    init_PbrSingleShader4();
    init_EnvConstantSingleShader();
    init_EnvConstantSingleShader2();
    init_EnvConstantSingleShader3();
    init_EnvConstantSingleShader4();
    init_FXAA3QualitySingleShader();
    init_FXAA3QualitySingleShader2();
    init_GammaCorrectionShader();
    init_GammaCorrectionShader2();
    init_GammaCorrectionShader3();
    init_GammaCorrectionShader4();
    init_ToneMappingShader();
    init_ToneMappingShader2();
    init_ToneMappingShader_vert();
    init_ToneMappingShader_frag();
    init_SummedAreaTableShader();
    init_SummedAreaTableShader2();
    init_FlatSingleShader();
    init_FlatSingleShader2();
    init_FlatSingleShader3();
    init_FlatSingleShader4();
    init_DepthMomentEncodeShader();
    init_DepthMomentEncodeShader2();
    init_ParaboloidDepthMomentEncodeShader_vert();
    init_ParaboloidDepthMomentEncodeShader_frag();
    init_MaterialRepository();
    init_Sampler();
    init_DummyTextures();
    init_GaussianBlurShader();
    init_GaussianBlurShader2();
    init_GaussianBlurShader3();
    init_GaussianBlurShader4();
    init_GaussianBlurForEncodedDepthShader();
    init_GaussianBlurForEncodedDepthShader2();
    init_PanoramaToCubeShader();
    init_PanoramaToCubeShader2();
    init_PanoramaToCubeShader_vert();
    init_PanoramaToCubeShader_frag();
    init_PrefilterIBLShader();
    init_PrefilterIBLShader2();
    init_PrefilterIBLShader_vert();
    init_PrefilterIBLShader_frag();
    init_Scalar();
    init_definitions();
    init_Vector2();
    init_SystemState();
    init_MToon1MaterialContent();
    __name(createMaterial, "createMaterial");
    __name(reuseOrRecreateMaterial, "reuseOrRecreateMaterial");
    __name(recreateMaterial, "recreateMaterial");
    __name(createPbrUberMaterial, "createPbrUberMaterial");
    __name(createClassicUberMaterial, "createClassicUberMaterial");
    __name(createParaboloidDepthMomentEncodeMaterial, "createParaboloidDepthMomentEncodeMaterial");
    __name(createDepthMomentEncodeMaterial, "createDepthMomentEncodeMaterial");
    __name(createFlatMaterial, "createFlatMaterial");
    __name(createEnvConstantMaterial, "createEnvConstantMaterial");
    __name(createFXAA3QualityMaterial, "createFXAA3QualityMaterial");
    __name(createFurnaceTestMaterial, "createFurnaceTestMaterial");
    __name(createDepthEncodeMaterial, "createDepthEncodeMaterial");
    __name(createShadowMapDecodeClassicSingleMaterial, "createShadowMapDecodeClassicSingleMaterial");
    __name(createGaussianBlurForEncodedDepthMaterial, "createGaussianBlurForEncodedDepthMaterial");
    __name(createVarianceShadowMapDecodeClassicSingleMaterial, "createVarianceShadowMapDecodeClassicSingleMaterial");
    __name(createDetectHighLuminanceMaterial, "createDetectHighLuminanceMaterial");
    __name(createGaussianBlurMaterial, "createGaussianBlurMaterial");
    __name(createSynthesizeHDRMaterial, "createSynthesizeHDRMaterial");
    __name(createColorGradingUsingLUTsMaterial, "createColorGradingUsingLUTsMaterial");
    __name(createGammaCorrectionMaterial, "createGammaCorrectionMaterial");
    __name(createToneMappingMaterial, "createToneMappingMaterial");
    __name(createSummedAreaTableMaterial, "createSummedAreaTableMaterial");
    __name(createPanoramaToCubeMaterial, "createPanoramaToCubeMaterial");
    __name(createPrefilterIBLMaterial, "createPrefilterIBLMaterial");
    __name(createMatCapMaterial, "createMatCapMaterial");
    __name(createEntityUIDOutputMaterial, "createEntityUIDOutputMaterial");
    __name(createMToon0xMaterial, "createMToon0xMaterial");
    __name(createMToon1Material, "createMToon1Material");
    __name(reuseOrRecreateCustomMaterial, "reuseOrRecreateCustomMaterial");
    __name(changeMaterial, "changeMaterial");
    MaterialHelper = Object.freeze({
      createMaterial,
      recreateMaterial,
      reuseOrRecreateCustomMaterial,
      createClassicUberMaterial,
      createDepthMomentEncodeMaterial,
      createParaboloidDepthMomentEncodeMaterial,
      createFlatMaterial,
      createPbrUberMaterial,
      createEnvConstantMaterial,
      createFXAA3QualityMaterial,
      createDepthEncodeMaterial,
      createShadowMapDecodeClassicSingleMaterial,
      createGammaCorrectionMaterial,
      createToneMappingMaterial,
      createPanoramaToCubeMaterial,
      createPrefilterIBLMaterial,
      createSummedAreaTableMaterial,
      createVarianceShadowMapDecodeClassicSingleMaterial,
      createEntityUIDOutputMaterial,
      createMToon0xMaterial,
      createMToon1Material,
      createFurnaceTestMaterial,
      createGaussianBlurForEncodedDepthMaterial,
      createDetectHighLuminanceMaterial,
      createGaussianBlurMaterial,
      createSynthesizeHDRMaterial,
      createColorGradingUsingLUTsMaterial,
      createMatCapMaterial,
      changeMaterial
    });
  }
});

// src/foundation/geometry/types/GeometryTypes.ts
function readBits(primitive, offset, length) {
  let mask = (1 << length) - 1;
  return primitive._sortkey >> offset & mask;
}
function isBlend(primitive) {
  const bit = readBits(primitive, PrimitiveSortKey_BitOffset_TranslucencyType, PrimitiveSortKey_BitLength_TranslucencyType);
  return bit === 2 || bit === 3;
}
function isBlendWithZWrite(primitive) {
  const bit = readBits(primitive, PrimitiveSortKey_BitOffset_TranslucencyType, PrimitiveSortKey_BitLength_TranslucencyType);
  return bit === 2;
}
function isBlendWithoutZWrite(primitive) {
  const bit = readBits(primitive, PrimitiveSortKey_BitOffset_TranslucencyType, PrimitiveSortKey_BitLength_TranslucencyType);
  return bit === 3;
}
function isTranslucent(primitive) {
  return readBits(primitive, PrimitiveSortKey_BitOffset_TranslucencyType, PrimitiveSortKey_BitLength_TranslucencyType) === 1;
}
function isOpaque(primitive) {
  return readBits(primitive, PrimitiveSortKey_BitOffset_TranslucencyType, PrimitiveSortKey_BitLength_TranslucencyType) === 0;
}
var PrimitiveSortKey_BitLength_TranslucencyType, PrimitiveSortKey_BitLength_Material, PrimitiveSortKey_BitLength_PrimitiveType, PrimitiveSortKey_BitOffset_PrimitiveType, PrimitiveSortKey_BitOffset_Material, PrimitiveSortKey_BitOffset_TranslucencyType, PrimitiveSortKey_BitOffset_ViewportLayer, PrimitiveSortKey_BitLength_Depth;
var init_GeometryTypes = __esm({
  "src/foundation/geometry/types/GeometryTypes.ts"() {
    "use strict";
    PrimitiveSortKey_BitLength_TranslucencyType = 2;
    PrimitiveSortKey_BitLength_Material = 10;
    PrimitiveSortKey_BitLength_PrimitiveType = 3;
    PrimitiveSortKey_BitOffset_PrimitiveType = 0;
    PrimitiveSortKey_BitOffset_Material = PrimitiveSortKey_BitLength_PrimitiveType;
    PrimitiveSortKey_BitOffset_TranslucencyType = PrimitiveSortKey_BitLength_PrimitiveType + PrimitiveSortKey_BitLength_Material;
    PrimitiveSortKey_BitOffset_ViewportLayer = PrimitiveSortKey_BitLength_PrimitiveType + PrimitiveSortKey_BitLength_Material + PrimitiveSortKey_BitLength_TranslucencyType;
    PrimitiveSortKey_BitLength_Depth = 32;
    __name(readBits, "readBits");
    __name(isBlend, "isBlend");
    __name(isBlendWithZWrite, "isBlendWithZWrite");
    __name(isBlendWithoutZWrite, "isBlendWithoutZWrite");
    __name(isTranslucent, "isTranslucent");
    __name(isOpaque, "isOpaque");
  }
});

// src/foundation/geometry/Primitive.ts
var _Primitive, Primitive;
var init_Primitive = __esm({
  "src/foundation/geometry/Primitive.ts"() {
    "use strict";
    init_PrimitiveMode();
    init_VertexAttribute();
    init_RnObject();
    init_ComponentType();
    init_MemoryManager();
    init_CompositionType();
    init_AABB();
    init_MaterialHelper();
    init_CGAPIResourceRepository();
    init_Vector3();
    init_MutableVector3();
    init_Is();
    init_GeometryTypes();
    init_Option();
    init_DataUtil();
    init_Config();
    init_RnException();
    init_Logger();
    _Primitive = class _Primitive extends RnObject {
      constructor() {
        super();
        __publicField(this, "__mode", PrimitiveMode.Unknown);
        __publicField(this, "__material");
        __publicField(this, "__materialVariants", /* @__PURE__ */ new Map());
        __publicField(this, "__currentVariantName", "");
        __publicField(this, "_prevMaterial");
        __publicField(this, "__attributes", /* @__PURE__ */ new Map());
        __publicField(this, "__oIndices", new None());
        __publicField(this, "__primitiveUid", -1);
        __publicField(this, "__aabb", new AABB());
        __publicField(this, "__targets", []);
        __publicField(this, "__vertexHandles");
        __publicField(this, "__mesh");
        __publicField(this, "_sortkey", 0);
        __publicField(this, "_viewDepth", 0);
        __publicField(this, "__latestPositionAccessorVersion", 0);
        __publicField(this, "__positionAccessorVersion", 0);
        __publicField(this, "__fingerPrint", "");
        if (_Primitive.__defaultMaterial == null) {
          _Primitive.__defaultMaterial = MaterialHelper.createClassicUberMaterial({
            isSkinning: true,
            isLighting: true
          });
        }
        this.__material = _Primitive.__defaultMaterial;
        this._prevMaterial = new WeakRef(_Primitive.__defaultMaterial);
      }
      calcFingerPrint() {
        let str = "";
        str += this.__mode.index;
        if (this.__oIndices.has()) {
          str += this.getIndexBitSize();
        }
        str += this.targets.length;
        str += _Primitive.getPrimitiveIdxHasMorph(this.__primitiveUid);
        for (const [semantic, accessor] of this.__attributes) {
          str += semantic;
          str += accessor.componentType.webgpu + accessor.compositionType.webgpu;
          str += accessor.actualByteStride;
        }
        this.__fingerPrint = str;
      }
      _getFingerPrint() {
        return this.__fingerPrint;
      }
      static getPrimitiveIdxHasMorph(primitiveUid) {
        return this.__primitiveUidIdxHasMorph.get(primitiveUid);
      }
      static getPrimitiveHasMorph(primitiveIdx) {
        var _a40;
        return (_a40 = this.__idxPrimitiveUidHasMorph.get(primitiveIdx)) == null ? void 0 : _a40.deref();
      }
      getIndexBitSize() {
        const indexAccessor = this.__oIndices.unwrapOrUndefined();
        if (indexAccessor == null) {
          throw new Error("indexAccessor is null");
        } else {
          if (indexAccessor.componentType === ComponentType.UnsignedShort) {
            return "uint16";
          } else if (indexAccessor.componentType === ComponentType.UnsignedInt) {
            return "uint32";
          } else if (indexAccessor.componentType === ComponentType.UnsignedByte) {
            return "uint16";
          } else {
            throw new Error("unknown indexAccessor.componentType");
          }
        }
      }
      get _vertexHandles() {
        return this.__vertexHandles;
      }
      static get variantUpdateCount() {
        return this.__variantUpdateCount;
      }
      setMaterialVariant(variantName, material) {
        this.__materialVariants.set(variantName, material);
        _Primitive.__variantUpdateCount++;
      }
      applyMaterialVariant(variantName) {
        const variant = this.__materialVariants.get(variantName);
        if (variant) {
          this.material = variant;
          this.__currentVariantName = variantName;
          _Primitive.__variantUpdateCount++;
        }
      }
      getCurrentVariantName() {
        for (const [name, material] of this.__materialVariants) {
          if (material === this.__material) {
            return name;
          }
        }
        return "";
      }
      getVariantNames() {
        return Array.from(this.__materialVariants.keys());
      }
      getVariantMaterial(variantName) {
        return this.__materialVariants.get(variantName);
      }
      set material(mat) {
        this.__material = mat;
        this.setSortKey(PrimitiveSortKey_BitOffset_Material, PrimitiveSortKey_BitLength_Material, mat.materialUID);
        let translucencyType = 0;
        if (mat.isTranslucentOpaque()) {
          translucencyType = 1;
        } else if (mat.isBlend()) {
          if (mat.zWriteWhenBlend) {
            translucencyType = 2;
          } else {
            translucencyType = 3;
          }
        }
        this.setSortKey(PrimitiveSortKey_BitOffset_TranslucencyType, PrimitiveSortKey_BitLength_TranslucencyType, translucencyType);
        mat._addBelongPrimitive(this);
      }
      get material() {
        return this.__material;
      }
      setSortKey(offset, length, value) {
        const offsetValue = value << offset;
        this._sortkey |= offsetValue;
        let mask = (1 << length) - 1;
        this._sortkey &= ~(mask << offset);
        this._sortkey |= (value & mask) << offset;
      }
      /**
      * belong to mesh (weak reference)
      * @param mesh
      */
      _belongToMesh(mesh) {
        this.__mesh = mesh;
      }
      get mesh() {
        return this.__mesh;
      }
      _backupMaterial() {
        this._prevMaterial = new WeakRef(this.__material);
      }
      _restoreMaterial() {
        const material = this._prevMaterial.deref();
        if (material != null) {
          this.__material = material;
        }
      }
      static getPrimitive(primitiveUid) {
        var _a40;
        return (_a40 = this.__primitives[primitiveUid]) == null ? void 0 : _a40.deref();
      }
      static getPrimitiveCount() {
        return this.__primitiveCount;
      }
      onAccessorUpdated(accessorVersion) {
        this.__positionAccessorVersion = accessorVersion;
        if (this.__mesh != null) {
          this.__mesh._onPrimitivePositionUpdated();
        }
      }
      setData(attributes, mode, material, indicesAccessor) {
        if (indicesAccessor != null) {
          this.__oIndices = new Some(indicesAccessor);
        } else {
          this.__oIndices = new None();
        }
        this.__attributes = attributes;
        const positionAccessor = this.__attributes.get(VertexAttribute.Position.XYZ);
        positionAccessor._primitive = new WeakRef(this);
        if (material != null) {
          this.material = material;
        } else {
          this.material = MaterialHelper.createClassicUberMaterial({
            isSkinning: true,
            isLighting: true
          });
        }
        this.__mode = mode;
        this.setSortKey(PrimitiveSortKey_BitOffset_PrimitiveType, PrimitiveSortKey_BitLength_PrimitiveType, mode.index);
        this.__primitiveUid = _Primitive.__primitiveCount++;
        _Primitive.__primitives[this.__primitiveUid] = new WeakRef(this);
        this.calcFingerPrint();
      }
      static get maxPrimitiveCount() {
        return 500;
      }
      copyVertexData({ attributes, attributeSemantics, primitiveMode, indices, material }) {
        let sumOfAttributesByteSize = 0;
        const byteAlign = 4;
        attributes.forEach((attribute) => {
          sumOfAttributesByteSize += attribute.byteLength;
        });
        let bufferSize = sumOfAttributesByteSize;
        if (indices != null) {
          bufferSize += DataUtil.addPaddingBytes(indices.byteLength, byteAlign);
        }
        const buffer = MemoryManager.getInstance().createBufferOnDemand(bufferSize, this, byteAlign);
        let indicesComponentType;
        let indicesAccessor;
        if (indices != null) {
          indicesComponentType = ComponentType.fromTypedArray(indices);
          const indicesBufferViewResult = buffer.takeBufferView({
            byteLengthToNeed: indices.byteLength,
            byteStride: 0
          });
          if (indicesBufferViewResult.isErr()) {
            throw new RnException(indicesBufferViewResult.getRnError());
          }
          const indicesAccessorResult = indicesBufferViewResult.get().takeAccessor({
            compositionType: CompositionType.Scalar,
            componentType: indicesComponentType,
            count: indices.byteLength / indicesComponentType.getSizeInBytes()
          });
          if (indicesAccessorResult.isErr()) {
            throw new RnException(indicesAccessorResult.getRnError());
          }
          indicesAccessor = indicesAccessorResult.get();
          for (let i2 = 0; i2 < indices.byteLength / indicesAccessor.componentSizeInBytes; i2++) {
            indicesAccessor.setScalar(i2, indices[i2], {});
          }
        }
        const attributesBufferView = buffer.takeBufferView({
          byteLengthToNeed: sumOfAttributesByteSize,
          byteStride: 0
        }).unwrapForce();
        const attributeAccessors = [];
        const attributeComponentTypes = [];
        attributes.forEach((typedArray, i2) => {
          const compositionType = CompositionType.vectorFrom(VertexAttribute.toVectorComponentN(attributeSemantics[i2]));
          attributeComponentTypes[i2] = ComponentType.fromTypedArray(attributes[i2]);
          const accessor = attributesBufferView.takeAccessor({
            compositionType,
            componentType: ComponentType.fromTypedArray(attributes[i2]),
            count: typedArray.byteLength / compositionType.getNumberOfComponents() / attributeComponentTypes[i2].getSizeInBytes()
          }).unwrapForce();
          accessor.copyFromTypedArray(typedArray);
          attributeAccessors.push(accessor);
        });
        const attributeMap = /* @__PURE__ */ new Map();
        for (let i2 = 0; i2 < attributeSemantics.length; i2++) {
          const attributeSemantic = attributeSemantics[i2];
          attributeMap.set(attributeSemantic, attributeAccessors[i2]);
        }
        this.setData(attributeMap, primitiveMode, material, indicesAccessor);
      }
      static createPrimitive(desc) {
        const primitive = new _Primitive();
        primitive.copyVertexData(desc);
        return primitive;
      }
      get indicesAccessor() {
        return this.__oIndices.unwrapOrUndefined();
      }
      getVertexCountAsIndicesBased() {
        if (this.indicesAccessor) {
          return this.indicesAccessor.elementCount;
        } else {
          return this.getVertexCountAsVerticesBased();
        }
      }
      getVertexCountAsVerticesBased() {
        for (const accessor of this.__attributes.values()) {
          return accessor.elementCount;
        }
        return 0;
      }
      getTriangleCountAsIndicesBased() {
        if (this.indicesAccessor) {
          switch (this.__mode) {
            case PrimitiveMode.Triangles:
              return this.indicesAccessor.elementCount / 3;
            case PrimitiveMode.TriangleStrip:
              return this.indicesAccessor.elementCount - 2;
            case PrimitiveMode.TriangleFan:
              return this.indicesAccessor.elementCount - 2;
            default:
              return 0;
          }
        } else {
          return this.getTriangleCountAsVerticesBased();
        }
      }
      getTriangleCountAsVerticesBased() {
        for (const accessor of this.__attributes.values()) {
          switch (this.__mode) {
            case PrimitiveMode.Triangles:
              return accessor.elementCount / 3;
            case PrimitiveMode.TriangleStrip:
              return accessor.elementCount - 2;
            case PrimitiveMode.TriangleFan:
              return accessor.elementCount - 2;
            default:
              return 0;
          }
        }
        return 0;
      }
      hasIndices() {
        return this.__oIndices.has();
      }
      get attributeAccessors() {
        const accessors = [];
        this.__attributes.forEach((accessor, semantic) => {
          accessors.push(accessor);
        });
        return accessors;
      }
      getAttribute(semantic) {
        return this.__attributes.get(semantic);
      }
      get attributeSemantics() {
        const semantics = [];
        this.__attributes.forEach((accessor, semantic) => {
          semantics.push(semantic);
        });
        return semantics;
      }
      get attributeEntries() {
        return this.__attributes.entries();
      }
      get attributeCompositionTypes() {
        const types = [];
        this.__attributes.forEach((accessor, semantic) => {
          types.push(accessor.compositionType);
        });
        return types;
      }
      get attributeComponentTypes() {
        const types = [];
        this.__attributes.forEach((accessor, semantic) => {
          types.push(accessor.componentType);
        });
        return types;
      }
      get primitiveMode() {
        return this.__mode;
      }
      get primitiveUid() {
        return this.__primitiveUid;
      }
      get positionAccessorVersion() {
        return this.__positionAccessorVersion;
      }
      get AABB() {
        if (this.__aabb.isVanilla() || this.positionAccessorVersion !== this.__latestPositionAccessorVersion) {
          const positionAccessor = this.__attributes.get(VertexAttribute.Position.XYZ);
          const min = positionAccessor.min;
          this.__aabb.minPoint = _Primitive.__tmpVec3_0.setComponents(min[0], min[1], min[2]);
          const max = positionAccessor.max;
          this.__aabb.maxPoint = _Primitive.__tmpVec3_0.setComponents(max[0], max[1], max[2]);
          this.__latestPositionAccessorVersion = positionAccessor.version;
        }
        return this.__aabb;
      }
      setVertexAttribute(accessor, vertexSemantic) {
        this.__attributes.set(vertexSemantic, accessor);
      }
      removeIndices() {
        this.__oIndices = new None();
      }
      setIndices(accessor) {
        this.__oIndices = new Some(accessor);
      }
      setBlendShapeTargets(targets) {
        if (_Primitive.__primitiveUidIdxHasMorph.size >= Config.maxVertexPrimitiveNumberInShader) {
          Logger.error("Primitive.__primitiveUidsHasMorph.size exceeds the Config.maxMorphPrimitiveNumber");
        } else {
          _Primitive.__idxPrimitiveUidHasMorph.set(_Primitive.__primitiveCountHasMorph, new WeakRef(this));
          _Primitive.__primitiveUidIdxHasMorph.set(this.__primitiveUid, _Primitive.__primitiveCountHasMorph++);
        }
        this.__targets = targets;
        this.calcFingerPrint();
      }
      getBlendShapeTargets() {
        return this.__targets.concat();
      }
      get targets() {
        return this.__targets;
      }
      isBlend() {
        if (this.material == null || !this.material.isBlend()) {
          return false;
        } else {
          return true;
        }
      }
      isOpaque() {
        return !this.isBlend();
      }
      create3DAPIVertexData() {
        if (this.__vertexHandles != null) {
          return false;
        }
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        this.__vertexHandles = cgApiResourceRepository.createVertexBufferAndIndexBuffer(this);
        return true;
      }
      update3DAPIVertexData() {
        const vertexHandles = this.__vertexHandles;
        if (Is.not.exist(this.__vertexHandles)) {
          return false;
        }
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        cgApiResourceRepository.updateVertexBufferAndIndexBuffer(this, vertexHandles);
        return true;
      }
      delete3DAPIVertexData() {
        if (this.__vertexHandles == null) {
          return false;
        }
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        webglResourceRepository.deleteVertexDataResources(this.__vertexHandles);
        this.__vertexHandles = void 0;
        return true;
      }
      get vertexHandles() {
        return this.__vertexHandles;
      }
      castRay(origVec3, dirVec3, isFrontFacePickable, isBackFacePickable, dotThreshold, hasFaceNormal) {
        let currentShortestT = Number.MAX_VALUE;
        let incrementNum = 3;
        if (this.__mode === PrimitiveMode.TriangleStrip) {
          incrementNum = 1;
        } else if (this.__mode === PrimitiveMode.Points) {
          return {
            result: false
          };
        }
        let hitPos0IndexBase = 0;
        let hitPos1IndexBase = 0;
        const hitPos2IndexBase = 0;
        let u = 0;
        let v = 0;
        if (this.hasIndices()) {
          const indices = this.__oIndices.unwrapForce();
          for (let i2 = 0; i2 < indices.elementCount - 2; i2++) {
            const j = i2 * incrementNum;
            if (j + 2 > indices.elementCount - 1) {
              break;
            }
            const pos0IndexBase = indices.getScalar(j, {});
            const pos1IndexBase = indices.getScalar(j + 1, {});
            const pos2IndexBase = indices.getScalar(j + 2, {});
            const result = this.__castRayInnerTomasMoller(origVec3, dirVec3, i2, pos0IndexBase, pos1IndexBase, pos2IndexBase, isFrontFacePickable, isBackFacePickable, dotThreshold, hasFaceNormal);
            if (Is.false(result) || Is.not.exist(result.data)) {
              continue;
            } else {
              if (result.data.t < currentShortestT) {
                currentShortestT = result.data.t;
                u = result.data.u;
                v = result.data.v;
                hitPos0IndexBase = pos0IndexBase;
                hitPos1IndexBase = pos1IndexBase;
                hitPos0IndexBase = pos2IndexBase;
              }
            }
          }
        } else {
          let elementCount = 0;
          for (const accessor of this.__attributes.values()) {
            elementCount = accessor.elementCount;
            break;
          }
          for (let i2 = 0; i2 < elementCount; i2 += incrementNum) {
            const pos0IndexBase = i2;
            const pos1IndexBase = i2 + 1;
            const pos2IndexBase = i2 + 2;
            const result = this.__castRayInnerTomasMoller(origVec3, dirVec3, i2, pos0IndexBase, pos1IndexBase, pos2IndexBase, isFrontFacePickable, isBackFacePickable, dotThreshold, hasFaceNormal);
            if (result.result && Is.defined(result.data)) {
              const t2 = result.data.t;
              if (t2 < currentShortestT) {
                currentShortestT = t2;
                u = result.data.u;
                v = result.data.v;
                hitPos0IndexBase = pos0IndexBase;
                hitPos1IndexBase = pos1IndexBase;
                hitPos0IndexBase = pos2IndexBase;
              }
            }
          }
        }
        if (currentShortestT === Number.MAX_VALUE) {
          return {
            result: false
          };
        } else {
          const currentShortestIntersectedPosVec3 = Vector3.fromCopy3(dirVec3.x * currentShortestT + origVec3.x, dirVec3.y * currentShortestT + origVec3.y, dirVec3.z * currentShortestT + origVec3.z);
          return {
            result: true,
            data: {
              t: currentShortestT,
              u,
              v,
              position: currentShortestIntersectedPosVec3
            }
          };
        }
      }
      __castRayInnerTomasMoller(origVec3, dirVec3, i2, pos0IndexBase, pos1IndexBase, pos2IndexBase, isFrontFacePickable, isBackFacePickable, dotThreshold, hasFaceNormal) {
        if (hasFaceNormal) {
          const normalAccessor = this.__attributes.get(VertexAttribute.Normal.XYZ);
          if (normalAccessor) {
            const normal = normalAccessor.getVec3(i2, {});
            if (normal.dot(dirVec3) < dotThreshold && !isFrontFacePickable) {
              return {
                result: false
              };
            }
            if (normal.dot(dirVec3) > -dotThreshold && !isBackFacePickable) {
              return {
                result: false
              };
            }
          }
        }
        const positionAccessor = this.__attributes.get(VertexAttribute.Position.XYZ);
        const pos0Vec3 = positionAccessor.getVec3(pos0IndexBase, {});
        const pos1Vec3 = positionAccessor.getVec3(pos1IndexBase, {});
        const pos2Vec3 = positionAccessor.getVec3(pos2IndexBase, {});
        const e1 = MutableVector3.zero();
        const e22 = MutableVector3.zero();
        const pvec = MutableVector3.zero();
        const tvec = MutableVector3.zero();
        const qvec = MutableVector3.zero();
        let u = 0, v = 0;
        MutableVector3.subtractTo(pos1Vec3, pos0Vec3, e1);
        MutableVector3.subtractTo(pos2Vec3, pos0Vec3, e22);
        MutableVector3.crossTo(dirVec3, e22, pvec);
        const det = Vector3.dot(e1, pvec);
        if (det > 1e-4) {
          MutableVector3.subtractTo(origVec3, pos0Vec3, tvec);
          u = Vector3.dot(tvec, pvec);
          if (u < 0 || u > det) {
            return {
              result: false
            };
          }
          MutableVector3.crossTo(tvec, e1, qvec);
          v = Vector3.dot(dirVec3, qvec);
          if (v < 0 || u + v > det) {
            return {
              result: false
            };
          }
        } else if (det < -1e-4) {
          MutableVector3.subtractTo(origVec3, pos0Vec3, tvec);
          u = Vector3.dot(tvec, pvec);
          if (u > 0 || u < det) {
            return {
              result: false
            };
          }
          MutableVector3.crossTo(tvec, e1, qvec);
          v = Vector3.dot(dirVec3, qvec);
          if (v > 0 || u + v < det) {
            return {
              result: false
            };
          }
        } else {
          return {
            result: false
          };
        }
        const inv_det = 1 / det;
        let t2 = Vector3.dot(e22, qvec);
        t2 *= inv_det;
        u *= inv_det;
        v *= inv_det;
        return {
          result: true,
          data: {
            t: t2,
            u,
            v
          }
        };
      }
      __calcNormalFromUV(pos0IndexBase, pos1IndexBase, pos2IndexBase, u, v) {
        const fDat = 1 - u - v;
        const positionAccessor = this.__attributes.get(VertexAttribute.Position.XYZ);
        const pos0Vec3 = positionAccessor.getVec3(pos0IndexBase, {});
        const pos1Vec3 = positionAccessor.getVec3(pos1IndexBase, {});
        const pos2Vec3 = positionAccessor.getVec3(pos2IndexBase, {});
        const pos0 = Vector3.multiply(pos0Vec3, fDat);
        const pos1 = Vector3.multiply(pos1Vec3, u);
        const pos2 = Vector3.multiply(pos2Vec3, v);
        const intersectedPosVec3 = MutableVector3.zero().add(pos0).add(pos1).add(pos2);
        return intersectedPosVec3;
      }
    };
    __name(_Primitive, "Primitive");
    __publicField(_Primitive, "__defaultMaterial");
    __publicField(_Primitive, "__primitiveCount", 0);
    __publicField(_Primitive, "__primitives", []);
    __publicField(_Primitive, "__primitiveUidIdxHasMorph", /* @__PURE__ */ new Map());
    __publicField(_Primitive, "__idxPrimitiveUidHasMorph", /* @__PURE__ */ new Map());
    __publicField(_Primitive, "__primitiveCountHasMorph", 0);
    __publicField(_Primitive, "__tmpVec3_0", MutableVector3.zero());
    __publicField(_Primitive, "__variantUpdateCount", 0);
    Primitive = _Primitive;
  }
});

// src/foundation/components/SceneGraph/SceneGraphOps.ts
function flattenHierarchy(sceneGraphComponent, isJointMode) {
  const results = [];
  if (!isJointMode || sceneGraphComponent.isJoint()) {
    results.push(sceneGraphComponent);
  }
  const children = sceneGraphComponent.children;
  for (let i2 = 0; i2 < children.length; i2++) {
    const hitChildren = flattenHierarchy(children[i2], isJointMode);
    Array.prototype.push.apply(results, hitChildren);
  }
  return results;
}
var init_SceneGraphOps = __esm({
  "src/foundation/components/SceneGraph/SceneGraphOps.ts"() {
    "use strict";
    __name(flattenHierarchy, "flattenHierarchy");
  }
});

// src/foundation/renderer/RenderPass.ts
var _RenderPass, RenderPass;
var init_RenderPass = __esm({
  "src/foundation/renderer/RenderPass.ts"() {
    "use strict";
    init_RnObject();
    init_Vector4();
    init_WebGLResourceRepository();
    init_Primitive();
    init_MutableVector4();
    init_WellKnownComponentTIDs();
    init_PrimitiveMode();
    init_CGAPIResourceRepository();
    init_SceneGraphOps();
    _RenderPass = class _RenderPass extends RnObject {
      constructor() {
        super();
        __publicField(this, "__renderPassUID");
        __publicField(this, "__entities", []);
        __publicField(this, "__sceneGraphDirectlyAdded", []);
        __publicField(this, "__topLevelSceneGraphComponents", []);
        __publicField(this, "__meshComponents", []);
        __publicField(this, "__optimizedMeshComponents", []);
        __publicField(this, "__frameBuffer");
        __publicField(this, "__resolveFrameBuffer");
        __publicField(this, "__resolveFrameBuffer2");
        __publicField(this, "__viewport");
        __publicField(this, "__material");
        __publicField(this, "__primitiveMaterial", /* @__PURE__ */ new Map());
        // Public RenderPass Settings
        __publicField(this, "toClearColorBuffer", false);
        __publicField(this, "toClearDepthBuffer", true);
        __publicField(this, "toClearStencilBuffer", false);
        __publicField(this, "isDepthTest", true);
        /**
        * depth write mask for primitives drawing
        * false does not prevent depth clear.
        */
        __publicField(this, "depthWriteMask", true);
        __publicField(this, "clearColor", Vector4.fromCopyArray([
          1,
          1,
          1,
          1
        ]));
        __publicField(this, "clearDepth", 1);
        __publicField(this, "clearStencil", 0);
        __publicField(this, "cameraComponent");
        /*＊
        * If this value is greater than 1, buffer-less rendering is performed with the specified number of vertices.
        * In this case, registered Entities are ignored and they are not rendered.
        */
        __publicField(this, "_drawVertexNumberForBufferLessRendering", 0);
        __publicField(this, "_primitiveModeForBufferLessRendering", PrimitiveMode.Triangles);
        __publicField(this, "_dummyPrimitiveForBufferLessRendering", new Primitive());
        // VR
        __publicField(this, "isVrRendering", true);
        __publicField(this, "isOutputForVr", false);
        // Internal use
        __publicField(this, "_lastOpaqueIndex", -1);
        __publicField(this, "_lastTranslucentIndex", -1);
        __publicField(this, "_lastBlendWithZWriteIndex", -1);
        __publicField(this, "_lastBlendWithoutZWriteIndex", -1);
        __publicField(this, "_lastPrimitiveUids", []);
        __publicField(this, "_lastTransformComponentsUpdateCount", -1);
        __publicField(this, "_lastCameraControllerComponentsUpdateCount", -1);
        __publicField(this, "_lastSceneGraphComponentsUpdateCount", -1);
        __publicField(this, "_renderedSomethingBefore", true);
        __publicField(this, "_isChangedSortRenderResult", false);
        /** Whether or not to draw opaque primitives contained in this render pass. */
        __publicField(this, "_toRenderOpaquePrimitives", true);
        /** Whether or not to draw translucent primitives contained in this render pass. */
        __publicField(this, "_toRenderTranslucentPrimitives", true);
        /** Whether or not to draw blend with ZWrite primitives contained in this render pass. */
        __publicField(this, "_toRenderBlendWithZWritePrimitives", true);
        /** Whether or not to draw blend without ZWrite primitives contained in this render pass. */
        __publicField(this, "_toRenderBlendWithoutZWritePrimitives", true);
        __publicField(this, "toRenderEffekseerEffects", false);
        __publicField(this, "__renderTargetColorAttachments");
        __publicField(this, "__postEachRenderFunc");
        this.__renderPassUID = ++_RenderPass.__mesh_uid_count;
      }
      setToRenderOpaquePrimitives(toRender) {
        this._toRenderOpaquePrimitives = toRender;
        this.__calcMeshComponents();
      }
      setToRenderBlendWithoutZWritePrimitives(toRender) {
        this._toRenderBlendWithoutZWritePrimitives = toRender;
        this.__calcMeshComponents();
      }
      setToRenderBlendWithZWritePrimitives(toRender) {
        this._toRenderBlendWithZWritePrimitives = toRender;
        this.__calcMeshComponents();
      }
      setToRenderTranslucentPrimitives(toRender) {
        this._toRenderTranslucentPrimitives = toRender;
        this.__calcMeshComponents();
      }
      isBufferLessRenderingMode() {
        return this._drawVertexNumberForBufferLessRendering > 0;
      }
      /**
      * @brief Set this render pass to buffer-less rendering mode.
      * When this function is called, buffer-less rendering is performed only once with the specified number of vertices.
      * This is useful for e.g. full-screen drawing.
      * In this case, even if Entities are registered using the addEntities method, they will be ignored and will not be rendered.
      * @param primitiveMode The primitive mode to be used in buffer-less rendering.
      * @param drawVertexNumberWithoutEntities The number of vertices to be rendered in buffer-less rendering.
      * @param material The material to be used in buffer-less rendering.
      */
      setBufferLessRendering(primitiveMode, drawVertexNumberWithoutEntities, material) {
        this._primitiveModeForBufferLessRendering = primitiveMode;
        this._drawVertexNumberForBufferLessRendering = drawVertexNumberWithoutEntities;
        this.__material = material;
      }
      /**
      * @brief Set this render pass to buffer-less rendering mode.
      * When this function is called, buffer-less rendering is performed only once with the specified number of vertices.
      * This is useful for e.g. full-screen drawing.
      * In this case, even if Entities are registered using the addEntities method, they will be ignored and will not be rendered.
      * @param material The material to be used in buffer-less rendering.
      */
      setBufferLessFullScreenRendering(material) {
        this._primitiveModeForBufferLessRendering = PrimitiveMode.Triangles;
        this._drawVertexNumberForBufferLessRendering = 3;
        this.__material = material;
      }
      clone() {
        var _a40, _b;
        const renderPass = new _RenderPass();
        renderPass.tryToSetUniqueName(this.uniqueName + "_cloned", true);
        renderPass.__entities = this.__entities.concat();
        renderPass.__sceneGraphDirectlyAdded = this.__sceneGraphDirectlyAdded.concat();
        renderPass.__topLevelSceneGraphComponents = this.__topLevelSceneGraphComponents.concat();
        renderPass.__meshComponents = this.__meshComponents.concat();
        renderPass.__optimizedMeshComponents = this.__optimizedMeshComponents.concat();
        renderPass.__frameBuffer = this.__frameBuffer;
        renderPass.__resolveFrameBuffer = this.__resolveFrameBuffer;
        renderPass.__resolveFrameBuffer2 = this.__resolveFrameBuffer2;
        renderPass.__viewport = (_a40 = this.__viewport) == null ? void 0 : _a40.clone();
        renderPass.toClearColorBuffer = this.toClearColorBuffer;
        renderPass.toClearDepthBuffer = this.toClearDepthBuffer;
        renderPass.toClearStencilBuffer = this.toClearStencilBuffer;
        renderPass.isDepthTest = this.isDepthTest;
        renderPass.clearColor = this.clearColor.clone();
        renderPass.clearDepth = this.clearDepth;
        renderPass.clearStencil = this.clearStencil;
        renderPass.cameraComponent = this.cameraComponent;
        renderPass.__material = this.__material;
        renderPass.__primitiveMaterial = new Map(this.__primitiveMaterial);
        renderPass.isVrRendering = this.isVrRendering;
        renderPass.isOutputForVr = this.isOutputForVr;
        renderPass._toRenderOpaquePrimitives = this._toRenderOpaquePrimitives;
        renderPass._toRenderTranslucentPrimitives = this._toRenderTranslucentPrimitives;
        renderPass._toRenderBlendWithoutZWritePrimitives = this._toRenderBlendWithoutZWritePrimitives;
        renderPass.__postEachRenderFunc = this.__postEachRenderFunc;
        renderPass.__renderTargetColorAttachments = (_b = this.__renderTargetColorAttachments) == null ? void 0 : _b.concat();
        renderPass._lastOpaqueIndex = this._lastOpaqueIndex;
        renderPass._lastTranslucentIndex = this._lastTranslucentIndex;
        renderPass._lastBlendWithZWriteIndex = this._lastBlendWithZWriteIndex;
        renderPass._lastBlendWithoutZWriteIndex = this._lastBlendWithoutZWriteIndex;
        renderPass._lastPrimitiveUids = this._lastPrimitiveUids.concat();
        renderPass._lastTransformComponentsUpdateCount = this._lastTransformComponentsUpdateCount;
        renderPass._lastCameraControllerComponentsUpdateCount = this._lastCameraControllerComponentsUpdateCount;
        renderPass._lastSceneGraphComponentsUpdateCount = this._lastSceneGraphComponentsUpdateCount;
        renderPass._renderedSomethingBefore = this._renderedSomethingBefore;
        renderPass._isChangedSortRenderResult = this._isChangedSortRenderResult;
        return renderPass;
      }
      setPostRenderFunction(func) {
        this.__postEachRenderFunc = func;
      }
      doPostRender() {
        if (this.__postEachRenderFunc != null) {
          this.__postEachRenderFunc();
        }
      }
      /**
      * Add entities to draw.
      * @param entities An array of entities.
      */
      addEntities(entities) {
        for (const entity of entities) {
          const sceneGraphComponent = entity.getSceneGraph();
          this.__sceneGraphDirectlyAdded.push(sceneGraphComponent);
          const collectedSgComponents = flattenHierarchy(sceneGraphComponent, false);
          const collectedEntities = collectedSgComponents.map((sg) => {
            return sg.entity;
          });
          const map = this.__entities.concat(collectedEntities).reduce((map2, entity2) => {
            map2.set(entity2.entityUID, entity2);
            return map2;
          }, /* @__PURE__ */ new Map());
          this.__entities = Array.from(map.values());
        }
        this.__calcMeshComponents();
        this.__topLevelSceneGraphComponents = [];
        this.__collectTopLevelSceneGraphComponents();
      }
      __calcMeshComponents() {
        this.__meshComponents = [];
        this.__optimizedMeshComponents = [];
        this.__collectMeshComponents();
      }
      /**
      * Gets the list of entities on this render pass.
      * @return An array of entities
      */
      get entities() {
        return this.__entities;
      }
      /**
      * Clear entities on this render pass.
      */
      clearEntities() {
        this.__meshComponents = [];
        this.__optimizedMeshComponents = [];
        this.__topLevelSceneGraphComponents = [];
        this.__entities = [];
      }
      __collectTopLevelSceneGraphComponents() {
        const goToTopLevel = /* @__PURE__ */ __name((sg) => {
          if (sg.parent) {
            goToTopLevel(sg.parent);
          }
          return sg;
        }, "goToTopLevel");
        this.__topLevelSceneGraphComponents = this.__sceneGraphDirectlyAdded.map((sg) => {
          return goToTopLevel(sg);
        });
        const set = new Set(this.__topLevelSceneGraphComponents);
        this.__topLevelSceneGraphComponents = Array.from(set);
      }
      __collectMeshComponents() {
        this.__meshComponents = [];
        this.__optimizedMeshComponents = [];
        this.__entities.filter((entity) => {
          const meshComponent = entity.getComponentByComponentTID(WellKnownComponentTIDs.MeshComponentTID);
          if (meshComponent != null && meshComponent.mesh != null) {
            this.__meshComponents.push(meshComponent);
            if (!this._toRenderOpaquePrimitives && meshComponent.mesh.isExistOpaque()) {
              return;
            }
            if (!this._toRenderTranslucentPrimitives && meshComponent.mesh.isExistTranslucent()) {
              return;
            }
            if (!this._toRenderBlendWithZWritePrimitives && meshComponent.mesh.isExistBlendWithZWrite()) {
              return;
            }
            if (!this._toRenderBlendWithoutZWritePrimitives && meshComponent.mesh.isExistBlendWithoutZWrite()) {
              return;
            }
            this.__optimizedMeshComponents.push(meshComponent);
          }
        });
      }
      /**
      * Get all the MeshComponents list of the entities on this render pass.
      * @return An array of MeshComponents
      */
      get meshComponents() {
        return this.__meshComponents;
      }
      /**
      * Get MeshComponents list to render
      * @return An array of MeshComponents
      */
      get _optimizedMeshComponents() {
        return this.__optimizedMeshComponents;
      }
      /**
      * Get all the highest level SceneGraphComponents list of the entities on this render pass.
      * @return An array of SceneGraphComponents
      */
      get sceneTopLevelGraphComponents() {
        return this.__topLevelSceneGraphComponents;
      }
      /**
      * Sets the target framebuffer of this render pass.
      * If two or more render pass share a framebuffer, Rhodonite renders entities to the same framebuffer in those render passes.
      * @param framebuffer A framebuffer
      */
      setFramebuffer(framebuffer) {
        this.__frameBuffer = framebuffer;
        if (framebuffer != null) {
          this.setViewport(Vector4.fromCopyArray([
            0,
            0,
            framebuffer.width,
            framebuffer.height
          ]));
        } else {
          this.__viewport = void 0;
        }
      }
      setRenderTargetColorAttachments(indeces) {
        this.__renderTargetColorAttachments = indeces;
      }
      getRenderTargetColorAttachments() {
        return this.__renderTargetColorAttachments;
      }
      /**
      * Gets the framebuffer if this render pass has the target framebuffer.
      * @return A framebuffer
      */
      getFramebuffer() {
        return this.__frameBuffer;
      }
      /**
      * Remove the existing framebuffer
      */
      removeFramebuffer() {
        this.__frameBuffer = void 0;
      }
      /**
      * Sets the viewport of this render pass.
      * @param vec A Vector4 (Origin of coordinatesX, origin of coordinatesY, width, height).
      */
      setViewport(vec) {
        if (this.__viewport != null) {
          this.__viewport.copyComponents(vec);
        } else {
          this.__viewport = MutableVector4.fromCopyArray([
            vec.x,
            vec.y,
            vec.z,
            vec.w
          ]);
        }
      }
      /**
      * Gets the viewport if this render pass has the viewport.
      * @return A Vector4 (Origin of coordinatesX, origin of coordinatesY, width, height).
      */
      getViewport() {
        let viewport = this.__viewport;
        if (viewport != null) {
          viewport = _RenderPass.__tmp_Vector4_0.copyComponents(viewport);
        }
        return viewport;
      }
      setResolveFramebuffer(framebuffer) {
        this.__resolveFrameBuffer = framebuffer;
      }
      getResolveFramebuffer() {
        return this.__resolveFrameBuffer;
      }
      setResolveFramebuffer2(framebuffer) {
        this.__resolveFrameBuffer2 = framebuffer;
      }
      getResolveFramebuffer2() {
        return this.__resolveFrameBuffer2;
      }
      _copyFramebufferToResolveFramebuffersWebGL() {
        this.__copyFramebufferToResolveFramebufferInner(this.__resolveFrameBuffer);
        this.__copyFramebufferToResolveFramebufferInner(this.__resolveFrameBuffer2);
      }
      __copyFramebufferToResolveFramebufferInner(resolveFrameBuffer) {
        if (resolveFrameBuffer == null) {
          return;
        }
        const repo = WebGLResourceRepository.getInstance();
        const webGLResourceFrameBuffer = repo.getWebGLResource(this.__frameBuffer.cgApiResourceUid);
        const webGLResourceResolveFramebuffer = repo.getWebGLResource(resolveFrameBuffer.cgApiResourceUid);
        if (webGLResourceFrameBuffer == null || webGLResourceResolveFramebuffer == null) {
          return;
        }
        const glw = repo.currentWebGLContextWrapper;
        const gl = glw.getRawContextAsWebGL2();
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, webGLResourceFrameBuffer);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, webGLResourceResolveFramebuffer);
        gl.blitFramebuffer(0, 0, this.__frameBuffer.width, this.__frameBuffer.height, 0, 0, resolveFrameBuffer.width, resolveFrameBuffer.height, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.NEAREST);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      }
      _copyResolve1ToResolve2WebGpu() {
        if (this.__resolveFrameBuffer == null || this.__resolveFrameBuffer2 == null) {
          return;
        }
        const webGpuResourceRepository = CGAPIResourceRepository.getWebGpuResourceRepository();
        for (let i2 = 0; i2 < this.__resolveFrameBuffer.colorAttachments.length; i2++) {
          if (this.__resolveFrameBuffer.colorAttachments[i2] == null || this.__resolveFrameBuffer2.colorAttachments[i2] == null || this.__resolveFrameBuffer.colorAttachments[i2]._textureResourceUid === -1 || this.__resolveFrameBuffer2.colorAttachments[i2]._textureResourceUid === -1) {
            continue;
          }
          webGpuResourceRepository.copyTextureData(this.__resolveFrameBuffer.colorAttachments[i2]._textureResourceUid, this.__resolveFrameBuffer2.colorAttachments[i2]._textureResourceUid);
        }
      }
      /**
      * Sets a material for the primitive on this render pass.
      * If Rhodonite draw the primitive using this render pass, Rhodonite uses this material instead of the material on the primitive.
      * @param material A material attaching to the primitive
      * @param primitive A target primitive
      */
      setMaterialForPrimitive(material, primitive) {
        this.__primitiveMaterial.set(primitive.objectUID, new WeakRef(material));
      }
      /**
      * Sets a material for all the primitive on this render pass.
      * For all the primitive, Rhodonite uses this material instead of the material on the primitive.
      * Where if this render pass has a map between primitive and material by setMaterialForPrimitive, Rhodonite uses the material mapped by primitive.
      * @param material A material attaching to the primitive
      */
      setMaterial(material) {
        this.__material = material;
      }
      get material() {
        return this.__material;
      }
      _getMaterialOf(primitive) {
        var _a40;
        return (_a40 = this.__primitiveMaterial.get(primitive.objectUID)) == null ? void 0 : _a40.deref();
      }
      __hasMaterialOf(primitive) {
        return this.__primitiveMaterial.has(primitive.objectUID);
      }
      getAppropriateMaterial(primitive) {
        let material = this._getMaterialOf(primitive);
        if (material != null) {
        } else if (this.__material != null) {
          material = this.__material;
        } else {
          material = primitive.material;
        }
        return material;
      }
      get renderPassUID() {
        return this.__renderPassUID;
      }
    };
    __name(_RenderPass, "RenderPass");
    __publicField(_RenderPass, "__tmp_Vector4_0", MutableVector4.zero());
    __publicField(_RenderPass, "__mesh_uid_count", -1);
    RenderPass = _RenderPass;
  }
});

// src/foundation/math/Transform3D.ts
var _Transform3D, Transform3D;
var init_Transform3D = __esm({
  "src/foundation/math/Transform3D.ts"() {
    "use strict";
    init_Matrix44();
    init_MutableMatrix44();
    init_MutableQuaternion();
    init_MutableVector3();
    init_Quaternion();
    init_Vector3();
    _Transform3D = class _Transform3D {
      constructor(x) {
        __publicField(this, "__position");
        __publicField(this, "__scale");
        __publicField(this, "__rotation");
        __publicField(this, "__updateCount", 0);
        this.__position = MutableVector3.dummy();
        this.__scale = MutableVector3.dummy();
        this.__rotation = MutableQuaternion.dummy();
        if (x !== void 0) {
          this.setTransform(x.positionInner, x.scaleInner, MutableQuaternion.fromCopyQuaternion(x.rotationInner));
        } else {
          this.__position = MutableVector3.zero();
          this.__scale = MutableVector3.one();
          this.__rotation = MutableQuaternion.identity();
        }
      }
      isEqual(rhs, delta = Number.EPSILON) {
        return this.positionInner.isEqual(rhs.positionInner, delta) && this.rotationInner.isEqual(rhs.rotationInner, delta) && this.scaleInner.isEqual(rhs.scaleInner, delta);
      }
      clone() {
        const clone = new _Transform3D(this);
        return clone;
      }
      set position(vec) {
        this.__position.copyComponents(vec);
        this.__updateTransform();
      }
      setPositionAsArray3(array) {
        this.__position._v[0] = array[0];
        this.__position._v[1] = array[1];
        this.__position._v[2] = array[2];
        this.__updateTransform();
      }
      /**
      * return a copy of a local position vector
      */
      get position() {
        return this.positionInner.clone();
      }
      /**
      * return a local position vector
      */
      get positionInner() {
        return this.__position;
      }
      set eulerAngles(vec) {
        const sx = Math.sin(vec._v[0] * 0.5);
        const cx = Math.cos(vec._v[0] * 0.5);
        const sy = Math.sin(vec._v[1] * 0.5);
        const cy = Math.cos(vec._v[1] * 0.5);
        const sz = Math.sin(vec._v[2] * 0.5);
        const cz = Math.cos(vec._v[2] * 0.5);
        this.rotation = MutableQuaternion.fromCopy4(sx * cy * cz - cx * sy * sz, cx * sy * cz + sx * cy * sz, cx * cy * sz - sx * sy * cz, cx * cy * cz + sx * sy * sz);
      }
      /**
      * return a copy of a local rotation (XYZ euler) vector
      */
      get eulerAngles() {
        return this.eulerAnglesInner.clone();
      }
      /**
      * return a local rotation (XYZ euler) vector
      */
      get eulerAnglesInner() {
        return this.__rotation.toEulerAngles();
      }
      set scale(vec) {
        this.__scale.copyComponents(vec);
        this.__updateTransform();
      }
      setScaleAsArray3(array) {
        this.__scale._v[0] = array[0];
        this.__scale._v[1] = array[1];
        this.__scale._v[2] = array[2];
        this.__updateTransform();
      }
      /**
      * return a copy of a local scale vector
      */
      get scale() {
        return this.scaleInner.clone();
      }
      /**
      * return a local scale vector
      */
      get scaleInner() {
        return this.__scale;
      }
      set rotation(quat) {
        this.__rotation.copyComponents(quat);
        this.__updateTransform();
      }
      setRotationAsArray4(array) {
        this.__rotation._v[0] = array[0];
        this.__rotation._v[1] = array[1];
        this.__rotation._v[2] = array[2];
        this.__rotation._v[3] = array[3];
        this.__updateTransform();
      }
      /**
      * return a copy of a local quaternion vector
      */
      get rotation() {
        return this.rotationInner.clone();
      }
      /**
      * return a local quaternion vector
      */
      get rotationInner() {
        return this.__rotation;
      }
      __updateTransform() {
        this.__updateCount++;
      }
      set matrix(mat) {
        this.__rotation.fromMatrix(mat);
        mat.getTranslateTo(this.__position);
        mat.getScaleTo(this.__scale);
        this.__updateTransform();
      }
      /**
      * return a copy of local transform matrix
      */
      get matrix() {
        return this.matrixInner;
      }
      /**
      * return a local transform matrix
      */
      get matrixInner() {
        const scale = this.scaleInner;
        const n00 = scale._v[0];
        const n11 = scale._v[1];
        const n22 = scale._v[2];
        const q = this.rotationInner;
        const sx = q._v[0] * q._v[0];
        const sy = q._v[1] * q._v[1];
        const sz = q._v[2] * q._v[2];
        const cx = q._v[1] * q._v[2];
        const cy = q._v[0] * q._v[2];
        const cz = q._v[0] * q._v[1];
        const wx = q._v[3] * q._v[0];
        const wy = q._v[3] * q._v[1];
        const wz = q._v[3] * q._v[2];
        const m00 = 1 - 2 * (sy + sz);
        const m01 = 2 * (cz - wz);
        const m02 = 2 * (cy + wy);
        const m10 = 2 * (cz + wz);
        const m11 = 1 - 2 * (sx + sz);
        const m12 = 2 * (cx - wx);
        const m20 = 2 * (cy - wy);
        const m21 = 2 * (cx + wx);
        const m22 = 1 - 2 * (sx + sy);
        const translate = this.positionInner;
        const mat = MutableMatrix44.fromCopy16RowMajor(m00 * n00, m01 * n11, m02 * n22, translate.x, m10 * n00, m11 * n11, m12 * n22, translate.y, m20 * n00, m21 * n11, m22 * n22, translate.z, 0, 0, 0, 1);
        return mat;
      }
      getMatrixInnerTo(mat) {
        const scale = this.scaleInner;
        const n00 = scale._v[0];
        const n11 = scale._v[1];
        const n22 = scale._v[2];
        const q = this.rotationInner;
        const sx = q._v[0] * q._v[0];
        const sy = q._v[1] * q._v[1];
        const sz = q._v[2] * q._v[2];
        const cx = q._v[1] * q._v[2];
        const cy = q._v[0] * q._v[2];
        const cz = q._v[0] * q._v[1];
        const wx = q._v[3] * q._v[0];
        const wy = q._v[3] * q._v[1];
        const wz = q._v[3] * q._v[2];
        const m00 = 1 - 2 * (sy + sz);
        const m01 = 2 * (cz - wz);
        const m02 = 2 * (cy + wy);
        const m10 = 2 * (cz + wz);
        const m11 = 1 - 2 * (sx + sz);
        const m12 = 2 * (cx - wx);
        const m20 = 2 * (cy - wy);
        const m21 = 2 * (cx + wx);
        const m22 = 1 - 2 * (sx + sy);
        const translate = this.positionInner;
        mat.setComponents(m00 * n00, m01 * n11, m02 * n22, translate.x, m10 * n00, m11 * n11, m12 * n22, translate.y, m20 * n00, m21 * n11, m22 * n22, translate.z, 0, 0, 0, 1);
      }
      get updateCount() {
        return this.__updateCount;
      }
      set rotateMatrix44(rotateMatrix) {
        this.rotation = _Transform3D.__tmpQuaternion_0.fromMatrix(rotateMatrix);
      }
      get rotateMatrix44() {
        return Matrix44.fromCopyQuaternion(this.rotation);
      }
      setPropertiesFromJson(arg) {
        let json = arg;
        if (typeof arg === "string") {
          json = JSON.parse(arg);
        }
        for (const key in json) {
          if (json.hasOwnProperty(key) && key in this) {
            if (key === "quaternion") {
              this["rotation"] = Quaternion.fromCopyArray4(json[key]);
            } else if (key === "matrix") {
              this[key] = Matrix44.fromCopyArray16RowMajor(json[key]);
            } else {
              this[key] = Vector3.fromCopyArray(json[key]);
            }
          }
        }
      }
      setRotationFromNewUpAndFront(UpVec, FrontVec) {
        const yDir = UpVec;
        const xDir = MutableVector3.crossTo(yDir, FrontVec, _Transform3D.__tmpVector3_0);
        const zDir = MutableVector3.crossTo(xDir, yDir, _Transform3D.__tmpVector3_1);
        const rotateMatrix = _Transform3D.__tmpMatrix44_0.setComponents(xDir.x, yDir.x, zDir.x, 0, xDir.y, yDir.y, zDir.y, 0, xDir.z, yDir.z, zDir.z, 0, 0, 0, 0, 1);
        this.rotateMatrix44 = rotateMatrix;
      }
      headToDirection(fromVec, toVec) {
        const fromDir = _Transform3D.__tmpVector3_0.copyComponents(fromVec).normalize();
        const toDir = _Transform3D.__tmpVector3_1.copyComponents(toVec).normalize();
        const rotationDir = MutableVector3.crossTo(fromDir, toDir, _Transform3D.__tmpVector3_2);
        const cosTheta = Vector3.dot(fromDir, toDir);
        const theta = Math.acos(cosTheta);
        this.rotation = _Transform3D.__tmpQuaternion_0.axisAngle(rotationDir, theta);
      }
      /**
      * Set multiple transform information at once. By using this method,
      * we reduce the cost of automatically updating other transform components inside this class.
      * This method may be useful for animation processing and so on.
      *
      * The transform components of these arguments must not be mutually discrepant.
      * for example. The transform components of matrix argument (translate, rotate/quaternion, scale)
      * must be equal to translate, rotate, scale, quaternion arguments.
      * And both rotate and quaternion arguments must be same rotation.
      * If there is an argument passed with null or undefined, it is interpreted as unchanged.
      *
      * @param {*} translate
      * @param {*} scale
      * @param {*} rotation
      */
      setTransform(translate, scale, rotation) {
        this.__position = translate.clone();
        this.__rotation = rotation.clone();
        this.__scale = scale.clone();
        this.__updateTransform();
      }
    };
    __name(_Transform3D, "Transform3D");
    __publicField(_Transform3D, "__tmpMatrix44_0", MutableMatrix44.zero());
    __publicField(_Transform3D, "__tmpVector3_0", MutableVector3.zero());
    __publicField(_Transform3D, "__tmpVector3_1", MutableVector3.zero());
    __publicField(_Transform3D, "__tmpVector3_2", MutableVector3.zero());
    __publicField(_Transform3D, "__tmpQuaternion_0", MutableQuaternion.identity());
    Transform3D = _Transform3D;
  }
});

// src/foundation/components/Transform/TransformComponent.ts
var _TransformComponent, TransformComponent;
var init_TransformComponent = __esm({
  "src/foundation/components/Transform/TransformComponent.ts"() {
    "use strict";
    init_Component();
    init_EntityRepository();
    init_WellKnownComponentTIDs();
    init_ProcessStage();
    init_misc();
    init_Transform3D();
    init_MutableQuaternion();
    _TransformComponent = class _TransformComponent extends Component {
      constructor(entityUid, componentSid, entityComponent, isReUse) {
        super(entityUid, componentSid, entityComponent, isReUse);
        __publicField(this, "__rest");
        __publicField(this, "__pose", new Transform3D());
        __publicField(this, "__updateCountAtLastLogic", 0);
      }
      static get renderedPropertyCount() {
        return null;
      }
      static get componentTID() {
        return WellKnownComponentTIDs.TransformComponentTID;
      }
      get componentTID() {
        return WellKnownComponentTIDs.TransformComponentTID;
      }
      get restOrPose() {
        if (this.__rest !== void 0) {
          return this.__rest;
        } else {
          return this.__pose;
        }
      }
      static get updateCount() {
        return this.__updateCount;
      }
      _backupTransformAsRest() {
        if (this.__rest === void 0) {
          this.__rest = this.__pose.clone();
          const sceneGraphComponent = this.entity.tryToGetSceneGraph();
          sceneGraphComponent.setWorldMatrixRestDirty();
        }
      }
      _restoreTransformFromRest() {
        if (this.__rest === void 0) {
          return;
        }
        this.__pose.setTransform(this.__rest.positionInner, this.__rest.scaleInner, MutableQuaternion.fromCopyQuaternion(this.__rest.rotationInner));
      }
      get localTransform() {
        return this.__pose;
      }
      set localTransform(transform) {
        this.__pose.setTransform(transform.positionInner, transform.scaleInner, MutableQuaternion.fromCopyQuaternion(transform.rotationInner));
        _TransformComponent.__updateCount++;
      }
      get localTransformRest() {
        return this.restOrPose;
      }
      set localTransformRest(transform) {
        if (Is.undefined(this.__rest)) {
          this.__rest = new Transform3D();
        }
        this.__rest.setTransform(transform.positionInner, transform.scaleInner, MutableQuaternion.fromCopyQuaternion(transform.rotationInner));
        _TransformComponent.__updateCount++;
      }
      set localPosition(vec) {
        this.__pose.position = vec;
        _TransformComponent.__updateCount++;
      }
      setLocalPositionAsArray3(array) {
        this.__pose.setPositionAsArray3(array);
        _TransformComponent.__updateCount++;
      }
      /**
      * return a copy of a local translate vector
      */
      get localPosition() {
        return this.__pose.position;
      }
      /**
      * return a local translate vector
      */
      get localPositionInner() {
        return this.__pose.positionInner;
      }
      /**
      * set a local translate vector as Rest
      */
      set localPositionRest(vec) {
        if (Is.undefined(this.__rest)) {
          this.__rest = this.__pose.clone();
        }
        this.__rest.position = vec;
        _TransformComponent.__updateCount++;
      }
      /**
      * return a copy of a local translate vector
      */
      get localPositionRest() {
        return this.restOrPose.position;
      }
      /**
      * return a local translate vector
      */
      get localPositionRestInner() {
        return this.restOrPose.positionInner;
      }
      set localEulerAngles(vec) {
        this.__pose.eulerAngles = vec;
        _TransformComponent.__updateCount++;
      }
      /**
      * return a copy of a local rotation (XYZ euler) vector
      */
      get localEulerAngles() {
        return this.__pose.eulerAngles;
      }
      /**
      * return a local rotation (XYZ euler) vector
      */
      get localEulerAnglesInner() {
        return this.__pose.eulerAnglesInner;
      }
      /**
      * set a local rotation (XYZ euler) vector as Rest
      */
      set localEulerAnglesRest(vec) {
        if (Is.undefined(this.__rest)) {
          this.__rest = this.__pose.clone();
        }
        this.__rest.eulerAngles = vec;
        _TransformComponent.__updateCount++;
      }
      /**
      * return a copy of a local rotation (XYZ euler) vector
      */
      get localEulerAnglesRest() {
        return this.restOrPose.eulerAngles;
      }
      /**
      * return a local rotation (XYZ euler) vector
      */
      get localEulerAnglesRestInner() {
        return this.restOrPose.eulerAnglesInner;
      }
      set localScale(vec) {
        this.__pose.scale = vec;
        _TransformComponent.__updateCount++;
      }
      setLocalScaleAsArray3(array) {
        this.__pose.setScaleAsArray3(array);
        _TransformComponent.__updateCount++;
      }
      /**
      * return a copy of a local scale vector
      */
      get localScale() {
        return this.__pose.scale;
      }
      /**
      * return a local scale vector
      */
      get localScaleInner() {
        return this.__pose.scaleInner;
      }
      /**
      * set a local scale vector as Rest
      */
      set localScaleRest(vec) {
        if (Is.undefined(this.__rest)) {
          this.__rest = this.__pose.clone();
        }
        this.__rest.scale = vec;
        _TransformComponent.__updateCount++;
      }
      /**
      * return a copy of a local scale vector
      */
      get localScaleRest() {
        return this.restOrPose.scale;
      }
      /**
      * return a local scale vector
      */
      get localScaleRestInner() {
        return this.restOrPose.scaleInner;
      }
      set localRotation(quat) {
        this.__pose.rotation = quat;
        _TransformComponent.__updateCount++;
      }
      setLocalRotationAsArray4(array) {
        this.__pose.setRotationAsArray4(array);
        _TransformComponent.__updateCount++;
      }
      /**
      * return a copy of a local quaternion vector
      */
      get localRotation() {
        return this.__pose.rotation;
      }
      /**
      * return a local quaternion vector
      */
      get localRotationInner() {
        return this.__pose.rotationInner;
      }
      /**
      * set a local quaternion vector as Rest
      */
      set localRotationRest(quat) {
        if (Is.undefined(this.__rest)) {
          this.__rest = this.__pose.clone();
        }
        this.__rest.rotation = quat;
        _TransformComponent.__updateCount++;
      }
      /**
      * return a copy of a local quaternion vector
      */
      get localRotationRest() {
        return this.restOrPose.rotation;
      }
      /**
      * return a local quaternion vector
      */
      get localRotationRestInner() {
        return this.restOrPose.rotationInner;
      }
      set localMatrix(mat) {
        this.__pose.matrix = mat;
        _TransformComponent.__updateCount++;
      }
      /**
      * return a copy of local transform matrix
      */
      get localMatrix() {
        return this.__pose.matrix;
      }
      /**
      * return a local transform matrix
      */
      get localMatrixInner() {
        return this.__pose.matrixInner;
      }
      getLocalMatrixInnerTo(mat) {
        this.__pose.getMatrixInnerTo(mat);
      }
      /**
      * set a local transform matrix as Rest
      */
      set localMatrixRest(mat) {
        if (Is.undefined(this.__rest)) {
          this.__rest = this.__pose.clone();
        }
        this.__rest.matrix = mat;
        _TransformComponent.__updateCount++;
      }
      /**
      * return a copy of local transform matrix
      */
      get localMatrixRest() {
        return this.restOrPose.matrix;
      }
      /**
      * return a local transform matrix
      */
      get localMatrixRestInner() {
        return this.restOrPose.matrixInner;
      }
      $load() {
        this.moveStageTo(ProcessStage.Logic);
      }
      $logic() {
        if (this.__updateCountAtLastLogic !== this.__pose.updateCount) {
          this.entity.tryToGetSceneGraph().setWorldMatrixDirty();
          this.__updateCountAtLastLogic = this.__pose.updateCount;
        }
      }
      _shallowCopyFrom(component_) {
        const component = component_;
        this.__pose = component.__pose.clone();
        if (component.__rest != null) {
          this.__rest = component.__rest.clone();
        }
        this.__updateCountAtLastLogic = component.__updateCountAtLastLogic;
        _TransformComponent.__updateCount++;
      }
      /**
      * get the entity which has this component.
      * @returns the entity which has this component
      */
      get entity() {
        return EntityRepository.getEntity(this.__entityUid);
      }
      _destroy() {
        super._destroy();
      }
      /**
      * @override
      * Add this component to the entity
      * @param base the target entity
      * @param _componentClass the component class to add
      */
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let TransformEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
            __publicField(this, "__transformComponent");
          }
          getTransform() {
            if (this.__transformComponent === void 0) {
              this.__transformComponent = this.getComponentByComponentTID(WellKnownComponentTIDs.TransformComponentTID);
            }
            return this.__transformComponent;
          }
          set localPosition(vec) {
            const transform = this.getTransform();
            transform.localPosition = vec;
          }
          get localPosition() {
            return this.localPositionInner.clone();
          }
          get localPositionInner() {
            const transform = this.getTransform();
            return transform.localPositionInner;
          }
          set localPositionRest(vec) {
            const transform = this.getTransform();
            transform.localPositionRest = vec;
          }
          get localPositionRest() {
            const transform = this.getTransform();
            return transform.localPositionRest;
          }
          get localPositionRestInner() {
            const transform = this.getTransform();
            return transform.localPositionRestInner;
          }
          set localScale(vec) {
            const transform = this.getTransform();
            transform.localScale = vec;
          }
          get localScale() {
            return this.localScaleInner.clone();
          }
          get localScaleInner() {
            const transform = this.getTransform();
            return transform.localScaleInner;
          }
          set localScaleRest(vec) {
            const transform = this.getTransform();
            transform.localScaleRest = vec;
          }
          get localScaleRest() {
            const transform = this.getTransform();
            return transform.localScaleRest;
          }
          get localScaleRestInner() {
            const transform = this.getTransform();
            return transform.localScaleRestInner;
          }
          set localEulerAngles(vec) {
            const transform = this.getTransform();
            transform.localEulerAngles = vec;
          }
          get localEulerAngles() {
            return this.localEulerAnglesInner.clone();
          }
          get localEulerAnglesInner() {
            const transform = this.getTransform();
            return transform.localEulerAnglesInner;
          }
          set localEulerAnglesRest(vec) {
            const transform = this.getTransform();
            transform.localEulerAnglesRest = vec;
          }
          get localEulerAnglesRest() {
            return this.localEulerAnglesRestInner.clone();
          }
          get localEulerAnglesRestInner() {
            const transform = this.getTransform();
            return transform.localEulerAnglesRestInner;
          }
          set localRotation(quat) {
            const transform = this.getTransform();
            transform.localRotation = quat;
          }
          get localRotation() {
            return this.localRotationInner.clone();
          }
          get localRotationInner() {
            const transform = this.getTransform();
            return transform.localRotationInner;
          }
          set localRotationRest(quat) {
            const transform = this.getTransform();
            transform.localRotationRest = quat;
          }
          get localRotationRest() {
            return this.localQuaternionRestInner.clone();
          }
          get localRotationRestInner() {
            const transform = this.getTransform();
            return transform.localRotationRestInner;
          }
          set localMatrix(mat) {
            const transform = this.getTransform();
            transform.localMatrix = mat;
          }
          get localMatrix() {
            return this.localMatrixInner.clone();
          }
          get localMatrixInner() {
            const transform = this.getTransform();
            return transform.localMatrixInner;
          }
          set localMatrixRest(mat) {
            const transform = this.getTransform();
            transform.localMatrixRest = mat;
          }
          get localMatrixRest() {
            return this.localMatrixRestInner.clone();
          }
          get localMatrixRestInner() {
            const transform = this.getTransform();
            return transform.localMatrixRestInner;
          }
        }, __name(_a40, "TransformEntity"), _a40);
        applyMixins(base, TransformEntity);
        return base;
      }
    };
    __name(_TransformComponent, "TransformComponent");
    __publicField(_TransformComponent, "__updateCount", 0);
    TransformComponent = _TransformComponent;
  }
});

// src/foundation/components/CameraController/CameraControllerComponent.ts
var _CameraControllerComponent, CameraControllerComponent;
var init_CameraControllerComponent = __esm({
  "src/foundation/components/CameraController/CameraControllerComponent.ts"() {
    "use strict";
    init_Component();
    init_EntityRepository();
    init_WellKnownComponentTIDs();
    init_OrbitCameraController();
    init_WalkThroughCameraController();
    init_CameraControllerType();
    init_definitions();
    init_Logger();
    _CameraControllerComponent = class _CameraControllerComponent extends Component {
      constructor(entityUid, componentSid, entityRepository, isReUse) {
        super(entityUid, componentSid, entityRepository, isReUse);
        __publicField(this, "__cameraController");
        this.__cameraController = new OrbitCameraController(this);
      }
      set type(type) {
        this.__cameraController.unregisterEventListeners();
        if (type === CameraControllerType.Orbit) {
          this.__cameraController = new OrbitCameraController(this);
        } else if (type === CameraControllerType.WalkThrough) {
          this.__cameraController = new WalkThroughCameraController(this);
        } else {
          Logger.warn("Not support type!");
        }
      }
      get type() {
        if (this.__cameraController instanceof OrbitCameraController) {
          return CameraControllerType.Orbit;
        } else {
          return CameraControllerType.WalkThrough;
        }
      }
      get controller() {
        return this.__cameraController;
      }
      static get componentTID() {
        return WellKnownComponentTIDs.CameraControllerComponentTID;
      }
      get componentTID() {
        return WellKnownComponentTIDs.CameraControllerComponentTID;
      }
      $load() {
        this.moveStageTo(ProcessStage.Logic);
      }
      $logic() {
        if (this.__cameraController) {
          this.__cameraController.logic(this.entity.tryToGetCamera());
        }
      }
      _updateCount(count) {
        _CameraControllerComponent.__updateCount = count;
      }
      static get updateCount() {
        return _CameraControllerComponent.__updateCount;
      }
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let CameraControllerEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
          }
          getCameraController() {
            return this.getComponentByComponentTID(WellKnownComponentTIDs.CameraControllerComponentTID);
          }
        }, __name(_a40, "CameraControllerEntity"), _a40);
        applyMixins(base, CameraControllerEntity);
        return base;
      }
    };
    __name(_CameraControllerComponent, "CameraControllerComponent");
    __publicField(_CameraControllerComponent, "__updateCount", 0);
    CameraControllerComponent = _CameraControllerComponent;
  }
});

// src/foundation/gizmos/Gizmo.ts
var _Gizmo, Gizmo;
var init_Gizmo = __esm({
  "src/foundation/gizmos/Gizmo.ts"() {
    "use strict";
    init_RnObject();
    init_SceneGraphOps();
    _Gizmo = class _Gizmo extends RnObject {
      /**
      * Constructor
      * @param entity the object which this gizmo belong to
      */
      constructor(target) {
        super();
        /**
        * The top entity of this gizmo group.
        * A programmer who implements a gizmo class has to make this entity
        * a child of the target entity's scene graph component
        * that the gizmo will belong to manually.
        */
        __publicField(this, "__topEntity");
        /** the target entity which this gizmo belong to */
        __publicField(this, "__target");
        __publicField(this, "__isVisible", false);
        this.__target = target;
        this.setGizmoTag();
      }
      ///
      ///
      /// Accessors
      ///
      ///
      set isVisible(flg) {
        this.__setVisible(flg);
      }
      get isVisible() {
        return this.__isVisible;
      }
      __setVisible(flg) {
        this.__isVisible = flg;
        if (this.__topEntity) {
          this.__topEntity.getSceneGraph().setVisibilityRecursively(flg);
        }
      }
      __toSkipSetup() {
        if (this.isSetup) {
          return true;
        }
        if (this.__target.matchTag("Being", "gizmo")) {
          return true;
        }
        return false;
      }
      setGizmoTag() {
        if (this.__topEntity) {
          this.__topEntity.tryToSetTag({
            tag: "Being",
            value: "gizmo"
          });
          this.__topEntity.tryToSetTag({
            tag: "Gizmo",
            value: "top"
          });
          const sceneGraphs = flattenHierarchy(this.__topEntity.getSceneGraph(), false);
          for (const sg of sceneGraphs) {
            sg.entity.tryToSetTag({
              tag: "Being",
              value: "gizmo"
            });
          }
          this.__topEntity.tryToSetTag({
            tag: "type",
            value: "background-assets"
          });
        }
      }
    };
    __name(_Gizmo, "Gizmo");
    Gizmo = _Gizmo;
  }
});

// src/foundation/geometry/Mesh.ts
var _Mesh, Mesh;
var init_Mesh = __esm({
  "src/foundation/geometry/Mesh.ts"() {
    "use strict";
    init_VertexAttribute();
    init_PrimitiveMode();
    init_MemoryManager();
    init_BufferUse();
    init_ComponentType();
    init_CompositionType();
    init_Vector3();
    init_AABB();
    init_CGAPIResourceRepository();
    init_MutableVector3();
    init_Is();
    init_GeometryTypes();
    init_ProcessStage();
    init_Logger();
    _Mesh = class _Mesh {
      /**
      * Constructor
      */
      constructor() {
        __publicField(this, "__meshUID");
        __publicField(this, "__primitives", []);
        __publicField(this, "__opaquePrimitives", []);
        __publicField(this, "__translucentPrimitives", []);
        __publicField(this, "__blendWithZWritePrimitives", []);
        __publicField(this, "__blendWithoutZWritePrimitives", []);
        __publicField(this, "__morphPrimitives", []);
        __publicField(this, "__localAABB", new AABB());
        __publicField(this, "__vaoUids", []);
        __publicField(this, "__variationVBOUid", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__latestPrimitivePositionAccessorVersionForAABB", 0);
        __publicField(this, "__latestPrimitivePositionAccessorVersionForSetUpDone", 0);
        __publicField(this, "__belongToEntities", []);
        /**
        * Specification of when calculate the tangent of a vertex to apply Normal texture (for pbr/MToon shader)
        * 0: Not calculate tangent (not apply normal texture)
        * 1: (default) Use original tangent in a vertex, if a vertex has tangent attribute. If a vertex does not have it, calculate a tangent in a shader.
        * 2: Use original tangent in a vertex, if a vertex has tangent attribute. If a vertex does not have it, precalculate a tangent in the javascript.
        * 3: Calculate all tangent in a shader.
        * 4: Precalculate all tangent in the javascript
        */
        __publicField(this, "tangentCalculationMode", 1);
        __publicField(this, "__hasFaceNormal", false);
        __publicField(this, "__primitivePositionUpdateCount", 0);
        this.__meshUID = ++_Mesh.__mesh_uid_count;
      }
      ///
      ///
      /// Public Members
      ///
      ///
      getVaoUids(index) {
        return this.__vaoUids[index];
      }
      getVaoUidsByPrimitiveUid(primitiveUid) {
        const index = this.__primitives.findIndex((primitive) => primitive.primitiveUid === primitiveUid);
        return this.__vaoUids[index];
      }
      get meshEntitiesInner() {
        return this.__belongToEntities;
      }
      _belongToMeshComponent(meshComponent) {
        this.__belongToEntities.push(meshComponent.entity);
      }
      /**
      * Adds primitive.
      * @param primitive The primitive object.
      */
      addPrimitive(primitive) {
        primitive._belongToMesh(this);
        if (isOpaque(primitive)) {
          this.__opaquePrimitives.push(primitive);
        } else if (isTranslucent(primitive)) {
          this.__translucentPrimitives.push(primitive);
        } else if (isBlendWithZWrite(primitive)) {
          this.__blendWithZWritePrimitives.push(primitive);
        } else if (isBlendWithoutZWrite(primitive)) {
          this.__blendWithoutZWritePrimitives.push(primitive);
        }
        this.__setPrimitives(this.__opaquePrimitives.concat(this.__translucentPrimitives).concat(this.__blendWithZWritePrimitives).concat(this.__blendWithoutZWritePrimitives));
      }
      __setPrimitives(primitives) {
        this.__primitives = primitives;
      }
      isExistOpaque() {
        return this.__opaquePrimitives.length > 0;
      }
      isExistTranslucent() {
        return this.__translucentPrimitives.length > 0;
      }
      isExistBlendWithZWrite() {
        return this.__blendWithZWritePrimitives.length > 0;
      }
      isExistBlendWithoutZWrite() {
        return this.__blendWithoutZWritePrimitives.length > 0;
      }
      getPrimitiveAt(i2) {
        return this.__primitives[i2];
      }
      getPrimitiveNumber() {
        return this.__primitives.length;
      }
      /**
      * @internal
      * @returns true: updated, false: not changed (not dirty)
      */
      updateVariationVBO() {
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        if (this.__variationVBOUid !== CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          cgApiResourceRepository.deleteVertexBuffer(this.__variationVBOUid);
        }
        const instanceNum = this.__belongToEntities.length;
        const entityInfo = new Float32Array(instanceNum * 4);
        for (let i2 = 0; i2 < instanceNum; i2++) {
          entityInfo[4 * i2 + 0] = this.__belongToEntities[i2].getSceneGraph().componentSID;
          const skeletal = this.__belongToEntities[i2].tryToGetSkeletal();
          if (skeletal != null) {
            entityInfo[4 * i2 + 1] = skeletal.componentSID;
          } else {
            entityInfo[4 * i2 + 1] = -1;
          }
          const blendShape = this.__belongToEntities[i2].tryToGetBlendShape();
          if (blendShape != null) {
            entityInfo[4 * i2 + 2] = blendShape.componentSID;
          } else {
            entityInfo[4 * i2 + 2] = -1;
          }
        }
        this.__variationVBOUid = cgApiResourceRepository.createVertexBufferFromTypedArray(entityInfo);
        return true;
      }
      ///
      /// Public WebGL-related Methods
      ///
      /**
      * @internal
      * @returns true: updated, false: not changed (not dirty)
      */
      deleteVariationVBO() {
        const webglResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        if (this.__variationVBOUid !== CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          webglResourceRepository.deleteVertexBuffer(this.__variationVBOUid);
          this.__variationVBOUid = CGAPIResourceRepository.InvalidCGAPIResourceUid;
          return true;
        }
        return false;
      }
      updateVAO() {
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        for (let i2 = 0; i2 < this.__primitives.length; i2++) {
          const primitive = this.__primitives[i2];
          const vertexHandles = primitive.vertexHandles;
          if (Is.undefined(vertexHandles)) {
            Logger.warn("Need to create 3DAPIVertexData before update VAO");
            continue;
          }
          if (isNaN(this.__vaoUids[i2]) || this.__vaoUids[i2] === CGAPIResourceRepository.InvalidCGAPIResourceUid || vertexHandles.vaoHandle === CGAPIResourceRepository.InvalidCGAPIResourceUid) {
            this.__vaoUids[i2] = webglResourceRepository.createVertexArray();
            vertexHandles.vaoHandle = this.__vaoUids[i2];
          }
          webglResourceRepository.setVertexDataToPipeline(vertexHandles, primitive, this.__variationVBOUid);
        }
        for (let i2 = this.__primitives.length; i2 < this.__vaoUids.length; i2++) {
          if (this.__vaoUids[i2]) {
            webglResourceRepository.deleteVertexArray(this.__vaoUids[i2]);
            this.__vaoUids[i2] = CGAPIResourceRepository.InvalidCGAPIResourceUid;
          }
        }
      }
      deleteVAO() {
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        for (let i2 = 0; i2 < this.__vaoUids.length; i2++) {
          webglResourceRepository.deleteVertexArray(this.__vaoUids[i2]);
          this.__vaoUids[i2] = CGAPIResourceRepository.InvalidCGAPIResourceUid;
        }
      }
      castRay(srcPointInLocal, directionInLocal, dotThreshold = 0) {
        var _a40;
        let finalShortestIntersectedPosVec3;
        let finalShortestT = Number.MAX_VALUE;
        let u = 0;
        let v = 0;
        for (const primitive of this.__primitives) {
          const result = primitive.castRay(srcPointInLocal, directionInLocal, true, true, dotThreshold, this.__hasFaceNormal);
          if (Is.defined(result.data) && ((_a40 = result.data) == null ? void 0 : _a40.t) < finalShortestT) {
            finalShortestT = result.data.t;
            finalShortestIntersectedPosVec3 = result.data.position;
            u = result.data.u;
            v = result.data.v;
          }
        }
        if (Is.defined(finalShortestIntersectedPosVec3)) {
          return {
            result: true,
            data: {
              t: finalShortestT,
              u,
              v,
              position: finalShortestIntersectedPosVec3
            }
          };
        } else {
          return {
            result: false
          };
        }
      }
      ///
      ///
      /// Accessors
      ///
      ///
      get primitives() {
        return this.__primitives;
      }
      get meshUID() {
        return this.__meshUID;
      }
      /**
      * @internal
      */
      get _variationVBOUid() {
        return this.__variationVBOUid;
      }
      _onPrimitivePositionUpdated() {
        this.__primitivePositionUpdateCount++;
        for (const entity of this.__belongToEntities) {
          entity.getMeshRenderer().moveStageTo(ProcessStage.Load);
        }
      }
      get primitivePositionUpdateCount() {
        return this.__primitivePositionUpdateCount;
      }
      /**
      * Gets AABB in local space.
      */
      get AABB() {
        if (this.__primitivePositionUpdateCount !== this.__latestPrimitivePositionAccessorVersionForAABB) {
          this.__localAABB.initialize();
          this.__latestPrimitivePositionAccessorVersionForAABB = this.__primitivePositionUpdateCount;
        }
        if (this.__localAABB.isVanilla()) {
          for (const primitive of this.__primitives) {
            this.__localAABB.mergeAABB(primitive.AABB);
          }
        }
        return this.__localAABB;
      }
      ///
      ///
      // Friend Members
      ///
      ///
      ///
      ///
      /// Private Members
      ///
      ///
      __calcMorphPrimitives() {
        for (let i2 = 0; i2 < this.__primitives.length; i2++) {
          const morphPrimitive = this.__morphPrimitives[i2];
          const primitive = this.__primitives[i2];
          const target0Attributes = primitive.targets[0];
          target0Attributes.forEach((accessor, semantic) => {
            const morphAccessor = morphPrimitive.getAttribute(semantic);
            const elementCount = morphAccessor.elementCount;
            for (let j = 0; j < elementCount; j++) {
              morphAccessor.setElementFromSameCompositionAccessor(j, primitive.getAttribute(semantic));
            }
          });
        }
      }
      /**
      * @internal
      */
      _calcTangents() {
        if (!this.__usePreCalculatedTangent()) {
          return;
        }
        for (const primitive of this.__primitives) {
          const tangentIdx = primitive.attributeSemantics.indexOf(VertexAttribute.Tangent.XYZ);
          if (tangentIdx !== -1 && this.tangentCalculationMode === 2) {
            continue;
          }
          const texcoordIdx = primitive.attributeSemantics.indexOf(VertexAttribute.Texcoord0.XY);
          const normalIdx = primitive.attributeSemantics.indexOf(VertexAttribute.Normal.XYZ);
          if (texcoordIdx !== -1 && normalIdx !== -1) {
            const positionIdx = primitive.attributeSemantics.indexOf(VertexAttribute.Position.XYZ);
            const positionAccessor = primitive.attributeAccessors[positionIdx];
            const texcoordAccessor = primitive.attributeAccessors[texcoordIdx];
            const normalAccessor = primitive.attributeAccessors[normalIdx];
            const indicesAccessor = primitive.indicesAccessor;
            let incrementNum = 3;
            if (primitive.primitiveMode === PrimitiveMode.TriangleStrip || primitive.primitiveMode === PrimitiveMode.TriangleFan) {
              incrementNum = 1;
            }
            const vertexNum = primitive.getVertexCountAsIndicesBased();
            const buffer = MemoryManager.getInstance().createOrGetBuffer(BufferUse.CPUGeneric);
            const tangentAttributeByteSize = positionAccessor.byteLength * 4 / 3;
            const tangentBufferView = buffer.takeBufferView({
              byteLengthToNeed: tangentAttributeByteSize,
              byteStride: 0
            }).unwrapForce();
            const tangentAccessor = tangentBufferView.takeAccessor({
              compositionType: CompositionType.Vec4,
              componentType: ComponentType.Float,
              count: positionAccessor.elementCount
            }).unwrapForce();
            for (let i2 = 0; i2 < vertexNum - 2; i2 += incrementNum) {
              const pos0 = positionAccessor.getVec3(i2, {
                indicesAccessor
              });
              const pos1 = positionAccessor.getVec3(i2 + 1, {
                indicesAccessor
              });
              const pos2 = positionAccessor.getVec3(i2 + 2, {
                indicesAccessor
              });
              const uv0 = texcoordAccessor.getVec2(i2, {
                indicesAccessor
              });
              const uv1 = texcoordAccessor.getVec2(i2 + 1, {
                indicesAccessor
              });
              const uv2 = texcoordAccessor.getVec2(i2 + 2, {
                indicesAccessor
              });
              const norm0 = normalAccessor.getVec3(i2, {
                indicesAccessor
              });
              this.__calcTangentFor3Vertices(i2, pos0, pos1, pos2, uv0, uv1, uv2, norm0, tangentAccessor, indicesAccessor);
            }
            primitive.setVertexAttribute(tangentAccessor, VertexAttribute.Tangent.XYZ);
          }
        }
      }
      /**
      * @internal
      */
      __calcTangentFor3Vertices(i2, pos0, pos1, pos2, uv0, uv1, uv2, norm0, tangentAccessor, indicesAccessor) {
        const tan0Vec3 = this.__calcTangentPerVertex(pos0, pos1, pos2, uv0, uv1, uv2, norm0, _Mesh.__tmpReturnVec3_0);
        const tan1Vec3 = this.__calcTangentPerVertex(pos1, pos2, pos0, uv1, uv2, uv0, norm0, _Mesh.__tmpReturnVec3_1);
        const tan2Vec3 = this.__calcTangentPerVertex(pos2, pos0, pos1, uv2, uv0, uv1, norm0, _Mesh.__tmpReturnVec3_2);
        tangentAccessor.setVec4(i2, tan0Vec3.x, tan0Vec3.y, tan0Vec3.z, 1, {
          indicesAccessor
        });
        tangentAccessor.setVec4(i2 + 1, tan1Vec3.x, tan1Vec3.y, tan1Vec3.z, 1, {
          indicesAccessor
        });
        tangentAccessor.setVec4(i2 + 2, tan2Vec3.x, tan2Vec3.y, tan2Vec3.z, 1, {
          indicesAccessor
        });
      }
      __calcTangentPerVertex(pos0Vec3, pos1Vec3, pos2Vec3, uv0Vec2, uv1Vec2, uv2Vec2, norm0Vec3, returnVec3) {
        const cp0 = [
          _Mesh.__tmpVec3_0.setComponents(pos0Vec3.x, uv0Vec2.x, uv0Vec2.y),
          _Mesh.__tmpVec3_1.setComponents(pos0Vec3.y, uv0Vec2.x, uv0Vec2.y),
          _Mesh.__tmpVec3_2.setComponents(pos0Vec3.z, uv0Vec2.x, uv0Vec2.y)
        ];
        const cp1 = [
          _Mesh.__tmpVec3_3.setComponents(pos1Vec3.x, uv1Vec2.x, uv1Vec2.y),
          _Mesh.__tmpVec3_4.setComponents(pos1Vec3.y, uv1Vec2.x, uv1Vec2.y),
          _Mesh.__tmpVec3_5.setComponents(pos1Vec3.z, uv1Vec2.x, uv1Vec2.y)
        ];
        const cp2 = [
          _Mesh.__tmpVec3_6.setComponents(pos2Vec3.x, uv2Vec2.x, uv2Vec2.y),
          _Mesh.__tmpVec3_7.setComponents(pos2Vec3.y, uv2Vec2.x, uv2Vec2.y),
          _Mesh.__tmpVec3_8.setComponents(pos2Vec3.z, uv2Vec2.x, uv2Vec2.y)
        ];
        const u = [];
        const v = [];
        for (let i2 = 0; i2 < 3; i2++) {
          const v1 = MutableVector3.subtractTo(cp1[i2], cp0[i2], _Mesh.__tmpVec3_9);
          const v2 = MutableVector3.subtractTo(cp2[i2], cp1[i2], _Mesh.__tmpVec3_10);
          const abc = MutableVector3.crossTo(v1, v2, _Mesh.__tmpVec3_11);
          const validate = Math.abs(abc.x) < Number.EPSILON;
          if (validate) {
            Logger.assert(validate, "Polygons or polygons on UV are degenerate!");
            return Vector3.fromCopyArray([
              0,
              0,
              0
            ]);
          }
          u[i2] = -abc.y / abc.x;
          v[i2] = -abc.z / abc.x;
        }
        if (u[0] * u[0] + u[1] * u[1] + u[2] * u[2] < Number.EPSILON) {
          MutableVector3.crossTo(norm0Vec3, pos1Vec3, returnVec3);
          return returnVec3.normalize();
        }
        return returnVec3.setComponents(u[0], u[1], u[2]).normalize();
      }
      __usePreCalculatedTangent() {
        if (this.tangentCalculationMode === 0 || this.tangentCalculationMode === 1 || this.tangentCalculationMode === 3) {
          return false;
        } else {
          return true;
        }
      }
      /**
      * @internal
      */
      _calcBaryCentricCoord() {
        for (const primitive of this.__primitives) {
          const BaryCentricCoordId = primitive.attributeSemantics.indexOf(VertexAttribute.BaryCentricCoord.XYZ);
          if (BaryCentricCoordId !== -1) {
            return;
          }
          const buffer = MemoryManager.getInstance().createOrGetBuffer(BufferUse.CPUGeneric);
          const positionIdx = primitive.attributeSemantics.indexOf(VertexAttribute.Position.XYZ);
          const positionAccessor = primitive.attributeAccessors[positionIdx];
          const vertexNum = positionAccessor.elementCount;
          const num = vertexNum;
          const baryCentricCoordAttributeByteSize = num * 4 * 4;
          const baryCentricCoordBufferView = buffer.takeBufferView({
            byteLengthToNeed: baryCentricCoordAttributeByteSize,
            byteStride: 0
          }).unwrapForce();
          const baryCentricCoordAccessor = baryCentricCoordBufferView.takeAccessor({
            compositionType: CompositionType.Vec4,
            componentType: ComponentType.Float,
            count: num
          }).unwrapForce();
          for (let ver_i = 0; ver_i < num; ver_i++) {
            baryCentricCoordAccessor.setVec4(ver_i, ver_i % 3 === 0 ? 1 : 0, ver_i % 3 === 1 ? 1 : 0, ver_i % 3 === 2 ? 1 : 0, ver_i, {});
          }
          primitive.setVertexAttribute(baryCentricCoordAccessor, VertexAttribute.BaryCentricCoord.XYZ);
        }
      }
      /**
      * @internal
      */
      _calcFaceNormalsIfNonNormal() {
        for (const primitive of this.__primitives) {
          const normalIdx = primitive.attributeSemantics.indexOf(VertexAttribute.Normal.XYZ);
          if (normalIdx !== -1) {
            return;
          }
          this.__hasFaceNormal = true;
          const positionIdx = primitive.attributeSemantics.indexOf(VertexAttribute.Position.XYZ);
          const positionAccessor = primitive.attributeAccessors[positionIdx];
          const indicesAccessor = primitive.indicesAccessor;
          let incrementNum = 3;
          if (primitive.primitiveMode === PrimitiveMode.TriangleStrip || primitive.primitiveMode === PrimitiveMode.TriangleFan) {
            incrementNum = 1;
          }
          const vertexNum = primitive.getVertexCountAsIndicesBased();
          const buffer = MemoryManager.getInstance().createOrGetBuffer(BufferUse.CPUGeneric);
          const normalAttributeByteSize = positionAccessor.byteLength;
          const normalBufferView = buffer.takeBufferView({
            byteLengthToNeed: normalAttributeByteSize,
            byteStride: 0
          }).unwrapForce();
          const normalAccessor = normalBufferView.takeAccessor({
            compositionType: CompositionType.Vec3,
            componentType: ComponentType.Float,
            count: positionAccessor.elementCount
          }).unwrapForce();
          for (let i2 = 0; i2 < vertexNum - 2; i2 += incrementNum) {
            const pos0 = positionAccessor.getVec3(i2, {
              indicesAccessor
            });
            const pos1 = positionAccessor.getVec3(i2 + 1, {
              indicesAccessor
            });
            const pos2 = positionAccessor.getVec3(i2 + 2, {
              indicesAccessor
            });
            this.__calcFaceNormalFor3Vertices(i2, pos0, pos1, pos2, normalAccessor, indicesAccessor);
          }
          primitive.setVertexAttribute(normalAccessor, VertexAttribute.Normal.XYZ);
        }
      }
      __calcFaceNormalFor3Vertices(i2, pos0, pos1, pos2, normalAccessor, indicesAccessor) {
        const ax = pos1.x - pos0.x;
        const ay = pos1.y - pos0.y;
        const az = pos1.z - pos0.z;
        const bx = pos2.x - pos0.x;
        const by = pos2.y - pos0.y;
        const bz = pos2.z - pos0.z;
        let nx = ay * bz - az * by;
        let ny = az * bx - ax * bz;
        let nz = ax * by - ay * bx;
        let da = Math.hypot(nx, ny, nz);
        if (da <= 1e-6) {
          da = 1e-4;
        }
        da = 1 / da;
        nx *= da;
        ny *= da;
        nz *= da;
        normalAccessor.setVec3(i2, nx, ny, nz, {
          indicesAccessor
        });
        normalAccessor.setVec3(i2 + 1, nx, ny, nz, {
          indicesAccessor
        });
        normalAccessor.setVec3(i2 + 2, nx, ny, nz, {
          indicesAccessor
        });
      }
      getPrimitiveIndexInMesh(primitive) {
        return this.primitives.indexOf(primitive);
      }
      /**
      * Apply a material variant to the mesh
      * @param variantName a variant name
      */
      applyMaterialVariant(variantName) {
        for (const primitive of this.primitives) {
          primitive.applyMaterialVariant(variantName);
        }
      }
      getCurrentVariantName() {
        function allEqual(arr) {
          return arr.every((val) => val === arr[0]);
        }
        __name(allEqual, "allEqual");
        const variantNames = this.primitives.map((primitive) => primitive.getCurrentVariantName());
        if (variantNames.length === 0) {
          return "";
        }
        if (allEqual(variantNames)) {
          return variantNames[0];
        }
        return "";
      }
      getVariantNames() {
        const variants = [];
        for (const primitive of this.primitives) {
          Array.prototype.push.apply(variants, primitive.getVariantNames());
        }
        return variants;
      }
      isSetUpDone() {
        let vertexHandlesReady = true;
        for (const primitive of this.primitives) {
          if (primitive.vertexHandles == null) {
            vertexHandlesReady = false;
            break;
          }
        }
        if (!vertexHandlesReady) {
          return false;
        }
        if (this.__latestPrimitivePositionAccessorVersionForSetUpDone !== this.__primitivePositionUpdateCount) {
          this.__latestPrimitivePositionAccessorVersionForSetUpDone = this.__primitivePositionUpdateCount;
          return false;
        }
        return true;
      }
    };
    __name(_Mesh, "Mesh");
    __publicField(_Mesh, "invalidateMeshUID", -1);
    __publicField(_Mesh, "__mesh_uid_count", _Mesh.invalidateMeshUID);
    __publicField(_Mesh, "__tmpVec3_0", MutableVector3.zero());
    __publicField(_Mesh, "__tmpVec3_1", MutableVector3.zero());
    __publicField(_Mesh, "__tmpVec3_2", MutableVector3.zero());
    __publicField(_Mesh, "__tmpVec3_3", MutableVector3.zero());
    __publicField(_Mesh, "__tmpVec3_4", MutableVector3.zero());
    __publicField(_Mesh, "__tmpVec3_5", MutableVector3.zero());
    __publicField(_Mesh, "__tmpVec3_6", MutableVector3.zero());
    __publicField(_Mesh, "__tmpVec3_7", MutableVector3.zero());
    __publicField(_Mesh, "__tmpVec3_8", MutableVector3.zero());
    __publicField(_Mesh, "__tmpVec3_9", MutableVector3.zero());
    __publicField(_Mesh, "__tmpVec3_10", MutableVector3.zero());
    __publicField(_Mesh, "__tmpVec3_11", MutableVector3.zero());
    __publicField(_Mesh, "__tmpReturnVec3_0", MutableVector3.zero());
    __publicField(_Mesh, "__tmpReturnVec3_1", MutableVector3.zero());
    __publicField(_Mesh, "__tmpReturnVec3_2", MutableVector3.zero());
    Mesh = _Mesh;
  }
});

// src/foundation/components/Transform/createTransformEntity.ts
function createTransformEntity() {
  const entity = EntityRepository.createEntity();
  const entity1 = EntityRepository.tryToAddComponentToEntityByTID(WellKnownComponentTIDs.TransformComponentTID, entity);
  return entity1;
}
var init_createTransformEntity = __esm({
  "src/foundation/components/Transform/createTransformEntity.ts"() {
    "use strict";
    init_EntityRepository();
    init_WellKnownComponentTIDs();
    __name(createTransformEntity, "createTransformEntity");
  }
});

// src/foundation/components/SceneGraph/createGroupEntity.ts
function createGroupEntity() {
  const entity = createTransformEntity();
  const entityAddedComponent = EntityRepository.tryToAddComponentToEntityByTID(WellKnownComponentTIDs.SceneGraphComponentTID, entity);
  return entityAddedComponent;
}
var init_createGroupEntity = __esm({
  "src/foundation/components/SceneGraph/createGroupEntity.ts"() {
    "use strict";
    init_EntityRepository();
    init_createTransformEntity();
    init_WellKnownComponentTIDs();
    __name(createGroupEntity, "createGroupEntity");
  }
});

// src/foundation/components/MeshRenderer/createMeshEntity.ts
function createMeshEntity() {
  const entity = createGroupEntity();
  const entityAddedComponent = EntityRepository.tryToAddComponentToEntityByTID(WellKnownComponentTIDs.MeshComponentTID, entity);
  const entityAddedComponent2 = EntityRepository.tryToAddComponentToEntityByTID(WellKnownComponentTIDs.MeshRendererComponentTID, entityAddedComponent);
  return entityAddedComponent2;
}
var init_createMeshEntity = __esm({
  "src/foundation/components/MeshRenderer/createMeshEntity.ts"() {
    "use strict";
    init_EntityRepository();
    init_createGroupEntity();
    init_WellKnownComponentTIDs();
    __name(createMeshEntity, "createMeshEntity");
  }
});

// src/foundation/gizmos/AABBGizmo.ts
var _AABBGizmo, AABBGizmo;
var init_AABBGizmo = __esm({
  "src/foundation/gizmos/AABBGizmo.ts"() {
    "use strict";
    init_Gizmo();
    init_PrimitiveMode();
    init_VertexAttribute();
    init_Primitive();
    init_Vector3();
    init_Mesh();
    init_Is();
    init_createMeshEntity();
    _AABBGizmo = class _AABBGizmo extends Gizmo {
      /**
      * Constructor
      * @param target the object which this gizmo belong to
      */
      constructor(target) {
        super(target);
      }
      ///
      ///
      /// Accessors
      ///
      ///
      get isSetup() {
        if (this.__topEntity != null) {
          return true;
        } else {
          return false;
        }
      }
      ///
      ///
      /// Friends Members
      ///
      ///
      /**
      * @internal
      * setup entities of Gizmo if not done yet
      */
      _setup() {
        if (this.__toSkipSetup()) {
          return;
        }
        this.__topEntity = createMeshEntity();
        this.__topEntity.tryToSetUniqueName(`AABBGizmo_of_${this.__target.uniqueName}`, true);
        this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix = true;
        this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph());
        const meshComponent = this.__topEntity.tryToGetMesh();
        _AABBGizmo.__mesh = new Mesh();
        _AABBGizmo.__mesh.addPrimitive(_AABBGizmo.generatePrimitive());
        meshComponent.setMesh(_AABBGizmo.__mesh);
        this.setGizmoTag();
        this._update();
      }
      /**
      * generate the primitive of the gizmo
      * @returns a primitive of the gizmo
      */
      static generatePrimitive() {
        const indices = new Uint32Array([
          // XY Plane on -Z
          0,
          1,
          1,
          2,
          2,
          3,
          3,
          0,
          // XY Plane on +Z
          4,
          5,
          5,
          6,
          6,
          7,
          7,
          4,
          // YZ Plane on -X
          0,
          3,
          3,
          7,
          7,
          4,
          4,
          0,
          // YZ Plane on +X
          1,
          2,
          2,
          6,
          6,
          5,
          5,
          1,
          // XZ Plane on -Y
          0,
          1,
          1,
          5,
          5,
          4,
          4,
          0,
          // XZ Plane on +Y
          3,
          2,
          2,
          6,
          6,
          7,
          7,
          3
        ]);
        const length = 1;
        const positions = new Float32Array([
          /// -Z
          // 0
          -length,
          -length,
          -length,
          // 1
          length,
          -length,
          -length,
          // 2
          length,
          length,
          -length,
          // 3
          -length,
          length,
          -length,
          /// +Z
          // 4
          -length,
          -length,
          length,
          // 5
          length,
          -length,
          length,
          // 6
          length,
          length,
          length,
          // 7
          -length,
          length,
          length
        ]);
        const primitive = Primitive.createPrimitive({
          indices,
          attributeSemantics: [
            VertexAttribute.Position.XYZ
          ],
          attributes: [
            positions
          ],
          primitiveMode: PrimitiveMode.Lines
        });
        return primitive;
      }
      /**
      * @internal
      * update the transform and etc of the gizmo
      */
      _update() {
        if (this.__topEntity == null) {
          return;
        }
        const sg = this.__target.getSceneGraph();
        const aabb = sg.worldMergedAABBWithSkeletal;
        this.__topEntity.getTransform().localPosition = aabb.centerPoint;
        this.__topEntity.getTransform().localScale = Vector3.fromCopyArray([
          aabb.sizeX / 2,
          aabb.sizeY / 2,
          aabb.sizeZ / 2
        ]);
      }
      _destroy() {
        if (Is.exist(this.__topEntity)) {
          this.__topEntity._destroy();
        }
      }
    };
    __name(_AABBGizmo, "AABBGizmo");
    __publicField(_AABBGizmo, "__mesh");
    AABBGizmo = _AABBGizmo;
  }
});

// src/foundation/gizmos/LocatorGizmo.ts
var _LocatorGizmo, LocatorGizmo;
var init_LocatorGizmo = __esm({
  "src/foundation/gizmos/LocatorGizmo.ts"() {
    "use strict";
    init_createMeshEntity();
    init_PrimitiveMode();
    init_VertexAttribute();
    init_Mesh();
    init_Primitive();
    init_Vector3();
    init_Is();
    init_Gizmo();
    _LocatorGizmo = class _LocatorGizmo extends Gizmo {
      /**
      * Constructor
      * @param target the object which this gizmo belong to
      */
      constructor(target) {
        super(target);
      }
      ///
      ///
      /// Accessors
      ///
      ///
      get isSetup() {
        if (this.__topEntity != null) {
          return true;
        } else {
          return false;
        }
      }
      set length(val) {
        _LocatorGizmo.__length = val;
      }
      get length() {
        return _LocatorGizmo.__length;
      }
      ///
      ///
      /// Friends Members
      ///
      ///
      /**
      * @internal
      * setup entities of Gizmo if not done yet
      */
      _setup() {
        if (this.__toSkipSetup()) {
          return;
        }
        this.__topEntity = createMeshEntity();
        this.__topEntity.tryToSetUniqueName(`LocatorGizmo_of_${this.__target.uniqueName}`, true);
        this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix = true;
        this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph());
        const sceneGraphComponent = this.__topEntity.tryToGetMesh();
        _LocatorGizmo.__mesh = new Mesh();
        _LocatorGizmo.__mesh.addPrimitive(_LocatorGizmo.__generatePrimitive());
        sceneGraphComponent.setMesh(_LocatorGizmo.__mesh);
        this.setGizmoTag();
      }
      /**
      * @internal
      * update the transform and etc of the gizmo
      */
      _update() {
        if (this.__topEntity == null) {
          return;
        }
        const sg = this.__target.getSceneGraph();
        const aabb = sg.worldMergedAABBWithSkeletal;
        if (aabb.isVanilla()) {
          this.__topEntity.getTransform().localPosition = sg.position;
        } else {
          this.__topEntity.getTransform().localPosition = aabb.centerPoint;
        }
        this.__topEntity.getTransform().localScale = Vector3.fromCopyArray([
          Math.max(1, aabb.isVanilla() ? 1 : aabb.sizeX / 2),
          Math.max(1, aabb.isVanilla() ? 1 : aabb.sizeY / 2),
          Math.max(1, aabb.isVanilla() ? 1 : aabb.sizeZ / 2)
        ]);
      }
      ///
      ///
      /// Private Static Members
      ///
      ///
      static __generatePrimitive() {
        const positions = new Float32Array([
          // X axis
          0,
          0,
          0,
          this.__length,
          0,
          0,
          // Y axis
          0,
          0,
          0,
          0,
          this.__length,
          0,
          // Z axis
          0,
          0,
          0,
          0,
          0,
          this.__length
        ]);
        const color = new Float32Array([
          // X axis as Red
          1,
          0,
          0,
          1,
          0,
          0,
          // Y axis as Green
          0,
          1,
          0,
          0,
          1,
          0,
          // Z axis as Blue
          0,
          0,
          1,
          0,
          0,
          1
        ]);
        const primitive = Primitive.createPrimitive({
          attributeSemantics: [
            VertexAttribute.Position.XYZ,
            VertexAttribute.Color0.XYZ
          ],
          attributes: [
            positions,
            color
          ],
          primitiveMode: PrimitiveMode.Lines
        });
        return primitive;
      }
      _destroy() {
        if (Is.exist(this.__topEntity)) {
          this.__topEntity._destroy();
        }
      }
    };
    __name(_LocatorGizmo, "LocatorGizmo");
    __publicField(_LocatorGizmo, "__mesh");
    __publicField(_LocatorGizmo, "__length", 1);
    LocatorGizmo = _LocatorGizmo;
  }
});

// src/foundation/geometry/shapes/IShape.ts
var _IShape, IShape;
var init_IShape = __esm({
  "src/foundation/geometry/shapes/IShape.ts"() {
    "use strict";
    init_Primitive();
    _IShape = class _IShape extends Primitive {
    };
    __name(_IShape, "IShape");
    IShape = _IShape;
  }
});

// src/foundation/geometry/shapes/Cube.ts
var _Cube, Cube;
var init_Cube = __esm({
  "src/foundation/geometry/shapes/Cube.ts"() {
    "use strict";
    init_PrimitiveMode();
    init_VertexAttribute();
    init_Vector3();
    init_Is();
    init_IShape();
    _Cube = class _Cube extends IShape {
      /**
      * Generates a cube object
      * @param _desc a descriptor object of a Cube
      */
      generate(_desc) {
        var _a40;
        const desc = {
          widthVector: (_a40 = _desc.widthVector) != null ? _a40 : Vector3.fromCopy3(1, 1, 1),
          color: _desc.color,
          material: _desc.material
        };
        const indices = [
          3,
          1,
          0,
          2,
          1,
          3,
          4,
          5,
          7,
          7,
          5,
          6,
          8,
          9,
          11,
          11,
          9,
          10,
          15,
          13,
          12,
          14,
          13,
          15,
          19,
          17,
          16,
          18,
          17,
          19,
          20,
          21,
          23,
          23,
          21,
          22
        ];
        const positions = [
          // upper
          -desc.widthVector.x / 2,
          desc.widthVector.y / 2,
          -desc.widthVector.z / 2,
          desc.widthVector.x / 2,
          desc.widthVector.y / 2,
          -desc.widthVector.z / 2,
          desc.widthVector.x / 2,
          desc.widthVector.y / 2,
          desc.widthVector.z / 2,
          -desc.widthVector.x / 2,
          desc.widthVector.y / 2,
          desc.widthVector.z / 2,
          // lower
          -desc.widthVector.x / 2,
          -desc.widthVector.y / 2,
          -desc.widthVector.z / 2,
          desc.widthVector.x / 2,
          -desc.widthVector.y / 2,
          -desc.widthVector.z / 2,
          desc.widthVector.x / 2,
          -desc.widthVector.y / 2,
          desc.widthVector.z / 2,
          -desc.widthVector.x / 2,
          -desc.widthVector.y / 2,
          desc.widthVector.z / 2,
          // front
          -desc.widthVector.x / 2,
          -desc.widthVector.y / 2,
          desc.widthVector.z / 2,
          desc.widthVector.x / 2,
          -desc.widthVector.y / 2,
          desc.widthVector.z / 2,
          desc.widthVector.x / 2,
          desc.widthVector.y / 2,
          desc.widthVector.z / 2,
          -desc.widthVector.x / 2,
          desc.widthVector.y / 2,
          desc.widthVector.z / 2,
          // back
          -desc.widthVector.x / 2,
          -desc.widthVector.y / 2,
          -desc.widthVector.z / 2,
          desc.widthVector.x / 2,
          -desc.widthVector.y / 2,
          -desc.widthVector.z / 2,
          desc.widthVector.x / 2,
          desc.widthVector.y / 2,
          -desc.widthVector.z / 2,
          -desc.widthVector.x / 2,
          desc.widthVector.y / 2,
          -desc.widthVector.z / 2,
          // right
          desc.widthVector.x / 2,
          -desc.widthVector.y / 2,
          -desc.widthVector.z / 2,
          desc.widthVector.x / 2,
          -desc.widthVector.y / 2,
          desc.widthVector.z / 2,
          desc.widthVector.x / 2,
          desc.widthVector.y / 2,
          desc.widthVector.z / 2,
          desc.widthVector.x / 2,
          desc.widthVector.y / 2,
          -desc.widthVector.z / 2,
          // left
          -desc.widthVector.x / 2,
          -desc.widthVector.y / 2,
          -desc.widthVector.z / 2,
          -desc.widthVector.x / 2,
          -desc.widthVector.y / 2,
          desc.widthVector.z / 2,
          -desc.widthVector.x / 2,
          desc.widthVector.y / 2,
          desc.widthVector.z / 2,
          -desc.widthVector.x / 2,
          desc.widthVector.y / 2,
          -desc.widthVector.z / 2
        ];
        const colors = Is.not.exist(desc.color) ? [] : [
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a,
          desc.color.r,
          desc.color.g,
          desc.color.b,
          desc.color.a
        ];
        const texcoords = [
          // upper
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1,
          // lower
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1,
          // front
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1,
          // back
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1,
          // right
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1,
          // left
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ];
        const normals = [
          // upper
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          // lower
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          // front
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          // back
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          // right
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          // left
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0
        ];
        const attributeSemantics = [
          VertexAttribute.Position.XYZ,
          VertexAttribute.Normal.XYZ,
          VertexAttribute.Texcoord0.XY
        ];
        const attributes = [
          new Float32Array(positions),
          new Float32Array(normals),
          new Float32Array(texcoords)
        ];
        if (Is.exist(desc.color)) {
          attributeSemantics.push(VertexAttribute.Color0.XYZ);
          attributes.push(new Float32Array(colors));
        }
        const primitiveMode = PrimitiveMode.Triangles;
        this.copyVertexData({
          attributes,
          attributeSemantics,
          primitiveMode,
          indices: new Uint16Array(indices),
          material: desc.material
        });
      }
    };
    __name(_Cube, "Cube");
    Cube = _Cube;
  }
});

// src/foundation/geometry/shapes/Plane.ts
var _Plane, Plane;
var init_Plane = __esm({
  "src/foundation/geometry/shapes/Plane.ts"() {
    "use strict";
    init_VertexAttribute();
    init_PrimitiveMode();
    init_IShape();
    _Plane = class _Plane extends IShape {
      /**
      * Generates a plane object
      * @param _desc a descriptor object of a Plane
      */
      generate(_desc) {
        var _a40, _b, _c, _d, _e, _f;
        const desc = {
          width: (_a40 = _desc.width) != null ? _a40 : 1,
          height: (_b = _desc.height) != null ? _b : 1,
          uSpan: (_c = _desc.uSpan) != null ? _c : 1,
          vSpan: (_d = _desc.vSpan) != null ? _d : 1,
          isUVRepeat: (_e = _desc.isUVRepeat) != null ? _e : false,
          flipTextureCoordinateY: (_f = _desc.flipTextureCoordinateY) != null ? _f : false,
          material: _desc.material
        };
        const positions = [];
        for (let i2 = 0; i2 <= desc.vSpan; i2++) {
          for (let j = 0; j <= desc.uSpan; j++) {
            positions.push((j / desc.uSpan - 1 / 2) * desc.width);
            positions.push(0);
            positions.push((i2 / desc.vSpan - 1 / 2) * desc.height);
          }
        }
        const indices = [];
        for (let i2 = 0; i2 < desc.vSpan; i2++) {
          let degenerate_left_index = 0;
          let degenerate_right_index = 0;
          for (let j = 0; j <= desc.uSpan; j++) {
            indices.push(i2 * (desc.uSpan + 1) + j);
            indices.push((i2 + 1) * (desc.uSpan + 1) + j);
            if (j === 0) {
              degenerate_left_index = (i2 + 1) * (desc.uSpan + 1) + j;
            } else if (j === desc.uSpan) {
              degenerate_right_index = (i2 + 1) * (desc.uSpan + 1) + j;
            }
          }
          indices.push(degenerate_right_index);
          indices.push(degenerate_left_index);
        }
        const normals = [];
        for (let i2 = 0; i2 <= desc.vSpan; i2++) {
          for (let j = 0; j <= desc.uSpan; j++) {
            normals.push(0);
            normals.push(1);
            normals.push(0);
          }
        }
        const texcoords = [];
        for (let i2 = 0; i2 <= desc.vSpan; i2++) {
          const i_ = desc.flipTextureCoordinateY ? i2 : desc.vSpan - i2;
          for (let j = 0; j <= desc.uSpan; j++) {
            if (desc.isUVRepeat) {
              texcoords.push(j);
              texcoords.push(i_);
            } else {
              texcoords.push(j / desc.uSpan);
              texcoords.push(i_ / desc.vSpan);
            }
          }
        }
        const attributeSemantics = [
          VertexAttribute.Position.XYZ,
          VertexAttribute.Normal.XYZ,
          VertexAttribute.Texcoord0.XY
        ];
        const primitiveMode = PrimitiveMode.TriangleStrip;
        const attributes = [
          new Float32Array(positions),
          new Float32Array(normals),
          new Float32Array(texcoords)
        ];
        this.copyVertexData({
          attributes,
          attributeSemantics,
          primitiveMode,
          indices: new Uint16Array(indices),
          material: desc == null ? void 0 : desc.material
        });
      }
    };
    __name(_Plane, "Plane");
    Plane = _Plane;
  }
});

// src/foundation/gizmos/TranslationGizmo.ts
var _TranslationGizmo, TranslationGizmo;
var init_TranslationGizmo = __esm({
  "src/foundation/gizmos/TranslationGizmo.ts"() {
    "use strict";
    init_CameraComponent();
    init_ComponentRepository();
    init_Config();
    init_AlphaMode();
    init_PrimitiveMode();
    init_VertexAttribute();
    init_Mesh();
    init_Primitive();
    init_Cube();
    init_Plane();
    init_MaterialHelper();
    init_Matrix44();
    init_MathUtil();
    init_Matrix33();
    init_MutableMatrix33();
    init_Quaternion();
    init_Vector3();
    init_Vector4();
    init_Is();
    init_MiscUtil();
    init_InputManager();
    init_Gizmo();
    init_createGroupEntity();
    init_createMeshEntity();
    init_Logger();
    _TranslationGizmo = class _TranslationGizmo extends Gizmo {
      /**
      * Constructor
      * @param target the object which this gizmo belong to
      */
      constructor(target) {
        super(target);
        __publicField(this, "__pickStatedPoint", Vector3.zero());
        __publicField(this, "__deltaPoint", Vector3.zero());
        __publicField(this, "__targetPointBackup", Vector3.zero());
        __publicField(this, "__isPointerDown", false);
        __publicField(this, "__latestTargetEntity");
        __publicField(this, "__onPointerDownFunc", this.__onPointerDown.bind(this));
        __publicField(this, "__onPointerMoveFunc", this.__onPointerMove.bind(this));
        __publicField(this, "__onPointerUpFunc", this.__onPointerUp.bind(this));
      }
      ///
      ///
      /// Accessors
      ///
      ///
      get isSetup() {
        if (this.__topEntity != null) {
          return true;
        } else {
          return false;
        }
      }
      set length(val) {
        _TranslationGizmo.__length = val;
      }
      get length() {
        return _TranslationGizmo.__length;
      }
      set isVisible(flg) {
        if (this.__isVisible === false && flg === true) {
          let eventTargetDom2 = window;
          if (Is.exist(Config.eventTargetDom)) {
            eventTargetDom2 = Config.eventTargetDom;
          }
          InputManager.register(INPUT_HANDLING_STATE_GIZMO_TRANSLATION, [
            {
              eventName: getEvent("start"),
              handler: this.__onPointerDownFunc,
              options: {},
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: getEvent("move"),
              handler: this.__onPointerMoveFunc,
              options: {},
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: getEvent("end"),
              handler: this.__onPointerUpFunc,
              options: {},
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "pointerleave",
              handler: this.__onPointerUpFunc,
              options: {},
              classInstance: this,
              eventTargetDom: eventTargetDom2
            }
          ]);
          this.__topEntity.getSceneGraph().addChild(_TranslationGizmo.__groupEntity.getSceneGraph());
          this.__latestTargetEntity = this.__target;
          if (_TranslationGizmo.__space === "local") {
            const parent = this.__target.getSceneGraph().parent;
            let quaternion = Quaternion.identity();
            if (Is.exist(parent)) {
              quaternion = parent.getQuaternionRecursively();
            }
            _TranslationGizmo.__groupEntity.getTransform().localRotation = quaternion;
          } else if (_TranslationGizmo.__space === "world") {
            _TranslationGizmo.__groupEntity.getTransform().localRotation = Quaternion.fromCopy4(0, 0, 0, 1);
          }
        }
        if (this.__isVisible === true && flg === false) {
          InputManager.unregister(INPUT_HANDLING_STATE_GIZMO_TRANSLATION);
          this.__deltaPoint = this.__target.getTransform().localPosition;
          this.__pickStatedPoint = Vector3.zero();
          this.__isPointerDown = false;
          this.__targetPointBackup = this.__target.getTransform().localPosition;
          _TranslationGizmo.__activeAxis = "none";
        }
        InputManager.setActive(INPUT_HANDLING_STATE_GIZMO_TRANSLATION, flg);
        this.__setVisible(flg);
        _TranslationGizmo.__xyPlaneEntity.getSceneGraph().isVisible = false;
        _TranslationGizmo.__yzPlaneEntity.getSceneGraph().isVisible = false;
        _TranslationGizmo.__zxPlaneEntity.getSceneGraph().isVisible = false;
      }
      setSpace(space) {
        _TranslationGizmo.__space = space;
        if (this.__isVisible) {
          this.isVisible = false;
          this.isVisible = true;
        }
      }
      get isVisible() {
        return this.__isVisible;
      }
      ///
      ///
      /// Friends Members
      ///
      ///
      /**
      * @internal
      * setup entities of Gizmo if not done yet
      */
      _setup() {
        if (this.__toSkipSetup()) {
          return;
        }
        this.__topEntity = createGroupEntity();
        this.__topEntity.tryToSetUniqueName(`TranslationGizmo_of_${this.__target.uniqueName}`, true);
        this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix = true;
        this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph());
        if (Is.not.exist(_TranslationGizmo.__xCubeEntity)) {
          _TranslationGizmo.__xCubeEntity = createMeshEntity();
          _TranslationGizmo.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_xCube", true);
          _TranslationGizmo.__xCubeEntity.getTransform().localPosition = Vector3.fromCopy3(1, 0, 0);
          _TranslationGizmo.__xCubeMesh = new Mesh();
          _TranslationGizmo.__xCubeMaterial = MaterialHelper.createClassicUberMaterial();
          _TranslationGizmo.__xCubeMaterial.setParameter("diffuseColorFactor", Vector4.fromCopyArray4([
            1,
            0,
            0,
            1
          ]));
          _TranslationGizmo.__xCubePrimitive = new Cube();
          _TranslationGizmo.__xCubePrimitive.generate({
            widthVector: Vector3.fromCopy3(1, 0.05, 0.05),
            material: _TranslationGizmo.__xCubeMaterial
          });
          _TranslationGizmo.__xCubeMesh.addPrimitive(_TranslationGizmo.__xCubePrimitive);
          _TranslationGizmo.__xCubeEntity.getMesh().setMesh(_TranslationGizmo.__xCubeMesh);
        }
        if (Is.not.exist(_TranslationGizmo.__yCubeEntity)) {
          _TranslationGizmo.__yCubeEntity = createMeshEntity();
          _TranslationGizmo.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_yCube", true);
          _TranslationGizmo.__yCubeEntity.getTransform().localPosition = Vector3.fromCopy3(0, 1, 0);
          _TranslationGizmo.__yCubeMesh = new Mesh();
          _TranslationGizmo.__yCubeMaterial = MaterialHelper.createClassicUberMaterial();
          _TranslationGizmo.__yCubeMaterial.setParameter("diffuseColorFactor", Vector4.fromCopyArray4([
            0,
            1,
            0,
            1
          ]));
          _TranslationGizmo.__yCubePrimitive = new Cube();
          _TranslationGizmo.__yCubePrimitive.generate({
            widthVector: Vector3.fromCopy3(0.05, 1, 0.05),
            material: _TranslationGizmo.__yCubeMaterial
          });
          _TranslationGizmo.__yCubeMesh.addPrimitive(_TranslationGizmo.__yCubePrimitive);
          _TranslationGizmo.__yCubeEntity.getMesh().setMesh(_TranslationGizmo.__yCubeMesh);
        }
        if (Is.not.exist(_TranslationGizmo.__zCubeEntity)) {
          _TranslationGizmo.__zCubeEntity = createMeshEntity();
          _TranslationGizmo.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_zCube", true);
          _TranslationGizmo.__zCubeEntity.getTransform().localPosition = Vector3.fromCopy3(0, 0, 1);
          _TranslationGizmo.__zCubeMesh = new Mesh();
          _TranslationGizmo.__zCubeMaterial = MaterialHelper.createClassicUberMaterial();
          _TranslationGizmo.__zCubeMaterial.setParameter("diffuseColorFactor", Vector4.fromCopyArray4([
            0,
            0,
            1,
            1
          ]));
          _TranslationGizmo.__zCubePrimitive = new Cube();
          _TranslationGizmo.__zCubePrimitive.generate({
            widthVector: Vector3.fromCopy3(0.05, 0.05, 1),
            material: _TranslationGizmo.__zCubeMaterial
          });
          _TranslationGizmo.__zCubeMesh.addPrimitive(_TranslationGizmo.__zCubePrimitive);
          _TranslationGizmo.__zCubeEntity.getMesh().setMesh(_TranslationGizmo.__zCubeMesh);
        }
        if (Is.not.exist(_TranslationGizmo.__xyPlaneEntity)) {
          _TranslationGizmo.__xyPlaneEntity = createMeshEntity();
          _TranslationGizmo.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_xyPlane", true);
          _TranslationGizmo.__xyPlaneEntity.getSceneGraph().isVisible = false;
          _TranslationGizmo.__xyPlaneEntity.getTransform().localEulerAngles = Vector3.fromCopy3(MathUtil.degreeToRadian(90), 0, 0);
          _TranslationGizmo.__xyPlaneMaterial = MaterialHelper.createClassicUberMaterial();
          _TranslationGizmo.__xyPlaneMaterial.alphaMode = AlphaMode.Blend;
          _TranslationGizmo.__xyPlaneMaterial.setParameter("diffuseColorFactor", Vector4.fromCopyArray4([
            0,
            0,
            0.5,
            0
          ]));
          _TranslationGizmo.__xyPlaneMesh = new Mesh();
          _TranslationGizmo.__xyPlanePrimitive = new Plane();
          _TranslationGizmo.__xyPlanePrimitive.generate({
            width: 1e5,
            height: 1e5,
            uSpan: 1,
            vSpan: 1,
            isUVRepeat: true,
            flipTextureCoordinateY: false,
            material: _TranslationGizmo.__xyPlaneMaterial
          });
          _TranslationGizmo.__xyPlaneMesh.addPrimitive(_TranslationGizmo.__xyPlanePrimitive);
          _TranslationGizmo.__xyPlaneEntity.getMesh().setMesh(_TranslationGizmo.__xyPlaneMesh);
        }
        if (Is.not.exist(_TranslationGizmo.__yzPlaneEntity)) {
          _TranslationGizmo.__yzPlaneEntity = createMeshEntity();
          _TranslationGizmo.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_yzPlane", true);
          _TranslationGizmo.__yzPlaneEntity.getSceneGraph().isVisible = false;
          _TranslationGizmo.__yzPlaneEntity.getTransform().localEulerAngles = Vector3.fromCopy3(0, 0, MathUtil.degreeToRadian(90));
          _TranslationGizmo.__yzPlaneMaterial = MaterialHelper.createClassicUberMaterial();
          _TranslationGizmo.__yzPlaneMaterial.alphaMode = AlphaMode.Blend;
          _TranslationGizmo.__yzPlaneMaterial.setParameter("diffuseColorFactor", Vector4.fromCopyArray4([
            0.5,
            0,
            0,
            0
          ]));
          _TranslationGizmo.__yzPlaneMesh = new Mesh();
          _TranslationGizmo.__yzPlanePrimitive = new Plane();
          _TranslationGizmo.__yzPlanePrimitive.generate({
            width: 1e5,
            height: 1e5,
            uSpan: 1,
            vSpan: 1,
            isUVRepeat: true,
            flipTextureCoordinateY: false,
            material: _TranslationGizmo.__yzPlaneMaterial
          });
          _TranslationGizmo.__yzPlaneMesh.addPrimitive(_TranslationGizmo.__yzPlanePrimitive);
          _TranslationGizmo.__yzPlaneEntity.getMesh().setMesh(_TranslationGizmo.__yzPlaneMesh);
        }
        if (Is.not.exist(_TranslationGizmo.__zxPlaneEntity)) {
          _TranslationGizmo.__zxPlaneEntity = createMeshEntity();
          _TranslationGizmo.__xCubeEntity.tryToSetUniqueName("TranslationGizmo_zxPlane", true);
          _TranslationGizmo.__zxPlaneEntity.getSceneGraph().isVisible = false;
          _TranslationGizmo.__zxPlaneMaterial = MaterialHelper.createClassicUberMaterial();
          _TranslationGizmo.__zxPlaneMaterial.setParameter("diffuseColorFactor", Vector4.fromCopyArray4([
            0,
            0.5,
            0,
            0
          ]));
          _TranslationGizmo.__zxPlaneMaterial.alphaMode = AlphaMode.Blend;
          _TranslationGizmo.__zxPlaneMesh = new Mesh();
          _TranslationGizmo.__zxPlanePrimitive = new Plane();
          _TranslationGizmo.__zxPlanePrimitive.generate({
            width: 1e5,
            height: 1e5,
            uSpan: 1,
            vSpan: 1,
            isUVRepeat: true,
            flipTextureCoordinateY: false,
            material: _TranslationGizmo.__zxPlaneMaterial
          });
          _TranslationGizmo.__zxPlaneMesh.addPrimitive(_TranslationGizmo.__zxPlanePrimitive);
          _TranslationGizmo.__zxPlaneEntity.getMesh().setMesh(_TranslationGizmo.__zxPlaneMesh);
        }
        if (Is.not.exist(_TranslationGizmo.__groupEntity)) {
          _TranslationGizmo.__groupEntity = createGroupEntity();
        }
        this.__topEntity.getSceneGraph().addChild(_TranslationGizmo.__groupEntity.getSceneGraph());
        _TranslationGizmo.__groupEntity.getSceneGraph().addChild(_TranslationGizmo.__xCubeEntity.getSceneGraph());
        _TranslationGizmo.__groupEntity.getSceneGraph().addChild(_TranslationGizmo.__yCubeEntity.getSceneGraph());
        _TranslationGizmo.__groupEntity.getSceneGraph().addChild(_TranslationGizmo.__zCubeEntity.getSceneGraph());
        _TranslationGizmo.__groupEntity.getSceneGraph().addChild(_TranslationGizmo.__xyPlaneEntity.getSceneGraph());
        _TranslationGizmo.__groupEntity.getSceneGraph().addChild(_TranslationGizmo.__yzPlaneEntity.getSceneGraph());
        _TranslationGizmo.__groupEntity.getSceneGraph().addChild(_TranslationGizmo.__zxPlaneEntity.getSceneGraph());
        this.__latestTargetEntity = this.__target;
        this.setGizmoTag();
      }
      /**
      * @internal
      * update the transform and etc of the gizmo
      */
      _update() {
        if (this.__topEntity == null) {
          return;
        }
        const sg = this.__target.getSceneGraph();
        const aabb = sg.worldMergedAABBWithSkeletal;
        if (aabb.isVanilla()) {
          this.__topEntity.getTransform().localPosition = sg.position;
        } else {
          this.__topEntity.getTransform().localPosition = aabb.centerPoint;
        }
        const max = Math.max(aabb.sizeX, aabb.sizeY, aabb.sizeZ);
        this.__topEntity.getTransform().localScale = Vector3.fromCopyArray([
          Math.min(1, aabb.isVanilla() ? 1 : max / 2),
          Math.min(1, aabb.isVanilla() ? 1 : max / 2),
          Math.min(1, aabb.isVanilla() ? 1 : max / 2)
        ]);
        if (this.__isPointerDown) {
          if (this.__latestTargetEntity === this.__target) {
            this.__target.getTransform().localPosition = this.__deltaPoint.clone();
          }
        }
      }
      ///
      ///
      /// Private Static Members
      ///
      ///
      static __generatePrimitive() {
        const positions = new Float32Array([
          // X axis
          0,
          0,
          0,
          this.__length,
          0,
          0,
          // Y axis
          0,
          0,
          0,
          0,
          this.__length,
          0,
          // Z axis
          0,
          0,
          0,
          0,
          0,
          this.__length
        ]);
        const color = new Float32Array([
          // X axis as Red
          1,
          0,
          0,
          1,
          0,
          0,
          // Y axis as Green
          0,
          1,
          0,
          0,
          1,
          0,
          // Z axis as Blue
          0,
          0,
          1,
          0,
          0,
          1
        ]);
        const primitive = Primitive.createPrimitive({
          attributeSemantics: [
            VertexAttribute.Position.XYZ,
            VertexAttribute.Color0.XYZ
          ],
          attributes: [
            positions,
            color
          ],
          primitiveMode: PrimitiveMode.Lines
        });
        return primitive;
      }
      __onPointerDown(evt) {
        evt.preventDefault();
        this.__isPointerDown = true;
        _TranslationGizmo.__originalX = evt.clientX;
        _TranslationGizmo.__originalY = evt.clientY;
        const parent = this.__target.getSceneGraph().parent;
        let worldMatrix = Matrix44.identity();
        if (Is.exist(parent)) {
          worldMatrix = parent.matrixInner.getRotate();
        }
        const scaleVec = Vector3.one();
        let rotMat = Matrix33.fromCopy9RowMajor(scaleVec.x * worldMatrix.m00, scaleVec.x * worldMatrix.m01, scaleVec.x * worldMatrix.m02, scaleVec.y * worldMatrix.m10, scaleVec.y * worldMatrix.m11, scaleVec.y * worldMatrix.m12, scaleVec.z * worldMatrix.m20, scaleVec.z * worldMatrix.m21, scaleVec.z * worldMatrix.m22);
        if (_TranslationGizmo.__space === "local") {
          rotMat = Matrix33.transpose(rotMat);
        } else if (_TranslationGizmo.__space === "world") {
          rotMat = MutableMatrix33.identity();
        }
        const { xResult, yResult, zResult } = _TranslationGizmo.castRay(evt);
        if (xResult.result) {
          assertExist(xResult.data);
          this.__pickStatedPoint = rotMat.multiplyVector(xResult.data.position.clone());
          Logger.debug("Down:" + this.__pickStatedPoint.toStringApproximately());
          _TranslationGizmo.__activeAxis = "x";
        }
        if (yResult.result) {
          assertExist(yResult.data);
          this.__pickStatedPoint = rotMat.multiplyVector(yResult.data.position.clone());
          Logger.debug("Down:" + this.__pickStatedPoint.toStringApproximately());
          _TranslationGizmo.__activeAxis = "y";
        }
        if (zResult.result) {
          assertExist(zResult.data);
          this.__pickStatedPoint = rotMat.multiplyVector(zResult.data.position.clone());
          Logger.debug("Down:" + this.__pickStatedPoint.toStringApproximately());
          _TranslationGizmo.__activeAxis = "z";
        }
        if (this.__latestTargetEntity === this.__target) {
          this.__targetPointBackup = this.__target.getTransform().localPosition;
        }
      }
      __onPointerMove(evt) {
        evt.preventDefault();
        if (Is.false(this.__isPointerDown)) {
          return;
        }
        const rect = evt.target.getBoundingClientRect();
        const width = evt.target.clientWidth;
        const height = evt.target.clientHeight;
        const x = evt.clientX - rect.left;
        const y = rect.height - (evt.clientY - rect.top);
        const viewport = Vector4.fromCopy4(0, 0, width, height);
        const activeCamera = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
        const parent = this.__target.getSceneGraph().parent;
        let worldMatrix = Matrix44.identity();
        if (Is.exist(parent)) {
          worldMatrix = parent.matrixInner.getRotate();
        }
        const scaleVec = Vector3.one();
        let rotMat = Matrix33.fromCopy9RowMajor(scaleVec.x * worldMatrix.m00, scaleVec.x * worldMatrix.m01, scaleVec.x * worldMatrix.m02, scaleVec.y * worldMatrix.m10, scaleVec.y * worldMatrix.m11, scaleVec.y * worldMatrix.m12, scaleVec.z * worldMatrix.m20, scaleVec.z * worldMatrix.m21, scaleVec.z * worldMatrix.m22);
        if (_TranslationGizmo.__space === "local") {
          rotMat = Matrix33.transpose(rotMat);
        } else if (_TranslationGizmo.__space === "world") {
          rotMat = MutableMatrix33.identity();
        }
        let pickInMovingPoint = this.__pickStatedPoint.clone();
        if (_TranslationGizmo.__activeAxis === "x") {
          const xResult = _TranslationGizmo.__xyPlaneEntity.getMesh().castRayFromScreenInWorld(x, y, activeCamera, viewport, 0);
          if (xResult.result) {
            assertExist(xResult.data);
            const position = rotMat.multiplyVector(xResult.data.position);
            pickInMovingPoint = Vector3.fromCopy3(position.x, pickInMovingPoint.y, pickInMovingPoint.z);
          }
          InputManager.disableCameraController();
        }
        if (_TranslationGizmo.__activeAxis === "y") {
          const yResult = _TranslationGizmo.__xyPlaneEntity.getMesh().castRayFromScreenInWorld(x, y, activeCamera, viewport, 0);
          if (yResult.result) {
            assertExist(yResult.data);
            const position = rotMat.multiplyVector(yResult.data.position);
            pickInMovingPoint = Vector3.fromCopy3(pickInMovingPoint.x, position.y, pickInMovingPoint.z);
          }
          InputManager.disableCameraController();
        }
        if (_TranslationGizmo.__activeAxis === "z") {
          const zResult = _TranslationGizmo.__yzPlaneEntity.getMesh().castRayFromScreenInWorld(x, y, activeCamera, viewport, 0);
          if (zResult.result) {
            assertExist(zResult.data);
            const position = rotMat.multiplyVector(zResult.data.position);
            pickInMovingPoint = Vector3.fromCopy3(pickInMovingPoint.x, pickInMovingPoint.y, position.z);
          }
          InputManager.disableCameraController();
        }
        const deltaVector3 = Vector3.subtract(pickInMovingPoint, this.__pickStatedPoint);
        if (deltaVector3.length() === 0) {
          return;
        }
        Logger.debug(`${this.__target.uniqueName}: ` + deltaVector3.toStringApproximately());
        if (_TranslationGizmo.__space === "local") {
          this.__deltaPoint = Vector3.add(deltaVector3, this.__targetPointBackup);
        } else if (_TranslationGizmo.__space === "world") {
          const parent2 = this.__target.getSceneGraph().parent;
          let worldMatrix2 = Matrix44.identity();
          if (Is.exist(parent2)) {
            worldMatrix2 = parent2.matrix.getRotate();
          }
          const scaleVec2 = Vector3.one();
          let rotMat2 = Matrix33.fromCopy9RowMajor(scaleVec2.x * worldMatrix2.m00, scaleVec2.x * worldMatrix2.m01, scaleVec2.x * worldMatrix2.m02, scaleVec2.y * worldMatrix2.m10, scaleVec2.y * worldMatrix2.m11, scaleVec2.y * worldMatrix2.m12, scaleVec2.z * worldMatrix2.m20, scaleVec2.z * worldMatrix2.m21, scaleVec2.z * worldMatrix2.m22);
          rotMat2 = Matrix33.transpose(rotMat2);
          const deltaDeltaVector3 = Vector3.add(this.__targetPointBackup, rotMat2.multiplyVector(deltaVector3));
          this.__deltaPoint = deltaDeltaVector3;
        }
      }
      __onPointerUp(evt) {
        evt.preventDefault();
        this.__isPointerDown = false;
        _TranslationGizmo.__activeAxis = "none";
        InputManager.enableCameraController();
        if (this.__latestTargetEntity === this.__target) {
          this.__targetPointBackup = this.__target.getTransform().localPosition;
        }
      }
      static castRay2(evt) {
        const rect = evt.target.getBoundingClientRect();
        const width = evt.target.clientWidth;
        const height = evt.target.clientHeight;
        const x = evt.clientX - rect.left;
        const y = rect.height - (evt.clientY - rect.top);
        const viewport = Vector4.fromCopy4(0, 0, width, height);
        const activeCamera = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
        const result = _TranslationGizmo.__groupEntity.getSceneGraph().castRayFromScreen(x, y, activeCamera, viewport, 0, []);
        return result;
      }
      static castRay(evt) {
        const rect = evt.target.getBoundingClientRect();
        const width = evt.target.clientWidth;
        const height = evt.target.clientHeight;
        const x = evt.clientX - rect.left;
        const y = rect.height - (evt.clientY - rect.top);
        const viewport = Vector4.fromCopy4(0, 0, width, height);
        const activeCamera = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
        const xResult = _TranslationGizmo.__xCubeEntity.getMesh().castRayFromScreenInWorld(x, y, activeCamera, viewport, 0);
        const yResult = _TranslationGizmo.__yCubeEntity.getMesh().castRayFromScreenInWorld(x, y, activeCamera, viewport, 0);
        const zResult = _TranslationGizmo.__zCubeEntity.getMesh().castRayFromScreenInWorld(x, y, activeCamera, viewport, 0);
        return {
          xResult,
          yResult,
          zResult
        };
      }
      _destroy() {
        if (Is.exist(this.__topEntity)) {
          this.__topEntity._destroy();
        }
      }
    };
    __name(_TranslationGizmo, "TranslationGizmo");
    __publicField(_TranslationGizmo, "__groupEntity");
    __publicField(_TranslationGizmo, "__xCubeEntity");
    __publicField(_TranslationGizmo, "__yCubeEntity");
    __publicField(_TranslationGizmo, "__zCubeEntity");
    __publicField(_TranslationGizmo, "__xCubeMesh");
    __publicField(_TranslationGizmo, "__yCubeMesh");
    __publicField(_TranslationGizmo, "__zCubeMesh");
    __publicField(_TranslationGizmo, "__xCubePrimitive");
    __publicField(_TranslationGizmo, "__yCubePrimitive");
    __publicField(_TranslationGizmo, "__zCubePrimitive");
    __publicField(_TranslationGizmo, "__xCubeMaterial");
    __publicField(_TranslationGizmo, "__yCubeMaterial");
    __publicField(_TranslationGizmo, "__zCubeMaterial");
    __publicField(_TranslationGizmo, "__xyPlaneEntity");
    __publicField(_TranslationGizmo, "__yzPlaneEntity");
    __publicField(_TranslationGizmo, "__zxPlaneEntity");
    __publicField(_TranslationGizmo, "__xyPlaneMesh");
    __publicField(_TranslationGizmo, "__yzPlaneMesh");
    __publicField(_TranslationGizmo, "__zxPlaneMesh");
    __publicField(_TranslationGizmo, "__xyPlanePrimitive");
    __publicField(_TranslationGizmo, "__yzPlanePrimitive");
    __publicField(_TranslationGizmo, "__zxPlanePrimitive");
    __publicField(_TranslationGizmo, "__xyPlaneMaterial");
    __publicField(_TranslationGizmo, "__yzPlaneMaterial");
    __publicField(_TranslationGizmo, "__zxPlaneMaterial");
    __publicField(_TranslationGizmo, "__originalX", 0);
    __publicField(_TranslationGizmo, "__originalY", 0);
    __publicField(_TranslationGizmo, "__activeAxis", "none");
    __publicField(_TranslationGizmo, "__space", "world");
    __publicField(_TranslationGizmo, "__length", 1);
    TranslationGizmo = _TranslationGizmo;
  }
});

// src/foundation/gizmos/ScaleGizmo.ts
var _ScaleGizmo, ScaleGizmo;
var init_ScaleGizmo = __esm({
  "src/foundation/gizmos/ScaleGizmo.ts"() {
    "use strict";
    init_CameraComponent();
    init_createMeshEntity();
    init_createGroupEntity();
    init_ComponentRepository();
    init_Config();
    init_AlphaMode();
    init_PrimitiveMode();
    init_VertexAttribute();
    init_Mesh();
    init_Primitive();
    init_Cube();
    init_Plane();
    init_MaterialHelper();
    init_MathUtil();
    init_Matrix33();
    init_Matrix44();
    init_MutableMatrix33();
    init_Quaternion();
    init_Vector3();
    init_Vector4();
    init_Is();
    init_Logger();
    init_MiscUtil();
    init_InputManager();
    init_Gizmo();
    _ScaleGizmo = class _ScaleGizmo extends Gizmo {
      /**
      * Constructor
      * @param target the object which this gizmo belong to
      */
      constructor(target) {
        super(target);
        __publicField(this, "__pickStatedPoint", Vector3.zero());
        __publicField(this, "__deltaPoint", Vector3.one());
        __publicField(this, "__targetScaleBackup", Vector3.one());
        __publicField(this, "__isPointerDown", false);
        __publicField(this, "__onPointerDownFunc", this.__onPointerDown.bind(this));
        __publicField(this, "__onPointerMoveFunc", this.__onPointerMove.bind(this));
        __publicField(this, "__onPointerUpFunc", this.__onPointerUp.bind(this));
      }
      ///
      ///
      /// Accessors
      ///
      ///
      get isSetup() {
        if (this.__topEntity != null) {
          return true;
        } else {
          return false;
        }
      }
      set length(val) {
        _ScaleGizmo.__length = val;
      }
      get length() {
        return _ScaleGizmo.__length;
      }
      set isVisible(flg) {
        if (this.__isVisible === false && flg === true) {
          let eventTargetDom2 = window;
          if (Is.exist(Config.eventTargetDom)) {
            eventTargetDom2 = Config.eventTargetDom;
          }
          InputManager.register(INPUT_HANDLING_STATE_GIZMO_SCALE, [
            {
              eventName: getEvent("start"),
              handler: this.__onPointerDownFunc,
              options: {},
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: getEvent("move"),
              handler: this.__onPointerMoveFunc,
              options: {},
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: getEvent("end"),
              handler: this.__onPointerUpFunc,
              options: {},
              classInstance: this,
              eventTargetDom: eventTargetDom2
            },
            {
              eventName: "pointerleave",
              handler: this.__onPointerUpFunc,
              options: {},
              classInstance: this,
              eventTargetDom: eventTargetDom2
            }
          ]);
          this.__topEntity.getSceneGraph().addChild(_ScaleGizmo.__groupEntity.getSceneGraph());
          _ScaleGizmo.__latestTargetEntity = this.__target;
          if (_ScaleGizmo.__space === "local") {
            const parent = this.__target.getSceneGraph();
            let quaternion = Quaternion.identity();
            if (Is.exist(parent)) {
              quaternion = parent.getQuaternionRecursively();
            }
            _ScaleGizmo.__groupEntity.getTransform().localRotation = quaternion;
          } else if (_ScaleGizmo.__space === "world") {
            _ScaleGizmo.__groupEntity.getTransform().localRotation = Quaternion.fromCopy4(0, 0, 0, 1);
          }
        }
        if (this.__isVisible === true && flg === false) {
          InputManager.unregister(INPUT_HANDLING_STATE_GIZMO_SCALE);
          this.__deltaPoint = this.__target.getTransform().localScale;
          this.__pickStatedPoint = Vector3.zero();
          this.__isPointerDown = false;
          this.__targetScaleBackup = this.__target.getTransform().localScale;
          _ScaleGizmo.__activeAxis = "none";
        }
        InputManager.setActive(INPUT_HANDLING_STATE_GIZMO_SCALE, flg);
        this.__setVisible(flg);
        _ScaleGizmo.__xyPlaneEntity.getSceneGraph().isVisible = false;
        _ScaleGizmo.__yzPlaneEntity.getSceneGraph().isVisible = false;
        _ScaleGizmo.__zxPlaneEntity.getSceneGraph().isVisible = false;
      }
      setSpace(space) {
        _ScaleGizmo.__space = space;
        if (this.__isVisible) {
          this.isVisible = false;
          this.isVisible = true;
        }
      }
      get isVisible() {
        return this.__isVisible;
      }
      ///
      ///
      /// Friends Members
      ///
      ///
      /**
      * @internal
      * setup entities of Gizmo if not done yet
      */
      _setup() {
        if (this.__toSkipSetup()) {
          return;
        }
        this.__topEntity = createGroupEntity();
        this.__topEntity.tryToSetUniqueName(`ScaleGizmo_of_${this.__target.uniqueName}`, true);
        this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix = true;
        this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph());
        if (Is.not.exist(_ScaleGizmo.__xCubeEntity)) {
          this.xMesh();
          this.xEdgeMesh();
        }
        if (Is.not.exist(_ScaleGizmo.__yCubeEntity)) {
          this.yMesh();
          this.yEdgeMesh();
        }
        if (Is.not.exist(_ScaleGizmo.__zCubeEntity)) {
          this.zMesh();
          this.zEdgeMesh();
        }
        if (Is.not.exist(_ScaleGizmo.__xyPlaneEntity)) {
          this.xyPlane();
        }
        if (Is.not.exist(_ScaleGizmo.__yzPlaneEntity)) {
          this.yzPlane();
        }
        if (Is.not.exist(_ScaleGizmo.__zxPlaneEntity)) {
          this.zxPlane();
        }
        if (Is.not.exist(_ScaleGizmo.__groupEntity)) {
          _ScaleGizmo.__groupEntity = createGroupEntity();
        }
        this.__topEntity.getSceneGraph().addChild(_ScaleGizmo.__groupEntity.getSceneGraph());
        _ScaleGizmo.__groupEntity.getSceneGraph().addChild(_ScaleGizmo.__xCubeEntity.getSceneGraph());
        _ScaleGizmo.__groupEntity.getSceneGraph().addChild(_ScaleGizmo.__yCubeEntity.getSceneGraph());
        _ScaleGizmo.__groupEntity.getSceneGraph().addChild(_ScaleGizmo.__zCubeEntity.getSceneGraph());
        _ScaleGizmo.__groupEntity.getSceneGraph().addChild(_ScaleGizmo.__xyPlaneEntity.getSceneGraph());
        _ScaleGizmo.__groupEntity.getSceneGraph().addChild(_ScaleGizmo.__yzPlaneEntity.getSceneGraph());
        _ScaleGizmo.__groupEntity.getSceneGraph().addChild(_ScaleGizmo.__zxPlaneEntity.getSceneGraph());
        _ScaleGizmo.__latestTargetEntity = this.__target;
        this.setGizmoTag();
      }
      zxPlane() {
        _ScaleGizmo.__zxPlaneEntity = createMeshEntity();
        _ScaleGizmo.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_zxPlane", true);
        _ScaleGizmo.__zxPlaneEntity.getSceneGraph().isVisible = false;
        _ScaleGizmo.__zxPlaneMaterial = MaterialHelper.createClassicUberMaterial();
        _ScaleGizmo.__zxPlaneMaterial.setParameter("diffuseColorFactor", Vector4.fromCopyArray4([
          0,
          0.5,
          0,
          0
        ]));
        _ScaleGizmo.__zxPlaneMaterial.alphaMode = AlphaMode.Blend;
        _ScaleGizmo.__zxPlaneMesh = new Mesh();
        _ScaleGizmo.__zxPlanePrimitive = new Plane();
        _ScaleGizmo.__zxPlanePrimitive.generate({
          width: 1e5,
          height: 1e5,
          uSpan: 1,
          vSpan: 1,
          isUVRepeat: true,
          flipTextureCoordinateY: false,
          material: _ScaleGizmo.__zxPlaneMaterial
        });
        _ScaleGizmo.__zxPlaneMesh.addPrimitive(_ScaleGizmo.__zxPlanePrimitive);
        _ScaleGizmo.__zxPlaneEntity.getMesh().setMesh(_ScaleGizmo.__zxPlaneMesh);
      }
      yzPlane() {
        _ScaleGizmo.__yzPlaneEntity = createMeshEntity();
        _ScaleGizmo.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_yzPlane", true);
        _ScaleGizmo.__yzPlaneEntity.getSceneGraph().isVisible = false;
        _ScaleGizmo.__yzPlaneEntity.getTransform().localEulerAngles = Vector3.fromCopy3(0, 0, MathUtil.degreeToRadian(90));
        _ScaleGizmo.__yzPlaneMaterial = MaterialHelper.createClassicUberMaterial();
        _ScaleGizmo.__yzPlaneMaterial.alphaMode = AlphaMode.Blend;
        _ScaleGizmo.__yzPlaneMaterial.setParameter("diffuseColorFactor", Vector4.fromCopyArray4([
          0.5,
          0,
          0,
          0
        ]));
        _ScaleGizmo.__yzPlaneMesh = new Mesh();
        _ScaleGizmo.__yzPlanePrimitive = new Plane();
        _ScaleGizmo.__yzPlanePrimitive.generate({
          width: 1e5,
          height: 1e5,
          uSpan: 1,
          vSpan: 1,
          isUVRepeat: true,
          flipTextureCoordinateY: false,
          material: _ScaleGizmo.__yzPlaneMaterial
        });
        _ScaleGizmo.__yzPlaneMesh.addPrimitive(_ScaleGizmo.__yzPlanePrimitive);
        _ScaleGizmo.__yzPlaneEntity.getMesh().setMesh(_ScaleGizmo.__yzPlaneMesh);
      }
      xyPlane() {
        _ScaleGizmo.__xyPlaneEntity = createMeshEntity();
        _ScaleGizmo.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_xyPlane", true);
        _ScaleGizmo.__xyPlaneEntity.getSceneGraph().isVisible = false;
        _ScaleGizmo.__xyPlaneEntity.getTransform().localEulerAngles = Vector3.fromCopy3(MathUtil.degreeToRadian(90), 0, 0);
        _ScaleGizmo.__xyPlaneMaterial = MaterialHelper.createClassicUberMaterial();
        _ScaleGizmo.__xyPlaneMaterial.alphaMode = AlphaMode.Blend;
        _ScaleGizmo.__xyPlaneMaterial.setParameter("diffuseColorFactor", Vector4.fromCopyArray4([
          0,
          0,
          0.5,
          0
        ]));
        _ScaleGizmo.__xyPlaneMesh = new Mesh();
        _ScaleGizmo.__xyPlanePrimitive = new Plane();
        _ScaleGizmo.__xyPlanePrimitive.generate({
          width: 1e5,
          height: 1e5,
          uSpan: 1,
          vSpan: 1,
          isUVRepeat: true,
          flipTextureCoordinateY: false,
          material: _ScaleGizmo.__xyPlaneMaterial
        });
        _ScaleGizmo.__xyPlaneMesh.addPrimitive(_ScaleGizmo.__xyPlanePrimitive);
        _ScaleGizmo.__xyPlaneEntity.getMesh().setMesh(_ScaleGizmo.__xyPlaneMesh);
      }
      zMesh() {
        _ScaleGizmo.__zCubeEntity = createMeshEntity();
        _ScaleGizmo.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_zCube", true);
        _ScaleGizmo.__zCubeEntity.getTransform().localPosition = Vector3.fromCopy3(0, 0, 1);
        _ScaleGizmo.__zCubeMesh = new Mesh();
        _ScaleGizmo.__zCubeMaterial = MaterialHelper.createClassicUberMaterial();
        _ScaleGizmo.__zCubeMaterial.setParameter("diffuseColorFactor", Vector4.fromCopyArray4([
          0,
          0,
          1,
          1
        ]));
        _ScaleGizmo.__zCubePrimitive = new Cube();
        _ScaleGizmo.__zCubePrimitive.generate({
          widthVector: Vector3.fromCopy3(0.05, 0.05, 1),
          material: _ScaleGizmo.__zCubeMaterial
        });
        _ScaleGizmo.__zCubeMesh.addPrimitive(_ScaleGizmo.__zCubePrimitive);
        _ScaleGizmo.__zCubeEntity.getMesh().setMesh(_ScaleGizmo.__zCubeMesh);
      }
      yMesh() {
        _ScaleGizmo.__yCubeEntity = createMeshEntity();
        _ScaleGizmo.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_yCube", true);
        _ScaleGizmo.__yCubeEntity.getTransform().localPosition = Vector3.fromCopy3(0, 1, 0);
        _ScaleGizmo.__yCubeMesh = new Mesh();
        _ScaleGizmo.__yCubeMaterial = MaterialHelper.createClassicUberMaterial();
        _ScaleGizmo.__yCubeMaterial.setParameter("diffuseColorFactor", Vector4.fromCopyArray4([
          0,
          1,
          0,
          1
        ]));
        _ScaleGizmo.__yCubePrimitive = new Cube();
        _ScaleGizmo.__yCubePrimitive.generate({
          widthVector: Vector3.fromCopy3(0.05, 1, 0.05),
          material: _ScaleGizmo.__yCubeMaterial
        });
        _ScaleGizmo.__yCubeMesh.addPrimitive(_ScaleGizmo.__yCubePrimitive);
        _ScaleGizmo.__yCubeEntity.getMesh().setMesh(_ScaleGizmo.__yCubeMesh);
      }
      xMesh() {
        _ScaleGizmo.__xCubeEntity = createMeshEntity();
        _ScaleGizmo.__xCubeEntity.tryToSetUniqueName("ScaleGizmo_xCube", true);
        _ScaleGizmo.__xCubeEntity.getTransform().localPosition = Vector3.fromCopy3(1, 0, 0);
        _ScaleGizmo.__xCubeMesh = new Mesh();
        _ScaleGizmo.__xCubeMaterial = MaterialHelper.createClassicUberMaterial();
        _ScaleGizmo.__xCubeMaterial.setParameter("diffuseColorFactor", Vector4.fromCopyArray4([
          1,
          0,
          0,
          1
        ]));
        _ScaleGizmo.__xCubePrimitive = new Cube();
        _ScaleGizmo.__xCubePrimitive.generate({
          widthVector: Vector3.fromCopy3(1, 0.05, 0.05),
          material: _ScaleGizmo.__xCubeMaterial
        });
        _ScaleGizmo.__xCubeMesh.addPrimitive(_ScaleGizmo.__xCubePrimitive);
        _ScaleGizmo.__xCubeEntity.getMesh().setMesh(_ScaleGizmo.__xCubeMesh);
      }
      xEdgeMesh() {
        _ScaleGizmo.__xEdgeCubeEntity = createMeshEntity();
        _ScaleGizmo.__xEdgeCubeEntity.tryToSetUniqueName("ScaleGizmo_xEdgeCube", true);
        _ScaleGizmo.__xEdgeCubeEntity.getTransform().localPosition = Vector3.fromCopy3(1, 0, 0);
        _ScaleGizmo.__xEdgeCubeMesh = new Mesh();
        _ScaleGizmo.__xEdgeCubePrimitive = new Cube();
        _ScaleGizmo.__xEdgeCubePrimitive.generate({
          widthVector: Vector3.fromCopy3(0.1, 0.1, 0.1),
          material: _ScaleGizmo.__xCubeMaterial
        });
        _ScaleGizmo.__xEdgeCubeMesh.addPrimitive(_ScaleGizmo.__xEdgeCubePrimitive);
        _ScaleGizmo.__xEdgeCubeEntity.getMesh().setMesh(_ScaleGizmo.__xEdgeCubeMesh);
        _ScaleGizmo.__xCubeEntity.addChild(_ScaleGizmo.__xEdgeCubeEntity.getSceneGraph());
      }
      yEdgeMesh() {
        _ScaleGizmo.__yEdgeCubeEntity = createMeshEntity();
        _ScaleGizmo.__yEdgeCubeEntity.tryToSetUniqueName("ScaleGizmo_yEdgeCube", true);
        _ScaleGizmo.__yEdgeCubeEntity.getTransform().localPosition = Vector3.fromCopy3(0, 1, 0);
        _ScaleGizmo.__yEdgeCubeMesh = new Mesh();
        _ScaleGizmo.__yEdgeCubePrimitive = new Cube();
        _ScaleGizmo.__yEdgeCubePrimitive.generate({
          widthVector: Vector3.fromCopy3(0.1, 0.1, 0.1),
          material: _ScaleGizmo.__yCubeMaterial
        });
        _ScaleGizmo.__yEdgeCubeMesh.addPrimitive(_ScaleGizmo.__yEdgeCubePrimitive);
        _ScaleGizmo.__yEdgeCubeEntity.getMesh().setMesh(_ScaleGizmo.__yEdgeCubeMesh);
        _ScaleGizmo.__yCubeEntity.addChild(_ScaleGizmo.__yEdgeCubeEntity.getSceneGraph());
      }
      zEdgeMesh() {
        _ScaleGizmo.__zEdgeCubeEntity = createMeshEntity();
        _ScaleGizmo.__zEdgeCubeEntity.tryToSetUniqueName("ScaleGizmo_zEdgeCube", true);
        _ScaleGizmo.__zEdgeCubeEntity.getTransform().localPosition = Vector3.fromCopy3(0, 0, 1);
        _ScaleGizmo.__zEdgeCubeMesh = new Mesh();
        _ScaleGizmo.__zEdgeCubePrimitive = new Cube();
        _ScaleGizmo.__zEdgeCubePrimitive.generate({
          widthVector: Vector3.fromCopy3(0.1, 0.1, 0.1),
          material: _ScaleGizmo.__zCubeMaterial
        });
        _ScaleGizmo.__zEdgeCubeMesh.addPrimitive(_ScaleGizmo.__zEdgeCubePrimitive);
        _ScaleGizmo.__zEdgeCubeEntity.getMesh().setMesh(_ScaleGizmo.__zEdgeCubeMesh);
        _ScaleGizmo.__zCubeEntity.addChild(_ScaleGizmo.__zEdgeCubeEntity.getSceneGraph());
      }
      /**
      * @internal
      * update the transform and etc of the gizmo
      */
      _update() {
        if (this.__topEntity == null) {
          return;
        }
        const sg = this.__target.getSceneGraph();
        const aabb = sg.worldMergedAABBWithSkeletal;
        if (aabb.isVanilla()) {
          this.__topEntity.getTransform().localPosition = sg.position;
        } else {
          this.__topEntity.getTransform().localPosition = aabb.centerPoint;
        }
        const max = Math.max(aabb.sizeX, aabb.sizeY, aabb.sizeZ);
        this.__topEntity.getTransform().localScale = Vector3.fromCopyArray([
          Math.min(1, aabb.isVanilla() ? 1 : max / 2),
          Math.min(1, aabb.isVanilla() ? 1 : max / 2),
          Math.min(1, aabb.isVanilla() ? 1 : max / 2)
        ]);
        if (this.__isPointerDown) {
          if (_ScaleGizmo.__latestTargetEntity === this.__target) {
            this.__target.getTransform().localScale = this.__deltaPoint.clone();
          }
        }
      }
      ///
      ///
      /// Private Static Members
      ///
      ///
      static __generatePrimitive() {
        const positions = new Float32Array([
          // X axis
          0,
          0,
          0,
          this.__length,
          0,
          0,
          // Y axis
          0,
          0,
          0,
          0,
          this.__length,
          0,
          // Z axis
          0,
          0,
          0,
          0,
          0,
          this.__length
        ]);
        const color = new Float32Array([
          // X axis as Red
          1,
          0,
          0,
          1,
          0,
          0,
          // Y axis as Green
          0,
          1,
          0,
          0,
          1,
          0,
          // Z axis as Blue
          0,
          0,
          1,
          0,
          0,
          1
        ]);
        const primitive = Primitive.createPrimitive({
          attributeSemantics: [
            VertexAttribute.Position.XYZ,
            VertexAttribute.Color0.XYZ
          ],
          attributes: [
            positions,
            color
          ],
          primitiveMode: PrimitiveMode.Lines
        });
        return primitive;
      }
      __onPointerDown(evt) {
        evt.preventDefault();
        this.__isPointerDown = true;
        _ScaleGizmo.__originalX = evt.clientX;
        _ScaleGizmo.__originalY = evt.clientY;
        const worldMatrix = this.__target.getSceneGraph().matrix.getRotate();
        const scaleVec = Vector3.one();
        let rotMat = Matrix33.fromCopy9RowMajor(scaleVec.x * worldMatrix.m00, scaleVec.x * worldMatrix.m01, scaleVec.x * worldMatrix.m02, scaleVec.y * worldMatrix.m10, scaleVec.y * worldMatrix.m11, scaleVec.y * worldMatrix.m12, scaleVec.z * worldMatrix.m20, scaleVec.z * worldMatrix.m21, scaleVec.z * worldMatrix.m22);
        if (_ScaleGizmo.__space === "local") {
          rotMat = Matrix33.transpose(rotMat);
        } else if (_ScaleGizmo.__space === "world") {
          rotMat = MutableMatrix33.identity();
        }
        const { xResult, yResult, zResult } = _ScaleGizmo.castRay(evt);
        if (xResult.result) {
          assertExist(xResult.data);
          this.__pickStatedPoint = rotMat.multiplyVector(xResult.data.position.clone());
          Logger.debug("Down:" + this.__pickStatedPoint.toStringApproximately());
          _ScaleGizmo.__activeAxis = "x";
        }
        if (yResult.result) {
          assertExist(yResult.data);
          this.__pickStatedPoint = rotMat.multiplyVector(yResult.data.position.clone());
          Logger.debug("Down:" + this.__pickStatedPoint.toStringApproximately());
          _ScaleGizmo.__activeAxis = "y";
        }
        if (zResult.result) {
          assertExist(zResult.data);
          this.__pickStatedPoint = rotMat.multiplyVector(zResult.data.position.clone());
          Logger.debug("Down:" + this.__pickStatedPoint.toStringApproximately());
          _ScaleGizmo.__activeAxis = "z";
        }
        if (_ScaleGizmo.__latestTargetEntity === this.__target) {
          this.__targetScaleBackup = this.__target.getTransform().localScale;
        }
      }
      __onPointerMove(evt) {
        evt.preventDefault();
        if (Is.false(this.__isPointerDown)) {
          return;
        }
        const rect = evt.target.getBoundingClientRect();
        const width = evt.target.clientWidth;
        const height = evt.target.clientHeight;
        const x = evt.clientX - rect.left;
        const y = rect.height - (evt.clientY - rect.top);
        const viewport = Vector4.fromCopy4(0, 0, width, height);
        const activeCamera = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
        const worldMatrix = this.__target.getSceneGraph().matrix.getRotate();
        const scaleVec = Vector3.one();
        let rotMat = Matrix33.fromCopy9RowMajor(scaleVec.x * worldMatrix.m00, scaleVec.x * worldMatrix.m01, scaleVec.x * worldMatrix.m02, scaleVec.y * worldMatrix.m10, scaleVec.y * worldMatrix.m11, scaleVec.y * worldMatrix.m12, scaleVec.z * worldMatrix.m20, scaleVec.z * worldMatrix.m21, scaleVec.z * worldMatrix.m22);
        if (_ScaleGizmo.__space === "local") {
          rotMat = Matrix33.transpose(rotMat);
        } else if (_ScaleGizmo.__space === "world") {
          rotMat = MutableMatrix33.identity();
        }
        let pickInMovingPoint = this.__pickStatedPoint.clone();
        if (_ScaleGizmo.__activeAxis === "x") {
          const xResult = _ScaleGizmo.__xyPlaneEntity.getMesh().castRayFromScreenInWorld(x, y, activeCamera, viewport, 0);
          if (xResult.result) {
            assertExist(xResult.data);
            const position = rotMat.multiplyVector(xResult.data.position);
            pickInMovingPoint = Vector3.fromCopy3(position.x, pickInMovingPoint.y, pickInMovingPoint.z);
            Logger.debug("Move:" + xResult.data.position.toStringApproximately());
          }
          InputManager.disableCameraController();
        }
        if (_ScaleGizmo.__activeAxis === "y") {
          const yResult = _ScaleGizmo.__xyPlaneEntity.getMesh().castRayFromScreenInWorld(x, y, activeCamera, viewport, 0);
          if (yResult.result) {
            assertExist(yResult.data);
            const position = rotMat.multiplyVector(yResult.data.position);
            pickInMovingPoint = Vector3.fromCopy3(pickInMovingPoint.x, position.y, pickInMovingPoint.z);
            Logger.debug("Move:" + yResult.data.position.toStringApproximately());
          }
          InputManager.disableCameraController();
        }
        if (_ScaleGizmo.__activeAxis === "z") {
          const zResult = _ScaleGizmo.__yzPlaneEntity.getMesh().castRayFromScreenInWorld(x, y, activeCamera, viewport, 0);
          if (zResult.result) {
            assertExist(zResult.data);
            const position = rotMat.multiplyVector(zResult.data.position);
            pickInMovingPoint = Vector3.fromCopy3(pickInMovingPoint.x, pickInMovingPoint.y, position.z);
            Logger.debug("Move:" + zResult.data.position.toStringApproximately());
          }
          InputManager.disableCameraController();
        }
        const sg = this.__target.getSceneGraph();
        const aabb = sg.worldMergedAABBWithSkeletal;
        const deltaVector3 = Vector3.multiply(Vector3.subtract(pickInMovingPoint, this.__pickStatedPoint), 1 / aabb.lengthCenterToCorner);
        Logger.debug(`${this.__target.uniqueName}: ` + deltaVector3.toStringApproximately());
        if (_ScaleGizmo.__space === "local") {
          this.__deltaPoint = Vector3.add(this.__targetScaleBackup, deltaVector3);
          this.__deltaPoint = Vector3.fromCopy3(Math.max(this.__deltaPoint.x, 0.01), Math.max(this.__deltaPoint.y, 0.01), Math.max(this.__deltaPoint.z, 0.01));
        } else if (_ScaleGizmo.__space === "world") {
          const worldMat = Matrix44.fromCopyQuaternion(this.__target.getSceneGraph().getQuaternionRecursively());
          const existedScale = Matrix44.multiply(worldMat, Matrix44.scale(this.__targetScaleBackup)).getScale();
          let scale = Vector4.add(deltaVector3, existedScale);
          scale = Vector4.fromCopy4(Math.max(scale.x, 0.01), Math.max(scale.y, 0.01), Math.max(scale.z, 0.01), Math.max(scale.w, 0.01));
          this.__deltaPoint = Matrix44.multiply(Matrix44.invert(worldMat), Matrix44.scale(scale)).getScale();
          this.__deltaPoint = Vector3.fromCopy3(Math.max(this.__deltaPoint.x, 0.01), Math.max(this.__deltaPoint.y, 0.01), Math.max(this.__deltaPoint.z, 0.01));
        }
      }
      __onPointerUp(evt) {
        evt.preventDefault();
        this.__isPointerDown = false;
        _ScaleGizmo.__activeAxis = "none";
        InputManager.enableCameraController();
        if (_ScaleGizmo.__latestTargetEntity === this.__target) {
          this.__targetScaleBackup = this.__target.getTransform().localScale;
        }
      }
      static castRay2(evt) {
        const rect = evt.target.getBoundingClientRect();
        const width = evt.target.clientWidth;
        const height = evt.target.clientHeight;
        const x = evt.clientX - rect.left;
        const y = rect.height - (evt.clientY - rect.top);
        const viewport = Vector4.fromCopy4(0, 0, width, height);
        const activeCamera = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
        const result = _ScaleGizmo.__groupEntity.getSceneGraph().castRayFromScreen(x, y, activeCamera, viewport, 0, []);
        return result;
      }
      static castRay(evt) {
        const rect = evt.target.getBoundingClientRect();
        const width = evt.target.clientWidth;
        const height = evt.target.clientHeight;
        const x = evt.clientX - rect.left;
        const y = rect.height - (evt.clientY - rect.top);
        const viewport = Vector4.fromCopy4(0, 0, width, height);
        const activeCamera = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
        const xResult = _ScaleGizmo.__xCubeEntity.getSceneGraph().castRayFromScreen(x, y, activeCamera, viewport, 0);
        const yResult = _ScaleGizmo.__yCubeEntity.getSceneGraph().castRayFromScreen(x, y, activeCamera, viewport, 0);
        const zResult = _ScaleGizmo.__zCubeEntity.getSceneGraph().castRayFromScreen(x, y, activeCamera, viewport, 0);
        return {
          xResult,
          yResult,
          zResult
        };
      }
      _destroy() {
        if (Is.exist(this.__topEntity)) {
          this.__topEntity._destroy();
        }
      }
    };
    __name(_ScaleGizmo, "ScaleGizmo");
    __publicField(_ScaleGizmo, "__groupEntity");
    __publicField(_ScaleGizmo, "__xCubeEntity");
    __publicField(_ScaleGizmo, "__yCubeEntity");
    __publicField(_ScaleGizmo, "__zCubeEntity");
    __publicField(_ScaleGizmo, "__xCubeMesh");
    __publicField(_ScaleGizmo, "__yCubeMesh");
    __publicField(_ScaleGizmo, "__zCubeMesh");
    __publicField(_ScaleGizmo, "__xCubePrimitive");
    __publicField(_ScaleGizmo, "__yCubePrimitive");
    __publicField(_ScaleGizmo, "__zCubePrimitive");
    __publicField(_ScaleGizmo, "__xEdgeCubeEntity");
    __publicField(_ScaleGizmo, "__yEdgeCubeEntity");
    __publicField(_ScaleGizmo, "__zEdgeCubeEntity");
    __publicField(_ScaleGizmo, "__xEdgeCubeMesh");
    __publicField(_ScaleGizmo, "__yEdgeCubeMesh");
    __publicField(_ScaleGizmo, "__zEdgeCubeMesh");
    __publicField(_ScaleGizmo, "__xEdgeCubePrimitive");
    __publicField(_ScaleGizmo, "__yEdgeCubePrimitive");
    __publicField(_ScaleGizmo, "__zEdgeCubePrimitive");
    __publicField(_ScaleGizmo, "__xCubeMaterial");
    __publicField(_ScaleGizmo, "__yCubeMaterial");
    __publicField(_ScaleGizmo, "__zCubeMaterial");
    __publicField(_ScaleGizmo, "__xyPlaneEntity");
    __publicField(_ScaleGizmo, "__yzPlaneEntity");
    __publicField(_ScaleGizmo, "__zxPlaneEntity");
    __publicField(_ScaleGizmo, "__xyPlaneMesh");
    __publicField(_ScaleGizmo, "__yzPlaneMesh");
    __publicField(_ScaleGizmo, "__zxPlaneMesh");
    __publicField(_ScaleGizmo, "__xyPlanePrimitive");
    __publicField(_ScaleGizmo, "__yzPlanePrimitive");
    __publicField(_ScaleGizmo, "__zxPlanePrimitive");
    __publicField(_ScaleGizmo, "__xyPlaneMaterial");
    __publicField(_ScaleGizmo, "__yzPlaneMaterial");
    __publicField(_ScaleGizmo, "__zxPlaneMaterial");
    __publicField(_ScaleGizmo, "__originalX", 0);
    __publicField(_ScaleGizmo, "__originalY", 0);
    __publicField(_ScaleGizmo, "__activeAxis", "none");
    __publicField(_ScaleGizmo, "__space", "world");
    __publicField(_ScaleGizmo, "__latestTargetEntity");
    __publicField(_ScaleGizmo, "__length", 1);
    ScaleGizmo = _ScaleGizmo;
  }
});

// src/foundation/math/raw/index.ts
var init_raw = __esm({
  "src/foundation/math/raw/index.ts"() {
    "use strict";
    init_raw_extension();
  }
});

// src/foundation/math/AbstractMathNumber.ts
var _AbstractArrayBufferBaseMathNumber, AbstractArrayBufferBaseMathNumber;
var init_AbstractMathNumber = __esm({
  "src/foundation/math/AbstractMathNumber.ts"() {
    "use strict";
    _AbstractArrayBufferBaseMathNumber = class _AbstractArrayBufferBaseMathNumber {
      constructor() {
        __publicField(this, "_v", new Float32Array());
      }
      isTheSourceSame(arrayBuffer) {
        return this._v.buffer === arrayBuffer;
      }
    };
    __name(_AbstractArrayBufferBaseMathNumber, "AbstractArrayBufferBaseMathNumber");
    AbstractArrayBufferBaseMathNumber = _AbstractArrayBufferBaseMathNumber;
  }
});

// src/foundation/math/ColorRgba.ts
var _ColorRgba, ColorRgba, ConstRgbaWhite, ConstRgbaBlack;
var init_ColorRgba = __esm({
  "src/foundation/math/ColorRgba.ts"() {
    "use strict";
    init_Vector4();
    _ColorRgba = class _ColorRgba extends Vector4 {
      constructor(r2) {
        super(r2);
      }
      get x() {
        return this._v[0];
      }
      get y() {
        return this._v[1];
      }
      get z() {
        return this._v[2];
      }
      get w() {
        return this._v[3];
      }
      get r() {
        return this._v[0];
      }
      get g() {
        return this._v[1];
      }
      get b() {
        return this._v[2];
      }
      get a() {
        return this._v[3];
      }
      static zero() {
        return super._zero(Float32Array);
      }
      static one() {
        return super._one(Float32Array);
      }
      static dummy() {
        return super._dummy(Float32Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float32Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
      }
      clone() {
        return super.clone();
      }
      static fromCopyArray(array) {
        return this._fromCopyArray(array, Float32Array);
      }
      static fromCopyArray4(array) {
        return this._fromCopyArray4(array, Float32Array);
      }
      static fromCopy4(x, y, z, w) {
        return this._fromCopy4(x, y, z, w, Float32Array);
      }
      static fromCopyVector4(vec4) {
        return this._fromCopyVector4(vec4, Float32Array);
      }
    };
    __name(_ColorRgba, "ColorRgba");
    ColorRgba = _ColorRgba;
    ConstRgbaWhite = new ColorRgba(new Float32Array([
      1,
      1,
      1,
      1
    ]));
    ConstRgbaBlack = new ColorRgba(new Float32Array([
      0,
      0,
      0,
      1
    ]));
  }
});

// src/foundation/math/IColor.ts
var init_IColor = __esm({
  "src/foundation/math/IColor.ts"() {
    "use strict";
  }
});

// src/foundation/math/IMathNumber.ts
var init_IMathNumber = __esm({
  "src/foundation/math/IMathNumber.ts"() {
    "use strict";
  }
});

// src/foundation/math/IMatrix.ts
var init_IMatrix = __esm({
  "src/foundation/math/IMatrix.ts"() {
    "use strict";
  }
});

// src/foundation/math/IQuaternion.ts
var init_IQuaternion = __esm({
  "src/foundation/math/IQuaternion.ts"() {
    "use strict";
  }
});

// src/foundation/math/IVector.ts
var init_IVector = __esm({
  "src/foundation/math/IVector.ts"() {
    "use strict";
  }
});

// src/foundation/math/LogQuaternion.ts
var _LogQuaternion, LogQuaternion;
var init_LogQuaternion = __esm({
  "src/foundation/math/LogQuaternion.ts"() {
    "use strict";
    init_Quaternion();
    _LogQuaternion = class _LogQuaternion {
      constructor(x) {
        __publicField(this, "_v");
        this._v = x;
      }
      get x() {
        return this._v[0];
      }
      get y() {
        return this._v[1];
      }
      get z() {
        return this._v[2];
      }
      get w() {
        return 1;
      }
      static fromFloat32Array(array) {
        return new _LogQuaternion(array);
      }
      static fromCopyArray3(array) {
        return new Quaternion(new Float32Array(array));
      }
      static fromCopyArray(array) {
        return new Quaternion(new Float32Array(array.slice(0, 3)));
      }
      static fromCopy3(x, y, z) {
        return new Quaternion(new Float32Array([
          x,
          y,
          z
        ]));
      }
      static fromCopyLogQuaternion(quat) {
        const v = new Float32Array(3);
        v[0] = quat._v[0];
        v[1] = quat._v[1];
        v[2] = quat._v[2];
        return new Quaternion(v);
      }
      static fromCopyVector4(vec) {
        const v = new Float32Array(3);
        v[0] = vec._v[0];
        v[1] = vec._v[1];
        v[2] = vec._v[2];
        return new Quaternion(v);
      }
      static fromCopyQuaternion(x) {
        const theta = Math.acos(x.w);
        const sin = Math.sin(theta);
        const v = new Float32Array(3);
        v[0] = x.x * (theta / sin);
        v[1] = x.y * (theta / sin);
        v[2] = x.z * (theta / sin);
        return new _LogQuaternion(v);
      }
      get className() {
        return "LogQuaternion";
      }
    };
    __name(_LogQuaternion, "LogQuaternion");
    LogQuaternion = _LogQuaternion;
  }
});

// src/foundation/math/MutableColorRgb.ts
var _MutableColorRgb, MutableColorRgb;
var init_MutableColorRgb = __esm({
  "src/foundation/math/MutableColorRgb.ts"() {
    "use strict";
    init_MutableVector3();
    _MutableColorRgb = class _MutableColorRgb extends MutableVector3 {
      constructor(r2) {
        super(r2);
      }
      get x() {
        return this._v[0];
      }
      set x(val) {
        this._v[0] = val;
      }
      get y() {
        return this._v[1];
      }
      set y(val) {
        this._v[1] = val;
      }
      get z() {
        return this._v[2];
      }
      set z(val) {
        this._v[2] = val;
      }
      get w() {
        return 1;
      }
      get r() {
        return this._v[0];
      }
      set r(val) {
        this._v[0] = val;
      }
      get g() {
        return this._v[1];
      }
      set g(val) {
        this._v[1] = val;
      }
      get b() {
        return this._v[2];
      }
      set b(val) {
        this._v[2] = val;
      }
      get a() {
        return 1;
      }
      static zero() {
        return super._zero(Float32Array);
      }
      static one() {
        return super._one(Float32Array);
      }
      static dummy() {
        return super._dummy(Float32Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float32Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
      }
      static cross(l_vec, r_vec) {
        return super._cross(l_vec, r_vec, Float32Array);
      }
      clone() {
        return super.clone();
      }
    };
    __name(_MutableColorRgb, "MutableColorRgb");
    MutableColorRgb = _MutableColorRgb;
  }
});

// src/foundation/math/MutableColorRgba.ts
var _MutableColorRgba, MutableColorRgba;
var init_MutableColorRgba = __esm({
  "src/foundation/math/MutableColorRgba.ts"() {
    "use strict";
    init_MutableVector4();
    _MutableColorRgba = class _MutableColorRgba extends MutableVector4 {
      constructor(r2) {
        super(r2);
      }
      get x() {
        return this._v[0];
      }
      set x(val) {
        this._v[0] = val;
      }
      get y() {
        return this._v[1];
      }
      set y(val) {
        this._v[1] = val;
      }
      get z() {
        return this._v[2];
      }
      set z(val) {
        this._v[2] = val;
      }
      get w() {
        return this._v[3];
      }
      set w(val) {
        this._v[3] = val;
      }
      get r() {
        return this._v[0];
      }
      set r(val) {
        this._v[0] = val;
      }
      get g() {
        return this._v[1];
      }
      set g(val) {
        this._v[1] = val;
      }
      get b() {
        return this._v[2];
      }
      set b(val) {
        this._v[2] = val;
      }
      get a() {
        return this._v[3];
      }
      set a(val) {
        this._v[3] = val;
      }
      static zero() {
        return super._zero(Float32Array);
      }
      static one() {
        return super._one(Float32Array);
      }
      static dummy() {
        return super._dummy(Float32Array);
      }
      static normalize(vec) {
        return super._normalize(vec, Float32Array);
      }
      static add(l_vec, r_vec) {
        return super._add(l_vec, r_vec, Float32Array);
      }
      static subtract(l_vec, r_vec) {
        return super._subtract(l_vec, r_vec, Float32Array);
      }
      static multiply(vec, value) {
        return super._multiply(vec, value, Float32Array);
      }
      static multiplyVector(l_vec, r_vec) {
        return super._multiplyVector(l_vec, r_vec, Float32Array);
      }
      static divide(vec, value) {
        return super._divide(vec, value, Float32Array);
      }
      static divideVector(l_vec, r_vec) {
        return super._divideVector(l_vec, r_vec, Float32Array);
      }
      clone() {
        return super.clone();
      }
    };
    __name(_MutableColorRgba, "MutableColorRgba");
    MutableColorRgba = _MutableColorRgba;
  }
});

// src/foundation/math/index.ts
var init_math = __esm({
  "src/foundation/math/index.ts"() {
    "use strict";
    init_raw();
    init_AABB();
    init_AbstractMathNumber();
    init_AbstractMatrix();
    init_AbstractQuaternion();
    init_AbstractVector();
    init_ColorRgb();
    init_ColorRgba();
    init_IColor();
    init_IdentityMatrix33();
    init_IdentityMatrix44();
    init_IMathNumber();
    init_IMatrix();
    init_IQuaternion();
    init_IVector();
    init_LogQuaternion();
    init_MathClassUtil();
    init_MathUtil();
    init_Matrix22();
    init_Matrix33();
    init_Matrix44();
    init_MutableColorRgb();
    init_MutableColorRgba();
    init_MutableMatrix22();
    init_MutableMatrix33();
    init_MutableMatrix44();
    init_MutableQuaternion();
    init_MutableScalar();
    init_MutableVector2();
    init_MutableVector3();
    init_MutableVector4();
    init_Quaternion();
    init_Scalar();
    init_Transform3D();
    init_Vector2();
    init_Vector3();
    init_Vector4();
    init_VectorN();
  }
});

// src/foundation/physics/Oimo/OimoPhysicsStrategy.ts
var _OimoPhysicsStrategy, OimoPhysicsStrategy;
var init_OimoPhysicsStrategy = __esm({
  "src/foundation/physics/Oimo/OimoPhysicsStrategy.ts"() {
    "use strict";
    init_math();
    init_Vector3();
    init_Is();
    _OimoPhysicsStrategy = class _OimoPhysicsStrategy {
      constructor() {
        __publicField(this, "__body");
        __publicField(this, "__entity");
        __publicField(this, "__property");
        __publicField(this, "__localScale", Vector3.one());
        if (Is.not.exist(_OimoPhysicsStrategy.__world)) {
          const world = new OIMO.World({
            timestep: 1 / 60,
            iterations: 8,
            broadphase: 2,
            worldscale: 1,
            random: _OimoPhysicsStrategy.__worldProperty.random,
            info: false,
            gravity: [
              _OimoPhysicsStrategy.__worldProperty.gravity.x,
              _OimoPhysicsStrategy.__worldProperty.gravity.y,
              _OimoPhysicsStrategy.__worldProperty.gravity.z
            ]
          });
          _OimoPhysicsStrategy.__world = world;
        }
      }
      setShape(prop, entity) {
        const world = _OimoPhysicsStrategy.__world;
        this.__localScale = prop.size;
        this.__property = {
          type: prop.type.str.toLowerCase(),
          size: [
            prop.size.x,
            prop.size.y,
            prop.size.z
          ],
          pos: [
            prop.position.x,
            prop.position.y,
            prop.position.z
          ],
          rot: [
            prop.rotation.x,
            prop.rotation.y,
            prop.rotation.z
          ],
          move: prop.move,
          density: prop.density,
          friction: prop.friction,
          restitution: prop.restitution
        };
        this.__body = world.add(this.__property);
        this.__entity = entity;
      }
      update() {
        if (this.__entity === void 0) {
          return;
        }
        const pos = this.__body.getPosition();
        const rot = this.__body.getQuaternion();
        this.__entity.getSceneGraph().setPositionWithoutPhysics(Vector3.fromCopy3(pos.x, pos.y, pos.z));
        this.__entity.getSceneGraph().setRotationWithoutPhysics(Quaternion.fromCopy4(rot.x, rot.y, rot.z, rot.w));
      }
      setPosition(worldPosition) {
        const world = _OimoPhysicsStrategy.__world;
        if (this.__entity === void 0) {
          return;
        }
        this.__body.remove();
        const prop = this.__property;
        this.__property = {
          type: prop.type,
          size: [
            prop.size[0],
            prop.size[1],
            prop.size[2]
          ],
          pos: [
            worldPosition.x,
            worldPosition.y,
            worldPosition.z
          ],
          rot: [
            this.__entity.eulerAngles.x,
            this.__entity.eulerAngles.y,
            this.__entity.eulerAngles.z
          ],
          move: prop.move,
          density: prop.density,
          friction: prop.friction,
          restitution: prop.restitution
        };
        this.__body = world.add(this.__property);
      }
      setEulerAngle(eulerAngles) {
        const world = _OimoPhysicsStrategy.__world;
        if (this.__entity === void 0) {
          return;
        }
        const pos = this.__body.getPosition();
        this.__body.remove();
        const prop = this.__property;
        this.__property = {
          type: prop.type,
          size: [
            prop.size[0],
            prop.size[1],
            prop.size[2]
          ],
          pos: [
            pos.x,
            pos.y,
            pos.z
          ],
          rot: [
            MathUtil.radianToDegree(eulerAngles.x),
            MathUtil.radianToDegree(eulerAngles.y),
            MathUtil.radianToDegree(eulerAngles.z)
          ],
          move: prop.move,
          density: prop.density,
          friction: prop.friction,
          restitution: prop.restitution
        };
        this.__body = world.add(this.__property);
      }
      setScale(scale) {
        const world = _OimoPhysicsStrategy.__world;
        if (this.__entity === void 0) {
          return;
        }
        const pos = this.__body.getPosition();
        this.__body.remove();
        const prop = this.__property;
        this.__property = {
          type: prop.type,
          size: [
            this.__localScale.x * scale.x,
            this.__localScale.y * scale.y,
            this.__localScale.z * scale.z
          ],
          pos: [
            pos.x,
            pos.y,
            pos.z
          ],
          rot: [
            this.__entity.eulerAngles.x,
            this.__entity.eulerAngles.y,
            this.__entity.eulerAngles.z
          ],
          move: prop.move,
          density: prop.density,
          friction: prop.friction,
          restitution: prop.restitution
        };
        this.__body = world.add(this.__property);
      }
      static update() {
        if (Is.exist(_OimoPhysicsStrategy.__world)) {
          _OimoPhysicsStrategy.__world.step();
        }
      }
    };
    __name(_OimoPhysicsStrategy, "OimoPhysicsStrategy");
    __publicField(_OimoPhysicsStrategy, "__worldProperty", {
      gravity: Vector3.fromCopy3(0, -9.8, 0),
      random: true
    });
    __publicField(_OimoPhysicsStrategy, "__world");
    OimoPhysicsStrategy = _OimoPhysicsStrategy;
  }
});

// src/foundation/components/SceneGraph/SceneGraphComponent.ts
var _SceneGraphComponent, SceneGraphComponent;
var init_SceneGraphComponent = __esm({
  "src/foundation/components/SceneGraph/SceneGraphComponent.ts"() {
    "use strict";
    init_Component();
    init_Matrix44();
    init_EntityRepository();
    init_ComponentType();
    init_WellKnownComponentTIDs();
    init_BufferUse();
    init_ProcessStage();
    init_MutableMatrix44();
    init_MutableMatrix33();
    init_Vector3();
    init_AABB();
    init_MutableVector3();
    init_AABBGizmo();
    init_LocatorGizmo();
    init_Is();
    init_TranslationGizmo();
    init_ScaleGizmo();
    init_OimoPhysicsStrategy();
    init_TransformComponent();
    init_SceneGraphOps();
    init_MutableScalar();
    init_MutableQuaternion();
    init_Quaternion();
    _SceneGraphComponent = class _SceneGraphComponent extends Component {
      constructor(entityUid, componentSid, entityRepository, isReUse) {
        super(entityUid, componentSid, entityRepository, isReUse);
        __publicField(this, "__parent");
        __publicField(this, "__children", []);
        __publicField(this, "__gizmoChildren", []);
        __publicField(this, "_worldMatrix", MutableMatrix44.dummy());
        __publicField(this, "_worldMatrixRest", MutableMatrix44.identity());
        __publicField(this, "_normalMatrix", MutableMatrix33.dummy());
        __publicField(this, "__isWorldMatrixUpToDate", false);
        __publicField(this, "__isWorldMatrixRestUpToDate", false);
        __publicField(this, "__isNormalMatrixUpToDate", false);
        __publicField(this, "__worldMergedAABBWithSkeletal", new AABB());
        __publicField(this, "__worldMergedAABB", new AABB());
        __publicField(this, "__isWorldAABBDirty", true);
        __publicField(this, "_isVisible", MutableScalar.dummy());
        __publicField(this, "_isBillboard", MutableScalar.dummy());
        __publicField(this, "__aabbGizmo");
        __publicField(this, "__locatorGizmo");
        __publicField(this, "__translationGizmo");
        __publicField(this, "__scaleGizmo");
        __publicField(this, "__transformGizmoSpace", "world");
        __publicField(this, "__latestPrimitivePositionAccessorVersion", 0);
        __publicField(this, "toMakeWorldMatrixTheSameAsLocalMatrix", false);
        // Skeletal
        __publicField(this, "isRootJoint", false);
        __publicField(this, "jointIndex", -1);
        __publicField(this, "_isCulled", false);
        __publicField(this, "__lastTransformComponentsUpdateCount", -1);
        _SceneGraphComponent.__sceneGraphs.push(new WeakRef(this));
        this.registerMember(BufferUse.GPUInstanceData, "worldMatrix", MutableMatrix44, ComponentType.Float, [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
        this.registerMember(BufferUse.GPUInstanceData, "normalMatrix", MutableMatrix33, ComponentType.Float, [
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
        this.registerMember(BufferUse.GPUInstanceData, "isVisible", MutableScalar, ComponentType.Float, [
          1
        ]);
        this.registerMember(BufferUse.GPUInstanceData, "isBillboard", MutableScalar, ComponentType.Float, [
          0
        ]);
        this.submitToAllocation(this.maxNumberOfComponent, isReUse);
      }
      set isVisible(flg) {
        this._isVisible.setValue(flg ? 1 : 0);
        _SceneGraphComponent.__updateCount++;
      }
      get isVisible() {
        return this._isVisible.getValue() === 1 ? true : false;
      }
      static get updateCount() {
        return _SceneGraphComponent.__updateCount;
      }
      setVisibilityRecursively(flag) {
        this.isVisible = flag;
        for (const child of this.__children) {
          child.setVisibilityRecursively(flag);
        }
      }
      set isBillboard(flg) {
        this._isBillboard.setValue(flg ? 1 : 0);
      }
      get isBillboard() {
        return this._isBillboard.getValue() === 1 ? true : false;
      }
      setIsBillboardRecursively(flg) {
        this._isBillboard.setValue(flg ? 1 : 0);
        for (const child of this.__children) {
          child.isBillboard = flg;
        }
      }
      set isAABBGizmoVisible(flg) {
        if (flg) {
          if (Is.not.defined(this.__aabbGizmo)) {
            this.__aabbGizmo = new AABBGizmo(this.entity);
            this.__aabbGizmo._setup();
          }
          this.__aabbGizmo.isVisible = true;
        } else {
          if (Is.exist(this.__aabbGizmo)) {
            this.__aabbGizmo.isVisible = false;
          }
        }
      }
      get isAABBGizmoVisible() {
        if (Is.exist(this.__aabbGizmo)) {
          return this.__aabbGizmo.isVisible;
        } else {
          return false;
        }
      }
      set isLocatorGizmoVisible(flg) {
        if (flg) {
          if (Is.not.defined(this.__locatorGizmo)) {
            this.__locatorGizmo = new LocatorGizmo(this.entity);
            this.__locatorGizmo._setup();
          }
          this.__locatorGizmo.isVisible = true;
        } else {
          if (Is.exist(this.__locatorGizmo)) {
            this.__locatorGizmo.isVisible = false;
          }
        }
      }
      get isLocatorGizmoVisible() {
        if (Is.exist(this.__locatorGizmo)) {
          return this.__locatorGizmo.isVisible;
        } else {
          return false;
        }
      }
      set isTranslationGizmoVisible(flg) {
        if (flg) {
          if (Is.not.defined(this.__translationGizmo)) {
            this.__translationGizmo = new TranslationGizmo(this.entity);
            this.__translationGizmo._setup();
          }
          this.__translationGizmo.isVisible = true;
        } else {
          if (Is.exist(this.__translationGizmo)) {
            this.__translationGizmo.isVisible = false;
          }
        }
      }
      get isTranslationGizmoVisible() {
        if (Is.exist(this.__translationGizmo)) {
          return this.__translationGizmo.isVisible;
        } else {
          return false;
        }
      }
      set isScaleGizmoVisible(flg) {
        if (flg) {
          if (Is.not.defined(this.__scaleGizmo)) {
            this.__scaleGizmo = new ScaleGizmo(this.entity);
            this.__scaleGizmo._setup();
          }
          this.__scaleGizmo.isVisible = true;
        } else {
          if (Is.exist(this.__scaleGizmo)) {
            this.__scaleGizmo.isVisible = false;
          }
        }
      }
      get isScaleGizmoVisible() {
        if (Is.exist(this.__scaleGizmo)) {
          return this.__scaleGizmo.isVisible;
        } else {
          return false;
        }
      }
      static getTopLevelComponents() {
        return _SceneGraphComponent.__sceneGraphs.map((sgRef) => sgRef.deref()).filter((sg) => {
          if (sg !== void 0) {
            return sg.isTopLevel;
          } else {
            return false;
          }
        }).filter((sg) => sg !== void 0);
      }
      isJoint() {
        if (this.jointIndex >= 0) {
          return true;
        } else {
          return false;
        }
      }
      static get componentTID() {
        return WellKnownComponentTIDs.SceneGraphComponentTID;
      }
      get componentTID() {
        return WellKnownComponentTIDs.SceneGraphComponentTID;
      }
      setWorldMatrixRestDirty() {
        this.matrixRestInner;
        this.setWorldMatrixRestDirtyRecursively();
      }
      setWorldMatrixRestDirtyRecursively() {
        this.__isWorldMatrixRestUpToDate = false;
        this.children.forEach((child) => {
          child.setWorldMatrixRestDirtyRecursively();
        });
      }
      setWorldMatrixDirty() {
        var _a40;
        this.setWorldMatrixDirtyRecursively();
        (_a40 = this.parent) == null ? void 0 : _a40.setWorldAABBDirtyParentRecursively();
      }
      setWorldMatrixDirtyRecursively() {
        this.__isWorldMatrixUpToDate = false;
        this.__isNormalMatrixUpToDate = false;
        this.__isWorldAABBDirty = true;
        this.children.forEach((child) => {
          child.setWorldMatrixDirtyRecursively();
        });
      }
      setWorldAABBDirtyParentRecursively() {
        var _a40;
        this.__isWorldAABBDirty = true;
        (_a40 = this.parent) == null ? void 0 : _a40.setWorldAABBDirtyParentRecursively();
      }
      /**
      * add a SceneGraph component as a child of this
      * @param sg a SceneGraph component
      */
      addChild(sg) {
        if (Is.exist(sg.__parent)) {
          sg.__parent.removeChild(sg);
        }
        sg.__parent = this;
        this.__children.push(sg);
      }
      /**
      * remove the child SceneGraph component from this
      * @param sg a SceneGraph component
      */
      removeChild(sg) {
        const index = this.__children.indexOf(sg);
        if (index >= 0) {
          this.__children.splice(index, 1);
        }
        sg.__parent = void 0;
      }
      /**
      * add a SceneGraph component as a child of this (But Gizmo only)
      * @param sg a SceneGraph component of Gizmo
      */
      _addGizmoChild(sg) {
        sg.__parent = this;
        this.__gizmoChildren.push(sg);
      }
      get isTopLevel() {
        return this.__parent == null;
      }
      get children() {
        return this.__children;
      }
      get parent() {
        return this.__parent;
      }
      get matrixInner() {
        if (!this.__isWorldMatrixUpToDate) {
          this._worldMatrix.copyComponents(this.__calcWorldMatrixRecursively());
          this.__isWorldMatrixUpToDate = true;
        }
        return this._worldMatrix;
      }
      get matrix() {
        return this.matrixInner.clone();
      }
      get matrixRestInner() {
        if (!this.__isWorldMatrixRestUpToDate) {
          this._worldMatrixRest.copyComponents(this.__calcWorldMatrixRestRecursively());
          this.__isWorldMatrixRestUpToDate = true;
        }
        return this._worldMatrixRest;
      }
      get matrixRest() {
        return this.matrixRestInner.clone();
      }
      get normalMatrixInner() {
        if (!this.__isNormalMatrixUpToDate) {
          Matrix44.invertTo(this.matrixInner, _SceneGraphComponent.invertedMatrix44);
          this._normalMatrix.copyComponents(_SceneGraphComponent.invertedMatrix44.transpose());
          this.__isNormalMatrixUpToDate = true;
        }
        return this._normalMatrix;
      }
      get entityWorldWithSkeletalMatrix() {
        return this.entityWorldMatrixWithSkeletalInner.clone();
      }
      get entityWorldMatrixWithSkeletalInner() {
        const skeletalComponent = this.entity.tryToGetSkeletal();
        if (Is.exist(skeletalComponent) && skeletalComponent.isWorldMatrixUpdated) {
          return skeletalComponent.worldMatrixInner;
        } else {
          const sceneGraphComponent = this.entity.getSceneGraph();
          return sceneGraphComponent.matrixInner;
        }
      }
      get normalMatrix() {
        return this.normalMatrixInner.clone();
      }
      isWorldMatrixUpToDateRecursively() {
        if (this.__isWorldMatrixUpToDate) {
          if (this.__parent) {
            const result = this.__parent.isWorldMatrixUpToDateRecursively();
            return result;
          } else {
            return true;
          }
        }
        return false;
      }
      __calcWorldMatrixRecursively() {
        if (this.__isWorldMatrixUpToDate) {
          return this._worldMatrix;
        }
        const transform = this.entity.getTransform();
        if (this.__parent == null || this.toMakeWorldMatrixTheSameAsLocalMatrix) {
          transform.getLocalMatrixInnerTo(_SceneGraphComponent.__tmp_mat4_2);
          return _SceneGraphComponent.__tmp_mat4_2;
        }
        const matrixFromAncestorToParent = this.__parent.__calcWorldMatrixRecursively();
        transform.getLocalMatrixInnerTo(_SceneGraphComponent.__tmp_mat4_3);
        return MutableMatrix44.multiplyTo(matrixFromAncestorToParent, _SceneGraphComponent.__tmp_mat4_3, _SceneGraphComponent.__tmp_mat4);
      }
      __calcWorldMatrixRestRecursively() {
        if (this.__isWorldMatrixRestUpToDate) {
          return this._worldMatrixRest;
        }
        const transform = this.entity.getTransform();
        if (this.__parent == null || this.toMakeWorldMatrixTheSameAsLocalMatrix) {
          transform.getLocalMatrixInnerTo(_SceneGraphComponent.__tmp_mat4_2);
          return _SceneGraphComponent.__tmp_mat4_2;
        }
        const matrixFromAncestorToParent = this.__parent.__calcWorldMatrixRestRecursively();
        transform.getLocalMatrixInnerTo(_SceneGraphComponent.__tmp_mat4_3);
        return MutableMatrix44.multiplyTo(matrixFromAncestorToParent, _SceneGraphComponent.__tmp_mat4_3, _SceneGraphComponent.__tmp_mat4);
      }
      getQuaternionRecursively() {
        if (Is.not.exist(this.parent)) {
          return this.entity.getTransform().localRotation;
        }
        const matrixFromAncestorToParent = this.parent.getQuaternionRecursively();
        return Quaternion.multiply(matrixFromAncestorToParent, this.entity.getTransform().localRotation);
      }
      get worldPosition() {
        const zeroVector = _SceneGraphComponent.__originVector3;
        this.matrixInner.multiplyVector3To(zeroVector, _SceneGraphComponent.returnVector3);
        return _SceneGraphComponent.returnVector3;
      }
      getWorldPositionOf(localPosition) {
        return this.matrixInner.multiplyVector3(localPosition);
      }
      getWorldPositionOfTo(localPosition, out) {
        return this.matrixInner.multiplyVector3To(localPosition, out);
      }
      getLocalPositionOf(worldPosition) {
        return Matrix44.invert(this.matrixInner).multiplyVector3(worldPosition);
      }
      getLocalPositionOfTo(worldPosition, out) {
        return Matrix44.invertTo(this.matrixInner, _SceneGraphComponent.__tmp_mat4).multiplyVector3To(worldPosition, out);
      }
      getWorldAABB() {
        const aabb = new AABB();
        const meshComponent = this.entity.tryToGetMesh();
        if (Is.exist(meshComponent) && Is.exist(meshComponent.mesh)) {
          aabb.mergeAABB(meshComponent.mesh.AABB);
          AABB.multiplyMatrixTo(this.entity.getSceneGraph().matrixInner, aabb, _SceneGraphComponent.__tmpAABB);
        } else {
          _SceneGraphComponent.__tmpAABB.initialize();
        }
        return _SceneGraphComponent.__tmpAABB;
      }
      calcWorldMergedAABB() {
        const aabb = this.getWorldAABB().clone();
        for (const child of this.children) {
          const childAABB = child.calcWorldMergedAABB();
          aabb.mergeAABB(childAABB);
        }
        this.__worldMergedAABB = aabb;
        return aabb;
      }
      get worldMergedAABB() {
        if (this.__isWorldAABBDirty) {
          this.calcWorldMergedAABB();
          this.__isWorldAABBDirty = false;
        }
        return this.__worldMergedAABB;
      }
      getWorldAABBWithSkeletal() {
        const aabb = new AABB();
        const meshComponent = this.entity.tryToGetMesh();
        if (Is.exist(meshComponent) && Is.exist(meshComponent.mesh)) {
          aabb.mergeAABB(meshComponent.mesh.AABB);
          AABB.multiplyMatrixTo(this.entity.getSceneGraph().entityWorldMatrixWithSkeletalInner, aabb, _SceneGraphComponent.__tmpAABB);
        } else {
          _SceneGraphComponent.__tmpAABB.initialize();
        }
        return _SceneGraphComponent.__tmpAABB;
      }
      calcWorldMergedAABBWithSkeletal() {
        const aabb = this.getWorldAABBWithSkeletal().clone();
        for (const child of this.children) {
          const childAABB = child.calcWorldMergedAABBWithSkeletal();
          aabb.mergeAABB(childAABB);
        }
        this.__worldMergedAABBWithSkeletal = aabb;
        return aabb;
      }
      get worldMergedAABBWithSkeletal() {
        if (this.__isWorldAABBDirty) {
          this.calcWorldMergedAABBWithSkeletal();
          this.__isWorldAABBDirty = false;
        }
        return this.__worldMergedAABBWithSkeletal;
      }
      /**
      * castRay Methods
      *
      * @param srcPointInWorld a source position in world space
      * @param directionInWorld a direction vector in world space
      * @param dotThreshold threshold of the intersected triangle and the ray
      * @param ignoreMeshComponents mesh components to ignore
      * @returns information of intersection in world space
      */
      castRay(srcPointInWorld, directionInWorld, dotThreshold = 0, ignoreMeshComponents = []) {
        const collectedSgComponents = flattenHierarchy(this, false);
        const meshComponents = [];
        for (const sg of collectedSgComponents) {
          const mesh = sg.entity.tryToGetMesh();
          if (mesh) {
            meshComponents.push(mesh);
          }
        }
        let rayDistance = Number.MAX_VALUE;
        let intersectedPosition = void 0;
        let selectedMeshComponent = void 0;
        let u = 0;
        let v = 0;
        for (const meshComponent of meshComponents) {
          if (!meshComponent.entity.getSceneGraph().isVisible) {
            continue;
          }
          if (!meshComponent.isPickable) {
            continue;
          }
          if (ignoreMeshComponents.indexOf(meshComponent) !== -1) {
            continue;
          }
          const result = meshComponent.castRay(srcPointInWorld, directionInWorld, dotThreshold);
          if (Is.defined(result.data) && result.data.t < rayDistance) {
            rayDistance = result.data.t;
            intersectedPosition = result.data.position;
            selectedMeshComponent = meshComponent;
            u = result.data.u;
            v = result.data.v;
          }
        }
        if (Is.exist(selectedMeshComponent) && Is.exist(intersectedPosition)) {
          return {
            result: true,
            data: {
              t: rayDistance,
              u,
              v,
              position: intersectedPosition,
              selectedMeshComponent
            }
          };
        } else {
          return {
            result: false
          };
        }
      }
      /**
      * castRayFromScreen Methods
      *
      * @param x x position of screen
      * @param y y position of screen
      * @param camera a camera component
      * @param viewport a viewport vector4
      * @param dotThreshold threshold of the intersected triangle and the ray
      * @param ignoreMeshComponents mesh components to ignore
      * @returns information of intersection in world space
      */
      castRayFromScreen(x, y, camera, viewport, dotThreshold = 0, ignoreMeshComponents = []) {
        const collectedSgComponents = flattenHierarchy(this, false);
        const meshComponents = [];
        for (const sg of collectedSgComponents) {
          const mesh = sg.entity.tryToGetMesh();
          if (mesh) {
            meshComponents.push(mesh);
          }
        }
        let rayDistance = Number.MAX_VALUE;
        let intersectedPosition = void 0;
        let selectedMeshComponent = void 0;
        let u = 0;
        let v = 0;
        for (const meshComponent of meshComponents) {
          if (!meshComponent.entity.getSceneGraph().isVisible) {
            continue;
          }
          if (!meshComponent.isPickable) {
            continue;
          }
          if (ignoreMeshComponents.indexOf(meshComponent) !== -1) {
            continue;
          }
          const result = meshComponent.castRayFromScreenInWorld(x, y, camera, viewport, dotThreshold);
          if (Is.defined(result.data) && result.data.t < rayDistance) {
            rayDistance = result.data.t;
            intersectedPosition = result.data.position;
            selectedMeshComponent = meshComponent;
            u = result.data.u;
            v = result.data.v;
          }
        }
        if (Is.exist(selectedMeshComponent) && Is.exist(intersectedPosition)) {
          return {
            result: true,
            data: {
              t: rayDistance,
              u,
              v,
              position: intersectedPosition,
              selectedMeshComponent
            }
          };
        } else {
          return {
            result: false
          };
        }
      }
      $load() {
        this.moveStageTo(ProcessStage.Logic);
      }
      $logic() {
        if (this.__lastTransformComponentsUpdateCount === TransformComponent.updateCount) {
          return;
        }
        this.matrixInner;
        this.normalMatrixInner;
        this.__updateGizmos();
        this.__lastTransformComponentsUpdateCount = TransformComponent.updateCount;
      }
      __updateGizmos() {
        if (Is.exist(this.__aabbGizmo) && this.__aabbGizmo.isSetup && this.__aabbGizmo.isVisible) {
          this.__aabbGizmo._update();
        }
        if (Is.exist(this.__locatorGizmo) && this.__locatorGizmo.isSetup && this.__locatorGizmo.isVisible) {
          this.__locatorGizmo._update();
        }
        if (Is.exist(this.__translationGizmo) && this.__translationGizmo.isSetup && this.__translationGizmo.isVisible) {
          this.__translationGizmo._update();
        }
        if (Is.exist(this.__scaleGizmo) && this.__scaleGizmo.isSetup && this.__scaleGizmo.isVisible) {
          this.__scaleGizmo._update();
        }
      }
      setPositionWithoutPhysics(vec) {
        if (Is.not.exist(this.__parent)) {
          this.entity.getTransform().localPosition = vec;
        } else {
          MutableMatrix44.invertTo(this.__parent.entity.getSceneGraph().matrixInner, _SceneGraphComponent.__tmp_mat4);
          this.entity.getTransform().localPosition = _SceneGraphComponent.__tmp_mat4.multiplyVector3(vec);
        }
      }
      set position(vec) {
        this.setPositionWithoutPhysics(vec);
        const physicsComponent = this.entity.tryToGetPhysics();
        if (physicsComponent !== void 0) {
          if (physicsComponent.strategy !== void 0) {
            if (physicsComponent.strategy instanceof OimoPhysicsStrategy) {
              const sceneGraphComponent = this.entity.tryToGetSceneGraph();
              if (sceneGraphComponent !== void 0) {
                physicsComponent.strategy.setPosition(vec);
              }
            }
          }
        }
      }
      get position() {
        return this.matrixInner.getTranslate();
      }
      getPositionTo(outVec) {
        return this.matrixInner.getTranslateTo(outVec);
      }
      get positionRest() {
        return this.matrixRestInner.getTranslate();
      }
      getPositionRestTo(outVec) {
        return this.matrixRestInner.getTranslateTo(outVec);
      }
      set eulerAngles(vec) {
        if (Is.not.exist(this.__parent)) {
          this.entity.getTransform().localEulerAngles = vec;
        } else {
          const quat = Quaternion.fromMatrix(this.__parent.entity.getSceneGraph().matrixInner);
          const invQuat = Quaternion.invert(quat);
          const rotation = Quaternion.fromMatrix(Matrix44.rotate(vec));
          const result = Quaternion.multiply(rotation, invQuat);
          this.entity.getTransform().localEulerAngles = result.toEulerAngles();
        }
        const physicsComponent = this.entity.tryToGetPhysics();
        if (physicsComponent !== void 0) {
          if (physicsComponent.strategy !== void 0) {
            if (physicsComponent.strategy instanceof OimoPhysicsStrategy) {
              const sceneGraphComponent = this.entity.tryToGetSceneGraph();
              if (sceneGraphComponent !== void 0) {
                physicsComponent.strategy.setEulerAngle(vec);
              }
            }
          }
        }
      }
      get eulerAngles() {
        return this.matrixInner.toEulerAngles();
      }
      setRotationWithoutPhysics(quat) {
        if (Is.not.exist(this.__parent)) {
          this.entity.getTransform().localRotation = quat;
        } else {
          const quatInner = this.__parent.entity.getSceneGraph().rotation;
          const invQuat = Quaternion.invert(quatInner);
          this.entity.getTransform().localRotation = Quaternion.multiply(quat, invQuat);
        }
      }
      set rotation(quat) {
        this.setRotationWithoutPhysics(quat);
        const physicsComponent = this.entity.tryToGetPhysics();
        if (physicsComponent !== void 0) {
          if (physicsComponent.strategy !== void 0) {
            if (physicsComponent.strategy instanceof OimoPhysicsStrategy) {
              const sceneGraphComponent = this.entity.tryToGetSceneGraph();
              if (sceneGraphComponent !== void 0) {
                physicsComponent.strategy.setEulerAngle(quat.toEulerAngles());
              }
            }
          }
        }
      }
      get rotation() {
        const parent = this.parent;
        if (parent != null) {
          return Quaternion.multiply(parent.rotation, this.entity.getTransform().localRotationInner);
        }
        return this.entity.getTransform().localRotationInner;
      }
      getRotationTo(outQuat) {
        const parent = this.parent;
        if (parent != null) {
          return Quaternion.multiplyTo(parent.getRotationTo(_SceneGraphComponent.__tmp_quat_0), this.entity.getTransform().localRotationInner, outQuat);
        }
        const quat = this.entity.getTransform().localRotationInner;
        outQuat.setComponents(quat._v[0], quat._v[1], quat._v[2], quat._v[3]);
        return outQuat;
      }
      get rotationRest() {
        const parent = this.parent;
        if (parent != null) {
          return Quaternion.multiply(parent.rotationRest, this.entity.getTransform().localRotationRestInner);
        }
        return this.entity.getTransform().localRotationRestInner;
      }
      getRotationRest(endFn) {
        const parent = this.parent;
        const IsEnd = endFn(this);
        if (parent != null && !IsEnd) {
          return Quaternion.multiply(parent.getRotationRest(endFn), this.entity.getTransform().localRotationRestInner);
        }
        return this.entity.getTransform().localRotationRestInner;
      }
      set scale(vec) {
        if (Is.not.exist(this.__parent)) {
          this.entity.getTransform().localScale = vec;
        } else {
          const mat = this.__parent.entity.getSceneGraph().matrix;
          mat._v[12] = 0;
          mat._v[13] = 0;
          mat._v[14] = 0;
          const invMat = MutableMatrix44.invert(mat);
          this.entity.getTransform().localScale = invMat.multiplyVector3(vec);
        }
        const physicsComponent = this.entity.tryToGetPhysics();
        if (physicsComponent !== void 0) {
          if (physicsComponent.strategy !== void 0) {
            if (physicsComponent.strategy instanceof OimoPhysicsStrategy) {
              const sceneGraphComponent = this.entity.tryToGetSceneGraph();
              if (sceneGraphComponent !== void 0) {
                physicsComponent.strategy.setScale(vec);
              }
            }
          }
        }
      }
      get scale() {
        return this.matrixInner.getScale();
      }
      __copyChild(child) {
        const newChild = EntityRepository._shallowCopyEntityInner(child.entity);
        newChild.getSceneGraph().__parent = this;
        return newChild;
      }
      _shallowCopyFrom(component_) {
        const component = component_;
        this.__parent = component.__parent;
        this.__children = [];
        for (let i2 = 0; i2 < component.__children.length; i2++) {
          const copyChild = this.__copyChild(component.__children[i2]).getSceneGraph();
          this.__children.push(copyChild);
        }
        this.__gizmoChildren = component.__gizmoChildren.concat();
        this._worldMatrix.copyComponents(component._worldMatrix);
        this._worldMatrixRest.copyComponents(component._worldMatrixRest);
        this._normalMatrix.copyComponents(component._normalMatrix);
        this.__isWorldMatrixUpToDate = false;
        this.__isWorldMatrixRestUpToDate = false;
        this.__isNormalMatrixUpToDate = false;
        this.__worldMergedAABBWithSkeletal = component.__worldMergedAABBWithSkeletal.clone();
        this.__isWorldAABBDirty = true;
        this._isVisible.copyComponents(component._isVisible);
        this._isBillboard.copyComponents(component._isBillboard);
        this.__transformGizmoSpace = component.__transformGizmoSpace;
        this.__latestPrimitivePositionAccessorVersion = component.__latestPrimitivePositionAccessorVersion;
        this.toMakeWorldMatrixTheSameAsLocalMatrix = component.toMakeWorldMatrixTheSameAsLocalMatrix;
        this.isRootJoint = component.isRootJoint;
        this.jointIndex = component.jointIndex;
      }
      /**
      * get the entity which has this component.
      * @returns the entity which has this component
      */
      get entity() {
        return EntityRepository.getEntity(this.__entityUid);
      }
      setTransformGizmoSpace(space) {
        var _a40, _b;
        this.__transformGizmoSpace = space;
        (_a40 = this.__translationGizmo) == null ? void 0 : _a40.setSpace(space);
        (_b = this.__scaleGizmo) == null ? void 0 : _b.setSpace(space);
      }
      _destroy() {
        var _a40, _b, _c, _d, _e;
        super._destroy();
        (_a40 = this.__aabbGizmo) == null ? void 0 : _a40._destroy();
        (_b = this.__locatorGizmo) == null ? void 0 : _b._destroy();
        (_c = this.__translationGizmo) == null ? void 0 : _c._destroy();
        (_d = this.__scaleGizmo) == null ? void 0 : _d._destroy();
        (_e = this.parent) == null ? void 0 : _e.removeChild(this);
        this.children.forEach((child) => {
          var _a41;
          return (_a41 = child.parent) == null ? void 0 : _a41.removeChild(child);
        });
      }
      /**
      * @override
      * Add this component to the entity
      * @param base the target entity
      * @param _componentClass the component class to add
      */
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let SceneGraphEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
            __publicField(this, "__sceneGraphcomponent");
          }
          getSceneGraph() {
            if (this.__sceneGraphComponent === void 0) {
              this.__sceneGraphComponent = this.getComponentByComponentTID(WellKnownComponentTIDs.SceneGraphComponentTID);
            }
            return this.__sceneGraphComponent;
          }
          get parent() {
            return this.getSceneGraph().parent;
          }
          get matrix() {
            const sceneGraph = this.getSceneGraph();
            return sceneGraph.matrix;
          }
          get matrixInner() {
            const sceneGraph = this.getSceneGraph();
            return sceneGraph.matrixInner;
          }
          get position() {
            const sceneGraph = this.getSceneGraph();
            return sceneGraph.position;
          }
          set position(vec) {
            const sceneGraph = this.getSceneGraph();
            sceneGraph.position = vec;
          }
          get positionRest() {
            const sceneGraph = this.getSceneGraph();
            return sceneGraph.positionRest;
          }
          get scale() {
            const sceneGraph = this.getSceneGraph();
            return sceneGraph.scale;
          }
          set scale(vec) {
            const sceneGraph = this.getSceneGraph();
            sceneGraph.scale = vec;
          }
          get eulerAngles() {
            const sceneGraph = this.getSceneGraph();
            return sceneGraph.eulerAngles;
          }
          set eulerAngles(vec) {
            const sceneGraph = this.getSceneGraph();
            sceneGraph.eulerAngles = vec;
          }
          get rotation() {
            const sceneGraph = this.getSceneGraph();
            return sceneGraph.rotation;
          }
          set rotation(quat) {
            const sceneGraph = this.getSceneGraph();
            sceneGraph.rotation = quat;
          }
          get rotationRest() {
            const sceneGraph = this.getSceneGraph();
            return sceneGraph.rotationRest;
          }
          addChild(sg) {
            const sceneGraph = this.getSceneGraph();
            sceneGraph.addChild(sg);
          }
          get children() {
            const sceneGraph = this.getSceneGraph();
            return sceneGraph.children;
          }
          removeChild(sg) {
            const sceneGraph = this.getSceneGraph();
            sceneGraph.removeChild(sg);
          }
        }, __name(_a40, "SceneGraphEntity"), _a40);
        applyMixins(base, SceneGraphEntity);
        return base;
      }
    };
    __name(_SceneGraphComponent, "SceneGraphComponent");
    __publicField(_SceneGraphComponent, "__originVector3", Vector3.zero());
    __publicField(_SceneGraphComponent, "returnVector3", MutableVector3.zero());
    __publicField(_SceneGraphComponent, "__sceneGraphs", []);
    __publicField(_SceneGraphComponent, "isJointAABBShouldBeCalculated", false);
    __publicField(_SceneGraphComponent, "invertedMatrix44", MutableMatrix44.fromCopyArray16ColumnMajor([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]));
    __publicField(_SceneGraphComponent, "__tmp_mat4", MutableMatrix44.identity());
    __publicField(_SceneGraphComponent, "__tmp_mat4_2", MutableMatrix44.identity());
    __publicField(_SceneGraphComponent, "__tmp_mat4_3", MutableMatrix44.identity());
    __publicField(_SceneGraphComponent, "__tmp_quat_0", MutableQuaternion.identity());
    __publicField(_SceneGraphComponent, "__tmp_quat_1", MutableQuaternion.identity());
    __publicField(_SceneGraphComponent, "__updateCount", -1);
    __publicField(_SceneGraphComponent, "__tmpAABB", new AABB());
    SceneGraphComponent = _SceneGraphComponent;
  }
});

// src/foundation/textures/RenderTargetTextureCube.ts
var _RenderTargetTextureCube, RenderTargetTextureCube;
var init_RenderTargetTextureCube = __esm({
  "src/foundation/textures/RenderTargetTextureCube.ts"() {
    "use strict";
    init_HdriFormat();
    init_ProcessApproach();
    init_TextureFormat();
    init_CGAPIResourceRepository();
    init_SystemState();
    init_AbstractTexture();
    _RenderTargetTextureCube = class _RenderTargetTextureCube extends AbstractTexture {
      constructor() {
        super();
        __publicField(this, "__fbo");
        __publicField(this, "hdriFormat", HdriFormat.HDR_LINEAR);
        __publicField(this, "_textureViewAsRenderTargetResourceUid", -1);
      }
      create({ width, height, mipLevelCount, format: internalFormat }) {
        this.__width = width;
        this.__height = height;
        this.__mipLevelCount = mipLevelCount != null ? mipLevelCount : Math.floor(Math.log2(Math.max(width, height))) + 1;
        const { format, type } = TextureFormat.getPixelFormatAndComponentTypeFromTextureFormat(internalFormat);
        this.__internalFormat = internalFormat;
        this.__format = format;
        this.__type = type;
        this.__createRenderTargetTexture();
      }
      __createRenderTargetTexture() {
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        const texture = cgApiResourceRepository.createRenderTargetTextureCube({
          width: this.__width,
          height: this.__height,
          mipLevelCount: this.__mipLevelCount,
          format: this.__internalFormat
        });
        this._textureResourceUid = texture;
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          this._textureViewResourceUid = cgApiResourceRepository.createTextureViewCube(this._textureResourceUid);
          this._textureViewAsRenderTargetResourceUid = cgApiResourceRepository.createCubeTextureViewAsRenderTarget(this._textureResourceUid, 0, 0);
        }
      }
      generateMipmaps() {
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        cgApiResourceRepository.generateMipmapsCube(this._textureResourceUid, this.width, this.height);
      }
      resize(width, height) {
        this.destroy3DAPIResources();
        this.__width = width;
        this.__height = height;
        this.__createRenderTargetTexture();
      }
      destroy3DAPIResources() {
        const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        cgApiResourceRepository.deleteTexture(this._textureResourceUid);
        this._textureResourceUid = CGAPIResourceRepository.InvalidCGAPIResourceUid;
        return true;
      }
      createCubeTextureViewAsRenderTarget(faceIdx, mipLevel) {
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          const webGpuResourceRepository = CGAPIResourceRepository.getWebGpuResourceRepository();
          this._textureViewAsRenderTargetResourceUid = webGpuResourceRepository.createCubeTextureViewAsRenderTarget(this._textureResourceUid, faceIdx, mipLevel);
        }
      }
      set _fbo(fbo) {
        this.__fbo = fbo;
      }
      get fbo() {
        return this.__fbo;
      }
      get mipmapLevelNumber() {
        return this.__mipLevelCount;
      }
      setIsTextureReady() {
        this.__isTextureReady = true;
      }
    };
    __name(_RenderTargetTextureCube, "RenderTargetTextureCube");
    RenderTargetTextureCube = _RenderTargetTextureCube;
  }
});

// src/foundation/components/MeshRenderer/MeshRendererComponent.ts
var _MeshRendererComponent, MeshRendererComponent;
var init_MeshRendererComponent = __esm({
  "src/foundation/components/MeshRenderer/MeshRendererComponent.ts"() {
    "use strict";
    init_ComponentRepository();
    init_Component();
    init_ProcessApproach();
    init_ProcessStage();
    init_EntityRepository();
    init_WellKnownComponentTIDs();
    init_CameraComponent();
    init_ModuleManager();
    init_GeometryTypes();
    init_TransformComponent();
    init_CameraControllerComponent();
    init_SceneGraphComponent();
    init_SystemState();
    init_RenderTargetTextureCube();
    _MeshRendererComponent = class _MeshRendererComponent extends Component {
      constructor(entityUid, componentSid, entityRepository, isReUse) {
        super(entityUid, componentSid, entityRepository, isReUse);
        __publicField(this, "__diffuseCubeMap");
        __publicField(this, "__specularCubeMap");
        __publicField(this, "__diffuseCubeMapContribution", 1);
        __publicField(this, "__specularCubeMapContribution", 1);
        __publicField(this, "__rotationOfCubeMap", 0);
        __publicField(this, "__updateCount", 0);
      }
      static get componentTID() {
        return WellKnownComponentTIDs.MeshRendererComponentTID;
      }
      get componentTID() {
        return WellKnownComponentTIDs.MeshRendererComponentTID;
      }
      get diffuseCubeMap() {
        return this.__diffuseCubeMap;
      }
      get specularCubeMap() {
        return this.__specularCubeMap;
      }
      get updateCount() {
        return this.__updateCount;
      }
      static get updateCount() {
        return _MeshRendererComponent.__updateCount;
      }
      get diffuseCubeMapContribution() {
        return this.__diffuseCubeMapContribution;
      }
      set diffuseCubeMapContribution(contribution) {
        this.__diffuseCubeMapContribution = contribution;
        _MeshRendererComponent.__updateCount++;
      }
      get specularCubeMapContribution() {
        return this.__specularCubeMapContribution;
      }
      set specularCubeMapContribution(contribution) {
        this.__specularCubeMapContribution = contribution;
        _MeshRendererComponent.__updateCount++;
      }
      get rotationOfCubeMap() {
        return this.__rotationOfCubeMap;
      }
      set rotationOfCubeMap(rotation) {
        this.__rotationOfCubeMap = rotation;
        _MeshRendererComponent.__updateCount++;
      }
      setIBLCubeMap(diffuseCubeTexture, specularCubeTexture) {
        if (diffuseCubeTexture == null || specularCubeTexture == null) {
          return;
        }
        this.__diffuseCubeMap = diffuseCubeTexture;
        this.__specularCubeMap = specularCubeTexture;
        const promises = [];
        if (diffuseCubeTexture instanceof RenderTargetTextureCube) {
          promises.push(new Promise((resolve) => {
            diffuseCubeTexture.setIsTextureReady();
            resolve();
          }));
        } else {
          promises.push(new Promise((resolve) => {
            if (!diffuseCubeTexture.startedToLoad) {
              diffuseCubeTexture.loadTextureImagesAsync().then(() => {
                resolve();
              });
            } else if (diffuseCubeTexture.isTextureReady) {
              resolve();
            } else {
              diffuseCubeTexture.registerOnTextureLoaded(() => {
                resolve();
              });
            }
          }));
        }
        if (specularCubeTexture instanceof RenderTargetTextureCube) {
          promises.push(new Promise((resolve) => {
            specularCubeTexture.setIsTextureReady();
            resolve();
          }));
        } else {
          promises.push(new Promise((resolve) => {
            if (!specularCubeTexture.startedToLoad) {
              specularCubeTexture.loadTextureImagesAsync().then(() => {
                resolve();
              });
            } else if (specularCubeTexture.isTextureReady) {
              resolve();
            } else {
              specularCubeTexture.registerOnTextureLoaded(() => {
                resolve();
              });
            }
          }));
        }
        return Promise.all(promises).then(() => {
          this.__updateCount++;
          _MeshRendererComponent.__updateCount++;
        });
      }
      static common_$load({ processApproach }) {
        const moduleManager = ModuleManager.getInstance();
        if (processApproach === ProcessApproach.WebGPU) {
          const moduleName = "webgpu";
          const webgpuModule = moduleManager.getModule(moduleName);
          _MeshRendererComponent.__cgApiRenderingStrategy = webgpuModule.WebGpuStrategyBasic.getInstance();
          _MeshRendererComponent.__cgApiRenderingStrategy.common_$load();
        } else {
          const moduleName = "webgl";
          const webglModule = moduleManager.getModule(moduleName);
          _MeshRendererComponent.__cgApiRenderingStrategy = webglModule.getRenderingStrategy(processApproach);
        }
      }
      $load() {
        const ready = _MeshRendererComponent.__cgApiRenderingStrategy.$load(this.entity.tryToGetMesh());
        if (ready) {
          this.moveStageTo(ProcessStage.Unknown);
        }
      }
      static sort_$render(renderPass) {
        if (TransformComponent.updateCount === renderPass._lastTransformComponentsUpdateCount && CameraControllerComponent.updateCount === renderPass._lastCameraControllerComponentsUpdateCount && SceneGraphComponent.updateCount === renderPass._lastSceneGraphComponentsUpdateCount) {
          return renderPass._lastPrimitiveUids;
        }
        let cameraComponent = renderPass.cameraComponent;
        if (cameraComponent == null) {
          cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
        }
        if (cameraComponent == null) {
          const cameraComponents = ComponentRepository.getComponentsWithType(CameraComponent);
          cameraComponent = cameraComponents.find((c2) => c2 != null && c2._isAlive);
          CameraComponent.current = cameraComponent.componentSID;
        }
        if (renderPass.isVrRendering) {
          const rnXRModule = ModuleManager.getInstance().getModule("xr");
          if (rnXRModule != null) {
            const webxrSystem = rnXRModule.WebXRSystem.getInstance();
            if (webxrSystem.isWebXRMode) {
              cameraComponent = webxrSystem._getCameraComponentAt(0);
            }
          }
        }
        let primitives = [];
        const meshComponents = renderPass._optimizedMeshComponents;
        primitives = _MeshRendererComponent.__cullingWithViewFrustum(cameraComponent, meshComponents);
        primitives = Array.from(new Set(primitives));
        primitives.sort((a2, b) => {
          const delta = a2._sortkey - b._sortkey;
          if (delta !== 0) {
            return delta;
          }
          return a2._viewDepth - b._viewDepth;
        });
        const primitiveUids = primitives.map((primitive) => primitive.primitiveUid);
        primitiveUids.push(-1);
        let _lastOpaqueIndex = primitives.length - 1;
        let _lastTranslucentIndex = primitives.length - 1;
        let _lastBlendWithZWriteIndex = primitives.length - 1;
        let _lastBlendWithoutZWriteIndex = primitives.length - 1;
        for (let i2 = 0; i2 < primitives.length; i2++) {
          const primitive = primitives[i2];
          const translucency = isTranslucent(primitive);
          if (translucency) {
            _lastOpaqueIndex = i2 - 1;
            break;
          }
          const blendWithZWrite = isBlendWithZWrite(primitive);
          if (blendWithZWrite) {
            _lastOpaqueIndex = i2 - 1;
            break;
          }
          const blendWithoutZWrite = isBlendWithoutZWrite(primitive);
          if (blendWithoutZWrite) {
            _lastOpaqueIndex = i2 - 1;
            break;
          }
        }
        for (let i2 = _lastOpaqueIndex + 1; i2 < primitives.length; i2++) {
          const primitive = primitives[i2];
          const blendWithZWrite = isBlendWithZWrite(primitive);
          if (blendWithZWrite) {
            _lastTranslucentIndex = i2 - 1;
            break;
          }
          const blendWithoutZWrite = isBlendWithoutZWrite(primitive);
          if (blendWithoutZWrite) {
            _lastTranslucentIndex = i2 - 1;
            break;
          }
        }
        for (let i2 = _lastTranslucentIndex + 1; i2 < primitives.length; i2++) {
          const primitive = primitives[i2];
          const blendWithoutZWrite = isBlendWithoutZWrite(primitive);
          if (blendWithoutZWrite) {
            _lastBlendWithZWriteIndex = i2 - 1;
            break;
          }
        }
        let resultChanged = false;
        if (_lastOpaqueIndex != renderPass._lastOpaqueIndex) {
          renderPass._lastOpaqueIndex = _lastOpaqueIndex;
          resultChanged || (resultChanged = true);
        }
        if (_lastTranslucentIndex != renderPass._lastTranslucentIndex) {
          renderPass._lastTranslucentIndex = _lastTranslucentIndex;
          resultChanged || (resultChanged = true);
        }
        if (_lastBlendWithZWriteIndex != renderPass._lastBlendWithZWriteIndex) {
          renderPass._lastBlendWithZWriteIndex = _lastBlendWithZWriteIndex;
          resultChanged || (resultChanged = true);
        }
        if (_lastBlendWithoutZWriteIndex != renderPass._lastBlendWithoutZWriteIndex) {
          renderPass._lastBlendWithoutZWriteIndex = _lastBlendWithoutZWriteIndex;
          resultChanged || (resultChanged = true);
        }
        if (primitiveUids.length !== renderPass._lastPrimitiveUids.length) {
          resultChanged || (resultChanged = true);
        } else {
          for (let i2 = _lastTranslucentIndex + 1; i2 < primitiveUids.length; i2++) {
            if (primitiveUids[i2] !== renderPass._lastPrimitiveUids[i2]) {
              resultChanged || (resultChanged = true);
              break;
            }
          }
        }
        renderPass._isChangedSortRenderResult = resultChanged;
        renderPass._lastPrimitiveUids = primitiveUids;
        renderPass._lastTransformComponentsUpdateCount = TransformComponent.updateCount;
        renderPass._lastCameraControllerComponentsUpdateCount = CameraControllerComponent.updateCount;
        renderPass._lastSceneGraphComponentsUpdateCount = SceneGraphComponent.updateCount;
        if (resultChanged) {
          renderPass._renderedSomethingBefore = true;
        }
        return primitiveUids;
      }
      static __cullingWithViewFrustum(cameraComponent, meshComponents) {
        let filteredMeshComponents = [];
        if (cameraComponent && _MeshRendererComponent._isFrustumCullingEnabled) {
          cameraComponent.updateFrustum();
          const frustum = cameraComponent.frustum;
          const frustumCulling = /* @__PURE__ */ __name((meshComponent, outMeshComponents) => {
            const result = meshComponent.entity.getTagValue("type") === "background-assets" ? true : frustum.culling(meshComponent);
            if (result) {
              outMeshComponents.push(meshComponent);
              meshComponent.entity.getSceneGraph()._isCulled = false;
              const skeletal = meshComponent.entity.tryToGetSkeletal();
              if (skeletal !== void 0) {
                skeletal._isCulled = false;
              }
            } else {
              meshComponent.entity.getSceneGraph()._isCulled = true;
              const skeletal = meshComponent.entity.tryToGetSkeletal();
              if (skeletal !== void 0) {
                skeletal._isCulled = true;
              }
            }
          }, "frustumCulling");
          for (const meshComponent of meshComponents) {
            if (meshComponent._isAlive && meshComponent.entity.getSceneGraph().isVisible) {
              frustumCulling(meshComponent, filteredMeshComponents);
            }
          }
        } else {
          filteredMeshComponents = meshComponents.filter((meshComponent) => meshComponent._isAlive && meshComponent.entity.getSceneGraph().isVisible);
        }
        const primitives = [];
        for (let i2 = 0; i2 < filteredMeshComponents.length; i2++) {
          const meshComponent = filteredMeshComponents[i2];
          const mesh = meshComponent.mesh;
          if (mesh !== void 0) {
            const meshPrimitives = mesh.primitives;
            let isBlendExist = false;
            for (let j = 0; j < meshPrimitives.length; j++) {
              const primitive = meshPrimitives[j];
              primitives.push(primitive);
              if (isBlend(primitive)) {
                isBlendExist = true;
              }
            }
            if (isBlendExist) {
              const viewDepth = meshComponent.calcViewDepth(cameraComponent);
              for (let j = 0; j < meshPrimitives.length; j++) {
                const primitive = meshPrimitives[j];
                primitive._viewDepth = viewDepth;
              }
            }
          }
        }
        return primitives;
      }
      static common_$prerender() {
        if (_MeshRendererComponent.__cgApiRenderingStrategy == null) {
          const processApproach = SystemState.currentProcessApproach;
          this.common_$load({
            processApproach
          });
        }
        _MeshRendererComponent.__cgApiRenderingStrategy.prerender();
      }
      static common_$render({ renderPass, processStage, renderPassTickCount, primitiveUids }) {
        return _MeshRendererComponent.__cgApiRenderingStrategy.common_$render(primitiveUids, renderPass, renderPassTickCount);
      }
      $render({ i: i2, renderPass, renderPassTickCount }) {
      }
      _shallowCopyFrom(component_) {
        const component = component_;
        this.__diffuseCubeMap = component.__diffuseCubeMap;
        this.__specularCubeMap = component.__specularCubeMap;
        this.diffuseCubeMapContribution = component.diffuseCubeMapContribution;
        this.specularCubeMapContribution = component.specularCubeMapContribution;
        this.rotationOfCubeMap = component.rotationOfCubeMap;
      }
      _destroy() {
        super._destroy();
        this.__diffuseCubeMap = void 0;
        this.__specularCubeMap = void 0;
      }
      /**
      * @override
      * Add this component to the entity
      * @param base the target entity
      * @param _componentClass the component class to add
      */
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let MeshRendererEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
          }
          getMeshRenderer() {
            return this.getComponentByComponentTID(WellKnownComponentTIDs.MeshRendererComponentTID);
          }
        }, __name(_a40, "MeshRendererEntity"), _a40);
        applyMixins(base, MeshRendererEntity);
        return base;
      }
    };
    __name(_MeshRendererComponent, "MeshRendererComponent");
    __publicField(_MeshRendererComponent, "__cgApiRenderingStrategy");
    __publicField(_MeshRendererComponent, "isDepthMaskTrueForBlendPrimitives", false);
    __publicField(_MeshRendererComponent, "__shaderProgramHandleOfPrimitiveObjectUids", /* @__PURE__ */ new Map());
    __publicField(_MeshRendererComponent, "__updateCount", 0);
    __publicField(_MeshRendererComponent, "_isFrustumCullingEnabled", true);
    MeshRendererComponent = _MeshRendererComponent;
  }
});

// src/webgpu/WebGpuResourceRepository.ts
var IBL_DIFFUSE_CUBE_TEXTURE_BINDING_SLOT, IBL_SPECULAR_CUBE_TEXTURE_BINDING_SLOT, _WebGpuResourceRepository, WebGpuResourceRepository;
var init_WebGpuResourceRepository = __esm({
  "src/webgpu/WebGpuResourceRepository.ts"() {
    "use strict";
    init_DataUtil();
    init_CompositionType();
    init_ComponentType();
    init_PixelFormat();
    init_TextureParameter();
    init_VertexAttribute();
    init_Primitive();
    init_Material();
    init_Is();
    init_CGAPIResourceRepository();
    init_Sampler();
    init_Config();
    init_HdriFormat();
    init_DummyTextures();
    init_MeshRendererComponent();
    init_AlphaMode();
    init_MiscUtil();
    init_CubeTexture();
    init_CameraComponent();
    init_EntityRepository();
    init_SystemState();
    init_BasisCompressionType();
    init_TextureFormat();
    init_RenderTargetTextureCube();
    init_Logger();
    init_hdrpng();
    IBL_DIFFUSE_CUBE_TEXTURE_BINDING_SLOT = 16;
    IBL_SPECULAR_CUBE_TEXTURE_BINDING_SLOT = 17;
    _WebGpuResourceRepository = class _WebGpuResourceRepository extends CGAPIResourceRepository {
      constructor() {
        super();
        __publicField(this, "__webGpuResources", /* @__PURE__ */ new Map());
        __publicField(this, "__resourceCounter", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__webGpuDeviceWrapper");
        __publicField(this, "__storageBuffer");
        __publicField(this, "__storageBlendShapeBuffer");
        __publicField(this, "__bindGroupStorageBuffer");
        __publicField(this, "__bindGroupLayoutStorageBuffer");
        __publicField(this, "__webGpuRenderPipelineMap", /* @__PURE__ */ new Map());
        __publicField(this, "__materialStateVersionMap", /* @__PURE__ */ new Map());
        __publicField(this, "__bindGroupTextureMap", /* @__PURE__ */ new Map());
        __publicField(this, "__bindGroupLayoutTextureMap", /* @__PURE__ */ new Map());
        __publicField(this, "__bindGroupSamplerMap", /* @__PURE__ */ new Map());
        __publicField(this, "__bindGroupLayoutSamplerMap", /* @__PURE__ */ new Map());
        __publicField(this, "__bindGroupsUniformDrawParameters", /* @__PURE__ */ new Map());
        __publicField(this, "__bindGroupLayoutUniformDrawParameters");
        __publicField(this, "__uniformDrawParametersBuffers", /* @__PURE__ */ new Map());
        __publicField(this, "__commandEncoder");
        __publicField(this, "__renderBundles", /* @__PURE__ */ new Map());
        __publicField(this, "__renderBundleEncoder");
        __publicField(this, "__systemDepthTexture");
        __publicField(this, "__systemDepthTextureView");
        __publicField(this, "__uniformMorphOffsetsBuffer");
        __publicField(this, "__uniformMorphWeightsBuffer");
        __publicField(this, "__renderPassEncoder");
        __publicField(this, "__generateMipmapsShaderModule");
        __publicField(this, "__generateMipmapsPipeline");
        __publicField(this, "__generateMipmapsFormat");
        __publicField(this, "__generateMipmapsSampler");
        __publicField(this, "__generateMipmapsBindGroupLayout");
        __publicField(this, "__contextCurrentTextureView");
        __publicField(this, "__lastMaterialsUpdateCount", -1);
        __publicField(this, "__lastCurrentCameraComponentSid", -1);
        __publicField(this, "__lastEntityRepositoryUpdateCount", -1);
        __publicField(this, "__lastPrimitivesMaterialVariantUpdateCount", -1);
        __publicField(this, "__lastMeshRendererComponentsUpdateCount", -1);
        __publicField(this, "__srcTextureViewsForGeneratingMipmaps", /* @__PURE__ */ new Map());
        __publicField(this, "__dstTextureViewsForGeneratingMipmaps", /* @__PURE__ */ new Map());
        __publicField(this, "__bindGroupsForGeneratingMipmaps", /* @__PURE__ */ new Map());
      }
      clearCache() {
        this.__webGpuRenderPipelineMap.clear();
        this.__materialStateVersionMap.clear();
        this.__bindGroupTextureMap.clear();
        this.__bindGroupLayoutTextureMap.clear();
        this.__bindGroupSamplerMap.clear();
        this.__bindGroupLayoutSamplerMap.clear();
        this.__renderBundles.clear();
      }
      addWebGpuDeviceWrapper(webGpuDeviceWrapper) {
        this.__webGpuDeviceWrapper = webGpuDeviceWrapper;
        this.__commandEncoder = this.__webGpuDeviceWrapper.gpuDevice.createCommandEncoder();
      }
      getWebGpuDeviceWrapper() {
        return this.__webGpuDeviceWrapper;
      }
      static getInstance() {
        if (!this.__instance) {
          this.__instance = new _WebGpuResourceRepository();
        }
        return this.__instance;
      }
      getResourceNumber() {
        return ++this.__resourceCounter;
      }
      __registerResource(obj) {
        const handle = this.getResourceNumber();
        obj._resourceUid = handle;
        this.__webGpuResources.set(handle, obj);
        return handle;
      }
      getCanvasSize() {
        const canvas = this.__webGpuDeviceWrapper.canvas;
        return [
          canvas.width,
          canvas.height
        ];
      }
      /**
      * create a WebGPU Texture
      * @param imageData - an ImageBitmapData
      * @param paramObject - a parameter object
      * @returns
      */
      createTextureFromImageBitmapData(imageData, { level, internalFormat, width, height, border, format, type, generateMipmap }) {
        const textureHandle = this.__createTextureInner(width, height, internalFormat, generateMipmap, imageData);
        return textureHandle;
      }
      async createTextureFromDataUri(dataUri, { level, internalFormat, border, format, type, generateMipmap }) {
        return new Promise((resolve) => {
          const img = new Image();
          if (!dataUri.match(/^data:/)) {
            img.crossOrigin = "Anonymous";
          }
          img.onload = async () => {
            const width = img.width;
            const height = img.height;
            const texture = await this.createTextureFromHTMLImageElement(img, {
              level,
              internalFormat,
              width,
              height,
              border,
              format,
              type,
              generateMipmap
            });
            resolve(texture);
          };
          img.src = dataUri;
        });
      }
      generateMipmaps2d(textureHandle, width, height) {
        const gpuTexture = this.__webGpuResources.get(textureHandle);
        const textureDescriptor = {
          size: [
            width,
            height,
            1
          ],
          format: gpuTexture.format,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
          mipLevelCount: Math.floor(Math.log2(Math.max(width, height))) + 1
        };
        this.generateMipmaps(gpuTexture, textureDescriptor);
      }
      generateMipmapsCube(textureHandle, width, height) {
        const gpuTexture = this.__webGpuResources.get(textureHandle);
        const textureDescriptor = {
          size: [
            width,
            height,
            6
          ],
          format: gpuTexture.format,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
          mipLevelCount: Math.floor(Math.log2(Math.max(width, height))) + 1
        };
        this.generateMipmaps(gpuTexture, textureDescriptor);
      }
      async getTexturePixelData(textureHandle, width, height, frameBufferUid, colorAttachmentIndex) {
        const gpuTexture = this.__webGpuResources.get(textureHandle);
        const textureData = new Uint8Array(width * height * 4);
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const commandEncoder = gpuDevice.createCommandEncoder();
        const buffer = gpuDevice.createBuffer({
          size: width * height * 4,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        });
        commandEncoder.copyTextureToBuffer({
          texture: gpuTexture
        }, {
          buffer,
          bytesPerRow: width * 4
        }, {
          width,
          height,
          depthOrArrayLayers: 1
        });
        gpuDevice.queue.submit([
          commandEncoder.finish()
        ]);
        await buffer.mapAsync(GPUMapMode.READ);
        const arrayBuffer = buffer.getMappedRange();
        textureData.set(new Uint8Array(arrayBuffer));
        buffer.unmap();
        return textureData;
      }
      /**
      * create a WebGPU Texture Mipmaps (including CubeMap support)
      *
      * @remarks
      * Adapted from: https://toji.dev/webgpu-best-practices/img-textures#generating-mipmaps
      * @param texture - a texture
      * @param textureDescriptor - a texture descriptor
      */
      generateMipmaps(texture, textureDescriptor) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        if (this.__generateMipmapsShaderModule == null) {
          this.__generateMipmapsShaderModule = gpuDevice.createShaderModule({
            code: (
              /* wgsl */
              `
          var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
            vec2f(-1, 1), vec2f(1, 1),
            vec2f(-1, -1), vec2f(1, -1));

          struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) texCoord : vec2f,
          };

          @vertex
          fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);
            output.position = vec4f(pos[vertexIndex], 0, 1);
            return output;
          }

          @group(0) @binding(0) var imgSampler : sampler;
          @group(0) @binding(1) var img : texture_2d<f32>;

          @fragment
          fn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {
            return textureSample(img, imgSampler, texCoord);
          }
        `
            )
          });
        }
        if (this.__generateMipmapsPipeline != null && textureDescriptor.format != this.__generateMipmapsFormat) {
          this.__generateMipmapsPipeline = void 0;
        }
        if (this.__generateMipmapsPipeline == null) {
          this.__generateMipmapsBindGroupLayout = gpuDevice.createBindGroupLayout({
            entries: [
              {
                binding: 0,
                visibility: GPUShaderStage.FRAGMENT,
                sampler: {
                  type: "filtering"
                }
              },
              {
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT,
                texture: {
                  viewDimension: "2d"
                }
              }
            ]
          });
          const pipelineLayout = gpuDevice.createPipelineLayout({
            bindGroupLayouts: [
              this.__generateMipmapsBindGroupLayout
            ]
          });
          this.__generateMipmapsPipeline = gpuDevice.createRenderPipeline({
            layout: pipelineLayout,
            vertex: {
              module: this.__generateMipmapsShaderModule,
              entryPoint: "vertexMain"
            },
            fragment: {
              module: this.__generateMipmapsShaderModule,
              entryPoint: "fragmentMain",
              targets: [
                {
                  format: textureDescriptor.format
                }
              ]
            },
            primitive: {
              topology: "triangle-strip",
              stripIndexFormat: "uint32"
            }
          });
          this.__generateMipmapsFormat = textureDescriptor.format;
        }
        if (this.__generateMipmapsSampler == null) {
          this.__generateMipmapsSampler = gpuDevice.createSampler({
            minFilter: "linear"
          });
        }
        if (this.__renderPassEncoder != null) {
          if (this.__renderBundleEncoder != null) {
            this.__renderPassEncoder.executeBundles([
              this.__renderBundleEncoder.finish()
            ]);
          }
          this.__renderPassEncoder.end();
          this.__renderPassEncoder = void 0;
        }
        const isCubemap = texture.dimension === "2d" && texture.depthOrArrayLayers === 6;
        const layerCount = isCubemap ? 6 : 1;
        for (let layer = 0; layer < layerCount; ++layer) {
          const srcTextureViewsMap = this.__srcTextureViewsForGeneratingMipmaps.get(texture);
          if (srcTextureViewsMap == null || srcTextureViewsMap[layer] == null) {
            const srcView2 = texture.createView({
              dimension: "2d",
              baseMipLevel: 0,
              mipLevelCount: 1,
              baseArrayLayer: layer,
              arrayLayerCount: 1
            });
            if (srcTextureViewsMap == null) {
              this.__srcTextureViewsForGeneratingMipmaps.set(texture, []);
            }
            this.__srcTextureViewsForGeneratingMipmaps.get(texture)[layer] = srcView2;
          }
          let srcView = this.__srcTextureViewsForGeneratingMipmaps.get(texture)[layer];
          for (let i2 = 1; i2 < textureDescriptor.mipLevelCount; ++i2) {
            const dstTextureViewsMap = this.__dstTextureViewsForGeneratingMipmaps.get(texture);
            if (dstTextureViewsMap == null || dstTextureViewsMap[layer] == null || dstTextureViewsMap[layer][i2] == null) {
              const dstView2 = texture.createView({
                dimension: "2d",
                baseMipLevel: i2,
                mipLevelCount: 1,
                baseArrayLayer: layer,
                arrayLayerCount: 1
              });
              if (dstTextureViewsMap == null) {
                this.__dstTextureViewsForGeneratingMipmaps.set(texture, []);
              }
              if (this.__dstTextureViewsForGeneratingMipmaps.get(texture)[layer] == null) {
                this.__dstTextureViewsForGeneratingMipmaps.get(texture)[layer] = [];
              }
              this.__dstTextureViewsForGeneratingMipmaps.get(texture)[layer][i2] = dstView2;
            }
            const dstView = this.__dstTextureViewsForGeneratingMipmaps.get(texture)[layer][i2];
            const passEncoder = this.__commandEncoder.beginRenderPass({
              colorAttachments: [
                {
                  view: dstView,
                  loadOp: "load",
                  storeOp: "store"
                }
              ]
            });
            const bindGroupsMap = this.__bindGroupsForGeneratingMipmaps.get(texture);
            if (bindGroupsMap == null || bindGroupsMap[layer] == null || bindGroupsMap[layer][i2] == null) {
              const bindGroup2 = gpuDevice.createBindGroup({
                layout: this.__generateMipmapsBindGroupLayout,
                entries: [
                  {
                    binding: 0,
                    resource: this.__generateMipmapsSampler
                  },
                  {
                    binding: 1,
                    resource: srcView
                  }
                ]
              });
              if (bindGroupsMap == null) {
                this.__bindGroupsForGeneratingMipmaps.set(texture, []);
              }
              if (this.__bindGroupsForGeneratingMipmaps.get(texture)[layer] == null) {
                this.__bindGroupsForGeneratingMipmaps.get(texture)[layer] = [];
              }
              this.__bindGroupsForGeneratingMipmaps.get(texture)[layer][i2] = bindGroup2;
            }
            const bindGroup = this.__bindGroupsForGeneratingMipmaps.get(texture)[layer][i2];
            passEncoder.setPipeline(this.__generateMipmapsPipeline);
            passEncoder.setBindGroup(0, bindGroup);
            passEncoder.draw(4);
            passEncoder.end();
            srcView = dstView;
          }
        }
      }
      createTextureSampler({ magFilter, minFilter, wrapS, wrapT, wrapR, anisotropy, isPremultipliedAlpha, shadowCompareMode }) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const maxAnisotropy = anisotropy ? 4 : 1;
        const desc = {
          magFilter: magFilter.webgpu,
          minFilter: minFilter.webgpu,
          mipmapFilter: minFilter === TextureParameter.LinearMipmapLinear || minFilter === TextureParameter.NearestMipmapLinear ? "linear" : "nearest",
          addressModeU: wrapS.webgpu,
          addressModeV: wrapT.webgpu,
          addressModeW: wrapR.webgpu,
          // lodMinClamp: 0,
          // lodMaxClamp: 32,
          maxAnisotropy
        };
        if (desc.magFilter === "nearest" || desc.minFilter === "nearest" || desc.mipmapFilter === "nearest") {
          desc.maxAnisotropy = 1;
        }
        const sampler = gpuDevice.createSampler(desc);
        const samplerHandle = this.__registerResource(sampler);
        return samplerHandle;
      }
      /**
      * create a WebGPU Vertex Buffer
      * @param accessor - an accessor
      * @returns
      */
      createVertexBuffer(accessor) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const vertexBuffer = gpuDevice.createBuffer({
          size: accessor.byteLength,
          usage: GPUBufferUsage.VERTEX,
          mappedAtCreation: true
        });
        new Uint8Array(vertexBuffer.getMappedRange()).set(accessor.getUint8Array());
        vertexBuffer.unmap();
        const bufferHandle = this.__registerResource(vertexBuffer);
        return bufferHandle;
      }
      /**
      * create a WebGPU Vertex Buffer
      * @param typedArray - a typed array
      * @returns a WebGPUResourceHandle
      */
      createVertexBufferFromTypedArray(typedArray) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const vertexBuffer = gpuDevice.createBuffer({
          size: typedArray.byteLength,
          usage: GPUBufferUsage.VERTEX,
          mappedAtCreation: true
        });
        new Uint8Array(vertexBuffer.getMappedRange()).set(new Uint8Array(typedArray.buffer));
        vertexBuffer.unmap();
        const resourceHandle = this.__registerResource(vertexBuffer);
        return resourceHandle;
      }
      /**
      * create a WebGPU Index Buffer
      * @param accessor - an accessor
      * @returns a WebGPUResourceHandle
      */
      createIndexBuffer(accessor) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        let uint8Array = accessor.getUint8Array();
        if (accessor.componentType === ComponentType.UnsignedByte) {
          const uint16Array = new Uint16Array(accessor.byteLength);
          const typedArray = accessor.getTypedArray();
          for (let i2 = 0; i2 < typedArray.length; i2++) {
            uint16Array[i2] = typedArray[i2];
          }
          uint8Array = new Uint8Array(uint16Array.buffer);
        }
        const size = DataUtil.addPaddingBytes(uint8Array.byteLength, 4);
        const indexBuffer = gpuDevice.createBuffer({
          size,
          usage: GPUBufferUsage.INDEX,
          mappedAtCreation: true
        });
        new Uint8Array(indexBuffer.getMappedRange()).set(uint8Array);
        indexBuffer.unmap();
        const bufferHandle = this.__registerResource(indexBuffer);
        return bufferHandle;
      }
      updateVertexBuffer(accessor, resourceHandle) {
        const vertexBuffer = this.__webGpuResources.get(resourceHandle);
        if (Is.not.exist(vertexBuffer)) {
          throw new Error("Not found VBO.");
        }
        vertexBuffer.mapAsync(GPUMapMode.WRITE).then(() => {
          new Uint8Array(vertexBuffer.getMappedRange()).set(accessor.bufferView.getUint8Array());
          vertexBuffer.unmap();
        });
      }
      updateIndexBuffer(accessor, resourceHandle) {
        const indexBuffer = this.__webGpuResources.get(resourceHandle);
        if (Is.not.exist(indexBuffer)) {
          throw new Error("Not found IBO.");
        }
        indexBuffer.mapAsync(GPUMapMode.WRITE).then(() => {
          let uint8Array = accessor.getUint8Array();
          if (accessor.componentType === ComponentType.UnsignedByte) {
            const uint16Array = new Uint16Array(accessor.byteLength);
            const typedArray = accessor.getTypedArray();
            for (let i2 = 0; i2 < typedArray.length; i2++) {
              uint16Array[i2] = typedArray[i2];
            }
            uint8Array = new Uint8Array(uint16Array.buffer);
          }
          new Uint8Array(indexBuffer.getMappedRange()).set(uint8Array);
          indexBuffer.unmap();
        });
      }
      deleteVertexBuffer(resourceHandle) {
        const vertexBuffer = this.__webGpuResources.get(resourceHandle);
        if (Is.not.exist(vertexBuffer)) {
          throw new Error("Not found VBO.");
        }
        vertexBuffer.destroy();
        this.__webGpuResources.delete(resourceHandle);
      }
      /**
      * create a VertexBuffer and IndexBuffer
      * @param primitive
      * @returns
      */
      createVertexBufferAndIndexBuffer(primitive) {
        let iboHandle;
        if (primitive.hasIndices()) {
          iboHandle = this.createIndexBuffer(primitive.indicesAccessor);
        }
        const attributesFlags = [];
        for (let i2 = 0; i2 < VertexAttribute.AttributeTypeNumber; i2++) {
          attributesFlags[i2] = false;
        }
        const vboHandles = [];
        primitive.attributeAccessors.forEach((accessor, i2) => {
          const vboHandle = this.createVertexBuffer(accessor);
          const slotIdx = VertexAttribute.toAttributeSlotFromJoinedString(primitive.attributeSemantics[i2]);
          attributesFlags[slotIdx] = true;
          vboHandles.push(vboHandle);
        });
        return {
          vaoHandle: -1,
          iboHandle,
          vboHandles,
          attributesFlags,
          setComplete: false
        };
      }
      /**
      * update the VertexBuffer and IndexBuffer
      * @param primitive
      * @param vertexHandles
      */
      updateVertexBufferAndIndexBuffer(primitive, vertexHandles) {
        if (vertexHandles.iboHandle) {
          this.updateIndexBuffer(primitive.indicesAccessor, vertexHandles.iboHandle);
        }
        const attributeAccessors = primitive.attributeAccessors;
        for (let i2 = 0; i2 < attributeAccessors.length; i2++) {
          this.updateVertexBuffer(attributeAccessors[i2], vertexHandles.vboHandles[i2]);
        }
      }
      deleteVertexDataResources(vertexHandles) {
        if (Is.exist(vertexHandles.iboHandle)) {
          const indexBuffer = this.__webGpuResources.get(vertexHandles.iboHandle);
          if (Is.exist(indexBuffer)) {
            indexBuffer.destroy();
          }
        }
        for (const vboHandle of vertexHandles.vboHandles) {
          const vertexBuffer = this.__webGpuResources.get(vboHandle);
          if (Is.exist(vertexBuffer)) {
            vertexBuffer.destroy();
          }
        }
      }
      /**
      * set the VertexData to the Pipeline
      */
      setVertexDataToPipeline({ vaoHandle, iboHandle, vboHandles }, primitive, instanceIDBufferUid = CGAPIResourceRepository.InvalidCGAPIResourceUid) {
        const buffers = [];
        const attributes = [];
        for (let i2 = 0; i2 < vboHandles.length; i2++) {
          const shaderLocation = VertexAttribute.toAttributeSlotFromJoinedString(primitive.attributeSemantics[i2]);
          const gpuVertexFormat = primitive.attributeAccessors[i2].componentType.webgpu + primitive.attributeAccessors[i2].compositionType.webgpu;
          attributes.push({
            shaderLocation,
            offset: primitive.attributeAccessors[i2].byteOffsetInBufferView,
            format: gpuVertexFormat
          });
        }
        buffers[0] = {
          stepMode: "vertex",
          attributes,
          arrayStride: primitive.attributeAccessors[0].byteStride
        };
        const instanceIDBuffer = this.__webGpuResources.get(instanceIDBufferUid);
        buffers[1] = {
          stepMode: "instance",
          attributes: [
            {
              shaderLocation: VertexAttribute.Instance.getAttributeSlot(),
              offset: 0,
              format: "float32x4"
            }
          ],
          arrayStride: 4 * 4
        };
      }
      __checkShaderCompileStatus(materialTypeName, shaderText, info) {
        Logger.info("MaterialTypeName: " + materialTypeName);
        const lineNumberedShaderText = MiscUtil.addLineNumberToCode(shaderText);
        Logger.info(lineNumberedShaderText);
        for (let i2 = 0; i2 < info.messages.length; i2++) {
          Logger.info(info.messages[i2].message);
          return false;
        }
        return true;
      }
      /**
      * create a shader program
      * @param param0
      * @returns
      */
      createShaderProgram({ material, primitive, vertexShaderStr, fragmentShaderStr, attributeNames, attributeSemantics, onError }) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const vsModule = gpuDevice.createShaderModule({
          code: vertexShaderStr
        });
        if (Config.cgApiDebugConsoleOutput) {
          vsModule.getCompilationInfo().then((info) => {
            if (info.messages.length > 0) {
              this.__checkShaderCompileStatus(material.materialTypeName, vertexShaderStr, info);
            }
          });
        }
        const fsModule = gpuDevice.createShaderModule({
          code: fragmentShaderStr
        });
        if (Config.cgApiDebugConsoleOutput) {
          fsModule.getCompilationInfo().then((info) => {
            if (info.messages.length > 0) {
              this.__checkShaderCompileStatus(material.materialTypeName, fragmentShaderStr, info);
            }
          });
        }
        const modules = {
          vsModule,
          fsModule
        };
        const modulesHandle = this.__registerResource(modules);
        return modulesHandle;
      }
      clearFrameBuffer(renderPass) {
        if (renderPass.entities.length > 0) {
          return;
        }
        if (!renderPass.toClearColorBuffer && !renderPass.toClearDepthBuffer) {
          return;
        }
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const context = this.__webGpuDeviceWrapper.context;
        const colorAttachments = [];
        let depthStencilAttachment;
        if (renderPass.toClearColorBuffer) {
          const framebuffer = renderPass.getFramebuffer();
          if (framebuffer != null) {
            for (let colorAttachment of framebuffer.colorAttachments) {
              const textureView = this.__webGpuResources.get(colorAttachment._textureViewAsRenderTargetResourceUid);
              colorAttachments.push({
                view: textureView,
                clearValue: {
                  r: renderPass.clearColor.x,
                  g: renderPass.clearColor.y,
                  b: renderPass.clearColor.z,
                  a: renderPass.clearColor.w
                },
                loadOp: "clear",
                storeOp: "store"
              });
            }
          } else {
            if (this.__contextCurrentTextureView == null) {
              this.__contextCurrentTextureView = context.getCurrentTexture().createView();
            }
            colorAttachments.push({
              view: this.__contextCurrentTextureView,
              clearValue: {
                r: renderPass.clearColor.x,
                g: renderPass.clearColor.y,
                b: renderPass.clearColor.z,
                a: renderPass.clearColor.w
              },
              loadOp: "clear",
              storeOp: "store"
            });
          }
        }
        if (renderPass.toClearDepthBuffer) {
          const framebuffer = renderPass.getFramebuffer();
          if (framebuffer != null && framebuffer.depthAttachment != null) {
            const depthTextureView = this.__webGpuResources.get(framebuffer.depthAttachment._textureViewAsRenderTargetResourceUid);
            depthStencilAttachment = {
              view: depthTextureView,
              depthClearValue: renderPass.clearDepth,
              depthLoadOp: "clear",
              depthStoreOp: "store"
            };
          } else {
            depthStencilAttachment = {
              view: this.__systemDepthTextureView,
              depthClearValue: renderPass.clearDepth,
              depthLoadOp: "clear",
              depthStoreOp: "store"
            };
          }
        }
        const renderPassDescriptor = {
          colorAttachments,
          depthStencilAttachment,
          label: renderPass.uniqueName
        };
        const passEncoder = this.__commandEncoder.beginRenderPass(renderPassDescriptor);
        passEncoder.end();
      }
      draw(primitive, material, renderPass, cameraId, zWrite) {
        const isBufferLessRendering = renderPass.isBufferLessRenderingMode();
        const VertexHandles = primitive._vertexHandles;
        if (!isBufferLessRendering && VertexHandles == null) {
          return;
        }
        let meshRendererComponentSid = -1;
        let meshRendererComponentUpdateCount = -1;
        let diffuseCubeMap;
        let specularCubeMap;
        if (!isBufferLessRendering) {
          const mesh = primitive.mesh;
          const entity = mesh.meshEntitiesInner[0];
          const meshRendererComponent = entity.getMeshRenderer();
          material._setInternalSettingParametersToGpuWebGpu({
            material,
            args: {
              cameraComponentSid: cameraId,
              entity,
              specularCube: meshRendererComponent.specularCubeMap
            }
          });
          meshRendererComponentSid = meshRendererComponent.componentSID;
          meshRendererComponentUpdateCount = meshRendererComponent.updateCount;
          diffuseCubeMap = meshRendererComponent.diffuseCubeMap;
          specularCubeMap = meshRendererComponent.specularCubeMap;
        }
        const renderPipelineId = `${primitive._getFingerPrint()} ${material.materialUID} ${renderPass.renderPassUID} ${meshRendererComponentSid} ${meshRendererComponentUpdateCount} ${zWrite} `;
        const [pipeline, recreated] = this.getOrCreateRenderPipeline(renderPipelineId, primitive, material, renderPass, zWrite, diffuseCubeMap, specularCubeMap);
        this.createRenderBundleEncoder(renderPass);
        const renderBundleEncoder = this.__renderBundleEncoder;
        renderBundleEncoder.setBindGroup(0, this.__bindGroupStorageBuffer);
        renderBundleEncoder.setPipeline(pipeline);
        renderBundleEncoder.setBindGroup(1, this.__bindGroupTextureMap.get(renderPipelineId));
        renderBundleEncoder.setBindGroup(2, this.__bindGroupSamplerMap.get(renderPipelineId));
        renderBundleEncoder.setBindGroup(3, this.__bindGroupsUniformDrawParameters.get(`${renderPass.renderPassUID}-${primitive.primitiveUid}`));
        if (isBufferLessRendering) {
          renderBundleEncoder.draw(renderPass._drawVertexNumberForBufferLessRendering);
        } else {
          const mesh = primitive.mesh;
          const variationVBO = this.__webGpuResources.get(mesh._variationVBOUid);
          renderBundleEncoder.setVertexBuffer(0, variationVBO);
          VertexHandles.vboHandles.forEach((vboHandle, i2) => {
            const vertexBuffer = this.__webGpuResources.get(vboHandle);
            renderBundleEncoder.setVertexBuffer(i2 + 1, vertexBuffer);
          });
          if (primitive.hasIndices()) {
            const indicesBuffer = this.__webGpuResources.get(VertexHandles.iboHandle);
            const indexBitSize = primitive.getIndexBitSize();
            renderBundleEncoder.setIndexBuffer(indicesBuffer, indexBitSize);
            const indicesAccessor = primitive.indicesAccessor;
            renderBundleEncoder.drawIndexed(indicesAccessor.elementCount, mesh.meshEntitiesInner.length);
          } else {
            const vertexCount = primitive.attributeAccessors[0].elementCount;
            renderBundleEncoder.draw(vertexCount, mesh.meshEntitiesInner.length);
          }
        }
        this.createRenderPassEncoder(renderPass);
      }
      createRenderBundleEncoder(renderPass) {
        if (this.__renderBundleEncoder == null) {
          const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
          const framebuffer = renderPass.getFramebuffer();
          let colorFormats = [
            navigator.gpu.getPreferredCanvasFormat()
          ];
          let depthStencilFormat = this.__systemDepthTexture.format;
          if (framebuffer != null) {
            colorFormats = [];
            for (let colorAttachment of framebuffer.colorAttachments) {
              const texture = this.__webGpuResources.get(colorAttachment._textureResourceUid);
              colorFormats.push(texture.format);
            }
            if (framebuffer.depthAttachment != null) {
              const depthTexture = this.__webGpuResources.get(framebuffer.depthAttachment._textureResourceUid);
              depthStencilFormat = depthTexture.format;
            } else {
              depthStencilFormat = void 0;
            }
          }
          const renderBundleDescriptor = {
            colorFormats,
            depthStencilFormat,
            sampleCount: renderPass.getResolveFramebuffer() != null ? renderPass.getFramebuffer().colorAttachments[0].sampleCount : 1
          };
          const encoder = gpuDevice.createRenderBundleEncoder(renderBundleDescriptor);
          this.__renderBundleEncoder = encoder;
        }
      }
      createRenderPassEncoder(renderPass) {
        if (this.__renderPassEncoder == null) {
          const framebuffer = renderPass.getFramebuffer();
          const resolveFramebuffer = renderPass.getResolveFramebuffer();
          const clearValue = renderPass.toClearColorBuffer ? {
            r: renderPass.clearColor.x,
            g: renderPass.clearColor.y,
            b: renderPass.clearColor.z,
            a: renderPass.clearColor.w
          } : void 0;
          const depthClearValue = renderPass.toClearDepthBuffer ? renderPass.clearDepth : void 0;
          if (resolveFramebuffer != null && framebuffer != null) {
            let depthTextureView = this.__systemDepthTextureView;
            if (framebuffer.depthAttachment != null) {
              const depthTexture = this.__webGpuResources.get(framebuffer.depthAttachment._textureResourceUid);
              if (depthTexture != null) {
                depthTextureView = this.__webGpuResources.get(framebuffer.depthAttachment._textureViewResourceUid);
              }
            }
            const renderPassDescriptor = {
              colorAttachments: [],
              depthStencilAttachment: {
                view: depthTextureView,
                depthClearValue,
                depthLoadOp: renderPass.toClearDepthBuffer ? "clear" : "load",
                depthStoreOp: "store"
              },
              label: renderPass.uniqueName
            };
            const colorAttachments = [];
            for (let i2 = 0; i2 < resolveFramebuffer.colorAttachments.length; i2++) {
              const colorAttachment = framebuffer.colorAttachments[i2];
              const resolveColorAttachment = resolveFramebuffer.colorAttachments[i2];
              const textureView = this.__webGpuResources.get(colorAttachment._textureViewAsRenderTargetResourceUid);
              let resolveTextureView = this.__webGpuResources.get(resolveColorAttachment._textureViewAsRenderTargetResourceUid);
              colorAttachments.push({
                view: textureView,
                resolveTarget: resolveTextureView,
                clearValue,
                loadOp: renderPass.toClearColorBuffer ? "clear" : "load",
                storeOp: "store"
              });
            }
            renderPassDescriptor.colorAttachments = colorAttachments;
            this.__renderPassEncoder = this.__commandEncoder.beginRenderPass(renderPassDescriptor);
          } else if (framebuffer != null) {
            let depthTextureView = void 0;
            if (framebuffer.depthAttachment != null) {
              const depthTexture = this.__webGpuResources.get(framebuffer.depthAttachment._textureResourceUid);
              if (depthTexture != null) {
                depthTextureView = this.__webGpuResources.get(framebuffer.depthAttachment._textureViewAsRenderTargetResourceUid);
              }
            }
            let depthStencilAttachment = void 0;
            if (depthTextureView != null) {
              depthStencilAttachment = {
                view: depthTextureView,
                depthClearValue,
                depthLoadOp: renderPass.toClearDepthBuffer ? "clear" : "load",
                depthStoreOp: "store"
              };
            }
            const renderPassDescriptor = {
              colorAttachments: [],
              depthStencilAttachment,
              label: renderPass.uniqueName
            };
            const colorAttachments = [];
            for (let colorAttachment of framebuffer.colorAttachments) {
              const textureView = this.__webGpuResources.get(colorAttachment._textureViewAsRenderTargetResourceUid);
              colorAttachments.push({
                view: textureView,
                clearValue,
                loadOp: renderPass.toClearColorBuffer ? "clear" : "load",
                storeOp: "store"
              });
            }
            renderPassDescriptor.colorAttachments = colorAttachments;
            this.__renderPassEncoder = this.__commandEncoder.beginRenderPass(renderPassDescriptor);
          } else {
            if (this.__contextCurrentTextureView == null) {
              const context = this.__webGpuDeviceWrapper.context;
              this.__contextCurrentTextureView = context.getCurrentTexture().createView();
            }
            const renderPassDescriptor = {
              colorAttachments: [
                {
                  view: this.__contextCurrentTextureView,
                  clearValue,
                  loadOp: renderPass.toClearColorBuffer ? "clear" : "load",
                  storeOp: "store"
                }
              ],
              depthStencilAttachment: {
                view: this.__systemDepthTextureView,
                depthClearValue,
                depthLoadOp: renderPass.toClearDepthBuffer ? "clear" : "load",
                depthStoreOp: "store"
              },
              label: renderPass.uniqueName
            };
            this.__renderPassEncoder = this.__commandEncoder.beginRenderPass(renderPassDescriptor);
          }
        }
      }
      __toClearRenderBundles() {
        if (Material.stateVersion !== this.__lastMaterialsUpdateCount || CameraComponent.current !== this.__lastCurrentCameraComponentSid || EntityRepository.updateCount !== this.__lastEntityRepositoryUpdateCount || Primitive.variantUpdateCount !== this.__lastPrimitivesMaterialVariantUpdateCount || MeshRendererComponent.updateCount !== this.__lastMeshRendererComponentsUpdateCount) {
          this.__renderBundles.clear();
          SystemState.webgpuRenderBundleMode = false;
          this.__lastCurrentCameraComponentSid = CameraComponent.current;
          this.__lastMaterialsUpdateCount = Material.stateVersion;
          this.__lastEntityRepositoryUpdateCount = EntityRepository.updateCount;
          this.__lastPrimitivesMaterialVariantUpdateCount = Primitive.variantUpdateCount;
          this.__lastMeshRendererComponentsUpdateCount = MeshRendererComponent.updateCount;
        }
      }
      executeRenderBundle(renderPass) {
        this.__toClearRenderBundles();
        if (renderPass._isChangedSortRenderResult || !Config.cacheWebGpuRenderBundles) {
          this.__renderBundles.clear();
        }
        let renderBundle = this.__renderBundles.get(renderPass.renderPassUID);
        if (renderBundle != null) {
          this.createRenderPassEncoder(renderPass);
          if (this.__renderPassEncoder != null) {
            this.__renderPassEncoder.executeBundles([
              renderBundle
            ]);
            this.__renderPassEncoder.end();
            this.__renderPassEncoder = void 0;
            return true;
          }
        }
        return false;
      }
      finishRenderBundleEncoder(renderPass) {
        if (this.__renderPassEncoder != null && this.__renderBundleEncoder != null) {
          const renderBundle = this.__renderBundleEncoder.finish();
          if (Config.cacheWebGpuRenderBundles) {
            this.__renderBundles.set(renderPass.renderPassUID, renderBundle);
          } else {
            this.__renderBundles.clear();
          }
          this.__renderPassEncoder.executeBundles([
            renderBundle
          ]);
          this.__renderPassEncoder.end();
          this.__renderBundleEncoder = void 0;
          this.__renderPassEncoder = void 0;
        }
      }
      getOrCreateRenderPipeline(renderPipelineId, primitive, material, renderPass, zWrite, diffuseCubeMap, specularCubeMap) {
        if (this.__webGpuRenderPipelineMap.has(renderPipelineId)) {
          const materialStateVersion = this.__materialStateVersionMap.get(renderPipelineId);
          if (materialStateVersion === material.stateVersion) {
            return [
              this.__webGpuRenderPipelineMap.get(renderPipelineId),
              false
            ];
          }
        }
        this.__webGpuRenderPipelineMap.delete(renderPipelineId);
        this.__materialStateVersionMap.delete(renderPipelineId);
        this.__bindGroupTextureMap.delete(renderPipelineId);
        this.__bindGroupLayoutTextureMap.delete(renderPipelineId);
        this.__bindGroupSamplerMap.delete(renderPipelineId);
        this.__bindGroupLayoutSamplerMap.delete(renderPipelineId);
        this.__createBindGroup(renderPipelineId, material, diffuseCubeMap, specularCubeMap);
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        const modules = this.__webGpuResources.get(material.getShaderProgramUid(primitive));
        if (modules != null) {
          new Error("Shader Modules is not found");
        }
        const gpuVertexBufferLayouts = [];
        if (!renderPass.isBufferLessRenderingMode()) {
          gpuVertexBufferLayouts.push({
            stepMode: "instance",
            attributes: [
              {
                shaderLocation: VertexAttribute.Instance.getAttributeSlot(),
                offset: 0,
                format: "float32x4"
              }
            ],
            arrayStride: 4 * 4
          });
        }
        primitive.attributeAccessors.forEach((accessor, i2) => {
          const slotIdx = VertexAttribute.toAttributeSlotFromJoinedString(primitive.attributeSemantics[i2]);
          const attribute = {
            shaderLocation: slotIdx,
            offset: 0,
            format: accessor.componentType.webgpu + accessor.compositionType.webgpu
          };
          gpuVertexBufferLayouts.push({
            stepMode: "vertex",
            arrayStride: primitive.attributeAccessors[i2].actualByteStride,
            attributes: [
              attribute
            ]
          });
        });
        const pipelineLayout = gpuDevice.createPipelineLayout({
          bindGroupLayouts: [
            this.__bindGroupLayoutStorageBuffer,
            this.__bindGroupLayoutTextureMap.get(renderPipelineId),
            this.__bindGroupLayoutSamplerMap.get(renderPipelineId),
            this.__bindGroupLayoutUniformDrawParameters
          ]
        });
        let blend;
        if (material.isBlend()) {
          if (material.alphaMode === AlphaMode.Blend) {
            blend = {
              color: {
                srcFactor: material.blendFuncSrcFactor.webgpu,
                dstFactor: material.blendFuncDstFactor.webgpu,
                operation: material.blendEquationMode.webgpu
              },
              alpha: {
                srcFactor: material.blendFuncAlphaSrcFactor.webgpu,
                dstFactor: material.blendFuncAlphaDstFactor.webgpu,
                operation: material.blendEquationModeAlpha.webgpu
              }
            };
          }
        }
        const mode = renderPass.isBufferLessRenderingMode() ? renderPass._primitiveModeForBufferLessRendering : primitive.primitiveMode;
        const topology = mode.getWebGPUTypeStr();
        let stripIndexFormat = void 0;
        if (topology === "triangle-strip" || topology === "line-strip") {
          stripIndexFormat = primitive.getIndexBitSize();
        }
        const primitiveIdxHasMorph = Primitive.getPrimitiveIdxHasMorph(primitive.primitiveUid);
        const framebuffer = renderPass.getFramebuffer();
        let targets = [
          {
            // @location(0) in fragment shader
            format: presentationFormat,
            blend
          }
        ];
        let depthStencilFormat = "depth24plus";
        if (framebuffer != null) {
          targets = [];
          for (let colorAttachment of framebuffer.colorAttachments) {
            const texture = this.__webGpuResources.get(colorAttachment._textureResourceUid);
            targets.push({
              format: texture.format,
              blend,
              writeMask: this.setColorWriteMask(material)
            });
          }
          if (framebuffer.depthAttachment != null) {
            const depthTexture = this.__webGpuResources.get(framebuffer.depthAttachment._textureResourceUid);
            depthStencilFormat = depthTexture.format;
          } else {
            depthStencilFormat = void 0;
          }
        }
        const pipeline = gpuDevice.createRenderPipeline({
          layout: pipelineLayout,
          vertex: {
            module: modules.vsModule,
            entryPoint: "main",
            buffers: gpuVertexBufferLayouts
          },
          fragment: {
            module: modules.fsModule,
            entryPoint: "main",
            targets
          },
          primitive: {
            topology,
            stripIndexFormat,
            frontFace: material.cullFrontFaceCCW ? "ccw" : "cw",
            cullMode: material.cullFace ? material.cullFaceBack ? "back" : "front" : "none"
          },
          depthStencil: depthStencilFormat == null ? void 0 : {
            depthWriteEnabled: zWrite,
            depthCompare: renderPass.isDepthTest ? "less" : "always",
            format: depthStencilFormat
          },
          multisample: {
            count: renderPass.getResolveFramebuffer() != null ? renderPass.getFramebuffer().colorAttachments[0].sampleCount : 1
          }
        });
        this.__webGpuRenderPipelineMap.set(renderPipelineId, pipeline);
        this.__materialStateVersionMap.set(renderPipelineId, material.stateVersion);
        return [
          pipeline,
          true
        ];
      }
      flush() {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        gpuDevice.queue.submit([
          this.__commandEncoder.finish()
        ]);
        this.__commandEncoder = gpuDevice.createCommandEncoder();
        if (this.__contextCurrentTextureView != null) {
          this.__contextCurrentTextureView = void 0;
        }
      }
      setColorWriteMask(material) {
        let flags = 0;
        if (material.colorWriteMask[0]) {
          flags |= 1;
        }
        if (material.colorWriteMask[1]) {
          flags |= 2;
        }
        if (material.colorWriteMask[2]) {
          flags |= 4;
        }
        if (material.colorWriteMask[3]) {
          flags |= 8;
        }
        return flags;
      }
      /**
      * Create Cube Texture from image files.
      * @param baseUri the base uri to load images;
      * @param mipLevelCount the number of mip levels (include root level). if no mipmap, the value should be 1;
      * @returns the WebGLResourceHandle for the generated Cube Texture
      */
      async createCubeTextureFromFiles(baseUri, mipLevelCount, isNamePosNeg, hdriFormat) {
        const imageArgs = [];
        let width = 0;
        let height = 0;
        for (let i2 = 0; i2 < mipLevelCount; i2++) {
          const loadOneLevel = /* @__PURE__ */ __name(() => {
            return new Promise((resolve, reject) => {
              let loadedCount = 0;
              const images2 = [];
              let extension = ".jpg";
              if (hdriFormat === HdriFormat.HDR_LINEAR) {
                extension = ".hdr";
              } else if (hdriFormat === HdriFormat.RGBE_PNG) {
                extension = ".RGBE.PNG";
              }
              let posX = "_right_";
              let negX = "_left_";
              let posY = "_top_";
              let negY = "_bottom_";
              let posZ = "_front_";
              let negZ = "_back_";
              if (isNamePosNeg) {
                posX = "_posx_";
                negX = "_negx_";
                posY = "_posy_";
                negY = "_negy_";
                posZ = "_posz_";
                negZ = "_negz_";
              }
              const faces = [
                [
                  baseUri + posX + i2 + extension,
                  "posX"
                ],
                [
                  baseUri + negX + i2 + extension,
                  "negX"
                ],
                [
                  baseUri + posY + i2 + extension,
                  "posY"
                ],
                [
                  baseUri + negY + i2 + extension,
                  "negY"
                ],
                [
                  baseUri + posZ + i2 + extension,
                  "posZ"
                ],
                [
                  baseUri + negZ + i2 + extension,
                  "negZ"
                ]
              ];
              for (let j = 0; j < faces.length; j++) {
                const face = faces[j][1];
                let image;
                if (hdriFormat === HdriFormat.HDR_LINEAR || hdriFormat === HdriFormat.RGB9_E5_PNG) {
                  image = new hdrpng_default();
                } else {
                  image = new Image();
                }
                image.hdriFormat = hdriFormat;
                image.side = face;
                image.uri = faces[j][0];
                image.crossOrigin = "Anonymous";
                image.onload = () => {
                  loadedCount++;
                  images2.push(image);
                  if (loadedCount === 6) {
                    resolve(images2);
                  }
                };
                image.onerror = () => {
                  reject(image.uri);
                };
                image.src = faces[j][0];
              }
            });
          }, "loadOneLevel");
          let images;
          try {
            images = await loadOneLevel();
          } catch (e3) {
            try {
              images = await loadOneLevel();
            } catch (uri) {
              Logger.error(`failed to load ${uri}`);
            }
          }
          const imageBitmaps = [];
          for (const image of images) {
            if (image.hdriFormat === HdriFormat.HDR_LINEAR) {
              imageBitmaps.push(image);
            } else {
              await image.decode();
              const imageBitmap = await createImageBitmap(image);
              imageBitmaps.push(imageBitmap);
              imageBitmap.side = image.side;
            }
          }
          const imageObj = {};
          for (const imageBitmap of imageBitmaps) {
            switch (imageBitmap.side) {
              case "posX":
                imageObj.posX = imageBitmap;
                break;
              case "posY":
                imageObj.posY = imageBitmap;
                break;
              case "posZ":
                imageObj.posZ = imageBitmap;
                break;
              case "negX":
                imageObj.negX = imageBitmap;
                break;
              case "negY":
                imageObj.negY = imageBitmap;
                break;
              case "negZ":
                imageObj.negZ = imageBitmap;
                break;
            }
            if (i2 === 0) {
              width = imageBitmap.width;
              height = imageBitmap.height;
            }
          }
          imageArgs.push(imageObj);
        }
        return this.createCubeTexture(mipLevelCount, imageArgs, width, height);
      }
      /**
      * create a CubeTexture
      *
      * @param mipLevelCount
      * @param images
      * @param width
      * @param height
      * @returns resource handle
      */
      createCubeTexture(mipLevelCount, images, width, height) {
        const mipmaps = [];
        for (let i2 = 0; i2 < mipLevelCount; i2++) {
          const imageBitmaps = [];
          if (images[i2].posX instanceof ImageBitmap || images[0].posX instanceof HTMLCanvasElement) {
            imageBitmaps.push(images[i2].posX);
            imageBitmaps.push(images[i2].negX);
            imageBitmaps.push(images[i2].posY);
            imageBitmaps.push(images[i2].negY);
            imageBitmaps.push(images[i2].posZ);
            imageBitmaps.push(images[i2].negZ);
          }
          mipmaps.push(imageBitmaps);
        }
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const cubemapTexture = gpuDevice.createTexture({
          dimension: "2d",
          size: [
            width,
            height,
            6
          ],
          format: mipmaps[0][0].hdriFormat === HdriFormat.HDR_LINEAR ? "rgba32float" : "rgba8unorm",
          mipLevelCount,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
        });
        for (let i2 = 0; i2 < mipLevelCount; i2++) {
          for (let j = 0; j < mipmaps[i2].length; j++) {
            const imageBitmap = mipmaps[i2][j];
            if (imageBitmap.hdriFormat === HdriFormat.HDR_LINEAR) {
              const newFloat323Array = new Float32Array(imageBitmap.width * imageBitmap.height * 4);
              const dataFloat = imageBitmap.dataFloat;
              const size = imageBitmap.width * imageBitmap.height;
              for (let k = 0; k < size; k++) {
                newFloat323Array[k * 4] = dataFloat[k * 3];
                newFloat323Array[k * 4 + 1] = dataFloat[k * 3 + 1];
                newFloat323Array[k * 4 + 2] = dataFloat[k * 3 + 2];
                newFloat323Array[k * 4 + 3] = 1;
              }
              const bytesPerRow = imageBitmap.width * 4 * Float32Array.BYTES_PER_ELEMENT;
              const paddedBytesPerRow = Math.ceil(bytesPerRow / 256) * 256;
              const paddedRowSize = paddedBytesPerRow / Float32Array.BYTES_PER_ELEMENT;
              const paddedFloatData = new Float32Array(paddedRowSize * imageBitmap.height);
              for (let y = 0; y < imageBitmap.height; y++) {
                const sourceStart = y * imageBitmap.width * 4;
                const sourceEnd = sourceStart + imageBitmap.width * 4;
                const destStart = y * paddedRowSize;
                paddedFloatData.set(newFloat323Array.subarray(sourceStart, sourceEnd), destStart);
              }
              const buffer = gpuDevice.createBuffer({
                size: paddedFloatData.byteLength,
                usage: GPUBufferUsage.COPY_SRC,
                mappedAtCreation: true
              });
              new Float32Array(buffer.getMappedRange()).set(paddedFloatData);
              buffer.unmap();
              const commandEncoder = gpuDevice.createCommandEncoder();
              commandEncoder.copyBufferToTexture({
                buffer,
                bytesPerRow: paddedBytesPerRow,
                rowsPerImage: imageBitmap.height
              }, {
                texture: cubemapTexture,
                origin: [
                  0,
                  0,
                  j
                ],
                mipLevel: i2
              }, [
                imageBitmap.width,
                imageBitmap.height,
                1
              ]);
              const commandBuffer = commandEncoder.finish();
              gpuDevice.queue.submit([
                commandBuffer
              ]);
            } else {
              gpuDevice.queue.copyExternalImageToTexture({
                source: imageBitmap
              }, {
                texture: cubemapTexture,
                origin: [
                  0,
                  0,
                  j
                ],
                mipLevel: i2
              }, [
                imageBitmap.width,
                imageBitmap.height,
                1
              ]);
            }
          }
        }
        const handle = this.__registerResource(cubemapTexture);
        const wrapS = TextureParameter.Repeat;
        const wrapT = TextureParameter.Repeat;
        const minFilter = mipLevelCount === 1 ? TextureParameter.Linear : TextureParameter.LinearMipmapLinear;
        const magFilter = TextureParameter.Linear;
        const sampler = new Sampler({
          wrapS,
          wrapT,
          minFilter,
          magFilter,
          anisotropy: false
        });
        sampler.create();
        return [
          handle,
          sampler
        ];
      }
      createStorageBuffer(inputArray) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const storageBuffer = gpuDevice.createBuffer({
          size: inputArray.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE
        });
        gpuDevice.queue.writeBuffer(storageBuffer, 0, inputArray);
        this.__storageBuffer = storageBuffer;
        const storageBufferHandle = this.__registerResource(storageBuffer);
        return storageBufferHandle;
      }
      updateStorageBuffer(storageBufferHandle, inputArray, updateComponentSize) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const storageBuffer = this.__webGpuResources.get(storageBufferHandle);
        gpuDevice.queue.writeBuffer(storageBuffer, 0, inputArray, 0, updateComponentSize);
      }
      updateStorageBufferPartially(storageBufferHandle, inputArray, offsetOfStorageBufferInByte, offsetOfInputArrayInElement, updateComponentSize) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const storageBuffer = this.__webGpuResources.get(storageBufferHandle);
        gpuDevice.queue.writeBuffer(storageBuffer, offsetOfStorageBufferInByte, inputArray, offsetOfInputArrayInElement, updateComponentSize);
      }
      createStorageBlendShapeBuffer(inputArray) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const storageBuffer = gpuDevice.createBuffer({
          size: inputArray.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE
        });
        gpuDevice.queue.writeBuffer(storageBuffer, 0, inputArray);
        this.__storageBlendShapeBuffer = storageBuffer;
        const storageBufferHandle = this.__registerResource(storageBuffer);
        return storageBufferHandle;
      }
      updateStorageBlendShapeBuffer(storageBufferHandle, inputArray, updateComponentSize) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const storageBuffer = this.__webGpuResources.get(storageBufferHandle);
        gpuDevice.queue.writeBuffer(storageBuffer, 0, inputArray, 0, updateComponentSize);
      }
      createBindGroupLayoutForDrawParameters() {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        {
          const bindGroupLayoutDesc = {
            entries: [
              {
                binding: 0,
                buffer: {
                  type: "uniform"
                },
                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT
              }
            ]
          };
          const bindGroupLayout = gpuDevice.createBindGroupLayout(bindGroupLayoutDesc);
          this.__bindGroupLayoutUniformDrawParameters = bindGroupLayout;
        }
      }
      updateUniformBufferForDrawParameters(identifier, materialSid, cameraSID, currentPrimitiveIdx, morphTargetNumber) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        let uniformBuffer = this.__uniformDrawParametersBuffers.get(identifier);
        if (uniformBuffer == null) {
          uniformBuffer = gpuDevice.createBuffer({
            size: 4 * 4,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM
          });
          this.__uniformDrawParametersBuffers.set(identifier, uniformBuffer);
          const bindGroup = gpuDevice.createBindGroup({
            layout: this.__bindGroupLayoutUniformDrawParameters,
            entries: [
              {
                binding: 0,
                resource: {
                  buffer: uniformBuffer
                }
              }
            ]
          });
          this.__bindGroupsUniformDrawParameters.set(identifier, bindGroup);
        }
        _WebGpuResourceRepository.__drawParametersUint32Array[0] = materialSid;
        _WebGpuResourceRepository.__drawParametersUint32Array[1] = cameraSID;
        _WebGpuResourceRepository.__drawParametersUint32Array[2] = currentPrimitiveIdx;
        _WebGpuResourceRepository.__drawParametersUint32Array[3] = morphTargetNumber;
        gpuDevice.queue.writeBuffer(uniformBuffer, 0, _WebGpuResourceRepository.__drawParametersUint32Array);
      }
      createUniformMorphOffsetsBuffer() {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const inputArray = new Uint32Array(Math.ceil(Config.maxVertexPrimitiveNumberInShader * Config.maxVertexMorphNumberInShader / 4) * 4);
        const uniformBuffer = gpuDevice.createBuffer({
          size: inputArray.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM
        });
        gpuDevice.queue.writeBuffer(uniformBuffer, 0, inputArray);
        this.__uniformMorphOffsetsBuffer = uniformBuffer;
        const uniformBufferHandle = this.__registerResource(uniformBuffer);
        return uniformBufferHandle;
      }
      updateUniformMorphOffsetsBuffer(inputArray, elementNum) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        if (this.__uniformMorphOffsetsBuffer == null) {
          throw new Error("Not found uniform morph buffer.");
        }
        gpuDevice.queue.writeBuffer(this.__uniformMorphOffsetsBuffer, 0, inputArray, 0, elementNum);
      }
      createUniformMorphWeightsBuffer() {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const inputArray = new Float32Array(Math.ceil(Config.maxVertexPrimitiveNumberInShader * Config.maxVertexMorphNumberInShader / 4) * 4);
        const uniformBuffer = gpuDevice.createBuffer({
          size: inputArray.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM
        });
        gpuDevice.queue.writeBuffer(uniformBuffer, 0, inputArray);
        this.__uniformMorphWeightsBuffer = uniformBuffer;
        const uniformBufferHandle = this.__registerResource(uniformBuffer);
        return uniformBufferHandle;
      }
      updateUniformMorphWeightsBuffer(inputArray, elementNum) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        if (this.__uniformMorphWeightsBuffer == null) {
          throw new Error("Not found uniform morph buffer.");
        }
        gpuDevice.queue.writeBuffer(this.__uniformMorphWeightsBuffer, 0, inputArray, 0, elementNum);
      }
      __createBindGroup(renderPipelineId, material, diffuseCubeMap, specularCubeMap) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        {
          const entries = [];
          const bindGroupLayoutEntries = [];
          if (this.__storageBuffer != null) {
            entries.push({
              binding: 0,
              resource: {
                buffer: this.__storageBuffer
              }
            });
            bindGroupLayoutEntries.push({
              binding: 0,
              buffer: {
                type: "read-only-storage"
              },
              visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT
            });
          }
          if (this.__storageBlendShapeBuffer != null) {
            entries.push({
              binding: 1,
              resource: {
                buffer: this.__storageBlendShapeBuffer
              }
            });
            bindGroupLayoutEntries.push({
              binding: 1,
              buffer: {
                type: "read-only-storage"
              },
              visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT
            });
          } else {
            const dummyBuffer = gpuDevice.createBuffer({
              size: 16,
              usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE
            });
            entries.push({
              binding: 1,
              resource: {
                buffer: dummyBuffer
              }
            });
            bindGroupLayoutEntries.push({
              binding: 1,
              buffer: {
                type: "read-only-storage"
              },
              visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT
            });
          }
          if (this.__uniformMorphOffsetsBuffer != null) {
            entries.push({
              binding: 2,
              resource: {
                buffer: this.__uniformMorphOffsetsBuffer
              }
            });
            bindGroupLayoutEntries.push({
              binding: 2,
              buffer: {
                type: "uniform"
              },
              visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT
            });
          }
          if (this.__uniformMorphWeightsBuffer != null) {
            entries.push({
              binding: 3,
              resource: {
                buffer: this.__uniformMorphWeightsBuffer
              }
            });
            bindGroupLayoutEntries.push({
              binding: 3,
              buffer: {
                type: "uniform"
              },
              visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT
            });
          }
          const bindGroupLayoutDesc = {
            entries: bindGroupLayoutEntries
          };
          const bindGroupLayout = gpuDevice.createBindGroupLayout(bindGroupLayoutDesc);
          const uniformBindGroup = gpuDevice.createBindGroup({
            layout: bindGroupLayout,
            entries
          });
          this.__bindGroupStorageBuffer = uniformBindGroup;
          this.__bindGroupLayoutStorageBuffer = bindGroupLayout;
        }
        {
          const entriesForTexture = [];
          const bindGroupLayoutEntriesForTexture = [];
          const entriesForSampler = [];
          const bindGroupLayoutEntriesForSampler = [];
          material._autoFieldVariablesOnly.forEach((value) => {
            const info = value.info;
            if (info.semantic === "diffuseEnvTexture" || info.semantic === "specularEnvTexture") {
              return;
            }
            if (CompositionType.isTexture(info.compositionType)) {
              const slot = value.value[0];
              const texture = value.value[1];
              const sampler = value.value[2];
              const type = texture instanceof CubeTexture || texture instanceof RenderTargetTextureCube ? "cube" : "2d";
              let gpuTextureView = this.__webGpuResources.get(texture._textureViewResourceUid);
              if (gpuTextureView == null) {
                if (texture instanceof CubeTexture || texture instanceof RenderTargetTextureCube) {
                  const gpuTexture = this.__webGpuResources.get(dummyBlackCubeTexture._textureResourceUid);
                  gpuTextureView = gpuTexture.createView({
                    dimension: "cube"
                  });
                } else {
                  const gpuTexture = this.__webGpuResources.get(dummyWhiteTexture._textureResourceUid);
                  gpuTextureView = gpuTexture.createView();
                }
              }
              entriesForTexture.push({
                binding: slot,
                resource: gpuTextureView
              });
              bindGroupLayoutEntriesForTexture.push({
                binding: slot,
                texture: {
                  viewDimension: type
                },
                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT
              });
              if (!sampler.created) {
                sampler.create();
              }
              const gpuSampler = this.__webGpuResources.get(sampler._samplerResourceUid);
              entriesForSampler.push({
                binding: slot,
                resource: gpuSampler
              });
              bindGroupLayoutEntriesForSampler.push({
                binding: slot,
                sampler: {
                  type: "filtering"
                },
                visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT
              });
            }
          });
          const diffuseCubeTextureView = this.__webGpuResources.get(Is.exist(diffuseCubeMap) ? diffuseCubeMap._textureViewResourceUid : -1);
          if (Is.exist(diffuseCubeTextureView)) {
            entriesForTexture.push({
              binding: IBL_DIFFUSE_CUBE_TEXTURE_BINDING_SLOT,
              resource: diffuseCubeTextureView
            });
          } else {
            const dummyCubeTextureView = this.__webGpuResources.get(dummyBlackCubeTexture._textureViewResourceUid);
            entriesForTexture.push({
              binding: IBL_DIFFUSE_CUBE_TEXTURE_BINDING_SLOT,
              resource: dummyCubeTextureView
            });
          }
          bindGroupLayoutEntriesForTexture.push({
            binding: IBL_DIFFUSE_CUBE_TEXTURE_BINDING_SLOT,
            texture: {
              viewDimension: "cube"
            },
            visibility: GPUShaderStage.FRAGMENT
          });
          const diffuseCubeSampler = this.__webGpuResources.get(Is.exist(diffuseCubeMap) ? diffuseCubeMap._samplerResourceUid : -1);
          if (Is.exist(diffuseCubeSampler)) {
            entriesForSampler.push({
              binding: IBL_DIFFUSE_CUBE_TEXTURE_BINDING_SLOT,
              resource: diffuseCubeSampler
            });
          } else {
            const dummyCubeSampler = this.__webGpuResources.get(dummyBlackCubeTexture._samplerResourceUid);
            entriesForSampler.push({
              binding: IBL_DIFFUSE_CUBE_TEXTURE_BINDING_SLOT,
              resource: dummyCubeSampler
            });
          }
          bindGroupLayoutEntriesForSampler.push({
            binding: IBL_DIFFUSE_CUBE_TEXTURE_BINDING_SLOT,
            sampler: {
              type: "filtering"
            },
            visibility: GPUShaderStage.FRAGMENT
          });
          const specularCubeTextureView = this.__webGpuResources.get(Is.exist(specularCubeMap) ? specularCubeMap._textureViewResourceUid : -1);
          if (Is.exist(specularCubeTextureView)) {
            entriesForTexture.push({
              binding: IBL_SPECULAR_CUBE_TEXTURE_BINDING_SLOT,
              resource: specularCubeTextureView
            });
          } else {
            const dummyCubeTextureView = this.__webGpuResources.get(dummyBlackCubeTexture._textureViewResourceUid);
            entriesForTexture.push({
              binding: IBL_SPECULAR_CUBE_TEXTURE_BINDING_SLOT,
              resource: dummyCubeTextureView
            });
          }
          bindGroupLayoutEntriesForTexture.push({
            binding: IBL_SPECULAR_CUBE_TEXTURE_BINDING_SLOT,
            texture: {
              viewDimension: "cube"
            },
            visibility: GPUShaderStage.FRAGMENT
          });
          const specularCubeSampler = this.__webGpuResources.get(Is.exist(specularCubeMap) ? specularCubeMap._samplerResourceUid : -1);
          if (Is.exist(specularCubeSampler)) {
            entriesForSampler.push({
              binding: IBL_SPECULAR_CUBE_TEXTURE_BINDING_SLOT,
              resource: specularCubeSampler
            });
          } else {
            const dummyCubeSampler = this.__webGpuResources.get(dummyBlackCubeTexture._samplerResourceUid);
            entriesForSampler.push({
              binding: IBL_SPECULAR_CUBE_TEXTURE_BINDING_SLOT,
              resource: dummyCubeSampler
            });
          }
          bindGroupLayoutEntriesForSampler.push({
            binding: IBL_SPECULAR_CUBE_TEXTURE_BINDING_SLOT,
            sampler: {
              type: "filtering"
            },
            visibility: GPUShaderStage.FRAGMENT
          });
          const bindGroupLayoutDescForTexture = {
            entries: bindGroupLayoutEntriesForTexture
          };
          const bindGroupLayoutForTexture = gpuDevice.createBindGroupLayout(bindGroupLayoutDescForTexture);
          const bindGroupForTexture = gpuDevice.createBindGroup({
            layout: bindGroupLayoutForTexture,
            entries: entriesForTexture
          });
          this.__bindGroupTextureMap.set(renderPipelineId, bindGroupForTexture);
          this.__bindGroupLayoutTextureMap.set(renderPipelineId, bindGroupLayoutForTexture);
          const bindGroupLayoutDescForSampler = {
            entries: bindGroupLayoutEntriesForSampler
          };
          const bindGroupLayoutForSampler = gpuDevice.createBindGroupLayout(bindGroupLayoutDescForSampler);
          const bindGroupForSampler = gpuDevice.createBindGroup({
            layout: bindGroupLayoutForSampler,
            entries: entriesForSampler
          });
          this.__bindGroupSamplerMap.set(renderPipelineId, bindGroupForSampler);
          this.__bindGroupLayoutSamplerMap.set(renderPipelineId, bindGroupLayoutForSampler);
        }
      }
      /**
      * create a Texture
      * @param imageData
      * @param param1
      * @returns
      */
      async createTextureFromHTMLImageElement(imageData, { level, internalFormat, width, height, border, format, type, generateMipmap }) {
        imageData.crossOrigin = "Anonymous";
        const textureHandle = this.__createTextureInner(width, height, internalFormat, generateMipmap, imageData);
        return textureHandle;
      }
      /**
      * create CompressedTextureFromBasis
      * @param basisFile
      * @param param1
      * @returns
      */
      createCompressedTextureFromBasis(basisFile, { border, format, type }) {
        let basisCompressionType;
        let compressionType;
        const mipmapDepth = basisFile.getNumLevels(0);
        const width = basisFile.getImageWidth(0, 0);
        const height = basisFile.getImageHeight(0, 0);
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const gpuAdapter = this.__webGpuDeviceWrapper.gpuAdapter;
        const s3tc = gpuAdapter.features.has("texture-compression-bc");
        if (s3tc) {
          basisCompressionType = BasisCompressionType.BC3;
          compressionType = "bc3-rgba-unorm";
        }
        const etc2 = gpuAdapter.features.has("texture-compression-etc2");
        if (etc2) {
          basisCompressionType = BasisCompressionType.ETC2;
          compressionType = "etc2-rgba8unorm";
        }
        const astc = gpuAdapter.features.has("texture-compression-astc");
        if (astc) {
          basisCompressionType = BasisCompressionType.ASTC;
          compressionType = "astc-4x4-unorm";
        }
        const textureDescriptor = {
          size: [
            width,
            height,
            1
          ],
          format: compressionType,
          mipLevelCount: mipmapDepth,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
        };
        const gpuTexture = gpuDevice.createTexture(textureDescriptor);
        for (let i2 = 0; i2 < mipmapDepth; i2++) {
          const width2 = basisFile.getImageWidth(0, i2);
          const height2 = basisFile.getImageHeight(0, i2);
          const textureSource = this.decodeBasisImage(basisFile, basisCompressionType, 0, i2);
          const imageData = new ImageData(new Uint8ClampedArray(textureSource), width2, height2);
          gpuDevice.queue.copyExternalImageToTexture({
            source: imageData
          }, {
            texture: gpuTexture,
            mipLevel: i2
          }, [
            width2,
            height2,
            1
          ]);
        }
        const textureHandle = this.__registerResource(gpuTexture);
        return textureHandle;
      }
      /**
      * decode the BasisImage
      * @param basisFile
      * @param basisCompressionType
      * @param imageIndex
      * @param levelIndex
      * @returns
      */
      decodeBasisImage(basisFile, basisCompressionType, imageIndex, levelIndex) {
        const extractSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisCompressionType.index);
        const textureSource = new Uint8Array(extractSize);
        if (!basisFile.transcodeImage(textureSource, imageIndex, levelIndex, basisCompressionType.index, 0, 0)) {
          Logger.error("failed to transcode the image.");
        }
        return textureSource;
      }
      /**
      * Create and bind compressed texture object
      * @param textureDataArray transcoded texture data for each mipmaps(levels)
      * @param compressionTextureType
      */
      createCompressedTexture(textureDataArray, compressionTextureType) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const blockInfo = compressionTextureType.blockInfo || {
          byteSize: 4,
          width: 1,
          height: 1
        };
        const textureDataLevel0 = textureDataArray[0];
        const textureDescriptor = {
          size: [
            Math.ceil(textureDataLevel0.width / blockInfo.width) * blockInfo.width,
            Math.ceil(textureDataLevel0.height / blockInfo.height) * blockInfo.height,
            1
          ],
          format: compressionTextureType.webgpu,
          mipLevelCount: textureDataArray.length,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
        };
        const texture = gpuDevice.createTexture(textureDescriptor);
        for (let level = 0; level < textureDataArray.length; level++) {
          const textureData = textureDataArray[level];
          const mipWidth = textureData.width;
          const mipHeight = textureData.height;
          const bytesPerRow = Math.ceil(mipWidth / blockInfo.width) * blockInfo.byteSize;
          const compressedTextureData = new Uint8Array(textureData.buffer.buffer);
          gpuDevice.queue.writeTexture({
            texture,
            mipLevel: level
          }, compressedTextureData, {
            offset: 0,
            bytesPerRow
          }, {
            width: Math.ceil(mipWidth / blockInfo.width) * blockInfo.width,
            height: Math.ceil(mipHeight / blockInfo.height) * blockInfo.height
          });
        }
        const textureHandle = this.__registerResource(texture);
        return textureHandle;
      }
      /**
      * allocate a Texture
      * @param format - the format of the texture
      * @param width - the width of the texture
      * @param height - the height of the texture
      * @param mipmapCount - the number of mipmap levels
      * @returns the handle of the texture
      */
      allocateTexture({ format, width, height, mipLevelCount }) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const textureDescriptor = {
          size: [
            width,
            height,
            1
          ],
          mipLevelCount,
          format: format.webgpu,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
        };
        const gpuTexture = gpuDevice.createTexture(textureDescriptor);
        const textureHandle = this.__registerResource(gpuTexture);
        return textureHandle;
      }
      /**
      * Load an image to a specific mip level of a texture
      * @param mipLevel - the mip level to load the image to
      * @param textureUid - the handle of the texture
      * @param format - the format of the image
      * @param type - the type of the data
      * @param xOffset - the x offset of copy region
      * @param yOffset - the y offset of copy region
      * @param width - the width of the image
      * @param height - the height of the image
      * @param data - the typedarray data of the image
      */
      async loadImageToMipLevelOfTexture2D({ mipLevel, textureUid, format, type, xOffset, yOffset, width, height, rowSizeByPixel, data }) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const texture = this.__webGpuResources.get(textureUid);
        const pixelFormat = TextureFormat.getPixelFormatFromTextureFormat(format);
        const compositionNum = PixelFormat.getCompositionNumFromPixelFormat(pixelFormat);
        const bytesPerRow = rowSizeByPixel * compositionNum * type.getSizeInBytes();
        const paddedBytesPerRow = Math.ceil(bytesPerRow / 256) * 256;
        const paddedData = new Uint8Array(paddedBytesPerRow * height);
        for (let row = 0; row < height; row++) {
          const srcOffset = row * bytesPerRow;
          const dstOffset = row * paddedBytesPerRow;
          paddedData.set(new Uint8Array(data.buffer, srcOffset, bytesPerRow), dstOffset);
        }
        const buffer = gpuDevice.createBuffer({
          size: paddedData.byteLength,
          usage: GPUBufferUsage.COPY_SRC,
          mappedAtCreation: true
        });
        new Uint8Array(buffer.getMappedRange()).set(paddedData);
        buffer.unmap();
        const commandEncoder = gpuDevice.createCommandEncoder();
        commandEncoder.copyBufferToTexture({
          buffer,
          offset: 0,
          bytesPerRow: paddedBytesPerRow,
          rowsPerImage: height
        }, {
          texture,
          mipLevel,
          origin: {
            x: xOffset,
            y: yOffset,
            z: 0
          }
        }, {
          width,
          height,
          depthOrArrayLayers: 1
        });
        const commandBuffer = commandEncoder.finish();
        gpuDevice.queue.submit([
          commandBuffer
        ]);
        try {
          await gpuDevice.queue.onSubmittedWorkDone();
        } catch (e3) {
          Logger.error(e3);
        }
      }
      __createTextureInner(width, height, internalFormat, generateMipmap, imageData) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const textureDescriptor = {
          size: [
            width,
            height,
            1
          ],
          format: internalFormat.webgpu,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
        };
        if (generateMipmap) {
          textureDescriptor.mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;
        }
        const gpuTexture = gpuDevice.createTexture(textureDescriptor);
        gpuDevice.queue.copyExternalImageToTexture({
          source: imageData
        }, {
          texture: gpuTexture
        }, [
          width,
          height
        ]);
        if (generateMipmap) {
          this.generateMipmaps(gpuTexture, textureDescriptor);
        }
        const textureHandle = this.__registerResource(gpuTexture);
        return textureHandle;
      }
      /**
      * create a RenderTargetTexture
      * @param param0
      * @returns
      */
      createRenderTargetTexture({ width, height, mipLevelCount, format }) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const textureDescriptor = {
          size: [
            width,
            height,
            1
          ],
          format: format.webgpu,
          mipLevelCount,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
        };
        const gpuTexture = gpuDevice.createTexture(textureDescriptor);
        const textureHandle = this.__registerResource(gpuTexture);
        return textureHandle;
      }
      /**
      * create a RenderTargetTextureArray
      * @param param0
      * @returns
      */
      createRenderTargetTextureArray({ width, height, level, internalFormat, format, type, arrayLength }) {
        return -1;
      }
      /**
      * create a RenderTargetTextureCube
      * @param param0
      * @returns
      */
      createRenderTargetTextureCube({ width, height, mipLevelCount, format }) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const textureDescriptor = {
          dimension: "2d",
          size: [
            width,
            height,
            6
          ],
          format: format.webgpu,
          mipLevelCount,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
        };
        const gpuTexture = gpuDevice.createTexture(textureDescriptor);
        const textureHandle = this.__registerResource(gpuTexture);
        return textureHandle;
      }
      /**
      * create Renderbuffer
      */
      createRenderBuffer(width, height, internalFormat, isMSAA, sampleCountMSAA) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const textureDescriptor = {
          size: [
            width,
            height,
            1
          ],
          format: internalFormat.webgpu,
          sampleCount: isMSAA ? sampleCountMSAA : 1,
          usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT
        };
        const gpuTexture = gpuDevice.createTexture(textureDescriptor);
        const textureHandle = this.__registerResource(gpuTexture);
        return textureHandle;
      }
      /**
      * delete a RenderBuffer
      * @param renderBufferUid
      */
      deleteRenderBuffer(renderBufferUid) {
        this.flush();
        this.clearCache();
        const texture = this.__webGpuResources.get(renderBufferUid);
        if (texture != null) {
          texture.destroy();
          this.__webGpuResources.delete(renderBufferUid);
        }
      }
      /**
      * copy Texture Data
      * @param fromTexture
      * @param toTexture
      */
      copyTextureData(fromTexture, toTexture) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const from32 = this.__webGpuResources.get(fromTexture);
        const to = this.__webGpuResources.get(toTexture);
        if (this.__renderPassEncoder != null) {
          if (this.__renderBundleEncoder != null) {
            this.__renderPassEncoder.executeBundles([
              this.__renderBundleEncoder.finish()
            ]);
          }
          this.__renderPassEncoder.end();
          this.__renderPassEncoder = void 0;
        }
        this.__commandEncoder.copyTextureToTexture({
          texture: from32
        }, {
          texture: to
        }, [
          to.width,
          to.height,
          1
        ]);
      }
      isMippmappedTexture(textureHandle) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const texture = this.__webGpuResources.get(textureHandle);
        if (texture.mipLevelCount > 1) {
          return true;
        } else {
          return false;
        }
      }
      duplicateTextureAsMipmapped(fromTexture) {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const texture = this.__webGpuResources.get(fromTexture);
        const textureDescriptor = {
          size: {
            width: texture.width,
            height: texture.height,
            depthOrArrayLayers: texture.depthOrArrayLayers
          },
          mipLevelCount: Math.floor(Math.log2(Math.max(texture.width, texture.height))) + 1,
          format: texture.format,
          usage: texture.usage
        };
        const newTexture = gpuDevice.createTexture(textureDescriptor);
        if (this.__renderPassEncoder != null) {
          if (this.__renderBundleEncoder != null) {
            this.__renderPassEncoder.executeBundles([
              this.__renderBundleEncoder.finish()
            ]);
          }
          this.__renderPassEncoder.end();
          this.__renderPassEncoder = void 0;
        }
        this.__commandEncoder.copyTextureToTexture({
          texture
        }, {
          texture: newTexture
        }, {
          width: texture.width,
          height: texture.height,
          depthOrArrayLayers: 1
        });
        const textureHandle = this.__registerResource(newTexture);
        const textureViewHandle = this.__registerResource(newTexture.createView());
        return [
          textureHandle,
          textureViewHandle
        ];
      }
      /**
      * attach the DepthBuffer to the FrameBufferObject
      * @param framebuffer a Framebuffer
      * @param renderable a DepthBuffer
      */
      attachDepthBufferToFrameBufferObject(framebuffer, renderable) {
      }
      /**
      * attach the StencilBuffer to the FrameBufferObject
      * @param framebuffer a Framebuffer
      * @param renderable a StencilBuffer
      */
      attachStencilBufferToFrameBufferObject(framebuffer, renderable) {
      }
      /**
      * attach the depthStencilBuffer to the FrameBufferObject
      * @param framebuffer a Framebuffer
      * @param renderable a depthStencilBuffer
      */
      attachDepthStencilBufferToFrameBufferObject(framebuffer, renderable) {
      }
      /**
      * create a FrameBufferObject
      * @returns
      */
      createFrameBufferObject() {
        return -1;
      }
      /**
      * delete a FrameBufferObject
      * @param frameBufferObjectHandle
      */
      deleteFrameBufferObject(frameBufferObjectHandle) {
      }
      /**
      * attach the ColorBuffer to the FrameBufferObject
      * @param framebuffer a Framebuffer
      * @param renderable a ColorBuffer
      */
      attachColorBufferToFrameBufferObject(framebuffer, index, renderable) {
        return;
      }
      /**
      * attach the ColorBuffer to the FrameBufferObject
      * @param framebuffer a Framebuffer
      * @param attachmentIndex a attachment index
      * @param faceIndex a face index
      * @param mipLevel a mip level
      * @param renderable a ColorBuffer
      */
      attachColorBufferCubeToFrameBufferObject(framebuffer, attachmentIndex, faceIndex, mipLevel, renderable) {
      }
      createTextureView2d(textureHandle) {
        const texture = this.__webGpuResources.get(textureHandle);
        const textureView = texture.createView();
        const textureViewHandle = this.__registerResource(textureView);
        return textureViewHandle;
      }
      createTextureViewAsRenderTarget(textureHandle) {
        const texture = this.__webGpuResources.get(textureHandle);
        const textureView = texture.createView({
          baseMipLevel: 0,
          mipLevelCount: 1
        });
        const textureViewHandle = this.__registerResource(textureView);
        return textureViewHandle;
      }
      createTextureViewCube(textureHandle) {
        const texture = this.__webGpuResources.get(textureHandle);
        const textureView = texture.createView({
          dimension: "cube"
        });
        const textureViewHandle = this.__registerResource(textureView);
        return textureViewHandle;
      }
      createCubeTextureViewAsRenderTarget(textureHandle, faceIdx, mipLevel) {
        const texture = this.__webGpuResources.get(textureHandle);
        const textureView = texture.createView({
          dimension: "2d",
          arrayLayerCount: 1,
          baseArrayLayer: faceIdx,
          baseMipLevel: mipLevel,
          mipLevelCount: 1,
          aspect: "all"
        });
        const textureViewHandle = this.__registerResource(textureView);
        return textureViewHandle;
      }
      deleteTexture(textureHandle) {
        this.flush();
        this.clearCache();
        const texture = this.__webGpuResources.get(textureHandle);
        if (texture == null) {
          return;
        }
        {
          this.__srcTextureViewsForGeneratingMipmaps.delete(texture);
          this.__dstTextureViewsForGeneratingMipmaps.delete(texture);
          this.__bindGroupsForGeneratingMipmaps.delete(texture);
        }
        texture.destroy();
        this.__webGpuResources.delete(textureHandle);
      }
      recreateSystemDepthTexture() {
        const gpuDevice = this.__webGpuDeviceWrapper.gpuDevice;
        const canvas = this.__webGpuDeviceWrapper.canvas;
        if (this.__systemDepthTexture != null) {
          this.__systemDepthTexture.destroy();
        }
        this.__systemDepthTexture = gpuDevice.createTexture({
          size: [
            canvas.width,
            canvas.height
          ],
          format: "depth24plus",
          usage: GPUTextureUsage.RENDER_ATTACHMENT
        });
        this.__systemDepthTextureView = this.__systemDepthTexture.createView();
      }
      resizeCanvas(width, height) {
        const canvas = this.__webGpuDeviceWrapper.canvas;
        canvas.width = width;
        canvas.height = height;
        this.recreateSystemDepthTexture();
      }
      setViewport(viewport) {
      }
      isSupportMultiViewVRRendering() {
        return false;
      }
    };
    __name(_WebGpuResourceRepository, "WebGpuResourceRepository");
    __publicField(_WebGpuResourceRepository, "__instance");
    __publicField(_WebGpuResourceRepository, "__drawParametersUint32Array", new Uint32Array(4));
    WebGpuResourceRepository = _WebGpuResourceRepository;
  }
});

// src/foundation/components/Mesh/MeshComponent.ts
var _MeshComponent, MeshComponent;
var init_MeshComponent = __esm({
  "src/foundation/components/Mesh/MeshComponent.ts"() {
    "use strict";
    init_Component();
    init_EntityRepository();
    init_WellKnownComponentTIDs();
    init_ProcessStage();
    init_Vector3();
    init_Vector4();
    init_Matrix44();
    init_MutableMatrix44();
    init_MathClassUtil();
    init_MutableVector3();
    init_Is();
    init_MiscUtil();
    init_Logger();
    _MeshComponent = class _MeshComponent extends Component {
      constructor(entityUid, componentSid, entityRepository, isReUse) {
        super(entityUid, componentSid, entityRepository, isReUse);
        __publicField(this, "__viewDepth", -Number.MAX_VALUE);
        __publicField(this, "__mesh");
        __publicField(this, "isPickable", true);
      }
      static get componentTID() {
        return WellKnownComponentTIDs.MeshComponentTID;
      }
      get componentTID() {
        return WellKnownComponentTIDs.MeshComponentTID;
      }
      setMesh(mesh) {
        this.__mesh = mesh;
        mesh._belongToMeshComponent(this);
      }
      unsetMesh() {
        if (this.__mesh == null) {
          return false;
        }
        this.__mesh = void 0;
        return true;
      }
      get mesh() {
        return this.__mesh;
      }
      calcViewDepth(cameraComponent) {
        if (Is.not.exist(this.__mesh)) {
          return Number.MAX_VALUE;
        }
        const centerPosition_inLocal = this.__mesh.AABB.centerPoint;
        const skeletal = this.entity.tryToGetSkeletal();
        if (Is.exist(skeletal) && Is.exist(skeletal._bindShapeMatrix)) {
          skeletal._bindShapeMatrix.multiplyVector3To(this.__mesh.AABB.centerPoint, centerPosition_inLocal);
        }
        const worldMatrixInner = this.entity.getSceneGraph().matrixInner;
        const centerPosition_inWorld = worldMatrixInner.multiplyVector3To(centerPosition_inLocal, _MeshComponent.__tmpVector3_0);
        const viewMatrix = cameraComponent.viewMatrix;
        const centerPosition_inView = viewMatrix.multiplyVector3To(centerPosition_inWorld, _MeshComponent.__tmpVector3_1);
        this.__viewDepth = centerPosition_inView.z;
        return this.__viewDepth;
      }
      get viewDepth() {
        return this.__viewDepth;
      }
      static alertNoMeshSet(meshComponent) {
        Logger.debug("No mesh is set on this MeshComponent:" + meshComponent.componentSID);
      }
      castRay(srcPointInWorld, directionInWorld, dotThreshold = 0) {
        if (this.__mesh) {
          let srcPointInLocal = srcPointInWorld;
          let directionInLocal = directionInWorld;
          const sceneGraphComponent = this.entity.tryToGetSceneGraph();
          if (sceneGraphComponent != null) {
            const invWorldMatrix = Matrix44.invert(sceneGraphComponent.matrixInner);
            srcPointInLocal = Vector3.fromCopyVector4(invWorldMatrix.multiplyVector(Vector4.fromCopyVector3(srcPointInWorld)));
            const distVecInWorld = Vector3.add(srcPointInWorld, directionInWorld);
            const distVecInLocal = Vector3.fromCopyVector4(invWorldMatrix.multiplyVector(Vector4.fromCopyVector3(distVecInWorld)));
            directionInLocal = Vector3.normalize(Vector3.subtract(distVecInLocal, srcPointInLocal));
            const result = this.__mesh.castRay(srcPointInLocal, directionInLocal, dotThreshold);
            let intersectPositionInWorld = null;
            if (Is.defined(result.data) && result.data.t >= 0) {
              intersectPositionInWorld = Vector3.fromCopyVector4(sceneGraphComponent.matrixInner.multiplyVector(Vector4.fromCopyVector3(result.data.position)));
              return {
                result: true,
                data: {
                  t: result.data.t,
                  u: result.data.u,
                  v: result.data.v,
                  position: intersectPositionInWorld
                }
              };
            }
          }
        }
        return {
          result: false
        };
      }
      castRayFromScreenInLocal(x, y, camera, viewport, dotThreshold = 0) {
        if (this.__mesh) {
          const sceneGraphComponent = this.entity.tryToGetSceneGraph();
          if (sceneGraphComponent != null) {
            const invPVW = MutableMatrix44.multiplyTo(camera.projectionMatrix, camera.viewMatrix, _MeshComponent.__tmpMatrix44_0).multiply(sceneGraphComponent.matrixInner).invert();
            const srcPointInLocal = MathClassUtil.unProjectTo(x, y, 0, invPVW, viewport, _MeshComponent.__tmpVector3_0);
            const distVecInLocal = MathClassUtil.unProjectTo(x, y, 1, invPVW, viewport, _MeshComponent.__tmpVector3_1);
            const directionInLocal = MutableVector3.subtractTo(distVecInLocal, srcPointInLocal, _MeshComponent.__tmpVector3_2).normalize();
            const result = this.__mesh.castRay(srcPointInLocal, directionInLocal, dotThreshold);
            if (Is.defined(result.data) && result.data.t >= 0) {
              return {
                result: true,
                data: {
                  t: result.data.t,
                  u: result.data.u,
                  v: result.data.v,
                  position: result.data.position
                }
              };
            }
          }
        }
        return {
          result: false
        };
      }
      castRayFromScreenInWorld(x, y, camera, viewport, dotThreshold = 0) {
        const result = this.castRayFromScreenInLocal(x, y, camera, viewport, dotThreshold);
        const sceneGraphComponent = this.entity.tryToGetSceneGraph();
        if (this.__mesh && sceneGraphComponent != null && result.result) {
          assertExist(result.data);
          const intersectedPositionInWorld = sceneGraphComponent.matrixInner.multiplyVector3To(result.data.position, _MeshComponent.__returnVector3);
          return {
            result: true,
            data: {
              t: result.data.t,
              u: result.data.u,
              v: result.data.v,
              position: intersectedPositionInWorld
            }
          };
        } else {
          return result;
        }
      }
      $load() {
        if (this.__mesh == null) {
          return;
        }
        this.__mesh._calcTangents();
        this.__mesh._calcFaceNormalsIfNonNormal();
        const blendShapeComponent = this.entity.tryToGetBlendShape();
        if (blendShapeComponent != null && blendShapeComponent.weights.length > 0) {
          this.__mesh._calcBaryCentricCoord();
        }
        this.moveStageTo(ProcessStage.Logic);
      }
      $logic() {
      }
      _shallowCopyFrom(component_) {
        const component = component_;
        this.__viewDepth = component.__viewDepth;
        if (Is.exist(component.__mesh)) {
          this.setMesh(component.__mesh);
        }
        this.isPickable = component.isPickable;
      }
      _destroy() {
        super._destroy();
        if (this.__mesh) {
          this.__mesh = void 0;
        }
      }
      /**
      * get the entity which has this component.
      * @returns the entity which has this component
      */
      get entity() {
        return EntityRepository.getEntity(this.__entityUid);
      }
      /**
      * @override
      * Add this component to the entity
      * @param base the target entity
      * @param _componentClass the component class to add
      */
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let MeshEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
          }
          getMesh() {
            return this.getComponentByComponentTID(WellKnownComponentTIDs.MeshComponentTID);
          }
        }, __name(_a40, "MeshEntity"), _a40);
        applyMixins(base, MeshEntity);
        return base;
      }
    };
    __name(_MeshComponent, "MeshComponent");
    __publicField(_MeshComponent, "__tmpVector3_0", MutableVector3.zero());
    __publicField(_MeshComponent, "__tmpVector3_1", MutableVector3.zero());
    __publicField(_MeshComponent, "__tmpVector3_2", MutableVector3.zero());
    __publicField(_MeshComponent, "__returnVector3", MutableVector3.zero());
    __publicField(_MeshComponent, "__tmpMatrix44_0", MutableMatrix44.zero());
    __publicField(_MeshComponent, "__latestPrimitivePositionAccessorVersion", 0);
    MeshComponent = _MeshComponent;
  }
});

// src/foundation/renderer/RenderingCommonMethods.ts
function isSkipDrawing(material, primitive) {
  if (material.getShaderProgramUid(primitive) === -1) {
    return true;
  } else {
    return false;
  }
}
function updateVBOAndVAO(mesh) {
  const primitiveNum = mesh.getPrimitiveNumber();
  for (let i2 = 0; i2 < primitiveNum; i2++) {
    const primitive = mesh.getPrimitiveAt(i2);
    if (Is.exist(primitive.vertexHandles)) {
      primitive.update3DAPIVertexData();
    } else {
      primitive.create3DAPIVertexData();
    }
  }
  mesh.updateVariationVBO();
  if (SystemState.currentProcessApproach !== ProcessApproach.WebGPU) {
    mesh.updateVAO();
  }
}
var init_RenderingCommonMethods = __esm({
  "src/foundation/renderer/RenderingCommonMethods.ts"() {
    "use strict";
    init_ProcessApproach();
    init_Is();
    init_SystemState();
    __name(isSkipDrawing, "isSkipDrawing");
    __name(updateVBOAndVAO, "updateVBOAndVAO");
  }
});

// src/webgpu/WebGpuStrategyBasic.ts
var _WebGpuStrategyBasic, WebGpuStrategyBasic;
var init_WebGpuStrategyBasic = __esm({
  "src/webgpu/WebGpuStrategyBasic.ts"() {
    "use strict";
    init_MeshComponent();
    init_MeshRendererComponent();
    init_MemoryManager();
    init_BufferUse();
    init_Primitive();
    init_Material();
    init_CGAPIResourceRepository();
    init_RenderingCommonMethods();
    init_WebGpuResourceRepository();
    init_Component();
    init_SceneGraphComponent();
    init_GlobalDataRepository();
    init_MaterialRepository();
    init_CompositionType();
    init_ComponentType();
    init_ModuleManager();
    init_ComponentRepository();
    init_CameraComponent();
    init_Config();
    init_VertexAttribute();
    init_BlendShapeComponent();
    init_CameraControllerComponent();
    init_TransformComponent();
    init_AnimationComponent();
    init_Logger();
    _WebGpuStrategyBasic = class _WebGpuStrategyBasic {
      constructor() {
        __publicField(this, "__storageBufferUid", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__storageBlendShapeBufferUid", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__uniformMorphOffsetsTypedArray");
        __publicField(this, "__uniformMorphWeightsTypedArray");
        __publicField(this, "__lastMaterialsUpdateCount", -1);
        __publicField(this, "__lastTransformComponentsUpdateCount", -1);
        __publicField(this, "__lastSceneGraphComponentsUpdateCount", -1);
        __publicField(this, "__lastCameraComponentsUpdateCount", -1);
        __publicField(this, "__lastCameraControllerComponentsUpdateCount", -1);
        __publicField(this, "__lastBlendShapeComponentsUpdateCountForWeights", -1);
        __publicField(this, "__lastBlendShapeComponentsUpdateCountForBlendData", -1);
      }
      static getInstance() {
        if (!this.__instance) {
          this.__instance = new _WebGpuStrategyBasic();
        }
        return this.__instance;
      }
      static getVertexShaderMethodDefinitions_storageBuffer() {
        return `
fn get_worldMatrix(instanceId: u32) -> mat4x4<f32>
{
  let index: u32 = ${Component.getLocationOffsetOfMemberOfComponent(SceneGraphComponent, "worldMatrix")}u + 4u * instanceId;
  let matrix = fetchMat4(index);

  return matrix;
}

fn get_normalMatrix(instanceId: u32) -> mat3x3<f32> {
  let index: u32 = ${Component.getLocationOffsetOfMemberOfComponent(SceneGraphComponent, "normalMatrix")}u * 4 + 9 * instanceId;
  let matrix = fetchMat3No16BytesAligned(index);

  return matrix;
}

fn get_isVisible(instanceId: u32) -> bool {
  let index: u32 = ${Component.getLocationOffsetOfMemberOfComponent(SceneGraphComponent, "isVisible")}u * 4u + instanceId;
  let visibility = fetchScalarNo16BytesAligned(index);
  if (visibility > 0.5) {
    return true;
  } else {
    return false;
  }
}

#ifdef RN_IS_VERTEX_SHADER
  #ifdef RN_IS_MORPHING
  fn get_position(vertexId: u32, basePosition: vec3<f32>, blendShapeComponentSID: u32) -> vec3<f32> {
    var position = basePosition;
    let scalar_idx = 3u * vertexId;
    for (var i=0u; i<uniformDrawParameters.morphTargetNumber; i++) {
      let currentPrimitiveIdx = uniformDrawParameters.currentPrimitiveIdx;
      let idx = ${Config.maxVertexMorphNumberInShader}u * currentPrimitiveIdx + i;
      let offsets = uniformMorphOffsets.data[ idx / 4u];
      let offsetPosition = offsets[idx % 4u];

      let basePosIn4bytes = offsetPosition * 4u + scalar_idx;
      let addPos = fetchVec3No16BytesAlignedFromBlendShapeBuffer(basePosIn4bytes);

      let idx2 = ${Config.maxVertexMorphNumberInShader}u * blendShapeComponentSID + i;
      let morphWeights: vec4f = uniformMorphWeights.data[ idx2 / 4u];
      let morphWeight: f32 = morphWeights[idx2 % 4u];
      position += addPos * morphWeight;
    }

    return position;
  }
  #endif
#endif

`;
      }
      static __getShaderProperty(materialTypeName, info, isGlobalData) {
        var _a40, _b;
        const returnType = info.compositionType.toWGSLType(info.componentType);
        const methodName = info.semantic.replace(".", "_");
        const isTexture2 = CompositionType.isTexture(info.compositionType);
        if (isTexture2) {
          const isCubeMap = info.compositionType === CompositionType.TextureCube;
          const textureType = isCubeMap ? "texture_cube<f32>" : "texture_2d<f32>";
          const samplerName = methodName.replace("Texture", "Sampler");
          return `
@group(1) @binding(${info.initialValue[0]}) var ${methodName}: ${textureType};
@group(2) @binding(${info.initialValue[0]}) var ${samplerName}: sampler;
`;
        }
        const vec4SizeOfProperty = info.compositionType.getVec4SizeOfProperty();
        const scalarSizeOfProperty = info.compositionType.getNumberOfComponents();
        const offsetOfProperty = _WebGpuStrategyBasic.getOffsetOfPropertyInShader(isGlobalData, info.semantic, materialTypeName);
        if (offsetOfProperty === -1) {
          Logger.error("Could not get the location offset of the property.");
        }
        let indexStr;
        let instanceSize = vec4SizeOfProperty;
        indexStr = `  let vec4_idx: u32 = ${offsetOfProperty}u + ${instanceSize}u * instanceId;
`;
        if (CompositionType.isArray(info.compositionType)) {
          instanceSize = vec4SizeOfProperty * ((_a40 = info.arrayLength) != null ? _a40 : 1);
          const paddedAsVec4 = Math.ceil(scalarSizeOfProperty / 4) * 4;
          const instanceSizeInScalar = paddedAsVec4 * ((_b = info.arrayLength) != null ? _b : 1);
          indexStr = `  let vec4_idx: u32 = ${offsetOfProperty}u + ${instanceSize} * instanceId + ${vec4SizeOfProperty}u * idxOfArray;
`;
          indexStr += `  let scalar_idx: u32 = ${// IndexOf4Bytes
          offsetOfProperty * 4} + ${instanceSizeInScalar} * instanceId + ${scalarSizeOfProperty}u * idxOfArray;
`;
        }
        const firstPartOfInnerFunc = `
fn get_${methodName}(instanceId: u32, idxOfArray: u32) -> ${returnType} {
${indexStr}
`;
        let str = `${firstPartOfInnerFunc}`;
        switch (info.compositionType) {
          case CompositionType.Vec4:
          case CompositionType.Vec4Array:
            str += "  let val = fetchElement(vec4_idx);\n";
            break;
          case CompositionType.Vec3:
            str += "  let col0 = fetchElement(vec4_idx);\n";
            str += `  let val = ${returnType}(col0.xyz);`;
            break;
          case CompositionType.Vec3Array:
            str += "  let val = fetchVec3No16BytesAligned(scalar_idx);\n";
            break;
          case CompositionType.Vec2:
            str += "  let col0 = fetchElement(vec4_idx);\n";
            str += `  let val = ${returnType}(col0.xy);`;
            break;
          case CompositionType.Vec2Array:
            str += "  let val = fetchVec2No16BytesAligned(scalar_idx);\n";
            break;
          case CompositionType.Scalar:
            str += "  let col0 = fetchElement(vec4_idx);\n";
            if (info.componentType === ComponentType.Int) {
              str += `  let val = i32(col0.x);`;
            } else if (info.componentType === ComponentType.UnsignedInt) {
              str += "  let val = u32(col0.x);";
            } else if (info.componentType === ComponentType.Bool) {
              str += `  let val = col0.x >= 0.5;`;
            } else {
              str += "  let val = col0.x;";
            }
            break;
          case CompositionType.ScalarArray:
            str += "  let col0 = fetchScalarNo16BytesAligned(scalar_idx);\n";
            if (info.componentType === ComponentType.Int) {
              str += "  let val = i32(col0);";
            } else if (info.componentType === ComponentType.UnsignedInt) {
              str += "  let val = u32(col0);";
            } else if (info.componentType === ComponentType.Bool) {
              str += "  let val = col0 >= 0.5;";
            } else {
              str += "  let val = col0;";
            }
            break;
          case CompositionType.Mat4:
            str += "  let val = fetchMat4(vec4_idx);\n";
            break;
          case CompositionType.Mat4Array:
            str += "  let val = fetchMat4(vec4_idx);\n";
            break;
          case CompositionType.Mat3:
            str += "  let val = fetchMat3(vec4_idx);\n";
            break;
          case CompositionType.Mat3Array:
            str += "  let val = fetchMat3No16BytesAligned(scalar_idx);\n";
            break;
          case CompositionType.Mat2:
            str += "  let val = fetchMat2(vec4_idx);\n";
            break;
          case CompositionType.Mat2Array:
            str += "  let val = fetchMat2No16BytesAligned(scalar_idx);\n";
            break;
          case CompositionType.Mat4x3Array:
            str += "  let val = fetchMat4x3(vec4_idx);\n";
            break;
          default:
            str += "";
        }
        str += `
  return val;
}
`;
        return str;
      }
      static getOffsetOfPropertyInShader(isGlobalData, propertyName, materialTypeName) {
        if (isGlobalData) {
          const globalDataRepository = GlobalDataRepository.getInstance();
          const dataBeginPos = globalDataRepository.getLocationOffsetOfProperty(propertyName);
          return dataBeginPos;
        } else {
          const dataBeginPos = MaterialRepository.getLocationOffsetOfMemberOfMaterial(materialTypeName, propertyName);
          return dataBeginPos;
        }
      }
      $load(meshComponent) {
        const mesh = meshComponent.mesh;
        if (mesh == null) {
          return false;
        }
        if (!mesh.isSetUpDone()) {
          updateVBOAndVAO(mesh);
        }
        return true;
      }
      common_$load() {
        if (this.__uniformMorphOffsetsTypedArray == null) {
          this.__uniformMorphOffsetsTypedArray = new Uint32Array(Math.ceil(Config.maxVertexPrimitiveNumberInShader * Config.maxVertexMorphNumberInShader / 4) * 4);
        }
        if (this.__uniformMorphWeightsTypedArray == null) {
          this.__uniformMorphWeightsTypedArray = new Float32Array(Math.ceil(Config.maxVertexPrimitiveNumberInShader * Config.maxVertexMorphNumberInShader / 4) * 4);
        }
        if (BlendShapeComponent.updateCount !== this.__lastBlendShapeComponentsUpdateCountForBlendData) {
          this.__createOrUpdateStorageBlendShapeBuffer();
          this.__lastBlendShapeComponentsUpdateCountForBlendData = BlendShapeComponent.updateCount;
        }
      }
      __setupShaderProgramForMeshComponent(meshComponent) {
        if (meshComponent.mesh == null) {
          MeshComponent.alertNoMeshSet(meshComponent);
          return;
        }
        const primitiveNum = meshComponent.mesh.getPrimitiveNumber();
        for (let i2 = 0; i2 < primitiveNum; i2++) {
          const primitive = meshComponent.mesh.getPrimitiveAt(i2);
          const material = primitive.material;
          this._setupShaderProgram(material, primitive);
        }
      }
      _setupShaderProgram(material, primitive) {
        if (material == null) {
          return;
        }
        if (material.isShaderProgramReady(primitive)) {
          return;
        }
        try {
          this.setupShaderForMaterial(material, primitive, _WebGpuStrategyBasic.getVertexShaderMethodDefinitions_storageBuffer(), _WebGpuStrategyBasic.__getShaderProperty);
          primitive._backupMaterial();
        } catch (e3) {
          Logger.error(e3);
          primitive._restoreMaterial();
          this.setupShaderForMaterial(primitive.material, primitive, _WebGpuStrategyBasic.getVertexShaderMethodDefinitions_storageBuffer(), _WebGpuStrategyBasic.__getShaderProperty);
        }
      }
      /**
      * setup shader program for the material in this WebGL strategy
      * @param material - a material to setup shader program
      */
      setupShaderForMaterial(material, primitive, vertexShaderMethodDefinitions, propertySetter) {
        material._createProgramWebGpu(primitive, vertexShaderMethodDefinitions, propertySetter);
      }
      renderWithRenderBundle(renderPass) {
        const webGpuResourceRepository = WebGpuResourceRepository.getInstance();
        return webGpuResourceRepository.executeRenderBundle(renderPass);
      }
      prerender() {
        if (AnimationComponent.isAnimating || TransformComponent.updateCount !== this.__lastTransformComponentsUpdateCount || SceneGraphComponent.updateCount !== this.__lastSceneGraphComponentsUpdateCount || Material.stateVersion !== this.__lastMaterialsUpdateCount) {
          this.__createAndUpdateStorageBuffer();
          this.__lastTransformComponentsUpdateCount = TransformComponent.updateCount;
          this.__lastSceneGraphComponentsUpdateCount = SceneGraphComponent.updateCount;
          this.__lastMaterialsUpdateCount = Material.stateVersion;
        } else if (CameraComponent.currentCameraUpdateCount !== this.__lastCameraComponentsUpdateCount || CameraControllerComponent.updateCount !== this.__lastCameraControllerComponentsUpdateCount) {
          this.__createAndUpdateStorageBufferForCameraOnly();
          this.__lastCameraComponentsUpdateCount = CameraComponent.currentCameraUpdateCount;
          this.__lastCameraControllerComponentsUpdateCount = CameraControllerComponent.updateCount;
        }
        if (BlendShapeComponent.updateCount !== this.__lastBlendShapeComponentsUpdateCountForWeights) {
          this.__updateUniformMorph();
          this.__lastBlendShapeComponentsUpdateCountForWeights = BlendShapeComponent.updateCount;
        }
      }
      common_$render(primitiveUids, renderPass, renderPassTickCount) {
        if (renderPass.isBufferLessRenderingMode()) {
          this.__renderWithoutBuffers(renderPass);
          return true;
        }
        let renderedSomething = false;
        const isZWrite = renderPass.isDepthTest && renderPass.depthWriteMask;
        const isZWrite2 = renderPass.isDepthTest && renderPass.depthWriteMask && MeshRendererComponent.isDepthMaskTrueForBlendPrimitives;
        if (renderPass._toRenderOpaquePrimitives) {
          for (let i2 = 0; i2 <= renderPass._lastOpaqueIndex; i2++) {
            const primitiveUid = primitiveUids[i2];
            const rendered = this.renderInner(primitiveUid, renderPass, isZWrite);
            renderedSomething || (renderedSomething = rendered);
          }
        }
        if (renderPass._toRenderTranslucentPrimitives) {
          for (let i2 = renderPass._lastOpaqueIndex + 1; i2 <= renderPass._lastTranslucentIndex; i2++) {
            const primitiveUid = primitiveUids[i2];
            const rendered = this.renderInner(primitiveUid, renderPass, isZWrite);
            renderedSomething || (renderedSomething = rendered);
          }
        }
        if (renderPass._toRenderBlendWithZWritePrimitives) {
          for (let i2 = renderPass._lastTranslucentIndex + 1; i2 <= renderPass._lastBlendWithZWriteIndex; i2++) {
            const primitiveUid = primitiveUids[i2];
            const rendered = this.renderInner(primitiveUid, renderPass, isZWrite);
            renderedSomething || (renderedSomething = rendered);
          }
        }
        if (renderPass._toRenderBlendWithoutZWritePrimitives) {
          for (let i2 = renderPass._lastBlendWithZWriteIndex + 1; i2 <= renderPass._lastBlendWithoutZWriteIndex; i2++) {
            const primitiveUid = primitiveUids[i2];
            const rendered = this.renderInner(primitiveUid, renderPass, isZWrite2);
            renderedSomething || (renderedSomething = rendered);
          }
        }
        return renderedSomething;
      }
      __renderWithoutBuffers(renderPass) {
        const material = renderPass.material;
        const primitive = renderPass._dummyPrimitiveForBufferLessRendering;
        this._setupShaderProgram(material, primitive);
        const webGpuResourceRepository = WebGpuResourceRepository.getInstance();
        webGpuResourceRepository.updateUniformBufferForDrawParameters(`${renderPass.renderPassUID}-${primitive.primitiveUid}`, material.materialSID, 0, 0, 0);
        webGpuResourceRepository.draw(primitive, material, renderPass, 0, true);
      }
      renderInner(primitiveUid, renderPass, zWrite) {
        var _a40;
        if (primitiveUid === -1) {
          return false;
        }
        const primitive = Primitive.getPrimitive(primitiveUid);
        if (primitive == null) {
          return false;
        }
        const material = renderPass.getAppropriateMaterial(primitive);
        this._setupShaderProgram(material, primitive);
        if (isSkipDrawing(material, primitive)) {
          return false;
        }
        const webGpuResourceRepository = WebGpuResourceRepository.getInstance();
        const cameraSID = this.__getAppropriateCameraComponentSID(renderPass, 0, false);
        const primitiveIdxHasMorph = (_a40 = Primitive.getPrimitiveIdxHasMorph(primitive.primitiveUid)) != null ? _a40 : 0;
        webGpuResourceRepository.updateUniformBufferForDrawParameters(`${renderPass.renderPassUID}-${primitive.primitiveUid}`, material.materialSID, cameraSID, primitiveIdxHasMorph, primitive.targets.length);
        webGpuResourceRepository.draw(primitive, material, renderPass, cameraSID, zWrite);
        return true;
      }
      __createAndUpdateStorageBuffer() {
        const memoryManager = MemoryManager.getInstance();
        const gpuInstanceDataBuffer = memoryManager.getBuffer(BufferUse.GPUInstanceData);
        const webGpuResourceRepository = WebGpuResourceRepository.getInstance();
        const float32Array = new Float32Array(gpuInstanceDataBuffer.getArrayBuffer());
        if (this.__storageBufferUid !== CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          const dataSizeForDataTexture = gpuInstanceDataBuffer.takenSizeInByte / 4;
          webGpuResourceRepository.updateStorageBuffer(this.__storageBufferUid, float32Array, dataSizeForDataTexture);
        } else {
          this.__storageBufferUid = webGpuResourceRepository.createStorageBuffer(float32Array);
        }
      }
      __createAndUpdateStorageBufferForCameraOnly() {
        const memoryManager = MemoryManager.getInstance();
        const gpuInstanceDataBuffer = memoryManager.getBuffer(BufferUse.GPUInstanceData);
        const webGpuResourceRepository = WebGpuResourceRepository.getInstance();
        const globalDataRepository = GlobalDataRepository.getInstance();
        const float32Array = new Float32Array(gpuInstanceDataBuffer.getArrayBuffer());
        if (this.__storageBufferUid !== CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          const offsetOfStorageBuffer = globalDataRepository.getLocationOffsetOfProperty("viewMatrix") * 16;
          const offsetOfFloat32Array = offsetOfStorageBuffer / 4;
          const positionOfBoneMatrix = globalDataRepository.getLocationOffsetOfProperty("boneMatrix") * 16 / 4;
          webGpuResourceRepository.updateStorageBufferPartially(this.__storageBufferUid, float32Array, offsetOfStorageBuffer, offsetOfFloat32Array, positionOfBoneMatrix - offsetOfFloat32Array);
        } else {
          this.__storageBufferUid = webGpuResourceRepository.createStorageBuffer(float32Array);
        }
      }
      __createOrUpdateStorageBlendShapeBuffer() {
        const memoryManager = MemoryManager.getInstance();
        const blendShapeDataBuffer = memoryManager.getBuffer(BufferUse.GPUVertexData);
        if (blendShapeDataBuffer == null) {
          return;
        }
        const webGpuResourceRepository = WebGpuResourceRepository.getInstance();
        const float32Array = new Float32Array(blendShapeDataBuffer.getArrayBuffer());
        if (this.__storageBlendShapeBufferUid !== CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          const componentSizeForDataTexture = blendShapeDataBuffer.takenSizeInByte / 4;
          webGpuResourceRepository.updateStorageBlendShapeBuffer(this.__storageBlendShapeBufferUid, float32Array, componentSizeForDataTexture);
        } else {
          this.__storageBlendShapeBufferUid = webGpuResourceRepository.createStorageBlendShapeBuffer(float32Array);
        }
        let i2 = 0;
        for (; i2 < Config.maxVertexPrimitiveNumberInShader; i2++) {
          const primitive = Primitive.getPrimitiveHasMorph(i2);
          if (primitive != null) {
            for (let j = 0; j < primitive.targets.length; j++) {
              const target = primitive.targets[j];
              const accessor = target.get(VertexAttribute.Position.XYZ);
              this.__uniformMorphOffsetsTypedArray[Config.maxVertexMorphNumberInShader * i2 + j] = accessor.byteOffsetInBuffer / 4 / 4;
            }
          } else {
            break;
          }
        }
        const elementNumToCopy = Config.maxVertexMorphNumberInShader * i2;
        webGpuResourceRepository.updateUniformMorphOffsetsBuffer(this.__uniformMorphOffsetsTypedArray, elementNumToCopy);
      }
      __updateUniformMorph() {
        const memoryManager = MemoryManager.getInstance();
        const blendShapeDataBuffer = memoryManager.getBuffer(BufferUse.GPUVertexData);
        if (blendShapeDataBuffer == null) {
          return;
        }
        const webGpuResourceRepository = WebGpuResourceRepository.getInstance();
        const blendShapeComponents = ComponentRepository.getComponentsWithType(BlendShapeComponent);
        for (let i2 = 0; i2 < blendShapeComponents.length; i2++) {
          const blendShapeComponent = blendShapeComponents[i2];
          const weights = blendShapeComponent.weights;
          for (let j = 0; j < weights.length; j++) {
            this.__uniformMorphWeightsTypedArray[Config.maxVertexMorphNumberInShader * blendShapeComponent.componentSID + j] = weights[j];
          }
        }
        if (blendShapeComponents.length > 0) {
          const elementNumToCopy = Config.maxVertexMorphNumberInShader * blendShapeComponents.length;
          webGpuResourceRepository.updateUniformMorphWeightsBuffer(this.__uniformMorphWeightsTypedArray, elementNumToCopy);
        }
      }
      __getAppropriateCameraComponentSID(renderPass, displayIdx, isVRMainPass) {
        if (isVRMainPass) {
          const rnXRModule = ModuleManager.getInstance().getModule("xr");
          const webxrSystem = rnXRModule.WebXRSystem.getInstance();
          let cameraComponentSid = -1;
          if (webxrSystem.isWebXRMode) {
            if (webxrSystem.isMultiView()) {
              cameraComponentSid = webxrSystem._getCameraComponentSIDAt(0);
            } else {
              cameraComponentSid = webxrSystem._getCameraComponentSIDAt(displayIdx);
            }
          }
          return cameraComponentSid;
        } else {
          let cameraComponent = renderPass.cameraComponent;
          if (cameraComponent == null) {
            cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
          }
          if (cameraComponent) {
            return cameraComponent.componentSID;
          } else {
            return -1;
          }
        }
      }
    };
    __name(_WebGpuStrategyBasic, "WebGpuStrategyBasic");
    __publicField(_WebGpuStrategyBasic, "__instance");
    WebGpuStrategyBasic = _WebGpuStrategyBasic;
  }
});

// version:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/VERSION-FILE
var VERSION_FILE_default;
var init_VERSION_FILE = __esm({
  "version:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/VERSION-FILE"() {
    VERSION_FILE_default = { version: "v0.14.2-8-g477103316-dirty", branch: "refactor/tsup2" };
  }
});

// src/version.ts
var VERSION;
var init_version = __esm({
  "src/version.ts"() {
    "use strict";
    init_VERSION_FILE();
    VERSION = VERSION_FILE_default;
  }
});

// src/foundation/components/Camera/createCameraEntity.ts
function createCameraEntity() {
  const entity = createGroupEntity();
  const entityAddedComponent = EntityRepository.tryToAddComponentToEntityByTID(WellKnownComponentTIDs.CameraComponentTID, entity);
  return entityAddedComponent;
}
var init_createCameraEntity = __esm({
  "src/foundation/components/Camera/createCameraEntity.ts"() {
    "use strict";
    init_EntityRepository();
    init_createGroupEntity();
    init_WellKnownComponentTIDs();
    __name(createCameraEntity, "createCameraEntity");
  }
});

// src/foundation/system/System.ts
var _System, System;
var init_System = __esm({
  "src/foundation/system/System.ts"() {
    "use strict";
    init_ProcessStage();
    init_ComponentRepository();
    init_ProcessApproach();
    init_ModuleManager();
    init_CGAPIResourceRepository();
    init_Component();
    init_Expression();
    init_EntityRepository();
    init_MemoryManager();
    init_GlobalDataRepository();
    init_Vector3();
    init_CameraType();
    init_Time();
    init_SystemState();
    init_MiscUtil();
    init_Is();
    init_Config();
    init_Frame();
    init_Vector4();
    init_RenderPass();
    init_WellKnownComponentTIDs();
    init_DummyTextures();
    init_WebGpuResourceRepository();
    init_WebGpuStrategyBasic();
    init_CameraComponent();
    init_AnimationComponent();
    init_CameraControllerComponent();
    init_MeshRendererComponent();
    init_TransformComponent();
    init_Primitive();
    init_version();
    init_createCameraEntity();
    init_Logger();
    _System = class _System {
      constructor() {
      }
      /**
      * Starts a render loop.
      *
      * @example
      * ```
      * Rn.System.startRenderLoop((time, _myArg1, _myArg2) => {
      *   Rn.System.process([expression]);
      * }, myArg1, myArg2);
      * ```
      *
      * @param renderLoopFunc - function to be called in each frame
      * @param args - arguments you want to be passed to renderLoopFunc
      */
      static startRenderLoop(renderLoopFunc, ...args) {
        this.__renderLoopFunc = renderLoopFunc;
        this.__args = args;
        const animationFrameObject = this.__getAnimationFrameObject();
        if (this.__rnXRModule === void 0) {
          this.__rnXRModule = ModuleManager.getInstance().getModule("xr");
        }
        this.__animationFrameId = animationFrameObject.requestAnimationFrame((_time, xrFrame) => {
          if (this.__rnXRModule !== void 0) {
            const webXRSystem = this.__rnXRModule.WebXRSystem.getInstance();
            const webARSystem = this.__rnXRModule.WebARSystem.getInstance();
            if (webXRSystem.isReadyForWebXR) {
              webXRSystem._preRender(_time, xrFrame);
              renderLoopFunc.apply(renderLoopFunc, [
                _time,
                ...args
              ]);
              webXRSystem._postRender();
            } else if (webARSystem.isReadyForWebAR) {
              webARSystem._preRender(_time, xrFrame);
              renderLoopFunc.apply(renderLoopFunc, [
                _time,
                ...args
              ]);
              webARSystem._preRender(_time, xrFrame);
            } else {
              renderLoopFunc.apply(renderLoopFunc, [
                _time,
                ...args
              ]);
            }
          } else {
            renderLoopFunc.apply(renderLoopFunc, [
              _time,
              ...args
            ]);
          }
          this.startRenderLoop(renderLoopFunc, ...args);
        });
      }
      static __getAnimationFrameObject() {
        let animationFrameObject = window;
        const rnXRModule = ModuleManager.getInstance().getModule("xr");
        if (Is.exist(rnXRModule)) {
          const webXRSystem = rnXRModule.WebXRSystem.getInstance();
          const webARSystem = rnXRModule.WebARSystem.getInstance();
          if (webXRSystem.requestedToEnterWebXR) {
            animationFrameObject = webXRSystem.xrSession;
          } else if (webARSystem.requestedToEnterWebAR) {
            animationFrameObject = webARSystem.arSession;
          }
          if (Is.not.exist(animationFrameObject)) {
            return window;
          }
        }
        return animationFrameObject;
      }
      /**
      * Stops a existing render loop.
      */
      static stopRenderLoop() {
        const animationFrameObject = this.__getAnimationFrameObject();
        animationFrameObject.cancelAnimationFrame(this.__animationFrameId);
        this.__animationFrameId = -1;
      }
      /**
      * Restart a render loop.
      */
      static restartRenderLoop() {
        if (this.__renderLoopFunc != null) {
          this.startRenderLoop(this.__renderLoopFunc, 0, this.__args);
        }
      }
      /**
      * A Simple version of process method
      *
      * @remarks
      * No need to create expressions and renderPasses and to register entities, etc...
      * It's suitable for simple use cases like sample apps.
      *
      * @param clearColor - color to clear the canvas
      */
      static processAuto(clearColor = Vector4.fromCopy4(0, 0, 0, 1)) {
        if (Is.not.exist(_System.__expressionForProcessAuto)) {
          const expression = new Expression();
          const renderPassInit = new RenderPass();
          renderPassInit.toClearColorBuffer = true;
          renderPassInit.toClearDepthBuffer = true;
          renderPassInit.clearColor = clearColor;
          const renderPassMain = new RenderPass();
          expression.addRenderPasses([
            renderPassInit,
            renderPassMain
          ]);
          _System.__expressionForProcessAuto = expression;
          _System.__renderPassForProcessAuto = renderPassMain;
        }
        _System.__renderPassForProcessAuto.clearEntities();
        const entities = EntityRepository._getEntities();
        _System.__renderPassForProcessAuto.addEntities(entities);
        this.process([
          _System.__expressionForProcessAuto
        ]);
      }
      static process(value) {
        var _a40;
        Time._processBegin();
        let expressions = value;
        if (value instanceof Frame) {
          expressions = value.expressions;
        }
        if (CameraComponent.current === Component.InvalidObjectUID) {
          _System.createCamera();
        }
        const time = GlobalDataRepository.getInstance().getValue("time", 0);
        time._v[0] = Time.timeFromSystemStart;
        if (this.processApproach === ProcessApproach.WebGPU) {
          const componentTids = ComponentRepository.getComponentTIDs();
          const webGpuResourceRepository = WebGpuResourceRepository.getInstance();
          for (const stage of Component._processStages) {
            const methodName = stage.methodName;
            const commonMethodName = "common_" + methodName;
            if (stage === ProcessStage.Render) {
              const webGpuStrategyBasic = WebGpuStrategyBasic.getInstance();
              MeshRendererComponent.common_$prerender();
              for (const exp of expressions) {
                for (const renderPass of exp.renderPasses) {
                  this.__cgApiResourceRepository.clearFrameBuffer(renderPass);
                  renderPass._isChangedSortRenderResult = false;
                  const primitiveUids = MeshRendererComponent.sort_$render(renderPass);
                  let doRender = renderPass._renderedSomethingBefore;
                  if (doRender) {
                    doRender = !webGpuStrategyBasic.renderWithRenderBundle(renderPass);
                    (_a40 = SystemState).webgpuRenderBundleMode || (_a40.webgpuRenderBundleMode = doRender);
                  }
                  if (doRender) {
                    const renderedSomething = MeshRendererComponent.common_$render({
                      renderPass,
                      processStage: stage,
                      renderPassTickCount: this.__renderPassTickCount,
                      primitiveUids
                    });
                    renderPass._renderedSomethingBefore = renderedSomething;
                    if (renderedSomething) {
                      webGpuResourceRepository.finishRenderBundleEncoder(renderPass);
                    }
                  }
                  renderPass._copyResolve1ToResolve2WebGpu();
                  renderPass.doPostRender();
                  this.__renderPassTickCount++;
                }
              }
              webGpuResourceRepository.flush();
            } else {
              if (!SystemState.webgpuRenderBundleMode || AnimationComponent.isAnimating || TransformComponent.updateCount !== this.__lastTransformComponentsUpdateCount || CameraComponent.currentCameraUpdateCount !== this.__lastCameraComponentsUpdateCount || CameraControllerComponent.updateCount !== this.__lastCameraControllerComponentsUpdateCount || Primitive.getPrimitiveCount() !== this.__lastPrimitiveCount) {
                for (const componentTid of componentTids) {
                  const componentClass = ComponentRepository.getComponentClass(componentTid);
                  const componentClass_commonMethod = componentClass[commonMethodName];
                  if (componentClass_commonMethod) {
                    componentClass_commonMethod({
                      processApproach: this.__processApproach,
                      renderPass: void 0,
                      processStage: stage,
                      renderPassTickCount: this.__renderPassTickCount
                    });
                  }
                  componentClass.process(componentClass, stage);
                }
              }
            }
          }
          this.__lastCameraComponentsUpdateCount = CameraComponent.currentCameraUpdateCount;
          this.__lastCameraControllerComponentsUpdateCount = CameraControllerComponent.updateCount;
          this.__lastTransformComponentsUpdateCount = TransformComponent.updateCount;
          this.__lastPrimitiveCount = Primitive.getPrimitiveCount();
        } else {
          const repo = CGAPIResourceRepository.getWebGLResourceRepository();
          const rnXRModule = ModuleManager.getInstance().getModule("xr");
          const componentTids = ComponentRepository.getComponentTIDs();
          const renderingComponentTids = ComponentRepository.getRenderingComponentTIDs();
          for (const stage of Component._processStages) {
            const methodName = stage.methodName;
            const commonMethodName = "common_" + methodName;
            if (stage === ProcessStage.Render) {
              MeshRendererComponent.common_$prerender();
              for (const exp of expressions) {
                for (const componentTid of renderingComponentTids) {
                  const componentClass = ComponentRepository.getComponentClass(componentTid);
                  for (const renderPass of exp.renderPasses) {
                    if (typeof spector !== "undefined") {
                      spector.setMarker(`| ${exp.uniqueName}: ${renderPass.uniqueName}#`);
                    }
                    repo.switchDepthTest(renderPass.isDepthTest);
                    if (componentTid === WellKnownComponentTIDs.MeshRendererComponentTID) {
                      _System.bindFramebufferWebGL(renderPass, rnXRModule);
                      _System.setViewportForNormalRendering(renderPass, rnXRModule);
                    }
                    if (componentTid === WellKnownComponentTIDs.MeshRendererComponentTID) {
                      this.__cgApiResourceRepository.clearFrameBuffer(renderPass);
                    }
                    renderPass._isChangedSortRenderResult = false;
                    const primitiveUids = MeshRendererComponent.sort_$render(renderPass);
                    let doRender = renderPass._renderedSomethingBefore;
                    if (doRender) {
                      const componentClass_commonMethod = componentClass[commonMethodName];
                      if (componentClass_commonMethod) {
                        const renderedSomething = componentClass_commonMethod({
                          processApproach: this.__processApproach,
                          renderPass,
                          processStage: stage,
                          renderPassTickCount: this.__renderPassTickCount,
                          primitiveUids
                        });
                        renderPass._renderedSomethingBefore = renderedSomething;
                      }
                      if (componentTid !== WellKnownComponentTIDs.MeshRendererComponentTID) {
                        componentClass.process(componentClass, stage);
                      }
                    }
                    this.__renderPassTickCount++;
                    renderPass._copyFramebufferToResolveFramebuffersWebGL();
                    renderPass.doPostRender();
                  }
                }
              }
            } else {
              if (AnimationComponent.isAnimating || TransformComponent.updateCount !== this.__lastTransformComponentsUpdateCount || CameraComponent.currentCameraUpdateCount !== this.__lastCameraComponentsUpdateCount || CameraControllerComponent.updateCount !== this.__lastCameraControllerComponentsUpdateCount || Primitive.getPrimitiveCount() !== this.__lastPrimitiveCount) {
                for (const componentTid of componentTids) {
                  const componentClass = ComponentRepository.getComponentClass(componentTid);
                  const componentClass_commonMethod = componentClass[commonMethodName];
                  if (componentClass_commonMethod) {
                    componentClass_commonMethod({
                      processApproach: this.__processApproach,
                      renderPass: void 0,
                      processStage: stage,
                      renderPassTickCount: this.__renderPassTickCount
                    });
                  }
                  componentClass.process(componentClass, stage);
                }
              }
            }
          }
          this.__lastCameraComponentsUpdateCount = CameraComponent.currentCameraUpdateCount;
          this.__lastCameraControllerComponentsUpdateCount = CameraControllerComponent.updateCount;
          this.__lastTransformComponentsUpdateCount = TransformComponent.updateCount;
          this.__lastPrimitiveCount = Primitive.getPrimitiveCount();
        }
        Time._processEnd();
      }
      static get processTime() {
        return Time.lastTimeTimeIntervalInMilliseconds;
      }
      static get timeAtProcessBegin() {
        return Time.timeAtProcessBeginMilliseconds;
      }
      static get timeAtProcessEnd() {
        return Time.timeAtProcessEndMilliseconds;
      }
      static createCamera() {
        const cameraEntity = createCameraEntity();
        cameraEntity.getTransform().localPosition = Vector3.fromCopyArray([
          0,
          0,
          1
        ]);
        cameraEntity.getCamera().type = CameraType.Orthographic;
        cameraEntity.getCamera().zNear = 0.1;
        cameraEntity.getCamera().zFar = 1e4;
        const webCGApiRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        const [width, height] = webCGApiRepository.getCanvasSize();
        cameraEntity.getCamera().xMag = width / height;
        cameraEntity.getCamera().yMag = 1;
      }
      static setViewportForNormalRendering(renderPass, rnXRModule) {
        const webXRSystem = rnXRModule == null ? void 0 : rnXRModule.WebXRSystem.getInstance();
        const webARSystem = rnXRModule == null ? void 0 : rnXRModule.WebARSystem.getInstance();
        if ((!(webXRSystem == null ? void 0 : webXRSystem.isWebXRMode) || !renderPass.isVrRendering) && !(webARSystem == null ? void 0 : webARSystem.isWebARMode)) {
          this.__cgApiResourceRepository.setViewport(renderPass.getViewport());
        }
      }
      static bindFramebufferWebGL(renderPass, rnXRModule) {
        const webXRSystem = rnXRModule == null ? void 0 : rnXRModule.WebXRSystem.getInstance();
        const webARSystem = rnXRModule == null ? void 0 : rnXRModule.WebARSystem.getInstance();
        if ((webXRSystem == null ? void 0 : webXRSystem.isWebXRMode) && renderPass.isOutputForVr) {
          const glw = this.__cgApiResourceRepository.currentWebGLContextWrapper;
          const gl = glw.getRawContext();
          gl.bindFramebuffer(gl.FRAMEBUFFER, webXRSystem.framebuffer);
        } else if (webARSystem == null ? void 0 : webARSystem.isWebARMode) {
          const glw = this.__cgApiResourceRepository.currentWebGLContextWrapper;
          const gl = glw.getRawContext();
          gl.bindFramebuffer(gl.FRAMEBUFFER, webARSystem.framebuffer);
        } else {
          this.__cgApiResourceRepository.bindFramebuffer(renderPass.getFramebuffer());
          this.__cgApiResourceRepository.setDrawTargets(renderPass);
        }
      }
      static __displayRnInfo() {
        console.log(`%cRhodonite%cWeb3D Library%c %cversion%c${VERSION.version}%c %cbranch%c${VERSION.branch}%c %cmode%c${this.__processApproach.str}`, `font-weight: bold; padding: 4px 8px; border-radius: 6px 0px 0px 6px; background: linear-gradient(to right, #ff0084 0%,#ff0022 100%);`, `padding: 4px; border-radius: 0px 6px 6px 0px; background: linear-gradient(to right, #8400ff 0%,#4400ff 100%);`, ``, `background: #666; padding: 4px; border-radius: 6px 0px 0px 6px`, `background: firebrick; padding: 4px; border-radius: 0px 6px 6px 0px`, ``, `background: #666; padding: 4px; border-radius: 6px 0px 0px 6px`, `background: green; padding: 4px; border-radius: 0px 6px 6px 0px`, ``, `background: #666; padding: 4px; border-radius: 6px 0px 0px 6px`, `background: blue; padding: 4px; border-radius: 0px 6px 6px 0px`);
      }
      /**
      * Initialize the Rhodonite system.
      *
      * @remarks
      * Don't forget `await` to use this method.
      *
      * @example
      * ```
      * await Rn.System.init({
      *   approach: Rn.ProcessApproach.DataTexture,
      *   canvas: document.getElementById('world') as HTMLCanvasElement,
      * });
      * ```
      *
      * @param desc
      * @returns
      */
      static async init(desc) {
        this.__processApproach = desc.approach;
        SystemState.currentProcessApproach = desc.approach;
        if (desc.notToDisplayRnInfoAtInit !== true) {
          this.__displayRnInfo();
        }
        await ModuleManager.getInstance().loadModule("webgl");
        await ModuleManager.getInstance().loadModule("webgpu");
        await ModuleManager.getInstance().loadModule("pbr");
        await ModuleManager.getInstance().loadModule("xr");
        Config.eventTargetDom = desc.canvas;
        MemoryManager.createInstanceIfNotCreated({
          cpuGeneric: Is.exist(desc.memoryUsageOrder) ? desc.memoryUsageOrder.cpuGeneric : 0.1,
          gpuInstanceData: Is.exist(desc.memoryUsageOrder) ? desc.memoryUsageOrder.gpuInstanceData : 0.5,
          gpuVertexData: Is.exist(desc.memoryUsageOrder) ? desc.memoryUsageOrder.gpuVertexData : 0.5
        });
        _System.__cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        if (desc.approach === ProcessApproach.WebGPU) {
          let addFeature2 = function(feature) {
            if (adapter.features.has(feature)) {
              features.push(feature);
            }
          };
          var addFeature = addFeature2;
          __name(addFeature2, "addFeature");
          const memoryManager = MemoryManager.getInstance();
          const requiredBufferSize = memoryManager.getMemorySize();
          const webGpuResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
          const module = ModuleManager.getInstance().getModule("webgpu");
          const WebGpuDeviceWrapperClass = module.WebGpuDeviceWrapper;
          const adapter = await navigator.gpu.requestAdapter();
          const { maxBufferSize, maxStorageBufferBindingSize } = adapter.limits;
          if (maxBufferSize < requiredBufferSize || maxStorageBufferBindingSize < requiredBufferSize) {
            throw new Error("The required buffer size is too large for this device.");
          }
          const features = [];
          addFeature2("float32-filterable");
          addFeature2("rg11b10ufloat-renderable");
          addFeature2("texture-compression-bc");
          addFeature2("texture-compression-etc2");
          addFeature2("texture-compression-astc");
          const device = await adapter.requestDevice({
            requiredFeatures: features,
            requiredLimits: {
              maxStorageBufferBindingSize,
              maxBufferSize
            }
          });
          const webGpuDeviceWrapper = new WebGpuDeviceWrapperClass(desc.canvas, adapter, device);
          webGpuResourceRepository.addWebGpuDeviceWrapper(webGpuDeviceWrapper);
          webGpuResourceRepository.recreateSystemDepthTexture();
          webGpuResourceRepository.createUniformMorphOffsetsBuffer();
          webGpuResourceRepository.createUniformMorphWeightsBuffer();
          webGpuResourceRepository.createBindGroupLayoutForDrawParameters();
        } else {
          const repo = CGAPIResourceRepository.getWebGLResourceRepository();
          repo.generateWebGLContext(desc.canvas, true, desc.webglOption);
          repo.switchDepthTest(true);
        }
        const globalDataRepository = GlobalDataRepository.getInstance();
        globalDataRepository.initialize(desc.approach);
        if (MiscUtil.isMobile() && ProcessApproach.isUniformApproach(desc.approach)) {
          Logger.warn("The number of Uniform variables available on mobile devices is limited and may interfere with rendering. Use the DataTexture ProcessApproach for this device.");
        }
        desc.canvas.addEventListener("webglcontextlost", ((event) => {
          event.preventDefault();
          this.stopRenderLoop();
          Logger.error("WebGL context lost occurred.");
        }).bind(this));
        desc.canvas.addEventListener("webglcontextrestored", () => {
          Logger.error("WebGL context restored.");
          this.restartRenderLoop();
        });
        await initDefaultTextures();
        SystemState.viewportAspectRatio = desc.canvas.width / desc.canvas.height;
      }
      static get processApproach() {
        return this.__processApproach;
      }
      static resizeCanvas(width, height) {
        const repo = CGAPIResourceRepository.getCgApiResourceRepository();
        repo.resizeCanvas(width, height);
        SystemState.viewportAspectRatio = width / height;
      }
      static getCanvasSize() {
        const repo = CGAPIResourceRepository.getCgApiResourceRepository();
        return repo.getCanvasSize();
      }
      static getCurrentWebGLContextWrapper() {
        return this.__cgApiResourceRepository.currentWebGLContextWrapper;
      }
    };
    __name(_System, "System");
    __publicField(_System, "__expressionForProcessAuto");
    __publicField(_System, "__renderPassForProcessAuto");
    __publicField(_System, "__processApproach", ProcessApproach.None);
    __publicField(_System, "__cgApiResourceRepository");
    __publicField(_System, "__renderPassTickCount", 0);
    __publicField(_System, "__animationFrameId", -1);
    __publicField(_System, "__renderLoopFunc");
    __publicField(_System, "__args", []);
    __publicField(_System, "__rnXRModule");
    __publicField(_System, "__lastCameraComponentsUpdateCount", -1);
    __publicField(_System, "__lastCameraControllerComponentsUpdateCount", -1);
    __publicField(_System, "__lastTransformComponentsUpdateCount", -1);
    __publicField(_System, "__lastPrimitiveCount", -1);
    System = _System;
  }
});

// src/foundation/system/index.ts
var init_system = __esm({
  "src/foundation/system/index.ts"() {
    "use strict";
    init_EventPubSub();
    init_InputManager();
    init_ModuleManager();
    init_System();
    init_SystemState();
  }
});

// src/foundation/materials/core/AbstractShaderNode.ts
var _AbstractShaderNode, AbstractShaderNode;
var init_AbstractShaderNode = __esm({
  "src/foundation/materials/core/AbstractShaderNode.ts"() {
    "use strict";
    init_RnObject();
    init_ShaderType();
    init_system();
    init_definitions();
    _AbstractShaderNode = class _AbstractShaderNode extends RnObject {
      constructor(shaderNodeName, shader) {
        super();
        __publicField(this, "__shaderFunctionName");
        __publicField(this, "__inputs", []);
        __publicField(this, "__outputs", []);
        __publicField(this, "__inputConnections", []);
        __publicField(this, "__shaderNodeUid");
        __publicField(this, "__codeGLSL");
        __publicField(this, "__codeWGSL");
        __publicField(this, "__commonPart");
        __publicField(this, "_shaderStage", "Neutral");
        this.__shaderFunctionName = shaderNodeName;
        this.__codeGLSL = shader.codeGLSL;
        this.__codeWGSL = shader.codeWGSL;
        this.__shaderNodeUid = ++_AbstractShaderNode.__invalidShaderNodeCount;
        _AbstractShaderNode._shaderNodes[_AbstractShaderNode.__invalidShaderNodeCount] = this;
        this.__commonPart = shader.commonPart;
      }
      setShaderStage(stage) {
        this._shaderStage = stage;
      }
      getShaderStage() {
        return this._shaderStage;
      }
      static getShaderNodeByUid(uid) {
        return _AbstractShaderNode._shaderNodes[uid];
      }
      /**
      * Add a node connection to this node as an input.
      * @param inputShaderNode - a shader node to connect to this node.
      * @param outputSocketOfInput- the output socket of the inputShaderNode.
      * @param inputSocketOfThis - the input socket of this node.
      */
      addInputConnection(inputShaderNode, outputSocketOfInput, inputSocketOfThis) {
        let idx = -1;
        for (let i2 = 0; i2 < this.__inputs.length; i2++) {
          if (this.__inputs[i2].name === inputSocketOfThis.name) {
            idx = i2;
            break;
          }
        }
        this.__inputConnections[idx] = {
          shaderNodeUid: inputShaderNode.shaderNodeUid,
          outputNameOfPrev: outputSocketOfInput.name,
          inputNameOfThis: inputSocketOfThis.name
        };
      }
      get shaderFunctionName() {
        return this.__shaderFunctionName;
      }
      getShaderFunctionNameDerivative() {
        return this.__shaderFunctionName;
      }
      getShaderCode(shaderStage) {
        if (this.__commonPart != null) {
          if (shaderStage === ShaderType.VertexShader) {
            return this.__commonPart.vertexShaderDefinitions;
          } else {
            return this.__commonPart.pixelShaderDefinitions;
          }
        } else {
          if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
            return this.__codeWGSL;
          } else {
            return this.__codeGLSL;
          }
        }
      }
      get shaderNodeUid() {
        return this.__shaderNodeUid;
      }
      getInput(name) {
        for (const input of this.__inputs) {
          if (input.name === name) {
            return input;
          }
        }
        return void 0;
      }
      getInputs() {
        return this.__inputs;
      }
      getOutput(name) {
        for (const output of this.__outputs) {
          if (output.name === name) {
            return output;
          }
        }
        return void 0;
      }
      getOutputs() {
        return this.__outputs;
      }
      get inputConnections() {
        return this.__inputConnections;
      }
      makeCallStatement(i2, shaderNode, functionName, varInputNames, varOutputNames) {
        let str = "";
        const varNames = varInputNames[i2].concat(varOutputNames[i2]);
        if (shaderNode.getInputs().length === varInputNames[i2].length && shaderNode.getOutputs().length === varOutputNames[i2].length) {
          let rowStr = "";
          if (varNames.length > 0) {
            rowStr += `${functionName}(`;
            for (let k = 0; k < varNames.length; k++) {
              const varName = varNames[k];
              if (varName == null) {
                continue;
              }
              if (k !== 0) {
                rowStr += ", ";
              }
              if (SystemState.currentProcessApproach === ProcessApproach.WebGPU && k >= varInputNames[i2].length) {
                rowStr += "&";
              }
              rowStr += varNames[k];
            }
            rowStr += ");\n";
          }
          str += rowStr;
        }
        return str;
      }
    };
    __name(_AbstractShaderNode, "AbstractShaderNode");
    __publicField(_AbstractShaderNode, "_shaderNodes", []);
    __publicField(_AbstractShaderNode, "__invalidShaderNodeCount", -1);
    AbstractShaderNode = _AbstractShaderNode;
  }
});

// src/webgl/shaders/CommonShaderPart.ts
var _CommonShaderPart, CommonShaderPart;
var init_CommonShaderPart = __esm({
  "src/webgl/shaders/CommonShaderPart.ts"() {
    "use strict";
    init_ProcessApproach();
    init_VertexAttribute();
    init_WebGLResourceRepository();
    init_SystemState();
    init_prerequisites();
    init_vertexInput();
    init_prerequisites2();
    init_mainPrerequisites();
    init_mainPrerequisites2();
    init_AbstractShaderNode();
    _CommonShaderPart = class _CommonShaderPart {
      constructor() {
        __publicField(this, "__webglResourceRepository", WebGLResourceRepository.getInstance());
      }
      static getMainBegin(isVertexStage) {
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          if (isVertexStage) {
            let str = `
var<private> output : VertexOutput;
@vertex
fn main(
${vertexInput_default.code}
) -> VertexOutput {
#ifdef RN_USE_INSTANCE
a_instanceIds = instance_ids;
#endif

#ifdef RN_USE_POSITION
a_position = vec3<f32>(position);
#else
a_position = vec3<f32>(0.0, 0.0, 0.0);
#endif

#ifdef RN_USE_NORMAL
a_normal = normal;
#endif

#ifdef RN_USE_TEXCOORD_0
a_texcoord_0 = texcoord_0;
#endif

#ifdef RN_USE_COLOR_0
a_color_0 = vec4<f32>(color_0);
#else
a_color_0 = vec4<f32>(0.0, 0.0, 0.0, 1.0);
#endif
`;
            return str;
          } else {
            let str = `
var<private> rt0: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 1.0);
@fragment
fn main(
  input: VertexOutput,
  @builtin(front_facing) isFront: bool,
) -> @location(0) vec4<f32> {
`;
            return str;
          }
        } else {
          return `
void main() {
`;
        }
      }
      static getMainEnd(isVertexStage) {
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          if (isVertexStage) {
            return `
  return output;
}
`;
          } else {
            return `
  return rt0;
}
`;
          }
        } else {
          return `
}
    `;
        }
      }
      static getVertexPrerequisites(shaderNodes) {
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          const varyingVariables = _CommonShaderPart.__makeVaryingVariablesWGSL(shaderNodes);
          let vertexShaderPrerequisites = "";
          vertexShaderPrerequisites += `
/* shaderity: @{definitions} */
#define RN_IS_NODE_SHADER

#ifdef RN_USE_INSTANCE
var<private> a_instanceIds: vec4<f32>;
#endif

var<private> a_position: vec3<f32>;

var<private> a_normal: vec3<f32>;

var<private> a_texcoord_0: vec2<f32>;

var<private> a_color_0: vec4<f32>;

struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  ${varyingVariables}
}

${prerequisites_default2.code}
/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */
`;
          return vertexShaderPrerequisites;
        } else {
          let vertexShaderPrerequisites = "";
          const in_ = "in";
          vertexShaderPrerequisites += `
#version 300 es
precision highp float;
precision highp int;
${prerequisites_default.code}

${in_} vec4 a_instanceInfo;
`;
          vertexShaderPrerequisites += `
uniform bool u_vertexAttributesExistenceArray[${VertexAttribute.AttributeTypeNumber}];
`;
          vertexShaderPrerequisites += "/* shaderity: @{matricesGetters} */";
          vertexShaderPrerequisites += "/* shaderity: @{getters} */";
          return vertexShaderPrerequisites;
        }
      }
      static __makeVaryingVariablesWGSL(shaderNodes) {
        const varyings = [];
        for (let i2 = 0; i2 < shaderNodes.length; i2++) {
          const shaderNode = shaderNodes[i2];
          for (let j = 0; j < shaderNode.inputConnections.length; j++) {
            const inputConnection = shaderNode.inputConnections[j];
            if (inputConnection == null) {
              continue;
            }
            const input = shaderNode.getInputs()[j];
            const inputNode = AbstractShaderNode.getShaderNodeByUid(inputConnection.shaderNodeUid);
            if (inputNode.getShaderStage() === "Vertex" && shaderNode.getShaderStage() === "Fragment") {
              const type = input.compositionType.toWGSLType(input.componentType);
              varyings.push({
                type,
                name: `${inputNode.shaderFunctionName}_${inputNode.shaderNodeUid}`
              });
            }
          }
        }
        varyings.sort((a2, b) => {
          if (a2.name < b.name) {
            return -1;
          } else {
            return 1;
          }
        });
        let varyingVariables = "";
        for (let i2 = 0; i2 < varyings.length; i2++) {
          varyingVariables += `@location(${i2}) ${varyings[i2].name}: ${varyings[i2].type},
`;
        }
        return varyingVariables;
      }
      static getPixelPrerequisites(shaderNodes) {
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          const varyingVariables = _CommonShaderPart.__makeVaryingVariablesWGSL(shaderNodes);
          let pixelShaderPrerequisites = "";
          pixelShaderPrerequisites += `
/* shaderity: @{definitions} */
#define RN_IS_NODE_SHADER

struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  ${varyingVariables}
}

${prerequisites_default2.code}
/* shaderity: @{getters} */
/* shaderity: @{matricesGetters} */
`;
          return pixelShaderPrerequisites;
        } else {
          let pixelShaderPrerequisites = "";
          pixelShaderPrerequisites += `
      #version 300 es
      precision highp float;
      precision highp int;
      ${prerequisites_default.code}
      `;
          pixelShaderPrerequisites += "/* shaderity: @{getters} */";
          pixelShaderPrerequisites += "layout(location = 0) out vec4 rt0;";
          return pixelShaderPrerequisites;
        }
      }
      static getMainPrerequisites() {
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          return mainPrerequisites_default2.code;
        } else {
          return mainPrerequisites_default.code;
        }
      }
      static getAssignmentStatement(varName, inputSocket) {
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          const wgslTypeStr = inputSocket.compositionType.toWGSLType(inputSocket.componentType);
          const wgslInitialValue = inputSocket.compositionType.getWgslInitialValue(inputSocket.componentType);
          const rowStr = `var ${varName}: ${wgslTypeStr} = ${wgslInitialValue};
`;
          return rowStr;
        } else {
          const glslTypeStr = inputSocket.compositionType.getGlslStr(inputSocket.componentType);
          const glslInitialValue = inputSocket.compositionType.getGlslInitialValue(inputSocket.componentType);
          const rowStr = `${glslTypeStr} ${varName} = ${glslInitialValue};
`;
          return rowStr;
        }
      }
      static getAssignmentVaryingStatementInPixelShader(varName, inputSocket, inputNode) {
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          const wgslTypeStr = inputSocket.compositionType.toWGSLType(inputSocket.componentType);
          const rowStr = `var ${varName}: ${wgslTypeStr} = input.${inputNode.shaderFunctionName}_${inputNode.shaderNodeUid};
`;
          return rowStr;
        } else {
          const glslTypeStr = inputSocket.compositionType.getGlslStr(inputSocket.componentType);
          const rowStr = `${glslTypeStr} ${varName} = v_${inputNode.shaderFunctionName}_${inputNode.shaderNodeUid};
`;
          return rowStr;
        }
      }
      static getAssignmentVaryingStatementInVertexShader(inputNode, varNames, j) {
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          return `output.${inputNode.shaderFunctionName}_${inputNode.shaderNodeUid} = ${varNames[j]};
`;
        } else {
          return `v_${inputNode.shaderFunctionName}_${inputNode.shaderNodeUid} = ${varNames[j]};
`;
        }
      }
    };
    __name(_CommonShaderPart, "CommonShaderPart");
    __publicField(_CommonShaderPart, "__instance");
    CommonShaderPart = _CommonShaderPart;
  }
});

// src/foundation/gizmos/LightGizmo.ts
var _LightGizmo, LightGizmo;
var init_LightGizmo = __esm({
  "src/foundation/gizmos/LightGizmo.ts"() {
    "use strict";
    init_createMeshEntity();
    init_PrimitiveMode();
    init_VertexAttribute();
    init_Mesh();
    init_Primitive();
    init_Vector3();
    init_Is();
    init_Gizmo();
    _LightGizmo = class _LightGizmo extends Gizmo {
      /**
      * Constructor
      * @param target the object which this gizmo belong to
      */
      constructor(target) {
        super(target);
      }
      ///
      ///
      /// Accessors
      ///
      ///
      get isSetup() {
        if (this.__topEntity != null) {
          return true;
        } else {
          return false;
        }
      }
      ///
      ///
      /// Friends Members
      ///
      ///
      /**
      * @internal
      * setup entities of Gizmo if not done yet
      */
      _setup() {
        if (this.__toSkipSetup()) {
          return;
        }
        this.__topEntity = createMeshEntity();
        this.__topEntity.tryToSetUniqueName(`LightGizmo_of_${this.__target.uniqueName}`, true);
        this.__topEntity.getSceneGraph().toMakeWorldMatrixTheSameAsLocalMatrix = true;
        this.__target.getSceneGraph()._addGizmoChild(this.__topEntity.getSceneGraph());
        const meshComponent = this.__topEntity.tryToGetMesh();
        _LightGizmo.__mesh = new Mesh();
        _LightGizmo.__mesh.addPrimitive(_LightGizmo.__generatePrimitive());
        meshComponent.setMesh(_LightGizmo.__mesh);
        this.setGizmoTag();
      }
      /**
      * @internal
      * update the transform and etc of the gizmo
      */
      _update() {
        if (this.__topEntity == null) {
          return;
        }
        const sg = this.__target.getSceneGraph();
        const aabb = sg.worldMergedAABBWithSkeletal;
        if (aabb.isVanilla()) {
          this.__topEntity.getTransform().localPosition = sg.position;
        } else {
          this.__topEntity.getTransform().localPosition = aabb.centerPoint;
        }
        this.__topEntity.getTransform().localRotation = sg.rotation;
        this.__topEntity.getTransform().localScale = Vector3.fromCopyArray([
          Math.max(1, aabb.isVanilla() ? 1 : aabb.sizeX / 2),
          Math.max(1, aabb.isVanilla() ? 1 : aabb.sizeY / 2),
          Math.max(1, aabb.isVanilla() ? 1 : aabb.sizeZ / 2)
        ]);
      }
      _destroy() {
        if (Is.exist(this.__topEntity)) {
          this.__topEntity._destroy();
        }
      }
      ///
      ///
      /// Private Static Members
      ///
      ///
      static __generatePrimitive() {
        const positions = new Float32Array([
          // Z axis
          0,
          0,
          0,
          0,
          0,
          -this.__length,
          // Arrow
          0,
          0,
          -this.__length,
          -0.1,
          0,
          -this.__length + 0.2,
          // Arrow end
          -0.1,
          0,
          -this.__length + 0.2,
          0,
          0,
          -this.__length + 0.2
        ]);
        const primitive = Primitive.createPrimitive({
          attributeSemantics: [
            VertexAttribute.Position.XYZ
          ],
          attributes: [
            positions
          ],
          primitiveMode: PrimitiveMode.Lines
        });
        return primitive;
      }
    };
    __name(_LightGizmo, "LightGizmo");
    __publicField(_LightGizmo, "__mesh");
    __publicField(_LightGizmo, "__length", 1);
    LightGizmo = _LightGizmo;
  }
});

// src/foundation/components/Transform/ITransformEntity.ts
var init_ITransformEntity = __esm({
  "src/foundation/components/Transform/ITransformEntity.ts"() {
    "use strict";
  }
});

// src/foundation/components/Transform/index.ts
var init_Transform = __esm({
  "src/foundation/components/Transform/index.ts"() {
    "use strict";
    init_ITransformEntity();
    init_TransformComponent();
    init_createTransformEntity();
  }
});

// src/foundation/components/Light/LightComponent.ts
var _LightComponent, LightComponent;
var init_LightComponent = __esm({
  "src/foundation/components/Light/LightComponent.ts"() {
    "use strict";
    init_ComponentRepository();
    init_Component();
    init_EntityRepository();
    init_WellKnownComponentTIDs();
    init_LightType();
    init_Vector3();
    init_ProcessStage();
    init_Config();
    init_GlobalDataRepository();
    init_MutableVector4();
    init_VectorN();
    init_LightGizmo();
    init_Is();
    init_Scalar();
    init_Transform();
    _LightComponent = class _LightComponent extends Component {
      constructor(entityUid, componentSid, entityRepository, isReUse) {
        super(entityUid, componentSid, entityRepository, isReUse);
        __publicField(this, "type", LightType.Point);
        __publicField(this, "__intensity", Vector3.fromCopyArray([
          1,
          1,
          1
        ]));
        __publicField(this, "__initialDirection", Vector3.fromCopyArray([
          0,
          0,
          -1
        ]));
        __publicField(this, "__direction", Vector3.fromCopyArray([
          0,
          0,
          -1
        ]));
        __publicField(this, "innerConeAngle", 0);
        __publicField(this, "outerConeAngle", Math.PI / 4);
        __publicField(this, "range", -1);
        __publicField(this, "enable", true);
        __publicField(this, "shadowAreaSizeForDirectionalLight", 10);
        __publicField(this, "__lightGizmo");
        __publicField(this, "__updateCount", 0);
        __publicField(this, "__lastUpdateCount", -1);
        __publicField(this, "__lastTransformUpdateCount", -1);
        this._setMaxNumberOfComponent(Math.max(10, Math.floor(Config.maxEntityNumber / 100)));
      }
      static get componentTID() {
        return WellKnownComponentTIDs.LightComponentTID;
      }
      get componentTID() {
        return WellKnownComponentTIDs.LightComponentTID;
      }
      get updateCount() {
        return this.__updateCount;
      }
      get direction() {
        return this.__direction;
      }
      set intensity(value) {
        this.__intensity = value;
        this.__updateCount++;
      }
      get intensity() {
        return this.__intensity;
      }
      get _up() {
        return Vector3.fromCopy3(0, 1, 0);
      }
      set isLightGizmoVisible(flg) {
        if (flg) {
          if (Is.not.defined(this.__lightGizmo)) {
            this.__lightGizmo = new LightGizmo(this.entity);
            this.__lightGizmo._setup();
          }
          this.__lightGizmo.isVisible = true;
        } else {
          if (Is.defined(this.__lightGizmo)) {
            this.__lightGizmo.isVisible = false;
          }
        }
        this.__updateCount++;
      }
      get isLightGizmoVisible() {
        if (Is.defined(this.__lightGizmo)) {
          return this.__lightGizmo.isVisible;
        } else {
          return false;
        }
      }
      $load() {
        _LightComponent.__lightPositions = _LightComponent.__globalDataRepository.getValue("lightPosition", 0);
        _LightComponent.__lightDirections = _LightComponent.__globalDataRepository.getValue("lightDirection", 0);
        _LightComponent.__lightIntensities = _LightComponent.__globalDataRepository.getValue("lightIntensity", 0);
        _LightComponent.__lightProperties = _LightComponent.__globalDataRepository.getValue("lightProperty", 0);
        _LightComponent.__lightNumber = _LightComponent.__globalDataRepository.getValue("lightNumber", 0);
        this.moveStageTo(ProcessStage.Logic);
      }
      __updateGizmo() {
        if (Is.defined(this.__lightGizmo) && this.__lightGizmo.isSetup && this.isLightGizmoVisible) {
          this.__lightGizmo._update();
        }
      }
      static common_$logic() {
        const lightComponents = ComponentRepository.getComponentsWithType(_LightComponent);
        _LightComponent.__lightNumber._v[0] = lightComponents.length;
      }
      $logic() {
        if (TransformComponent.updateCount === this.__lastTransformUpdateCount && this.__lastUpdateCount === this.__updateCount) {
          return;
        }
        const sceneGraphComponent = this.entity.getSceneGraph();
        this.__direction = sceneGraphComponent.normalMatrixInner.multiplyVector(this.__initialDirection);
        const lightAngleScale = 1 / Math.max(1e-3, Math.cos(this.innerConeAngle) - Math.cos(this.outerConeAngle));
        const lightAngleOffset = -Math.cos(this.outerConeAngle) * lightAngleScale;
        _LightComponent.__lightDirections._v[3 * this.componentSID + 0] = this.__direction.x;
        _LightComponent.__lightDirections._v[3 * this.componentSID + 1] = this.__direction.y;
        _LightComponent.__lightDirections._v[3 * this.componentSID + 2] = this.__direction.z;
        const lightPosition = sceneGraphComponent.worldPosition;
        _LightComponent.__lightPositions._v[3 * this.componentSID + 0] = lightPosition.x;
        _LightComponent.__lightPositions._v[3 * this.componentSID + 1] = lightPosition.y;
        _LightComponent.__lightPositions._v[3 * this.componentSID + 2] = lightPosition.z;
        _LightComponent.__lightIntensities._v[3 * this.componentSID + 0] = this.__intensity.x;
        _LightComponent.__lightIntensities._v[3 * this.componentSID + 1] = this.__intensity.y;
        _LightComponent.__lightIntensities._v[3 * this.componentSID + 2] = this.__intensity.z;
        _LightComponent.__lightProperties._v[4 * this.componentSID + 0] = this.enable ? this.type.index : -1;
        _LightComponent.__lightProperties._v[4 * this.componentSID + 1] = this.range;
        _LightComponent.__lightProperties._v[4 * this.componentSID + 2] = lightAngleScale;
        _LightComponent.__lightProperties._v[4 * this.componentSID + 3] = lightAngleOffset;
        this.__updateGizmo();
        this.__lastTransformUpdateCount = TransformComponent.updateCount;
        this.__lastUpdateCount = this.__updateCount;
      }
      _destroy() {
        super._destroy();
        _LightComponent.__lightIntensities._v[3 * this.componentSID + 0] = 0;
        _LightComponent.__lightIntensities._v[3 * this.componentSID + 1] = 0;
        _LightComponent.__lightIntensities._v[3 * this.componentSID + 2] = 0;
      }
      /**
      * get the entity which has this component.
      * @returns the entity which has this component
      */
      get entity() {
        return EntityRepository.getEntity(this.__entityUid);
      }
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let LightEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
          }
          getLight() {
            return this.getComponentByComponentTID(WellKnownComponentTIDs.LightComponentTID);
          }
        }, __name(_a40, "LightEntity"), _a40);
        applyMixins(base, LightEntity);
        return base;
      }
    };
    __name(_LightComponent, "LightComponent");
    __publicField(_LightComponent, "__globalDataRepository", GlobalDataRepository.getInstance());
    __publicField(_LightComponent, "__tmp_vec4", MutableVector4.zero());
    __publicField(_LightComponent, "__lightPositions", new VectorN(new Float32Array(0)));
    __publicField(_LightComponent, "__lightDirections", new VectorN(new Float32Array(0)));
    __publicField(_LightComponent, "__lightIntensities", new VectorN(new Float32Array(0)));
    __publicField(_LightComponent, "__lightProperties", new VectorN(new Float32Array(0)));
    __publicField(_LightComponent, "__lightNumber", Scalar2.zero());
    LightComponent = _LightComponent;
  }
});

// src/webgl/WebGLStrategyCommonMethod.ts
function setWebGLParameters(material, gl) {
  setCull(material, gl);
  setBlendSettings(material, gl);
  setAlphaToCoverage(material, gl);
  setColorWriteMask(material, gl);
}
function setCull(material, gl) {
  const cullFace = material.cullFace;
  const cullFrontFaceCCW = material.cullFrontFaceCCW;
  const cullFaceBack = material.cullFaceBack;
  if (lastCullFace !== cullFace) {
    if (cullFace) {
      gl.enable(gl.CULL_FACE);
    } else {
      gl.disable(gl.CULL_FACE);
    }
    lastCullFace = cullFace;
  }
  if (cullFace === true && lastFrontFaceCCW !== cullFrontFaceCCW) {
    if (cullFrontFaceCCW) {
      gl.frontFace(gl.CCW);
    } else {
      gl.frontFace(gl.CW);
    }
    lastFrontFaceCCW = cullFrontFaceCCW;
  }
  if (cullFaceBack !== lastCullFaceBack) {
    if (cullFaceBack) {
      gl.cullFace(gl.BACK);
    } else {
      gl.cullFace(gl.FRONT);
    }
    lastCullFaceBack = cullFaceBack;
  }
}
function setBlendSettings(material, gl) {
  const isBlendMode = material.isBlend();
  if (lastIsTransparentMode !== isBlendMode) {
    if (isBlendMode) {
      gl.enable(gl.BLEND);
    } else {
      gl.disable(gl.BLEND);
    }
    lastIsTransparentMode = isBlendMode;
  }
  if (material.alphaMode === AlphaMode.Blend) {
    setBlendEquationMode(material.blendEquationMode.index, material.blendEquationModeAlpha.index, gl);
    setBlendFuncSrcFactor(material.blendFuncSrcFactor.index, material.blendFuncDstFactor.index, material.blendFuncAlphaSrcFactor.index, material.blendFuncAlphaDstFactor.index, gl);
  }
}
function setBlendEquationMode(blendEquationMode, blendEquationModeAlpha, gl) {
  const needUpdateBlendEquation = differentWithLastBlendEquation(blendEquationMode, blendEquationModeAlpha);
  if (needUpdateBlendEquation) {
    gl.blendEquationSeparate(blendEquationMode, blendEquationModeAlpha);
    lastBlendEquationMode = blendEquationMode;
    lastBlendEquationModeAlpha = blendEquationModeAlpha;
  }
}
function differentWithLastBlendEquation(equationMode, equationModeAlpha) {
  const result = lastBlendEquationMode !== equationMode || lastBlendEquationModeAlpha !== equationModeAlpha;
  return result;
}
function setBlendFuncSrcFactor(blendFuncSrcFactor, blendFuncDstFactor, blendFuncAlphaSrcFactor, blendFuncAlphaDstFactor, gl) {
  const needUpdateBlendFunc = differentWithLastBlendFuncFactor(blendFuncSrcFactor, blendFuncDstFactor, blendFuncAlphaSrcFactor, blendFuncAlphaDstFactor);
  if (needUpdateBlendFunc) {
    gl.blendFuncSeparate(blendFuncSrcFactor, blendFuncDstFactor, blendFuncAlphaSrcFactor, blendFuncAlphaDstFactor);
    lastBlendFuncSrcFactor = blendFuncSrcFactor;
    lastBlendFuncDstFactor = blendFuncDstFactor;
    lastBlendFuncAlphaSrcFactor = blendFuncAlphaSrcFactor;
    lastBlendFuncAlphaDstFactor = blendFuncAlphaDstFactor;
  }
}
function differentWithLastBlendFuncFactor(srcFactor, dstFactor, alphaSrcFactor, alphaDstFactor) {
  const result = lastBlendFuncSrcFactor !== srcFactor || lastBlendFuncDstFactor !== dstFactor || lastBlendFuncAlphaSrcFactor !== alphaSrcFactor || lastBlendFuncAlphaDstFactor !== alphaDstFactor;
  return result;
}
function setAlphaToCoverage(material, gl) {
  const alphaToCoverage = material.alphaToCoverage;
  if (alphaToCoverage !== lastAlphaToCoverage) {
    if (alphaToCoverage) {
      gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    } else {
      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    }
    lastAlphaToCoverage = alphaToCoverage;
  }
}
function setColorWriteMask(material, gl) {
  const colorWriteMask = material.colorWriteMask;
  if (colorWriteMask[0] !== lastColorWriteMask[0] || colorWriteMask[1] !== lastColorWriteMask[1] || colorWriteMask[2] !== lastColorWriteMask[2] || colorWriteMask[3] !== lastColorWriteMask[3]) {
    gl.colorMask(colorWriteMask[0], colorWriteMask[1], colorWriteMask[2], colorWriteMask[3]);
    lastColorWriteMask = colorWriteMask;
  }
}
function setVRViewport(renderPass, displayIdx) {
  const webglResourceRepository = WebGLResourceRepository.getInstance();
  const rnXRModule = ModuleManager.getInstance().getModule("xr");
  const webxrSystem = rnXRModule.WebXRSystem.getInstance();
  if (webxrSystem.isWebXRMode) {
    webglResourceRepository.setViewport(webxrSystem._getViewportAt(displayIdx));
  }
}
function getDisplayCount(isVRMainPass, webxrSystem) {
  if (webxrSystem.isWebXRMode) {
    if (webxrSystem.isMultiView()) {
      return 1;
    } else if (isVRMainPass) {
      return 2;
    } else {
      return 1;
    }
  } else {
    return 1;
  }
}
function isVrMainPass(renderPass) {
  const rnXRModule = ModuleManager.getInstance().getModule("xr");
  const isVRMainPass = (rnXRModule == null ? void 0 : rnXRModule.WebXRSystem.getInstance().isWebXRMode) && renderPass.isVrRendering;
  return isVRMainPass;
}
function getPointSpriteShaderSemanticsInfoArray() {
  return [
    {
      semantic: "pointSize",
      compositionType: CompositionType.Scalar,
      componentType: ComponentType.Float,
      stage: ShaderType.PixelShader,
      initialValue: Scalar2.fromCopyNumber(30),
      min: 0,
      max: Number.MAX_VALUE,
      isInternalSetting: false
    },
    {
      semantic: "pointDistanceAttenuation",
      compositionType: CompositionType.Vec3,
      componentType: ComponentType.Float,
      stage: ShaderType.PixelShader,
      initialValue: Vector3.fromCopyArray([
        0,
        0.1,
        0.01
      ]),
      min: 0,
      max: 1,
      isInternalSetting: false
    }
  ];
}
function setupShaderProgram(material, primitive, webglStrategy) {
  if (material == null) {
    return;
  }
  if (material.isShaderProgramReady(primitive)) {
    return;
  }
  try {
    primitive == null ? void 0 : primitive._backupMaterial();
    webglStrategy.setupShaderForMaterial(material, primitive);
  } catch (e3) {
    console.log(e3);
    primitive == null ? void 0 : primitive._restoreMaterial();
    webglStrategy.setupShaderForMaterial(material, primitive);
  }
}
var lastIsTransparentMode, lastBlendEquationMode, lastBlendEquationModeAlpha, lastBlendFuncSrcFactor, lastBlendFuncDstFactor, lastBlendFuncAlphaSrcFactor, lastBlendFuncAlphaDstFactor, lastCullFace, lastFrontFaceCCW, lastCullFaceBack, lastAlphaToCoverage, lastColorWriteMask, WebGLStrategyCommonMethod_default;
var init_WebGLStrategyCommonMethod = __esm({
  "src/webgl/WebGLStrategyCommonMethod.ts"() {
    "use strict";
    init_AlphaMode();
    init_ModuleManager();
    init_WebGLResourceRepository();
    init_CompositionType();
    init_ComponentType();
    init_ShaderType();
    init_Scalar();
    init_Vector3();
    lastCullFace = false;
    lastFrontFaceCCW = true;
    lastCullFaceBack = true;
    lastAlphaToCoverage = false;
    lastColorWriteMask = [
      true,
      true,
      true,
      true
    ];
    __name(setWebGLParameters, "setWebGLParameters");
    __name(setCull, "setCull");
    __name(setBlendSettings, "setBlendSettings");
    __name(setBlendEquationMode, "setBlendEquationMode");
    __name(differentWithLastBlendEquation, "differentWithLastBlendEquation");
    __name(setBlendFuncSrcFactor, "setBlendFuncSrcFactor");
    __name(differentWithLastBlendFuncFactor, "differentWithLastBlendFuncFactor");
    __name(setAlphaToCoverage, "setAlphaToCoverage");
    __name(setColorWriteMask, "setColorWriteMask");
    __name(setVRViewport, "setVRViewport");
    __name(getDisplayCount, "getDisplayCount");
    __name(isVrMainPass, "isVrMainPass");
    __name(getPointSpriteShaderSemanticsInfoArray, "getPointSpriteShaderSemanticsInfoArray");
    __name(setupShaderProgram, "setupShaderProgram");
    WebGLStrategyCommonMethod_default = Object.freeze({
      setWebGLParameters,
      setVRViewport,
      getDisplayCount,
      isVrMainPass,
      getPointSpriteShaderSemanticsInfoArray
    });
  }
});

// src/webgl/WebGLStrategyUniform.ts
var _WebGLStrategyUniform, WebGLStrategyUniform;
var init_WebGLStrategyUniform = __esm({
  "src/webgl/WebGLStrategyUniform.ts"() {
    "use strict";
    init_WebGLResourceRepository();
    init_Primitive();
    init_CGAPIResourceRepository();
    init_ShaderSemantics();
    init_ComponentRepository();
    init_LightComponent();
    init_Config();
    init_PixelFormat();
    init_ComponentType();
    init_MeshRendererComponent();
    init_CompositionType();
    init_MemoryManager();
    init_ShaderType();
    init_BufferUse();
    init_GlobalDataRepository();
    init_MiscUtil();
    init_WebGLStrategyCommonMethod();
    init_Is();
    init_RenderingCommonMethods();
    init_ModuleManager();
    init_AnimationComponent();
    init_TextureFormat();
    init_Logger();
    _WebGLStrategyUniform = class _WebGLStrategyUniform {
      constructor() {
        __publicField(this, "__webglResourceRepository", WebGLResourceRepository.getInstance());
        __publicField(this, "__dataTextureUid", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__lastShader", -1);
        __publicField(this, "__lastMaterial");
        __publicField(this, "__lastRenderPassTickCount", -1);
        __publicField(this, "__lightComponents");
      }
      /**
      * setup shader program for the material in this WebGL strategy
      * @param material - a material to setup shader program
      */
      setupShaderForMaterial(material, primitive) {
        const webglResourceRepository = WebGLResourceRepository.getInstance();
        const glw = webglResourceRepository.currentWebGLContextWrapper;
        const [programUid, newOne] = material._createProgramWebGL(_WebGLStrategyUniform.__vertexShaderMethodDefinitions_uniform, ShaderSemantics.getShaderProperty, primitive, glw.isWebGL2);
        if (newOne) {
          material._setupBasicUniformsLocations(primitive);
          material._setUniformLocationsOfMaterialNodes(true, primitive);
          const shaderSemanticsInfos = _WebGLStrategyUniform.componentMatrices;
          const shaderSemanticsInfosPointSprite = WebGLStrategyCommonMethod_default.getPointSpriteShaderSemanticsInfoArray();
          material._setupAdditionalUniformLocations(shaderSemanticsInfos.concat(shaderSemanticsInfosPointSprite), true, primitive);
          _WebGLStrategyUniform.__globalDataRepository._setUniformLocationsForUniformModeOnly(material.getShaderProgramUid(primitive));
        }
        return programUid;
      }
      /**
      * re-setup shader program for the material in this WebGL strategy
      * @param material - a material to re-setup shader program
      * @param updatedShaderSources - updated shader sources
      * @param onError - callback function to handle error
      * @returns
      */
      _reSetupShaderForMaterialBySpector(material, primitive, updatedShaderSources, onError) {
        const [programUid, newOne] = material._createProgramByUpdatedSources(updatedShaderSources, primitive, onError);
        if (programUid === CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          return programUid;
        }
        if (newOne) {
          material._setupBasicUniformsLocations(primitive);
          material._setUniformLocationsOfMaterialNodes(true, primitive);
          const shaderSemanticsInfos = _WebGLStrategyUniform.componentMatrices;
          const shaderSemanticsInfosPointSprite = WebGLStrategyCommonMethod_default.getPointSpriteShaderSemanticsInfoArray();
          material._setupAdditionalUniformLocations(shaderSemanticsInfos.concat(shaderSemanticsInfosPointSprite), true, primitive);
        }
        _WebGLStrategyUniform.__globalDataRepository._setUniformLocationsForUniformModeOnly(material.getShaderProgramUid(primitive));
        return programUid;
      }
      $load(meshComponent) {
        const mesh = meshComponent.mesh;
        if (!Is.exist(mesh)) {
          return false;
        }
        if (!mesh.isSetUpDone()) {
          updateVBOAndVAO(mesh);
        }
        return true;
      }
      prerender() {
        this.__lightComponents = ComponentRepository.getComponentsWithType(LightComponent);
        if (this.__dataTextureUid === CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          const memoryManager = MemoryManager.getInstance();
          const buffer = memoryManager.getBuffer(BufferUse.GPUVertexData);
          if (buffer == null) {
            return;
          }
          if (buffer.takenSizeInByte / MemoryManager.bufferWidthLength / 4 > MemoryManager.bufferHeightLength) {
            Logger.warn("The buffer size exceeds the size of the data texture.");
          }
          const dataTextureByteSize = MemoryManager.bufferWidthLength * MemoryManager.bufferHeightLength * 4 * 4;
          const concatArrayBuffer = MiscUtil.concatArrayBuffers2({
            finalSize: dataTextureByteSize,
            srcs: [
              buffer.getArrayBuffer()
            ],
            srcsCopySize: [
              buffer.takenSizeInByte
            ],
            srcsOffset: [
              0
            ]
          });
          const floatDataTextureBuffer = new Float32Array(concatArrayBuffer);
          this.__dataTextureUid = this.__webglResourceRepository.createTextureFromTypedArray(floatDataTextureBuffer, {
            level: 0,
            internalFormat: TextureFormat.RGBA32F,
            width: MemoryManager.bufferWidthLength,
            height: MemoryManager.bufferHeightLength,
            border: 0,
            format: PixelFormat.RGBA,
            type: ComponentType.Float,
            generateMipmap: false
          });
        }
      }
      attachGPUData(primitive) {
      }
      attachVertexData(i2, primitive, glw, instanceIDBufferUid) {
      }
      attachVertexDataInner(mesh, primitive, primitiveUid, glw, instanceIDBufferUid) {
        const vaoHandles = primitive.vertexHandles;
        const vao = this.__webglResourceRepository.getWebGLResource(mesh.getVaoUidsByPrimitiveUid(primitiveUid));
        const gl = glw.getRawContext();
        if (vao != null) {
          glw.bindVertexArray(vao);
        } else {
          this.__webglResourceRepository.setVertexDataToPipeline(vaoHandles, primitive, instanceIDBufferUid);
          const ibo = this.__webglResourceRepository.getWebGLResource(vaoHandles.iboHandle);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        }
      }
      dettachVertexData(glw) {
        const gl = glw.getRawContext();
        if (glw.bindVertexArray) {
          glw.bindVertexArray(null);
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }
      static getInstance() {
        if (!this.__instance) {
          this.__instance = new _WebGLStrategyUniform();
          const rnXRModule = ModuleManager.getInstance().getModule("xr");
          const webxrSystem = rnXRModule.WebXRSystem.getInstance();
          _WebGLStrategyUniform.__webxrSystem = webxrSystem;
        }
        return this.__instance;
      }
      common_$render(primitiveUids, renderPass, renderPassTickCount) {
        if (typeof spector !== "undefined") {
          spector.setMarker("|  |  Uniform:$render#");
        }
        const glw = this.__webglResourceRepository.currentWebGLContextWrapper;
        const gl = glw.getRawContextAsWebGL2();
        if (renderPass.isBufferLessRenderingMode()) {
          this.__renderWithoutBuffers(gl, renderPass);
          return true;
        }
        let renderedSomething = false;
        if (renderPass._toRenderOpaquePrimitives) {
          if (!renderPass.depthWriteMask) {
            gl.depthMask(false);
          }
          for (let i2 = 0; i2 <= renderPass._lastOpaqueIndex; i2++) {
            const primitiveUid = primitiveUids[i2];
            const rendered = this.renderInner(primitiveUid, glw, renderPass, renderPassTickCount);
            renderedSomething || (renderedSomething = rendered);
          }
        }
        if (renderPass._toRenderTranslucentPrimitives) {
          for (let i2 = renderPass._lastOpaqueIndex + 1; i2 <= renderPass._lastTranslucentIndex; i2++) {
            const primitiveUid = primitiveUids[i2];
            const rendered = this.renderInner(primitiveUid, glw, renderPass, renderPassTickCount);
            renderedSomething || (renderedSomething = rendered);
          }
        }
        if (renderPass._toRenderBlendWithZWritePrimitives) {
          for (let i2 = renderPass._lastTranslucentIndex + 1; i2 <= renderPass._lastBlendWithZWriteIndex; i2++) {
            const primitiveUid = primitiveUids[i2];
            const rendered = this.renderInner(primitiveUid, glw, renderPass, renderPassTickCount);
            renderedSomething || (renderedSomething = rendered);
          }
        }
        if (renderPass._toRenderBlendWithoutZWritePrimitives) {
          if (!MeshRendererComponent.isDepthMaskTrueForBlendPrimitives) {
            gl.depthMask(false);
          }
          for (let i2 = renderPass._lastBlendWithZWriteIndex + 1; i2 <= renderPass._lastBlendWithoutZWriteIndex; i2++) {
            const primitiveUid = primitiveUids[i2];
            const rendered = this.renderInner(primitiveUid, glw, renderPass, renderPassTickCount);
            renderedSomething || (renderedSomething = rendered);
          }
        }
        gl.depthMask(true);
        this.__webglResourceRepository.unbindTextureSamplers();
        return renderedSomething;
      }
      __renderWithoutBuffers(gl, renderPass) {
        const material = renderPass.material;
        const primitive = renderPass._dummyPrimitiveForBufferLessRendering;
        setupShaderProgram(material, primitive, this);
        const shaderProgramUid = material.getShaderProgramUid(primitive);
        const shaderProgram = this.__webglResourceRepository.getWebGLResource(shaderProgramUid);
        gl.useProgram(shaderProgram);
        this.__lastShader = shaderProgramUid;
        this.bindDataTexture(gl, shaderProgram);
        WebGLStrategyCommonMethod_default.setWebGLParameters(material, gl);
        material._setParametersToGpuWebGLWithOutInternalSetting({
          shaderProgram,
          firstTime: true,
          isUniformMode: true
        });
        const isVrMainPass2 = WebGLStrategyCommonMethod_default.isVrMainPass(renderPass);
        if (shaderProgram.vrState != null && isVrMainPass2) {
          const vrState = GlobalDataRepository.getInstance().getValue("vrState", 0);
          vrState._v[0] = isVrMainPass2 ? 1 : 0;
          vrState._v[1] = 0;
          shaderProgram._gl.uniform2iv(shaderProgram.vrState, vrState._v);
        }
        if (renderPass.depthWriteMask) {
          gl.depthMask(true);
        } else {
          gl.depthMask(false);
        }
        this.__webglResourceRepository.setViewport(renderPass.getViewport());
        gl.drawArrays(renderPass._primitiveModeForBufferLessRendering.index, 0, renderPass._drawVertexNumberForBufferLessRendering);
      }
      renderInner(primitiveUid, glw, renderPass, renderPassTickCount) {
        var _a40, _b, _c;
        const gl = glw.getRawContext();
        const primitive = Primitive.getPrimitive(primitiveUid);
        if (primitive == null) {
          return false;
        }
        const material = renderPass.getAppropriateMaterial(primitive);
        setupShaderProgram(material, primitive, this);
        const mesh = primitive.mesh;
        const meshEntities = mesh.meshEntitiesInner;
        let renderedSomething = false;
        const isVrMainPass2 = WebGLStrategyCommonMethod_default.isVrMainPass(renderPass);
        const displayCount = WebGLStrategyCommonMethod_default.getDisplayCount(isVrMainPass2, _WebGLStrategyUniform.__webxrSystem);
        for (const entity of meshEntities) {
          if (entity.getSceneGraph()._isCulled) {
            continue;
          }
          const meshComponent = entity.getMesh();
          this.attachVertexDataInner(meshComponent.mesh, primitive, primitiveUid, glw, CGAPIResourceRepository.InvalidCGAPIResourceUid);
          const shaderProgramUid = material.getShaderProgramUid(primitive);
          const shaderProgram = this.__webglResourceRepository.getWebGLResource(shaderProgramUid);
          let firstTime = true;
          if (shaderProgramUid !== this.__lastShader || gl.__changedProgram) {
            if (isSkipDrawing(material, primitive)) {
              return false;
            }
            firstTime = true;
            gl.__changedProgram = false;
            gl.useProgram(shaderProgram);
            this.bindDataTexture(gl, shaderProgram);
            if (AnimationComponent.isAnimating) {
              const time = GlobalDataRepository.getInstance().getValue("time", 0);
              shaderProgram._gl.uniform1f(shaderProgram.time, time._v[0]);
            }
            this.__lastShader = shaderProgramUid;
          }
          if (((_a40 = this.__lastMaterial) == null ? void 0 : _a40.deref()) !== material) {
            firstTime = true;
            this.__lastMaterial = new WeakRef(material);
          }
          for (let displayIdx = 0; displayIdx < displayCount; displayIdx++) {
            if (isVrMainPass2) {
              WebGLStrategyCommonMethod_default.setVRViewport(renderPass, displayIdx);
            }
            const renderingArg = {
              setUniform: true,
              glw,
              entity,
              primitive,
              worldMatrix: entity.getSceneGraph().matrix,
              normalMatrix: entity.getSceneGraph().normalMatrix,
              isBillboard: entity.getSceneGraph().isBillboard,
              lightComponents: this.__lightComponents,
              renderPass,
              diffuseCube: (_b = entity.tryToGetMeshRenderer()) == null ? void 0 : _b.diffuseCubeMap,
              specularCube: (_c = entity.tryToGetMeshRenderer()) == null ? void 0 : _c.specularCubeMap,
              isVr: isVrMainPass2,
              displayIdx
            };
            if (firstTime) {
              WebGLStrategyCommonMethod_default.setWebGLParameters(material, gl);
              material._setParametersToGpuWebGL({
                material,
                shaderProgram,
                firstTime,
                args: renderingArg
              });
            }
            material._setParametersToGpuWebGLPerPrimitive({
              material,
              shaderProgram,
              firstTime,
              args: renderingArg
            });
            if (shaderProgram.vrState != null && isVrMainPass2) {
              const vrState = GlobalDataRepository.getInstance().getValue("vrState", 0);
              vrState._v[0] = isVrMainPass2 ? 1 : 0;
              vrState._v[1] = displayIdx;
              shaderProgram._gl.uniform2iv(shaderProgram.vrState, vrState._v);
            }
            if (primitive.indicesAccessor) {
              gl.drawElements(primitive.primitiveMode.index, primitive.indicesAccessor.elementCount, primitive.indicesAccessor.componentType.index, 0);
            } else {
              gl.drawArrays(primitive.primitiveMode.index, 0, primitive.getVertexCountAsVerticesBased());
            }
          }
          renderedSomething = true;
        }
        return renderedSomething;
      }
      bindDataTexture(gl, shaderProgram) {
        gl.uniform1i(shaderProgram.dataTexture, 7);
        this.__webglResourceRepository.bindTexture2D(7, this.__dataTextureUid);
        const samplerUid = this.__webglResourceRepository.createOrGetTextureSamplerRepeatNearest();
        this.__webglResourceRepository.bindTextureSampler(7, samplerUid);
      }
    };
    __name(_WebGLStrategyUniform, "WebGLStrategyUniform");
    __publicField(_WebGLStrategyUniform, "__instance");
    __publicField(_WebGLStrategyUniform, "__globalDataRepository", GlobalDataRepository.getInstance());
    __publicField(_WebGLStrategyUniform, "__webxrSystem");
    __publicField(_WebGLStrategyUniform, "componentMatrices", [
      {
        semantic: "vertexAttributesExistenceArray",
        compositionType: CompositionType.ScalarArray,
        componentType: ComponentType.Int,
        stage: ShaderType.VertexShader,
        min: 0,
        max: 1,
        isInternalSetting: true
      },
      {
        semantic: "worldMatrix",
        compositionType: CompositionType.Mat4,
        componentType: ComponentType.Float,
        stage: ShaderType.VertexShader,
        min: -Number.MAX_VALUE,
        max: Number.MAX_VALUE,
        isInternalSetting: true
      },
      {
        semantic: "normalMatrix",
        compositionType: CompositionType.Mat3,
        componentType: ComponentType.Float,
        stage: ShaderType.VertexShader,
        min: -Number.MAX_VALUE,
        max: Number.MAX_VALUE,
        isInternalSetting: true
      },
      {
        semantic: "isBillboard",
        compositionType: CompositionType.Scalar,
        componentType: ComponentType.Bool,
        stage: ShaderType.VertexShader,
        min: -Number.MAX_VALUE,
        max: Number.MAX_VALUE,
        isInternalSetting: true
      }
    ]);
    __publicField(_WebGLStrategyUniform, "__vertexShaderMethodDefinitions_uniform", `uniform mat4 u_worldMatrix;
uniform mat3 u_normalMatrix;
uniform bool u_isBillboard;

mat4 get_worldMatrix(float instanceId) {
  return u_worldMatrix;
}

mat3 get_normalMatrix(float instanceId) {
  return u_normalMatrix;
}

bool get_isVisible(float instanceId) {
  return true; // visibility is handled in CPU side in WebGLStrategyUniform, so this is dummy value.
}

bool get_isBillboard(float instanceId) {
  return u_isBillboard;
}

#ifdef RN_IS_VERTEX_SHADER
# ifdef RN_IS_MORPHING
  vec3 get_position(float vertexId, vec3 basePosition) {
    vec3 position = basePosition;
    int scalar_idx = 3 * int(vertexId);
    #ifdef GLSL_ES3
      int posIn4bytes = scalar_idx % 4;
    #else
      int posIn4bytes = int(mod(float(scalar_idx), 4.0));
    #endif
    for (int i=0; i<${Config.maxVertexMorphNumberInShader}; i++) {

      int basePosIn16bytes = u_dataTextureMorphOffsetPosition[i] + (scalar_idx - posIn4bytes)/4;

      vec3 addPos = vec3(0.0);
      if (posIn4bytes == 0) {
        vec4 val = fetchElement(basePosIn16bytes);
        addPos = val.xyz;
      } else if (posIn4bytes == 1) {
        vec4 val0 = fetchElement(basePosIn16bytes);
        addPos = vec3(val0.yzw);
      } else if (posIn4bytes == 2) {
        vec4 val0 = fetchElement(basePosIn16bytes);
        vec4 val1 = fetchElement(basePosIn16bytes+1);
        addPos = vec3(val0.zw, val1.x);
      } else if (posIn4bytes == 3) {
        vec4 val0 = fetchElement(basePosIn16bytes);
        vec4 val1 = fetchElement(basePosIn16bytes+1);
        addPos = vec3(val0.w, val1.xy);
      }

      // int index = u_dataTextureMorphOffsetPosition[i] + 1 * int(vertexId);
      // vec3 addPos = fetchElement(u_dataTexture, index, widthOfDataTexture, heightOfDataTexture).xyz;

      position += addPos * u_morphWeights[i];
      if (i == u_morphTargetNumber-1) {
        break;
      }
    }

    return position;
  }
# endif
#endif
  `);
    WebGLStrategyUniform = _WebGLStrategyUniform;
  }
});

// src/webgl/WebGLStrategyDataTexture.ts
var _WebGLStrategyDataTexture, WebGLStrategyDataTexture;
var init_WebGLStrategyDataTexture = __esm({
  "src/webgl/WebGLStrategyDataTexture.ts"() {
    "use strict";
    init_WebGLResourceRepository();
    init_MemoryManager();
    init_PixelFormat();
    init_ComponentType();
    init_BufferUse();
    init_MeshComponent();
    init_Primitive();
    init_CGAPIResourceRepository();
    init_Material();
    init_CompositionType();
    init_Component();
    init_SceneGraphComponent();
    init_MeshRendererComponent();
    init_ComponentRepository();
    init_Config();
    init_CameraComponent();
    init_GlobalDataRepository();
    init_WellKnownComponentTIDs();
    init_MiscUtil();
    init_WebGLStrategyCommonMethod();
    init_ModuleManager();
    init_Is();
    init_LightComponent();
    init_MaterialRepository();
    init_RenderingCommonMethods();
    init_CameraControllerComponent();
    init_TransformComponent();
    init_AnimationComponent();
    init_TextureFormat();
    init_Logger();
    _WebGLStrategyDataTexture = class _WebGLStrategyDataTexture {
      constructor() {
        __publicField(this, "__webglResourceRepository", WebGLResourceRepository.getInstance());
        __publicField(this, "__dataTextureUid", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__dataUBOUid", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__lastShader", CGAPIResourceRepository.InvalidCGAPIResourceUid);
        __publicField(this, "__lastMaterial");
        __publicField(this, "__lastMaterialStateVersion", -1);
        __publicField(this, "__lastRenderPassTickCount", -1);
        __publicField(this, "__lightComponents");
        __publicField(this, "_totalSizeOfGPUShaderDataStorageExceptMorphData", 0);
        __publicField(this, "__lastMaterialsUpdateCount", -1);
        __publicField(this, "__lastTransformComponentsUpdateCount", -1);
        __publicField(this, "__lastSceneGraphComponentsUpdateCount", -1);
        __publicField(this, "__lastCameraComponentsUpdateCount", -1);
        __publicField(this, "__lastCameraControllerComponentsUpdateCount", -1);
      }
      static dumpDataTextureBuffer() {
        this.__isDebugOperationToDataTextureBufferDone = false;
      }
      static getVertexShaderMethodDefinitions_dataTexture() {
        return `

  mat4 get_worldMatrix(float instanceId)
  {
    int index = ${Component.getLocationOffsetOfMemberOfComponent(SceneGraphComponent, "worldMatrix")} + 4 * int(instanceId);
    mat4 matrix = fetchMat4(index);

    return matrix;
  }


  mat3 get_normalMatrix(float instanceId) {
    int index = ${Component.getLocationOffsetOfMemberOfComponent(SceneGraphComponent, "normalMatrix")} * 4 + 9 * int(instanceId);
    mat3 matrix = fetchMat3No16BytesAligned(index);
    return matrix;
  }

  bool get_isVisible(float instanceId) {
    int index = ${Component.getLocationOffsetOfMemberOfComponent(SceneGraphComponent, "isVisible")} * 4 + int(instanceId);
    float visibility = fetchScalarNo16BytesAligned(index);
    return (visibility > 0.5) ? true : false;
  }

  bool get_isBillboard(float instanceId) {
    int index = ${Component.getLocationOffsetOfMemberOfComponent(SceneGraphComponent, "isBillboard")} * 4 + int(instanceId);
    float isBillboard = fetchScalarNo16BytesAligned(index);
    return (isBillboard > 0.5) ? true : false;
  }

#ifdef RN_IS_VERTEX_SHADER
  #ifdef RN_IS_MORPHING
  vec3 get_position(float vertexId, vec3 basePosition) {
    vec3 position = basePosition;
    int scalar_idx = 3 * int(vertexId);
    for (int i=0; i<${Config.maxVertexMorphNumberInShader}; i++) {

      int basePosIn4bytes = u_dataTextureMorphOffsetPosition[i] * 4 + scalar_idx;
      vec3 addPos = fetchVec3No16BytesAligned(basePosIn4bytes);

      position += addPos * u_morphWeights[i];
      if (i == u_morphTargetNumber-1) {
        break;
      }
    }

    return position;
  }
  #endif
#endif
`;
      }
      /**
      * setup shader program for the material in this WebGL strategy
      * @param material - a material to setup shader program
      */
      setupShaderForMaterial(material, primitive) {
        const webglResourceRepository = WebGLResourceRepository.getInstance();
        const glw = webglResourceRepository.currentWebGLContextWrapper;
        const [programUid, newOne] = material._createProgramWebGL(_WebGLStrategyDataTexture.getVertexShaderMethodDefinitions_dataTexture(), _WebGLStrategyDataTexture.__getShaderProperty, primitive, glw.isWebGL2);
        if (newOne) {
          material._setupBasicUniformsLocations(primitive);
          material._setUniformLocationsOfMaterialNodes(false, primitive);
          material._setupAdditionalUniformLocations(WebGLStrategyCommonMethod_default.getPointSpriteShaderSemanticsInfoArray(), false, primitive);
          _WebGLStrategyDataTexture.__globalDataRepository._setUniformLocationsForDataTextureModeOnly(material.getShaderProgramUid(primitive));
        }
        return programUid;
      }
      /**
      * re-setup shader program for the material in this WebGL strategy
      * @param material - a material to re-setup shader program
      * @param updatedShaderSources - updated shader sources
      * @param onError - callback function to handle error
      * @returns
      */
      _reSetupShaderForMaterialBySpector(material, primitive, updatedShaderSources, onError) {
        const [programUid, newOne] = material._createProgramByUpdatedSources(updatedShaderSources, primitive, onError);
        if (programUid === CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          return programUid;
        }
        if (newOne) {
          material._setupBasicUniformsLocations(primitive);
          material._setUniformLocationsOfMaterialNodes(false, primitive);
          material._setupAdditionalUniformLocations(WebGLStrategyCommonMethod_default.getPointSpriteShaderSemanticsInfoArray(), false, primitive);
        }
        _WebGLStrategyDataTexture.__globalDataRepository._setUniformLocationsForDataTextureModeOnly(material.getShaderProgramUid(primitive));
        return programUid;
      }
      static __getShaderProperty(materialTypeName, info, isGlobalData, isWebGL2) {
        var _a40, _b;
        const returnType = info.compositionType.getGlslStr(info.componentType);
        let indexStr;
        const isTexture2 = CompositionType.isTexture(info.compositionType);
        const methodName = info.semantic.replace(".", "_");
        let varDef = "";
        const varType = info.compositionType.getGlslStr(info.componentType);
        let varIndexStr = "";
        if (info.arrayLength) {
          varIndexStr = `[${info.arrayLength}]`;
        }
        if (info.needUniformInDataTextureMode || isTexture2) {
          varDef = `  uniform ${varType} u_${methodName}${varIndexStr};
`;
        }
        const vec4SizeOfProperty = info.compositionType.getVec4SizeOfProperty();
        const scalarSizeOfProperty = info.compositionType.getNumberOfComponents();
        const offsetOfProperty = _WebGLStrategyDataTexture.getOffsetOfPropertyInShader(isGlobalData, info.semantic, materialTypeName);
        if (offsetOfProperty === -1) {
          Logger.error("Could not get the location offset of the property.");
        }
        let instanceSize = vec4SizeOfProperty;
        indexStr = `int vec4_idx = ${offsetOfProperty} + ${instanceSize} * instanceId;
`;
        if (CompositionType.isArray(info.compositionType)) {
          instanceSize = vec4SizeOfProperty * ((_a40 = info.arrayLength) != null ? _a40 : 1);
          const paddedAsVec4 = Math.ceil(scalarSizeOfProperty / 4) * 4;
          const instanceSizeInScalar = paddedAsVec4 * ((_b = info.arrayLength) != null ? _b : 1);
          indexStr = `int vec4_idx = ${offsetOfProperty} + ${instanceSize} * instanceId + ${vec4SizeOfProperty} * idxOfArray;
`;
          indexStr += `int scalar_idx = ${// IndexOf4Bytes
          offsetOfProperty * 4} + ${instanceSizeInScalar} * instanceId + ${scalarSizeOfProperty} * idxOfArray;
`;
        }
        let intStr = "";
        if (info.componentType === ComponentType.Int && info.compositionType !== CompositionType.Scalar) {
          intStr = "i";
        }
        let firstPartOfInnerFunc = "";
        if (!isTexture2 && !info.needUniformInDataTextureMode) {
          firstPartOfInnerFunc += `
${returnType} get_${methodName}(highp float _instanceId, const int idxOfArray) {
  int instanceId = int(_instanceId);
  ${indexStr}
  `;
          let str = `${varDef}
${firstPartOfInnerFunc}`;
          switch (info.compositionType) {
            case CompositionType.Vec4:
            case CompositionType.Vec4Array:
              str += "        highp vec4 val = fetchElement(vec4_idx);\n";
              break;
            case CompositionType.Vec3:
              str += "        vec4 col0 = fetchElement(vec4_idx);\n";
              str += `        highp ${intStr}vec3 val = ${intStr}vec3(col0.xyz);`;
              break;
            case CompositionType.Vec3Array:
              str += "        vec3 val = fetchVec3No16BytesAligned(scalar_idx);\n";
              break;
            case CompositionType.Vec2:
              str += "        highp vec4 col0 = fetchElement(vec4_idx);\n";
              str += `        highp ${intStr}vec2 val = ${intStr}vec2(col0.xy);`;
              break;
            case CompositionType.Vec2Array:
              str += "        highp vec2 val = fetchVec2No16BytesAligned(scalar_idx);\n";
              break;
            case CompositionType.Scalar:
              str += "        vec4 col0 = fetchElement(vec4_idx);\n";
              if (info.componentType === ComponentType.Int) {
                str += "        int val = int(col0.x);";
              } else if (info.componentType === ComponentType.Bool) {
                str += "        bool val = bool(col0.x);";
              } else {
                str += "       float val = col0.x;";
              }
              break;
            case CompositionType.ScalarArray:
              str += "        float col0 = fetchScalarNo16BytesAligned(scalar_idx);\n";
              if (info.componentType === ComponentType.Int) {
                str += "        int val = int(col0);";
              } else if (info.componentType === ComponentType.Bool) {
                str += "        bool val = bool(col0);";
              } else {
                str += "       float val = col0;";
              }
              break;
            case CompositionType.Mat4:
              str += "        mat4 val = fetchMat4(vec4_idx);\n";
              break;
            case CompositionType.Mat4Array:
              str += "        mat4 val = fetchMat4(vec4_idx);\n";
              break;
            case CompositionType.Mat3:
              str += "        mat3 val = fetchMat3(vec4_idx);\n";
              break;
            case CompositionType.Mat3Array:
              str += "        mat3 val = fetchMat3No16BytesAligned(scalar_idx);\n";
              break;
            case CompositionType.Mat2:
              str += "        mat2 val = fetchMat2(vec4_idx);\n";
              break;
            case CompositionType.Mat2Array:
              str += "        mat2 val = fetchMat2No16BytesAligned(scalar_idx);\n";
              break;
            case CompositionType.Mat4x3Array:
              str += "        mat4x3 val = fetchMat4x3(vec4_idx);\n";
              break;
            default:
              str += "";
          }
          str += `
  return val;
}
`;
          return str;
        } else if (!isTexture2 && info.needUniformInDataTextureMode) {
          if (!isWebGL2 && info.arrayLength) {
            return `
${varDef}
`;
          } else {
            let varIndexStr2 = "";
            if (info.arrayLength) {
              varIndexStr2 = "[idxOfArray]";
            }
            const str = `${varDef}
${returnType} get_${methodName}(highp float _instanceId, const int idxOfArray) {
  return u_${methodName}${varIndexStr2};
}
`;
            return str;
          }
        } else {
          return varDef;
        }
      }
      static getOffsetOfPropertyInShader(isGlobalData, propertyName, materialTypeName) {
        if (isGlobalData) {
          const globalDataRepository = GlobalDataRepository.getInstance();
          const dataBeginPos = globalDataRepository.getLocationOffsetOfProperty(propertyName);
          return dataBeginPos;
        } else {
          const dataBeginPos = MaterialRepository.getLocationOffsetOfMemberOfMaterial(materialTypeName, propertyName);
          return dataBeginPos;
        }
      }
      $load(meshComponent) {
        const mesh = meshComponent.mesh;
        if (mesh == null) {
          MeshComponent.alertNoMeshSet(meshComponent);
          return false;
        }
        _WebGLStrategyDataTexture.__currentComponentSIDs = _WebGLStrategyDataTexture.__globalDataRepository.getValue("currentComponentSIDs", 0);
        if (!mesh.isSetUpDone()) {
          this.deleteDataTexture();
          updateVBOAndVAO(mesh);
        }
        return true;
      }
      __createAndUpdateDataTexture() {
        this.__createAndUpdateDataTextureInner();
      }
      __createAndUpdateDataTextureForCameraOnly() {
        const globalDataRepository = GlobalDataRepository.getInstance();
        const positionOfBoneMatrixInByte = globalDataRepository.getLocationOffsetOfProperty("boneMatrix") * 16;
        this.__createAndUpdateDataTextureInner(positionOfBoneMatrixInByte);
      }
      __createAndUpdateDataTextureInner(_copySizeInByte) {
        const memoryManager = MemoryManager.getInstance();
        const gpuInstanceDataBuffer = memoryManager.getBuffer(BufferUse.GPUInstanceData);
        const glw = this.__webglResourceRepository.currentWebGLContextWrapper;
        const uboTotalSize = glw.getAlignedMaxUniformBlockSize();
        const startOffsetOfDataTextureOnGPUInstanceData = this.__isUboUse() ? uboTotalSize : 0;
        if (gpuInstanceDataBuffer == null) {
          return;
        }
        const dataTextureByteSize = MemoryManager.bufferWidthLength * MemoryManager.bufferHeightLength * 4 * 4;
        if (this.__dataTextureUid !== CGAPIResourceRepository.InvalidCGAPIResourceUid) {
          const copySizeInByte = _copySizeInByte != null ? _copySizeInByte : gpuInstanceDataBuffer.takenSizeInByte;
          const bufferSizeForDataTextureInByte = copySizeInByte - startOffsetOfDataTextureOnGPUInstanceData;
          const height = Math.min(Math.ceil(bufferSizeForDataTextureInByte / MemoryManager.bufferWidthLength / 4 / 4), MemoryManager.bufferHeightLength);
          const updateByteSize = MemoryManager.bufferWidthLength * height * 4 * 4;
          if (bufferSizeForDataTextureInByte > dataTextureByteSize) {
            Logger.warn("The buffer size exceeds the size of the data texture.");
          }
          const floatDataTextureBuffer = new Float32Array(gpuInstanceDataBuffer.getArrayBuffer(), startOffsetOfDataTextureOnGPUInstanceData, updateByteSize / 4);
          this.__webglResourceRepository.updateTexture(this.__dataTextureUid, floatDataTextureBuffer, {
            level: 0,
            xoffset: 0,
            yoffset: 0,
            width: MemoryManager.bufferWidthLength,
            height,
            format: PixelFormat.RGBA,
            type: ComponentType.Float
          });
          if (!_WebGLStrategyDataTexture.__isDebugOperationToDataTextureBufferDone) {
            MiscUtil.downloadTypedArray("Rhodonite_dataTextureBuffer.bin", floatDataTextureBuffer);
            _WebGLStrategyDataTexture.__isDebugOperationToDataTextureBufferDone = true;
          }
        } else {
          const morphBuffer = memoryManager.getBuffer(BufferUse.GPUVertexData);
          let morphBufferTakenSizeInByte = 0;
          let morphBufferArrayBuffer = new ArrayBuffer(0);
          if (Is.exist(morphBuffer)) {
            morphBufferTakenSizeInByte = morphBuffer.takenSizeInByte;
            morphBufferArrayBuffer = morphBuffer.getArrayBuffer();
          }
          let floatDataTextureBuffer;
          {
            const morphBuffer2 = memoryManager.getBuffer(BufferUse.GPUVertexData);
            let morphBufferTakenSizeInByte2 = 0;
            if (Is.exist(morphBuffer2)) {
              morphBufferTakenSizeInByte2 = morphBuffer2.takenSizeInByte;
            }
            let morphBufferArrayBuffer2 = new ArrayBuffer(0);
            if (Is.exist(morphBuffer2)) {
              morphBufferArrayBuffer2 = morphBuffer2.getArrayBuffer();
            }
            const actualSpaceForDataTextureInByte = gpuInstanceDataBuffer.takenSizeInByte - startOffsetOfDataTextureOnGPUInstanceData;
            const paddingSpaceTexel = MemoryManager.bufferWidthLength - actualSpaceForDataTextureInByte / 4 / 4 % MemoryManager.bufferWidthLength;
            const paddingSpaceBytes = paddingSpaceTexel * 4 * 4;
            const finalArrayBuffer = MiscUtil.concatArrayBuffers2({
              finalSize: dataTextureByteSize,
              srcs: [
                gpuInstanceDataBuffer.getArrayBuffer(),
                morphBufferArrayBuffer2
              ],
              srcsCopySize: [
                // final size =
                actualSpaceForDataTextureInByte + paddingSpaceBytes,
                morphBufferTakenSizeInByte2
              ],
              srcsOffset: [
                startOffsetOfDataTextureOnGPUInstanceData,
                0
              ]
            });
            if (actualSpaceForDataTextureInByte + paddingSpaceBytes + morphBufferTakenSizeInByte2 > dataTextureByteSize) {
              Logger.warn("The buffer size exceeds the size of the data texture.");
            }
            floatDataTextureBuffer = new Float32Array(finalArrayBuffer);
            Config.totalSizeOfGPUShaderDataStorageExceptMorphData = gpuInstanceDataBuffer.takenSizeInByte + paddingSpaceBytes;
          }
          this.__dataTextureUid = this.__webglResourceRepository.createTextureFromTypedArray(floatDataTextureBuffer, {
            level: 0,
            internalFormat: TextureFormat.RGBA32F,
            width: MemoryManager.bufferWidthLength,
            height: MemoryManager.bufferHeightLength,
            border: 0,
            format: PixelFormat.RGBA,
            type: ComponentType.Float,
            generateMipmap: false
          });
        }
      }
      deleteDataTexture() {
        if (this.__dataTextureUid != null) {
          this.__webglResourceRepository.deleteTexture(this.__dataTextureUid);
          this.__dataTextureUid = CGAPIResourceRepository.InvalidCGAPIResourceUid;
        }
      }
      prerender() {
        if (AnimationComponent.isAnimating || TransformComponent.updateCount !== this.__lastTransformComponentsUpdateCount || SceneGraphComponent.updateCount !== this.__lastSceneGraphComponentsUpdateCount || Material.stateVersion !== this.__lastMaterialsUpdateCount) {
          this.__createAndUpdateDataTexture();
          this.__createAndUpdateUBO();
          this.__lastTransformComponentsUpdateCount = TransformComponent.updateCount;
          this.__lastSceneGraphComponentsUpdateCount = SceneGraphComponent.updateCount;
          this.__lastMaterialsUpdateCount = Material.stateVersion;
        } else if (CameraComponent.currentCameraUpdateCount !== this.__lastCameraComponentsUpdateCount || CameraControllerComponent.updateCount !== this.__lastCameraControllerComponentsUpdateCount) {
          this.__createAndUpdateDataTextureForCameraOnly();
          this.__lastCameraComponentsUpdateCount = CameraComponent.currentCameraUpdateCount;
          this.__lastCameraControllerComponentsUpdateCount = CameraControllerComponent.updateCount;
        }
        this.__lightComponents = ComponentRepository.getComponentsWithType(LightComponent);
      }
      __isUboUse() {
        return this.__webglResourceRepository.currentWebGLContextWrapper.isWebGL2 && Config.isUboEnabled;
      }
      __createAndUpdateUBO() {
        if (this.__isUboUse()) {
          const glw = this.__webglResourceRepository.currentWebGLContextWrapper;
          const alignedMaxUniformBlockSize = glw.getAlignedMaxUniformBlockSize();
          const maxConventionBlocks = glw.getMaxConventionUniformBlocks();
          const memoryManager = MemoryManager.getInstance();
          const buffer = memoryManager.getBuffer(BufferUse.GPUInstanceData);
          if (this.__dataUBOUid === CGAPIResourceRepository.InvalidCGAPIResourceUid) {
            this.__dataUBOUid = this.__webglResourceRepository.setupUniformBufferDataArea(new Float32Array(buffer.getArrayBuffer()));
          } else {
            const array = new Float32Array(buffer.getArrayBuffer());
            this.__webglResourceRepository.updateUniformBuffer(
              this.__dataUBOUid,
              array,
              0,
              alignedMaxUniformBlockSize * maxConventionBlocks / 4
              // (4 bytes unit)
            );
          }
        }
      }
      attachGPUData(primitive) {
      }
      attachGPUDataInner(gl, shaderProgram) {
      }
      attachVertexData(i2, primitive, glw, instanceIDBufferUid) {
      }
      attachVertexDataInner(mesh, primitive, primitiveIndex, glw, instanceIDBufferUid) {
        const vertexHandles = primitive.vertexHandles;
        const gl = glw.getRawContext();
        const vao = this.__webglResourceRepository.getWebGLResource(mesh.getVaoUids(primitiveIndex));
        if (vao != null) {
          glw.bindVertexArray(vao);
        } else {
          this.__webglResourceRepository.setVertexDataToPipeline(vertexHandles, primitive, mesh._variationVBOUid);
          const ibo = this.__webglResourceRepository.getWebGLResource(vertexHandles.iboHandle);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        }
      }
      static getInstance() {
        if (!this.__instance) {
          this.__instance = new _WebGLStrategyDataTexture();
          const rnXRModule = ModuleManager.getInstance().getModule("xr");
          const webxrSystem = rnXRModule.WebXRSystem.getInstance();
          _WebGLStrategyDataTexture.__webxrSystem = webxrSystem;
        }
        return this.__instance;
      }
      __setCurrentComponentSIDsForEachDisplayIdx(renderPass, displayIdx, isVRMainPass) {
        if (isVRMainPass) {
          let cameraComponentSid = -1;
          const webxrSystem = _WebGLStrategyDataTexture.__webxrSystem;
          if (webxrSystem.isWebXRMode) {
            if (webxrSystem.isMultiView()) {
              cameraComponentSid = webxrSystem._getCameraComponentSIDAt(0);
            } else {
              cameraComponentSid = webxrSystem._getCameraComponentSIDAt(displayIdx);
            }
          }
          _WebGLStrategyDataTexture.__currentComponentSIDs._v[WellKnownComponentTIDs.CameraComponentTID] = cameraComponentSid;
        } else {
          let cameraComponent = renderPass.cameraComponent;
          if (cameraComponent == null) {
            cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
          }
          if (cameraComponent) {
            _WebGLStrategyDataTexture.__currentComponentSIDs._v[WellKnownComponentTIDs.CameraComponentTID] = cameraComponent.componentSID;
          } else {
            _WebGLStrategyDataTexture.__currentComponentSIDs._v[WellKnownComponentTIDs.CameraComponentTID] = -1;
          }
        }
      }
      __setCurrentComponentSIDsForEachPrimitive(gl, material, shaderProgram) {
        if (_WebGLStrategyDataTexture.__currentComponentSIDs == null) {
          _WebGLStrategyDataTexture.__currentComponentSIDs = _WebGLStrategyDataTexture.__globalDataRepository.getValue("currentComponentSIDs", 0);
        }
        _WebGLStrategyDataTexture.__currentComponentSIDs._v[0] = material.materialSID;
      }
      common_$render(primitiveUids, renderPass, renderPassTickCount) {
        if (typeof spector !== "undefined") {
          spector.setMarker("|  |  DataTexture:common_$render#");
        }
        const glw = this.__webglResourceRepository.currentWebGLContextWrapper;
        const gl = glw.getRawContextAsWebGL2();
        if (renderPass.isBufferLessRenderingMode()) {
          this.__renderWithoutBuffers(gl, renderPass);
          return true;
        }
        let renderedSomething = false;
        if (renderPass._toRenderOpaquePrimitives) {
          if (!renderPass.depthWriteMask) {
            gl.depthMask(false);
          }
          for (let i2 = 0; i2 <= renderPass._lastOpaqueIndex; i2++) {
            const primitiveUid = primitiveUids[i2];
            const rendered = this.__renderInner(primitiveUid, glw, renderPass);
            renderedSomething || (renderedSomething = rendered);
          }
        }
        if (renderPass._toRenderTranslucentPrimitives) {
          for (let i2 = renderPass._lastOpaqueIndex + 1; i2 <= renderPass._lastTranslucentIndex; i2++) {
            const primitiveUid = primitiveUids[i2];
            const rendered = this.__renderInner(primitiveUid, glw, renderPass);
            renderedSomething || (renderedSomething = rendered);
          }
        }
        if (renderPass._toRenderBlendWithZWritePrimitives) {
          for (let i2 = renderPass._lastTranslucentIndex + 1; i2 <= renderPass._lastBlendWithZWriteIndex; i2++) {
            const primitiveUid = primitiveUids[i2];
            const rendered = this.__renderInner(primitiveUid, glw, renderPass);
            renderedSomething || (renderedSomething = rendered);
          }
        }
        if (renderPass._toRenderBlendWithoutZWritePrimitives) {
          if (!MeshRendererComponent.isDepthMaskTrueForBlendPrimitives) {
            gl.depthMask(false);
          }
          for (let i2 = renderPass._lastBlendWithZWriteIndex + 1; i2 <= renderPass._lastBlendWithoutZWriteIndex; i2++) {
            const primitiveUid = primitiveUids[i2];
            const rendered = this.__renderInner(primitiveUid, glw, renderPass);
            renderedSomething || (renderedSomething = rendered);
          }
        }
        gl.depthMask(true);
        this.__lastRenderPassTickCount = renderPassTickCount;
        return renderedSomething;
      }
      __renderWithoutBuffers(gl, renderPass) {
        const material = renderPass.material;
        const primitive = renderPass._dummyPrimitiveForBufferLessRendering;
        setupShaderProgram(material, primitive, this);
        const shaderProgramUid = material.getShaderProgramUid(primitive);
        const shaderProgram = this.__webglResourceRepository.getWebGLResource(shaderProgramUid);
        gl.useProgram(shaderProgram);
        this.__lastShader = shaderProgramUid;
        this.bindDataTexture(gl, shaderProgram);
        this.__setCurrentComponentSIDsForEachPrimitive(gl, material, shaderProgram);
        gl.uniform1fv(shaderProgram.currentComponentSIDs, _WebGLStrategyDataTexture.__currentComponentSIDs._v);
        const isVRMainPass = WebGLStrategyCommonMethod_default.isVrMainPass(renderPass);
        if (shaderProgram.vrState != null && isVRMainPass) {
          const vrState = GlobalDataRepository.getInstance().getValue("vrState", 0);
          vrState._v[0] = isVRMainPass ? 1 : 0;
          vrState._v[1] = 0;
          shaderProgram._gl.uniform2iv(shaderProgram.vrState, vrState._v);
        }
        WebGLStrategyCommonMethod_default.setWebGLParameters(material, gl);
        material._setParametersToGpuWebGLWithOutInternalSetting({
          shaderProgram,
          firstTime: true,
          isUniformMode: false
        });
        if (renderPass.depthWriteMask) {
          gl.depthMask(true);
        } else {
          gl.depthMask(false);
        }
        this.__webglResourceRepository.setViewport(renderPass.getViewport());
        gl.drawArrays(renderPass._primitiveModeForBufferLessRendering.index, 0, renderPass._drawVertexNumberForBufferLessRendering);
      }
      __renderInner(primitiveUid, glw, renderPass) {
        var _a40;
        const gl = glw.getRawContextAsWebGL2();
        const primitive = Primitive.getPrimitive(primitiveUid);
        if (primitive == null) {
          return false;
        }
        const mesh = primitive.mesh;
        const entity = mesh.meshEntitiesInner[0];
        const material = renderPass.getAppropriateMaterial(primitive);
        setupShaderProgram(material, primitive, this);
        const meshRendererComponent = entity.getMeshRenderer();
        const primitiveIndex = mesh.getPrimitiveIndexInMesh(primitive);
        this.attachVertexDataInner(mesh, primitive, primitiveIndex, glw, mesh._variationVBOUid);
        let firstTime = false;
        const shaderProgramUid = material.getShaderProgramUid(primitive);
        if (shaderProgramUid !== this.__lastShader || gl.__changedProgram) {
          if (isSkipDrawing(material, primitive)) {
            return false;
          }
          const shaderProgram = this.__webglResourceRepository.getWebGLResource(shaderProgramUid);
          gl.useProgram(shaderProgram);
          gl.__changedProgram = false;
          this.bindDataTexture(gl, shaderProgram);
          _WebGLStrategyDataTexture.__shaderProgram = shaderProgram;
          firstTime = true;
        }
        if (((_a40 = this.__lastMaterial) == null ? void 0 : _a40.deref()) !== material) {
          firstTime = true;
          this.__lastMaterial = new WeakRef(material);
        }
        if (this.__lastMaterialStateVersion !== material.stateVersion) {
          firstTime = true;
          this.__lastMaterialStateVersion = material.stateVersion;
        }
        const isVRMainPass = WebGLStrategyCommonMethod_default.isVrMainPass(renderPass);
        const renderingArg = {
          glw,
          entity,
          worldMatrix: entity.getSceneGraph().matrixInner,
          normalMatrix: entity.getSceneGraph().normalMatrixInner,
          isBillboard: entity.getSceneGraph().isBillboard,
          lightComponents: this.__lightComponents,
          renderPass,
          primitive,
          diffuseCube: meshRendererComponent.diffuseCubeMap,
          specularCube: meshRendererComponent.specularCubeMap,
          setUniform: false,
          isVr: isVRMainPass,
          displayIdx: -1
        };
        if (firstTime) {
          this.__setCurrentComponentSIDsForEachPrimitive(gl, material, _WebGLStrategyDataTexture.__shaderProgram);
          WebGLStrategyCommonMethod_default.setWebGLParameters(material, gl);
          material._setParametersToGpuWebGL({
            material,
            shaderProgram: _WebGLStrategyDataTexture.__shaderProgram,
            firstTime,
            args: renderingArg
          });
        }
        material._setParametersToGpuWebGLPerPrimitive({
          material,
          shaderProgram: _WebGLStrategyDataTexture.__shaderProgram,
          firstTime,
          args: renderingArg
        });
        const displayCount = WebGLStrategyCommonMethod_default.getDisplayCount(isVRMainPass, _WebGLStrategyDataTexture.__webxrSystem);
        for (let displayIdx = 0; displayIdx < displayCount; displayIdx++) {
          if (isVRMainPass) {
            WebGLStrategyCommonMethod_default.setVRViewport(renderPass, displayIdx);
          }
          this.__setCurrentComponentSIDsForEachDisplayIdx(renderPass, displayIdx, isVRMainPass);
          gl.uniform1fv(_WebGLStrategyDataTexture.__shaderProgram.currentComponentSIDs, _WebGLStrategyDataTexture.__currentComponentSIDs._v);
          if (_WebGLStrategyDataTexture.__shaderProgram.vrState != null && isVRMainPass && displayCount > 1) {
            const vrState = GlobalDataRepository.getInstance().getValue("vrState", 0);
            vrState._v[0] = isVRMainPass ? 1 : 0;
            vrState._v[1] = displayIdx;
            _WebGLStrategyDataTexture.__shaderProgram._gl.uniform2iv(_WebGLStrategyDataTexture.__shaderProgram.vrState, vrState._v);
          }
          if (primitive.indicesAccessor) {
            gl.drawElementsInstanced(primitive.primitiveMode.index, primitive.indicesAccessor.elementCount, primitive.indicesAccessor.componentType.index, 0, mesh.meshEntitiesInner.length);
          } else {
            gl.drawArraysInstanced(primitive.primitiveMode.index, 0, primitive.getVertexCountAsVerticesBased(), mesh.meshEntitiesInner.length);
          }
        }
        this.__lastShader = shaderProgramUid;
        return true;
      }
      bindDataTexture(gl, shaderProgram) {
        gl.uniform1i(shaderProgram.dataTexture, 7);
        this.__webglResourceRepository.bindTexture2D(7, this.__dataTextureUid);
        const samplerUid = this.__webglResourceRepository.createOrGetTextureSamplerRepeatNearest();
        this.__webglResourceRepository.bindTextureSampler(7, samplerUid);
      }
    };
    __name(_WebGLStrategyDataTexture, "WebGLStrategyDataTexture");
    __publicField(_WebGLStrategyDataTexture, "__instance");
    __publicField(_WebGLStrategyDataTexture, "__shaderProgram");
    __publicField(_WebGLStrategyDataTexture, "__globalDataRepository", GlobalDataRepository.getInstance());
    __publicField(_WebGLStrategyDataTexture, "__currentComponentSIDs");
    __publicField(_WebGLStrategyDataTexture, "__isDebugOperationToDataTextureBufferDone", true);
    __publicField(_WebGLStrategyDataTexture, "__webxrSystem");
    WebGLStrategyDataTexture = _WebGLStrategyDataTexture;
  }
});

// src/webgl/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
var WebGL, main_default, globalObj;
var init_main = __esm({
  "src/webgl/main.ts"() {
    "use strict";
    init_getRenderingStrategy();
    init_CommonShaderPart();
    init_WebGLContextWrapper();
    init_WebGLResourceRepository();
    init_WebGLStrategyUniform();
    init_WebGLStrategyDataTexture();
    WebGL = Object.freeze({
      getRenderingStrategy: getRenderingStrategy_default,
      CommonShaderPart,
      WebGLContextWrapper,
      WebGLResourceRepository,
      WebGLStrategyUniform,
      WebGLStrategyDataTexture
    });
    main_default = WebGL;
    globalObj = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : void 0;
    globalObj.RnWebGL = WebGL;
  }
});

// src/webgpu/WebGpuDeviceWrapper.ts
var _WebGpuDeviceWrapper, WebGpuDeviceWrapper;
var init_WebGpuDeviceWrapper = __esm({
  "src/webgpu/WebGpuDeviceWrapper.ts"() {
    "use strict";
    _WebGpuDeviceWrapper = class _WebGpuDeviceWrapper {
      constructor(canvas, gpuAdapter, gpuDevice) {
        __publicField(this, "__canvas");
        __publicField(this, "__gpuAdapter");
        __publicField(this, "__gpuDevice");
        __publicField(this, "__context");
        this.__canvas = canvas;
        this.__context = canvas.getContext("webgpu");
        this.__gpuAdapter = gpuAdapter;
        this.__gpuDevice = gpuDevice;
        const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        this.__context.configure({
          device: this.__gpuDevice,
          format: presentationFormat,
          alphaMode: "premultiplied"
        });
      }
      get canvas() {
        return this.__canvas;
      }
      get gpuAdapter() {
        return this.__gpuAdapter;
      }
      get gpuDevice() {
        return this.__gpuDevice;
      }
      get context() {
        return this.__context;
      }
    };
    __name(_WebGpuDeviceWrapper, "WebGpuDeviceWrapper");
    WebGpuDeviceWrapper = _WebGpuDeviceWrapper;
  }
});

// src/webgpu/main.ts
var main_exports2 = {};
__export(main_exports2, {
  default: () => main_default2
});
var WebGpu, main_default2, globalObj2;
var init_main2 = __esm({
  "src/webgpu/main.ts"() {
    "use strict";
    init_WebGpuDeviceWrapper();
    init_WebGpuResourceRepository();
    init_WebGpuStrategyBasic();
    WebGpu = Object.freeze({
      WebGpuDeviceWrapper,
      WebGpuResourceRepository,
      WebGpuStrategyBasic
    });
    main_default2 = WebGpu;
    globalObj2 = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : void 0;
    globalObj2.RnWebGpu = WebGpu;
  }
});

// src/effekseer/EffekseerComponent.ts
var _EffekseerComponent, EffekseerComponent;
var init_EffekseerComponent = __esm({
  "src/effekseer/EffekseerComponent.ts"() {
    "use strict";
    init_Component();
    init_EntityRepository();
    init_ProcessStage();
    init_CameraComponent();
    init_ComponentRepository();
    init_WellKnownComponentTIDs();
    init_CGAPIResourceRepository();
    init_MutableMatrix44();
    init_Is();
    init_Logger();
    _EffekseerComponent = class _EffekseerComponent extends Component {
      constructor(entityUid, componentSid, entityRepository, isReUse) {
        super(entityUid, componentSid, entityRepository, isReUse);
        __publicField(this, "uri");
        __publicField(this, "arrayBuffer");
        __publicField(this, "type", "efk");
        __publicField(this, "playJustAfterLoaded", false);
        __publicField(this, "isLoop", false);
        __publicField(this, "isPause", false);
        __publicField(this, "randomSeed", -1);
        __publicField(this, "isImageLoadWithCredential", false);
        __publicField(this, "__effect");
        __publicField(this, "__context");
        __publicField(this, "__handle");
        __publicField(this, "__speed", 1);
        __publicField(this, "__timer");
        __publicField(this, "__isInitialized", false);
        __publicField(this, "isLoadEffect", false);
      }
      static get componentTID() {
        return WellKnownComponentTIDs.EffekseerComponentTID;
      }
      cancelLoop() {
        clearInterval(this.__timer);
      }
      isPlay() {
        if (Is.exist(this.__handle)) {
          if (this.__handle.exists) {
            return !this.isPause;
          } else {
            return false;
          }
        } else {
          return false;
        }
      }
      play() {
        if (Is.not.exist(this.__context)) {
          Logger.warn("No Effekseer context yet");
          return false;
        }
        if (Is.not.exist(this.__effect)) {
          Logger.warn("No Effekseer effect yet");
          return false;
        }
        this.stop();
        this.isPause = false;
        this.__handle = this.__context.play(this.__effect, 0, 0, 0);
        if (Is.exist(this.__handle) && Is.exist(this.__handle.setRandomSeed) && this.randomSeed > 0) {
          this.__handle.setRandomSeed(this.randomSeed);
        }
        return true;
      }
      continue() {
        this.isPause = false;
      }
      pause() {
        if (Is.exist(this.__handle)) {
          this.isPause = true;
          clearInterval(this.__timer);
        }
      }
      stop() {
        if (Is.exist(this.__handle)) {
          this.__handle.stop();
          this.isPause = true;
          clearInterval(this.__timer);
        }
      }
      set playSpeed(val) {
        if (this.__handle) {
          this.__handle.setSpeed(val);
        }
        this.__speed = val;
      }
      get playSpeed() {
        return this.__speed;
      }
      setTime(targetSec) {
        if (!this.play()) {
          return false;
        }
        if (Is.not.exist(this.__context)) {
          return false;
        }
        let time = 0;
        const oneTime = 0.0166;
        time = oneTime;
        while (time <= targetSec) {
          this.__context.update(time / oneTime);
          time += oneTime;
          if (targetSec < time) {
            const exceededSec = targetSec - time;
            const remainSec = oneTime - exceededSec;
            this.__context.update(remainSec / oneTime);
            break;
          }
        }
        this.pause();
        return true;
      }
      set translate(vec) {
        if (this.__handle) {
          this.__handle.setLocation(vec.x, vec.y, vec.z);
        }
        this.entity.tryToGetTransform().localPosition = vec;
      }
      get translate() {
        return this.entity.tryToGetTransform().localPosition;
      }
      set rotate(vec) {
        if (this.__handle) {
          this.__handle.setRotation(vec.x, vec.y, vec.z);
        }
        this.entity.tryToGetTransform().localEulerAngles = vec;
      }
      get rotate() {
        return this.entity.tryToGetTransform().localEulerAngles;
      }
      set scale(vec) {
        if (this.__handle) {
          this.__handle.setScale(vec.x, vec.y, vec.z);
        }
        this.entity.tryToGetTransform().localScale = vec;
      }
      get scale() {
        return this.entity.tryToGetTransform().localScale;
      }
      __createEffekseerContext() {
        if (Is.not.exist(this.uri) && Is.not.exist(this.arrayBuffer)) {
          return false;
        }
        effekseer.setImageCrossOrigin(this.isImageLoadWithCredential ? "use-credentials" : "");
        this.__context = effekseer.createContext();
        if (Is.not.exist(this.__context)) {
          Logger.error("Effekseer context creation fails");
          return false;
        }
        const webGLResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        const glw = webGLResourceRepository.currentWebGLContextWrapper;
        this.__isInitialized = true;
        const gl = glw.getRawContext();
        const data = Is.exist(this.uri) ? this.uri : this.arrayBuffer;
        this.__context.init(gl, {
          enablePremultipliedAlpha: true
        });
        const onLoad = /* @__PURE__ */ __name(() => {
          if (this.playJustAfterLoaded) {
            this.play();
            this.moveStageTo(ProcessStage.Logic);
          }
        }, "onLoad");
        const onError = /* @__PURE__ */ __name((message, path) => {
          Logger.error(message + ", " + path);
        }, "onError");
        if (this.type === "efkpkg") {
          if (Is.not.exist(_EffekseerComponent.Unzip)) {
            Logger.error("Please Set an Unzip object to EffekseerComponent.Unzip");
            return false;
          }
          this.__effect = this.__context.loadEffectPackage(data, _EffekseerComponent.Unzip, 1, onLoad.bind(this), onError.bind(this));
        } else {
          this.__effect = this.__context.loadEffect(data, 1, onLoad.bind(this), onError.bind(this));
        }
        return true;
      }
      $load() {
        if (this.__isInitialized) {
          return;
        }
        if (Is.not.exist(this.__context) && Is.not.exist(this.__effect)) {
          const useWASM = Is.exist(_EffekseerComponent.wasmModuleUri);
          if (useWASM) {
            effekseer.initRuntime(_EffekseerComponent.wasmModuleUri, () => {
              const succeed = this.__createEffekseerContext();
              if (succeed) {
                this.moveStageTo(ProcessStage.Logic);
              }
            }, () => {
              Logger.error("Failed to initialize Effekseer");
            });
          } else {
            const succeed = this.__createEffekseerContext();
            if (succeed) {
              this.moveStageTo(ProcessStage.Logic);
            }
          }
        }
      }
      $logic() {
        if (!this.isPause) {
          if (Is.exist(this.__context) && Is.false(this.isPause)) {
            this.__context.update();
          }
        }
        if (this.__handle != null) {
          const worldMatrix = _EffekseerComponent.__tmp_identityMatrix_0.copyComponents(this.entity.tryToGetSceneGraph().matrixInner);
          this.__handle.setMatrix(worldMatrix._v);
          this.__handle.setSpeed(this.__speed);
        }
        if (this.isPause) {
          this.moveStageTo(ProcessStage.Render);
          return;
        }
        if (this.isLoop) {
          if (!this.isPlay()) {
            this.play();
          }
        }
        this.moveStageTo(ProcessStage.Render);
      }
      _destroy() {
        super._destroy();
        if (Is.exist(this.__context)) {
          this.__context.releaseEffect(!this.__effect);
          effekseer.releaseContext(this.__context);
          this.__context = void 0;
        }
        if (Is.exist(this.__handle)) {
          this.__handle = void 0;
        }
        this.__effect = void 0;
      }
      $render() {
        if (Is.not.exist(this.__effect)) {
          this.moveStageTo(ProcessStage.Load);
          return;
        }
        const cameraComponent = ComponentRepository.getComponent(CameraComponent, CameraComponent.current);
        const viewMatrix = _EffekseerComponent.__tmp_identityMatrix_0;
        const projectionMatrix = _EffekseerComponent.__tmp_identityMatrix_1;
        if (cameraComponent) {
          viewMatrix.copyComponents(cameraComponent.viewMatrix);
          projectionMatrix.copyComponents(cameraComponent.projectionMatrix);
        } else {
          viewMatrix.identity();
          projectionMatrix.identity();
        }
        if (Is.exist(this.__context)) {
          this.__context.setProjectionMatrix(projectionMatrix._v);
          this.__context.setCameraMatrix(viewMatrix._v);
          this.__context.draw();
        }
        this.moveStageTo(ProcessStage.Logic);
      }
      static sort_$render(renderPass) {
        if (Is.false(renderPass.toRenderEffekseerEffects)) {
          return [];
        }
        const components = ComponentRepository.getComponentsWithType(_EffekseerComponent);
        return components.map((c2) => c2.componentSID);
      }
      /**
      * @override
      * Add this component to the entity
      * @param base the target entity
      * @param _componentClass the component class to add
      */
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let EffekseerEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
          }
          getEffekseer() {
            return this.getComponentByComponentTID(_EffekseerComponent.componentTID);
          }
        }, __name(_a40, "EffekseerEntity"), _a40);
        applyMixins(base, EffekseerEntity);
        return base;
      }
    };
    __name(_EffekseerComponent, "EffekseerComponent");
    __publicField(_EffekseerComponent, "ANIMATION_EVENT_PLAY", 0);
    __publicField(_EffekseerComponent, "ANIMATION_EVENT_PAUSE", 1);
    __publicField(_EffekseerComponent, "ANIMATION_EVENT_END", 2);
    __publicField(_EffekseerComponent, "Unzip");
    __publicField(_EffekseerComponent, "wasmModuleUri");
    __publicField(_EffekseerComponent, "__tmp_identityMatrix_0", MutableMatrix44.identity());
    __publicField(_EffekseerComponent, "__tmp_identityMatrix_1", MutableMatrix44.identity());
    EffekseerComponent = _EffekseerComponent;
  }
});

// src/effekseer/main.ts
var main_exports3 = {};
__export(main_exports3, {
  Effekseer: () => Effekseer2
});
var createEffekseerEntity, Effekseer2;
var init_main3 = __esm({
  "src/effekseer/main.ts"() {
    "use strict";
    init_EffekseerComponent();
    init_EntityRepository();
    init_TransformComponent();
    init_SceneGraphComponent();
    createEffekseerEntity = /* @__PURE__ */ __name(function() {
      const entity = EntityRepository.createEntity();
      const entity1 = EntityRepository.addComponentToEntity(TransformComponent, entity);
      const entity2 = EntityRepository.addComponentToEntity(SceneGraphComponent, entity1);
      const entity3 = EntityRepository.addComponentToEntity(EffekseerComponent, entity2);
      return entity3;
    }, "createEffekseerEntity");
    Effekseer2 = Object.freeze({
      EffekseerComponent,
      createEffekseerEntity
    });
  }
});

// src/pbr/main.ts
var main_exports4 = {};
__export(main_exports4, {
  default: () => main_default3
});
var sheen_E_and_DGTerm, PBR, main_default3;
var init_main4 = __esm({
  "src/pbr/main.ts"() {
    "use strict";
    sheen_E_and_DGTerm = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAIAAADTED8xAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGkmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNy4yLWMwMDAgNzkuNTY2ZWJjNWI0LCAyMDIyLzA1LzA5LTA4OjI1OjU1ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjMuNCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjItMDctMTFUMDA6MDg6NDArMDk6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTA3LTExVDEyOjU4OjE0KzA5OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIyLTA3LTExVDEyOjU4OjE0KzA5OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpkZjBkNDUyYS00ZTNjLTRlMDQtOGUwOC0zZTA4YzBhZmY5NWYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6YjMzNWYzNGYtOWZlNy00MWU3LWEyZWEtNWZlYzVmZmY3NDlmIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YjMzNWYzNGYtOWZlNy00MWU3LWEyZWEtNWZlYzVmZmY3NDlmIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiMzM1ZjM0Zi05ZmU3LTQxZTctYTJlYS01ZmVjNWZmZjc0OWYiIHN0RXZ0OndoZW49IjIwMjItMDctMTFUMDA6MDg6NDArMDk6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMy40IChNYWNpbnRvc2gpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpjYzQyMmE0NC1mM2QxLTRhZTEtYWMyNS02NGE3NGZkZGI0MTciIHN0RXZ0OndoZW49IjIwMjItMDctMTFUMTA6NTY6MjArMDk6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMy40IChNYWNpbnRvc2gpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpkZjBkNDUyYS00ZTNjLTRlMDQtOGUwOC0zZTA4YzBhZmY5NWYiIHN0RXZ0OndoZW49IjIwMjItMDctMTFUMTI6NTg6MTQrMDk6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMy40IChNYWNpbnRvc2gpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pi6E66IAAKbnSURBVHiclf1Lr3XLtiUGtR5z7X3OzXuvMm2wxSNBcgHJYFdApkqJX+CKK1iU+WdI1Ki4BAYkpEQpJJBlOS2nLTtJnHnT13lf556zz/6+OTqF6K311mOMtfZh7rXnN+YY8Y7Wn9EjRvxX//N/iN//R/j5H1y//7/nz/8xfo/rZ+TvkW9cwBtI4G0XF/AdeAPfgQuV5j0vdpq0+5f9TKY5rjFTJp/qO+f1m7mu2yNPDCs8n8pRsuT3Y2m4FQ7Li1lOst6Y6T2xWn5U7Re4te34PhLn52n0NH6pEDU7Pqk3vizqXi9uiXFLnLebccu+f8ZsyRe1xK3wuBUV/+T/kPgXyD9D/hnwL/5R/tl/mH/2H1x/9n/J3/zNZYC+DMrvp79HSnjPvCAK/abQfIAbkwwE5csw4QkwqcXhi1sCzAQOXKcZx/c1i8rbn8+l37zfeUyPL4vCjZZwu9b39XTzMeUjUnURt/bgy/Se6+tkuzsX8Xp9Qh4HUX1GEsfnkcaOxKpu5etv8AJewAeu17+Zr/8dXv9HfPwX+Pjf4/W/xfofxdqUMoq7bJQfKw672H/r1iDMm/fmHlN+QME/d64Q9odZ1GN2WOFH+3/xE9Zgz3XPG3Ms77MSn6fP2cJHSsinZuCTqcFTSn/6ddswG+A3vx60uCWL2R0v8xeL+oJmMIv1SdHNj/gr5G8QPyG/IRJYuH4Efv3fzfe/h+vfw/WXuP7PeP8Hmf834B8jr517ifvmwOtjV9UOb8r7qblHyus2BC687hR4jMhBNirqmnNw3ebvnst51Rcfz7XYxyOB6r0ze9wG5D5u958gOj9jSXdF5dAE7ln8c1ck7g3wxJ8V8vjJW4IvOvtYkWd0ZvdY7L3BH/g91XlgvTb6gT9GBPI78P3v4f3v4vu/u/Kfvq//EPl/yvyHyH+G/O3CtyuvCETO0cyuz+dPLP87f15PDd2y4rL+fCHm7qPgCQ5i+IxlHrU86prK8hlo7rz5s8Sffe713h/d6z0uvkh8CNWjui+yfMZi7yzc7/8hpHVv7dfD9XV/74SKyRcOkOxkH3gjEhnAB/IH4FfAHwE/IwP4BnwDvgPfke+/j+vfx/W/wfX/jPy/XvkPMv8x8l9m/g3y94lvme+w4QoA2YN+qChi7ZIkR3OPQfkME59Jg6PGOy9/pK6Dc3xW4xcIO34efbmLr5gD8vj5mh4eCzza8Mh9057+IqEecgN24aU9yrQv+qW2fUH8RxuUF1/OxT1XPMEAwMcFrCgbAD8gf4X4NfIbAOAb8HORQZZtG3H9O5n/zrr+aV7/D+Q/iOsfIf8M+ZfAb5C/Q/6M+I4sH08idyMyu2JvnM+f4HVoDo+ze2T8rNsiv+uG/kMm4P8fEBwfZ/ye/tA07ljP2ap7+Z/x6Tv+/MJ/rskCD0B8jbz85OkX4ugPF3pOmXfWfnTw3n4lcMaEz7WGo+NLEiACWIgX8gP4AfEjrl8B34AEXsBCvoAX1hvvN/BGvhEXcP19XH8/rv91Xv/vzH+I/EfIf4b8c+RfI3+D/An5c8S3yO+JKzIRmaSH7k+ezfrs87Us/gNvPnKpOybu7NbzflEL/gCgPN45aOCxnXhK8FjUF7B+vD6kxNcU+NiF4/NYez4h9Q7iz4p6rOX+81HWHTN49OIjArmAF+KF/AH5A+JXyO+IxLUQC/ECXkg5/+XafCOuv4vrfxXX/xL5n+D6fyH/U+R/nfnnyL/A9ZvE30b+hPwZ8Q35PXAFLuBKZGQmgMhqXP7CsD4OzaPm8AjTA2G4jcLjlH9d+53ZY7bnM8Tc2d5x89BMHPT3NuSXc/+LPAWfNNIbcwAoPmnS0Z6jli8kJz5P87VAeGz2I+3BRulgHx/VxYX8AD4QP+D6sXSeCFxRY5Av4DuwEG/gQr4pXN/A9UfI/0Vc/zbyP4vrP0L+Y1z/DPHnyL+4SiD8LuKnxM/brA68r14HS2RGUUJ6kx9Bee/Vff4Owe36zxeYy0+Y0NcfV35Uixd7PU3eoZffefwjsz9kxTGvjzLkszbfxSBuI/mFfnIf9kcB8kgMd73lLoRxG7Ff7M5R432i740BcAEfGcDi3wfwA/AD8OPUHBfWd7wXYiG3FrSAF7AvLuBCXj/i+rdy/U/i+s+x/hNc/yXyn6/rz6/8i8RfZf4G+C3yJ+D3tBO+A++0ReEry2hcUWZAbNvhJh/uHY7bZPgcPzKYiyR8wPQgg0chfn96pFFL7vPxi8zsC9rGzJs3xBx57wzvgNofrth4Lm/JF+Tx+PSxzY808Iufz0TKUdTXYvADgLQgvJC0huNtOUkkuUoOlChY5ceJaxsGiPwR1/8U17+B+C+Q/xni/5P5L5B/DvwF8q8zfwP8LfJ3yN8jfs78WXEVmdeK612cNJEZyHIjxdnfbTzo9zXHN29oOBjzMYJ3tnHMQdym7TBkcZtFbwyeJvjrWfki42ddeGz5ZyR0dByzd1+0LWeux5T3ocMN9J74s349solfbN5dtMYnPd2fjwwEJUC8gA/ERxnEACJxAQgkdaFYiO9FDPnGtqFz60VbFAQQv0b8zyL/xxn/JfI/j/znkf9N5n8b+EvkXyP/Bvlb4HeRP2X+HvEz8hvie2bFVSRNhcI5iSHZqYz6yjkY97kXWMMUj69Z+NcFPg5iPMH6oJPPqriXKZA9Lmw5Vu7dOWo5VCPcru99ufPs+8/PupA3leYXO3tXRDHv4/M79wY/8qD4kgY+VgwGX+6gD+RmxFfhLkgDuS82wSxci4rQG3EhKQrywnX9yRX/NvJ/gPyvkP8k819k/nnkX2T+JfKvA79B/hb5W+RPGT9H/j7jG/Ib8M4ytxN4Z14ZmxJKQSr7eXcpcNkgHG4l3ODyGV+/s+ecP+/Zj899IeIuJY4En4Eyn74fC/lCbYjbBW4AvV/chedjy++N8YxfK3iPeVXsLzL4oyXHhN4/n/EIzexH/SKmWwu6pm4hjXanlEDYVHHV9/7DGxGIwFq4rn8181/J/O9F/pMoV+l/i/zLzL9C/jXyb5G/jfzdFT9F/rSlQeAb4tvK9xvfgcvshGtbzBcS2ISQMbsVW2TYgMUnUQlKskv4bCnqF6U8noD4COhj6B+z3NnYZyrEPf2d+A/ueGhxd3Ac/Pho4WP3j9rV3z/QKP8iwWe0h6fR82Y/VnQIgYso/thMtMwA0oDC41bizYFMIKOQvZnwFZQMFxA0A951vQUCAshA/vcz/1Xkv35d/xT53yD/JfJfZv5V5F8hf4P8DfA75O+QP2X8FPnzhZ9zr0LH98h34h14R14ZF3AFtu/oItYd89bN2D9x8QE+Ga+8zRZI/muGLeUno3yA6QtdK2/3/xB2+5kQe5QkdwI7mP3XUHscDTyN1WdyTC2/0/999A5hlU/Xnv2zpuKXsjzK1Y9EcfEWAvT948JFOeAsJIOiIIok8EYG8GaiC9e79aVIIBH5q7z+DcS/gvz/Iv858u8i/+K6/hL5V8i/CfzmvaUBfsr8KfL3Gb/P/AaUyyjxHXEh34k38rriym0nZJUO7LW2QKbJgUgJLqSYE/Jh7I6J/II27rnuE3Ont3uWQw27a1x/SEWfPfKbzvjxBDVYGx5LCPv+Qzp1NOkLED9mv/frs6G401Lebj7KmaTj0/SZVXIg97qYO+utsmDBEgUQ+q8mgzQnaWyTNoD8e5l/guvvIf/ryD+N+NPMP900gPwb5N8Cf3vl75A/BX6K/H3mz4mfI74hv134DrwD72S0ReQbkWplZAKZkQASGUja0S0ZdrevSoNNN59NzxeM/BjfLySvVrWOOfhM6H9BlvfsX/Dgg+kePXqE2l1cPJZzr/SzTt1J2i++4D45Bw3WBWccnxXyxf2jzR/FFQJYtG4VAbHVmAR2/PNmtdiqRX0WkG+yWEmAN8nDljT3dSTi+kD8D5F/ktc/Q/4J8o+Rf4z868g/zvwb5G8Qv838bebvED9p6SDjmxYQEt+j/EXvKCMhkW9E7oC8CxmZ72rusd5ckoFjnbSkOTrTkr4H6jyiVt9fjPt9NfoPAboSezPuYXZHwM/ByD8jDNwq8oY9NiAnFv/wz0FyX4iaL8B95+J3crr36JFN7LwfkCErFUj2wKt8QbiAV1GCD0Gzk0MLQus/JVuyEJdceYr8uxF/lPnHuP4I+Xcy/w7yj+oPf4v828jfIn+b8VPkT1f8HnSYJn6uCFW8s5ynW+6sRGa5YxORa0udLNVoSwaNXALyrnJiEhhmNS2Mhxn6xbF+5Nme5i6vvVhMWPtk3znuga2jQJ9vPBV4/zz26w/8xFONd1GQtybdBQ7m9Z0qjuz3PqoZjz2KrQKl34jyb+bqi3ghgUhEWgVajQrgjdhMFYBZCG1dJK4wrO013utH5N9H/BrXryN/nflr5K+BXyN/Df5c+dt3/C7yp4zfI38Cfo74cccXZRYZBL4nGK2KzPquBbWMJJFmZi+u9Ygk2I8wJp1A6XgSII9s6VAqrtv0HxC/c69HleNxyj37Z/rJHdaOyEf0HEg9isW8fqSEx/SPWUTb3v3HvJ8B2guPp6o/m6CDMvf9WgmGa/Or//JVpmUm8BLjBBJ43SZMvJ9FaengSkTgsqDkvLZ9HLj+NcSPyB8zf4X81ZW/Qv4q8ldX/oj9h19l/i7zd4gfkb/P/H3ED1d+i/iW+Q3xDfkBfM/eh1yWxxYIu6qSX3Et4CKvL4QHrj04yX9Qo2Lrx4mwnvIf52q/KLsxnzoU7il9YB+J5ED8UekviqZ7S47a/fog1OP+Y5rj8xlYD3rA50N3J4aDgF3I3Kv2ipYN4EclkkNztRDQalcZBol8lUvH0b/5fbBFW4WIKQFWrRAjrnab4pJf5u9mfiB/QH6s/OEt6OePyB8jf7zix8gfM3+H+AH5A/LniN9f+XPiA/jIrRHF9+0j2pSwnUUZZSGEbd7MEgvN60OGkOE7ScgX+8f+cilOM8GFurtE/uwnnvjxsT3lkaMfgHtke5+hELeiPkv2KGc+g+YXJTy2/J7ygPKdW3/dgEN84Wk04vZzp/nQ3ctpYEc6KP5n1XbhTQOqI22/RQ+ZyCDYJlsrSFrGcVEm5P75x5Erc2W+kB+o74/MHzI/gI/ID+QH8oeIHzN/Qn4EfmAYRcWZ5taI4nvmO/ECTeQoSkggMhF13S7U3QRfY5b7NIFacxtD2uO8gHeMuxqLO0DvoM85u9cNDcf0Hz9zTrBHpD4KlgP9nzH1Ozs/qjgac8fr16LgfvPxexdy8AX/HDe/YP+PJA0RgHPr/Rdr6kJZQgDUJpCUBt4g54so3gtj/1XRRQ0jEBeuzVevP0L+a8hAriu3+vVCFvSvHaK0qSJemR+5f8bPyA/EN+S3iG/I94VX4h34jnhtE5lryW/k2iSw0R/cphOZF3LMTJIQOGZbWMytC6QQQEoVLH2go5UcK3ePzYG/x8+aNjEmmDTTR7GPyAZGX/3p3b90IOyLFuLWF+X64vOo+dyb+hm4P6v9KPyRLKPXAXzy+JeBFbgkASgEaFVaqMRGR8yBc6K6KsG+kD2wLryDbpuigf8OEivjnYFckevKFflKbLHwyqxojYyijYyfka+IV+YL8T1yId7IV5ZZ/AbeF67AyiKGiNKCapEv49qKTTZxg/rSZNLRvZmkMJUqS9+8/0YMjjncEBMmEO7IPmDxGdo+Y5x3WjpKu8PlCyo98PpFG77g2Z8B/Xj6GQ0fzP6RFI9acq8E9xM5LrkmcC3EZVaDLlRrjnn1eUoX6HtJ2MlgSwaUZ+mSSL7+TuS1XZeZsXfLZL6Q2yf1gXxFfa+MVfSw0Y+PxDdgb975fuGN+J75ynjvgNXAW7vSgCuxkFfEbsV2EW2gZuPbZRrRXaHaxTg6LtWpBw1+4tVPDZhy5KCEY7aU44Dp46TePzHz3kXBZ7jPT1Iq/WONn+Fbd/4QenCyP6pTq47yP5MYeSvNR/VDkr54NqiuLPrsF5B04GwzgA25q0AJ44yBFXhH+1PKKXQZO4xeGUj2LK8/QV7E4WbKq8NQd9xSrsxX5ivwyljIFXhl/By5Ml7Ibxkv5PfE3l2zEivxvkoI7IjrIE1XmF1G2cp76YAKTkZGmuGbhfnqcdF1bKrAXGw4AFy/ZXAH4zI0MY6w+/dn6scjSfyBUDtu3pWEI2XM68+o6Kjia7adT4X7I2esnuwLafNZy48GfDSV8/neCSlRsPX1WHQksrFSFnYNwXqOAe2+UQKUckFnqPKEfJWB9/WnyO+ReWXGdt8XPUSyZRHbaF7IlbFthr1m8a1+xivyVYtlpRpdke/kbs4oV2n1sxh0ZkZ786MIo9Sh6lf09CkMLwVqsYhJDByqPNEZStODeWfYuK2LfcZrD0wcgL5/HDGf0ZInuBPPnXofS7jX+4V4eYQ75rVfHHTySJAHQ4qhAqEUFenuuRAXakE1u/cV3LZqHTUwtmgd4maR4V2XzbfhfmtEQUsgxWzzT5HfFWMdRQXkxlpnjvJYZbyw/UhRPyNXctNaYGWdWbqCEUtXmQQLuMoyLrs9siRdraNVzbErHsQQOza19J3J5sJIQOlNSIgYBiyUG+OZLaKMibfZexYUj/i78+xHjHZLZj8+q+KAZn5yfZT2+LmLpqM9MVMe5HEnzoNm9vfHax9NFQC3wGvvC+xCT3MHSiTRTWkQnLD0RolpGVdrasn+2eW0VPkh848j35nfk1ZB5KWFuUzRK7atDKzYCtKmASzEylyI78iVeC98v2oTZ2SuwDuRRhUXiPIOAzRv6V7GqObS6G2Mh01TlmuVI54ZPPFOYoTEkDckdJEedmV6G26QPQCtBA4dB3resnyBRf8cGssj17/z8vvTO0bv5evnXX97YBw3kvASjp9K+fGG9lXNuj3cn+pQsfw0d9AqSth8Uqfdyl2YMBsAJQoAsnw2tpapJGqwy/+jzJ+R35DvLQeybIMr8gqXSyLcjA36KPRHYCXWhe8RKzOaNsj7UcKhdb7S8uXtojs3FdC3B4jrB1SIojtNf3Bt2+nYO8RNLETxB5Yyp7DBdOOcj1j8TAFQvgMBx0dCxmvHLOSzjI9c9k4Md1mx5k/Ma9zyftaAz9p5f6RaPjDvOu+P7QOlF2hl2QZbApRqhJ6MvkBPaZDnpd3flt/lT/VtBHDlQv4d5LfIN/Kd+T3yyktuHFJMIjNWxhXYNBBYGdWHLShWrHd+SyxgW8Yb9CviO3KhNj/vv+j9+HWqVwB55ZXx2lFGteOg2X0AeQ0M1/qHUwL5sVQgC0nqwvrpnVMeU5rMIE5/0EPc7uN2cdd/nJYOeOB254B4kpHcaUwV3Vv1iNovxMhBXd6YR4lxNMPL//AHQS+QB3ImyTOJ/kje1AoxkIlYNp2rK8urHu2Y6jRqSc2z5IDtZFmJK3+F/KO4vl/4Htuzud6RVwW25aXWXyYKLooCtCj4HgjEd96PiJX5JvSDQURvG0Np3UlJtsOKIkKu0gQiolxZqPAJuXx36bs/tUSe0vo4DGegUd5nfNjNB0D7TKXbnN9h/RkvVIJHqviCKz8y6TsE70R1kPdnBPOLutmdDPAHdFCfJgB5gdxJB/Ri1kZOJN6b91MOFFtb7EaaIqTCpRxciIU3gAuxbNoSAFeqLq495xYWv7rW7yO/Xfk98zvyuzQiUsy1fUMXuxjAFYGMpGqUCLMHAoisrY7bEkA7vGofUHMTLhFcyZiiRn+ZyDvYWppOmI28WT536aDs6EJs0UGYFDQjuJfa2oN053k9u5w1uVbxORBxA98XKPca72Uen9GkWVrYyOLWsMd6XVY8qm2HiPiibY8d/xiFBi6U5xy0enU4XIGS10EJkM74t8S4130hVus8ceP9sBkuvSiR5YP6AfmrzG+R31eRwXsf0BW0Cmgi03+fiNKIULcithAoLT5W5FaTrjIeYp93F8CbJn01dntLt3S88tJyAeclow5ATYoAM1456jv87iosl8+UHqQjvM6Jp70IvCHZ+ZWOAQZy9zjf0HBHqj+9p79fO9n8IuvF7fter9+5X9w/j1rQZ8nuj+J0g9IbEh7FgK1W1N+17QGZyAuRdBCtT6sJqu0JwhrFqnENf6tMDrRZHMgfkT9c+cOVP+LaulAfLBe955LcuWgAAMoYyI37iIwrvknemfn7TjY2oLWCFgUpU3iyf15gbUEXRb+HyI+sQFi7k70uUgF5expPM0Bg72Jv1HLHYo+/uZKuHDk9y6NAwK00/9wfHRIGT1U4HB8VmHtRj9XdwXbH3j3NUUhvidwP9iRfthoQ0yQAV8rKKRTAKu+eyOaylFtcVNGLNGXQB3j8VlIvSkTibdfID1w/1Jl16wfkj5nvzHfkmxfcGKn1go2WgLz3m1lHRGQkvmdEnezFyNWohmh3s/W59vPsfQ2ZbRjU30JeO3Rjj3m1W+sJ21kUAB2kKPuYtwh+uDl8+Juwe9T4aDFAI+SXmPchmpTlkYV/hubj0We5cpZ/VOT38fT0/nkkiXt1n+V9LMSMYBOa/QakCX3BupGdFTOXq90oHreYKJ0e4DMUv99iQfflCNpyYC3atReAF9YPkT9Efsv8Afk98nuWSfCDmQRX5ub2e/14K+M7nKjwn9KUM4C147K3syhpHtTBRrlff7O3c8ZVw3O1bCr2f2UjPgN55XbvBNG+sRpIQywieXoFPUVpek1RLwcxKHnm9Pc2hd7irGE/pv/Ed4zUXyD7EZR/iFhwoeR3/PtRBHk5d1kU05A4+viZTDjK1/XHmZwsv9g/AJrFyadlBEex/73+M7Qm2wtWriGFEu0IiNWaz7UIp4smtV9AGhHDoa+9CeYj8MPeEnnhh9oOFlfkdaXiilI+wg1IKkVXgTvq0VUOsEh8L88ptoOoBqU2tGVE7PVjUkJTRXF15BVBuxngVmhSnK0ZR5SnyCMsKsyoYy3KpbrH+KoG3bT6k1QqjePvroH0spp4AhvzyFPvoI9bFV8TzP0bM72X81hXHN39ZBjutd9r2Z+PvAWad/tICTumDbwjOrm0gUZjt279v+g8Res8pQ659n+Vi+mi5lNpFCB0vRIv4CNXb5dB/kBF6AfkPjXoAnbUwv4ACq3YnvjYnPiiDhHpOjJwHm7BnwR9+YqdBiKJ3byukFc4Gc1n7HYuICClowGISEdkNQ4iA0rpTUIC6kB2u1Nb10n258DBwsBEGjoCJ5E9IjtvF5/dfCwnnpIdFYmoPqvoUW48NhIT+vvnR9z6Cc5BKMfk68CpF2mJoBi82Q+b8ScNAJg6lLwvrG/N552tFCUjiHJVuFvk68qPdb3efoTd3gkZe4ngjfy4zCSIWrsq8Cd+QHzbe9syvnMgIzOo+bxz9Pxd4f4RV17NImu1eLt2Ng9ZdBD1gG6BAOyYui3t9n/UyBkQxI2aAi24whBkzCw5+I8h/fxYmju1eCoHWZOEaCk7GSY0j9rcDjkKjCe8HhLGxqyb/1maI/FR4B/Swf3pUyFa7kSf71DcKOy+qUmwnzBPUUb7hQDgwmvhfXEN6qrQiTJ5N++XtlNA2lzfFgQycL2AV2IFXrlemxKQH5HftX0s8a6TTeMDeUV+ZPlmKooocGVBMnTha7/Anvw3tZYdyVGLYps/Zv+8gFXmQZ0k3A4ibrspMaQgh0SpRiVKgvSUJSa5albSIiE3UQefFkRit0fwfvqQEuiBpdJmgHjUW3owRDke0zXxdPDpA+hHc7yEL5r8WUb/+YsSwB+Jq+1k1+EGlQx13k/+SAmAJgNBXxr/vqh9ZCBP4NaCWLiuEhThxDB9oKEV3m1ka67WilzIV+bKS+y/VKPAO+Md+ZH5ztzHW7+ShgEDETaIvsveVDAHwxKk/KAuCnqB4v3q1XZcbScwUc71AcqBS4GlUbQRGdRnDAWlpTHaNJMNa/u4dKFaj0DsNeYGU51tgUNOOES2F5Y4PkMtPqOBcXPqIp+lP3DmaL5zdBcd90/cMoqjPzTvS7K8dzBKAnDh54q+6MIUJUrCkDXsZOA+0L2PLKn/rItuU6r+8Cijiycoon6WKEhuGdMunFx5rcAC1taIojbRv6K3Sr4SH4HrwgvxEZnIHYidgeuKjOSO+OBJ6+GYebsg0HfQF5RtDEDrVLvAHe9XwUKolTjqOsB2+5hj05w8WxTt673ywYkjSredIJNg10SNKptDg+0CvFf6WM+qfGU8wOqC4kBVMQorMebTPwTQsBpnYX19R7+37Z7l/jNujT+uP+6t96ZvTNcJyZPrw3i/s39BXGVl4JIQQClC62oayMsQv2rvFtDSoDnaWrmtjUux/n6eNTfB5CvyI3MfoPsBZMa1Mb83v3PxCheN42jfitixvEBgkEPYcO1lgW1x2xpZKiDiCi6O8XuPPvWtPR7JKLrScfr+bkbuL1JAjQMVngAy6AM915NJL+ioCkdD7IARdvpRAhzYSMsuTaHF3w1CX5f5GZFgVqQs8ZTmKPn+6LrdTIMnF8KsyvSQOBb8CPrj59Z89hFAJSWWcYNoezcP3r8YO7aa6yeVn9D2g2uLmZVYsVZk1H75fCU3SVIIvBJX4hWh9YHrwhV4rch35g5r286ijcnLtKLQmfDGVC8gQT/kYI4XV9BQ0XIlFhbpITG0IHmBtoVeF8UsQJdPxc753JrUoIhoNxdcX3KExYVS/w/ICFKUgzOz8dpHleOgDai9eaaElXM04Hh60MZn6b+gnHsufVTmeTDWIVxgjSjlfg4BBA4Pwo9SnK6oP+F++zqD0qDYLa8HVaAMg2oAr2tcFivbGtXWhaDrV+BVYiFekW/kK3PHTl/AFXHRM7rjgxiGE738ylCe2Vvzk1IOhNhfVrdAe+DKfahqb6x5no4QnssOLhGyB+oCpBqlMB6si0tjO2NRR1MrGyb9a7d2OITOXrKGkhvReUfiQ4bACpFMoEQaHXa58cjR9fRg/2rAUcjRhccCcavr6PWHDYjVQ2quqZ4SoHuw6YkLAoyvIVCn2iOWH1R+pPrHDkAyX9BhB0cDKYDItU+L4PFd+z2rtT94mwRXYh+LsoBXxBv5ulLr1C/EFbnp5wWRdyTP/Tro3aVBOKazqN6Xj8JXw5PnCFQEtd5wU5rSBen/cyG4Bg2g+4fgqGR0ThJoZP8yCQT7nO2L7EKfuWUAFx4MiV9k4Xe+weqfie2x6vujIans+qzul4qNp58f51QD4C7aCHxnJrH8468ciAR9xcrQkco4tKYN/070kvC68AY9QjDJAGD/W0ZC0SON0f23gFfiO6/bNsjY4aKvxBV4AVdGrswrX4oTRWbghchro3/6R5zzNRkEtOa6bWIjAPsW7qkvcUHgIrg3srlasRlwSYbcOA29B20vYxBWUYQFUoNwWrco5UsFUpIokbPFDbMZCCa2GMEEGiCW9uDKx6cxZzrGnXP7z8ebWrDjgH+qAh0SyVtyNonpPx7zyCp4Ad8ny+8uedBEC4t6WowxgG0JakkByG1VC/SBAN7mCKr7YDDcRStcg8GFhkAkFqXUurD3di3Eitw+U9nKG/2vWgamprTRn5FpvH/EGiiOyCagBimWPPBXc+PkEC6ZBNH2wB6eRct4ocRIQV6WMDed5fZ4brZ9oVa+xO+N+7co2uRZv00W3CAcnifIrTXD/muh3ioC0rGX5GwCGMM1K+TPSW/z4bhzMGjdeSSDz2jjaImn+XhIzbGQsDftg9Yt3d3CffkFw+7bnZov34g7na0t8UEvqhpEBxE7EECE7AH726eLRh2dsvc9lp4TFXGx77w2243MUlHwKijsk+BBbWNE1HCTV7Orvc/mfeXamh1HuFpaClKudHugfPp74Sx6aQDYawABXLVmXGSxvaKl2FuIA/X1Ru5UpyD+zYHjYoQpVDeod+sbEhQm1XEuZShTjmEZo3QUctRyZ9c5r+N25yjg8XNH/J0a95TQDcq1zcpv/BvB6H8b1Wb8tHpX4nu0A6O8ikFVp4tGGPQDc/WXAfK5HPEAOkBov5WY0mi3YlH5CbOJ6y9iIePKtV1DgYV4vfPaxJBYtUiMBF45BqeFVhmeWBMVteUmuM6bAMVLjV+qqLwiln62KzQRseAhQ702vBcTSIigMBCrAP1HI/AH7QB1xtuOIHMJDYcqrNkK07ijq0tI8cobtWBizvE6nn6mtXyC/jtdPdZ4CI3nPmwVCCP4oLi+ghv1b1VAUgoVsMV54Ht0WGgy5U4m+dzN2TOy6oQIyOJa4pLDBmixRaWInQwP2gmSwW5HUibsXfCbHq5YmVf5Ukv5ca/oK4GszZoA3fHQbKWm4eIIibtrL1xWVgBcEnZBVqw3lnMGk4JmMRR0ZwxEywKFccCpoqqd7F9kQOYtoXOsasW4ejISmMLAG0UGOWHqiHQI5CjPoi1utfjnUap40z4TPrBWHcV+ZNaBM0rnVNs/yd3rgcgjuuDND0L80LD+SAD7IsBlMksQpIG4jvHKoo0cmhml86a/hdzH/iwayuUwTb76Jsj7V8mB3DrSnsGF11UIVqeT3Jl8u+GOLQqucumsLGZfoI99COk2lFPnDJdYQGn1Fseww4R4oUmjJaCp3gLBQyq6vSsisUMAKyxp5wpxD+I/m1YPMVD9HVIEw+EFQmAXAsXRPAmEZ1ly4DK6ivsnbz8PrAsqBwXmDXe6Y69IslL8Zjn4hYKOqu+2XwZ9GO8Hpg1gNwFLY02r8Dg11ORA9JJxbr9QJrb2X8vDGSvjDSRWtDoUIgyeFfdKXBHryosWQjlAL2h94MrgJp2yFgSFzHwFLh+3RAYWoyGQ2/oMGdyFgR0ogdZiZBwvB72WuYqpoJYYWNk2giMzV+mTCpXgYFeUR82cfPsFDrH/aAZuWpxA4J7MOYN54o9qgUkXg/JMeX5Onm049UdDUH2Wd36cDO7oh68EK3zBG1o6/S7FoJ9UeHYG5/o7ZP4SYwlmAVb2vgKwTEHjof/7o8hQats7yQxTUbkRbQwUDQSPyuoTgfrO1n/Ku7RwZYX9vECSEySyNYKL96V3wdcEstbEueOhurH1n1orRw2SFIebwpcbubGdy5uuzGJmMCsZb/acy1tq4gPAWD6rQS/py8gixUSETDVzsx5koKHPcyLIK6YhoZSfMe/z58GM56+nhw9C4EjsIM9HL5Dyy8xNcXfWENab4njbJRnI5InQKB+21FHxMA+yUAO7xRQC3o0sJSK9/2mUACKevL8Yf2yNqOmhtBRayZlxRa5aftAhwBt9RRg7pGcFcPUwyIkJGb5ZHGBF32RId8gmlhmw39ZBwNFZ1Gy4MN87dkIiIVv/MaCQoBBcIeAPGhM1+kyxa7FTXCidLUiO94Jmxw1xaoZNJoGDgMTds0B4/DwIhLzd/7youN25f3aacTCWk86ehwV8BxBj2js12f8mlSuap5FfAbjpPwl4gB2GCqSUDvRq0kpcJQQSPUO9StADVYsUQeiLKnLrQljAdYEb0gqXQrwUIfBiRWyVetVExJpi66LwgRnEioe7NuIjrqs3zUiKGBk3y57vdUWrQ9Amm7qX4JKZSCIaNAkEF8JMoINLCkCpSlpD0B0GRFQGhl1knmyo5DxHn/eD7W5+d5ABmtqP+W8mDaOivmW/vhYmR0qvOrYRfM+pi8vkQNB117p+s68+TQhqaxTX9YiXrlxjgyr8GAAfArYxY2VeqRquwSxBubW9JuL6KEWIf3vfpdhz6GfwZKHxtwicBN2gHIBtQrgOsO1doGVChnmYE4vLWTBbPrLtntgrTqXN1xAl5YMIIbloQP2kGH5e3N7DxduNWOM9Fc8tpV14pNHdCuVwp7qU2FJIaGl4PThPmxbjvPEAXweIfh7lfS1MHss8UqoJvSEmyWvlA3USPIUA59yZ/cbC9+w0aehXnWJkLQceO20tXsCbiKz9NACMtcitXtECZUYGlWce+B/Y6tB+tGJdeW3FDbXVPUhFyxz8C8gLi2xu63ons+Bnw31bpyuq2MWVw6u8bmT8fFQdishUYsNtCuulAkU7dkz7p4KEyqaZaF4MbS4rPYdrZ73Oa+iulGUkTyRRymSes9fT57RkaKo5q/yDhB6J4QaiQUXHLHw2NUch+84HKDRxC1w0iUgmFjXiwj1M7Umjjbg1XLJyX1wS2SC13PtNPHLsKuSYZ/YDtCZSUjLPIpoMIpDbrRp8X1igYvAiXPuvxQEZNZlY3JZTZDCpZdPYljN7rMoA2AJBJq+JnUykHF5BabBdiR0Q2jNWNL4VeqMHWgMwl2a5kkIDXk4pOnui/GeNdA8CxZ7ALWU49Em2vzVFG+IRPepzDtDB3xTiRNkT5WXCsj/euZPB3SX1SAPePN2hG/SJChdPRNgguh6oGAmswLfbi+B3s0QGwVogLuqID30Vg9VTRRfQnM4oIdDQF6EephjcGbpP/iFkk/QQdej1sJLJwneJFcokNQkZMnm9BwvYRLVKU9oOJaAWWhY9p6GRuHoDxO7m6k5p9GpyyOUZAJFMUaxnD2rtOqNTYk+dynIruX7e1JmSFewWgclFbFZp/RcZbJlyx+4wTliIEorAg1zt+OTgg09Af8r7uYgeaWolWODLeeHX4qiYzH73UBKgohdpHgTaO5hEv1MCyP67uUak1g3tNcnos8hdSjUhiKHQpwnpQs71MXGf1HzYaaIaa7PTC6kwB2CtcgSV0qJv04I2t6sXVIr9awUcPXg8Sn3wRrKKWiIA5CETebTaE4CrTLxo0GZq978JmuP8ohrsWlbgFxmk1CS4sGi+6U3hlNynteoJwUQpte7gTH1ZOcdHcA1M0WPgeSBIu/mB7AqcaIC9XbBn5EKbvGGzRe0bW5v+hmKqLQrk8Sb7hfXzMvYfRifeVsKoLdSKqvcZsCyoTZc84aec7SH37L6WOhSRmZc1MKT/oNJIw9mtXlrf9RC/GGrPxZHYbH5rLQtxZa6IvKrrsgGCdkjHS5csNEAjesh5X/y+BUK5Phu1hX6jE26rL3dqCr4AtCBXeJB2JV4GDWqDUejYpQvHNi+Q8I8uBL6GIT67waC5FT3E/GkgYeE3UYABkNGkXgnWsam+wBSz+EamUQLEOzgzopMegqjpbYFl6Pd2ne6gLj6DNLAPPeREIJA0pnNmbA8WphwAgidxyVBeVWAdHqrYqOLxqDUtx2v7WNGiYEM/LomCBCLkD5UutImBFtQmCXmcVrCbSbivxFtOSGkmZrnVaIcNPeRO3c7+6KfFr4MnAwSFQQBYdJsW7ZYqTyz1DJoyNIGWJhLunsYWCBQt7j36hFSGdDxgEn7TWnIQyf3z4Y0W9K9Hg9h7YD9d4CqwPcnc3vL59HKmLSaoYy4WAJze/b29PTNz0QgW6LOcJNXl2bqkLh98JJkwTQI6THUz4GQQFi64SJPLg/dQm6LL6lh1lGIpP9pPPDlJn4CqQTi5Wq5VO5eLhkA2HMNVih2EhBYCZTAXsw8AbTrLfzqgX2k21hk1zQXjJBm0FVtQ25fbp8S21YTDFp4HoizrfhTJ6BZPu0nloCIQpQ7GOe8HgfWQHp/zeHQVdMN5dXHPhFylpZInd70wM/0SNRwLeJvbS9Dvjs2J7+sauasO6dcx/Ng0kO9d7eZum3vNoAKnNaIThvuC9lVaUwbiTRpwMijPKdZVlk69tK4S7IOmERIC11wP3uKIYkGOVygWsXnVzk9+cd0GjT0rVhJiOc19ssUxuOcAQUHdq2eUAPKtNucGuPRbk0hQqcwSv26EED5kiC4apN87sJwMIscN5/oiLZMwg+unR1w5gMmrjsT6fOB2605V4q5VNCdWpYPQF6370rs7qvdPcXcN/iHdQipZDe3FpVOtfe3ZT7pRYAX01UVizPnNSlTb0ipfGiWgz81dXAi7RBjR5RQRcet/UP8O6E5BP80dtMDXLdRRQnP+fJ7Dhqu7KYmRW+eWD1Te0dB7jukLKmGZlYo2QNkM9Fy4pZzY6UMkAQpRaI2tyaDtWnMpuQexPVLHp8mm+K2PQRpfV1kHsn32ezzdtLml/Ig6TraZcc6C/I6EAD0X1bNAHY92ig/qPzXhwVPXWaI7Q08p2Y+urOO28l3SIIHkuWhcdy6N+fJSFqvrZfzd9tQUlhwgr6q/1SaybOIgqOP6xG26xcJCvGvHvwRFrTcHVrI1CESujCsTiFWGb55jIv4u3reP3HKJkYXUCwqQ1tIVVZxo92gVHdMCJgkB4GETLQEqloLDSNcRih1mNw6tXJEHR8vi6Mk/BYZx2yYDX+scOGQX+nMQ1Mnso9OrqPRYIHnc9Se3T5ir1Ll+UVV7JfqFW6JyCY00iEsIuGRQq5OYKs6EK+p9YMMRtOlBbICMMJigxyUoIhWabMZreXhWnUS6cQ87MH2Rr2481HnwXLpaNgbaOdcKUnU3N9YqMvSqF/E4HpFgaDMpFmTwIgOQg9vPYpcrMyumOhGMnd0CrxxARV1NDkTqXvWqCFKpTzUd5PjR/D57TQ3+U+bXphMmJmoKEuLLxUkbFbfEu0geJDtYu4J0Dn7tZJDH/RvJBfDhDPMwfL0UodypR+QRWqYSiI0MAJd/1foKEc6KIHIqn0R/Bd7i+ncayIrQJNlmV3ovU65Pjl4td62MHWEPIDKuINxls24mXYxsxT4oNBbjfErv31wVe49j2QO1HEbQRrDSqAG4jL+Et3ngvqcp/CYZUmp25TnBXC1WlbYsJiOhGtjrxGYabxlyte9URwZFSs6UQMVNONDNBG+9OZQG3BuannjjbN0mtFMTXfFEBufPIUroBXJaOUQB7J1BaUUQL0OfubS5zCz3ZA9NFFprANiq80B/5vadZlzZBoCIYf9d0dtmsk6MjfSqNmIyuvwgj29Do3/G1mEOFT/rkHQtEbxLfcqIIh5pRP1S98jY2pCWDvRW8gJ9RoZWTngcgORCDwV1jbDxK5QD9PWv2O/hM9VdZ0LL6UnfDIky3aadilAzM8WflqFA9r8JgTXggiJPiUXpYIYrR7b3kwVPlBbOcAM2B8eZh32cZnAUyB8fuj5en3bWgUfBWI/FgIT7QB95ojvh5D6ZnOSaNy/iAt6BC3ktvmVviwWIjY9TaYsf0g/Y8ZY1eqY6L1nqTQbB5pQGv9n5po11GgPbs7V3uwQQ0ZSAQFyEfqO3Vmm2uhCrGlng56pB0XIqNcUjiTxWXn0sCihNyBW7X1uXkc5U7L3GSZZxND0cDlDzbGAczqsFBmKFsqFQ2BnoD4UiTef8osUTvLCmnyEp2KQD0E1NvHuXA6YFVOLd/I93dilpPPu65S86MTkweL/XbesXongJFnXvJV+Qs7tR47VwvaleMdhCpWbkBa4K52wXfX89HEFNg/Bo9/+e+JLxVNx5yG+AyDv+gv5NsMBoHyjJs8TFVSioTTBXAx0I84SKWsbMcfZC/ksm5NpLht8EXKUXBZQbh1Qx0NZqUmpqWQLFB6VEryWAjFc2q8kMEpIhRtzugQycoz5z/GDqsXVBowS1rnnrZ99ieB8H7rtZvEiSbrD0hhQTZTfwRpgbeTn6svWAw+SIWfu2FHj6/kUrYx/CkhcLKEEPMlYfNNK7q0RXdMuom5cE4H71oJkJW9XKpDSQWNh3fEGgKtnvotxbIssZyfcTq0Vk3KU0R1BMrIzMjhK9CfHczqYyedNWxzxN44SVFJUTXPO06aCE3E2R65Daj0F/j7fWxfiGcFB6wMiAdTdVICg6pE0QPNVkeJfZJcfuBdfHHj6HRnTgUd/7foVCKNE1bYDLMotby9eYJA+y1Yfq1RM5Yd7Wrpgr+fPzDrzp/t/ILHcQyvydMoGubbYkK7aBaA9Ws8mPo9wrA5mcOrMHmvThj0AfEYBYGVfIAGiK0gXqiOtmQJHIWDwF0fa7dxiqsG7qnbNscK0ixS+T7hxQVEQil5ygZTwVfSxKiaQjNlvTkXYExlCwQTBxURjs37sVTCeq2HRE4oQK6Vm3ROmj0ZPEO+KrcsceEG92fPOTNltnko/yxgGYWHQ5cKhDYvyV2OjbErGQyfuvmUtVNL6qAVvpv2hXX9sSoAV8JfakXCLDnY9A6TojOeTYPrXitQHEfu9i6BT3vW8matqMGJxxZNkDmyXulxkEYb2BtxMA9VbJTPlDtQ4whkE6jnh1a/UanO1V5YPUAnN2N6vY1dGH2kRPdZ7jE1KMhhmAoKszinj2OwSKz7dpDS2NJVl177tcMHTbygB/guzbnFc9Ig94atdWJWdcipkWN81jWAWwKVQhuRfCOuSGYHVauYxPt6xgvV3F7EmK2d8dGkx2Y/n+uRC1+hu4qPAk7+x5So2Y7GOUI7z6U0pRnck8+q9ONb+quGcXacROzWK0S6O0oGKii6tj0VrQLjv0ihxkXK04S3buqCGBvd4/LiNYRBDeZgJ3k1NHAZAK2Axkx/5sbBeNakuNsJVEvxbHtl0sk6EIB7kCF+HeFgexq4Orl7lAqXoRKYUS3r2vBhxOfhYyGL5uW+Sp8/gwzN3Btp9+iCUrtMjrGJYrxs0tmE6fqdnzvnLhVbLjvLanvH4H3shm/4vO0B0TkTyPvSCeGcC7Aif3hGUrphQJK4oTZwGl1BJzPclXsyd1K79BbcddQH0RiKtws+87Y6a+lIFQuBEX0JudMz601ZmWsj0s5aopwtASWiAvMvF2YnbPuZuhVSN3ko5MSLlBJRZQnk/iP+aywob44tsOxJUpImOhd8kED4mfU05HF1k/u1zE5ay2gIeDhxYzGQYqMRnMciopALQS7IqQ7qRYDmlIEkA04IUK7nsCtTFkSACj8jBZVsdB1/xcsoDlBQLqkMw9+/utRGlksHJ7haxFZJyQ2AlrJ5kfj0ZBJSm7u9KuXjuj7I7yil5GEuTrcRFVoCgAX49K7WtXoXVf8zVykBz9nI4C/HhUxBCrjlcJdXMrBeY02mKqjSLpQnu2mGr/2FGliX53QXt+aHvaCnEvFGAfOFPckQsFA8clJGQv1z9i7hpKgq0XHmxW290RPs9mXiex1xzW/PgawzKCnZf7t//BpqRlcdfbH+M+JzmKK/tnQBZX4C3G/8bm2gqGy+0F2sNFX0QZxCjehUCWwuBxvjb9BTLyWwAr4x1cGN4Eh3L47JQr5DmtAeY6UcD0oqAQoGc9arm3de32JSVJDtR2tmEq4ZBRNuvKsjsyOg9ncVNaMfrKnVTUBdYaGoKJThd5RaWXZcTq/TEkZNaZiEUnaTmTqvsbl8HV4YN/S4j08HMgEW1RFxmQp9dkcWobUcKekgnb4QtTkwbuUuIjb6LBXZZOCSdY3Y/pTJ60e91yiTBi3gdXlTa+gQt4Q8pP7nerXnVu4eGIyiuQK/rFGtRNhfY03KdUk516G3miAdqFAcb6MHlsi3YhkrESwo8IowRCZkTtINvQL8zvBiD6X9oKHEWfOKWrVQLzyEVFzreRkIu9EEppNg8nKZoLUIuqpmdTrBxACpLLhmhb2zSDUQIA7VxtH+u4xp6e7H6Ql6nDgValRA18ZgxemzPkgxkiwWhCwFMNYcu+HzvxHlx3zOdxzYjknE/zllhjHUfFM5lrQVQXALwvvFGn5eYV6RZwIJE0hUMO0D2Xe+Sy2ygZBER5M6wlm93upa4EQn2XqhPcXFJ83QenLNIMRGyOuJcXrgpGKGKgTRoS/uKjNkgaoiEjrhICax9cl3FtDs8lgiowegpoqKZ0mxhV7iEuO6CMpyqzrf8et+CeyiNyTt7HxfBSEo2zeTOHSTyEXb/DACVH+yez9mIZBVwNfJ6La5zkaBpoWSbyNASKuvaDekVSKODHHEFpefzziOOY9COdx6v3Yj0Zy3wjyudTrs+8Ovot2hGUbg/ExVHalJ/bQ75Qb8cuL4fRQLVE2jAgtWePzcYezx+iCC+FPlAKBuhmDGz/Jl+iwJSQtUaMSGxXeFDEQl7atOgjvHrgxR8S+/VmBPf2QcmdP9icbwGDZJXpW0XpshOKGbuhTBmXRQ7k0KbABGKvt5i10BilNURS4JEyIW9/mxQWNNc0qgFpbacZfdyEx05DgScaopQ7QBtA4iOHZ20AV4+SprDMC5+qYIJTaEz1a8T5mERmmgQu5Juu/Qt4R+j6isyUUygyuSJGd4aRW24aQDW5jcLSonfdOrJQnFGDQM4Tm51Hb4vZWB/GQK0WS8+hsZpTCHCsIoDttAmOX8fCodg/9kJvXs1U22VEUjMKKXXFovuz3rpRciG9ujo9rrIQvMUtArA7wymUvXYmJ5Tio8s+dm0+HdhMsJvbpRRJADdRINPCIZ4sAJAWCf+4/IjCWkP3CI+L0JZIblk9YN0S1QpyWLuUuBOZqpqNVBOtb1vpDzk9rwt55RYI2yzcUZ/5Rnk5F/IqFXf7P9MkZT3d7K5MfFtHScFhB2MWKLWo1IMbk0LEXhRBzYWtCBqomwctBx4itx+2qqMPhq6XrUHXsYmj8iGBxZ46/IH6OU1yzQUBnVUJtmEg45ZuXdkDhJUt3fZyBb2cEaq4+HEVDgwPKdQEMDyUtFHXANA11b8iCUl0i7GD5HkvIGD4dsBSq0/9sK4EaX0+9oiKLC48GK/7W67PA9AHuDVJ/ljkERb5TMMXwHvhfeGdeSXN38C1TduF65LqT/ZfrvCtCIn9N+41ftn9MygtsTDCo7hNQbl1Gzp52hhAGcFJNYG8u7K0NVmWg6Lr27VDz02GAuV2uxaupEsGZPySYrrvy8lNy0SmZDzD8opOpMcsko2dMFcMvVVG64hrQuAeYzN4pdO0muTQl9G8OFvCbHRi1CC7qijwU91Rn10UcDgn/w1Z3mSLNB5EKtCm+AHxCeuB5k8+Dvq0O/enwFgFW7kP/ex4h4jM2it2cS0sI64+FSuvIoBa+UofQfQSDFkbOLtoGriQsNh83t+7CqswLYFvBX1nAbfAZClFWV2KQMGiyYr4ljrUdmc3inoGzPuicjnpJbpNIKzg+1+ydaQmEZa3IngkEUXA1Wr+7rLp9NogjJQEE7HJey9lC0O8YECfBWbz16ol7HqnZTZQa0LjPflF4iB1lyjgDEsstcIi7UyKkg/uvuwXZNzRrL/7Uwc6bhdp6pNArzC47Sd/k2kH3tv8pa5fWN+unpJJuV9dIe5+xY7xKk8RgB0ZsUd3W8AQrsjq9r9NgXtmZf4mrcS0mXVigBQHshc6gjZUNP7luwm97ZJuRTDEmoyuWrwPHpVqtI8NaqesXsAssG2OG8rUYp9qkfrgxxMBWhFPgMsOAisVpBYOlFs1WLuHq1cZQLW/SWhf0H9a1AC6icSoVZxkAQ3j7UygXC3JcFCDuLrJEBbTFNfjMhQf/9VbIocQ2FgiBQSxe9eO/DO2+e47ccZ+el0IyOW/cq/4XsB7xXXtMDhqPhnbAi5dn84fsf9L/m4wCAJKzCER2wg7sVbsLbk9ka7uogqe1slIh9ahK9AtMlZrOO0kiTY/xXdiEbu0uckkA3TsAMHzD23E7oyGT7e00+Z6hbsxYxvH1bg9SiENH3T9kKc7GbAFsocDZhwz7CpkQTOCKIN5yLYZuGQrA9kpQf2pZi80ES77SPi7ex0BFZbSR81UplaueKeRMMY3W+6KkY+3YdmUKCh6fzraLIBov8psUj2N2NrEm3bHFXFVRJnu4Iq4Fh2gRZSR0YsAGaV0ZNT19rXlimQtyRrJa1pPUfsiKjEWb271PoCI2g5c5SB2vH8lim3/xqosEby/KuGmEMSueOdHFwXdDOyUiFgok8NyPHwrDSIi1goWxKaxgO7Pbk81yKoAGx9RCdRKRLEMVDb7YoP1rxAQdhGdkSWy35wUdH8aSLFFdFjt4MDnTMlyOS3OKtgQGA53YWszyn1E0wH0mLB2KO+Ei/cVOMSu1SMXL8F+GofaTs8r40qqQBUIVLGVWxnJtV9wF9cySlhRBlUI7iVoUiJzRYrXCuIacYybDewlYDb09rHo8er5sUSIRYT5J5lqj/4i1PaGmdW4IBywNg2sSlCwLoO64FqFZliTDcNqBtT+aqTmwBrfDUYUDUdPFTYZk26spw5w7IxdSYM7DLXRXyyzGQjHSkTU8G1kh2ZpDxYx2iwrlIdTZND1FLq/XPOJGfZ8GABHyrttIFwL9Muakta4RALvjPfm+gH7KyGQ+2fGlQXo0oXCfm6sU6HYaE7QSUYbACu4NBNAcWFRoziP2qlpRuyyOLp7HWcVa98vH66L1KwTCE5AgXqzfdjjfh42qwcv3dzEMLwoapaxeqOAWGzDatmwFkmTQkntQlePvmuE1lQtzC8hqUmSeG4eLy4vhoIuo4GNM4sRjCU1Eva8zE5cicM1wTT8SQN+Yx34FrgPAsg8bWXPtapNs8SdIGCtYsvijXgvXBdVoMS1t1VFnYF1Rf3MCoomYZQviIrQ1nwQ7QwlU8+yS6PpIUgbJS6KFWmywdlCOaQdylSzAnTvR1+QTRo3N4ASHDVRVFSIfhRHFDEILy/j4feLmDkkuKjhEFDRLZwNs6Z1W7q1ejr71hJgU35ELW5Yw2FVBJEgeaCGIGizhKU0pi+x0CXtB2m0FIPZh5RYJUY/LRoYBBAGepjHA55nXktQiCLxuHmgSdM1uXe0lp9rR0CUUfsGEtsYKKK7InJFKUJS9NHQl1KEWp9FMhYhjUMkqN+TyxtYm5+AJKSJ5NAHAnhxYWAnWJpCput/m7XqbuXaPrFuhFBM0hLfte8GoW4tdMVinpvoVdkaCTZeibaRq1mxoMyfIPLVlqaKRca9RzDVJAcaaSl5QaqD9U0d39QC4ySwgnTdRNW2r5JB17BbgqTxO2RtvA3Dru9lcb+NfqrwvNV0oB+wwmOX/c7a5H4hriTXB94RGXF18HPIE5okDHmmtisv2ZmWBlHQT6E2KRacr+9RPoYDlaxHc9NMFjxCo8vCIwtkYlCiAUNbceUiC+kh4rWJVl1yMHZYMqjtzN74WV183140ktBVlzFjhFqt3OS0MKpZZbGIQXTvF6liGZs4GX9Jnm5/j5NBfxVx1k1Cky03Lq55aI5sRCXccwyaBbNKwL6Sx3gQVzd87+vDVerwbh2Jyo+xUsDMgI1+LfQmtX85gqL9Pxlb9efOry0Eot0+pRqV+atFg+qUdJsmCQ15tWX7i6w0kEXu+V49i8HSaBjQGAiKfpSJXZSQhGpjoSZtC40Al5U1dUopzV5lIOLV0sRpo0sWqW9aUgkAPVFiqOT6TpxRvRDhlJYfRHCysaK9puCmCmA0p9M4hFWjkAqNgUik2IdYUnNvYxsN5CY3TjIdmUbL9lQ0sGQEC8UWL3Ni/RH3/eZEfP6p0W/0I97RIQ+l84ShP5AL10JGO0a354dx0Uhya+o5NAAKx8T0zugiYoXkRjUvyVs29O2CZpWLCJQ5G0YDwZnMYqXNnAw0la41fqJjGTGskuyNtN1cmp4sxbKj77fOIwJjXYKjKGiToidiNwTyRrCaX9RJEmpZJON4kHZsqLFsdBGiwNSAoyWGUUQTVRNN09S8S5SLVDBAr5ykgZjunVpOSFsEEI5tBU5wd69R3bmRxBYtPOH5vT2em4UrAG5bt1sFCgjxvRFMuv5eR0KbvOUtLby6PVBPixAoqcVIGtYrUEs2hKxUqEfutcTCyYqqEKpMq9j55qBFGD1xzYgLQlmGwWDzjcgmIPFcEhih5Ombx7bvFejuRNTShCFcMDaki2yaFuc4EKvBjs/COHQmf/rCstcF/YTiEQPgTg8iLArqusdVRyMD3pAzJidJrLzBOkUGN1/n4RUVyqeeMz+bWeAdKKfnwrt0obgi9sG3mxLK6q2V3bgYnWDoJy+n9sJzQkUSgx56IMTj1cIV6W3eyRZHJ9pi1oxSt9G8cDqdKYtBuu8vTH3aRbVtSma8VanVLiabQiZexKQx+KYOt4nZ/cHLQ4yxxE73Tvhmeb0kJ66+f/K+cNxdJkpZQ3NhtgUSj+ORlVNPtSxAi3zQSv0J7D3X/Y80KE278ZAGw4JtghEeDtzfge1kpJ/tEmV9m7Cxo32oArWBa3t8o1YDdig79Xs0xMu3wwXglNVCxIfh03rZLiMwjHQP6F6VF85cC6o7NmTgYGmqlr6J2qJ1Mn5jeroUg6QK3rCD/2jO70x7QK4pzunPiDMinOpYABB0W4mrOxdtmoeXfsqLZY1TJ4PIitnWRqtdZNdcKAkOg9PMvk6HOCeXbTEaCPW+O3SjFTGxZnOl+ivgZ4M4jTDc/3MZwAZ58JbFV2QHO3B3S8CjG+jj56Og7Su1J4zxUyCYL6jkYO+JMUUoReuC9UYpoR/SkZaEJfkyFwSKuUYYbw4ATTP0XVYuhUU04gaDJCMOPS+QWfhDp7FlYLZN4iVgN+sjqzeVxKre/9C15QmY33DO3jK7kZoI2ogC3TXikHThdNLYnoSvqRIuRVBYKtWuheemgSYRq58lh8BJEQEebF86jyijNSKTBUFKOEgCnn5Ig+TR/u8VV1AOIOq8k70CgNrscgF18k/FulHtSdP+bQUAThJGGzCC6Wb5kJGJbPqJ1Y9KhtjqL0zi474CCoJeyYBekBJJHFkG/w2CWkxO6RER8UKQTAezJ8uvkprWh4hAUwJJRZgZEUFss7d2dSFRAGn00wPdXRPzBdTEqugQKSU52cs7l0CPkybRr1kTX2SrvGRzzfp500sDUO5gLHH0hu3k7gPu+fBIFYgMEmBY/xV4b8RXGDNPPE/4CsBWimgZG+J1M8wq2DqSa/wgwwpropbMtGiwRBhBMijR0UKT5FFz7MTQF0QRo0qdkSJIkWEDr2CEls5NJIjGS+Mm+Q3EmvKBjK4h4/5Tw2QgJMoquxatmxCtU9UxEpUjWUFBi00SnZlUACQAWUUatbREUt8bvvOCBNUgdplQNFk4Vhb+GIlZUdNbgT2wLoLebV9fDBbE74aBaMNxw3vvOuDNQzt7w1lDn4EPe6HXA4EK/a7VSJUvfFdoQ8IU/RYRbNi20SuiE5CVjB5ZYVpwrMFdHG6fDLJJIKSeFuPHdpJy9pmFSFMp4uANm+ZepAV9g5ivNjcWWQGXr/UBsVhXjFxq5U/Y9aqsEUXJS5Rq+Alb/345FSidUOkQ1yiQhMUj/I6NVN22uWs23pekcI1Pj7RujPsdx7kE4Q5cM3tgP00JkfnxO7ZYlhHvwDt2LEO8ecbtW0tdQUXIN77kRH9EC41t+C6uXi0CHY140Jcs12e5hopmyisKrmFVP6X6O8HUGHFJOEh8RU4RSf0hqtIiGJHK4gLZ4kRlA5s0RrwI88bgi4/KnEgSkRFP43azZxoe6AeQqAhVv5rtW2+FXParm4s2cgy2LYnkABCV7NZSxzA5AkpLWAMa7bC2EomxQWUyoelLbSgGB0j4yAuk/RFNTl4tBcjxdsWp6sTcCmOpWpqQfi7gu/t8QH9/xJV4S8nhvqt9X55+3wFTC7RawOLiRKs9CCyuANAfum/LaIbmek9lzjt09TQxOBcxTo9FT39K9eQEZ4kLjiwrkA69qIcYHBszBmUH0nAo7YdZpbEYa4OQk124KApF+c3aRSSWqInT2nUrSsShMDL9t4j+KJoPjrBIxgIxWJhYhuQF7NEqpnMAl4zDfNOklhDcezaYoHGjoWuN/xP93j/x9NNu1pkOW6dfuOBu/qKE2v0YlAN70Vfn3e698AS9VCCMPTFGBkmX6Gb5kg+u7cgwCLr/o1w3yQtyWaUMZ5A9iGE0sJ/mNOk0l6iSQ4gBqXlCVqCHkYNoopjzqm+V09D1gB/pOfs5WxKByDM7xY9hUXKjhURjFYZajYWExBQcqMaI/ESvXZFx8n1Bardb44LzMAgc0VFJCG8kobmncEntiW5ADZEzfl/3bSePqGYivi0HgBr/xvfb1P2LBm4FeNY+d6J/J1sd1KmFAr4KIDJ3WMRQ8XNNeohAvTXDhMBCB/koKCgjNUAa3NVDY98MClJEJMpPUkNofhKgxIKDaa/vlojZ6Fwmto0T99Q2pdGUCZrUxVkFHyEwAtxAA00wSS6KYTe97esUoxeJ01Z2QSTQ5/zZcoHAZKNK7RGnV6UN8RjlNGthCVBKUqPXYm0sziVKg+WN7hb5nz5FOVhJI/j4vn8ORxAnEYvuzovMPvm3aAGb6p+FfgyVRuiHfD58uvg+mLEUUB4A6TnVujAzgP1MDdNu/bZ7CG7tj2G/Y9CGaACm679ocmVRVE1ARUZJgmsfzAaQZj9ClNCMyvWCnrcA49s4r/EyBEp8KXZSwXZsfOWlph7BtQX3cjbv5COjLQmLSplNIV2mEwxYuEArPPZPeP5iCE04qq7pghg2mSAaYAX1tbyWJofe/qG7ZQTLgzng/4lHaO4au7TQu+xUZ3o83fnTjxZDgOj0lIJEiPMiuPnL9wBIU+K0FuXWXmFKAHBH2GZ2tBGTrLDOvtx3yt4diAQlBjkNeTxoMCyGDJAhOl+nnLDptEmrWU3bGylUhRUY7YxqKeEcVt/7d5LAdrWkBDbDhEPzUsFY2DPubtQ3iMHYfuMyvN0mR0jT7dvtMg3UYta67MKMBlRajwhHLGrumcEYGWRVM+YFsmSWyYHwayA24slS0/Z8NbJrnevyTe76035fHvxWBu4yoJtpOy4E+jwfFdkmdSG6/EHKKXDX8i3lhmSCCwdByvGnYTWHac191ncVbTZxBE3nIMk6JxNzVfXmlSJIOXXCMcq0FcrFLptihV1jlQ78TjBh6URqYyH0eYpGP6nJaEfNGJTMArOZhBfCMQ7Eua9APRQ5ishIfmT2q2dLY9lYNbLR0DdTX7CzTPZNmQGb98aUAFGJM3Z8Wzl8aqkr5n6Xfr2XGccWAdoXXNu65BI9QL/M6t3gWWYJhIGbJq/IQFsFfIboIDKmC/N1Om3gZiFoOV1sXjQg3MseKPqLAHUPgWEZlNVCNxLQiRkgaW0wIHUhYR9h3TYQkyyMoNmjIWFoppeJSWJqvEYRv9NOrRt0XLTotQmJA2xYF6g1MvaLqeej6NvVDKF8V8KNkc0OmIJI3qMKHY0ylZ8YiY9PCtyb65ejs0Kda5FLbzid6E9/AQyhkvbiyYvC4Tr8/eL99HjSAmfsvrEfOUDl2yIxGNcseg5sdWjZfY70YLHN9A1AOmJIvHw5hTBujMY0dR6WrAKltLQ4EBONiLlTbDWTJBkXdTUf75yNuMAIdpAMkfM0lE0lFKN1cBlJGNmMjCO3ySxx+qYCyYYuCAqVEwPnuDh5KBdV0+ZKoiCERbtYr4yX6XNNbw8oDcKoI1FRPWE04PxeAT9c/OqQHu7h0onndd5bVLxDPSLckcilkAczAJQAgIwEo5Pd86YWysFk+o3FfSHTGTpRa/KfGsQmKScJujUFJlKY8/4edNJqu0FzUoIXbqzTWaSmcUPKqcWx2Oy894YSpAgjg2bGxbkVCG2oJuqU2uA+03m+xngXwBw9IDaqKu6ltPo3OHk9NGyPxlBDp/JtJn0YRA8L9HJCQaDof8Iu9lkmim7IEenwjrZ3qcMcak//bd/ORTYvObBfFCeuv81ogKZCIbjIALINAuJf03ggy89I+YATwJAVtqmNP/cILhKD8RubDF7Kl9JMi/PqPxl6KVDWfPReYQRsV8DBTwk5fdU9Sh6x14n1hnUlYR/3LmSjCVYhA8bgWv9SYfP9ontIJ+XNfC3DOG5oBh+B1hXVvKh9drw/LwqsvOhuNzHyiRHDfqLFcpu+IgKCwIzdLNwXJ1753vp95rvPtJr+/u2fkT6TVIfM2FXoGzUiwr0DIgzEMEU/fTEYHRREtp0c4RZXwZWvthyMMbiF1Iu+hfTsQeJI1ZCJ99ck1zTYPtoqRmf4oL93eMbebA5BM5XLuCa9q8G72GhWU6Psb7FKpRGAxScP3l3AHavXzUIbRtGaUkc9kZaN9yPCwksbfayyR9M4vUDPkemxE3mzK2IDKrmJYUqV7jSjnjilTTwDA8Xy02ZfnwQI9Hcf4Hwu7l459Z813EGbfzMgtML9bZsLcvHnMmc/lQsS0p5vsn9mhDbLb0xmC4eGXUuDgBQhI5Vyg5L9+H6Gvgkv0CIjdFdLvGOfntkAbSRwhrX319AiHCNGG5y2xOkbD5IhBHRjF5Ygas+x2POAeFj5YYsYsAQSTGGXO0daSnQV3S49lQIGQ3JYwOmu9ThRwh52Fk1QetsHyYjrD+jv/5dr9/UvuWpkQiHNHdvzJpO+Ii+Zv7a2Vb5O1A6v8vasUuj1qrGLi7UXLQQq+mT/FcBM0aElMNR9wOzg6fFEnYBys3odxM3ygEUGBKpD95S6GbfB7WkActIAaPtq/gRxYnEvneq4lAiqKJIA4qqTtzb/FZVmODR1HdadAje4CkhwC8kdvG3rD8b90YY++ljIqjIdlE0QeLER0yjyE7ugUDntKAoHPmyoJ1UkOk1TGuA5lXhJF9ozJZIQT0bFLLzrHXU5lrTk/s9TBXq7GbCQioCQ86fIIKQO7Rdft+7eu+CRyzyhpNGktsPr1pFAlyi24etWbx0eYaLAzQNjtG0TO/p7BD3ziBiN0E3ZnaIoYr15VkTwPlhRtSGOkgc1tuJA1s0sAVN+SByFe2kv0SiMUJBZV1CN0zAFg9uo7zE7dwvsTHYeRPWDewasXFRKP0Sjya69Q5ud1/igk7CbJHUxtUC8Tllx0oAnTmYPrQS7J3Rhv5nizXCGt8Cd048pZSZbq5ERnDBiEP/O1ogEYtFDUULucAbZvmbyRgG6qIJLftJq2vBFJwbq9WyO/sLc8OiLE1CfMdGZPg3Rj4pfigaO2RKnN/ppTry4wmV8msVQILj3k0/G9Dd6iqJUgj+NvtuAV0GEJnl2sEwQ/VWCk6AVJvmgJ8Op4KykSWvgEhyuCg5lk27yi7TklfagN12RJ9SwaMQ0NCV7d1l0d158SXWhH+mq/BXZEkBrXsB7cRUsJnnAjGD0ShmN42gy2M7QRZNA+FbUNIzrbyVHfswUQIFA/QS/gy8nNIybEAjmclgbSRw3UbFGgg3Hl+Bz8iBcxCg7mkhNctrArIva0bjPa7J9gjgJvaC9caOE5nvRBmsVJakVbKzwEn1CRPP5yVnlzNVqrsmKcxTECEIFshs2CsC8YJmkohs18MvwrdlVLKPPmsIcAWC/nOvClXlxI287MSemzdlP0MMCgcjRdaRPu4Cmq7RuLiFeLN8uFO6GEfcPoHG/ID/PDvcviSGgp1Qdjslwt/NnhQwFqsahnziv0uDXk95nbTPgeDX8nbOcNxrQtZTsVnt68bjJzE/4UV3cvytQtHQxlhoNC0Kc/F6otVZZu5XXKCTmFx85+o1qLcSfTxzcodq7kCZYklYPj0iaiZYVie4cDspZyAt4v3hqVbv26311jPBJ13koECze083f6HOvpMH3oi9k+FLDScYFbeJpk6BKAKICQmUDVERnl19mcdAYoKTdPc+9zsUx3dmF59RqrjgdzEI9mHrYUBLEQaarQQ9Mz0/Tm+kx+5p72Aqa+5vrBjq9p1tsXLAgZGvY4tmFCZ2rg35PB0SKxcWrkCA0twkunERwdcxPQW2C48+FmWe2VQZxDnozcWFEKyo32mg4k4X3WPtefjERZdX0NVWjzIy1UXtR27Fzm9/T6n37heghGcUg1Jq4EO77zlD9O8F2XxaCLQIClBtSbMT+Ff+zF7nK0kUAFRDK1S66g9jzJAvoiQA9A2gWAm6n1BSfTFqPJCjSdl2A8QVOP1LUVOYyOtF9sxNqFIQwkwZqhiDknLeSZBAEg32rSZZFGKo2ROfpYlUTMI8QBQOBNOJqpdC/C1rePoOq7XSTsiSOXa5blxoxEgjZwaE2Yuj5gxYHdjEL2K+nttCG0oKI5mxDVqtUc4k3kdeae95hcoC+Qe1ruRTc74qQuXcA0382plkmbKGgWTsCFiS30yOpr9MKqjS1DYBrvUIvp7ntXXDcRBiOftHDnpvsqWzEhw4eIpkV9+K3p59Yh6SBvr1S/g4nxcGeC4ItRihkhsEQxE6Yrr8eTnMR8Fqm5Li5OwuJEcNlf/eBc3zWsVLVESdrgKcNHCqNX0QMzqLH3UH0OBmlI4A1AphTzs3UT0bwp9Jkq/tpq1pXgic7DH//JphtJ6Ted10R0TRtTe2pteHa3kU0L+P0u4+N+zIk2iyO4qySIXtocpk9IFiHjZ0ArSdBON6WsdpTtEtbnLOcpSlUYXENuAq27yyYNta1q4YE5oQnHakZOTovfPLlfkXbKucbNJyWbD9NiL03xNVrICJeLhAoieA8frbcOcjqepudWHesUB9Nb1QTyYhmdcmmfclCfNPyJvUg1l3hiXb+1Msb8wzvafcOYz9TflIF+lPtUWSouH45fMzr3wsCq87GglvG9SqzKLKhENg/Ic8PJQNkPBDctTb8KosZaTcx9FItlKRDMO16z4xTEedI/PROA8AndoWvBrj7HyOl04zLgYc7++YR7tYUzUpJNLCbQZLe3HpTC5Y1ILqXjbmmSz4pInR1yFojUEK2QQsFlFiwnxqE3Y9l9x3QfG5CMlRpdxOWcpk230IAyO3iXLb+tTKbQvA25T6J/uRNoZ8rAMK6xfNwIzygsH5ZvdKO4lrg2VV7uJhgu2s0jPvplsw5Ih0oBIojgEPRJrLxpvKHpi0M4y4BTtw3/kBuuub9I5ofI/0hhWrW3DL2WgiFvi+ATkE/rF4dvrAz8kUYDsqWACh9poEm3cbRL0hHpR/ctdmEaMBArQ60lT/74KAXR9+/uyL/hxfUpkQNsAJF85zWQ/8xN38uoZyPZL/Ko2+LxLk6TePeT3xo81fhzSYWVjvvdUIEYntvihjKH5p0jG6cdNQDYb4NAzFyYitbGmL7T40MOA3HqpbkZvpWuIBNZTHUA6MtUICwhaEn+dCBDzmiD4Y04OyLrYmi+g4aSWGiJmZi2gD24srBSod2EaH0BSOH6R5WJ4YmCWfi6NxNcsDI6N3E/FeCYhIDxYxd2DB5saLKps5gPOK18jLFvQCd+43t2aBXglqvJcrd3++GslZq6eIcPv5JEuP+JgOqPSMlXZkdLCQi2SiNQrn8/ZVA5BSKDw2QcsQSmutHB4lDN9GQEqnw4BpDOZoear5g5/Gj5IPfHzwJVr5ZyX4ueeN+GdCTgkHJ0pA2qaKOi0reJGyg0qUj2aOQo3O2tvrWwcbGzo142Gh1wFQmRhBVa/1cCdSsqfMi6W6naCA6CVs+iMr4Uo0qrstwv26iYKox5vvPgv7L7N0wA8DiJlLLApbgWNwFtSY0ndRbjCDCYF6Q/YMRpujz/tsgTkpDqfjbGVVTDI0FKQQkkgPrMEntNq7wur9/cX0X89upBW2wttlqNNMyBA6Vpr3GigSFAL0smFlIVbyNb5ikkkAujoapeLhSNpEcX8b8W/FpBNPjaYUvGqxhHYGVbxTUYw5KqmqMEYkFuUiYB6eSSNkSgEpOIgvKFsc/LYTN780Y2HfWpBOu+Dbzvrn/y70z4z03tIYZ0InpEo1SirDK6QTa07uTxd2b1nkkBIulq54XMBv0EAVOAypWKN+NI4Nt4gnWkrzwBGsm9pvUSQI9Z+05HTgqOgkwmqhN1RAmmsmx2SGSi042RATRLwAO9EJRcfzP0jds/Zg3w2SzA7bB+cLUjliCXHguOVSKt5YUxYfdi67FYhxrhNf2/yzGPN82sBcEt5r0amUpTekvz4/rQrr24Gfc/vpgCIb0ELJNEkkvJ2rcZOnCsoDKGCh/kPaGgxze/RT737w13QvEIVsQxAGi2SEbPZqgIjAISU+ZhtMQR96Cvuri+UKiuoDeScGMy7QvkxjGGicXF1E1u2+YFIwMbR3X5Ce/86ejG6qgGbbgedAKE2bECzUT3QYjSFHesqAJk0JaJ4EK4CmfjXyn27AuhKRIYB3ruKXlZyk520JYzbYL2TnA3ULjrtDv4x5WCQp3XzZJZMsc2gBQsFpBn3WBhUOGMq0L2MkofQQiDQbNV2kclAMpQIOCwphOwUuRDmk4VhpKYPGvEP5MgMMmUeisbzd22bzgi8aMbZNzCTKLxNNeJsO98K5rEDQuAQQUe++Layh211SRzttCUrlgHR/FjUJHOaKNIvtB7mIvJAE5o9MYvJQc9h/qr+RJokd7T+sOgKvvsAWBNZSfvikcC+hT/9Gd5v11ZNWDHLjk8/EQaOIbpUFFR8JV0EQ8E4O0fxDfKb9+Sw8heBsPaPJoTB/8W5ZD0cPBy01ut9KCZlSnZrJLVpm6PxlnN2AVkYm7it32HUKx2++UsK+r5QP9TlcszB6Jm4uQinc2zIb2MshNWwK60vpOK8v484ZpFTw2KE+J5C1Pb60GLuzioHl7scMi5+4ot2XwjVInTtVFNq42ecUkhmXoT5VAm9UK3ChO87qc1fkiMSCBgOBSQA50Jo3F1JJwmgokwhCRpFRwWhf6bObBFWVAZgMf5UwMWFKjorQdNjkpxNAfwQXgYUyztpiJbaahuJ3aFQBJoSYMr4W8M5R3EIzA29Bt2vTtLOCCLrqopsSD75vDYIjIlIuT95c9Fco1o4QzzDEKq92C0g9epp8tTrEseGEo8av1HPcF9YXoJMoAKJ/PF75OqT2L2A0denUzDMTdV1MFvGSUXsSuGqYnMncVBlPT+E3PxrE7TN+ctgcVKGb6ZttGEnCPxDS4xYc8u6rWQpg2H28kZWvGBU2zyyP6ZAccIgJ93eLIBN0GmQGosa2yqs/0XA3TqosyKdFjZWQT0bUvfUs9ndXCuq9iV7G2liASNSYQIqwwL231RV7km1ekDIDMvAIZmYFcmUBm+iKu+H1a+IOWBaTeEO5GLfILNW14gEMgywGKihQqRq6nNVM2+ONkODOLMVz7Ozpo2rtkxlWjGIMj447+GMHPZ0yb8WkDtBEGyVTTVDNntFFcL4sSKr1x1Uo2IEUEk/l7YvF9jIetkKgZwWY/MHM1dSd4sQ/H28S6Y0WfEcD0cnZDjpp68I20wCg6Q7NGxFurforqghN9vLlQLW+u35oMj2k4968s5MryhJrCk8obE/3uA91M+rCbpfFnsXOnq1aKpCCZuKgs2tXPBiiw2S2B/nlgkaSIKLXq/lFd/TQknnabJs04+oXO7PuxQD0EmwmxiZPvkskNejCv/zh7VOpBbWtsEMREpxSSJj3QxmiYcwFLoOc4mj6+lXUBlDelFMXoe1Cm9X+OfnSppdPb7fp/LBoa4SQ6tWRLCySnHNEAfy1B33bx9mruRfJYPO3QDz2/8pJ8iCae+na4p32Lcg4diRho29fvH2lYxQa13EEFJFeNNkQFWeMgW/mUHvK4eUWuJFc5iE7C1wkjeNUDHkJ1ZAMGMMOAeUsdNzv7XCreCctnxdVoXZuPsgMkxdHZfgFbEqCS7mQM1W64LKoN4tVNqCSbJPoNdcYSnB3XMRkT/QZbpxCaBBwib6sN7kkxzkqckvs5p2Dh2gtbK68ga0dqn3uv5rrSYvGeee0LU5CWCRM3BsIO+5dff2r/uiNs6Sdjp5vX1v4BAtd8XI2/0o5SstLcRCSY4qw5F61g6ybuKYo4adGqQzMXZ/OGeKE/mJ1IFB3VoxbX/R12DRq7o4RoKIQvEbDSxoqndGQbsCaUjXgMic1uG88TncKobTOQBDC2MkgxEHQHRWyCzLCam/A2TsbIxGw27H53f4Nhrl61vbuV/o1s82AOjcjwLRf+WB8I8/2LbMxldKFVF5EBcbWdRQSx0OEpOdQtASBom5KSpCWtGRsVIYjLm3kqvatx2YRxw70hNQhzm1rCGqY7LehoRMDIbOcTjfpJicUMEGDYoxhqdo/61XpCRpPdQHX4OKAYuThH08ruUnYHjZIn+sPeBOMKk4NPI8LmVffUGI21aIBV3dHcJ10eRIkSXKMtywchaiW4tPZl6HwZ1lF6jjxFyW0ovnS1lxGGln+4gJJwFzq1xFt6P3f3oonkUIEIbytHtyqNBU2ggLULN4gMfl0XDvc05UdQdmbvsKYWVKwHQJjXFc3mD61JiYt40ughZGc3bppgfKmYj3WoidApDb3YvejT4CEGXp3UQgE6dtrAJYB1gU09wXFPipUkNbKvzc5XN8Ex3q2RMtauISamMIJHs8ZoSI9qU48Ros6c26ffdSzQLWahGP+1Xf6UBiYKRqS0+zRvqwebSGBQtmSBaMuhEq1O1kgFIyOyh2UvGGvXr0O8rWQ9uvNvA7c8s6Mo6dzE1vCHpjEYlIrlbGiENoAwDVYhUeWcdYOJ63ZM2Qeg1sEnOwsNmMFwWeYAOrqKeqDnrluoAWyMCDaiufKgs33Llr0QwKs77khvPdXsCgF3yA6Yi0m8fFKv91HQ94rgvfZZ22WO/SsLtcE3zc8TptZvqzemRXsYuyuTkWoHMSBwhQVIQ9ilner6UtYdxEgs1bnJA6351K9QmT1G0kC6SWH2jMSL6CFtsO5UBJsS3++SPdxNQuCWSPFvyfqwtINvje32Ica2M/vqwSI5d4QMxYXipWcj2wBwsXBAjwy4Ikm557O3VjqkdplanNqaRhLBSVGi0nem7EEu9jPIgSsJLQQH5xquKvVI89T9Ouvd01GjtF3+Y7NLUiMiCFsg3HUbGNc/7gth0U+R9R4CaFvMlBV7+LQ9siN5ZBPTmAYTN0XFXC5YrW8AbZAQzcYJTIBu4SPa499NYqAoJhg2R4NzgnszxTUrDbOkHbLY0pDzJZ27l9KIj9V9DCuzfaPi6Es8u4qyLb8GDkGv2bDgHRHM5Xg1RnzoJ/WPvKurM0JKy8Ao+bGgzs5qJIuK1LUIvGZr/Z8YjfJJMUpSoECi1rxgZzV3FBDJwC1mpb9DP28ywc3cBXBJGFLxY5JKssVZgBzMHtJ/aC6DbkoSP6QjdQN69DnKTAwrWgnEfff3WEu2MBXOWYrZ7M/y1JT5a5YQjjRV1ATa2KUEiyC99VR2IxkUzWd0JRkieGFoONEP6jmwoMvsULkuUdRiBAevpk9DKWbkGUOcmIA2saJf8EPsutvVwYlydTKYlIPz0OCqPRm3wy2OMnCbu9umlhYFR+ynePmh/IRt7OqUgWjt/DLckBrt0BSCacoWvgJjYNcL2WdpuVfUPi0WOF6HS14XdubUSTyKSgJ6RUhlSvFIwx5GCYU+VZE9UZuGQ0taSRxkKEvYjNbsJrk1adjrZR6CxTUiZ97ONRWbpC5Mrd34ajWsH3a0nFLe/lMVORBcxOPNUYCQWs6fHSDkNQR/Fqs6+EWvG2Zm+38Y1JC2s9FEhLv/i7PmSLZutoFYOzom4pASGAoSjzNRMpbJkew5rV01vugmTi9eK+qqGT3QPOnHZqoThLP/G46XBWhhhkhERKu1o/1if05sxyFw0aUBThjGKpVSeTnbDaVSe0qcsjHNzNkRp1IlPHAT5Lth1aUOyBj74ttn2t+1DbdqNZWmiW1jd8me5pfieJeD3siqeM2g6h737VDXvko2GDQpGfQ/1rDyitbFL5im5KqL8/uhyqdQeKoutmTWIkJKP9We0uCTJej9i2pAK/Q2c2ksfD6ihTC1qRiwc75e+WRG6w4p5+BwnTEmZExoa4Ko4BWim0iOpOZPFfpbDiyKEQnEwchZVHotBo4gG7XkEVJRjFm6az8GTQ7PKQzuPWr8TkBGeUghNOm0OYMzKZWtLDKsg4zEGJYJp35qZGwToGOoDbXc5iuQpRkAtptRMKqVLGSzdjLZ4R51ESFwt9dlo7mmJa12SoZgGkOJCQWAjktX1XSQ+vDw9GS1A0qCgaOk1WUk9aVjVrIV+ggrdpfgO3QHpCctGQK68OBzIw8rFqRSMkIUPYy3Jx1An3F7py5k9HbYuA33gewY/TFZMahd4soxmmZXSAyJ3lrCeek9CLXxtwHthLgt2tnOoyT0WkoN79qcXsgGUotZjaQnXd+C/gc7D4CbZhrcrkqhPY/wODnqRQQTQFYndjzqWjEqTdN/OPNwEh/cmoKisU+CicqdmLl8ZQDtrxiHh7qmlOhj2QPFqic6C2bJxgQx3Si32AFYXPT2FFlK04cIBZQuYQKh8EZOWH1vBhkxFr8aPhNVa6z1ariNGGKUKw6/AZkHKo8spKVdha+X6cqK7Vr3tyK7pK0RCt357JLpBSKqbBuXrQOYj6j3xZORd3aGoO00yGlJF1/XG+9mTDVuxJY0ANijobQYlojIGpP+AyEu+CpLdvTYSBlEVyB4zLqVIzR7xZO0yMJTjr9gB2At5JSI0fYtedlbjwBirB5Q46+JpFIb3p5W+qvLVKjM6wIec+Iiq3W36NyNOXVJmFQ3DrDiiEA2GhjyZA5CkG3LmTvymmLjUHATKPqhS5gxyEyH1Sd75kkDrpcTxzhUmpzRPqQQxE1uWJaOCFhUcdP2LnqXTOna0zTcSiWLYpANGKstp/LhwSRz7Zs3j2dyznMiuz6O7LByjEio6faNmoPJK/smOVY30mZfUwdMmRCN7FZ5jgzsVOyepqOOupDOUdzJ3TY1zUTY6oyjnGhiCB8+ZlzoIhAtYHs8TPtp4FoobiW0xOFtraeNcrF9X6LuyQOWVnzlBvXdvSsb1vtpWESnL5MFctXLKOBuIoHeRERz+n0/eJKPI1vqCWqBUzy02bmDzKHsRFsVldtUChhLaHw0CSTA1TdHtTMj/Q1k12GaJRsFYqKqkT0sBOOIVf7iwhmRDTKDsDZ7Ib2uaXjQG9LDzvUfXNmKEZ6MDgy7IhrPwBZWvSymny61kfLHszqRGdUNGlAzYW8rmxgeDdtmkgWGVCUpAjZCCsSqvVppDJVAt/fb4c7ObT0r6ZGsY61iSAZQBSrD14t6lBIlASfWhXIYmxQQx6oT06TdVDnU/BKQEVwfF6pRTd1wHEpXgMqDgRijEMbhWHqjnI7idKyhUzYzc6vXVPBiaVThQiPm3J1oa+4u9gM7VYG4NLCwDDXGVSnXLuz8H6P1CWVy6E4ZbD/oFY1uXnj+QYRNouHNcykBFctBdZWpGYe1el0H+MaWXCi2566jkxOJ2V8GPPe6jAA4XyQ250y1TZ4cuJyZbwcrv03kZ7Qk/5KUFv9uvOsOeLSoEQnnovQLDPWGLTYnrMGoSB02lcHsxhBhSSC2BPL4oOAW6Qn9SSdGGrEJJeBN46bwKLrCroPAiY4Zs0HWwmGU2vQZPdph1XCAorMYtRiC9+fVHekLptUs+orYpBPjKTfQAwBfciO/diSwFoPbgIyp0uCG+yA9uM4dKVAN2nDlR+iPjvH06YZUJiZj4SOYp5Yt/LOlgXShop9iW01jrupItoCQknD24xgaozvjtBxs2AvfM0SssyezG8J7OufNAo3a1oI7KPfMtglEAi8hkDdBzAUaoWuKkZwsf+C6uHuTnvNNlxX7mxLSjycZhVMtmXRi+I4iaWfqxDKrWcdCocFdxxlZa6v8Xpk20IvqImK5K6Z2vWT6xoAmCYsI2svG5i21IOracPIgKwqdhb8qaln0hBhGp5uiSRZCWynmJRUuo6rQSPVSdDpTGSiXIte1SggEwReaQmbcP19WGjigDe/of5qjmXKv2ZZnswiSsCB0IiZ3X6R4xsbVzZ1EiFzWDue7Qhpp75l4HI0uK0DKFOmrcCkklGPj3XsO7VA4kD01raw1FpGTsXx1w4d0K5mja05T/nNp0+O6BbdtzM1IOD3dpbimLfsY4wS4FDEIGIegaAQfQUQrlAvk641vB9v0pZJZgvxSHyq0XmlzlBvK45YGrZ/cbwpzvWggs2+Xz+22o0ib+PKDOS6XaUScboDbHYMaEdA+TZUuTSylFWgcnVdaCEN3nL7RaJY5UOkKktqcGkADa9gUJgkDaGR7EAQmUx8kY/8VnWCmYX9FA6aYnUl3Z5f8/WfY5hkI3QefACm7eU21/olUxPg9QX0UXJRjl7B1xCIjDvrh4XBTNwB2U+u9Acwpti26DfCkdVUXsGb0GEmBqiGbxCOaYY8EwQhyCkFSqiFICbXaNScvZ+FqUnbhlTwtOj9n4JAfD2Eh0xGWhlIFy9DPBpC7k06mXTH4K6xYp24VCGDFNtx7pw7TmGQElh0U2WM7fzadRC/JOVlWAy1/ROfizwgq1QbNw+9Z0NSBVnujbGv24Lqvfhr6d6IOegPhJYXE0S8X/iEHmtSFAwb6m2o0cCksEuvjI05MhtWTUQsdm31Gp2/kWQmckTElnsZ5qhR3IUJ0LAbp2O3OmiZjGIYDjXwRowLqRS5PIE4KiEMPHkDOG9VNK83A6uBXsVsE6bWEWjAWgYH6WFPN7MAuYXkPqVZBQsxlA8nSBkcF9wAZLxDxUlmS+Xt432NEgAJFGSSDYSQAVHXSAGehoAUsfleaZEqhn08PtJXpbARZPzStXrWjMAup2czYqEGcBiZGwinNmdCAYzVb2MWkBG//npCUc8nWdNfkauGNKya1iw2l6TWQ8RawKqfj4ydIhdMwWSEEimeOn4ah/g+wH+H9zeHThHaEGYfmrA2dZSg2Ga2PLZJfK/2n36mj6w4y9wZHG0shkk46FdZ954r0H+Prez+AlgWuQBOGFDzCFDBaOk6CMP3HVaP6Gf1oHIAV0mTEpCe7D/5j3qo9DSwRoOe0GV4heMuxSXI8karLT+PlabxHsB7oFVpsVlRg8E9Gp2UDQS/YqhWDEoTZYOHg4gDCctdVLwscHlLqJ+ymuZ4c8q26GEv2nyKt6O5vJarKD8Srt4Y1NJucBoLlrOSA8Jut3sW6V6eZvvsSNM4a6GXUtRzu2aHOHRY6ICSdhBZCDGSXRkToM1tbAhs6R/QEGDfWhTibXhPT1QcyHREV0axU5dXJJhv1nwhrWFml0YWQmRXrVRqnFsFaCQ5FqF0rPVWmdPHnQifDyOIzqwtSQkM22P0Ki2fYsMpvtcE0GSuU2BXo1fjkOIAsmYpH8161M6YuHsXn+qwOSYk7tWMU2N2eLqIuOUkhINHutTkXOypmqZOasq0CeciamPcqzph8UUAG9muR2pFP56nsYPQ7jhJmMcPUp0a58OaxCS8gLBKujrUqEDvJ1U0iMimC0AyAYJ5KUUuhyovxIezOFyjpSnTS5FElN1XVHRKGJtelGQjZrY2IaRkJYOKzvWl6ynFs0IqP+oavTSFpHlLHmHJ5nKZAY5Dtt4D5Ohqb4JRdlSzD7dyeVl2GVg8ARTKrddp9ljjqG2LHaq+23ItqGkOpUhscC4mr1R5QI0iBOzaHJg6i4dvceiFfZQ3rvjQcSKUxeQKXEjDyGNy34FIUMpWeliqG4JtqRKUIxIR1pIzprEKyRfBsA24ywdPAxMdkXxZDEYX7TQMMGSJ3JBeUL2jiBFZMa0Rij3ZqSJiiVU/lykzago6D5pQoFGqxiWf7CLiBmtQBu7Sf0sc4+H1qA4WW0oQRXv3n/hyQkXESvXyTgMwbRmyapgCPDmjZUUMt+lmmnzT7l9ve3TVCs/7usdD0jULuF9epON1Sn+BFGVMbbJ6wUBZHZ2+YFNONSWkcjuELioCcpNEOn4Of1uYEK8SfN+jLtXUjjGChmqmwdqaXYdl2YlvudSqSgnvM5dAlmue1HtK9F1aAUiJXeKbCiqCj4RONqXQ1d2oyEXaGim52O0QYje/CindHWcAB6Wke7Mb5S0sS70hYUzXI1IKa/UvbuQKZedX2lKQo6MgIgoyen0xQF5pIMu4bZPOYMT+Gq6EaJXn/cNMNy6E73w7NG+IN914Oc3HsgIfUazJyB7enzd7H3DOqj0yOR7IBTzjci76208Dk94CPWSO7n1V4nxBIsRvsZoDsf9FyCu67HXlNPYLg243oDf4b3GsmBosK5zckV4edOjIJ9ND0RT+9VBx21ArsRAk+Fe+YZjHpuoMpmGlxBmXvtupim83rfloUtOBox/7gEBQ5+L18kZIGwMiyh6sRLzPa8u6ZA07CgDt5yLnL7pK1wLg3D/UhQYZqH1avmihr0itlaT6qXaYYpWkOGGBhWb1kW/RzAKgTK+fGYnC+yQ6Ot8p5NZCC5Au3iy5ask9V1LnDFgTItBy4Q9uxFY9KpJBV5QmSYg+Grd12fnussZiWdHhFGikNbHA8x3oZuvgVKA7u/hzhVar51jRety3wCvGP9l0Ch+tG6k1NcdGSaV8QLVExyBUKOhIKJ6nEeafKIXhsYbh5Q3AZQYQBtpLLqC6/2hR2kn0UAmAhWy2m/hBk/wWbsFzBjXlCsz7LZ45lalbJ0RwnDfqccj/IH4VjTcwWOMeacdo5Vlavi6TBy7l6pUm5Q1NYrDXm7JKDGG18CLg+1JMFtOE0uLyaZzqg5ulGTsULrsb6tIOl/xhgBHdMPacv6MNRPMzQ9SUffNOws/ODtS8NlylOMSgK06e0f6Qgyyx6BK0ru0EcPabUyoydo+Rh19o43hiqNEhG7xjn7XkroPNpkt6IjI4hk/69i6L86Vep2jw2FFiFnhbce7BEKg7MVr3GjmQFUCzD/rLEMe0NK8r5uIasEOit5fh2JKmMBzSRt9CYpsURsw3MkmMm1lOjzFhgsBrnXnBMcmVI7dl0kUzJ06EhZEtixFDoVdr4SHFanWyYB5o41SjtakiPwKE4CfQNEFq0TQYaiyJa6waHUmqPwKrhBYWDWribuJw5le7TSIiaNeqp6AJZS9zrMpD1iXQGwp52V5D8mM7meKTAMFPYKcbKZJufgMs9Cadmdup2xo8PaC6GPHBBylW9UqgavmjlR7BGd2GL3LvixNkZCpsdpMVlTZhmf7B8zuLUjgC9mnGYBC4NxNpltKU5iGB+oWbN4xpKo/FcJxXRMKhhYF7y8gIN+aLUm2bzNUDwctzKDDTT7b4YOukpr/sujnzSNY6Gj04VDz8P7tsAHfNs6lOxtChwNzQAhyCl01FIXWk3Jhsc7Fd5n9DQbDteiOz235yVMAoJQ3meVGwDQi5C3tE3MRP7XgLXwaQMLTnWWgBGBpbp4kP/EbLRlgBEAJzkhvhOH3tlIYlaWzC+E0lwOhJYbT+MNGbvJtS+2/symkgIM2k7hAjawIW4pOiB1F6jWW+uDxVo9VldwnTvZFiGpJiu/eamGKXdDrjsFDElUgw4gRTC/jYZdxs4RsSBovMrV1AHE0R3ya5SY4f0mOLU5wthHpHi/XBYN7VRR1IvjpWH6c6f/3nJXUigTnOh0hujRhjcYcsvtRrD7e2Ns8N+3fO7in+X/coF3UpxBMlpOUy6jSKXt8fUtgsDN+gTYVKrOOiTKjT3BdlGjsi1Zj8oAy8qQnrabkcTAvIR9RhyvRZ2fwGvztqOatm1y342ajknQUVIAmcJDdRSTHNt/sgqjWMy16hjZGC6mo9y++y2rUmX4fsnQauGI7vMkA2OD0moG+WHuAi5SuxwlurSAbbUWNI7ylkUbURTcsfPuTJ241zUo5qQsIB8IfvFR9l+T9h2rYogmKFvZr+6Ct0rU9MMEMI6vRLkhH7xhkK2SgPkwwF8CSyiHtmUt5KjzwKCdj2qJY17Z6vZyOejiSr1dv9UyEDXxTcs1dvjcGYPuaFoPYel92TWPPelOliYCwDd/E44c0Nm6zzSatDJLLs9LUbbT43FGreWMGknj3Vkljmf0y8k9WBPaxiZ+do5G1BJKXhdGTvlELqoDsjTOkDNaQLlzUypOrJ6beppMBw6PXqqGuWM15euxUKG5V345iyWGU2ONgwD114UJXGCfrMMjA+zAOS1Gwmu0bG0hGn2KtapRdDsunsu0QZiC4cxMypT05k0o+OwkqdJByn0Vju974WvZoFtOpz7bJQDIxmspFPDTq4hPGk3CMkHe3/Z+Mf0mZ15WSOIdVLaTe2JVhcfXKiqKrzPTOzuI5u47bKzzV9+Nm2Q62tB4NgDkPXVBzFolWCZzSD0EyCmi7dWI8do9pFsBeJ+gZLmqH2XDaEqx7Flc+MvUCqUJ6EsNlDKTGXunWsDOpr6utwTI49tF6g+nk5rkZMtYDGjYjl7RambWkLDZlvzbF3uoAwD6qLi3tVJtvSrSAslrK4oSCu+ymsHRI8mGA2wlTeu7Llyqvjkyk0D1q5qyUkX9hRsmG3mFI1yhCS1YlNsJlULowSqCTSOM4BIMWxos4vxTqx6ZSopxzAtxUms2sSF+9cdch4qR6ybnycnPaA/abmGUFJFWvOC6Wm+9LvmUu5BEiyw/lkwW4LMvq6NvTF5z0q2IOKn75Nh27ELn5Qj9hml1CI0IkJY7mGz7DidCXQmOql0zU0Sx3no5M09DSIYUpSD3iAISJVXR3wNZDXNE99D6rocqMtjOZmihkMUNZsaJcYCNUbBg82k2MA8LVoz1vySVNJ3Nro+IzjWfnnXuDi2ojcR2NCIPF56+vvTSILShtO9bum9RmEoAIT8m641hV2LWQ7m6zTTQw5oIveYb5ZJqmtlY7YBMdV3EB+SBt6qw3Xord4FLnnurV5DLcIUrbSXb0fzUTVS7sTWvZwPd7+n8z78rniz3dCUGFNoO4ev52hN6tCgxiQ1V7DxFOXRdtczSemCdZYy3LjfYF6N45YP060JcXQ5lNgoeYQGoI15D9VI8mG1sSu3ZhqbL+Gj9I6kVMlzaGw6z+8QGak0Mh6Rk+6ollpe0H2xSavWAZqDK9vcmbhY0qYai90ZZ37Mp/stSpxp+/0Ug0eBo9bddkWG6WUVSH1JAnRz2TRBGgUpgzVZtQ7s3s+knkksnDQyUR4VHhzi2bAtBNPONR8pb2mO0ByhaSB4uMbYuLhVe/PwAOXHbCkXhn6p41wn4mpAAaV+ml+1j07JamWX4PIhTrZ9igJjwC5MhMIhajjxwresC+gCzSK2l0nkZN+G4+NjjKpmV4TuJNqlTXkSIunqSU2WH62ukuElt4HbKb0vJhZ2yyNMc1vUnUCSk/Ktk8IEuOWtdVVj6icisMUB6W5Okggr3FrtdN7vCDS0940u5en+rJOzMDRGILX5nY6aRK5WRtKwnuT3EgWdy9WeZYYEZ7cdneLThtGB17RkopY0e1rVye9OhFV2Wwrom2k3BSQWux/oojmxZakLN3PXmJsuN5kgmOWAwpyaAFdn7sJKs6pluWa2PqNoFpdd0dCWrMAeg4SkQRhfr5tBtYRMkSdeeTuHyUDHy2i9KPHo9E2NYQKqkU1VY8CJ5glr/9kmimq2KFSoisKubYNsHDv0o5SiZmNUbI6UwLCPU4zfFR42tZn6oTvpqYoS0BdTi0+/0A7N4ALwfONJdXhWLeIcGjNutXshmrCkghQkwugCXHEvEuTRCVWGHiYGCMrVCHamWj64e7cz5m9e9K4XFTShKvdrdIib1rxOfp/stnY2kvmZv7Jy9bAK7CShRp7ECG6Uo3zJbxiLz9t5WFJ+cJR+/9UOonqw8SBbtjm6n4640jFN9o9ELaK13q8tlOgCOcp1H9S13Df6oPkYsEQVkK6SfWFwt7gjy9J5XSag5LUGwxagWq61+cWi3OVKZGjwrb4YnCbmOJxZjDg7ZXYHmcv25lPtVgmjBab72quTDKOiBZFldjdpAe83eBpuV1vkBT8DtwmNM15/dFkFGrs2hX5WZ2XIcakQDw5t+I9RGsjyNYNqag1UTtUlpMzQ6Rk1za7MtA6cxu9Xo7/xgXaMwiqCiwiTFbuVbTQ3VfT+3U4WT1hfwDWeuoQRk9anpUraXRmjMVUpY6NMQBVCoXjuGmKTioHGRLwYF2+Mf8R9q74iHtsGBeRxXr4Ey9QxLNyIhGLLuhyo8IqauRpuYNHOfrhDklnY6aI9vuLQOVEuTM/KK3vCgGssyZHk6dGNJGUOZ1Q7eUMrFWGWnjFyuwP4z+zVKIUPgTw7L2AxHm5rO0USXGowXWtA02I801EetwtXqdm2PQSna9XRbOQ3yNK59eOi732nwTISWhwax1qQc2MuSPFiFzKUXicJ2FLXFv0HObmYUpuj8d7/S4EOmrzDBQlIGdv/9dZNedBC3RGQAO3PmCqQOu4hPUGV6VCBRmenc6Z584TvsRlg0S8UtJqKE3ERuuejx20kDg5vIx5y85Mq5Nas3fE0foPdt8AhuWh25iKmuEkAornH0MpUApFf3zFwO7xP3Wk/7dUAx1pNmSsS3YFwv1ObE+L0TGwFCr5SOVhCU1FX3r8a8Q7oUz8hOS36UuS1ZIetQMcOtbu5yhZr1qWhaH5hqvOaabVYDiOqbSSYX6g1dTVJLMq61tg8/JhWoXsCyqEkzpKkDPlzj40yqsXNg1DxHN9SDguRpvNk4a9gTcju7w58ILNu4lFwtdrJotqDGQ3xRrxVAfhBudwBDEvjFCVeAooY3TTe3OR0U4Fa/ggHuwSKqSKqCWXMLhSRqA9Tsjd3xBALo/H6cNAGoJ0aGzbVAAecvuBfwfEJqkxcc9hcoQ1p0SGK0aqR0Y9H51RFww4GfWtN6Uj64SOZowGDVNwrJbVLfnrcsvcIkaIkfFqviy681wFMpSkEe2iQ8ewKEKI7H9FRdEKx5MPQpvQ06mfTmON7rpSNC9GVywoidSQ+1hC8CpGlJl4Kg5icz/P9AkwcjQF4gWLPYU3XNOXw3raeDc0SuyokoDTv0Z1o2ohZRyHbZ15e3SxvT8FAS9QgOLLLCC9jWWfvNmt2E/ZpK0OH2U/kGdvmk+wZf/E16P/RipsaAHq3FC8UQX+Xtf8+WbvoZgZs/sJm/ilwJOV/LuDy+OdCDg5wU/do/X4rS6QQTw+3TTXLUNVPgiJnyjB9KTtyYRgPEL5vSstQEPs2WCmUK+ajz1LizKJzShriMRYBDnargsJLDDtP16sWlaRJA6OfYQwcBMVzDrXneGccLH2SU9cV7dUN0WoTXWG6tY41u0Myqct48mb2DxaYByOXb9eY1P5fbwGMFmguMgZNeLMX9ZmkKpLGrccRV0rgs+KHppDBt8qUk+WvLtlvNqBdswpLoA+J1+FrQDdo2jB1hAVvp0ccnIXfbxFtyzQZn4OcMArVO6BZ5cgy0ZaDx2ZARnaB71nPiZkpGqIHDcCBBUBnl+fIYq+uKBZTP5MO0wZxS5gDVo11kBiEcpczZEaNaU18lztVxzye3XQnWMB2DIqaNMYiFll+QZ/Y3K8CgEDPTX8F6173dbHQpmNTheswmZjh1v3USGWnHr8OkgggW7wc/lbEiHEcFwfEs7Wg5Fj3xVGj+39GS2czVrcwRJY2O12/pp8aP5MNtapVaLlc0XecCaoSldawS5j9YCUESRHOVoiUJJJUC0e4tfmDvD0cSAq3dBj3b8SpJQ4VSN0JA6sLigPcnl7lR4zmsf39HxQLJM3Yz8fdoLxMRSlAUF8K83gyDdw7JH+RHCNZlKZkUo00PnKSAl0yFhTc1umTxKD5cwtEIF4uBEjHfpKhf6TA2KD5fTtCdCYy7nVjS8B9TVpSRZXd7Ydj0V3k1AY3ZxF2dIpISTXW0T0E+nCHCygC3EatOdAURuZdZoPtBAcdAS2+QCzC5FhoccpaOzShWy9sPuq+Ly8Yo6DaYw1LKy1ne0JH+tX61zh2BOiozFaKQO1fEHSsSwtaBPoWHTkZ/xAR6ffHUy0XCBjO7NXWI+M5YjWF4/6xb+b+KG8rA1PvOmsBkSoyJc0Hrw+qiRjKT3ghy24bzytIxbkvsXSw7FlXiTGaytJkA/gWmTGelvKoTnr2soYZxE9bcxkqpSve/E421HrSJTt1nB2b8UKaKVNy9AY0i/hQfdoPALL85vdk7b7mBd0/1oaF1OXgNmkQz8pPa/92k+m2uqxfTG+f4WmF2dCoyWg5M0mluK9pQSpdkFX/x2dAvyeDnqgBR2xuLkbb/a/srf8MhofmZt23CDjCjI+qLTS7iT6H0jQb1mC94Cy4phag7lRlaoFs12IAVXu51bi/Z6U98pgZnUhOdk51y1WgZem5HNF+Y/VAdG7z1YIuow9j9Sg3IXvjr09xWx0iigUwnDkBuPTo7eD2jekz7facAKuoil4K4MWaucIgjhZBILt6DmZWgcGWRet+vYaVLVuSylJvMGAUsRfbH4LJGX+3YePM9SjnoIBPoyGRrToKxMySo7TozJ7vvAPBOGnow1ipGqkLvdQRpsnsLH2ccC+QVUC/am9nkSBtnSbGuyPoHqn553tUiYOmJdT7EDYZdxTtoHH215i9IXjzYNOqnZ0Dn2r//TGNqukq7VsJJyW0NylGjVWOQ1ns5MVbazJ7W3dLH1O0Tz2HgauQnjh9UN6MlgwaVfUhSI1MHWTeo89GD16yinRtidIcXmIab5My43xXSWOy//3vcQpdWkCo6yHZOTqXOht2wQCKQvzOmGft3Ok7iQqC/kB6M/4Y/1XbpKYmZa/K6RGci19NLVtulKaRrorMBSZDtTk9B4/f1+SaDnu5Vn2Ch9ZEVQSwnxphZ+FoHt/7V7Yao0UAFcXucCwwWhBNhFhtn3ZdgZEhoNltwMUUAjH/jpbDxLG3R5xDUxsTE+E9fzYGCsd5621Yl9V2oYsXo1+aWhWwpKexSco3AhD8YB8z7qMvwutNy+js3Bp1+nmcNoqGyeARyGGx9K6GY9Zq0lm2JN4GRAbAN6WeywKwtbDk3CkZodAkcVBCohVxsV601p4cOM+rET8qNWBZURrxAsTOZVgOT3yjCiOwUbR8LE5RefvuKeupFZca1ZB0AyT+g5Bypo2z6jiK2pdllVpPp1ZVDzwkTixcDFKNF52wkc2SuUjHeARrh1vAC35QbpnOLY5qtrje19jt9nd/lPyGaSlLJYJutLFM6YKW0pixjkdHaybjTLVm/fWP3DtnNCiezN/j+8VrXz4IEsZ4xwQrdZVB3N1jHFzjMjT0pJCMrRs2fGqMwUXc/cyVM6+YcasBRy3UMRhBMPQKNjHEEUFsHbW41sEMmtAGsT/Kh0cFaYeUAuuV2IIdBkxd2TgavNiYBJcOWgUi/Ku6npiJ7A1ZqGf5JBa0Kie9P3ocusWYgjRN6VLdui9JRU5PqK92ccrf/7ClK5mrnUK35bD9vUs7kL1MJhxZHL6YelGP2/5J6y1YkcGlKTiAuKn14nA91yzEP+Z7cbrtkt1xaf7TBEHDvpAPGZOrKh5wyRuBa/87XX7oVrVn0zhlCAeYF2L/jpVSBUejLNSEnFtvJtVrOGDABZEklmy1mCFhq8J3mzgoKAzZldJs2aYszJS6XwefdGO8v1VR7wfglEuZbCZVbNtSRfkfWzLA8N0o5ogGfKst5D5yVUpPhXKXCdlMRzpDEYbmSFhMQ6Q7NK2ovme7pVqLllkc5FvKNZxR5KdcNxhe2lKRLdfjGvWeT2sVciYK62av/lIzCTXPTG3hW828i0oe5FjfztoJQZhBXOSXlJDiUgpUrhgElFgg5gvxbGSnTOMOrakaud6Fm3MiwX6d96u9uw0uN9iP6gWM96VBvw6RXXUmilooll9svioebNuGpSF1XxMYkxE3+eBgTS1O9XAcDHqEJ+0yGWcquh9SRcOX6B6OAoxE9lNfYbDnUyAOVqhhba3DgiZMWTdV3fixEgkao/Wbv66mPTWD2vZtTJrxedEchzAt2bSXBhls9UA8G1KBeH8TUhJeiwA9mDQR31bBk0u0m9p45wOJiDzvU/m5HeS4Jm3AuBsHD4npg5eKs+84u9UdhYJevLkatfWdnf2kip5Wy06OLhv9aAA8OygitugT303L24CzcqSKDPWUjzDh+Hg8hIwwo4rwQoLtVhXe57SiOBM0T8EfzkuNKXZrm8nVE50ybUhlppmLpVcjrYqGoBuXcdO1RC0EXw3GsebqyNaJV9a1uu8LzBBTGAZMfWWnHLQBG7AjJqXZM0enFYTj+E7GxWW0a3IyO6ZXAF08CQRXdoN/PusT2Q1oy1LyYWo1R0otGpjyE4NIOMelKQ2Si1b6aeWPZqi3nWuS7NlmdUYKMXVAEwLN9CaU68mXNVghxdv2VWcTmvsfp5X56GDDMTmN9Lds2XIYFEJbo5MSe9BYH4zFwjU9MS/6ZVPo+qSliPUoy/nz+I8NndSC1bjPDaD0iHzwme1c8Y0BQHNouVBxMGYwrz06rzUoxwa0g0F6q2Lie9ZYfUHn6nKULOyC6pyxAXcAq8wW9t1msITGnH3cPj56HvYgrCW6TS5Y5RwcOi2NStC9TXJusVjbopNNItTDDZAsXBR5+EZ4mFu9e/RJC2mPNsGkMXXXprpdTCrVCOLZnyhF0pnAEXOq72ZZpQsbKLXxRXpNRistGVkKBsfnWItNPJmzftOxng8Q75RUoupDfjnMa3D9S8l289RI21BGYO0xt8ZRKy3BIkSGQWpZypgFwpmZ9ac/9g5aZQyaxU05XUg9GoNrqZItmSoHX1QBcTixQMhOcOUYR7280Q3Xnh4arDAbUQjjMboNKS4pss0HjjH/Z7FhpXkoh7dTKd2GCYOyuhCDBrwJo2SOki2E8dNLAQ70KQ0AglJBE25l1vSlbg4lRHPpOPM1BFef5v73ypI3sHls88ERRTmHX8jNcWKFdfdwjp9C3uFZkpAZ3HG2uZLxNKpDv2nyMxa7MDvDxq5JbGOhjcmuacgCHZvhDFVwEGZrdj5nmXlHs1WxmH2nsZMpupE7zzZPDyayRqsCW+PyVltrHVgxVb5ge8IoUDSj3pX/wI9A3HWKqQf2CYcgLh+PjhsXAaTxdQPlUH6SyeZxnzaP/WnaCAxHvkDrGkXGjgtyU7tLWcA+C3pWUY/y5lBylX1nueza1ZWcZbp+EvKNMMnmlHpq0OgrV94EkT13Ftk/Mo70KuerBQFUM7sNfsL4nWUO2LfyNKHWmxLbpyQS8xLrjvYnqDRtrJGrd9/3ZezB/p+UJVFFNBqaqEoFyvvq79CB5dQ/FGNIdKy2dF3DkYOlsW5bH+sjd5OpWL3cJhtaM2qc7wj7yfs1jDn5Z7DtmSAmcEeXDWRdTvEt4buBwoo0J/w+C2+S8Amb8LzrV/VPR0QTCO5Qn1XXApZ3JmD9iVsPCRe3bgU3aUNVONt5p+c4Om7QL6go5WnIMpeJFIyJa+INxf3D7umL1YXGs8Qs90hta/iy3fG799J/9jRJqdCdvuDiAHqJt8lnydU4H6W0W4MRbqXbrwLewXHlOfVBVjJp/DYvo67Nhow+WQtTtwDhINo49DGxMRatOsGkCrbwNvFO1UoYYz5PjiBfUIZluJXv2gKLcqr0h4Ny1vyZY42ioM+nZP/Gtjco86be7DT7ToqyLI0HuoXdjxH5PMgjrAYfxLNwjmU5msied29zGpel8WySUOxo3WwHaEMz509rSfv1FQcB3vHtNQJ6zpS3jxdSH2ksNgiDbDBxE67GPH3GYJr3Jm8phMjL9FH60TvBmKFuc4g8ZFJTLe68ju1jmv0XW1JagTJOnm3lO5+E/hGkITs1+Czte6FzBW1u6VH7qRsDIqSYDCnGm99n4+0+puXNJp4Qj3Ff9UpaYLMtrQSjVff6UAhw3rNgmuyzYsV6YyR0P09Pkbj7jcNpdntZStet/hdq95bcQ/WF/RxGCG5ShbjsR8blmQeawr5zprHj5brsIUP6s4gxFdV5R2daX4r5tANsutImJS27CiLurvW+C5fy4Qhz1olRx2E5OGS5w6spy50YxHevWKHaNl5kJKDvKg41MuzFBWO47/R/GAZGG0afVjhDyBIGaxRPbf2nIUENXi8JvppIZGu69Kj7x7lXfsAEzFyGoTaMqOQgcjWJfe6G9buSjM3oE4Y0b15TeQ9p283VZdNPwr4bWGY5BTHXGvUgEQRcVZ2NHHjiDlrrlEbHuh8API6NpHL3GA5d1p2/LJadNgYM5beinIT0LMzluqwc0YBUmWU0cOwYVnkaooQrPGPDZJhNbIOhTgza8Lve7tUDkXkZ3C0OFNi7IvVkT3CO0QMDQnVnDdtacye5UdOw7Pr4HDjTzawmAW2jd8X6K9Te8A3C9K4vQWcmw44Hte8RJ2j8Nbr9G5HdAK99K0TqVJrx8JSyLsL06YO0DztShDq7PHygVZQh7+jj+EyOHrNh2U3tUP5RUFR7joP3wAITp9AIiq+DzaX9uFOmltXSemM0bObTJGZf5WiICO4XcM03EYk1JhUheXKURnOf477zyFNRub2eta6vuWpm1yc6fcx9+CSIvIeY1bCJZxR03K7CRZBhLqyJTn6Y7d7MTKLKhZJa+IBC8YjJ0o6Uhq0QtqQ45b2KAdNTW5j0Nr9Jk2uy9gDyExEhsHotIkKddtjuJmJ012faP5nLzaz3EAl14bEBTqi1ELbsbCwYIMSuMg0nyKw9uJV4mawACQPCWCKpCyn7Mf6OPFdyjtUrcDrvjvzoQTgD74RI19qdSJbOdKjujLrOWgz3HMz2IDFZaHxxiJrwBngQcniTYMtJbk5NvticDNwRJqtuEaMgRpVGrWijaxBDdSzswtPch0UfLaymlSA61NCFEaHIMr0GoxaNr2uPMPUpeSqE6LCm42zJoIo9/osKQzr/C778674kXK1l+IQAJ8wFWjERIUVV0VjXmVnojIPN+xAfFIJBSDV6nsAV3DRqOQgvifjLMBHRtH7E9ngzxH6UcTBzw7ff1HAEObSo6T73I+zsfkC5l3rjgj5SzvDyvKDm7d+Gkpx3XERoC/z+bXr4LG3jrNtFQBsriMZm3dMquKjFM8C0r3iKDgp2zSMjRGksJLB1MwtngNQhFwJT6YCGmgSG6KgHeHaRB+ynsmPcH1p1jqLSnqenca/RWVSc7C1nRXiwAarweCw29otnxqPBCOlVWDZkqj5vWbxtHvXgCWyYbAHreOXt0aNBE6GO+QoGJnf0igddmQWFmxzoYwGMiA+1RNrMIQS8v91xa7nOFypGIMq42cphjNO7Hkpkaw7Lit2ktWyuakGgFNV+GQz1GOgXt813gpMzigzCfKZKRsyl7TJz66iNyAOIsDR+LX6gOwfWlcyMxSx/LZqdqenxdC2KSqMu1e5GPF3a7VCigB4QOUbtbkQ6Nbozqp/WZNvbI0kSAndwwXhB/YxqUjWWVU5HkBqVFhYq0kqcpufBcXO+E+k4he44WHf3Ihq7bKUd6M0ux9Hl1nqsQPiHvzw6aD9YFMXHO3dd5U+iBPTx96wdtGFZdr3DbL0lA8zPk7QlKkGc7F+hFpv25AW6vG3mUXUvKoOIxvoAiO+c8B3405TY6Ljz2NWkFUcZoY4wb4t74bUjz5ywOXCu1YQxcjUGRiHKKyayZoGb9coaOQoBn3pTkqW10PAib8XKh+PnOZ99Id2CiIxx+vSGKGnPHFbOKQ41CUZUQTbfQG9laQ6I9wdIc27Cdj8egQa5vF+MnjjQvwxnIHzRLPNENggpjbLP7uN6bZRbID3vYenmU67PvsViDyGQnnOT3JN/5KjG1aC64hFEi2IkR3SdmXE3Z8gG0HXfuv5Qd3O5NC3/zsLFnqPrtSm72Y4wneQ+hDoVQumPLZRS1sWrN3bTquuqWB3szF0/0dEjvfc/h5kEmsJHL0bUHbFb9Emeke6wTx4ZFF3+nsVeDCabbLWoemUGcfCnsDGWk9Ap1/DkDBZ1WLTixE4haWkOeDjW7+V4sutkFn0dR8mzjphNFX8yWNfP7pczIbu5RhvKhWdCoOF1ApotDNP6xjZwNZVPqYMO/UdNs+COjm5QimRR6nuzj/CCegycTiIG5URjtMuUPInhtm+yHOxDIXEtVdS5yrETLJNRO236RirwVUgcULfuBssXU99kcCwOkKNbXf20Q0T332uOIG5nMO545qYxr4l3JA0O5s3xP6/Drncr1+1+M5XPl7oaDQTNqf/NPAdczgTqjqXUnqEDcGqAnh5UfbF56qCenqMUD92ZfSzklXgRNZK5uk0iEtCIxWykX5gtyzoDMdeGd03L1K3DfCqUEOjiEcE2C4jLZsjvD1cGwZ1Hyn0tizaI8otZhKg5p3ncdI0o+UYCh9dlnF53SDC+d95XFXMA1yu+UcuBwgO1dyUKxoqOOuJWnWvt8VSdWhyW3os95JvJk+cGWMrh2ZQRXKyRu1L0FG6iEH+uTVkzq66HxYqbC6jppn+QN6sCV8PMSxPGd9Q9GU5bBUqy+XDQz2bwIoB+xSoCfPEp0R4NR7+TarIzdVh8hKNHf04GMdCpz2A94uj5lD7MwT91J2W5Y73lhsPuDkHMEtSeZzbPGte8qbHIWyPHp7nUQLM6iHlz/0oxQoeyzXULCXE7I+apipya5OjYvPQsnmxS3NDvjzgL/Rs3qvAZ58/2OOnQzx4pFlVMzshjmNTG7EHS8mbTj3eaxal4T2uh829HUt5vclM8cIZ/SjvaPw7O1Rr/IzSPNTKM8fJkw2eSBqmY2W3VYk65z6pYGlrzPtIfK2WukqnwO5PWr7CzBMMm2zWjfo+QSXxOuXXmKH8i1WVIMEt2hwthJQROZ+IkUlGXDZZPx6HSuA3qxYYt5c47RSetL221R7C+DdGynvucxkmB9sUCVmx3zXk+3MbySQl65tfGI9sUTrtjn9bapdYrOx8NbDtjUq3K+xBLM6MnDm2n+U30DZckx4WampZXOddRqZ8h19hoDDmfdjfK2efZiJjX3cjoO/ebkl13dzsMTGmWsfo4ZHR0yT4IPj1hPpmIM9pC/y675cUS8SPqU2Ok1ufMVVMTwIiubSaiY+KnCmTDgNhTNk502Fi3k1H2JwPI6e5MyKWzfzboienjOC3pTiOuaIroAUdGW3zK4Pjduy7RzTiVIgE0us0APU5xtuqs8bjv0P+c8/bVQx+eilWCw5mrSq1c4XVP5Ei7Jo01K53tc2CF3QTZ6uGrWbwzn46Wuw2QXVWl8Def8uTQE6luTjhV7DYYKQdzdwPUrGjh2eZBtkSoxIdgZzAcNSEPjxOI1TzjW8k5O3l/3oRAGAs3obHb8LhwBtXjKwaOqoMRQo6jOIsQd7Re98djAQfzQPc/vB23a+yoxk/6cFSG28IWzM7pGW2Q9Hd2oBvTz6IOTMCkloxg6FqFNwcd9XmbgTka3UA2luDWWeRprWp6Nma/697Gg7z7JDYl9jbU4kDO7D5UdhGX1ZVsJOxw3HPKog+IJk08e4HQ+rQxX6aYpyyaguXTdmxFs+E9179Eh/f7d8AR6wc+xeG6AYdj9FGzitmYmI/uVXuZDRNMfmhFdV98nk1HzzPBLPvwzrB3TURjUYm8QER4A+jZxNNcP5jxmf1QPLQhODvHQzfEXILJBOvsQlunOuKR/D0A7R5g4psuxOPRj7bETRcYJqPYbvHKodgosT4XEDwzlBFBTVSDH0yNnNlbd3DcXI3sblvcCMayjK0zmvuYyb5g2+qqq1iffb4gGy/QBst0X9AJOBO398ORyQg8lgEhNVWoZUlCQdpgotX3oEL14FAygHrt1TxmyWlmjGbx0i5K4IzEKCbtNoOxf4d11Wh31JjNg0bibGLtoKNj/bTYfBw3E4tQTg5iwk/XOZz60GTtCpY9XSe/T/sfN5jx5mCC96ZXsN2dUidtjO0BZyMmcEE66cabihx23UzL2KFAA6bvDgyWSWPUn4Q1wyqSDpMTo+MIBpWL8xNljRgXp+MFHJP4PLs/OxQntXMIk2kDaJP+1kAOUyGt0sGa5oFzYYMDkxUqE9xyicnmrLpB2x7WVcNAEOwdkiDHTckBGc5XIcbBavwxb3f4WeyFU9pdnfAQPSc8T/YUIzSEhvE5gSnvzN4TH5Of3eaHLHgip4fWWC7mnZx1CqVmIV6dHTL1pEYYp2RnlRzN3auuw2dl2BUTLwq51+ZLsNbIxpgfnKjGuMIpjT+A+zHRrlY1ZTKZWcChZqAvuv0OdA+vUEu616pxhFpgG8Q5k6XiZC7xfvJwTdycwSba8N9OVPZzKmF1M0Z8TqfEs+YzuO0BlLSWPICPLGA03aqDZcFkMGdlwhZnZCP4sm4c5ceYC8CUYM20t+rQ4K0jJz91clWbgwtPh8rkY+UNErjkY5EtS6fNAw7kOzrJ9kxWSQvdJFoRsRGD8jTQoyure6bin4lThwc3Foelq7Ydqo6L2ZP3O27QWD/JwCmK0sZHJddZOGArayprvnNpMOlU+1mQE8k6Jmk0pn+CmAuGY7gmc+hqhxxIm7Cr74Qa0BXFuJasa2NtUoXujPZHQGrGKHF0R3gKslLxiR7bGOVPHnKWndbs3Yxd8gismCi3BhXEY1rJrreYC6hkxeYgh8YIVpTTXDYDeoz2fqv2elCBBm+uUGeOPjUHbiBO49wcnns5bGUHXajMYW/EdOHfhyuclh6U1GFaOKnAfPwHVT3cGI2GoaLLDGJUffE3Fx1t9llyi+KQ8rotJQc98mNkp1oBWRHd8clhiw6NnEZpgrJ5nIA+y03E0NOhBpg/J87IylNYreGJN2NprgMuipfNLxRU16xB/ZDHlm4DzBhVkMhVJowg94/VlGRbw3zWs0SD682doLwxefB+2N6ygWrxAoP40DRycvrjIOg1S7BkZ2kq86CTmL/jNNDvdNUp0dwIwV0BzyUbXDQ9d9dtt0GsC2NXzdhtYw0JPwVpNiCtqaKR4OjfTKaOhHN240WZxHeibir0lhi461KEJGbBTpWpEJ2hoelk7Bo/KMTS5kIhcZN9mH9WvrKbE4kKZO7R7rh/I4nGuvcXM2J04viO9WTHNFyt9uQOx3BuNJ3ddkKj48a0tTOaYJQWs2p0CZ1+qzfXI83MbquiZYXkGKKZd8LoKRw6jvS6Dn9hgjwbwOUEFqOnQp5KO8ybGA7BupVGIcfqUrNTJ3JrcjRyBxNIyzKOdVBpGOcFOcXuqzAKlq6lZEGRUmqFiKcb7KPiB3AIoLEuC4Bz+U74DgUA0PuQNoLbkW99bkrwVuzP1ckeXDp5FjjYXNw8RbtJDjLS/qjxAH7aHVGO0Hy02S/uaoN306SzTSKqiffw1ZPMfMSNnm06+76ojkz6xvMsMXpmm3cm+65HGybHAvCEnZo5aMxHhrjxLWatR0mn12LfRYKkDYB0ig0rlMnUQpWGoVa1T9b6eKpqehHtAiokepJM+pu/OBSOTl/VdTo55QCmlFiWzHB5O2XOZvc2vA2CmFliFAJpU1M3GDSWRiHehrRc989Y2Oe1Q9xFgUPkaCE9MP1odb8CVIjvS2mB2hwohthdOAgLjQr9FtkYmo34J9gd7qMPdh3G3Y+WGAeplqRo4kZdMBeQ7sCYi/LO0szeEN3o3QJ2lhbT9Jlfa1EmUQ/JA3DpCM7xj4X0jPsAVh8A2KFN6atp7Z4Z4+mkeEylGhHWynO6p4Pl4E93oGPAK8MXVo+GTdZ4L/Ca6TF1j4M37//3rDTlMPbLmX76CGIzrSKb53AdQo3+cq8QMCVEuIlRix0zOkswGupugacqCcf9gsru9nBZLN1q/+koOzliRipxQTZ3fxLwMNLjqEkPhlufEMwC0rWgKrd/pwB39ZN6MFUUowouk42Wqj4bzclkJz2YjBHnNt7fUuKoJn2qmHHAL86baowD+qCWg3lblbWuXh0cYBhZHtB4pml/jocqedu9g07bKwY7x5yb/aVmLCo/tOMHHQVsn1d1ZloF3sPhHRpw9wSsZA+9ua1aDrQONs9rqXw1IKOKUMnJ9EmKCnakhtcctSqh3LWPrg/FgQqyrxnBUOp7rRz3o4tIXTRtRSpuNLtdG+O7R2YLn3jAgTdyuHGSEgaW61FWGC2NO1Z4j7sVfnL04NP96NhKn3ZnbCw6IdJzuT/X0eIIPIWONqosfc42NNncXJlxUBQp52oMjQQIL3xo3nPwWhWRfZLN1EfAn6JcZM1fvShRi3Ri3t6l0HozR2FWUYVLo/KV4Ko3sO5MdB8DqnlFQeoM4Fm9VXdoQcZHz/C4A4giDOlF6ga4sdjmtBj/nNrRgONR2EXONQeraCgSnmD0aksMsxqPQnSxgAx33bSGExO6tyrqW+xjkthIyWTh5Ac2ABNhBz+GbUPDLZV7RV0Ep66iMxwyWvkxhIWove5V7UZGXngymOfgCNmlh3oBRbZGUwI7WAmz2H/gFCAAuCk+kWL5cdpzydp0s4Z3GcqPTwxK0Ke12Yd1WQD9rvmKF9LUOjtXiOi96mjVq9O4GpNjah8a3960eT9vNx36h59n3TKCRNzRgU8AAgkyyaL6+bjuG9Hpmyn6HHvnvD0gvxd3HD3qGk8z2qve/6YVjseErKupwmhJIT0ti4C0wH29imaO2IjwETFgbg9yR6rCRsbREn6Q/0aEMHSPR3AHzpUjWA1c/dJGAvWaeTuM2Tm32xXnisxNbnRT5n15VIVIPEx2HqN8UJd+HdB8wJJBYv/rHl7PHbbIlTPZwZqzuU/4BHpx3DTcgiu7tDhqf2iruVPoIem2GcNujfzozmxWwc/jkSRGBHebkRYzPvi7wuwlsx7Z6DZH19dMoJNpZ1xg6AnRNNAOKMUILY2gQ1a0lIwWcgHA4db78HYd/dScgC09urRjuG+C5Vj9dS9qqxmssdHs/KyNyKaKUaZxze4YRgmzDZ3xiDjy9DG//KMpH5oHr41iW7I7rar4EUSkhjmkJsH0b6tLOBoj4CdFswHDIfZkBHNkPAJnVNinnnibx8oZycqCNI8yUhTpLbAbvnRwvJfAQ/Ro0rTwKdIt/j2D4Xq8TDvi97GRzHMlbjqAsdVKuMxCmBF5M999Qi1WwgmPeR4ignIUe8d39imWrDhv9cZMcNzPYxVsfmQ8eEZYmSLaSUvKflABMx6zqOdxL6Ofx3HHFnvdyGG/YpRoRbZ1G4C4ksDMtjVuMLYxXDPqWBIp7dhdDZ3cUGlwH72aYsf7GhbRfTimww/HbVoe3314OrstzHfLmw3z3Xhv4HraI+ZCxOfHkHF6LW9Jxq14csDfhdXx9CCJHE9bmByFPrRmsvu8PRIIJiRbV3HnZX5mFdzqvZoFjxFI2X+ipbnM5M1rjmj3FcXpx7EY1Q0j2GsZXTm7YL3XGi1/77rWbHYAvkNtFtE0K6qwkW/279QlDynoHdr3V+JXuCGArLqBEnV/TK7vmOGQ1s9tV7gzO4FlRrAii8hub0TCX8f0N8Rjt6HM5XhKJm8G26+mjv4eT/3RvUn5lCBmbNw9/RApN5DcZQ7vxJFlT2EPbMv3Z4sZMLYMt+riWJOpKCBa8/f9MU7eYSU7QvOWy9tftCoI2vKz/DNmgYy4aG/GqRuYdyiIusvMGLeDVWwiMtZH4K+BX0WqYw8qRAAepSMRsEzd51nk5dOEqSgiCfQ0V2kXCyHxVIj1ZYDWijKoOMXYK9yHaiUTGGWmqjY2J5mWcmQFky0r+ZpZ9s1dpTqyy7mAV+tmu/yEeXgjkrn8+JbMMeYZgb1VOoGMZG2jzfY9NuWlHaK66HKgJ60SvKozCSAjX8mfgSvzxUev6pFGsrLXyAeQGqihke7ar8jMKkS6rrqjohJAZM6iXuyz4LoLuTjLiJ2ph8Jxlcz7smRgr3vSIyMReP//AMbcfwmNPZQ4AAAAAElFTkSuQmCC";
    PBR = Object.freeze({
      sheen_E_and_DGTerm
    });
    main_default3 = PBR;
  }
});

// node_modules/webxr-input-profiles/packages/motion-controllers/src/constants.js
var Constants;
var init_constants = __esm({
  "node_modules/webxr-input-profiles/packages/motion-controllers/src/constants.js"() {
    "use strict";
    Constants = {
      Handedness: Object.freeze({
        NONE: "none",
        LEFT: "left",
        RIGHT: "right"
      }),
      ComponentState: Object.freeze({
        DEFAULT: "default",
        TOUCHED: "touched",
        PRESSED: "pressed"
      }),
      ComponentProperty: Object.freeze({
        BUTTON: "button",
        X_AXIS: "xAxis",
        Y_AXIS: "yAxis",
        STATE: "state"
      }),
      ComponentType: Object.freeze({
        TRIGGER: "trigger",
        SQUEEZE: "squeeze",
        TOUCHPAD: "touchpad",
        THUMBSTICK: "thumbstick",
        BUTTON: "button"
      }),
      ButtonTouchThreshold: 0.05,
      AxisTouchThreshold: 0.1,
      VisualResponseProperty: Object.freeze({
        TRANSFORM: "transform",
        VISIBILITY: "visibility"
      })
    };
  }
});

// node_modules/webxr-input-profiles/packages/motion-controllers/src/visualResponse.js
function normalizeAxes(x = 0, y = 0) {
  let xAxis = x;
  let yAxis = y;
  const hypotenuse = Math.sqrt(x * x + y * y);
  if (hypotenuse > 1) {
    const theta = Math.atan2(y, x);
    xAxis = Math.cos(theta);
    yAxis = Math.sin(theta);
  }
  const result = {
    normalizedXAxis: xAxis * 0.5 + 0.5,
    normalizedYAxis: yAxis * 0.5 + 0.5
  };
  return result;
}
var defaultComponentValues, _a35, VisualResponse;
var init_visualResponse = __esm({
  "node_modules/webxr-input-profiles/packages/motion-controllers/src/visualResponse.js"() {
    "use strict";
    init_constants();
    defaultComponentValues = {
      xAxis: 0,
      yAxis: 0,
      button: 0,
      state: Constants.ComponentState.DEFAULT
    };
    __name(normalizeAxes, "normalizeAxes");
    VisualResponse = (_a35 = class {
      constructor(visualResponseDescription) {
        this.componentProperty = visualResponseDescription.componentProperty;
        this.states = visualResponseDescription.states;
        this.valueNodeName = visualResponseDescription.valueNodeName;
        this.valueNodeProperty = visualResponseDescription.valueNodeProperty;
        if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
          this.minNodeName = visualResponseDescription.minNodeName;
          this.maxNodeName = visualResponseDescription.maxNodeName;
        }
        this.value = 0;
        this.updateFromComponent(defaultComponentValues);
      }
      /**
      * Computes the visual response's interpolation weight based on component state
      * @param {Object} componentValues - The component from which to update
      * @param {number} xAxis - The reported X axis value of the component
      * @param {number} yAxis - The reported Y axis value of the component
      * @param {number} button - The reported value of the component's button
      * @param {string} state - The component's active state
      */
      updateFromComponent({ xAxis, yAxis, button, state }) {
        const { normalizedXAxis, normalizedYAxis } = normalizeAxes(xAxis, yAxis);
        switch (this.componentProperty) {
          case Constants.ComponentProperty.X_AXIS:
            this.value = this.states.includes(state) ? normalizedXAxis : 0.5;
            break;
          case Constants.ComponentProperty.Y_AXIS:
            this.value = this.states.includes(state) ? normalizedYAxis : 0.5;
            break;
          case Constants.ComponentProperty.BUTTON:
            this.value = this.states.includes(state) ? button : 0;
            break;
          case Constants.ComponentProperty.STATE:
            if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {
              this.value = this.states.includes(state);
            } else {
              this.value = this.states.includes(state) ? 1 : 0;
            }
            break;
          default:
            throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
        }
      }
    }, __name(_a35, "VisualResponse"), _a35);
  }
});

// node_modules/webxr-input-profiles/packages/motion-controllers/src/components.js
var _a36, Component2;
var init_components = __esm({
  "node_modules/webxr-input-profiles/packages/motion-controllers/src/components.js"() {
    "use strict";
    init_constants();
    init_visualResponse();
    Component2 = (_a36 = class {
      /**
      * @param {Object} componentId - Id of the component
      * @param {Object} componentDescription - Description of the component to be created
      */
      constructor(componentId, componentDescription) {
        if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {
          throw new Error("Invalid arguments supplied");
        }
        this.id = componentId;
        this.type = componentDescription.type;
        this.rootNodeName = componentDescription.rootNodeName;
        this.touchPointNodeName = componentDescription.touchPointNodeName;
        this.visualResponses = {};
        Object.keys(componentDescription.visualResponses).forEach((responseName) => {
          const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);
          this.visualResponses[responseName] = visualResponse;
        });
        this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);
        this.values = {
          state: Constants.ComponentState.DEFAULT,
          button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
          xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
          yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
        };
      }
      get data() {
        const data = {
          id: this.id,
          ...this.values
        };
        return data;
      }
      /**
      * @description Poll for updated data based on current gamepad state
      * @param {Object} gamepad - The gamepad object from which the component data should be polled
      */
      updateFromGamepad(gamepad) {
        this.values.state = Constants.ComponentState.DEFAULT;
        if (this.gamepadIndices.button !== void 0 && gamepad.buttons.length > this.gamepadIndices.button) {
          const gamepadButton = gamepad.buttons[this.gamepadIndices.button];
          this.values.button = gamepadButton.value;
          this.values.button = this.values.button < 0 ? 0 : this.values.button;
          this.values.button = this.values.button > 1 ? 1 : this.values.button;
          if (gamepadButton.pressed || this.values.button === 1) {
            this.values.state = Constants.ComponentState.PRESSED;
          } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {
            this.values.state = Constants.ComponentState.TOUCHED;
          }
        }
        if (this.gamepadIndices.xAxis !== void 0 && gamepad.axes.length > this.gamepadIndices.xAxis) {
          this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];
          this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;
          this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis;
          if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {
            this.values.state = Constants.ComponentState.TOUCHED;
          }
        }
        if (this.gamepadIndices.yAxis !== void 0 && gamepad.axes.length > this.gamepadIndices.yAxis) {
          this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];
          this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;
          this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis;
          if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {
            this.values.state = Constants.ComponentState.TOUCHED;
          }
        }
        Object.values(this.visualResponses).forEach((visualResponse) => {
          visualResponse.updateFromComponent(this.values);
        });
      }
    }, __name(_a36, "Component"), _a36);
  }
});

// node_modules/webxr-input-profiles/packages/motion-controllers/src/motionController.js
var _a37, MotionController;
var init_motionController = __esm({
  "node_modules/webxr-input-profiles/packages/motion-controllers/src/motionController.js"() {
    "use strict";
    init_components();
    MotionController = (_a37 = class {
      /**
      * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
      * @param {Object} profile - The best matched profile description for the supplied xrInputSource
      * @param {Object} assetUrl
      */
      constructor(xrInputSource, profile, assetUrl) {
        if (!xrInputSource) {
          throw new Error("No xrInputSource supplied");
        }
        if (!profile) {
          throw new Error("No profile supplied");
        }
        this.xrInputSource = xrInputSource;
        this.assetUrl = assetUrl;
        this.id = profile.profileId;
        this.layoutDescription = profile.layouts[xrInputSource.handedness];
        this.components = {};
        Object.keys(this.layoutDescription.components).forEach((componentId) => {
          const componentDescription = this.layoutDescription.components[componentId];
          this.components[componentId] = new Component2(componentId, componentDescription);
        });
        this.updateFromGamepad();
      }
      get gripSpace() {
        return this.xrInputSource.gripSpace;
      }
      get targetRaySpace() {
        return this.xrInputSource.targetRaySpace;
      }
      /**
      * @description Returns a subset of component data for simplified debugging
      */
      get data() {
        const data = [];
        Object.values(this.components).forEach((component) => {
          data.push(component.data);
        });
        return data;
      }
      /**
      * @description Poll for updated data based on current gamepad state
      */
      updateFromGamepad() {
        Object.values(this.components).forEach((component) => {
          component.updateFromGamepad(this.xrInputSource.gamepad);
        });
      }
    }, __name(_a37, "MotionController"), _a37);
  }
});

// node_modules/webxr-input-profiles/packages/motion-controllers/src/profiles.js
async function fetchJsonFile(path) {
  const response = await fetch(path);
  if (!response.ok) {
    throw new Error(response.statusText);
  } else {
    return response.json();
  }
}
async function fetchProfilesList(basePath) {
  if (!basePath) {
    throw new Error("No basePath supplied");
  }
  const profileListFileName = "profilesList.json";
  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);
  return profilesList;
}
async function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {
  if (!xrInputSource) {
    throw new Error("No xrInputSource supplied");
  }
  if (!basePath) {
    throw new Error("No basePath supplied");
  }
  const supportedProfilesList = await fetchProfilesList(basePath);
  let match;
  xrInputSource.profiles.some((profileId) => {
    const supportedProfile = supportedProfilesList[profileId];
    if (supportedProfile) {
      match = {
        profileId,
        profilePath: `${basePath}/${supportedProfile.path}`,
        deprecated: !!supportedProfile.deprecated
      };
    }
    return !!match;
  });
  if (!match) {
    if (!defaultProfile) {
      throw new Error("No matching profile name found");
    }
    const supportedProfile = supportedProfilesList[defaultProfile];
    if (!supportedProfile) {
      throw new Error(`No matching profile name found and default profile "${defaultProfile}" missing.`);
    }
    match = {
      profileId: defaultProfile,
      profilePath: `${basePath}/${supportedProfile.path}`,
      deprecated: !!supportedProfile.deprecated
    };
  }
  const profile = await fetchJsonFile(match.profilePath);
  let assetPath;
  if (getAssetPath) {
    let layout;
    if (xrInputSource.handedness === "any") {
      layout = profile.layouts[Object.keys(profile.layouts)[0]];
    } else {
      layout = profile.layouts[xrInputSource.handedness];
    }
    if (!layout) {
      throw new Error(`No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`);
    }
    if (layout.assetPath) {
      assetPath = match.profilePath.replace("profile.json", layout.assetPath);
    }
  }
  return {
    profile,
    assetPath
  };
}
var init_profiles = __esm({
  "node_modules/webxr-input-profiles/packages/motion-controllers/src/profiles.js"() {
    "use strict";
    __name(fetchJsonFile, "fetchJsonFile");
    __name(fetchProfilesList, "fetchProfilesList");
    __name(fetchProfile, "fetchProfile");
  }
});

// src/foundation/importer/Gltf2Importer.ts
var _Gltf2Importer, Gltf2Importer;
var init_Gltf2Importer = __esm({
  "src/foundation/importer/Gltf2Importer.ts"() {
    "use strict";
    init_DataUtil();
    init_RnPromise();
    init_Is();
    init_MiscUtil();
    init_Result();
    init_Logger();
    _Gltf2Importer = class _Gltf2Importer {
      constructor() {
      }
      /**
      * Import glTF2 file
      * @param uri - uri of glTF file
      * @param options - options for loading process
      * @returns a glTF2 based JSON pre-processed
      */
      static async importFromUri(uri, options) {
        var _a40;
        const r_arrayBuffer = await DataUtil.fetchArrayBuffer(uri);
        if (r_arrayBuffer.isErr()) {
          return new Err({
            message: "fetchArrayBuffer error",
            error: void 0
          });
        }
        const result = await this._importGltfOrGlbFromArrayBuffers(r_arrayBuffer.get(), (_a40 = options == null ? void 0 : options.files) != null ? _a40 : {}, options, uri);
        return result;
      }
      static async importFromArrayBuffers(files, options) {
        for (const fileName in files) {
          const fileExtension = DataUtil.getExtension(fileName);
          if (fileExtension === "gltf" || fileExtension === "glb") {
            const result = await this._importGltfOrGlbFromArrayBuffers(files[fileName], files, options);
            return result;
          }
        }
        return new Err({
          message: "no gltf or glb file found",
          error: void 0
        });
      }
      /**
      * Import glTF2 array buffer.
      * @param arrayBuffer .gltf/.glb file in ArrayBuffer
      * @param otherFiles other resource files data in ArrayBuffers
      * @param options options for loading process (Optional)
      * @param uri .gltf file's uri (Optional)
      * @returns a glTF2 based JSON pre-processed
      */
      static async _importGltfOrGlbFromArrayBuffers(arrayBuffer, otherFiles, options, uri) {
        const dataView = new DataView(arrayBuffer, 0, 20);
        const magic = dataView.getUint32(0, true);
        if (magic !== 1179937895) {
          const gotText = DataUtil.arrayBufferToString(arrayBuffer);
          const json = JSON.parse(gotText);
          try {
            const gltfJson = await this._importGltf(json, otherFiles, options, uri);
            return new Ok(gltfJson);
          } catch (err) {
            return new Err({
              message: "this.__importGltf error",
              error: void 0
            });
          }
        } else {
          try {
            const gltfJson = await this._importGlb(arrayBuffer, otherFiles, options);
            return new Ok(gltfJson);
          } catch (err) {
            return new Err({
              message: "this.importGlb error",
              error: void 0
            });
          }
        }
      }
      static _getOptions(defaultOptions, json, options) {
        var _a40, _b;
        if (((_b = (_a40 = json.asset) == null ? void 0 : _a40.extras) == null ? void 0 : _b.rnLoaderOptions) != null) {
          for (const optionName in json.asset.extras.rnLoaderOptions) {
            defaultOptions[optionName] = json.asset.extras.rnLoaderOptions[optionName];
          }
        }
        for (const optionName in options) {
          defaultOptions[optionName] = options[optionName];
        }
        if (options && options.loaderExtensionName && typeof options.loaderExtensionName === "string") {
          if (Rn[options.loaderExtensionName] != null) {
            defaultOptions.loaderExtension = Rn[options.loaderExtensionName].getInstance();
          } else {
            Logger.error(`${options.loaderExtensionName} not found!`);
            defaultOptions.loaderExtension = void 0;
          }
        }
        return defaultOptions;
      }
      static async _importGlb(arrayBuffer, files, options) {
        const dataView = new DataView(arrayBuffer, 0, 20);
        const gltfVer = dataView.getUint32(4, true);
        if (gltfVer !== 2) {
          throw new Error("invalid version field in this binary glTF file.");
        }
        const lengthOfJSonChunkData = dataView.getUint32(12, true);
        const chunkType = dataView.getUint32(16, true);
        if (chunkType !== 1313821514) {
          throw new Error("invalid chunkType of chunk0 in this binary glTF file.");
        }
        const uint8ArrayJSonContent = new Uint8Array(arrayBuffer, 20, lengthOfJSonChunkData);
        const gotText = DataUtil.uint8ArrayToString(uint8ArrayJSonContent);
        const gltfJson = JSON.parse(gotText);
        const defaultOptions = DataUtil.createDefaultGltfOptions();
        options = this._getOptions(defaultOptions, gltfJson, options);
        const uint8array = new Uint8Array(arrayBuffer, 20 + lengthOfJSonChunkData + 8);
        if (gltfJson.asset.extras === void 0) {
          gltfJson.asset.extras = {
            fileType: "glTF",
            version: "2"
          };
        }
        this._mergeExtendedJson(gltfJson, options.extendedJson);
        gltfJson.asset.extras.rnLoaderOptions = options;
        try {
          await this._loadInner(gltfJson, files, options, uint8array);
        } catch (err) {
          Logger.info("this._loadInner error in _loadAsBinaryJson: " + err);
        }
        return gltfJson;
      }
      static async _importGltf(gltfJson, fileArrayBuffers, options, uri, callback) {
        const basePath = (uri == null ? void 0 : uri.substring(0, uri == null ? void 0 : uri.lastIndexOf("/"))) + "/";
        if (gltfJson.asset.extras === void 0) {
          gltfJson.asset.extras = {
            fileType: "glTF",
            version: "2"
          };
        }
        const defaultOptions = DataUtil.createDefaultGltfOptions();
        options = this._getOptions(defaultOptions, gltfJson, options);
        this._mergeExtendedJson(gltfJson, options.extendedJson);
        gltfJson.asset.extras.rnLoaderOptions = options;
        try {
          await this._loadInner(gltfJson, fileArrayBuffers, options, void 0, basePath, callback);
        } catch (err) {
          Logger.error("this._loadInner error in _loadAsTextJson: " + err);
        }
        return gltfJson;
      }
      static _loadInner(gltfJson, files, options, uint8arrayOfGlb, basePath, callback) {
        const promises = [];
        promises.push(this._loadResources(uint8arrayOfGlb, gltfJson, files, options, basePath, callback));
        promises.push(new RnPromise((resolve) => {
          this._loadJsonContent(gltfJson);
          resolve();
        }));
        return RnPromise.all(promises);
      }
      static _loadJsonContent(gltfJson) {
        this._loadDependenciesOfScenes(gltfJson);
        this._loadDependenciesOfNodes(gltfJson);
        this._loadDependenciesOfMeshes(gltfJson);
        this._loadDependenciesOfMaterials(gltfJson);
        this._loadDependenciesOfTextures(gltfJson);
        this._loadDependenciesOfJoints(gltfJson);
        this._loadDependenciesOfAnimations(gltfJson);
        this._loadDependenciesOfAccessors(gltfJson);
        this._loadDependenciesOfBufferViews(gltfJson);
        if (gltfJson.asset.extras === void 0) {
          gltfJson.asset.extras = {};
        }
      }
      static _loadDependenciesOfScenes(gltfJson) {
        for (const scene of gltfJson.scenes) {
          if (Is.undefined(scene.nodesObjects)) {
            scene.nodesObjects = [];
          }
          for (const i2 of scene.nodes) {
            scene.nodesObjects[i2] = gltfJson.nodes[scene.nodes[i2]];
          }
        }
      }
      static _loadDependenciesOfNodes(gltfJson) {
        var _a40, _b;
        for (const node_i in gltfJson.nodes) {
          const node = gltfJson.nodes[node_i];
          node.childrenObjects = (_a40 = node.childrenObjects) != null ? _a40 : [];
          if (node.children) {
            for (const child_i of node.children) {
              node.childrenObjects[child_i] = gltfJson.nodes[child_i];
              gltfJson.nodes[child_i].parent = parseInt(node_i);
              gltfJson.nodes[child_i].parentObject = node;
            }
          }
          if (node.mesh !== void 0 && gltfJson.meshes !== void 0) {
            node.meshObject = gltfJson.meshes[node.mesh];
          }
          if (node.skin !== void 0 && gltfJson.skins !== void 0) {
            node.skinObject = gltfJson.skins[node.skin];
            if (Is.exist(node.skinObject)) {
              if (Is.not.exist((_b = node.meshObject) == null ? void 0 : _b.extras)) {
                node.meshObject.extras = {};
              }
              node.meshObject.extras._skin = node.skin;
            }
          }
          if (node.camera !== void 0 && gltfJson.cameras !== void 0) {
            node.cameraObject = gltfJson.cameras[node.camera];
          }
          if (node.extensions !== void 0 && node.extensions.KHR_lights_punctual !== void 0 && gltfJson.extensions !== void 0 && gltfJson.extensions.KHR_lights_punctual !== void 0) {
            node.extensions.KHR_lights_punctual.lightIndex = node.extensions.KHR_lights_punctual.light;
            node.extensions.KHR_lights_punctual.light = gltfJson.extensions.KHR_lights_punctual.lights[node.extensions.KHR_lights_punctual.lightIndex];
          }
        }
      }
      static _loadDependenciesOfMeshes(gltfJson) {
        var _a40;
        if (Is.not.exist(gltfJson.meshes)) {
          return;
        }
        for (const mesh of gltfJson.meshes) {
          for (const primitive of mesh.primitives) {
            if (primitive.material !== void 0) {
              primitive.materialObject = gltfJson.materials[primitive.material];
            }
            if (((_a40 = primitive.extensions) == null ? void 0 : _a40.KHR_materials_variants) != null) {
              primitive.materialVariants = [];
              const mappings = primitive.extensions.KHR_materials_variants.mappings;
              const variantNames = gltfJson.extensions.KHR_materials_variants.variants;
              for (const mapping of mappings) {
                const variants = mapping.variants.map((variantIdx) => {
                  return variantNames[variantIdx].name;
                });
                const materialVariant = {
                  materialObject: gltfJson.materials[mapping.material],
                  material: mapping.material,
                  variants
                };
                primitive.materialVariants.push(materialVariant);
              }
            }
            primitive.attributesObjects = {};
            for (const attributeName in primitive.attributes) {
              const accessorId = primitive.attributes[attributeName];
              const accessor = gltfJson.accessors[accessorId];
              accessor.extras = {
                toGetAsTypedArray: true,
                attributeName
              };
              primitive.attributesObjects[attributeName] = accessor;
            }
            if (primitive.indices != null) {
              primitive.indicesObject = gltfJson.accessors[primitive.indices];
            }
            if (primitive.targets != null) {
              primitive.targetsObjects = [];
              for (const target of primitive.targets) {
                const attributes = {};
                for (const attributeName in target) {
                  const targetShapeTargetAccessorId = target[attributeName];
                  if (targetShapeTargetAccessorId >= 0) {
                    const accessor = gltfJson.accessors[targetShapeTargetAccessorId];
                    accessor.extras = {
                      toGetAsTypedArray: true,
                      attributeName
                    };
                    attributes[attributeName] = accessor;
                  }
                }
                primitive.targetsObjects.push(attributes);
              }
            }
          }
        }
      }
      static _checkRnGltfLoaderOptionsExist(gltfModel) {
        if (gltfModel.asset.extras && gltfModel.asset.extras.rnLoaderOptions) {
          return true;
        } else {
          return false;
        }
      }
      static _loadDependenciesOfMaterials(gltfJson) {
        if (!gltfJson.textures) gltfJson.textures = [];
        if (gltfJson.materials) {
          for (const material of gltfJson.materials) {
            if (material.pbrMetallicRoughness) {
              const baseColorTexture = material.pbrMetallicRoughness.baseColorTexture;
              if (baseColorTexture !== void 0) {
                baseColorTexture.texture = gltfJson.textures[baseColorTexture.index];
              }
              const metallicRoughnessTexture = material.pbrMetallicRoughness.metallicRoughnessTexture;
              if (metallicRoughnessTexture !== void 0) {
                metallicRoughnessTexture.texture = gltfJson.textures[metallicRoughnessTexture.index];
              }
            }
            const normalTexture = material.normalTexture;
            if (normalTexture !== void 0) {
              normalTexture.texture = gltfJson.textures[normalTexture.index];
            }
            const occlusionTexture = material.occlusionTexture;
            if (occlusionTexture !== void 0) {
              occlusionTexture.texture = gltfJson.textures[occlusionTexture.index];
            }
            const emissiveTexture = material.emissiveTexture;
            if (emissiveTexture !== void 0) {
              emissiveTexture.texture = gltfJson.textures[emissiveTexture.index];
            }
            if (this._checkRnGltfLoaderOptionsExist(gltfJson) && gltfJson.asset.extras.rnLoaderOptions.loaderExtension && gltfJson.asset.extras.rnLoaderOptions.loaderExtension.setTextures) {
              gltfJson.asset.extras.rnLoaderOptions.loaderExtension.setTextures(gltfJson, material);
            }
            if (Is.exist(material.extensions)) {
              const extensions = material.extensions;
              if (Is.exist(extensions.KHR_materials_clearcoat)) {
                const clearcoatTexture = extensions.KHR_materials_clearcoat.clearcoatTexture;
                if (clearcoatTexture !== void 0) {
                  clearcoatTexture.texture = gltfJson.textures[clearcoatTexture.index];
                }
                const clearcoatRoughnessTexture = extensions.KHR_materials_clearcoat.clearcoatRoughnessTexture;
                if (clearcoatRoughnessTexture !== void 0) {
                  clearcoatRoughnessTexture.texture = gltfJson.textures[clearcoatRoughnessTexture.index];
                }
                const clearcoatNormalTexture = extensions.KHR_materials_clearcoat.clearcoatNormalTexture;
                if (clearcoatNormalTexture !== void 0) {
                  clearcoatNormalTexture.texture = gltfJson.textures[clearcoatNormalTexture.index];
                }
              }
              if (Is.exist(extensions.KHR_materials_transmission)) {
                const transmissionTexture = extensions.KHR_materials_transmission.transmissionTexture;
                if (transmissionTexture !== void 0) {
                  transmissionTexture.texture = gltfJson.textures[transmissionTexture.index];
                }
              }
              if (Is.exist(extensions.KHR_materials_volume)) {
                const thicknessTexture = extensions.KHR_materials_volume.thicknessTexture;
                if (thicknessTexture !== void 0) {
                  thicknessTexture.texture = gltfJson.textures[thicknessTexture.index];
                }
              }
              if (Is.exist(extensions.KHR_materials_sheen)) {
                const sheenColorTexture = extensions.KHR_materials_sheen.sheenColorTexture;
                if (sheenColorTexture !== void 0) {
                  sheenColorTexture.texture = gltfJson.textures[sheenColorTexture.index];
                }
                const sheenRoughnessTexture = extensions.KHR_materials_sheen.sheenRoughnessTexture;
                if (sheenRoughnessTexture !== void 0) {
                  sheenRoughnessTexture.texture = gltfJson.textures[sheenRoughnessTexture.index];
                }
              }
              if (Is.exist(extensions.KHR_materials_specular)) {
                const specularTexture = extensions.KHR_materials_specular.specularTexture;
                if (specularTexture !== void 0) {
                  specularTexture.texture = gltfJson.textures[specularTexture.index];
                }
                const specularColorTexture = extensions.KHR_materials_specular.specularColorTexture;
                if (specularColorTexture !== void 0) {
                  specularColorTexture.texture = gltfJson.textures[specularColorTexture.index];
                }
              }
              if (Is.exist(extensions.KHR_materials_iridescence)) {
                const iridescenceTexture = extensions.KHR_materials_iridescence.iridescenceTexture;
                if (iridescenceTexture !== void 0) {
                  iridescenceTexture.texture = gltfJson.textures[iridescenceTexture.index];
                }
                const iridescenceThicknessTexture = extensions.KHR_materials_iridescence.iridescenceThicknessTexture;
                if (iridescenceThicknessTexture !== void 0) {
                  iridescenceThicknessTexture.texture = gltfJson.textures[iridescenceThicknessTexture.index];
                }
              }
              if (Is.exist(extensions.KHR_materials_anisotropy)) {
                const anisotropyTexture = extensions.KHR_materials_anisotropy.anisotropyTexture;
                if (anisotropyTexture !== void 0) {
                  anisotropyTexture.texture = gltfJson.textures[anisotropyTexture.index];
                }
              }
              if (Is.exist(extensions.VRMC_materials_mtoon)) {
                const mToon = extensions.VRMC_materials_mtoon;
                const shadeMultiplyTexture = mToon.shadeMultiplyTexture;
                if (shadeMultiplyTexture != null) {
                  shadeMultiplyTexture.texture = gltfJson.textures[shadeMultiplyTexture.index];
                }
                const shadingShiftTexture = mToon.shadingShiftTexture;
                if (shadingShiftTexture != null) {
                  shadingShiftTexture.texture = gltfJson.textures[shadingShiftTexture.index];
                }
                const matcapTexture = mToon.matcapTexture;
                if (matcapTexture != null) {
                  matcapTexture.texture = gltfJson.textures[matcapTexture.index];
                }
                const rimMultiplyTexture = mToon.rimMultiplyTexture;
                if (rimMultiplyTexture != null) {
                  rimMultiplyTexture.texture = gltfJson.textures[rimMultiplyTexture.index];
                }
                const outlineWidthMultiplyTexture = mToon.outlineWidthMultiplyTexture;
                if (outlineWidthMultiplyTexture != null) {
                  outlineWidthMultiplyTexture.texture = gltfJson.textures[outlineWidthMultiplyTexture.index];
                }
                const uvAnimationMaskTexture = mToon.uvAnimationMaskTexture;
                if (uvAnimationMaskTexture != null) {
                  uvAnimationMaskTexture.texture = gltfJson.textures[uvAnimationMaskTexture.index];
                }
              }
            }
          }
        }
      }
      static _loadDependenciesOfTextures(gltfJson) {
        var _a40, _b;
        if (gltfJson.textures) {
          for (const texture of gltfJson.textures) {
            ifDefinedThen((v) => texture.samplerObject = gltfJson.samplers[v], texture.sampler);
            if (((_b = (_a40 = texture.extensions) == null ? void 0 : _a40.KHR_texture_basisu) == null ? void 0 : _b.source) != null) {
              texture.extensions.KHR_texture_basisu.fallbackSourceIndex = texture.source;
              texture.source = texture.extensions.KHR_texture_basisu.source;
              texture.image = gltfJson.images[texture.source];
            } else if (texture.source !== void 0) {
              texture.image = gltfJson.images[texture.source];
            }
          }
        }
      }
      static _loadDependenciesOfJoints(gltfJson) {
        if (gltfJson.skins) {
          for (const skin of gltfJson.skins) {
            skin.skeletonObject = gltfJson.nodes[skin.skeleton];
            skin.inverseBindMatricesObject = gltfJson.accessors[skin.inverseBindMatrices];
            if (Is.not.exist(skin.skeleton)) {
              skin.skeleton = skin.joints[0];
              skin.skeletonObject = gltfJson.nodes[skin.skeleton];
            }
            skin.jointsObjects = [];
            for (const jointIndex of skin.joints) {
              skin.jointsObjects.push(gltfJson.nodes[jointIndex]);
            }
          }
        }
      }
      static _loadDependenciesOfAnimations(gltfJson) {
        if (gltfJson.animations) {
          for (const animation of gltfJson.animations) {
            for (const channel of animation.channels) {
              if (Is.exist(channel.sampler)) {
                channel.samplerObject = animation.samplers[channel.sampler];
                channel.target.nodeObject = gltfJson.nodes[channel.target.node];
                channel.samplerObject.inputObject = gltfJson.accessors[channel.samplerObject.input];
                channel.samplerObject.outputObject = gltfJson.accessors[channel.samplerObject.output];
                if (Is.undefined(channel.samplerObject.outputObject.extras)) {
                  channel.samplerObject.outputObject.extras = {};
                }
                if (channel.target.path === "weights") {
                  let weightsArrayLength = channel.samplerObject.outputObject.count / channel.samplerObject.inputObject.count;
                  if (channel.samplerObject.interpolation === "CUBICSPLINE") {
                    weightsArrayLength = channel.samplerObject.outputObject.count / channel.samplerObject.inputObject.count / 3;
                  }
                  channel.samplerObject.outputObject.extras.weightsArrayLength = weightsArrayLength;
                }
                if (channel.target.path === "rotation") {
                  channel.samplerObject.outputObject.extras.quaternionIfVec4 = true;
                }
              }
            }
          }
        }
      }
      static _loadDependenciesOfAccessors(gltfJson) {
        for (const accessor of gltfJson.accessors) {
          if (accessor.bufferView != null) {
            accessor.bufferViewObject = gltfJson.bufferViews[accessor.bufferView];
          }
          if (Is.exist(accessor.sparse)) {
            const sparse = accessor.sparse;
            if (Is.exist(sparse) && Is.exist(sparse.indices) && Is.exist(sparse.values)) {
              sparse.indices.bufferViewObject = gltfJson.bufferViews[sparse.indices.bufferView];
              sparse.values.bufferViewObject = gltfJson.bufferViews[sparse.values.bufferView];
            }
          }
        }
      }
      static _loadDependenciesOfBufferViews(gltfJson) {
        for (const bufferView of gltfJson.bufferViews) {
          if (bufferView.buffer !== void 0) {
            bufferView.bufferObject = gltfJson.buffers[bufferView.buffer];
          }
        }
      }
      static _mergeExtendedJson(gltfJson, extendedData) {
        let extendedJson = null;
        if (extendedData instanceof ArrayBuffer) {
          const extendedJsonStr = DataUtil.arrayBufferToString(extendedData);
          extendedJson = JSON.parse(extendedJsonStr);
        } else if (typeof extendedData === "string") {
          extendedJson = JSON.parse(extendedData);
        } else if (typeof extendedData === "object") {
          extendedJson = extendedData;
        }
        Object.assign(gltfJson, extendedJson);
      }
      static _loadResources(uint8ArrayOfGlb, gltfJson, files, options, basePath, callback) {
        var _a40;
        const promisesToLoadResources = [];
        let rnpArrayBuffer;
        for (const rnm2Buffer of gltfJson.buffers) {
          let filename = "";
          if (rnm2Buffer.uri) {
            const splitUri = rnm2Buffer.uri.split("/");
            filename = splitUri[splitUri.length - 1];
          }
          if (typeof rnm2Buffer.uri === "undefined") {
            rnpArrayBuffer = new RnPromise((resolve) => {
              rnm2Buffer.buffer = uint8ArrayOfGlb;
              resolve(uint8ArrayOfGlb);
            });
          } else if (rnm2Buffer.uri.match(/^data:application\/(.*);base64,/)) {
            rnpArrayBuffer = new RnPromise((resolve) => {
              const arrayBuffer = DataUtil.dataUriToArrayBuffer(rnm2Buffer.uri);
              rnm2Buffer.buffer = new Uint8Array(arrayBuffer);
              resolve(arrayBuffer);
            });
          } else if (files && this.__containsFileName(files, filename)) {
            rnpArrayBuffer = new RnPromise((resolve) => {
              const fullPath = this.__getFullPathOfFileName(files, filename);
              const arrayBuffer = files[fullPath];
              rnm2Buffer.buffer = new Uint8Array(arrayBuffer);
              resolve(arrayBuffer);
            });
          } else {
            rnpArrayBuffer = new RnPromise(DataUtil.loadResourceAsync(basePath + rnm2Buffer.uri, true, (resolve, response) => {
              rnm2Buffer.buffer = new Uint8Array(response);
              resolve(response);
            }, (reject, error) => {
              reject("HTTP Error Status:" + error);
            }));
          }
          rnm2Buffer.bufferPromise = rnpArrayBuffer;
          promisesToLoadResources.push(rnpArrayBuffer);
        }
        for (const rnm2Image of (_a40 = gltfJson.images) != null ? _a40 : []) {
          if (rnm2Image.uri == null) {
            if (Is.exist(uint8ArrayOfGlb)) {
              const imageUint8Array = DataUtil.createUint8ArrayFromBufferViewInfo(gltfJson, rnm2Image.bufferView, uint8ArrayOfGlb);
              const imageUri = DataUtil.createBlobImageUriFromUint8Array(imageUint8Array, rnm2Image.mimeType);
              promisesToLoadResources.push(this.__loadImageUri(imageUri, rnm2Image, files));
            } else {
              const rnm2BufferView = gltfJson.bufferViews[rnm2Image.bufferView];
              const bufferInfo = rnm2BufferView.bufferObject;
              if (Is.not.exist(bufferInfo)) {
                Logger.error("gltf2BufferView.bufferObject not found");
                continue;
              }
              const bufferPromise = bufferInfo.bufferPromise;
              const loadImageAfterLoadingBuffer = new RnPromise((resolve) => {
                bufferPromise.then((arraybuffer) => {
                  const imageUint8Array = DataUtil.createUint8ArrayFromBufferViewInfo(gltfJson, rnm2Image.bufferView, arraybuffer);
                  const imageUri = DataUtil.createBlobImageUriFromUint8Array(imageUint8Array, rnm2Image.mimeType);
                  this.__loadImageUri(imageUri, rnm2Image, files).then(() => {
                    resolve(arraybuffer);
                  });
                });
              });
              const bufferPromiseIndex = promisesToLoadResources.indexOf(bufferPromise);
              promisesToLoadResources[bufferPromiseIndex] = loadImageAfterLoadingBuffer;
              bufferInfo.bufferPromise = loadImageAfterLoadingBuffer;
            }
          } else {
            const imageFileStr = rnm2Image.uri;
            const splitUri = imageFileStr.split("/");
            const filename = splitUri[splitUri.length - 1];
            let imageUri;
            if (files && this.__containsFileName(files, filename)) {
              const fullPath = this.__getFullPathOfFileName(files, filename);
              const arrayBuffer = files[fullPath];
              imageUri = DataUtil.createBlobImageUriFromUint8Array(new Uint8Array(arrayBuffer), rnm2Image.mimeType);
            } else if (imageFileStr.match(/^data:/)) {
              imageUri = imageFileStr;
            } else {
              imageUri = basePath + imageFileStr;
            }
            promisesToLoadResources.push(this.__loadImageUri(imageUri, rnm2Image, files));
          }
        }
        return RnPromise.all(promisesToLoadResources, callback).catch((err) => {
          Logger.error("Promise.all error: " + err);
        });
      }
      static __containsFileName(optionsFiles, filename) {
        for (const key in optionsFiles) {
          const split = key.split("/");
          const last = split[split.length - 1];
          if (last === filename) {
            return true;
          }
        }
        return false;
      }
      static __getFullPathOfFileName(optionsFiles, filename) {
        for (const key in optionsFiles) {
          const split = key.split("/");
          const last = split[split.length - 1];
          if (last === filename) {
            return key;
          }
        }
        return void 0;
      }
      static __loadImageUri(imageUri, imageJson, files) {
        var _a40, _b;
        let loadImagePromise;
        if (imageUri.match(/basis$/)) {
          loadImagePromise = new RnPromise((resolve) => {
            fetch(imageUri, {
              mode: "cors"
            }).then((response) => {
              response.arrayBuffer().then((buffer) => {
                const uint8Array = new Uint8Array(buffer);
                imageJson.basis = uint8Array;
                resolve(imageJson);
              });
            });
          });
        } else if ((_a40 = imageJson.uri) == null ? void 0 : _a40.match(/basis$/)) {
          loadImagePromise = new RnPromise((resolve) => {
            imageJson.basis = new Uint8Array(files[imageJson.uri]);
            resolve(imageJson);
          });
        } else if (imageUri.match(/\.ktx2$/) || imageUri.match(/^data:image\/ktx2/) || imageJson.bufferView != null && imageJson.mimeType === "image/ktx2") {
          loadImagePromise = new RnPromise((resolve) => {
            fetch(imageUri, {
              mode: "cors"
            }).then((response) => {
              response.arrayBuffer().then((buffer) => {
                const uint8Array = new Uint8Array(buffer);
                imageJson.ktx2 = uint8Array;
                resolve(imageJson);
              });
            });
          });
        } else if ((_b = imageJson.uri) == null ? void 0 : _b.match(/ktx2$/)) {
          loadImagePromise = new RnPromise((resolve) => {
            imageJson.ktx2 = new Uint8Array(files[imageJson.uri]);
            resolve(imageJson);
          });
        } else {
          loadImagePromise = DataUtil.createImageFromUri(imageUri, imageJson.mimeType).then((image) => {
            image.crossOrigin = "Anonymous";
            imageJson.image = image;
            return imageJson;
          });
        }
        return loadImagePromise;
      }
    };
    __name(_Gltf2Importer, "Gltf2Importer");
    Gltf2Importer = _Gltf2Importer;
  }
});

// src/foundation/components/Skeletal/SkeletalComponent.ts
var _SkeletalComponent, SkeletalComponent;
var init_SkeletalComponent = __esm({
  "src/foundation/components/Skeletal/SkeletalComponent.ts"() {
    "use strict";
    init_Component();
    init_EntityRepository();
    init_WellKnownComponentTIDs();
    init_Matrix44();
    init_ProcessStage();
    init_MutableVector3();
    init_MutableQuaternion();
    init_MathUtil();
    init_MutableVector4();
    init_MutableMatrix44();
    init_GlobalDataRepository();
    init_Config();
    init_BoneDataType();
    init_misc();
    init_Logger();
    _SkeletalComponent = class _SkeletalComponent extends Component {
      constructor(entityUid, componentSid, entityRepository, isReUse) {
        super(entityUid, componentSid, entityRepository, isReUse);
        __publicField(this, "_jointIndices", []);
        __publicField(this, "__joints", []);
        __publicField(this, "__inverseBindMatricesAccessor");
        __publicField(this, "_bindShapeMatrix");
        __publicField(this, "__jointMatrices");
        __publicField(this, "topOfJointsHierarchy");
        __publicField(this, "isSkinning", true);
        __publicField(this, "__qArray", new Float32Array(0));
        __publicField(this, "__tsArray", new Float32Array(0));
        __publicField(this, "__tqArray", new Float32Array(0));
        __publicField(this, "__sqArray", new Float32Array(0));
        __publicField(this, "__qtsArray", new Float32Array(0));
        __publicField(this, "__qtsInfo", MutableVector4.dummy());
        __publicField(this, "__matArray", new Float32Array(0));
        __publicField(this, "__worldMatrix", MutableMatrix44.identity());
        __publicField(this, "__isWorldMatrixVanilla", true);
        __publicField(this, "_isCulled", false);
        this.moveStageTo(ProcessStage.Logic);
        if (isReUse) {
          return;
        }
        if (_SkeletalComponent.__tookGlobalDataNum < Config.maxSkeletonNumber) {
          if (Config.boneDataType === BoneDataType.Mat43x1) {
            _SkeletalComponent.__globalDataRepository.takeOne("boneMatrix");
          } else if (Config.boneDataType === BoneDataType.Vec4x2) {
            _SkeletalComponent.__globalDataRepository.takeOne("boneTranslatePackedQuat");
            _SkeletalComponent.__globalDataRepository.takeOne("boneScalePackedQuat");
          } else if (Config.boneDataType === BoneDataType.Vec4x2Old) {
            _SkeletalComponent.__globalDataRepository.takeOne("boneQuaternion");
            _SkeletalComponent.__globalDataRepository.takeOne("boneTranslateScale");
          } else if (Config.boneDataType === BoneDataType.Vec4x1) {
            _SkeletalComponent.__globalDataRepository.takeOne("boneTranslateScale");
            _SkeletalComponent.__globalDataRepository.takeOne("boneCompressedChunk");
          }
          _SkeletalComponent.__tookGlobalDataNum++;
        } else {
          Logger.warn("The actual number of Skeleton generated exceeds Config.maxSkeletonNumber.");
        }
      }
      static get componentTID() {
        return WellKnownComponentTIDs.SkeletalComponentTID;
      }
      get componentTID() {
        return WellKnownComponentTIDs.SkeletalComponentTID;
      }
      setInverseBindMatricesAccessor(inverseBindMatricesAccessor) {
        this.__inverseBindMatricesAccessor = inverseBindMatricesAccessor;
      }
      setJoints(joints) {
        this.__joints = joints;
        let index = 0;
        if (this.componentSID < Config.maxSkeletonNumber) {
          index = this.componentSID;
        }
        if (Config.boneDataType === BoneDataType.Mat43x1) {
          this.__matArray = _SkeletalComponent.__globalDataRepository.getValue("boneMatrix", index)._v;
        } else if (Config.boneDataType === BoneDataType.Vec4x2) {
          this.__tqArray = _SkeletalComponent.__globalDataRepository.getValue("boneTranslatePackedQuat", index)._v;
          this.__sqArray = _SkeletalComponent.__globalDataRepository.getValue("boneScalePackedQuat", index)._v;
        } else if (Config.boneDataType === BoneDataType.Vec4x2Old) {
          this.__qArray = _SkeletalComponent.__globalDataRepository.getValue("boneQuaternion", index)._v;
          this.__tsArray = _SkeletalComponent.__globalDataRepository.getValue("boneTranslateScale", index)._v;
        } else if (Config.boneDataType === BoneDataType.Vec4x1) {
          this.__tsArray = _SkeletalComponent.__globalDataRepository.getValue("boneTranslateScale", index)._v;
          this.__qtsArray = _SkeletalComponent.__globalDataRepository.getValue("boneCompressedChunk", index)._v;
          this.__qtsInfo = _SkeletalComponent.__globalDataRepository.getValue("boneCompressedInfo", 0);
        }
      }
      getJoints() {
        return this.__joints.concat();
      }
      get rootJointWorldMatrixInner() {
        var _a40;
        return (_a40 = this.topOfJointsHierarchy) == null ? void 0 : _a40.matrixInner;
      }
      get jointMatrices() {
        return this.__jointMatrices;
      }
      get jointQuaternionArray() {
        return this.__qArray;
      }
      get jointTranslateScaleArray() {
        return this.__tsArray;
      }
      get jointTranslatePackedQuat() {
        return this.__tqArray;
      }
      get jointScalePackedQuat() {
        return this.__sqArray;
      }
      get jointMatricesArray() {
        return this.__matArray;
      }
      get jointCompressedChunk() {
        return this.__qtsArray;
      }
      get jointCompressedInfo() {
        return this.__qtsInfo;
      }
      get worldMatrix() {
        return this.__worldMatrix.clone();
      }
      get worldMatrixInner() {
        return this.__worldMatrix;
      }
      get isWorldMatrixUpdated() {
        return !this.__isWorldMatrixVanilla;
      }
      $logic() {
        if (!this.isSkinning || this._isCulled) {
          return;
        }
        for (let i2 = 0; i2 < this.__joints.length; i2++) {
          const joint = this.__joints[i2];
          const globalJointTransform = joint.isVisible ? joint.matrixInner : joint.matrixRestInner;
          MutableMatrix44.multiplyTypedArrayTo(globalJointTransform, this.__inverseBindMatricesAccessor.getTypedArray(), _SkeletalComponent.__tmp_mat4, i2);
          if (this._bindShapeMatrix) {
            _SkeletalComponent.__tmp_mat4.multiply(this._bindShapeMatrix);
          }
          const m = _SkeletalComponent.__tmp_mat4;
          if (i2 === 0 && joint.entity.tryToGetAnimation() != null) {
            this.__worldMatrix.copyComponents(m);
          }
          if (i2 === 1 && this.__joints[0].entity.tryToGetAnimation() == null) {
            this.__worldMatrix.copyComponents(m);
          }
          this.__isWorldMatrixVanilla = false;
          if (Config.boneDataType === BoneDataType.Mat43x1 || Config.boneDataType === BoneDataType.Vec4x1) {
            this.__copyToMatArray(m, i2);
          }
          if (Config.boneDataType !== BoneDataType.Mat43x1) {
            const scaleVec = _SkeletalComponent.__tmpVec3_0.setComponents(Math.hypot(m._v[0], m._v[1], m._v[2]), Math.hypot(m._v[4], m._v[5], m._v[6]), Math.hypot(m._v[8], m._v[9], m._v[10]));
            m.m00 /= scaleVec.x;
            m.m01 /= scaleVec.x;
            m.m02 /= scaleVec.x;
            m.m10 /= scaleVec.y;
            m.m11 /= scaleVec.y;
            m.m12 /= scaleVec.y;
            m.m20 /= scaleVec.z;
            m.m21 /= scaleVec.z;
            m.m22 /= scaleVec.z;
            const q = _SkeletalComponent.__tmp_q.fromMatrix(m);
            if (Config.boneDataType === BoneDataType.Vec4x2Old || Config.boneDataType === BoneDataType.Vec4x1) {
              let maxScale = 1;
              if (Math.abs(scaleVec.x) > Math.abs(scaleVec.y)) {
                if (Math.abs(scaleVec.x) > Math.abs(scaleVec.z)) {
                  maxScale = scaleVec.x;
                } else {
                  maxScale = scaleVec.z;
                }
              } else {
                if (Math.abs(scaleVec.y) > Math.abs(scaleVec.z)) {
                  maxScale = scaleVec.y;
                } else {
                  maxScale = scaleVec.z;
                }
              }
              this.__tsArray[i2 * 4 + 3] = maxScale;
            }
            if (Config.boneDataType === BoneDataType.Vec4x2) {
              const vec2QPacked = MathUtil.packNormalizedVec4ToVec2(q.x, q.y, q.z, q.w, Math.pow(2, 12));
              this.__tqArray[i2 * 4 + 0] = m.m03;
              this.__tqArray[i2 * 4 + 1] = m.m13;
              this.__tqArray[i2 * 4 + 2] = m.m23;
              this.__sqArray[i2 * 4 + 0] = scaleVec.x;
              this.__sqArray[i2 * 4 + 1] = scaleVec.y;
              this.__sqArray[i2 * 4 + 2] = scaleVec.z;
              this.__tqArray[i2 * 4 + 3] = vec2QPacked[0];
              this.__sqArray[i2 * 4 + 3] = vec2QPacked[1];
            } else if (Config.boneDataType === BoneDataType.Vec4x2Old) {
              this.__tsArray[i2 * 4 + 0] = m.m03;
              this.__tsArray[i2 * 4 + 1] = m.m13;
              this.__tsArray[i2 * 4 + 2] = m.m23;
              this.__qArray[i2 * 4 + 0] = q.x;
              this.__qArray[i2 * 4 + 1] = q.y;
              this.__qArray[i2 * 4 + 2] = q.z;
              this.__qArray[i2 * 4 + 3] = q.w;
            }
            if (Config.boneDataType === BoneDataType.Vec4x1) {
              this.__tsArray[i2 * 4 + 0] = m.m03;
              this.__tsArray[i2 * 4 + 1] = m.m13;
              this.__tsArray[i2 * 4 + 2] = m.m23;
              const vec2QPacked = MathUtil.packNormalizedVec4ToVec2(q.x, q.y, q.z, q.w, Math.pow(2, 12));
              this.__qtsArray[i2 * 4 + 0] = vec2QPacked[0];
              this.__qtsArray[i2 * 4 + 1] = vec2QPacked[1];
            }
          }
        }
        if (Config.boneDataType === BoneDataType.Vec4x1) {
          let maxAbsX = 1;
          let maxAbsY = 1;
          let maxAbsZ = 1;
          for (let i2 = 0; i2 < this.__joints.length; i2++) {
            const absX = Math.abs(this.__tsArray[i2 * 4 + 0]);
            if (absX > maxAbsX) {
              maxAbsX = absX;
            }
            const absY = Math.abs(this.__tsArray[i2 * 4 + 1]);
            if (absY > maxAbsY) {
              maxAbsY = absY;
            }
            const absZ = Math.abs(this.__tsArray[i2 * 4 + 2]);
            if (absZ > maxAbsZ) {
              maxAbsZ = absZ;
            }
          }
          this.__qtsInfo.x = maxAbsX;
          this.__qtsInfo.y = maxAbsY;
          this.__qtsInfo.z = maxAbsZ;
          this.__qtsInfo.w = 1;
          for (let i2 = 0; i2 < this.__joints.length; i2++) {
            const x = this.__tsArray[i2 * 4 + 0];
            const y = this.__tsArray[i2 * 4 + 1];
            const z = this.__tsArray[i2 * 4 + 2];
            const scale = this.__tsArray[i2 * 4 + 3];
            const normalizedX = x / maxAbsX;
            const normalizedY = y / maxAbsY;
            const normalizedZ = z / maxAbsZ;
            const normalizedW = scale;
            const vec2TPacked = MathUtil.packNormalizedVec4ToVec2(normalizedX, normalizedY, normalizedZ, normalizedW, Math.pow(2, 12));
            this.__qtsArray[i2 * 4 + 2] = vec2TPacked[0];
            this.__qtsArray[i2 * 4 + 3] = vec2TPacked[1];
          }
        }
      }
      __copyToMatArray(m, i2) {
        this.__matArray[i2 * 12 + 0] = m._v[0];
        this.__matArray[i2 * 12 + 1] = m._v[1];
        this.__matArray[i2 * 12 + 2] = m._v[2];
        this.__matArray[i2 * 12 + 3] = m._v[4];
        this.__matArray[i2 * 12 + 4] = m._v[5];
        this.__matArray[i2 * 12 + 5] = m._v[6];
        this.__matArray[i2 * 12 + 6] = m._v[8];
        this.__matArray[i2 * 12 + 7] = m._v[9];
        this.__matArray[i2 * 12 + 8] = m._v[10];
        this.__matArray[i2 * 12 + 9] = m._v[12];
        this.__matArray[i2 * 12 + 10] = m._v[13];
        this.__matArray[i2 * 12 + 11] = m._v[14];
      }
      getInverseBindMatricesAccessor() {
        return this.__inverseBindMatricesAccessor;
      }
      _shallowCopyFrom(component_) {
        const component = component_;
        this._jointIndices = component._jointIndices.concat();
        this.setJoints(component.__joints.concat());
        this.setJoints([]);
        this.__inverseBindMatricesAccessor = component.__inverseBindMatricesAccessor;
        if (Is.exist(component._bindShapeMatrix)) {
          this._bindShapeMatrix = component._bindShapeMatrix.clone();
        }
        if (Is.exist(component.__jointMatrices)) {
          this.__jointMatrices = component.__jointMatrices.concat();
        }
        this.topOfJointsHierarchy = component.topOfJointsHierarchy;
        this.isSkinning = component.isSkinning;
        this.__qArray.set(component.__qArray);
        this.__tsArray.set(component.__tsArray);
        this.__tqArray.set(component.__tqArray);
        this.__sqArray.set(component.__sqArray);
        this.__qtsArray.set(component.__qtsArray);
        this.__qtsInfo.copyComponents(component.__qtsInfo);
        this.__matArray.set(component.__matArray);
        this.__worldMatrix.copyComponents(component.__worldMatrix);
        this.__isWorldMatrixVanilla = component.__isWorldMatrixVanilla;
      }
      /**
      * get the entity which has this component.
      * @returns the entity which has this component
      */
      get entity() {
        return EntityRepository.getEntity(this.__entityUid);
      }
      _destroy() {
        super._destroy();
      }
      /**
      * @override
      * Add this component to the entity
      * @param base the target entity
      * @param _componentClass the component class to add
      */
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let SkeletalEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
          }
          getSkeletal() {
            return this.getComponentByComponentTID(WellKnownComponentTIDs.SkeletalComponentTID);
          }
        }, __name(_a40, "SkeletalEntity"), _a40);
        applyMixins(base, SkeletalEntity);
        return base;
      }
      _getInverseBindMatrices(sg) {
        const index = this.__joints.indexOf(sg);
        const float32Array = this.__inverseBindMatricesAccessor.getTypedArray();
        const m = new Matrix44(float32Array.slice(index * 16, index * 16 + 16));
        return m;
      }
    };
    __name(_SkeletalComponent, "SkeletalComponent");
    __publicField(_SkeletalComponent, "__globalDataRepository", GlobalDataRepository.getInstance());
    __publicField(_SkeletalComponent, "__tookGlobalDataNum", 0);
    __publicField(_SkeletalComponent, "__tmpVec3_0", MutableVector3.zero());
    __publicField(_SkeletalComponent, "__tmp_mat4", MutableMatrix44.identity());
    __publicField(_SkeletalComponent, "__tmp_q", MutableQuaternion.fromCopy4(0, 0, 0, 1));
    __publicField(_SkeletalComponent, "__identityMat", MutableMatrix44.identity());
    SkeletalComponent = _SkeletalComponent;
  }
});

// src/foundation/importer/RhodoniteImportExtension.ts
function createEffekseerAnimation(entity, effect) {
  const effekseerComponent = entity.getComponentByComponentTID(WellKnownComponentTIDs.EffekseerComponentTID);
  if (Is.exist(effekseerComponent)) {
    effekseerComponent.playJustAfterLoaded = true;
    effekseerComponent.isLoop = true;
    if (Is.exist(effect.timelines)) {
      const timelines = effect.timelines;
      for (const timeline of timelines) {
        const values = timeline.values;
        const timelineName = timeline.name;
        const timelineValues = values.map((value) => {
          return {
            input: value.input,
            event: value.event
          };
        });
        let animationComponent = entity.tryToGetAnimation();
        let animationEntity;
        if (Is.not.exist(animationComponent)) {
          animationEntity = EntityRepository.addComponentToEntity(AnimationComponent, entity);
        }
        animationComponent = animationEntity.getAnimation();
        animationComponent.setAnimation(Is.exist(timelineName) ? timelineName : "Default", "effekseer", new Float32Array(timelineValues.map((value) => value.input)), new Float32Array(timelineValues.map((value) => {
          if (value.event === "play") {
            return 1;
          } else if (value.event === "pause") {
            return 0;
          } else {
            return 0;
          }
        })), 1, AnimationInterpolation.Step, true);
      }
    }
  }
}
var _RhodoniteImportExtension, RhodoniteImportExtension;
var init_RhodoniteImportExtension = __esm({
  "src/foundation/importer/RhodoniteImportExtension.ts"() {
    "use strict";
    init_EffekseerComponent();
    init_components2();
    init_EntityRepository();
    init_definitions();
    init_DataUtil();
    init_Is();
    init_Logger();
    _RhodoniteImportExtension = class _RhodoniteImportExtension {
      static importBillboard(gltfJson, groups) {
        const RHODONITE_billboard = "RHODONITE_billboard";
        if (Is.not.exist(gltfJson.extensionsUsed) || gltfJson.extensionsUsed.findIndex((extension) => {
          return RHODONITE_billboard === extension;
        }) === -1) {
          return;
        }
        for (const node_i in gltfJson.nodes) {
          const group = groups[node_i];
          const nodeJson = gltfJson.nodes[node_i];
          const sceneGraphComponent = group.getSceneGraph();
          if (nodeJson.extensions !== void 0) {
            if (nodeJson.extensions.RHODONITE_billboard !== void 0) {
              if (nodeJson.extensions.RHODONITE_billboard.isBillboard === true) {
                sceneGraphComponent.isBillboard = true;
              }
            }
          }
        }
      }
      static importEffect(gltfJson, rootGroup) {
        const RHODONITE_effekseer = "RHODONITE_effekseer";
        if (Is.not.exist(gltfJson.extensions) || Is.not.exist(gltfJson.extensions.RHODONITE_effekseer) || gltfJson.extensionsUsed.findIndex((extension) => {
          return RHODONITE_effekseer === extension;
        }) === -1) {
          return;
        }
        const entities = rootGroup.getTagValue("rnEntities");
        const effects = gltfJson.extensions.RHODONITE_effekseer.effects;
        for (const effect of effects) {
          const entity = entities[effect.node];
          const effekseerEntity = EntityRepository.addComponentToEntity(EffekseerComponent, entity);
          const effekseerComponent = effekseerEntity.getEffekseer();
          effekseerComponent.playJustAfterLoaded = true;
          effekseerComponent.isLoop = true;
          if (Is.exist(effect.bufferView)) {
            const rnm2Buffer = gltfJson.buffers[0];
            rnm2Buffer.bufferPromise.then((arrayBufferOfBuffer) => {
              const imageUint8Array = DataUtil.createUint8ArrayFromBufferViewInfo(gltfJson, effect.bufferView, arrayBufferOfBuffer);
              effekseerComponent.arrayBuffer = imageUint8Array.buffer.slice(imageUint8Array.byteOffset, imageUint8Array.byteOffset + imageUint8Array.byteLength);
              effekseerComponent.type = "efkpkg";
            });
          } else if (Is.exist(effect.uri)) {
            effekseerComponent.uri = effect.uri;
            effekseerComponent.type = "efk";
          } else {
            Logger.error("No real effect data.");
          }
          createEffekseerAnimation(effekseerEntity, effect);
        }
      }
    };
    __name(_RhodoniteImportExtension, "RhodoniteImportExtension");
    __publicField(_RhodoniteImportExtension, "__instance");
    RhodoniteImportExtension = _RhodoniteImportExtension;
    __name(createEffekseerAnimation, "createEffekseerAnimation");
  }
});

// src/foundation/components/AnimationState/AnimationStateComponent.ts
var _AnimationStateComponent, AnimationStateComponent;
var init_AnimationStateComponent = __esm({
  "src/foundation/components/AnimationState/AnimationStateComponent.ts"() {
    "use strict";
    init_Component();
    init_EntityRepository();
    init_ProcessStage();
    init_WellKnownComponentTIDs();
    _AnimationStateComponent = class _AnimationStateComponent extends Component {
      constructor(entityUid, componentSid, entityComponent, isReUse) {
        super(entityUid, componentSid, entityComponent, isReUse);
        __publicField(this, "__activeAnimationTrack", "");
        __publicField(this, "__interpolationStartTime", performance.now());
        __publicField(this, "__blendingDuration", 1);
        __publicField(this, "__isBlending", false);
        __publicField(this, "__blendingRatio", 0);
        this.moveStageTo(ProcessStage.Logic);
      }
      static get componentTID() {
        return WellKnownComponentTIDs.AnimationStateComponentTID;
      }
      get componentTID() {
        return WellKnownComponentTIDs.AnimationStateComponentTID;
      }
      get isBlending() {
        return this.__isBlending;
      }
      get blendingRatio() {
        return this.__blendingRatio;
      }
      $logic() {
        if (!this.__isBlending) {
          return;
        }
        const elapsedTime = (performance.now() - this.__interpolationStartTime) / 1e3;
        const blendingTime = elapsedTime / this.__blendingDuration;
        if (blendingTime >= 1) {
          this.__isBlending = false;
        }
        const ratio = Math.min(blendingTime, 1);
        this.setAnimationBlendingRatio(ratio);
        this.__blendingRatio = ratio;
      }
      setFirstActiveAnimationTrack(trackName) {
        this.__activeAnimationTrack = trackName;
        this.setActiveAnimationTrack(trackName);
        this.setAnimationBlendingRatio(0);
        this.__isBlending = false;
      }
      forceTransitionTo(trackName, duration) {
        const prevTrack = this.__activeAnimationTrack;
        this.setActiveAnimationTrack(prevTrack);
        this.setSecondActiveAnimationTrack(trackName);
        this.__interpolationStartTime = performance.now();
        this.__blendingDuration = duration;
        this.__activeAnimationTrack = trackName;
        this.__isBlending = true;
      }
      setActiveAnimationTrack(animationTrackName) {
        function processRecursively(entity) {
          const anim = entity.tryToGetAnimation();
          if (anim != null) {
            anim.setActiveAnimationTrack(animationTrackName);
          }
          for (const child of entity.children) {
            processRecursively(child.entity);
          }
        }
        __name(processRecursively, "processRecursively");
        processRecursively(this.entity);
      }
      setSecondActiveAnimationTrack(animationTrackName) {
        function processRecursively(entity) {
          const anim = entity.tryToGetAnimation();
          if (anim != null) {
            anim.setSecondActiveAnimationTrack(animationTrackName);
          }
          for (const child of entity.children) {
            processRecursively(child.entity);
          }
        }
        __name(processRecursively, "processRecursively");
        processRecursively(this.entity);
      }
      setUseGlobalTime(flg) {
        function processRecursively(entity) {
          const anim = entity.tryToGetAnimation();
          if (anim != null) {
            anim.useGlobalTime = flg;
          }
          for (const child of entity.children) {
            processRecursively(child.entity);
          }
        }
        __name(processRecursively, "processRecursively");
        processRecursively(this.entity);
      }
      setIsLoop(flg) {
        function processRecursively(entity) {
          const anim = entity.tryToGetAnimation();
          if (anim != null) {
            anim.isLoop = flg;
          }
          for (const child of entity.children) {
            processRecursively(child.entity);
          }
        }
        __name(processRecursively, "processRecursively");
        processRecursively(this.entity);
      }
      setTime(time) {
        function processRecursively(entity) {
          const anim = entity.tryToGetAnimation();
          if (anim != null) {
            anim.time = time;
          }
          for (const child of entity.children) {
            processRecursively(child.entity);
          }
        }
        __name(processRecursively, "processRecursively");
        processRecursively(this.entity);
      }
      setAnimationBlendingRatio(ratio) {
        function processRecursively(entity) {
          const anim = entity.tryToGetAnimation();
          if (anim != null) {
            anim.animationBlendingRatio = ratio;
          }
          for (const child of entity.children) {
            processRecursively(child.entity);
          }
        }
        __name(processRecursively, "processRecursively");
        processRecursively(this.entity);
      }
      _destroy() {
        super._destroy();
      }
      /**
      * get the entity which has this component.
      * @returns the entity which has this component
      */
      get entity() {
        return EntityRepository.getEntity(this.__entityUid);
      }
      /**
      * @override
      * Add this component to the entity
      * @param base the target entity
      * @param _componentClass the component class to add
      */
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let BlendShapeEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
          }
          getAnimationState() {
            return this.getComponentByComponentTID(WellKnownComponentTIDs.AnimationStateComponentTID);
          }
        }, __name(_a40, "BlendShapeEntity"), _a40);
        applyMixins(base, BlendShapeEntity);
        return base;
      }
    };
    __name(_AnimationStateComponent, "AnimationStateComponent");
    AnimationStateComponent = _AnimationStateComponent;
  }
});

// src/foundation/components/Light/createLightEntity.ts
function createLightEntity() {
  const entity = createGroupEntity();
  const entityAddedComponent = EntityRepository.tryToAddComponentToEntityByTID(WellKnownComponentTIDs.LightComponentTID, entity);
  return entityAddedComponent;
}
var init_createLightEntity = __esm({
  "src/foundation/components/Light/createLightEntity.ts"() {
    "use strict";
    init_EntityRepository();
    init_createGroupEntity();
    init_WellKnownComponentTIDs();
    __name(createLightEntity, "createLightEntity");
  }
});

// src/foundation/importer/ModelConverter.ts
function setupMToon1(material, gltfModel, materialJson) {
  const mToon = materialJson.extensions.VRMC_materials_mtoon;
  {
    const shadeColorFactor = mToon.shadeColorFactor;
    material.setParameter("shadeColorFactor", Vector3.fromCopyArray3(shadeColorFactor));
  }
  {
    const shadeMultiplyTexture = mToon.shadeMultiplyTexture;
    if (shadeMultiplyTexture != null) {
      const rnTexture = ModelConverter._createTexture(shadeMultiplyTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(shadeMultiplyTexture.texture);
      material.setTextureParameter("shadeMultiplyTexture", rnTexture, rnSampler);
      if (shadeMultiplyTexture.texCoord != null) {
        material.setParameter("shadeMultiplyTexcoordIndex", shadeMultiplyTexture.texCoord);
      }
    }
  }
  {
    const shadingShiftFactor = mToon.shadingShiftFactor;
    if (shadingShiftFactor != null) {
      material.setParameter("shadingShiftFactor", shadingShiftFactor);
    }
  }
  {
    const shadingShiftTexture = mToon.shadingShiftTexture;
    if (shadingShiftTexture != null) {
      const rnTexture = ModelConverter._createTexture(shadingShiftTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(shadingShiftTexture.texture);
      material.setTextureParameter("shadingShiftTexture", rnTexture, rnSampler);
      if (shadingShiftTexture.texCoord != null) {
        material.setParameter("shadingShiftTexcoordIndex", shadingShiftTexture.texCoord);
      }
      const shadingShiftTextureScale = shadingShiftTexture.scale;
      if (shadingShiftTextureScale != null) {
        material.setParameter("shadingShiftTextureScale", shadingShiftTextureScale);
      }
    }
  }
  {
    const shadingToonyFactor = mToon.shadingToonyFactor;
    if (shadingToonyFactor != null) {
      material.setParameter("shadingToonyFactor", shadingToonyFactor);
    }
  }
  {
    const giEqualizationFactor = mToon.giEqualizationFactor;
    if (giEqualizationFactor != null) {
      material.setParameter("giEqualizationFactor", giEqualizationFactor);
    }
  }
  {
    const matcapTexture = mToon.matcapTexture;
    if (matcapTexture != null) {
      const rnTexture = ModelConverter._createTexture(matcapTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(matcapTexture.texture);
      material.setTextureParameter("matcapTexture", rnTexture, rnSampler);
      if (matcapTexture.texCoord != null) {
        material.setParameter("matcapTexcoordIndex", matcapTexture.texCoord);
      }
    }
  }
  {
    const matcapFactor = mToon.matcapFactor;
    if (matcapFactor != null) {
      material.setParameter("matcapFactor", Vector3.fromCopyArray3(matcapFactor));
    }
  }
  {
    const parametricRimColorFactor = mToon.parametricRimColorFactor;
    if (parametricRimColorFactor != null) {
      material.setParameter("parametricRimColorFactor", Vector3.fromCopyArray3(parametricRimColorFactor));
    }
  }
  {
    const parametricRimFresnelPowerFactor = mToon.parametricRimFresnelPowerFactor;
    if (parametricRimFresnelPowerFactor != null) {
      material.setParameter("parametricRimFresnelPowerFactor", parametricRimFresnelPowerFactor);
    }
  }
  {
    const parametricRimLiftFactor = mToon.parametricRimLiftFactor;
    if (parametricRimLiftFactor != null) {
      material.setParameter("parametricRimLiftFactor", parametricRimLiftFactor);
    }
  }
  {
    const rimMultiplyTexture = mToon.rimMultiplyTexture;
    if (rimMultiplyTexture != null) {
      const rnTexture = ModelConverter._createTexture(rimMultiplyTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(rimMultiplyTexture.texture);
      material.setTextureParameter("rimMultiplyTexture", rnTexture, rnSampler);
      if (rimMultiplyTexture.texCoord != null) {
        material.setParameter("rimMultiplyTexcoordIndex", rimMultiplyTexture.texCoord);
      }
    }
  }
  {
    const rimLightingMixFactor = mToon.rimLightingMixFactor;
    if (rimLightingMixFactor != null) {
      material.setParameter("rimLightingMixFactor", rimLightingMixFactor);
    }
  }
  {
    const outlineWidthMode = mToon.outlineWidthMode;
    if (outlineWidthMode != null) {
      if (outlineWidthMode === "none") {
        material.setParameter("outlineWidthMode", 0);
      } else if (outlineWidthMode === "worldCoordinates") {
        material.setParameter("outlineWidthMode", 1);
      } else if (outlineWidthMode === "screenCoordinates") {
        material.setParameter("outlineWidthMode", 2);
      }
    }
  }
  {
    const outlineWidthFactor = mToon.outlineWidthFactor;
    if (outlineWidthFactor != null) {
      material.setParameter("outlineWidthFactor", outlineWidthFactor);
    }
  }
  {
    const outlineWidthMultiplyTexture = mToon.outlineWidthMultiplyTexture;
    if (outlineWidthMultiplyTexture != null) {
      const rnTexture = ModelConverter._createTexture(outlineWidthMultiplyTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(outlineWidthMultiplyTexture.texture);
      material.setTextureParameter("outlineWidthMultiplyTexture", rnTexture, rnSampler);
    }
  }
  {
    const outlineColorFactor = mToon.outlineColorFactor;
    if (outlineColorFactor != null) {
      material.setParameter("outlineColorFactor", Vector3.fromCopyArray3(outlineColorFactor));
    }
  }
  {
    const outlineLightingMixFactor = mToon.outlineLightingMixFactor;
    if (outlineLightingMixFactor != null) {
      material.setParameter("outlineLightingMixFactor", outlineLightingMixFactor);
    }
  }
  {
    const uvAnimationMaskTexture = mToon.uvAnimationMaskTexture;
    if (uvAnimationMaskTexture != null) {
      const rnTexture = ModelConverter._createTexture(uvAnimationMaskTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(uvAnimationMaskTexture.texture);
      material.setTextureParameter("uvAnimationMaskTexture", rnTexture, rnSampler);
      if (uvAnimationMaskTexture.texCoord != null) {
        material.setParameter("uvAnimationMaskTexcoordIndex", uvAnimationMaskTexture.texCoord);
      }
    }
  }
  {
    const uvAnimationScrollXSpeedFactor = mToon.uvAnimationScrollXSpeedFactor;
    if (uvAnimationScrollXSpeedFactor != null) {
      material.setParameter("uvAnimationScrollXSpeedFactor", uvAnimationScrollXSpeedFactor);
    }
  }
  {
    const uvAnimationScrollYSpeedFactor = mToon.uvAnimationScrollYSpeedFactor;
    if (uvAnimationScrollYSpeedFactor != null) {
      material.setParameter("uvAnimationScrollYSpeedFactor", uvAnimationScrollYSpeedFactor);
    }
  }
  {
    const uvAnimationRotationSpeedFactor = mToon.uvAnimationRotationSpeedFactor;
    if (uvAnimationRotationSpeedFactor != null) {
      material.setParameter("uvAnimationRotationSpeedFactor", uvAnimationRotationSpeedFactor);
    }
  }
}
function setupPbrMetallicRoughness(pbrMetallicRoughness, material, gltfModel, options, materialJson) {
  var _a40;
  const isUnlit = ((_a40 = materialJson.extensions) == null ? void 0 : _a40.KHR_materials_unlit) != null;
  const baseColorFactor = pbrMetallicRoughness.baseColorFactor;
  if (baseColorFactor != null) {
    material.setParameter("baseColorFactor", Vector4.fromCopyArray4(baseColorFactor));
  }
  const baseColorTexture = pbrMetallicRoughness.baseColorTexture;
  if (baseColorTexture != null) {
    const rnTexture = ModelConverter._createTexture(baseColorTexture.texture, gltfModel, {
      autoDetectTransparency: options == null ? void 0 : options.autoDetectTextureTransparency
    });
    const rnSampler = ModelConverter._createSampler(baseColorTexture.texture);
    material.setTextureParameter("baseColorTexture", rnTexture, rnSampler);
    if (baseColorTexture.texCoord != null) {
      material.setParameter("baseColorTexcoordIndex", baseColorTexture.texCoord);
    }
    ModelConverter._setupTextureTransform(baseColorTexture, material, "baseColorTextureTransform", "baseColorTextureRotation");
  }
  const occlusionTexture = materialJson.occlusionTexture;
  if (occlusionTexture != null && Is.falsy(isUnlit)) {
    const rnTexture = ModelConverter._createTexture(occlusionTexture.texture, gltfModel);
    const rnSampler = ModelConverter._createSampler(occlusionTexture.texture);
    material.setTextureParameter("occlusionTexture", rnTexture, rnSampler);
    if (occlusionTexture.texCoord != null) {
      material.setParameter("occlusionTexcoordIndex", occlusionTexture.texCoord);
    }
    if (occlusionTexture.strength != null) {
      material.setParameter("occlusionStrength", occlusionTexture.strength);
    }
    ModelConverter._setupTextureTransform(occlusionTexture, material, "occlusionTextureTransform", "occlusionTextureRotation");
  }
  let metallicFactor = pbrMetallicRoughness.metallicFactor;
  metallicFactor = isUnlit ? 0 : metallicFactor != null ? metallicFactor : 1;
  let roughnessFactor = pbrMetallicRoughness.roughnessFactor;
  roughnessFactor = isUnlit ? 1 : roughnessFactor != null ? roughnessFactor : 1;
  material.setParameter("metallicRoughnessFactor", Vector2.fromCopyArray2([
    metallicFactor,
    roughnessFactor
  ]));
  const metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;
  if (metallicRoughnessTexture != null && Is.falsy(isUnlit)) {
    const rnTexture = ModelConverter._createTexture(metallicRoughnessTexture.texture, gltfModel);
    const rnSampler = ModelConverter._createSampler(metallicRoughnessTexture.texture);
    material.setTextureParameter("metallicRoughnessTexture", rnTexture, rnSampler);
    if (metallicRoughnessTexture.texCoord != null) {
      material.setParameter("metallicRoughnessTexcoordIndex", metallicRoughnessTexture.texCoord);
    }
    ModelConverter._setupTextureTransform(metallicRoughnessTexture, material, "metallicRoughnessTextureTransform", "metallicRoughnessTextureRotation");
  }
  setup_KHR_materials_clearcoat(materialJson, material, gltfModel);
  const transmission = setup_KHR_materials_transmission(materialJson, material, gltfModel);
  if (!options.transmission) {
    options.transmission = transmission;
  }
  setup_KHR_materials_volume(materialJson, material, gltfModel);
  setup_KHR_materials_sheen(materialJson, material, gltfModel);
  setup_KHR_materials_specular(materialJson, material, gltfModel);
  setup_KHR_materials_ior(materialJson, material, gltfModel);
  setup_KHR_materials_iridescence(materialJson, material, gltfModel);
  setup_KHR_materials_anisotropy(materialJson, material, gltfModel);
  setup_KHR_materials_emissive_strength(materialJson, material, gltfModel);
}
function setup_KHR_materials_transmission(materialJson, material, gltfModel) {
  var _a40;
  const KHR_materials_transmission = (_a40 = materialJson.extensions) == null ? void 0 : _a40.KHR_materials_transmission;
  if (Is.exist(KHR_materials_transmission)) {
    const transmissionFactor = Is.exist(KHR_materials_transmission.transmissionFactor) ? KHR_materials_transmission.transmissionFactor : 0;
    material.setParameter("transmissionFactor", transmissionFactor);
    const transmissionTexture = KHR_materials_transmission.transmissionTexture;
    if (Is.exist(transmissionTexture)) {
      const rnTransmissionTexture = ModelConverter._createTexture(transmissionTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(transmissionTexture.texture);
      material.setTextureParameter("transmissionTexture", rnTransmissionTexture, rnSampler);
    }
    return true;
  }
  return false;
}
function setup_KHR_materials_clearcoat(materialJson, material, gltfModel) {
  var _a40;
  const KHR_materials_clearcoat = (_a40 = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _a40.KHR_materials_clearcoat;
  if (Is.exist(KHR_materials_clearcoat)) {
    const clearCoatFactor = Is.exist(KHR_materials_clearcoat.clearcoatFactor) ? KHR_materials_clearcoat.clearcoatFactor : 0;
    material.setParameter("clearCoatFactor", clearCoatFactor);
    const clearCoatTexture = KHR_materials_clearcoat.clearcoatTexture;
    if (clearCoatTexture != null) {
      const rnClearCoatTexture = ModelConverter._createTexture(clearCoatTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(clearCoatTexture.texture);
      material.setTextureParameter("clearCoatTexture", rnClearCoatTexture, rnSampler);
      if (clearCoatTexture.texCoord != null) {
        material.setParameter("clearCoatTexcoordIndex", clearCoatTexture.texCoord);
      }
      ModelConverter._setupTextureTransform(clearCoatTexture, material, "clearCoatTextureTransform", "clearCoatTextureRotation");
    }
    const clearCoatRoughnessFactor = Is.exist(KHR_materials_clearcoat.clearcoatRoughnessFactor) ? KHR_materials_clearcoat.clearcoatRoughnessFactor : 0;
    material.setParameter("clearCoatRoughnessFactor", clearCoatRoughnessFactor);
    const clearCoatRoughnessTexture = KHR_materials_clearcoat.clearcoatRoughnessTexture;
    if (clearCoatRoughnessTexture != null) {
      const rnClearCoatRoughnessTexture = ModelConverter._createTexture(clearCoatRoughnessTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(clearCoatRoughnessTexture.texture);
      material.setTextureParameter("clearCoatRoughnessTexture", rnClearCoatRoughnessTexture, rnSampler);
      if (clearCoatRoughnessTexture.texCoord != null) {
        material.setParameter("clearCoatRoughnessTexcoordIndex", clearCoatRoughnessTexture.texCoord);
      }
      ModelConverter._setupTextureTransform(clearCoatRoughnessTexture, material, "clearCoatRoughnessTextureTransform", "clearCoatRoughnessTextureRotation");
    }
    const clearCoatNormalTexture = KHR_materials_clearcoat.clearcoatNormalTexture;
    if (clearCoatNormalTexture != null) {
      const rnClearCoatNormalTexture = ModelConverter._createTexture(clearCoatNormalTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(clearCoatNormalTexture.texture);
      material.setTextureParameter("clearCoatNormalTexture", rnClearCoatNormalTexture, rnSampler);
      if (clearCoatNormalTexture.texCoord != null) {
        material.setParameter("clearCoatNormalTexcoordIndex", clearCoatNormalTexture.texCoord);
      }
      ModelConverter._setupTextureTransform(clearCoatNormalTexture, material, "clearCoatNormalTextureTransform", "clearCoatNormalTextureRotation");
    }
  }
}
function setup_KHR_materials_volume(materialJson, material, gltfModel) {
  var _a40;
  const KHR_materials_volume = (_a40 = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _a40.KHR_materials_volume;
  if (Is.exist(KHR_materials_volume)) {
    const thicknessFactor = KHR_materials_volume.thicknessFactor ? KHR_materials_volume.thicknessFactor : 0;
    if (thicknessFactor != null) {
      material.setParameter("thicknessFactor", thicknessFactor);
    }
    const thicknessTexture = KHR_materials_volume.thicknessTexture;
    if (thicknessTexture != null) {
      const rnThicknessTexture = ModelConverter._createTexture(thicknessTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(thicknessTexture.texture);
      material.setTextureParameter("thicknessTexture", rnThicknessTexture, rnSampler);
    }
    const attenuationDistance = KHR_materials_volume.attenuationDistance ? KHR_materials_volume.attenuationDistance : 0;
    if (attenuationDistance != null) {
      material.setParameter("attenuationDistance", attenuationDistance);
    }
    const attenuationColor = KHR_materials_volume.attenuationColor ? Vector3.fromCopyArray3(KHR_materials_volume.attenuationColor) : Vector3.fromCopy3(1, 1, 1);
    if (attenuationColor != null) {
      material.setParameter("attenuationColor", attenuationColor);
    }
  }
}
function setup_KHR_materials_sheen(materialJson, material, gltfModel) {
  var _a40;
  const KHR_materials_sheen = (_a40 = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _a40.KHR_materials_sheen;
  if (Is.exist(KHR_materials_sheen)) {
    const sheenColorFactor = Is.exist(KHR_materials_sheen.sheenColorFactor) ? KHR_materials_sheen.sheenColorFactor : [
      0,
      0,
      0
    ];
    material.setParameter("sheenColorFactor", Vector3.fromCopyArray3(sheenColorFactor));
    const sheenColorTexture = KHR_materials_sheen.sheenColorTexture;
    if (sheenColorTexture != null) {
      const rnSheenColorTexture = ModelConverter._createTexture(sheenColorTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(sheenColorTexture.texture);
      material.setTextureParameter("sheenColorTexture", rnSheenColorTexture, rnSampler);
    }
    const sheenRoughnessFactor = Is.exist(KHR_materials_sheen.sheenRoughnessFactor) ? KHR_materials_sheen.sheenRoughnessFactor : 0;
    material.setParameter("sheenRoughnessFactor", sheenRoughnessFactor);
    const sheenRoughnessTexture = KHR_materials_sheen.sheenRoughnessTexture;
    if (sheenRoughnessTexture != null) {
      const rnSheenRoughnessTexture = ModelConverter._createTexture(sheenRoughnessTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(sheenRoughnessTexture.texture);
      material.setTextureParameter("sheenRoughnessTexture", rnSheenRoughnessTexture, rnSampler);
    }
  }
}
function setup_KHR_materials_specular(materialJson, material, gltfModel) {
  var _a40;
  const KHR_materials_specular = (_a40 = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _a40.KHR_materials_specular;
  if (Is.exist(KHR_materials_specular)) {
    const specularFactor = Is.exist(KHR_materials_specular.specularFactor) ? KHR_materials_specular.specularFactor : 1;
    material.setParameter("specularFactor", specularFactor);
    const specularTexture = KHR_materials_specular.specularTexture;
    if (specularTexture != null) {
      const rnSpecularTexture = ModelConverter._createTexture(specularTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(specularTexture.texture);
      material.setTextureParameter("specularTexture", rnSpecularTexture, rnSampler);
    }
    const SpecularColorFactor2 = Is.exist(KHR_materials_specular.specularColorFactor) ? KHR_materials_specular.specularColorFactor : [
      1,
      1,
      1
    ];
    material.setParameter("specularColorFactor", Vector3.fromCopyArray3(SpecularColorFactor2));
    const SpecularColorTexture2 = KHR_materials_specular.specularColorTexture;
    if (SpecularColorTexture2 != null) {
      const rnSpecularColorTexture = ModelConverter._createTexture(SpecularColorTexture2.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(SpecularColorTexture2.texture);
      material.setTextureParameter("specularColorTexture", rnSpecularColorTexture, rnSampler);
    }
  }
}
function setup_KHR_materials_ior(materialJson, material, gltfModel) {
  var _a40;
  const KHR_materials_ior = (_a40 = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _a40.KHR_materials_ior;
  if (Is.exist(KHR_materials_ior)) {
    const ior = Is.exist(KHR_materials_ior.ior) ? KHR_materials_ior.ior : 1.5;
    material.setParameter("ior", ior);
  }
}
function setup_KHR_materials_iridescence(materialJson, material, gltfModel) {
  var _a40;
  const KHR_materials_iridescence = (_a40 = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _a40.KHR_materials_iridescence;
  if (Is.exist(KHR_materials_iridescence)) {
    const iridescenceFactor = Is.exist(KHR_materials_iridescence.iridescenceFactor) ? KHR_materials_iridescence.iridescenceFactor : 0;
    material.setParameter("iridescenceFactor", iridescenceFactor);
    const iridescenceTexture = KHR_materials_iridescence.iridescenceTexture;
    if (iridescenceTexture != null) {
      const rnIridescenceTexture = ModelConverter._createTexture(iridescenceTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(iridescenceTexture.texture);
      material.setTextureParameter("iridescenceTexture", rnIridescenceTexture, rnSampler);
    }
    const iridescenceIor = Is.exist(KHR_materials_iridescence.iridescenceIor) ? KHR_materials_iridescence.iridescenceIor : 1.3;
    material.setParameter("iridescenceIor", iridescenceIor);
    const iridescenceThicknessMinimum = Is.exist(KHR_materials_iridescence.iridescenceThicknessMinimum) ? KHR_materials_iridescence.iridescenceThicknessMinimum : 100;
    material.setParameter("iridescenceThicknessMinimum", iridescenceThicknessMinimum);
    const iridescenceThicknessMaximum = Is.exist(KHR_materials_iridescence.iridescenceThicknessMaximum) ? KHR_materials_iridescence.iridescenceThicknessMaximum : 400;
    material.setParameter("iridescenceThicknessMaximum", iridescenceThicknessMaximum);
    const iridescenceThicknessTexture = KHR_materials_iridescence.iridescenceThicknessTexture;
    if (iridescenceThicknessTexture != null) {
      const rnIridescenceThicknessTexture = ModelConverter._createTexture(iridescenceThicknessTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(iridescenceThicknessTexture.texture);
      material.setTextureParameter("iridescenceThicknessTexture", rnIridescenceThicknessTexture, rnSampler);
    }
  }
}
function setup_KHR_materials_anisotropy(materialJson, material, gltfModel) {
  var _a40;
  const KHR_materials_anisotropy = (_a40 = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _a40.KHR_materials_anisotropy;
  if (Is.exist(KHR_materials_anisotropy)) {
    const anisotropyStrength = Is.exist(KHR_materials_anisotropy.anisotropyStrength) ? KHR_materials_anisotropy.anisotropyStrength : 0;
    material.setParameter("anisotropyStrength", anisotropyStrength);
    const anisotropyRotation = Is.exist(KHR_materials_anisotropy.anisotropyRotation) ? KHR_materials_anisotropy.anisotropyRotation : 0;
    material.setParameter("anisotropyRotation", Vector2.fromCopy2(Math.cos(anisotropyRotation), Math.sin(anisotropyRotation)));
    const anisotropyTexture = KHR_materials_anisotropy.anisotropyTexture;
    if (anisotropyTexture != null) {
      const rnAnisotropyTexture = ModelConverter._createTexture(anisotropyTexture.texture, gltfModel);
      const rnSampler = ModelConverter._createSampler(anisotropyTexture.texture);
      material.setTextureParameter("anisotropyTexture", rnAnisotropyTexture, rnSampler);
    }
  }
}
function setup_KHR_materials_emissive_strength(materialJson, material, gltfModel) {
  var _a40;
  const KHR_materials_emissive_strength = (_a40 = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _a40.KHR_materials_emissive_strength;
  if (Is.exist(KHR_materials_emissive_strength)) {
    const emissiveStrength = Is.exist(KHR_materials_emissive_strength.emissiveStrength) ? KHR_materials_emissive_strength.emissiveStrength : 1;
    material.setParameter("emissiveStrength", emissiveStrength);
  }
}
var _ModelConverter, ModelConverter;
var init_ModelConverter = __esm({
  "src/foundation/importer/ModelConverter.ts"() {
    "use strict";
    init_EntityRepository();
    init_MeshComponent();
    init_Vector3();
    init_Quaternion();
    init_Matrix44();
    init_Primitive();
    init_Buffer();
    init_PrimitiveMode();
    init_CompositionType();
    init_ComponentType();
    init_VertexAttribute();
    init_CameraType();
    init_Texture();
    init_Vector4();
    init_AnimationComponent();
    init_AnimationInterpolation();
    init_MathUtil();
    init_SkeletalComponent();
    init_AlphaMode();
    init_MaterialHelper();
    init_Vector2();
    init_ShadingModel();
    init_Mesh();
    init_MutableVector4();
    init_LightType();
    init_Config();
    init_BufferUse();
    init_MemoryManager();
    init_Scalar();
    init_TextureParameter();
    init_CGAPIResourceRepository();
    init_Is();
    init_DataUtil();
    init_glTF2();
    init_BlendShapeComponent();
    init_LightComponent();
    init_RhodoniteImportExtension();
    init_Sampler();
    init_AnimationStateComponent();
    init_createGroupEntity();
    init_createMeshEntity();
    init_createLightEntity();
    init_createCameraEntity();
    init_Logger();
    _ModelConverter = class _ModelConverter {
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      constructor() {
      }
      static __generateGroupEntity(gltfModel) {
        const entity = createGroupEntity();
        this.addTags(entity, gltfModel);
        return entity;
      }
      static addTags(entity, gltfModel) {
        entity.tryToSetTag({
          tag: "SourceType",
          value: gltfModel.asset.extras.fileType
        });
        entity.tryToSetTag({
          tag: "SourceTypeVersion",
          value: gltfModel.asset.extras.version
        });
      }
      static __generateMeshEntity(gltfModel) {
        const entity = createMeshEntity();
        this.addTags(entity, gltfModel);
        return entity;
      }
      static __generateCameraEntity(gltfModel) {
        const entity = createCameraEntity();
        this.addTags(entity, gltfModel);
        return entity;
      }
      static __generateLightEntity(gltfModel) {
        const entity = createLightEntity();
        this.addTags(entity, gltfModel);
        return entity;
      }
      static __setupMaterials(gltfModel) {
        const rnMaterials = [];
        if (gltfModel.materials != null) {
          for (const material of gltfModel.materials) {
            const rnMaterial = this.__setupMaterial(gltfModel, material);
            rnMaterials.push(rnMaterial);
          }
        }
        return rnMaterials;
      }
      static convertToRhodoniteObject(gltfModel) {
        var _a40;
        gltfModel.asset.extras.rnMeshesAtGltMeshIdx = [];
        const rnBuffers = this.createRnBuffer(gltfModel);
        gltfModel.asset.extras.rnMaterials = {};
        const rnMaterials = this.__setupMaterials(gltfModel);
        const { rnEntities, rnEntitiesByNames } = this.__setupObjects(gltfModel, rnBuffers, rnMaterials);
        gltfModel.asset.extras.rnEntities = rnEntities;
        this._setupTransform(gltfModel, rnEntities);
        const rootGroup = this.__generateGroupEntity(gltfModel);
        this._setupAnimation(gltfModel, rnEntities, rnBuffers, rootGroup);
        this._setupSkeleton(gltfModel, rnEntities, rnBuffers);
        this._setupHierarchy(gltfModel, rnEntities);
        rootGroup.tryToSetUniqueName("FileRoot", true);
        rootGroup.tryToSetTag({
          tag: "ObjectType",
          value: "top"
        });
        if (gltfModel.scenes[0].nodes) {
          for (const nodesIndex of gltfModel.scenes[0].nodes) {
            const sg = rnEntities[nodesIndex].getSceneGraph();
            rootGroup.getSceneGraph().addChild(sg);
          }
        }
        if (gltfModel.asset.extras && gltfModel.asset.extras.rnLoaderOptions) {
          const options = gltfModel.asset.extras.rnLoaderOptions;
          if (options && options.loaderExtension && ((_a40 = options == null ? void 0 : options.loaderExtension) == null ? void 0 : _a40.loadExtensionInfoAndSetToRootGroup)) {
            options.loaderExtension.loadExtensionInfoAndSetToRootGroup(rootGroup, gltfModel);
          }
          if (options && options.expression) {
            options.expression.tryToSetTag({
              tag: "gltfModel",
              value: gltfModel
            });
          }
        }
        rootGroup.tryToSetTag({
          tag: "rnEntities",
          value: rnEntities
        });
        rootGroup.tryToSetTag({
          tag: "rnEntitiesByNames",
          value: rnEntitiesByNames
        });
        rootGroup.tryToSetTag({
          tag: "gltfModel",
          value: gltfModel
        });
        if (Is.not.exist(gltfModel.extras)) {
          gltfModel.extras = {};
        }
        gltfModel.extras.rnEntities = rnEntities;
        gltfModel.extras.rnEntitiesByNames = rnEntitiesByNames;
        RhodoniteImportExtension.importEffect(gltfModel, rootGroup);
        RhodoniteImportExtension.importBillboard(gltfModel, rnEntities);
        if (Is.exist(gltfModel.extensionsUsed)) {
          if (gltfModel.extensionsUsed.indexOf("VRMC_vrm") > 0) {
          }
        }
        return rootGroup;
      }
      static createRnBuffer(gltfModel) {
        const rnBuffers = [];
        for (const buffer of gltfModel.buffers) {
          const rnBuffer = new Buffer2({
            byteLength: buffer.byteLength,
            buffer: buffer.buffer,
            name: `gltf2Buffer_0_(${buffer.uri})`,
            byteAlign: 4
          });
          rnBuffers.push(rnBuffer);
        }
        return rnBuffers;
      }
      static _setupTransform(gltfModel, groups) {
        for (const node_i in gltfModel.nodes) {
          const group = groups[node_i];
          const nodeJson = gltfModel.nodes[node_i];
          const groupTransform = group.getTransform();
          if (nodeJson.translation) {
            groupTransform.localPosition = Vector3.fromCopyArray([
              nodeJson.translation[0],
              nodeJson.translation[1],
              nodeJson.translation[2]
            ]);
          }
          if (nodeJson.scale) {
            groupTransform.localScale = Vector3.fromCopyArray([
              nodeJson.scale[0],
              nodeJson.scale[1],
              nodeJson.scale[2]
            ]);
          }
          if (nodeJson.rotation) {
            groupTransform.localRotation = Quaternion.fromCopy4(nodeJson.rotation[0], nodeJson.rotation[1], nodeJson.rotation[2], nodeJson.rotation[3]);
          }
          if (nodeJson.matrix) {
            groupTransform.localMatrix = Matrix44.fromCopyArrayColumnMajor(nodeJson.matrix);
          }
        }
      }
      static _setupHierarchy(gltfModel, rnEntities) {
        const groupSceneComponents = rnEntities.map((group) => {
          return group.getSceneGraph();
        });
        for (const node_i in gltfModel.nodes) {
          const parentNode_i = parseInt(node_i);
          const glTF2ParentNode = gltfModel.nodes[parentNode_i];
          if (Is.exist(glTF2ParentNode.children)) {
            const rnParentSceneGraphComponent = groupSceneComponents[parentNode_i];
            for (const childNode_i of glTF2ParentNode.children) {
              const rnChildSceneGraphComponent = groupSceneComponents[childNode_i];
              rnParentSceneGraphComponent.addChild(rnChildSceneGraphComponent);
            }
          }
        }
      }
      /**
      * @internal
      */
      static _setupAnimation(gltfModel, rnEntities, rnBuffers, rootGroup) {
        var _a40;
        if (gltfModel.animations == null || gltfModel.animations.length === 0) {
          return;
        }
        const newRootGroup = EntityRepository.addComponentToEntity(AnimationStateComponent, rootGroup);
        for (const animation of gltfModel.animations) {
          for (const sampler of animation.samplers) {
            this._readBinaryFromAccessorAndSetItToAccessorExtras(sampler.inputObject, rnBuffers);
            this._readBinaryFromAccessorAndSetItToAccessorExtras(sampler.outputObject, rnBuffers);
          }
        }
        for (const animation of gltfModel.animations) {
          for (const channel of animation.channels) {
            if (Is.exist(channel.samplerObject)) {
              const animInputArray = channel.samplerObject.inputObject.extras.typedDataArray;
              const animOutputArray = channel.samplerObject.outputObject.extras.typedDataArray;
              const interpolation = (_a40 = channel.samplerObject.interpolation) != null ? _a40 : "LINEAR";
              let animationAttributeType = "undefined";
              if (channel.target.path === "translation") {
                animationAttributeType = "translate";
              } else if (channel.target.path === "rotation") {
                animationAttributeType = "quaternion";
              } else {
                animationAttributeType = channel.target.path;
              }
              const rnEntity = rnEntities[channel.target.node];
              if (Is.exist(rnEntity)) {
                let animationComponent = rnEntity.tryToGetAnimation();
                if (Is.not.exist(animationComponent)) {
                  const newRnEntity = EntityRepository.addComponentToEntity(AnimationComponent, rnEntity);
                  animationComponent = newRnEntity.getAnimation();
                }
                if (Is.exist(animationComponent)) {
                  const outputComponentN = channel.samplerObject.outputObject.extras.componentN;
                  animationComponent.setAnimation(Is.exist(animation.name) ? animation.name : "Untitled_Animation", animationAttributeType, animInputArray, animOutputArray, outputComponentN, AnimationInterpolation.fromString(interpolation));
                }
              }
            }
          }
        }
      }
      static _setupSkeleton(gltfModel, rnEntities, rnBuffers) {
        if (gltfModel.skins == null) {
          return;
        }
        for (const node_i in gltfModel.nodes) {
          const node = gltfModel.nodes[node_i];
          const sg = rnEntities[node_i].getSceneGraph();
          let skeletalComponent;
          if (Is.exist(node.skinObject)) {
            const rnEntity = rnEntities[node_i];
            const newRnEntity = EntityRepository.addComponentToEntity(SkeletalComponent, rnEntity);
            skeletalComponent = newRnEntity.getSkeletal();
            if (Is.exist(node.skinObject.bindShapeMatrix)) {
              skeletalComponent._bindShapeMatrix = Matrix44.fromCopyArrayColumnMajor(node.skinObject.bindShapeMatrix);
            }
            if (Is.exist(node.skinObject.skeleton)) {
              sg.isRootJoint = true;
              if (Is.exist(node.mesh)) {
                const joints = [];
                for (const i2 of node.skinObject.joints) {
                  joints.push(rnEntities[i2].getSceneGraph());
                }
                skeletalComponent.setJoints(joints);
                if (Is.exist(node.skinObject.skeleton)) {
                  skeletalComponent.topOfJointsHierarchy = rnEntities[node.skinObject.skeleton].getSceneGraph();
                } else {
                  skeletalComponent.topOfJointsHierarchy = joints[0];
                }
              }
            }
            for (const joint_i of node.skinObject.joints) {
              const sg2 = rnEntities[joint_i].getSceneGraph();
              sg2.jointIndex = joint_i;
            }
            const inverseBindMatAccessor = node.skinObject.inverseBindMatricesObject;
            if (Is.exist(inverseBindMatAccessor)) {
              const rnBufferOfInverseBindMatAccessor = this.__getRnBufferViewAndRnAccessor(inverseBindMatAccessor, rnBuffers);
              skeletalComponent.setInverseBindMatricesAccessor(rnBufferOfInverseBindMatAccessor);
            }
          }
        }
      }
      static __setupObjects(gltfModel, rnBuffers, rnMaterials) {
        var _a40, _b, _c, _d, _e;
        const rnEntities = [];
        const rnEntitiesByNames = /* @__PURE__ */ new Map();
        for (const node_i in gltfModel.nodes) {
          const node = gltfModel.nodes[parseInt(node_i)];
          let entity;
          if (node.mesh != null) {
            const meshIdx = node.mesh;
            const meshEntity = this.__setupMesh(node.meshObject, meshIdx, rnBuffers, gltfModel, rnMaterials);
            if (node.name) {
              meshEntity.tryToSetUniqueName(node.name, true);
            }
            if ((_a40 = node.meshObject) == null ? void 0 : _a40.name) {
              const meshComponent = meshEntity.getComponent(MeshComponent);
              meshComponent.tryToSetUniqueName(node.meshObject.name, true);
            }
            entity = meshEntity;
          } else if (node.cameraObject != null) {
            const cameraEntity = this.__setupCamera(node.cameraObject, gltfModel);
            if (node.name) {
              cameraEntity.tryToSetUniqueName(node.name, true);
            }
            entity = cameraEntity;
          } else if ((_b = node.extensions) == null ? void 0 : _b.KHR_lights_punctual) {
            const lightEntity = this.__setupLight(node.extensions.KHR_lights_punctual.light, gltfModel);
            entity = lightEntity;
          } else {
            const group = this.__generateGroupEntity(gltfModel);
            if (node.name) {
              group.tryToSetUniqueName(node.name, true);
            }
            entity = group;
          }
          if (this.__isMorphing(node, gltfModel)) {
            let weights = [];
            if (node.weights) {
              weights = node.weights;
            } else if ((_c = node.meshObject) == null ? void 0 : _c.weights) {
              weights = node.meshObject.weights;
            } else {
              let targetNum = 0;
              for (const primitive of node.meshObject.primitives) {
                if (Is.exist(primitive.targets)) {
                  if (primitive.targets.length > targetNum) {
                    targetNum = primitive.targets.length;
                  }
                }
              }
              weights = new Array(targetNum).fill(0);
            }
            entity = EntityRepository.addComponentToEntity(BlendShapeComponent, entity);
            const blendShapeComponent = entity.getBlendShape();
            blendShapeComponent.weights = weights;
            if ((_e = (_d = node.meshObject) == null ? void 0 : _d.primitives[0].extras) == null ? void 0 : _e.targetNames) {
              blendShapeComponent.targetNames = node.meshObject.primitives[0].extras.targetNames;
            }
          }
          entity.tryToSetTag({
            tag: TagGltf2NodeIndex,
            value: node_i
          });
          rnEntities.push(entity);
          rnEntitiesByNames.set(node.name, entity);
        }
        return {
          rnEntities,
          rnEntitiesByNames
        };
      }
      static __isMorphing(node, gltfModel) {
        var _a40, _b, _c;
        const argument = (_b = (_a40 = gltfModel.asset.extras) == null ? void 0 : _a40.rnLoaderOptions) == null ? void 0 : _b.defaultMaterialHelperArgumentArray[0];
        if ((argument == null ? void 0 : argument.isMorphing) === false) {
          return false;
        } else {
          return ((_c = node.meshObject) == null ? void 0 : _c.primitives[0].targets) != null;
        }
      }
      static __setupLight(light, gltfModel) {
        var _a40, _b;
        const lightEntity = this.__generateLightEntity(gltfModel);
        const lightComponent = lightEntity.getComponent(LightComponent);
        if (light.name != null) {
          lightComponent.tryToSetUniqueName(light.name, true);
          lightComponent.type = LightType.fromString(light.type);
          let color = Vector3.fromCopyArray3([
            1,
            1,
            1
          ]);
          let intensity = 1;
          if (light.color != null) {
            color = Vector3.fromCopyArray3(light.color);
          }
          if (light.intensity != null) {
            intensity = light.intensity;
          }
          lightComponent.intensity = Vector3.multiply(color, intensity);
          if (light.range != null) {
            lightComponent.range = light.range;
          }
          if (light.type === "spot") {
            if (((_a40 = light.spot) == null ? void 0 : _a40.innerConeAngle) != null) {
              lightComponent.innerConeAngle = light.spot.innerConeAngle;
            }
            if (((_b = light.spot) == null ? void 0 : _b.outerConeAngle) != null) {
              lightComponent.outerConeAngle = light.spot.outerConeAngle;
            }
          }
        }
        return lightEntity;
      }
      static __setupCamera(camera, gltfModel) {
        const cameraEntity = this.__generateCameraEntity(gltfModel);
        const cameraComponent = cameraEntity.getCamera();
        cameraComponent.direction = Vector3.fromCopyArray([
          0,
          0,
          -1
        ]);
        if (gltfModel.asset && gltfModel.asset.LastSaved_ApplicationVendor) {
          cameraComponent.direction = Vector3.fromCopyArray([
            1,
            0,
            0
          ]);
          cameraComponent.directionInner = Vector3.fromCopyArray([
            1,
            0,
            0
          ]);
        }
        cameraComponent.up = Vector3.fromCopyArray([
          0,
          1,
          0
        ]);
        cameraComponent.type = CameraType.fromString(camera.type);
        if (cameraComponent.type === CameraType.Perspective) {
          cameraComponent.aspect = camera.perspective.aspectRatio ? camera.perspective.aspectRatio : 1;
          cameraComponent.setFovyAndChangeFocalLength(MathUtil.radianToDegree(camera.perspective.yfov));
          cameraComponent.zNear = camera.perspective.znear;
          cameraComponent.zFar = camera.perspective.zfar ? camera.perspective.zfar : 1e5;
          cameraComponent.tryToSetTag({
            tag: "OriginalFovY",
            value: cameraComponent.fovy
          });
        } else if (cameraComponent.type === CameraType.Orthographic) {
          cameraComponent.xMag = camera.orthographic.xmag;
          cameraComponent.yMag = camera.orthographic.ymag;
          cameraComponent.zNear = camera.orthographic.znear;
          cameraComponent.zFar = camera.orthographic.zfar;
          cameraComponent.tryToSetTag({
            tag: "OriginalXMag",
            value: cameraComponent.xMag
          });
          cameraComponent.tryToSetTag({
            tag: "OriginalYMag",
            value: cameraComponent.yMag
          });
        }
        cameraComponent.tryToSetTag({
          tag: "OriginalAspect",
          value: cameraComponent.aspect
        });
        return cameraEntity;
      }
      static __setupMesh(mesh, meshIndex, rnBuffers, gltfModel, rnMaterials) {
        var _a40, _b, _c, _d, _e;
        const meshEntity = this.__generateMeshEntity(gltfModel);
        const existingRnMesh = (_a40 = gltfModel.asset.extras.rnMeshesAtGltMeshIdx[meshIndex]) == null ? void 0 : _a40.deref();
        let rnPrimitiveMode = PrimitiveMode.Triangles;
        const meshComponent = meshEntity.getMesh();
        if (existingRnMesh != null) {
          meshComponent.setMesh(existingRnMesh);
        } else {
          const rnMesh = new Mesh();
          const rnLoaderOptions = gltfModel.asset.extras.rnLoaderOptions;
          if ((rnLoaderOptions == null ? void 0 : rnLoaderOptions.tangentCalculationMode) != null) {
            rnMesh.tangentCalculationMode = rnLoaderOptions.tangentCalculationMode;
          }
          const setupMaterialVariants = /* @__PURE__ */ __name((rnPrimitive, primitive) => {
            const materialVariants = primitive.materialVariants;
            if (Is.not.exist(materialVariants)) {
              return;
            }
            for (const materialVariant of materialVariants) {
              const material = rnMaterials[materialVariant.material];
              for (const variantName of materialVariant.variants) {
                rnPrimitive.setMaterialVariant(variantName, material);
              }
            }
          }, "setupMaterialVariants");
          for (const i2 in mesh.primitives) {
            const primitive = mesh.primitives[i2];
            if (primitive.mode != null) {
              rnPrimitiveMode = PrimitiveMode.from(primitive.mode);
            }
            const rnPrimitive = new Primitive();
            const rnMaterial = primitive.material != null ? rnMaterials[primitive.material] : this.__setupMaterial(gltfModel);
            setupMaterialVariants(rnPrimitive, primitive);
            if (rnMaterial.materialTypeName.indexOf("MToon") !== -1) {
              const VRMProperties = gltfModel.extensions.VRM;
              if ((VRMProperties == null ? void 0 : VRMProperties.rnExtension) != null) {
                const rnExtension = VRMProperties.rnExtension;
                const renderPassOutline = rnExtension.renderPassOutline;
                const outlineMaterial = (_d = (_c = (_b = primitive.materialObject) == null ? void 0 : _b.extras) == null ? void 0 : _c.outlineMaterial) == null ? void 0 : _d.deref();
                if (outlineMaterial != null) {
                  renderPassOutline.setMaterialForPrimitive(outlineMaterial, rnPrimitive);
                  rnPrimitive.setMaterialVariant("outline", outlineMaterial);
                }
              }
            }
            let indicesRnAccessor;
            const map = /* @__PURE__ */ new Map();
            if ((_e = primitive.extensions) == null ? void 0 : _e.KHR_draco_mesh_compression) {
              indicesRnAccessor = this.__decodeDraco(primitive, rnBuffers, gltfModel, map);
              if (Is.not.exist(indicesRnAccessor)) {
                break;
              }
            } else {
              if (Is.exist(primitive.indices)) {
                indicesRnAccessor = this.__getRnBufferViewAndRnAccessor(primitive.indicesObject, rnBuffers);
              }
              const rnBufferViewMap = /* @__PURE__ */ new Map();
              for (const attributeName in primitive.attributesObjects) {
                const rnm2attribute = primitive.attributesObjects[attributeName];
                const rnBuffer = rnBuffers[rnm2attribute.bufferViewObject.buffer];
                let rnBufferView;
                if (Is.exist(rnm2attribute.bufferView)) {
                  rnBufferView = rnBufferViewMap.get(rnm2attribute.bufferView);
                  if (Is.not.exist(rnBufferView)) {
                    rnBufferView = this.__getRnBufferView(rnm2attribute.bufferViewObject, rnBuffer);
                    rnBufferViewMap.set(rnm2attribute.bufferView, rnBufferView);
                  }
                } else {
                  rnBufferView = rnBuffer.takeBufferView({
                    byteLengthToNeed: 0,
                    byteStride: 0
                  }).unwrapForce();
                }
                const attributeRnAccessor = this.__getRnAccessor(rnm2attribute, rnBufferView);
                const joinedString = VertexAttribute.toVertexAttributeSemanticJoinedStringAsGltfStyle(VertexAttribute.fromString(rnm2attribute.extras.attributeName));
                map.set(joinedString, attributeRnAccessor);
              }
            }
            rnPrimitive.setData(map, rnPrimitiveMode, rnMaterial, indicesRnAccessor);
            if (primitive.targets != null) {
              let maxMorphTargetNumber2 = Config.maxMorphTargetNumber;
              if ((rnLoaderOptions == null ? void 0 : rnLoaderOptions.maxMorphTargetNumber) != null) {
                maxMorphTargetNumber2 = rnLoaderOptions.maxMorphTargetNumber;
              }
              const targets = [];
              for (let i3 = 0; i3 < primitive.targetsObjects.length; i3++) {
                if (i3 >= maxMorphTargetNumber2) {
                  break;
                }
                const target = primitive.targetsObjects[i3];
                const targetMap = /* @__PURE__ */ new Map();
                for (const attributeName in target) {
                  const attributeAccessor = target[attributeName];
                  const attributeRnAccessor = this.__getRnBufferViewAndRnAccessor(attributeAccessor, rnBuffers);
                  const attributeRnAccessorInGPUVertexData = this.__copyRnAccessorAndBufferView(attributeRnAccessor);
                  const vertexAttribute = VertexAttribute.fromString(attributeName);
                  const joinedString = VertexAttribute.toVertexAttributeSemanticJoinedStringAsGltfStyle(vertexAttribute);
                  targetMap.set(joinedString, attributeRnAccessorInGPUVertexData);
                }
                targets.push(targetMap);
              }
              rnPrimitive.setBlendShapeTargets(targets);
            }
            rnMesh.addPrimitive(rnPrimitive);
          }
          meshComponent.setMesh(rnMesh);
          gltfModel.asset.extras.rnMeshesAtGltMeshIdx[meshIndex] = new WeakRef(rnMesh);
        }
        return meshEntity;
      }
      static setSparseAccessor(accessor, rnAccessor) {
        var _a40, _b, _c, _d;
        const count = accessor.sparse.count;
        const sparseIndices = accessor.sparse.indices;
        const indicesBufferView = sparseIndices.bufferViewObject;
        let buffer = sparseIndices.bufferViewObject.bufferObject.buffer;
        const byteOffsetBufferViewAndSparseIndices = ((_a40 = indicesBufferView.byteOffset) != null ? _a40 : 0) + ((_b = sparseIndices.byteOffset) != null ? _b : 0);
        const componentBytesIndices = this._checkBytesPerComponent(sparseIndices);
        const byteLengthIndices = componentBytesIndices * count;
        const dataViewIndices = new DataView(buffer.buffer, byteOffsetBufferViewAndSparseIndices + buffer.byteOffset, byteLengthIndices);
        const dataViewMethodIndices = this._checkDataViewMethod(sparseIndices);
        const sparseValues = accessor.sparse.values;
        const valueBufferView = sparseValues.bufferViewObject;
        buffer = sparseValues.bufferViewObject.bufferObject.buffer;
        const byteOffsetBufferViewAndAccessorValues = ((_c = valueBufferView.byteOffset) != null ? _c : 0) + ((_d = sparseValues.byteOffset) != null ? _d : 0);
        const componentBytesValues = this._checkBytesPerComponent(accessor);
        const componentNValues = this._checkComponentNumber(accessor);
        const byteLengthValues = componentBytesValues * componentNValues * count;
        const dataViewValues = new DataView(buffer.buffer, byteOffsetBufferViewAndAccessorValues + buffer.byteOffset, byteLengthValues);
        const dataViewMethodValues = this._checkDataViewMethod(accessor);
        const typedArray = rnAccessor.getTypedArray();
        const littleEndian = true;
        for (let i2 = 0; i2 < count; i2++) {
          const index = dataViewIndices[dataViewMethodIndices](componentBytesIndices * i2, littleEndian);
          for (let j = 0; j < componentNValues; j++) {
            const value = dataViewValues[dataViewMethodValues](componentBytesValues * componentNValues * i2 + componentBytesValues * j, littleEndian);
            typedArray[index * componentNValues + j] = value;
          }
        }
      }
      static __setVRM1Material(gltfModel, materialJson, rnLoaderOptions) {
        var _a40;
        const VRMProperties = gltfModel.extensions.VRM;
        const VRMC_materials_mtoon = (_a40 = materialJson.extensions) == null ? void 0 : _a40.VRMC_materials_mtoon;
        if (VRMC_materials_mtoon != null) {
          const defaultMaterialHelperArgument = rnLoaderOptions.defaultMaterialHelperArgumentArray[0];
          const additionalName = defaultMaterialHelperArgument.additionalName;
          const isMorphing = true;
          const isSkinning = true;
          const isLighting = this.__isLighting(gltfModel, materialJson);
          const useTangentAttribute = true;
          const textures = defaultMaterialHelperArgument.textures;
          const samplers = defaultMaterialHelperArgument.samplers;
          const debugMode = defaultMaterialHelperArgument.debugMode;
          const maxInstancesNumber = defaultMaterialHelperArgument.maxInstancesNumber;
          const makeOutputSrgb = this.__makeOutputSrgb(gltfModel);
          let renderPassOutline;
          if (Is.exist(VRMProperties == null ? void 0 : VRMProperties.rnExtension)) {
            const rnExtension = VRMProperties.rnExtension;
            renderPassOutline = rnExtension.renderPassOutline;
            renderPassOutline.isVrRendering = true;
            renderPassOutline.tryToSetUniqueName("VRM Outline RenderPass", true);
          }
          if (renderPassOutline != null) {
            let outlineMaterial;
            if (VRMC_materials_mtoon.outlineWidthMode !== "none") {
              outlineMaterial = MaterialHelper.createMToon1Material({
                additionalName,
                isMorphing,
                isSkinning,
                isLighting,
                useTangentAttribute,
                isOutline: true,
                materialJson,
                textures,
                samplers,
                debugMode,
                maxInstancesNumber,
                makeOutputSrgb
              });
            }
            if (Is.exist(outlineMaterial)) {
              materialJson.extras.outlineMaterial = new WeakRef(outlineMaterial);
            }
          }
          const material = MaterialHelper.createMToon1Material({
            additionalName,
            isMorphing,
            isSkinning,
            isLighting,
            useTangentAttribute,
            isOutline: false,
            materialJson,
            textures,
            samplers,
            debugMode,
            maxInstancesNumber,
            makeOutputSrgb
          });
          materialJson.extensions.KHR_materials_unlit = void 0;
          return material;
        }
        return void 0;
      }
      static setMToonTextures(textures, materialProperties, material, samplers) {
        const litColorTexture = textures[materialProperties.textureProperties._MainTex];
        if (litColorTexture != null) {
          material.setTextureParameter("litColorTexture", litColorTexture, samplers[materialProperties.textureProperties._MainTex]);
        }
        const shadeColorTexture = textures[materialProperties.textureProperties._ShadeTexture];
        if (shadeColorTexture != null) {
          material.setTextureParameter("shadeColorTexture", shadeColorTexture, samplers[materialProperties.textureProperties._ShadeTexture]);
        }
        const receiveShadowTexture = textures[materialProperties.textureProperties._ReceiveShadowTexture];
        if (receiveShadowTexture != null) {
          material.setTextureParameter("receiveShadowTexture", receiveShadowTexture, samplers[materialProperties.textureProperties._ReceiveShadowTexture]);
        }
        const shadingGradeTexture = textures[materialProperties.textureProperties._ShadingGradeTexture];
        if (shadingGradeTexture != null) {
          material.setTextureParameter("shadingGradeTexture", shadingGradeTexture, samplers[materialProperties.textureProperties._ShadingGradeTexture]);
        }
        const rimTexture = textures[materialProperties.textureProperties._RimTexture];
        if (rimTexture != null) {
          material.setTextureParameter("rimTexture", rimTexture, samplers[materialProperties.textureProperties._RimTexture]);
        }
        const matCapTexture = textures[materialProperties.textureProperties._SphereAdd];
        if (matCapTexture != null) {
          material.setTextureParameter("matCapTexture", matCapTexture, samplers[materialProperties.textureProperties._SphereAdd]);
        }
        const emissionTexture = textures[materialProperties.textureProperties._EmissionMap];
        if (emissionTexture != null) {
          material.setTextureParameter("emissionTexture", emissionTexture, samplers[materialProperties.textureProperties._EmissionMap]);
        }
        const normalTexture = textures[materialProperties.textureProperties._BumpMap];
        if (normalTexture != null) {
          material.setTextureParameter("normalTexture", normalTexture, samplers[materialProperties.textureProperties._BumpMap]);
        }
        const outlineWidthTexture = textures[materialProperties.textureProperties._OutlineWidthTexture];
        if (outlineWidthTexture != null) {
          material.setTextureParameter("outlineWidthTexture", outlineWidthTexture, samplers[materialProperties.textureProperties._OutlineWidthTexture]);
        }
        const uvAnimationMaskTexture = textures[materialProperties.textureProperties._UvAnimMaskTexture];
        if (uvAnimationMaskTexture != null) {
          material.setTextureParameter("uvAnimationMaskTexture", uvAnimationMaskTexture, samplers[materialProperties.textureProperties._UvAnimMaskTexture]);
        }
      }
      static __setVRM0xMaterial(gltfModel, materialJson, rnLoaderOptions) {
        const VRMProperties = gltfModel.extensions.VRM;
        const materialProperties = materialJson.extras.vrm0xMaterialProperty;
        const shaderName = materialProperties.shader;
        if (shaderName === "VRM/MToon") {
          const defaultMaterialHelperArgument = rnLoaderOptions.defaultMaterialHelperArgumentArray[0];
          const additionalName = defaultMaterialHelperArgument.additionalName;
          const isMorphing = true;
          const isSkinning = true;
          const isLighting = this.__isLighting(gltfModel, materialJson);
          const useTangentAttribute = true;
          const textures = defaultMaterialHelperArgument.textures;
          const samplers = defaultMaterialHelperArgument.samplers;
          const debugMode = defaultMaterialHelperArgument.debugMode;
          const maxInstancesNumber = defaultMaterialHelperArgument.maxInstancesNumber;
          const makeOutputSrgb = this.__makeOutputSrgb(gltfModel);
          let renderPassOutline;
          if (Is.exist(VRMProperties == null ? void 0 : VRMProperties.rnExtension)) {
            const rnExtension = VRMProperties.rnExtension;
            renderPassOutline = rnExtension.renderPassOutline;
            renderPassOutline.isVrRendering = true;
            renderPassOutline.tryToSetUniqueName("VRM Outline RenderPass", true);
          }
          if (renderPassOutline != null) {
            let outlineMaterial;
            if (materialProperties.floatProperties._OutlineWidthMode !== 0) {
              outlineMaterial = MaterialHelper.createMToon0xMaterial({
                additionalName,
                isMorphing,
                isSkinning,
                isLighting,
                useTangentAttribute,
                isOutline: true,
                materialProperties,
                textures,
                samplers,
                debugMode,
                maxInstancesNumber,
                makeOutputSrgb
              });
            }
            if (Is.exist(outlineMaterial)) {
              _ModelConverter.setMToonTextures(textures, materialProperties, outlineMaterial, samplers);
              materialJson.extras.outlineMaterial = new WeakRef(outlineMaterial);
            }
          }
          const material = MaterialHelper.createMToon0xMaterial({
            additionalName,
            isMorphing,
            isSkinning,
            isLighting,
            useTangentAttribute,
            isOutline: false,
            materialProperties,
            textures,
            samplers,
            debugMode,
            maxInstancesNumber,
            makeOutputSrgb
          });
          _ModelConverter.setMToonTextures(textures, materialProperties, material, samplers);
          return material;
        }
        return void 0;
      }
      static __generateAppropriateMaterial(gltfModel, materialJson) {
        var _a40, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
        const isTranslucent2 = Is.exist((_a40 = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _a40.KHR_materials_transmission);
        if (((_b = gltfModel.asset.extras) == null ? void 0 : _b.rnLoaderOptions) != null) {
          const rnLoaderOptions = gltfModel.asset.extras.rnLoaderOptions;
          if (((_c = rnLoaderOptions.loaderExtension) == null ? void 0 : _c.isNeededToUseThisMaterial) != null && rnLoaderOptions.loaderExtension.isNeededToUseThisMaterial(gltfModel)) {
            const loaderExtension = (_e = (_d = gltfModel.asset.extras) == null ? void 0 : _d.rnLoaderOptions) == null ? void 0 : _e.loaderExtension;
            if ((loaderExtension == null ? void 0 : loaderExtension.generateMaterial) != null) {
              return loaderExtension.generateMaterial(materialJson);
            }
          }
          if (rnLoaderOptions.__isImportVRM0x) {
            const material = this.__setVRM0xMaterial(gltfModel, materialJson, rnLoaderOptions);
            if (Is.exist(material)) {
              material.isTranslucent = isTranslucent2;
              return material;
            }
          }
          const materialHelperName = rnLoaderOptions.defaultMaterialHelperName;
          if (materialHelperName != null) {
            return MaterialHelper[materialHelperName](...rnLoaderOptions.defaultMaterialHelperArgumentArray);
          }
        }
        const isMorphing = true;
        const isSkinning = true;
        const isLighting = this.__isLighting(gltfModel, materialJson);
        const additionalName = "";
        if (Is.exist(materialJson)) {
          if (((_f = materialJson.extensions) == null ? void 0 : _f.VRMC_materials_mtoon) != null) {
            const rnLoaderOptions = gltfModel.asset.extras.rnLoaderOptions;
            const material = this.__setVRM1Material(gltfModel, materialJson, rnLoaderOptions);
            if (Is.exist(material)) {
              material.isTranslucent = isTranslucent2;
              return material;
            }
          }
        }
        const maxMaterialInstanceNumber = Config.maxMaterialInstanceForEachType;
        if (parseFloat((_g = gltfModel.asset) == null ? void 0 : _g.version) >= 2) {
          const rnLoaderOptions = (_i = (_h = gltfModel.asset.extras) == null ? void 0 : _h.rnLoaderOptions) != null ? _i : {};
          const useTangentAttribute = true;
          const useNormalTexture = this.__useNormalTexture(gltfModel);
          const material = MaterialHelper.createPbrUberMaterial({
            isMorphing,
            isSkinning,
            isLighting,
            isClearCoat: Is.exist((_j = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _j.KHR_materials_clearcoat),
            isTransmission: Is.exist((_k = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _k.KHR_materials_transmission),
            isVolume: Is.exist((_l = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _l.KHR_materials_volume),
            isSheen: Is.exist((_m = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _m.KHR_materials_sheen),
            isSpecular: Is.exist((_n = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _n.KHR_materials_specular),
            isIridescence: Is.exist((_o = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _o.KHR_materials_iridescence),
            isAnisotropy: Is.exist((_p = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _p.KHR_materials_anisotropy),
            isShadow: rnLoaderOptions.shadow ? true : false,
            useTangentAttribute,
            useNormalTexture,
            additionalName,
            maxInstancesNumber: maxMaterialInstanceNumber
          });
          const makeOutputSrgb = this.__makeOutputSrgb(gltfModel);
          if (Is.exist(makeOutputSrgb)) {
            material.setParameter("makeOutputSrgb", makeOutputSrgb);
          }
          material.isTranslucent = isTranslucent2;
          return material;
        } else {
          const material = MaterialHelper.createClassicUberMaterial({
            isSkinning,
            isLighting,
            additionalName,
            maxInstancesNumber: maxMaterialInstanceNumber
          });
          material.isTranslucent = isTranslucent2;
          return material;
        }
      }
      static __isLighting(gltfModel, materialJson) {
        var _a40, _b, _c, _d;
        const argument = (_c = (_b = (_a40 = gltfModel == null ? void 0 : gltfModel.asset) == null ? void 0 : _a40.extras) == null ? void 0 : _b.rnLoaderOptions) == null ? void 0 : _c.defaultMaterialHelperArgumentArray[0];
        if ((argument == null ? void 0 : argument.isLighting) != null) {
          return argument.isLighting;
        } else {
          return ((_d = materialJson == null ? void 0 : materialJson.extensions) == null ? void 0 : _d.KHR_materials_unlit) != null ? false : true;
        }
      }
      // private static __isSkinning(node: RnM2Node, gltfModel: RnM2) {
      //   const argument =
      //     gltfModel?.asset?.extras?.rnLoaderOptions?.defaultMaterialHelperArgumentArray![0];
      //   if (argument?.isSkinning === false) {
      //     return false;
      //   } else {
      //     return node.skin != null;
      //   }
      // }
      static __useTangentAttribute(gltfModel, primitive) {
        var _a40, _b, _c;
        const tangentCalculationMode = (_c = (_b = (_a40 = gltfModel == null ? void 0 : gltfModel.asset) == null ? void 0 : _a40.extras) == null ? void 0 : _b.rnLoaderOptions) == null ? void 0 : _c.tangentCalculationMode;
        switch (tangentCalculationMode) {
          case 0:
            return false;
          case 1:
            break;
          case 2:
            return true;
          case 3:
            return false;
          case 4:
            return true;
          default:
        }
        for (const attribute in primitive.attributes) {
          if (attribute === "TANGENT") {
            return true;
          }
        }
        return false;
      }
      static __useNormalTexture(gltfModel) {
        var _a40, _b, _c, _d, _e, _f;
        const argument = (_c = (_b = (_a40 = gltfModel == null ? void 0 : gltfModel.asset) == null ? void 0 : _a40.extras) == null ? void 0 : _b.rnLoaderOptions) == null ? void 0 : _c.defaultMaterialHelperArgumentArray[0];
        if ((argument == null ? void 0 : argument.useNormalTexture) === false) {
          return false;
        } else {
          return ((_f = (_e = (_d = gltfModel == null ? void 0 : gltfModel.asset) == null ? void 0 : _d.extras) == null ? void 0 : _e.rnLoaderOptions) == null ? void 0 : _f.tangentCalculationMode) !== 0;
        }
      }
      static __makeOutputSrgb(gltfModel) {
        var _a40, _b, _c;
        const argument = (_c = (_b = (_a40 = gltfModel == null ? void 0 : gltfModel.asset) == null ? void 0 : _a40.extras) == null ? void 0 : _b.rnLoaderOptions) == null ? void 0 : _c.defaultMaterialHelperArgumentArray[0];
        return argument == null ? void 0 : argument.makeOutputSrgb;
      }
      static __setupMaterial(gltfModel, materialJson) {
        var _a40;
        const material = this.__generateAppropriateMaterial(gltfModel, materialJson);
        if (materialJson == null) return material;
        _ModelConverter.setParametersToMaterial(materialJson, gltfModel, material, false);
        if (((_a40 = materialJson.extras) == null ? void 0 : _a40.outlineMaterial) != null) {
          _ModelConverter.setParametersToMaterial(materialJson, gltfModel, materialJson.extras.outlineMaterial.deref(), true);
        }
        return material;
      }
      static setParametersToMaterial(materialJson, gltfModel, material, isOutline) {
        var _a40, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        const isUnlit = ((_a40 = materialJson.extensions) == null ? void 0 : _a40.KHR_materials_unlit) != null;
        const options = gltfModel.asset.extras.rnLoaderOptions;
        const pbrMetallicRoughness = materialJson.pbrMetallicRoughness;
        if (pbrMetallicRoughness != null) {
          setupPbrMetallicRoughness(pbrMetallicRoughness, material, gltfModel, options, materialJson);
        } else {
          let param = ShadingModel2.Phong.index;
          if ((_b = materialJson == null ? void 0 : materialJson.extras) == null ? void 0 : _b.technique) {
            switch (materialJson.extras.technique) {
              case ShadingModel2.Constant.str:
                param = ShadingModel2.Constant.index;
                break;
              case ShadingModel2.Lambert.str:
                param = ShadingModel2.Lambert.index;
                break;
              case ShadingModel2.BlinnPhong.str:
                param = ShadingModel2.BlinnPhong.index;
                break;
              case ShadingModel2.Phong.str:
                param = ShadingModel2.Phong.index;
                break;
            }
            material.setParameter("shadingModel", Scalar2.fromCopyNumber(param));
          }
        }
        const emissiveFactor = isUnlit ? [
          0,
          0,
          0
        ] : materialJson.emissiveFactor;
        if (emissiveFactor != null) {
          material.setParameter("emissiveFactor", Vector3.fromCopyArray3(emissiveFactor));
        }
        const emissiveTexture = materialJson.emissiveTexture;
        if (emissiveTexture != null && Is.falsy(isUnlit)) {
          const rnTexture = _ModelConverter._createTexture(emissiveTexture.texture, gltfModel);
          const rnSampler = _ModelConverter._createSampler(emissiveTexture.texture);
          material.setTextureParameter("emissiveTexture", rnTexture, rnSampler);
          if (parseFloat((_c = gltfModel.asset) == null ? void 0 : _c.version) >= 2 && emissiveTexture.texCoord != null) {
            material.setParameter("emissiveTexcoordIndex", emissiveTexture.texCoord);
          }
          _ModelConverter._setupTextureTransform(emissiveTexture, material, "emissiveTextureTransform", "emissiveTextureRotation");
        }
        let alphaMode = materialJson.alphaMode;
        if (options == null ? void 0 : options.alphaMode) {
          alphaMode = options.alphaMode;
        }
        if (alphaMode != null) {
          material.alphaMode = AlphaMode.fromGlTFString(alphaMode);
          if (material.alphaMode === AlphaMode.Mask && !((_e = (_d = gltfModel.asset.extras) == null ? void 0 : _d.rnLoaderOptions) == null ? void 0 : _e.__isImportVRM0x)) {
            material.setParameter("alphaCutoff", Scalar2.fromCopyNumber((_f = materialJson.alphaCutoff) != null ? _f : 0.5));
          }
        }
        material.isTranslucent = Is.exist((_g = materialJson.extensions) == null ? void 0 : _g.KHR_materials_transmission);
        const doubleSided = materialJson.doubleSided;
        if (doubleSided != null && !isOutline) {
          material.cullFace = !doubleSided;
        }
        const normalTexture = materialJson.normalTexture;
        if (normalTexture != null && Is.falsy(isUnlit)) {
          const rnTexture = _ModelConverter._createTexture(normalTexture.texture, gltfModel);
          const rnSampler = _ModelConverter._createSampler(normalTexture.texture);
          material.setTextureParameter("normalTexture", rnTexture, rnSampler);
          if (parseFloat((_h = gltfModel.asset) == null ? void 0 : _h.version) >= 2) {
            if (normalTexture.texCoord != null) {
              material.setParameter("normalTexcoordIndex", normalTexture.texCoord);
            }
            if (normalTexture.scale != null) {
              material.setParameter("normalScale", normalTexture.scale);
            }
          }
        }
        _ModelConverter._setupTextureTransform(normalTexture, material, "normalTextureTransform", "normalTextureRotation");
        if (this._checkRnGltfLoaderOptionsExist(gltfModel)) {
          const loaderExtension = (_j = (_i = gltfModel.asset.extras) == null ? void 0 : _i.rnLoaderOptions) == null ? void 0 : _j.loaderExtension;
          if ((loaderExtension == null ? void 0 : loaderExtension.setupMaterial) != null) {
            loaderExtension.setupMaterial(gltfModel, materialJson, material);
          }
        }
        if (((_k = materialJson.extensions) == null ? void 0 : _k.VRMC_materials_mtoon) != null) {
          setupMToon1(material, gltfModel, materialJson);
        }
      }
      static _createSampler(texture) {
        var _a40, _b, _c, _d;
        const sampler = new Sampler({
          magFilter: Is.exist((_a40 = texture.samplerObject) == null ? void 0 : _a40.magFilter) ? TextureParameter.from(texture.samplerObject.magFilter) : TextureParameter.Linear,
          minFilter: Is.exist((_b = texture.samplerObject) == null ? void 0 : _b.minFilter) ? TextureParameter.from(texture.samplerObject.minFilter) : TextureParameter.Linear,
          wrapS: Is.exist((_c = texture.samplerObject) == null ? void 0 : _c.wrapS) ? TextureParameter.from(texture.samplerObject.wrapS) : TextureParameter.Repeat,
          wrapT: Is.exist((_d = texture.samplerObject) == null ? void 0 : _d.wrapT) ? TextureParameter.from(texture.samplerObject.wrapT) : TextureParameter.Repeat
        });
        sampler.create();
        return sampler;
      }
      static _createTexture(texture, gltfModel, { autoDetectTransparency = false } = {}) {
        var _a40, _b, _c, _d, _e, _f, _g, _h;
        const options = (_a40 = gltfModel.asset.extras) == null ? void 0 : _a40.rnLoaderOptions;
        const rnTexture = new Texture2();
        rnTexture.autoDetectTransparency = autoDetectTransparency;
        rnTexture.autoResize = (options == null ? void 0 : options.autoResizeTexture) === true;
        const textureOption = {
          magFilter: Is.exist((_b = texture.samplerObject) == null ? void 0 : _b.magFilter) ? TextureParameter.from(texture.samplerObject.magFilter) : TextureParameter.Linear,
          minFilter: Is.exist((_c = texture.samplerObject) == null ? void 0 : _c.minFilter) ? TextureParameter.from(texture.samplerObject.minFilter) : TextureParameter.Linear,
          wrapS: Is.exist((_d = texture.samplerObject) == null ? void 0 : _d.wrapS) ? TextureParameter.from(texture.samplerObject.wrapS) : TextureParameter.Repeat,
          wrapT: Is.exist((_e = texture.samplerObject) == null ? void 0 : _e.wrapT) ? TextureParameter.from(texture.samplerObject.wrapT) : TextureParameter.Repeat
        };
        const image = texture.image;
        if (image.image) {
          const imageElem = image.image;
          const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
          const isWebGL1 = !((_f = webglResourceRepository.currentWebGLContextWrapper) == null ? void 0 : _f.isWebGL2);
          if (isWebGL1 && !this.__sizeIsPowerOfTwo(imageElem) && this.__needResizeToPowerOfTwoOnWebGl1(textureOption)) {
            rnTexture.autoResize = true;
          }
          rnTexture.generateTextureFromImage(imageElem);
          rnTexture.loadFromImgLazy();
        } else if (image.basis) {
          rnTexture.generateTextureFromBasis(image.basis, {});
        } else if (image.ktx2) {
          rnTexture.generateTextureFromKTX2(image.ktx2);
        }
        if (image.uri) {
          rnTexture.name = image.uri;
        } else {
          const ext = (_g = image.mimeType) == null ? void 0 : _g.split("/")[1];
          rnTexture.name = (_h = image.name) != null ? _h : texture.name + `.${ext}`;
        }
        rnTexture.tryToSetUniqueName(rnTexture.name, true);
        return rnTexture;
      }
      static __needResizeToPowerOfTwoOnWebGl1(textureOption) {
        if (textureOption.wrapS !== TextureParameter.ClampToEdge || textureOption.wrapT !== TextureParameter.ClampToEdge || textureOption.minFilter !== TextureParameter.Linear && textureOption.minFilter !== TextureParameter.Nearest) {
          return true;
        }
        return false;
      }
      static __sizeIsPowerOfTwo(image) {
        const width = image.width;
        const height = image.height;
        if ((width & width - 1) === 0 && (height & height - 1) === 0) {
          return true;
        } else {
          return false;
        }
      }
      static __needParameterInitialization(materialJson, materialTypeName) {
        if (materialJson == null) return false;
        return true;
      }
      static _checkRnGltfLoaderOptionsExist(gltfModel) {
        var _a40;
        if ((_a40 = gltfModel.asset.extras) == null ? void 0 : _a40.rnLoaderOptions) {
          return true;
        } else {
          return false;
        }
      }
      static __rewrapWithTypedArray(typedArrayClass, uint8Array, byteOffset, length) {
        return new typedArrayClass(uint8Array.buffer, byteOffset + uint8Array.byteOffset, length);
      }
      static _checkBytesPerComponent(accessor) {
        let bytesPerComponent = 0;
        switch (accessor.componentType) {
          case 5120:
            bytesPerComponent = 1;
            break;
          case 5121:
            bytesPerComponent = 1;
            break;
          case 5122:
            bytesPerComponent = 2;
            break;
          case 5123:
            bytesPerComponent = 2;
            break;
          case 5124:
            bytesPerComponent = 4;
            break;
          case 5125:
            bytesPerComponent = 4;
            break;
          case 5126:
            bytesPerComponent = 4;
            break;
          default:
            break;
        }
        return bytesPerComponent;
      }
      static _checkComponentNumber(accessor) {
        let componentN = 0;
        switch (accessor.type) {
          case "SCALAR":
            componentN = 1;
            break;
          case "VEC2":
            componentN = 2;
            break;
          case "VEC3":
            componentN = 3;
            break;
          case "VEC4":
            componentN = 4;
            break;
          case "MAT4":
            componentN = 16;
            break;
        }
        return componentN;
      }
      static _checkDataViewMethod(accessor) {
        let dataViewMethod = "";
        switch (accessor.componentType) {
          case 5120:
            dataViewMethod = "getInt8";
            break;
          case 5121:
            dataViewMethod = "getUint8";
            break;
          case 5122:
            dataViewMethod = "getInt16";
            break;
          case 5123:
            dataViewMethod = "getUint16";
            break;
          case 5124:
            dataViewMethod = "getInt32";
            break;
          case 5125:
            dataViewMethod = "getUint32";
            break;
          case 5126:
            dataViewMethod = "getFloat32";
            break;
          default:
            break;
        }
        return dataViewMethod;
      }
      static _isSystemLittleEndian() {
        return !!new Uint8Array(new Uint16Array([
          255
        ]).buffer)[0];
      }
      static _readBinaryFromAccessorAndSetItToAccessorExtras(accessor, rnBuffers) {
        var _a40, _b, _c;
        const bufferView = accessor.bufferViewObject;
        let byteOffsetFromBuffer = ((_a40 = bufferView.byteOffset) != null ? _a40 : 0) + ((_b = accessor.byteOffset) != null ? _b : 0);
        const buffer = bufferView.bufferObject;
        let uint8Array = buffer.buffer;
        const componentN = this._checkComponentNumber(accessor);
        const componentBytes = this._checkBytesPerComponent(accessor);
        const dataViewMethod = this._checkDataViewMethod(accessor);
        if (Is.not.exist(accessor.extras)) {
          accessor.extras = {
            attributeName: "",
            toGetAsTypedArray: true,
            typedDataArray: new Float32Array(),
            componentN: 0,
            componentBytes: 4,
            dataViewMethod: ""
          };
        }
        accessor.extras.componentN = Is.exist((_c = accessor.extras) == null ? void 0 : _c.weightsArrayLength) ? accessor.extras.weightsArrayLength : componentN;
        accessor.extras.componentBytes = componentBytes;
        accessor.extras.dataViewMethod = dataViewMethod;
        const byteLength = componentBytes * componentN * accessor.count;
        if (Is.exist(rnBuffers)) {
          const rnBuffer = rnBuffers[accessor.bufferViewObject.buffer];
          const rnBufferView = this.__getRnBufferView(bufferView, rnBuffer);
          const rnAccessor = this.__getRnAccessor(accessor, rnBufferView);
          uint8Array = rnAccessor.getUint8Array();
          byteOffsetFromBuffer = 0;
        }
        let float32Array = new Float32Array();
        const numberArray = [];
        if (_ModelConverter._isSystemLittleEndian()) {
          let typedDataArray = new Float32Array();
          if (dataViewMethod === "getFloat32") {
            typedDataArray = this.__rewrapWithTypedArray(Float32Array, uint8Array, byteOffsetFromBuffer, byteLength / componentBytes);
          } else if (dataViewMethod === "getInt8") {
            typedDataArray = new Int8Array(uint8Array, byteOffsetFromBuffer, byteLength / componentBytes);
          } else if (dataViewMethod === "getUint8") {
            typedDataArray = new Uint8Array(uint8Array, byteOffsetFromBuffer, byteLength / componentBytes);
          } else if (dataViewMethod === "getInt16") {
            typedDataArray = this.__rewrapWithTypedArray(Int16Array, uint8Array, byteOffsetFromBuffer, byteLength / componentBytes);
          } else if (dataViewMethod === "getUint16") {
            typedDataArray = this.__rewrapWithTypedArray(Uint16Array, uint8Array, byteOffsetFromBuffer, byteLength / componentBytes);
          } else if (dataViewMethod === "getInt32") {
            typedDataArray = this.__rewrapWithTypedArray(Int32Array, uint8Array, byteOffsetFromBuffer, byteLength / componentBytes);
          } else if (dataViewMethod === "getUint32") {
            typedDataArray = this.__rewrapWithTypedArray(Uint32Array, uint8Array, byteOffsetFromBuffer, byteLength / componentBytes);
          }
          float32Array = this.__normalizeTypedArrayToFloat32Array(dataViewMethod, typedDataArray);
        } else {
          const dataView = new DataView(uint8Array.buffer, byteOffsetFromBuffer + uint8Array.byteOffset, byteLength);
          const byteDelta = componentBytes * componentN;
          const littleEndian = true;
          for (let pos = 0; pos < byteLength; pos += byteDelta) {
            switch (accessor.type) {
              case "SCALAR":
                numberArray.push(dataView[dataViewMethod](pos, littleEndian));
                break;
              case "VEC2":
                numberArray.push(dataView[dataViewMethod](pos, littleEndian));
                numberArray.push(dataView[dataViewMethod](pos + componentBytes, littleEndian));
                break;
              case "VEC3":
                numberArray.push(dataView[dataViewMethod](pos, littleEndian));
                numberArray.push(dataView[dataViewMethod](pos + componentBytes, littleEndian));
                numberArray.push(dataView[dataViewMethod](pos + componentBytes * 2, littleEndian));
                break;
              case "VEC4":
                for (let i2 = 0; i2 < 4; i2++) {
                  numberArray.push(dataView[dataViewMethod](pos + componentBytes * i2, littleEndian));
                }
                break;
              case "MAT4":
                for (let i2 = 0; i2 < 16; i2++) {
                  numberArray.push(dataView[dataViewMethod](pos + componentBytes * i2, littleEndian));
                }
                break;
            }
          }
          float32Array = this.__normalizeTypedArrayToFloat32Array(dataViewMethod, numberArray);
        }
        accessor.extras.typedDataArray = float32Array;
        return float32Array;
      }
      /**
      * normalize values of TypedArray to Float32Array
      * See: the last part of 3.11.Animation at https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#animations
      * @param dataViewMethod
      * @param numberArray
      * @returns
      */
      static __normalizeTypedArrayToFloat32Array(dataViewMethod, numberArray) {
        if (dataViewMethod === "getInt8") {
          return DataUtil.normalizedInt8ArrayToFloat32Array(numberArray);
        } else if (dataViewMethod === "getUint8") {
          return DataUtil.normalizedUint8ArrayToFloat32Array(numberArray);
        } else if (dataViewMethod === "getInt16") {
          return DataUtil.normalizedInt16ArrayToFloat32Array(numberArray);
        } else if (dataViewMethod === "getUint16") {
          return DataUtil.normalizedUint16ArrayToFloat32Array(numberArray);
        } else if (dataViewMethod === "getInt32") {
          Logger.error("Not considered");
          return new Float32Array();
        } else if (dataViewMethod === "getUint32") {
          Logger.error("Not considered");
          return new Float32Array();
        } else if (dataViewMethod === "getFloat32") {
          return new Float32Array(numberArray);
        } else {
          Logger.error("Not considered");
          return new Float32Array();
        }
      }
      static __addOffsetToIndices(meshComponent) {
        const primitiveNumber = meshComponent.mesh.getPrimitiveNumber();
        let offsetSum = 0;
        for (let i2 = 0; i2 < primitiveNumber; i2++) {
          const primitive = meshComponent.mesh.getPrimitiveAt(i2);
          const indicesAccessor = primitive.indicesAccessor;
          if (indicesAccessor) {
            const elementNumber = indicesAccessor.elementCount;
            for (let j = 0; j < elementNumber; j++) {
              const index = indicesAccessor.getScalar(j, {});
              indicesAccessor.setScalar(j, index + offsetSum, {});
            }
            offsetSum += elementNumber;
          }
        }
      }
      /**
      * Take a Rn.Accessor from the Rn.Buffer
      *  from the information of the Gltf2Buffer, Gltf2BufferView, and Gltf2Accessor.
      * @param accessor
      * @param rnBuffer
      * @returns
      */
      static __getRnAccessor(accessor, rnBufferView) {
        var _a40;
        let rnAccessor;
        if (rnBufferView != null) {
          rnAccessor = rnBufferView.takeAccessorWithByteOffset({
            compositionType: CompositionType.fromString(accessor.type),
            componentType: ComponentType.from(accessor.componentType),
            count: accessor.count,
            byteOffsetInBufferView: (_a40 = accessor.byteOffset) != null ? _a40 : 0,
            byteStride: accessor.byteStride,
            max: accessor.max,
            min: accessor.min,
            normalized: accessor.normalized
          }).unwrapForce();
        } else {
          const rnBuffer = MemoryManager.getInstance().createOrGetBuffer(BufferUse.GPUVertexData);
          const compositionType = CompositionType.fromString(accessor.type);
          const componentType = ComponentType.from(accessor.componentType);
          const rnBufferView2 = rnBuffer.takeBufferView({
            byteLengthToNeed: accessor.count * compositionType.getNumberOfComponents() * componentType.getSizeInBytes(),
            byteStride: compositionType.getNumberOfComponents() * componentType.getSizeInBytes()
          }).unwrapForce();
          rnAccessor = rnBufferView2.takeAccessor({
            compositionType,
            componentType,
            count: accessor.count,
            max: accessor.max,
            min: accessor.min,
            normalized: accessor.normalized
          }).unwrapForce();
        }
        if (Is.exist(accessor.sparse)) {
          this.setSparseAccessor(accessor, rnAccessor);
        }
        return rnAccessor;
      }
      /**
      * Take a Rn.BufferView and a Rn.Accessor from the Rn.Buffer
      *  from the information of the Gltf2Buffer, Gltf2BufferView, and Gltf2Accessor.
      * @param accessor
      * @param rnBuffer
      * @returns
      */
      static __getRnBufferViewAndRnAccessor(accessor, rnBuffers) {
        const gltfBufferView = accessor.bufferViewObject;
        let rnBufferView;
        if (gltfBufferView != null) {
          const rnBuffer = rnBuffers[gltfBufferView.buffer];
          rnBufferView = this.__getRnBufferView(gltfBufferView, rnBuffer);
        }
        const rnAccessor = this.__getRnAccessor(accessor, rnBufferView);
        return rnAccessor;
      }
      static __copyRnAccessorAndBufferView(srcRnAccessor) {
        const byteSize = srcRnAccessor.elementCount * 3 * 4;
        const dstRnBuffer = MemoryManager.getInstance().createOrGetBuffer(BufferUse.GPUVertexData);
        const dstRnBufferView = dstRnBuffer.takeBufferView({
          byteLengthToNeed: byteSize,
          byteStride: 3 * 4
          /* bytes */
        }).unwrapForce();
        const dstRnAccessor = dstRnBufferView.takeAccessor({
          compositionType: CompositionType.Vec3,
          componentType: ComponentType.Float,
          count: srcRnAccessor.elementCount,
          max: srcRnAccessor.max,
          min: srcRnAccessor.min,
          normalized: srcRnAccessor.normalized
        }).unwrapForce();
        dstRnAccessor.copyBuffer(srcRnAccessor);
        return dstRnAccessor;
      }
      static __takeRnBufferViewAndRnAccessorForDraco(accessor, compositionNum, rnBuffer) {
        const rnBufferView = rnBuffer.takeBufferView({
          byteLengthToNeed: accessor.count * compositionNum * 4,
          byteStride: 0
        }).unwrapForce();
        const rnAccessor = this.__getRnAccessor(accessor, rnBufferView);
        return rnAccessor;
      }
      static __getRnBufferView(rnm2bufferView, rnBuffer) {
        var _a40, _b;
        const rnBufferView = rnBuffer.takeBufferViewWithByteOffset({
          byteLengthToNeed: rnm2bufferView.byteLength,
          byteStride: (_a40 = rnm2bufferView.byteStride) != null ? _a40 : 0,
          byteOffset: (_b = rnm2bufferView.byteOffset) != null ? _b : 0
        }).unwrapForce();
        return rnBufferView;
      }
      static __getGeometryFromDracoBuffer(draco, decoder, arrayBuffer) {
        const buffer = new draco.DecoderBuffer();
        buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);
        const geometryType = decoder.GetEncodedGeometryType(buffer);
        let dracoGeometry;
        let decodingStatus;
        if (geometryType === draco.TRIANGULAR_MESH) {
          dracoGeometry = new draco.Mesh();
          decodingStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);
        } else if (geometryType === draco.POINT_CLOUD) {
          dracoGeometry = new draco.PointCloud();
          decodingStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
        } else {
          const errorMsg = "Unknown geometry type.";
          Logger.error(errorMsg);
        }
        dracoGeometry.geometryType = geometryType;
        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
          let errorMsg = "Decoding failed: ";
          errorMsg += decodingStatus.error_msg();
          Logger.error(errorMsg);
          draco.destroy(decoder);
          draco.destroy(dracoGeometry);
          return void 0;
        }
        draco.destroy(buffer);
        return dracoGeometry;
      }
      static __getIndicesFromDraco(draco, decoder, dracoGeometry, triangleStripDrawMode) {
        const geometryType = dracoGeometry.geometryType;
        if (geometryType !== draco.TRIANGULAR_MESH) {
          return void 0;
        }
        let indices;
        if (triangleStripDrawMode) {
          const stripsArray = new draco.DracoInt32Array();
          decoder.GetTriangleStripsFromMesh(dracoGeometry, stripsArray);
          indices = new Uint32Array(stripsArray.size());
          for (let i2 = 0; i2 < stripsArray.size(); ++i2) {
            indices[i2] = stripsArray.GetValue(i2);
          }
          draco.destroy(stripsArray);
        } else {
          const numFaces = dracoGeometry.num_faces();
          const numIndices = numFaces * 3;
          indices = new Uint32Array(numIndices);
          const ia = new draco.DracoInt32Array();
          for (let i2 = 0; i2 < numFaces; ++i2) {
            decoder.GetFaceFromMesh(dracoGeometry, i2, ia);
            const index = i2 * 3;
            indices[index] = ia.GetValue(0);
            indices[index + 1] = ia.GetValue(1);
            indices[index + 2] = ia.GetValue(2);
          }
          draco.destroy(ia);
        }
        return indices;
      }
      static __decodeDraco(primitive, rnBuffers, gltfModel, map) {
        const bufferView = gltfModel.bufferViews[primitive.extensions.KHR_draco_mesh_compression.bufferView];
        const rnBufferView = this.__getRnBufferView(bufferView, rnBuffers[bufferView.buffer]);
        const arraybufferOfBufferView = new Uint8Array(rnBufferView.getUint8Array()).buffer;
        const draco = new DracoDecoderModule();
        const decoder = new draco.Decoder();
        const dracoGeometry = this.__getGeometryFromDracoBuffer(draco, decoder, arraybufferOfBufferView);
        if (dracoGeometry == null) {
          draco.destroy(dracoGeometry);
          draco.destroy(decoder);
          return void 0;
        }
        const numPoints = dracoGeometry.num_points();
        const rnBufferForDraco = this.__createBufferForDecompressedData(primitive, numPoints);
        const primitiveMode = PrimitiveMode.from(primitive.mode);
        let isTriangleStrip = false;
        if (primitiveMode === PrimitiveMode.TriangleStrip) {
          isTriangleStrip = true;
        }
        const indices = this.__getIndicesFromDraco(draco, decoder, dracoGeometry, isTriangleStrip);
        const indicesRnAccessor = this.__takeRnBufferViewAndRnAccessorForDraco(primitive.indicesObject, 1, rnBufferForDraco);
        for (let i2 = 0; i2 < indices.length; i2++) {
          indicesRnAccessor.setScalar(i2, indices[i2], {});
        }
        for (const attributeName in primitive.attributes) {
          const dracoAttributeId = primitive.extensions.KHR_draco_mesh_compression.attributes[attributeName];
          const attributeGltf2Accessor = primitive.attributesObjects[attributeName];
          let attributeRnAccessor = void 0;
          if (Is.not.exist(dracoAttributeId)) {
            attributeRnAccessor = this.__getRnBufferViewAndRnAccessor(attributeGltf2Accessor, rnBuffers);
          } else {
            const compositionNum = CompositionType.fromString(attributeGltf2Accessor.type).getNumberOfComponents();
            attributeRnAccessor = this.__takeRnBufferViewAndRnAccessorForDraco(attributeGltf2Accessor, compositionNum, rnBufferForDraco);
            const dracoAttributePointer = decoder.GetAttributeByUniqueId(dracoGeometry, dracoAttributeId);
            const decompressedAttributeData = new draco.DracoFloat32Array();
            decoder.GetAttributeFloatForAllPoints(dracoGeometry, dracoAttributePointer, decompressedAttributeData);
            for (let i2 = 0; i2 < numPoints; i2++) {
              if (compositionNum === 1) {
                attributeRnAccessor.setScalar(i2, decompressedAttributeData.GetValue(i2 * compositionNum), {});
              } else if (compositionNum === 2) {
                attributeRnAccessor.setVec2(i2, decompressedAttributeData.GetValue(i2 * compositionNum), decompressedAttributeData.GetValue(i2 * compositionNum + 1), {});
              } else if (compositionNum === 3) {
                attributeRnAccessor.setVec3(i2, decompressedAttributeData.GetValue(i2 * compositionNum), decompressedAttributeData.GetValue(i2 * compositionNum + 1), decompressedAttributeData.GetValue(i2 * compositionNum + 2), {});
              } else if (compositionNum === 4) {
                attributeRnAccessor.setVec4(i2, decompressedAttributeData.GetValue(i2 * compositionNum), decompressedAttributeData.GetValue(i2 * compositionNum + 1), decompressedAttributeData.GetValue(i2 * compositionNum + 2), decompressedAttributeData.GetValue(i2 * compositionNum + 3), {});
              }
            }
            draco.destroy(decompressedAttributeData);
          }
          if (Is.exist(attributeGltf2Accessor.sparse)) {
            this.setSparseAccessor(attributeGltf2Accessor, attributeRnAccessor);
          }
          const joinedString = VertexAttribute.toVertexAttributeSemanticJoinedStringAsGltfStyle(VertexAttribute.fromString(attributeGltf2Accessor.extras.attributeName));
          map.set(joinedString, attributeRnAccessor);
        }
        draco.destroy(dracoGeometry);
        draco.destroy(decoder);
        return indicesRnAccessor;
      }
      static _setupTextureTransform(textureJson, rnMaterial, textureTransformShaderSemantic, textureRotationShaderSemantic) {
        var _a40;
        if ((_a40 = textureJson == null ? void 0 : textureJson.extensions) == null ? void 0 : _a40.KHR_texture_transform) {
          const transform = MutableVector4.fromCopyArray([
            1,
            1,
            0,
            0
          ]);
          let rotation = 0;
          const transformJson = textureJson.extensions.KHR_texture_transform;
          if (transformJson.scale != null) {
            transform.x = transformJson.scale[0];
            transform.y = transformJson.scale[1];
          }
          if (transformJson.offset != null) {
            transform.z = transformJson.offset[0];
            transform.w = transformJson.offset[1];
          }
          if (transformJson.rotation != null) {
            rotation = transformJson.rotation;
          }
          rnMaterial.setParameter(textureTransformShaderSemantic, transform);
          rnMaterial.setParameter(textureRotationShaderSemantic, rotation);
        }
      }
      static __createBufferForDecompressedData(primitive, numPoints) {
        let byteLengthOfBufferForDraco = 0;
        if (Is.exist(primitive.indices)) {
          const count = primitive.indicesObject.count;
          byteLengthOfBufferForDraco += count * 4;
        }
        const drcAttributes = primitive.extensions.KHR_draco_mesh_compression.attributes;
        for (const attributeName in primitive.attributes) {
          if (drcAttributes[attributeName] == null) {
            continue;
          }
          const accessor = primitive.attributesObjects[attributeName];
          const compositionNum = CompositionType.fromString(accessor.type).getNumberOfComponents();
          const attributeByteLength = numPoints * compositionNum * 4;
          byteLengthOfBufferForDraco += attributeByteLength;
        }
        return new Buffer2({
          byteLength: byteLengthOfBufferForDraco,
          buffer: new ArrayBuffer(byteLengthOfBufferForDraco),
          name: "Draco",
          byteAlign: 4
        });
      }
    };
    __name(_ModelConverter, "ModelConverter");
    ModelConverter = _ModelConverter;
    __name(setupMToon1, "setupMToon1");
    __name(setupPbrMetallicRoughness, "setupPbrMetallicRoughness");
    __name(setup_KHR_materials_transmission, "setup_KHR_materials_transmission");
    __name(setup_KHR_materials_clearcoat, "setup_KHR_materials_clearcoat");
    __name(setup_KHR_materials_volume, "setup_KHR_materials_volume");
    __name(setup_KHR_materials_sheen, "setup_KHR_materials_sheen");
    __name(setup_KHR_materials_specular, "setup_KHR_materials_specular");
    __name(setup_KHR_materials_ior, "setup_KHR_materials_ior");
    __name(setup_KHR_materials_iridescence, "setup_KHR_materials_iridescence");
    __name(setup_KHR_materials_anisotropy, "setup_KHR_materials_anisotropy");
    __name(setup_KHR_materials_emissive_strength, "setup_KHR_materials_emissive_strength");
  }
});

// src/xr/WebXRInput.ts
async function createMotionController(xrInputSource, basePath, profilePriorities) {
  const { profile, assetPath } = await fetchProfile(xrInputSource, basePath);
  const motionController = new MotionController(xrInputSource, profile, assetPath);
  motionControllers.set(xrInputSource, motionController);
  const result = await addMotionControllerToScene(motionController);
  if (result.isOk()) {
    const rootGroup = ModelConverter.convertToRhodoniteObject(result.get());
    return rootGroup;
  } else {
    return void 0;
  }
}
async function addMotionControllerToScene(motionController) {
  const asset = await Gltf2Importer.importFromUri(motionController.assetUrl);
  addTouchPointDots(motionController, asset);
  return asset;
}
function updateGamePad(timestamp, xrFrame, viewerData) {
  Array.from(motionControllers.values()).forEach((motionController) => {
    motionController.updateFromGamepad();
    Object.keys(motionController.components).forEach((componentId) => {
      const component = motionController.components[componentId];
      processInput(component, motionController.xrInputSource.handedness, viewerData, timestamp);
    });
  });
}
function processInput(component, handed, viewerData, timestamp) {
  const componentName = wellKnownMapping.get(component.rootNodeName);
  if (Is.not.exist(componentName)) {
    return;
  }
  if (lastTimestamp === 0) {
    lastTimestamp = timestamp;
    return;
  }
  const deltaSec = (timestamp - lastTimestamp) * 1e-6;
  switch (componentName) {
    case GeneralType.TRIGGER:
      processTriggerInput(component, handed, viewerData, deltaSec);
      break;
    case GeneralType.THUMBSTICK:
      processThumbstickInput(component, handed, viewerData, deltaSec);
      break;
    case GeneralType.SQUEEZE:
      processSqueezeInput(component, handed, viewerData, deltaSec);
      break;
    case GeneralType.BUTTON_1:
    case GeneralType.BUTTON_2:
    case GeneralType.BUTTON_3:
    case GeneralType.BUTTON_SPECIAL:
      processButtonInput(component, handed, viewerData, deltaSec);
      break;
    case GeneralType.TOUCHPAD:
      processTouchpadInput(component, handed, viewerData, deltaSec);
      break;
    default:
  }
}
function processTriggerInput(triggerComponent, handed, viewerData, deltaSec) {
  let value = 0;
  const scale = 0.1;
  const componentName = wellKnownMapping.get(triggerComponent.rootNodeName);
  if (triggerComponent.values.state === Constants.ComponentState.PRESSED) {
    Logger.info(componentName + ", " + triggerComponent.values.button + ", " + handed);
    value = valueWithDefault({
      value: triggerComponent.values.button,
      defaultValue: 0
    }) * deltaSec;
  } else if (triggerComponent.values.state === Constants.ComponentState.TOUCHED) {
    Logger.info(componentName + ", " + triggerComponent.values.button + ", " + handed);
    value = valueWithDefault({
      value: triggerComponent.values.button,
      defaultValue: 0
    }) * deltaSec;
  }
  if (handed === "right") {
    value *= -1;
  }
  scaleVec3.x -= value * scale;
  scaleVec3.y -= value * scale;
  scaleVec3.z -= value * scale;
  scaleVec3.x = Math.max(scaleVec3.x, 0.05);
  scaleVec3.y = Math.max(scaleVec3.y, 0.05);
  scaleVec3.z = Math.max(scaleVec3.z, 0.05);
  scaleVec3.x = Math.min(scaleVec3.x, 3);
  scaleVec3.y = Math.min(scaleVec3.y, 3);
  scaleVec3.z = Math.min(scaleVec3.z, 3);
  viewerData.viewerScale.copyComponents(scaleVec3);
}
function processSqueezeInput(squeezeComponent, handed, viewerData, deltaSec) {
  const componentName = wellKnownMapping.get(squeezeComponent.rootNodeName);
  if (squeezeComponent.values.state === Constants.ComponentState.PRESSED) {
    Logger.info(componentName + ", " + squeezeComponent.values.button + ", " + handed);
  } else if (squeezeComponent.values.state === Constants.ComponentState.TOUCHED) {
    Logger.info(componentName + ", " + squeezeComponent.values.button + ", " + handed);
  }
}
function processThumbstickInput(thumbstickComponent, handed, viewerData, deltaSec) {
  const componentName = wellKnownMapping.get(thumbstickComponent.rootNodeName);
  let xAxis = 0;
  let yAxis = 0;
  const deltaScaleHorizontal = 0.25;
  const deltaScaleVertical = 0.1;
  const deltaScaleAzimuthAngle = 0.15;
  if (thumbstickComponent.values.state === Constants.ComponentState.PRESSED) {
    Logger.info(componentName + ", " + thumbstickComponent.values.button + ", " + thumbstickComponent.values.state + ", " + handed);
    xAxis = valueWithDefault({
      value: thumbstickComponent.values.xAxis,
      defaultValue: 0
    }) * deltaSec;
    yAxis = valueWithDefault({
      value: thumbstickComponent.values.yAxis,
      defaultValue: 0
    }) * deltaSec;
  } else if (thumbstickComponent.values.state === Constants.ComponentState.TOUCHED) {
    xAxis = valueWithDefault({
      value: thumbstickComponent.values.xAxis,
      defaultValue: 0
    }) * deltaSec;
    yAxis = valueWithDefault({
      value: thumbstickComponent.values.yAxis,
      defaultValue: 0
    }) * deltaSec;
  }
  xAxis = Math.min(xAxis, 1);
  yAxis = Math.min(yAxis, 1);
  const deltaVector = MutableVector3.zero();
  if (handed === "right") {
    viewerData.viewerAzimuthAngle.x -= xAxis * deltaScaleAzimuthAngle;
    deltaVector.y -= yAxis * deltaScaleVertical * viewerData.viewerScale.x;
  } else {
    deltaVector.x += xAxis * deltaScaleHorizontal * viewerData.viewerScale.x;
    deltaVector.z += yAxis * deltaScaleHorizontal * viewerData.viewerScale.x;
  }
  const orientationMat = MutableMatrix33.fromCopyQuaternion(viewerData.viewerOrientation);
  const rotateMat = orientationMat.multiply(MutableMatrix33.rotateY(viewerData.viewerAzimuthAngle.x));
  rotateMat.multiplyVectorTo(deltaVector, deltaVector);
  viewerData.viewerTranslate.add(deltaVector);
}
function processButtonInput(buttonComponent, handed, viewerData, deltaSec) {
  const componentName = wellKnownMapping.get(buttonComponent.rootNodeName);
  if (buttonComponent.values.state === Constants.ComponentState.PRESSED) {
    Logger.info(componentName + ", " + buttonComponent.values.button + ", " + buttonComponent.values.state + ", " + handed);
  } else if (buttonComponent.values.state === Constants.ComponentState.TOUCHED) {
    Logger.info(componentName + ", " + buttonComponent.values.button + ", " + buttonComponent.values.state + ", " + handed);
  }
}
function processTouchpadInput(thumbstick, handed, viewerData, deltaSec) {
  if (thumbstick.values.state === Constants.ComponentState.PRESSED) {
  } else if (thumbstick.values.state === Constants.ComponentState.TOUCHED && thumbstick.values.yAxis !== 0) {
    const scootDistance = thumbstick.values.yAxis;
  }
}
function addTouchPointDots(motionController, asset) {
  Object.values(motionController.components).forEach((component) => {
    if (component.touchPointNodeName) {
      const touchPointRoot = asset.getChildByName(component.touchPointNodeName, true);
    }
  });
}
function updateMotionControllerModel(entity, motionController) {
  const map = entity.getTagValue("rnEntitiesByNames");
  Object.values(motionController.components).forEach((component) => {
    for (const visualResponseName in component.visualResponses) {
      const visualResponse = component.visualResponses[visualResponseName];
      const entity2 = map.get(visualResponse.valueNodeName);
      if (Is.not.exist(entity2)) {
        Logger.warn("The entity of the controller doesn't exist");
        continue;
      }
      if (visualResponse.valueNodeProperty === "visibility") {
        entity2.getSceneGraph().isVisible = !!visualResponse.value;
      } else if (visualResponse.valueNodeProperty === "transform") {
        const minNode = map.get(visualResponse.minNodeName);
        const maxNode = map.get(visualResponse.maxNodeName);
        if (Is.not.exist(minNode) || Is.not.exist(maxNode)) {
          Logger.warn("The min/max Node of the component of the controller doesn't exist");
          continue;
        }
        const minNodeTransform = minNode.getTransform();
        const maxNodeTransform = maxNode.getTransform();
        entity2.getTransform().quaternion = Quaternion.qlerp(minNodeTransform.localRotationInner, maxNodeTransform.localRotationInner, visualResponse.value);
        entity2.getTransform().localPosition = Vector3.lerp(minNodeTransform.localPositionInner, maxNodeTransform.localPositionInner, visualResponse.value);
      }
    }
  });
}
function getMotionController(xrInputSource) {
  return motionControllers.get(xrInputSource);
}
var motionControllers, GeneralType, wellKnownMapping, lastTimestamp, scaleVec3;
var init_WebXRInput = __esm({
  "src/xr/WebXRInput.ts"() {
    "use strict";
    init_motionController();
    init_profiles();
    init_constants();
    init_Gltf2Importer();
    init_ModelConverter();
    init_Is();
    init_Quaternion();
    init_Vector3();
    init_MiscUtil();
    init_MutableVector3();
    init_MutableMatrix33();
    init_Logger();
    motionControllers = /* @__PURE__ */ new Map();
    GeneralType = Object.freeze({
      TRIGGER: "trigger",
      SQUEEZE: "squeeze",
      TOUCHPAD: "touchpad",
      THUMBSTICK: "thumbstick",
      BUTTON_1: "button_1",
      BUTTON_2: "button_2",
      BUTTON_3: "button_3",
      BUTTON_SPECIAL: "button_special"
    });
    wellKnownMapping = /* @__PURE__ */ new Map();
    wellKnownMapping.set("a_button", GeneralType.BUTTON_1);
    wellKnownMapping.set("b_button", GeneralType.BUTTON_2);
    wellKnownMapping.set("x_button", GeneralType.BUTTON_1);
    wellKnownMapping.set("y_button", GeneralType.BUTTON_2);
    wellKnownMapping.set("thumbrest", GeneralType.BUTTON_3);
    wellKnownMapping.set("menu", GeneralType.BUTTON_SPECIAL);
    wellKnownMapping.set("xr_standard_trigger", GeneralType.TRIGGER);
    wellKnownMapping.set("xr_standard_squeeze", GeneralType.SQUEEZE);
    wellKnownMapping.set("xr_standard_thumbstick", GeneralType.THUMBSTICK);
    wellKnownMapping.set("xr_standard_touchpad", GeneralType.TOUCHPAD);
    wellKnownMapping.set("trigger", GeneralType.TRIGGER);
    wellKnownMapping.set("squeeze", GeneralType.SQUEEZE);
    wellKnownMapping.set("thumbstick", GeneralType.THUMBSTICK);
    wellKnownMapping.set("touchpad", GeneralType.TOUCHPAD);
    __name(createMotionController, "createMotionController");
    __name(addMotionControllerToScene, "addMotionControllerToScene");
    __name(updateGamePad, "updateGamePad");
    lastTimestamp = 0;
    __name(processInput, "processInput");
    scaleVec3 = MutableVector3.one();
    __name(processTriggerInput, "processTriggerInput");
    __name(processSqueezeInput, "processSqueezeInput");
    __name(processThumbstickInput, "processThumbstickInput");
    __name(processButtonInput, "processButtonInput");
    __name(processTouchpadInput, "processTouchpadInput");
    __name(addTouchPointDots, "addTouchPointDots");
    __name(updateMotionControllerModel, "updateMotionControllerModel");
    __name(getMotionController, "getMotionController");
  }
});

// src/xr/WebXRSystem.ts
var defaultUserPositionInVR, _WebXRSystem, WebXRSystem;
var init_WebXRSystem = __esm({
  "src/xr/WebXRSystem.ts"() {
    "use strict";
    init_CGAPIResourceRepository();
    init_Vector3();
    init_MutableMatrix44();
    init_Vector4();
    init_System();
    init_ModuleManager();
    init_WebXRInput();
    init_Is();
    init_MutableVector3();
    init_MutableQuaternion();
    init_MutableScalar();
    init_MaterialRepository();
    init_createGroupEntity();
    init_createCameraEntity();
    init_Logger();
    defaultUserPositionInVR = Vector3.fromCopyArray([
      0,
      1.1,
      0
    ]);
    _WebXRSystem = class _WebXRSystem {
      constructor() {
        __publicField(this, "__xrSession");
        __publicField(this, "__xrReferenceSpace");
        __publicField(this, "__webglLayer");
        __publicField(this, "__glw");
        __publicField(this, "__xrViewerPose");
        __publicField(this, "__isWebXRMode", false);
        __publicField(this, "__spaceType", "local");
        __publicField(this, "__requestedToEnterWebXR", false);
        __publicField(this, "__isReadyForWebXR", false);
        __publicField(this, "__defaultPositionInLocalSpaceMode", defaultUserPositionInVR);
        __publicField(this, "__canvasWidthForVR", 0);
        __publicField(this, "__canvasHeightForVR", 0);
        __publicField(this, "__viewerEntity");
        __publicField(this, "__leftCameraEntity");
        __publicField(this, "__rightCameraEntity");
        __publicField(this, "__basePath");
        __publicField(this, "__controllerEntities", []);
        __publicField(this, "__xrInputSources", []);
        __publicField(this, "__viewerTranslate", MutableVector3.zero());
        __publicField(this, "__viewerAzimuthAngle", MutableScalar.zero());
        __publicField(this, "__viewerOrientation", MutableQuaternion.identity());
        __publicField(this, "__viewerScale", MutableVector3.one());
        __publicField(this, "__multiviewFramebufferHandle", -1);
        __publicField(this, "__multiviewColorTextureHandle", -1);
        __publicField(this, "__webglStereoUtil");
        this.__viewerEntity = createGroupEntity();
        this.__viewerEntity.tryToSetUniqueName("WebXR Viewer", true);
        this.__viewerEntity.tryToSetTag({
          tag: "type",
          value: "background-assets"
        });
        this.__leftCameraEntity = createCameraEntity();
        this.__leftCameraEntity.tryToSetUniqueName("WebXR Left Camera", true);
        this.__leftCameraEntity.tryToSetTag({
          tag: "type",
          value: "background-assets"
        });
        this.__leftCameraEntity.getCamera()._xrLeft = true;
        this.__rightCameraEntity = createCameraEntity();
        this.__rightCameraEntity.tryToSetUniqueName("WebXR Right Camera", true);
        this.__rightCameraEntity.tryToSetTag({
          tag: "type",
          value: "background-assets"
        });
        this.__rightCameraEntity.getCamera()._xrRight = true;
        this.__viewerEntity.getSceneGraph().addChild(this.__leftCameraEntity.getSceneGraph());
        this.__viewerEntity.getSceneGraph().addChild(this.__rightCameraEntity.getSceneGraph());
      }
      /// Public Methods
      /**
      * Ready for WebXR
      *
      * @param requestButtonDom
      * @returns true: prepared properly, false: failed to prepare
      */
      async readyForWebXR(requestButtonDom, basePath) {
        if (typeof window === "undefined") {
          throw new Error("This method works in Browser environment");
        }
        this.__basePath = basePath;
        await ModuleManager.getInstance().loadModule("xr");
        const glw = CGAPIResourceRepository.getWebGLResourceRepository().currentWebGLContextWrapper;
        if (glw == null) {
          Logger.error("WebGL Context is not ready yet.");
          return [];
        }
        this.__glw = glw;
        const supported = await navigator.xr.isSessionSupported("immersive-vr");
        if (supported) {
          if (requestButtonDom) {
            requestButtonDom.style.display = "block";
          } else {
            const paragraph = document.createElement("p");
            const anchor = document.createElement("a");
            anchor.setAttribute("id", "enter-vr");
            const enterVr = document.createTextNode("Enter VR");
            anchor.appendChild(enterVr);
            paragraph.appendChild(anchor);
            const canvas = glw.canvas;
            canvas.parentNode.insertBefore(paragraph, canvas);
            window.addEventListener("click", this.enterWebXR.bind(this));
          }
          this.__isReadyForWebXR = true;
        } else {
          throw new Error("WebXR is not supported in this environment.");
        }
        return [];
      }
      /**
      * Enter to WebXR (VR mode)
      * @param initialUserPosition the initial user position in world space
      * @param callbackOnXrSessionEnd the callback function for XrSession ending
      * @returns boolean value about succeeded or not
      */
      async enterWebXR({ initialUserPosition, callbackOnXrSessionStart = /* @__PURE__ */ __name(() => {
      }, "callbackOnXrSessionStart"), callbackOnXrSessionEnd = /* @__PURE__ */ __name(() => {
      }, "callbackOnXrSessionEnd"), profilePriorities = [] }) {
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        const glw = webglResourceRepository.currentWebGLContextWrapper;
        if (glw != null && this.__isReadyForWebXR) {
          let referenceSpace;
          const session = await navigator.xr.requestSession("immersive-vr");
          this.__xrSession = session;
          session.addEventListener("end", () => {
            glw.__gl.bindFramebuffer(glw.__gl.FRAMEBUFFER, null);
            this.__xrSession = void 0;
            this.__webglLayer = void 0;
            this.__xrViewerPose = void 0;
            this.__xrReferenceSpace = void 0;
            this.__spaceType = "local";
            this.__isReadyForWebXR = false;
            this.__requestedToEnterWebXR = false;
            this.__xrInputSources.length = 0;
            this.__setWebXRMode(false);
            MaterialRepository._makeShaderInvalidateToAllMaterials();
            this.__defaultPositionInLocalSpaceMode = defaultUserPositionInVR;
            Logger.info("XRSession ends.");
            System.stopRenderLoop();
            System.restartRenderLoop();
            callbackOnXrSessionEnd();
          });
          const promiseFn = /* @__PURE__ */ __name((resolve) => {
            session.addEventListener("inputsourceschange", (e3) => {
              this.__onInputSourcesChange(e3, resolve, profilePriorities);
            });
          }, "promiseFn");
          const promise = new Promise(promiseFn);
          referenceSpace = await session.requestReferenceSpace("local");
          this.__spaceType = "local";
          this.__defaultPositionInLocalSpaceMode = initialUserPosition != null ? initialUserPosition : defaultUserPositionInVR;
          this.__xrReferenceSpace = referenceSpace;
          System.stopRenderLoop();
          await this.__setupWebGLLayer(session, callbackOnXrSessionStart);
          this.__requestedToEnterWebXR = true;
          System.restartRenderLoop();
          Logger.warn("End of enterWebXR.");
          return promise;
        } else {
          Logger.error("WebGL context or WebXRSession is not ready yet.");
          return void 0;
        }
      }
      /**
      * Disable WebXR (Close the XrSession)
      */
      async exitWebXR() {
        if (this.__xrSession != null) {
          await this.__xrSession.end();
        }
      }
      /// Getter Methods
      getCanvasWidthForVr() {
        return this.__canvasWidthForVR;
      }
      getCanvasHeightForVr() {
        return this.__canvasHeightForVR;
      }
      getControllerEntities() {
        return this.__controllerEntities;
      }
      /// Accessors
      get leftViewMatrix() {
        return this.__leftCameraEntity.getCamera().viewMatrix;
      }
      get rightViewMatrix() {
        return this.__rightCameraEntity.getCamera().viewMatrix;
      }
      get leftProjectionMatrix() {
        var _a40;
        const xrViewLeft = (_a40 = this.__xrViewerPose) == null ? void 0 : _a40.views[0];
        return MutableMatrix44.fromCopyFloat32ArrayColumnMajor(Is.exist(xrViewLeft) ? xrViewLeft.projectionMatrix : MutableMatrix44.identity()._v);
      }
      get rightProjectionMatrix() {
        var _a40;
        const xrViewRight = (_a40 = this.__xrViewerPose) == null ? void 0 : _a40.views[1];
        return MutableMatrix44.fromCopyFloat32ArrayColumnMajor(Is.exist(xrViewRight) ? xrViewRight.projectionMatrix : MutableMatrix44.identity()._v);
      }
      get framebuffer() {
        var _a40, _b;
        return (_b = (_a40 = this.__xrSession) == null ? void 0 : _a40.renderState.baseLayer) == null ? void 0 : _b.framebuffer;
      }
      isMultiView() {
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        return webglResourceRepository.isSupportMultiViewVRRendering();
      }
      get requestedToEnterWebXR() {
        return this.__requestedToEnterWebXR;
      }
      get xrSession() {
        return this.__xrSession;
      }
      get requestedToEnterWebVR() {
        return this.__requestedToEnterWebXR;
      }
      get isWebXRMode() {
        return this.__isWebXRMode;
      }
      __setWebXRMode(mode) {
        this.__isWebXRMode = mode;
        this.__glw._isWebXRMode = mode;
      }
      get isReadyForWebXR() {
        return this.__isReadyForWebXR;
      }
      /// Public Static Methods
      static getInstance() {
        if (!this.__instance) {
          this.__instance = new _WebXRSystem();
        }
        return this.__instance;
      }
      /// Friend methods
      /**
      * Getter of the view matrix of right eye
      * @param index (0: left, 1: right)
      * @internal
      * @returns The view matrix vector of right eye
      */
      _getViewMatrixAt(index) {
        if (index === 0) {
          return this.leftViewMatrix;
        } else {
          return this.rightViewMatrix;
        }
      }
      /**
      * Getter of the project matrix of right eye
      * @param index (0: left, 1: right)
      * @internal
      * @returns The project matrix of right eye
      */
      _getProjectMatrixAt(index) {
        if (index === 0) {
          return this.leftProjectionMatrix;
        } else {
          return this.rightProjectionMatrix;
        }
      }
      /**
      * Getter of the viewport vector
      * @param index (0: left, 1: right)
      * @internal
      * @returns the viewport vector
      */
      _getViewportAt(index) {
        if (index === 0) {
          return this._getLeftViewport();
        } else {
          return this._getRightViewport();
        }
      }
      /**
      * Getter of the viewport vector of left eye
      * @internal
      * @returns The viewport vector of left eye
      */
      _getLeftViewport() {
        return Vector4.fromCopyArray([
          0,
          0,
          this.__canvasWidthForVR / 2,
          this.__canvasHeightForVR
        ]);
      }
      /**
      * Getter of the viewport vector of right eye
      * @internal
      * @returns The viewport vector of right eye
      */
      _getRightViewport() {
        if (this.isMultiView()) {
          return Vector4.fromCopyArray([
            0,
            0,
            this.__canvasWidthForVR / 2,
            this.__canvasHeightForVR
          ]);
        } else {
          return Vector4.fromCopyArray([
            this.__canvasWidthForVR / 2,
            0,
            this.__canvasWidthForVR / 2,
            this.__canvasHeightForVR
          ]);
        }
      }
      _setValuesToGlobalDataRepository() {
        this.__leftCameraEntity.getCamera().projectionMatrix = this.leftProjectionMatrix;
        this.__rightCameraEntity.getCamera().projectionMatrix = this.rightProjectionMatrix;
        this.__leftCameraEntity.getCamera().setValuesToGlobalDataRepository();
        this.__rightCameraEntity.getCamera().setValuesToGlobalDataRepository();
      }
      /**
      * Getter of the position of the VR camera in world space
      * @internal
      * @param displayIdx (0: left, 1: right)
      * @returns The position of the VR camera in world space
      */
      _getCameraWorldPositionAt(displayIdx) {
        var _a40;
        const xrView = (_a40 = this.__xrViewerPose) == null ? void 0 : _a40.views[displayIdx];
        if (Is.exist(xrView)) {
          const pos = xrView.transform.position;
          const def = this.__defaultPositionInLocalSpaceMode;
          const translate = this.__viewerTranslate;
          const viewerHeadPos = Vector3.add(Vector3.fromCopyArray([
            pos.x,
            pos.y,
            pos.z
          ]), def);
          return Vector3.fromCopyArray([
            (viewerHeadPos.x + translate.x) * this.__viewerScale.x,
            (viewerHeadPos.y + translate.y) * this.__viewerScale.y,
            (viewerHeadPos.z + translate.z) * this.__viewerScale.z
          ]);
        } else {
          return this.__defaultPositionInLocalSpaceMode;
        }
      }
      /**
      * Getter of the CameraComponent SID of left/right eye
      * @internal
      * @param index (0: left, 1: right)
      * @returns the SID of the CameraComponent of left/right eye
      */
      _getCameraComponentSIDAt(index) {
        if (index === 0) {
          return this.__leftCameraEntity.getCamera().componentSID;
        } else {
          return this.__rightCameraEntity.getCamera().componentSID;
        }
      }
      /**
      * Getter of the CameraComponent of left/right eye
      * @internal
      * @param index (0: left, 1: right)
      * @returns the CameraComponent of left/right eye
      */
      _getCameraComponentAt(index) {
        if (index === 0) {
          return this.__leftCameraEntity.getCamera();
        } else {
          return this.__rightCameraEntity.getCamera();
        }
      }
      /**
      * Pre process for rendering
      * @internal
      * @param xrFrame XRFrame object
      */
      _preRender(time, xrFrame) {
        if (this.isWebXRMode && this.__requestedToEnterWebXR && xrFrame != null) {
          this.__updateView(xrFrame);
          this.__updateInputSources(xrFrame);
          updateGamePad(time, xrFrame, {
            viewerTranslate: this.__viewerTranslate,
            viewerScale: this.__viewerScale,
            viewerOrientation: this.__viewerOrientation,
            viewerAzimuthAngle: this.__viewerAzimuthAngle
          });
        }
      }
      resetViewerTransform() {
        this.__viewerTranslate = MutableVector3.zero();
        this.__viewerAzimuthAngle = MutableScalar.zero();
        this.__viewerOrientation = MutableQuaternion.identity();
        this.__viewerScale = MutableVector3.one();
      }
      /**
      * Post process for rendering
      * @internal
      */
      _postRender() {
        if (this.__isWebXRMode) {
        }
      }
      /// Private Methods
      async __onInputSourcesChange(event, resolve, profilePriorities) {
        this.__xrInputSources.length = 0;
        for (const xrInputSource of event.added) {
          this.__xrInputSources.push(xrInputSource);
          const controller = await createMotionController(xrInputSource, this.__basePath, profilePriorities);
          if (Is.exist(controller)) {
            this.__controllerEntities.push(controller);
            this.__viewerEntity.getSceneGraph().addChild(controller.getSceneGraph());
          }
        }
        resolve(this.__controllerEntities);
      }
      __setCameraInfoFromXRViews(xrViewerPose) {
        if (Is.not.exist(xrViewerPose)) {
          Logger.warn("xrViewerPose not exist");
          return;
        }
        const xrViewLeft = xrViewerPose.views[0];
        const xrViewRight = xrViewerPose.views[1];
        if (Is.not.exist(xrViewLeft) || Is.not.exist(xrViewRight)) {
          return;
        }
        const orientation = xrViewerPose.transform.orientation;
        this.__viewerOrientation.x = orientation.x;
        this.__viewerOrientation.y = orientation.y;
        this.__viewerOrientation.z = orientation.z;
        this.__viewerOrientation.w = orientation.w;
        const lm = MutableMatrix44.fromCopyFloat32ArrayColumnMajor(xrViewLeft == null ? void 0 : xrViewLeft.transform.matrix);
        const rm = MutableMatrix44.fromCopyFloat32ArrayColumnMajor(xrViewRight == null ? void 0 : xrViewRight.transform.matrix);
        const rotateMatLeft = lm;
        const rotateMatRight = rm;
        const scale = this.__viewerScale.x;
        const pos = xrViewLeft.transform.position;
        const translateLeftScaled = MutableVector3.add(this.__defaultPositionInLocalSpaceMode, this.__viewerTranslate);
        const translateRightScaled = MutableVector3.add(this.__defaultPositionInLocalSpaceMode, this.__viewerTranslate);
        const xrViewerPosLeft = Vector3.fromCopyArray([
          pos.x,
          pos.y,
          pos.z
        ]);
        const xrViewerPosRight = Vector3.fromCopyArray([
          pos.x,
          pos.y,
          pos.z
        ]);
        const translateLeft = MutableVector3.add(this.__defaultPositionInLocalSpaceMode, this.__viewerTranslate).add(xrViewerPosLeft);
        const translateRight = MutableVector3.add(this.__defaultPositionInLocalSpaceMode, this.__viewerTranslate).add(xrViewerPosRight);
        const viewerTranslateScaledX = (translateLeftScaled.x + translateRightScaled.x) / 2;
        const viewerTranslateScaledZ = (translateLeftScaled.z + translateRightScaled.z) / 2;
        const viewerTranslateX = (translateLeft.x + translateRight.x) / 2;
        const viewerTranslateZ = (translateLeft.z + translateRight.z) / 2;
        const viewerTransform = this.__viewerEntity.getTransform();
        viewerTransform.localPosition = Vector3.fromCopyArray([
          viewerTranslateScaledX,
          0,
          viewerTranslateScaledZ
        ]);
        viewerTransform.localScale = Vector3.fromCopyArray([
          scale,
          scale,
          scale
        ]);
        viewerTransform.localEulerAngles = Vector3.fromCopyArray([
          0,
          this.__viewerAzimuthAngle.x,
          0
        ]);
        rotateMatLeft.translateY = translateLeft.y;
        rotateMatLeft.translateX = translateLeft.x - viewerTranslateX;
        rotateMatLeft.translateZ = translateLeft.z - viewerTranslateZ;
        rotateMatLeft.translateY += xrViewerPosLeft.y;
        rotateMatLeft.translateX += xrViewerPosLeft.x;
        rotateMatLeft.translateZ += xrViewerPosLeft.z;
        rotateMatRight.translateY = translateRight.y;
        rotateMatRight.translateX = translateRight.x - viewerTranslateX;
        rotateMatRight.translateZ = translateRight.z - viewerTranslateZ;
        rotateMatRight.translateY += xrViewerPosRight.y;
        rotateMatRight.translateX += xrViewerPosRight.x;
        rotateMatRight.translateZ += xrViewerPosRight.z;
        this.__leftCameraEntity.getTransform().localMatrix = rotateMatLeft;
        this.__rightCameraEntity.getTransform().localMatrix = rotateMatRight;
      }
      async __setupWebGLLayer(xrSession, callbackOnXrSessionStart) {
        var _a40;
        const gl = (_a40 = this.__glw) == null ? void 0 : _a40.getRawContextAsWebGL2();
        if (gl != null) {
          await gl.makeXRCompatible();
          if (typeof window === "undefined") {
            throw new Error("This method works in Browser environment");
          }
          this.__webglLayer = new window.XRWebGLLayer(xrSession, gl);
          const webglLayer = this.__webglLayer;
          xrSession.updateRenderState({
            baseLayer: webglLayer,
            depthNear: 0.01,
            depthFar: 1e3
          });
          const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
          this.__canvasWidthForVR = webglLayer.framebufferWidth;
          this.__canvasHeightForVR = webglLayer.framebufferHeight;
          Logger.info(this.__canvasWidthForVR.toString());
          Logger.info(this.__canvasHeightForVR.toString());
          MaterialRepository._makeShaderInvalidateToAllMaterials();
          webglResourceRepository.resizeCanvas(this.__canvasWidthForVR, this.__canvasHeightForVR);
          this.__setWebXRMode(true);
          callbackOnXrSessionStart();
        } else {
          Logger.error("WebGL context is not ready for WebXR.");
        }
      }
      __updateView(xrFrame) {
        this.__xrViewerPose = xrFrame.getViewerPose(this.__xrReferenceSpace);
        this.__setCameraInfoFromXRViews(this.__xrViewerPose);
      }
      __updateInputSources(xrFrame) {
        this.__xrInputSources.forEach((input, i2) => {
          if (Is.exist(input.gripSpace)) {
            const xrPose = xrFrame.getPose(input.gripSpace, this.__xrReferenceSpace);
            if (Is.exist(xrPose)) {
              const hand = this.__controllerEntities[i2];
              if (Is.exist(hand)) {
                const handWorldMatrix = MutableMatrix44.fromCopyFloat32ArrayColumnMajor(xrPose.transform.matrix);
                const rotateMat = MutableMatrix44.fromCopyMatrix44(handWorldMatrix);
                rotateMat.translateY += this.__defaultPositionInLocalSpaceMode.y;
                rotateMat.translateY += this.__viewerTranslate.y;
                hand.getTransform().localMatrix = rotateMat;
                const motionController = getMotionController(input);
                if (Is.exist(motionController)) {
                  updateMotionControllerModel(hand, motionController);
                } else {
                  Logger.warn("motionController not found");
                }
              }
            }
          }
        });
      }
    };
    __name(_WebXRSystem, "WebXRSystem");
    __publicField(_WebXRSystem, "__instance");
    WebXRSystem = _WebXRSystem;
  }
});

// src/xr/WebARSystem.ts
var defaultUserPositionInVR2, _WebARSystem, WebARSystem;
var init_WebARSystem = __esm({
  "src/xr/WebARSystem.ts"() {
    "use strict";
    init_createCameraEntity();
    init_MutableMatrix44();
    init_MutableQuaternion();
    init_MutableScalar();
    init_MutableVector3();
    init_Vector3();
    init_Is();
    init_Logger();
    init_Option();
    init_CGAPIResourceRepository();
    init_ModuleManager();
    init_System();
    defaultUserPositionInVR2 = Vector3.fromCopyArray([
      0,
      1.1,
      0
    ]);
    _WebARSystem = class _WebARSystem {
      constructor() {
        __publicField(this, "__oGlw", new None());
        __publicField(this, "__isReadyForWebAR", false);
        __publicField(this, "__oArSession", new None());
        __publicField(this, "__oWebglLayer", new None());
        __publicField(this, "__spaceType", "local");
        __publicField(this, "__isWebARMode", false);
        __publicField(this, "__requestedToEnterWebAR", false);
        __publicField(this, "__oArViewerPose", new None());
        __publicField(this, "__oArReferenceSpace", new None());
        __publicField(this, "__defaultPositionInLocalSpaceMode", defaultUserPositionInVR2);
        __publicField(this, "__canvasWidthForAR", 0);
        __publicField(this, "__canvasHeightForAR", 0);
        __publicField(this, "_cameraEntity", createCameraEntity());
        __publicField(this, "__viewerTranslate", MutableVector3.zero());
        __publicField(this, "__viewerAzimuthAngle", MutableScalar.zero());
        __publicField(this, "__viewerOrientation", MutableQuaternion.identity());
        __publicField(this, "__viewerScale", MutableVector3.one());
        this._cameraEntity.tryToSetUniqueName("WebAR Viewer", true);
        this._cameraEntity.tryToSetTag({
          tag: "type",
          value: "background-assets"
        });
      }
      static getInstance() {
        if (!this.__instance) {
          this.__instance = new _WebARSystem();
        }
        return this.__instance;
      }
      /**
      * Ready for WebAR
      *
      * @param requestButtonDom
      * @returns true: prepared properly, false: failed to prepare
      */
      async readyForWebAR(requestButtonDom) {
        if (typeof window === "undefined") {
          throw new Error("This method works in Browser environment");
        }
        await ModuleManager.getInstance().loadModule("xr");
        const glw = CGAPIResourceRepository.getWebGLResourceRepository().currentWebGLContextWrapper;
        if (glw == null) {
          throw new Error("WebGL Context is not ready yet.");
        }
        this.__oGlw = new Some(glw);
        const supported = await navigator.xr.isSessionSupported("immersive-ar");
        if (supported) {
          Logger.info("WebAR is supported.");
          if (requestButtonDom) {
            requestButtonDom.style.display = "block";
          } else {
            const paragraph = document.createElement("p");
            const anchor = document.createElement("a");
            anchor.setAttribute("id", "enter-ar");
            const enterVr = document.createTextNode("Enter AR");
            anchor.appendChild(enterVr);
            paragraph.appendChild(anchor);
            const canvas = glw.canvas;
            canvas.parentNode.insertBefore(paragraph, canvas);
            window.addEventListener("click", this.enterWebAR.bind(this));
          }
          this.__isReadyForWebAR = true;
        } else {
          throw new Error("WebAR is not supported in this environment.");
        }
        return [];
      }
      /**
      * Enter to WebXR (AR mode)
      * @param initialUserPosition the initial user position in world space
      * @param callbackOnXrSessionEnd the callback function for XrSession ending
      * @returns boolean value about succeeded or not
      */
      async enterWebAR({ initialUserPosition, callbackOnXrSessionStart = /* @__PURE__ */ __name(() => {
      }, "callbackOnXrSessionStart"), callbackOnXrSessionEnd = /* @__PURE__ */ __name(() => {
      }, "callbackOnXrSessionEnd") }) {
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        const glw = webglResourceRepository.currentWebGLContextWrapper;
        if (glw != null && this.__isReadyForWebAR) {
          const session = await navigator.xr.requestSession("immersive-vr");
          this.__oArSession = new Some(session);
          session.addEventListener("end", () => {
            glw.__gl.bindFramebuffer(glw.__gl.FRAMEBUFFER, null);
            this.__oArSession = new None();
            this.__oWebglLayer = new None();
            this.__oArViewerPose = new None();
            this.__oArReferenceSpace = new None();
            this.__spaceType = "local";
            this.__isReadyForWebAR = false;
            this.__requestedToEnterWebAR = false;
            this.__isWebARMode = false;
            this.__defaultPositionInLocalSpaceMode = defaultUserPositionInVR2;
            Logger.info("XRSession ends.");
            System.stopRenderLoop();
            System.restartRenderLoop();
            callbackOnXrSessionEnd();
          });
          const referenceSpace = await session.requestReferenceSpace("local");
          this.__spaceType = "local";
          this.__defaultPositionInLocalSpaceMode = initialUserPosition != null ? initialUserPosition : defaultUserPositionInVR2;
          this.__oArReferenceSpace = new Some(referenceSpace);
          System.stopRenderLoop();
          await this.__setupWebGLLayer(session, callbackOnXrSessionStart);
          this.__requestedToEnterWebAR = true;
          System.restartRenderLoop();
          Logger.warn("End of enterWebXR.");
          return;
        } else {
          Logger.error("WebGL context or WebXRSession is not ready yet.");
          return;
        }
      }
      async __setupWebGLLayer(xrSession, callbackOnXrSessionStart) {
        const gl = this.__oGlw.unwrapForce().getRawContext();
        if (gl != null) {
          await gl.makeXRCompatible();
          if (typeof window === "undefined") {
            throw new Error("This method works in Browser Environment");
          }
          this.__oWebglLayer = new Some(window.XRWebGLLayer(xrSession, gl));
          const webglLayer = this.__oWebglLayer.unwrapForce();
          xrSession.updateRenderState({
            baseLayer: webglLayer,
            depthNear: 0.1,
            depthFar: 1e4
          });
          const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
          this.__canvasWidthForAR = webglLayer.framebufferWidth;
          this.__canvasHeightForAR = webglLayer.framebufferHeight;
          Logger.info(this.__canvasWidthForAR.toString());
          Logger.info(this.__canvasHeightForAR.toString());
          webglResourceRepository.resizeCanvas(this.__canvasWidthForAR, this.__canvasHeightForAR);
          this.__isWebARMode = true;
          callbackOnXrSessionStart();
        } else {
          Logger.error("WebGL context is not ready for WebXR.");
        }
      }
      /**
      * Disable WebXR (Close the XrSession)
      */
      async exitWebAR() {
        if (this.__oArSession.has()) {
          await this.__oArSession.get().end();
        }
      }
      /// Getter Methods
      getCanvasWidthForVr() {
        return this.__canvasWidthForAR;
      }
      getCanvasHeightForVr() {
        return this.__canvasHeightForAR;
      }
      get viewMatrix() {
        return this._cameraEntity.getCamera().viewMatrix;
      }
      __updateView(xrFrame) {
        this.__oArViewerPose = new Some(xrFrame.getViewerPose(this.__oArReferenceSpace.unwrapForce()));
        this.__setCameraInfoFromXRViews(this.__oArViewerPose.unwrapForce());
      }
      __setCameraInfoFromXRViews(xrViewerPose) {
        if (Is.not.exist(xrViewerPose)) {
          Logger.warn("xrViewerPose not exist");
          return;
        }
        const xrView = xrViewerPose.views[0];
        if (Is.not.exist(xrView)) {
          return;
        }
        const orientation = xrViewerPose.transform.orientation;
        this.__viewerOrientation.x = orientation.x;
        this.__viewerOrientation.y = orientation.y;
        this.__viewerOrientation.z = orientation.z;
        this.__viewerOrientation.w = orientation.w;
        const m = MutableMatrix44.fromCopyFloat32ArrayColumnMajor(xrView == null ? void 0 : xrView.transform.matrix);
        const rotateMat = m;
        const scale = this.__viewerScale.x;
        const pos = xrView.transform.position;
        const translateScaled = MutableVector3.add(this.__defaultPositionInLocalSpaceMode, this.__viewerTranslate);
        const xrViewerPos = Vector3.fromCopyArray([
          pos.x,
          pos.y,
          pos.z
        ]);
        const translate = MutableVector3.add(this.__defaultPositionInLocalSpaceMode, this.__viewerTranslate).add(xrViewerPos);
        const viewerTranslateScaledX = translateScaled.x;
        const viewerTranslateScaledZ = translateScaled.z;
        const viewerTranslateX = translate.x;
        const viewerTranslateZ = translate.z;
        const viewerTransform = this._cameraEntity.getTransform();
        viewerTransform.localPosition = Vector3.fromCopyArray([
          viewerTranslateScaledX,
          0,
          viewerTranslateScaledZ
        ]);
        viewerTransform.localScale = Vector3.fromCopyArray([
          scale,
          scale,
          scale
        ]);
        viewerTransform.localEulerAngles = Vector3.fromCopyArray([
          0,
          this.__viewerAzimuthAngle.x,
          0
        ]);
        rotateMat.translateY = translate.y;
        rotateMat.translateX = translate.x - viewerTranslateX;
        rotateMat.translateZ = translate.z - viewerTranslateZ;
        rotateMat.translateY += xrViewerPos.y;
        rotateMat.translateX += xrViewerPos.x;
        rotateMat.translateZ += xrViewerPos.z;
        this._cameraEntity.getTransform().localMatrix = rotateMat;
      }
      get projectionMatrix() {
        const xrView = this.__oArViewerPose.unwrapForce().views[0];
        return MutableMatrix44.fromCopyFloat32ArrayColumnMajor(Is.exist(xrView) ? xrView.projectionMatrix : MutableMatrix44.identity()._v);
      }
      /**
      * Pre process for rendering
      * @internal
      * @param xrFrame XRFrame object
      */
      _preRender(time, xrFrame) {
        if (this.isWebARMode && this.__requestedToEnterWebAR && xrFrame != null) {
          this.__updateView(xrFrame);
        }
      }
      /**
      * Post process for rendering
      * @internal
      */
      _postRender() {
        if (this.isWebARMode) {
          const gl = this.__oGlw.unwrapForce().getRawContext();
        }
        if (this.requestedToEnterWebAR) {
        }
      }
      get isWebARMode() {
        return this.__isWebARMode;
      }
      get isReadyForWebAR() {
        return this.__isReadyForWebAR;
      }
      get requestedToEnterWebAR() {
        return this.__requestedToEnterWebAR;
      }
      get arSession() {
        return this.__oArSession.unwrapOrUndefined();
      }
      get framebuffer() {
        var _a40, _b;
        return (_b = (_a40 = this.__oArSession.unwrapOrUndefined()) == null ? void 0 : _a40.renderState.baseLayer) == null ? void 0 : _b.framebuffer;
      }
    };
    __name(_WebARSystem, "WebARSystem");
    __publicField(_WebARSystem, "__instance");
    WebARSystem = _WebARSystem;
  }
});

// src/xr/main.ts
var main_exports5 = {};
__export(main_exports5, {
  default: () => main_default4
});
var XR, main_default4, globalObj3;
var init_main5 = __esm({
  "src/xr/main.ts"() {
    "use strict";
    init_WebXRSystem();
    init_WebARSystem();
    XR = Object.freeze({
      WebXRSystem,
      WebARSystem
    });
    main_default4 = XR;
    globalObj3 = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : void 0;
    globalObj3.RnXR = XR;
  }
});

// src/foundation/system/ModuleManager.ts
var _ModuleManager, ModuleManager;
var init_ModuleManager = __esm({
  "src/foundation/system/ModuleManager.ts"() {
    "use strict";
    _ModuleManager = class _ModuleManager {
      constructor() {
        __publicField(this, "__modules", /* @__PURE__ */ new Map());
      }
      /* eslint-disable prettier/prettier */
      async loadModule(moduleName, options) {
        let module;
        if (moduleName.toLowerCase() === "webgl") {
          module = await (await Promise.resolve().then(() => (init_main(), main_exports))).default;
        } else if (moduleName.toLowerCase() === "webgpu") {
          module = await (await Promise.resolve().then(() => (init_main2(), main_exports2))).default;
        } else if (moduleName.toLowerCase() === "effekseer") {
          module = await (await Promise.resolve().then(() => (init_main3(), main_exports3))).Effekseer;
          module.EffekseerComponent.wasmModuleUri = options == null ? void 0 : options.wasm;
        } else if (moduleName.toLowerCase() === "pbr") {
          module = await (await Promise.resolve().then(() => (init_main4(), main_exports4))).default;
        } else if (moduleName.toLowerCase() === "xr") {
          module = await (await Promise.resolve().then(() => (init_main5(), main_exports5))).default;
        }
        this.__modules.set(moduleName, module);
        return module;
      }
      getModule(moduleName) {
        return this.__modules.get(moduleName);
      }
      static getInstance() {
        if (!this.__instance) {
          this.__instance = new _ModuleManager();
        }
        return this.__instance;
      }
    };
    __name(_ModuleManager, "ModuleManager");
    __publicField(_ModuleManager, "__instance");
    ModuleManager = _ModuleManager;
  }
});

// src/foundation/renderer/CGAPIResourceRepository.ts
var _CGAPIResourceRepository, CGAPIResourceRepository;
var init_CGAPIResourceRepository = __esm({
  "src/foundation/renderer/CGAPIResourceRepository.ts"() {
    "use strict";
    init_ModuleManager();
    init_SystemState();
    init_definitions();
    _CGAPIResourceRepository = class _CGAPIResourceRepository {
      static getCgApiResourceRepository() {
        const moduleName = ProcessApproach.isWebGL2Approach(SystemState.currentProcessApproach) ? "webgl" : "webgpu";
        const moduleManager = ModuleManager.getInstance();
        const cgApiModule = moduleManager.getModule(moduleName);
        if (moduleName === "webgl") {
          const webGLResourceRepository = cgApiModule.WebGLResourceRepository.getInstance();
          return webGLResourceRepository;
        } else {
          const webGLResourceRepository = cgApiModule == null ? void 0 : cgApiModule.WebGpuResourceRepository.getInstance();
          return webGLResourceRepository;
        }
      }
      static getWebGLResourceRepository() {
        const moduleName = "webgl";
        const moduleManager = ModuleManager.getInstance();
        const webglModule = moduleManager.getModule(moduleName);
        const webGLResourceRepository = webglModule.WebGLResourceRepository.getInstance();
        return webGLResourceRepository;
      }
      static getWebGpuResourceRepository() {
        const moduleName = "webgpu";
        const moduleManager = ModuleManager.getInstance();
        const webgpuModule = moduleManager.getModule(moduleName);
        const webGpuResourceRepository = webgpuModule.WebGpuResourceRepository.getInstance();
        return webGpuResourceRepository;
      }
    };
    __name(_CGAPIResourceRepository, "CGAPIResourceRepository");
    __publicField(_CGAPIResourceRepository, "InvalidCGAPIResourceUid", -1);
    CGAPIResourceRepository = _CGAPIResourceRepository;
  }
});

// src/foundation/core/GlobalDataRepository.ts
var _GlobalDataRepository, GlobalDataRepository;
var init_GlobalDataRepository = __esm({
  "src/foundation/core/GlobalDataRepository.ts"() {
    "use strict";
    init_BufferUse();
    init_MemoryManager();
    init_CompositionType();
    init_ComponentType();
    init_MathClassUtil();
    init_CGAPIResourceRepository();
    init_ShaderType();
    init_VectorN();
    init_Config();
    init_Scalar();
    init_Vector4();
    init_Vector3();
    init_MutableMatrix44();
    init_WellKnownComponentTIDs();
    init_BoneDataType();
    init_ProcessApproach();
    init_ShaderSemanticsInfo();
    init_math();
    _GlobalDataRepository = class _GlobalDataRepository {
      constructor() {
        __publicField(this, "__fields", /* @__PURE__ */ new Map());
      }
      /**
      * Initialize the GlobalDataRepository
      * @param approach - ProcessApproachEnum for initialization
      */
      initialize(approach) {
        const currentComponentSIDsInfo = {
          semantic: "currentComponentSIDs",
          compositionType: CompositionType.ScalarArray,
          componentType: ComponentType.Float,
          arrayLength: WellKnownComponentTIDs.maxWellKnownTidNumber,
          stage: ShaderType.VertexAndPixelShader,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: true,
          needUniformInDataTextureMode: true,
          initialValue: new VectorN(new Float32Array(WellKnownComponentTIDs.maxWellKnownTidNumber))
        };
        this.__registerProperty(currentComponentSIDsInfo, 1);
        this.takeOne("currentComponentSIDs");
        const viewMatrixInfo = {
          semantic: "viewMatrix",
          compositionType: CompositionType.Mat4,
          componentType: ComponentType.Float,
          stage: ShaderType.VertexAndPixelShader,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: true,
          initialValue: MutableMatrix44.identity()
        };
        const projectionMatrixInfo = {
          semantic: "projectionMatrix",
          compositionType: CompositionType.Mat4,
          componentType: ComponentType.Float,
          stage: ShaderType.VertexAndPixelShader,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: true,
          initialValue: MutableMatrix44.identity()
        };
        const viewPositionInfo = {
          semantic: "viewPosition",
          compositionType: CompositionType.Vec3,
          componentType: ComponentType.Float,
          stage: ShaderType.VertexAndPixelShader,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: true,
          initialValue: Vector3.fromCopyArray([
            0,
            0,
            1
          ])
        };
        this.__registerProperty(viewMatrixInfo, Config.maxCameraNumber);
        this.__registerProperty(projectionMatrixInfo, Config.maxCameraNumber);
        this.__registerProperty(viewPositionInfo, Config.maxCameraNumber);
        const maxSkeletalBoneNumber2 = ProcessApproach.isUniformApproach(approach) ? Config.maxSkeletalBoneNumberForUniformMode : Config.maxSkeletalBoneNumber;
        const boneMatrixInfo = {
          semantic: "boneMatrix",
          compositionType: CompositionType.Mat4x3Array,
          arrayLength: maxSkeletalBoneNumber2,
          componentType: ComponentType.Float,
          stage: ShaderType.VertexShader,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: true,
          soloDatum: true,
          initialValue: new VectorN(new Float32Array(0))
        };
        const boneQuaternionInfo = {
          semantic: "boneQuaternion",
          compositionType: CompositionType.Vec4Array,
          arrayLength: maxSkeletalBoneNumber2,
          componentType: ComponentType.Float,
          stage: ShaderType.VertexShader,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: true,
          soloDatum: true,
          initialValue: new VectorN(new Float32Array(0))
        };
        const boneTranslateScaleInfo = {
          semantic: "boneTranslateScale",
          compositionType: CompositionType.Vec4Array,
          arrayLength: maxSkeletalBoneNumber2,
          componentType: ComponentType.Float,
          soloDatum: true,
          stage: ShaderType.VertexShader,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: true,
          initialValue: new VectorN(new Float32Array(0))
        };
        const boneTranslatePackedQuatInfo = {
          semantic: "boneTranslatePackedQuat",
          compositionType: CompositionType.Vec4Array,
          arrayLength: maxSkeletalBoneNumber2,
          componentType: ComponentType.Float,
          stage: ShaderType.VertexShader,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: true,
          soloDatum: true,
          initialValue: new VectorN(new Float32Array(0))
        };
        const boneScalePackedQuatInfo = {
          semantic: "boneScalePackedQuat",
          compositionType: CompositionType.Vec4Array,
          arrayLength: maxSkeletalBoneNumber2,
          componentType: ComponentType.Float,
          soloDatum: true,
          stage: ShaderType.VertexShader,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: true,
          initialValue: new VectorN(new Float32Array(0))
        };
        const boneCompressedChunkInfo = {
          semantic: "boneCompressedChunk",
          compositionType: CompositionType.Vec4Array,
          arrayLength: maxSkeletalBoneNumber2,
          componentType: ComponentType.Float,
          soloDatum: true,
          stage: ShaderType.VertexShader,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: true,
          initialValue: new VectorN(new Float32Array(0))
        };
        const boneCompressedInfoInfo = {
          semantic: "boneCompressedInfo",
          compositionType: CompositionType.Vec4,
          componentType: ComponentType.Float,
          soloDatum: true,
          stage: ShaderType.VertexShader,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: true,
          initialValue: Vector4.zero()
        };
        const skeletalComponentSIDInfo = {
          semantic: "skinningMode",
          compositionType: CompositionType.Scalar,
          componentType: ComponentType.Int,
          stage: ShaderType.VertexAndPixelShader,
          min: 0,
          max: 1,
          isInternalSetting: true,
          initialValue: Scalar2.fromCopyNumber(-1)
        };
        if (Config.boneDataType === BoneDataType.Mat43x1) {
          this.__registerProperty(boneMatrixInfo, Config.maxSkeletonNumber);
        } else if (Config.boneDataType === BoneDataType.Vec4x2) {
          this.__registerProperty(boneTranslatePackedQuatInfo, Config.maxSkeletonNumber);
          this.__registerProperty(boneScalePackedQuatInfo, Config.maxSkeletonNumber);
        } else if (Config.boneDataType === BoneDataType.Vec4x2Old) {
          this.__registerProperty(boneQuaternionInfo, Config.maxSkeletonNumber);
          this.__registerProperty(boneTranslateScaleInfo, Config.maxSkeletonNumber);
        } else if (Config.boneDataType === BoneDataType.Vec4x1) {
          this.__registerProperty(boneTranslateScaleInfo, Config.maxSkeletonNumber);
          this.__registerProperty(boneCompressedChunkInfo, Config.maxSkeletonNumber);
          this.__registerProperty(boneCompressedInfoInfo, 1);
          this.takeOne("boneCompressedInfo");
        }
        this.__registerProperty(skeletalComponentSIDInfo, 1);
        this.takeOne("skinningMode");
        const lightPositionInfo = {
          semantic: "lightPosition",
          compositionType: CompositionType.Vec3Array,
          componentType: ComponentType.Float,
          stage: ShaderType.VertexAndPixelShader,
          arrayLength: Config.maxLightNumberInShader,
          min: -Number.MAX_VALUE,
          max: Number.MAX_VALUE,
          isInternalSetting: true,
          initialValue: new VectorN(new Float32Array(Config.maxLightNumberInShader))
        };
        const lightDirectionInfo = {
          semantic: "lightDirection",
          compositionType: CompositionType.Vec3Array,
          componentType: ComponentType.Float,
          stage: ShaderType.PixelShader,
          arrayLength: Config.maxLightNumberInShader,
          min: -1,
          max: 1,
          isInternalSetting: true,
          initialValue: new VectorN(new Float32Array(Config.maxLightNumberInShader))
        };
        const lightIntensityInfo = {
          semantic: "lightIntensity",
          compositionType: CompositionType.Vec3Array,
          componentType: ComponentType.Float,
          stage: ShaderType.PixelShader,
          arrayLength: Config.maxLightNumberInShader,
          min: 0,
          max: 10,
          isInternalSetting: true,
          initialValue: new VectorN(new Float32Array(Config.maxLightNumberInShader))
        };
        const lightPropertyInfo = {
          semantic: "lightProperty",
          compositionType: CompositionType.Vec4Array,
          componentType: ComponentType.Float,
          stage: ShaderType.PixelShader,
          arrayLength: Config.maxLightNumberInShader,
          min: 0,
          max: 10,
          isInternalSetting: true,
          initialValue: new VectorN(new Float32Array(Config.maxLightNumberInShader))
        };
        this.__registerProperty(lightPositionInfo, 1);
        this.__registerProperty(lightDirectionInfo, 1);
        this.__registerProperty(lightIntensityInfo, 1);
        this.__registerProperty(lightPropertyInfo, 1);
        this.takeOne("lightDirection");
        this.takeOne("lightIntensity");
        this.takeOne("lightPosition");
        this.takeOne("lightProperty");
        const lightNumberInfo = {
          semantic: "lightNumber",
          compositionType: CompositionType.Scalar,
          componentType: ComponentType.Int,
          stage: ShaderType.VertexAndPixelShader,
          min: 0,
          max: Number.MAX_SAFE_INTEGER,
          isInternalSetting: true,
          initialValue: Scalar2.fromCopyNumber(0)
        };
        this.__registerProperty(lightNumberInfo, 1);
        this.takeOne("lightNumber");
        const backBufferTextureSize = {
          semantic: "backBufferTextureSize",
          compositionType: CompositionType.Vec2,
          componentType: ComponentType.Float,
          stage: ShaderType.PixelShader,
          min: 0,
          max: Number.MAX_SAFE_INTEGER,
          isInternalSetting: true,
          needUniformInDataTextureMode: true,
          initialValue: Vector2.fromCopy2(0, 0)
        };
        this.__registerProperty(backBufferTextureSize, 1);
        this.takeOne("backBufferTextureSize");
        const vrState = {
          semantic: "vrState",
          compositionType: CompositionType.Vec2,
          componentType: ComponentType.Int,
          stage: ShaderType.PixelShader,
          min: 0,
          max: Number.MAX_SAFE_INTEGER,
          isInternalSetting: true,
          needUniformInDataTextureMode: true,
          initialValue: Vector2.fromCopy2(0, 0)
        };
        this.__registerProperty(vrState, 1);
        this.takeOne("vrState");
        const timeInfo = {
          semantic: "time",
          compositionType: CompositionType.Scalar,
          componentType: ComponentType.Float,
          stage: ShaderType.VertexAndPixelShader,
          min: 0,
          max: Number.MAX_SAFE_INTEGER,
          isInternalSetting: true,
          initialValue: Scalar2.fromCopyNumber(0)
        };
        this.__registerProperty(timeInfo, 1);
        this.takeOne("time");
      }
      static getInstance() {
        if (!this.__instance) {
          this.__instance = new _GlobalDataRepository();
        }
        return this.__instance;
      }
      __registerProperty(semanticInfo, maxCount) {
        const buffer = MemoryManager.getInstance().createOrGetBuffer(BufferUse.GPUInstanceData);
        const alignedByteLength = calcAlignedByteLength(semanticInfo);
        const bufferView = buffer.takeBufferView({
          byteLengthToNeed: alignedByteLength * maxCount,
          byteStride: 0
        }).unwrapForce();
        let maxArrayLength = semanticInfo.arrayLength;
        if (CompositionType.isArray(semanticInfo.compositionType) && maxArrayLength == null) {
          maxArrayLength = 100;
        }
        const accessor = bufferView.takeAccessor({
          compositionType: semanticInfo.compositionType,
          componentType: ComponentType.Float,
          count: maxCount,
          byteStride: alignedByteLength,
          arrayLength: maxArrayLength
        }).unwrapForce();
        const globalPropertyStruct = {
          shaderSemanticsInfo: semanticInfo,
          values: [],
          maxCount,
          accessor
        };
        this.__fields.set(semanticInfo.semantic, globalPropertyStruct);
      }
      takeOne(shaderSemantic) {
        const globalPropertyStruct = this.__fields.get(shaderSemantic);
        if (globalPropertyStruct) {
          const semanticInfo = globalPropertyStruct.shaderSemanticsInfo;
          const typedArray = globalPropertyStruct.accessor.takeOne();
          const countIndex = globalPropertyStruct.values.length;
          const valueObj = MathClassUtil.initWithFloat32Array(semanticInfo.initialValue, semanticInfo.initialValue, typedArray, semanticInfo.compositionType);
          globalPropertyStruct.values[countIndex] = valueObj;
          return valueObj;
        }
        return void 0;
      }
      setValue(shaderSemantic, countIndex, value) {
        const globalPropertyStruct = this.__fields.get(shaderSemantic);
        if (globalPropertyStruct) {
          const valueObj = globalPropertyStruct.values[countIndex];
          MathClassUtil._setForce(valueObj, value);
        }
      }
      getValue(shaderSemantic, countIndex) {
        const globalPropertyStruct = this.__fields.get(shaderSemantic);
        if (globalPropertyStruct) {
          const valueObj = globalPropertyStruct.values[countIndex];
          return valueObj;
        }
        return void 0;
      }
      getGlobalPropertyStruct(propertyName) {
        return this.__fields.get(propertyName);
      }
      getGlobalProperties() {
        return Array.from(this.__fields.values());
      }
      _setUniformLocationsForUniformModeOnly(shaderProgramUid) {
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        const semanticsInfoArray = [];
        this.__fields.forEach((globalPropertyStruct, key) => {
          const semanticInfo = globalPropertyStruct.shaderSemanticsInfo;
          semanticsInfoArray.push(semanticInfo);
        });
        webglResourceRepository.setupUniformLocations(shaderProgramUid, semanticsInfoArray, true);
      }
      _setUniformLocationsForDataTextureModeOnly(shaderProgramUid) {
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        const semanticsInfoArray = [];
        this.__fields.forEach((globalPropertyStruct, key) => {
          const semanticInfo = globalPropertyStruct.shaderSemanticsInfo;
          if (semanticInfo.needUniformInDataTextureMode) {
            semanticsInfoArray.push(semanticInfo);
          }
        });
        webglResourceRepository.setupUniformLocations(shaderProgramUid, semanticsInfoArray, true);
      }
      setUniformValues(shaderProgram) {
        const webglResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
        this.__fields.forEach((globalPropertyStruct, key) => {
          const info = globalPropertyStruct.shaderSemanticsInfo;
          const values = globalPropertyStruct.values;
          for (let i2 = 0; i2 < values.length; i2++) {
            webglResourceRepository.setUniformValue(shaderProgram, info.semantic, true, values[i2]);
          }
        });
      }
      // getLocationOffsetOfProperty(propertyIndex: Index, countIndex: Index) {
      //   const globalPropertyStruct = this.__fields.get(propertyIndex);
      //   if (globalPropertyStruct) {
      //     const value = globalPropertyStruct.values[countIndex];
      //     return (value._v as Float32Array).byteOffset / 4 / 4;
      //   }
      //   return void 0;
      // }
      getLocationOffsetOfProperty(propertyName) {
        const globalPropertyStruct = this.__fields.get(propertyName);
        if (globalPropertyStruct) {
          return globalPropertyStruct.accessor.byteOffsetInBuffer / 4 / 4;
        }
        return -1;
      }
      getCurrentDataNumberOfTheProperty(propertyName) {
        const globalPropertyStruct = this.__fields.get(propertyName);
        if (globalPropertyStruct) {
          return globalPropertyStruct.values.length;
        }
        return 0;
      }
      _addPropertiesStr(vertexPropertiesStr, pixelPropertiesStr, propertySetter, isWebGL2) {
        this.__fields.forEach((globalPropertyStruct) => {
          const info = globalPropertyStruct.shaderSemanticsInfo;
          if (info.stage === ShaderType.VertexShader || info.stage === ShaderType.VertexAndPixelShader) {
            vertexPropertiesStr += propertySetter("", info, true, isWebGL2);
          }
          if (info.stage === ShaderType.PixelShader || info.stage === ShaderType.VertexAndPixelShader) {
            pixelPropertiesStr += propertySetter("", info, true, isWebGL2);
          }
        });
        return [
          vertexPropertiesStr,
          pixelPropertiesStr
        ];
      }
    };
    __name(_GlobalDataRepository, "GlobalDataRepository");
    __publicField(_GlobalDataRepository, "__instance");
    GlobalDataRepository = _GlobalDataRepository;
  }
});

// src/foundation/components/Camera/CameraComponent.ts
var _CameraComponent, CameraComponent;
var init_CameraComponent = __esm({
  "src/foundation/components/Camera/CameraComponent.ts"() {
    "use strict";
    init_ComponentRepository();
    init_Component();
    init_EntityRepository();
    init_WellKnownComponentTIDs();
    init_Vector3();
    init_Vector4();
    init_CameraType();
    init_Matrix44();
    init_BufferUse();
    init_ComponentType();
    init_MutableMatrix44();
    init_ProcessStage();
    init_MutableVector4();
    init_MutableVector3();
    init_Frustum();
    init_Config();
    init_GlobalDataRepository();
    init_MathUtil();
    init_ModuleManager();
    init_Is();
    init_LightType();
    init_SystemState();
    init_ProcessApproach();
    init_TransformComponent();
    init_CameraControllerComponent();
    _CameraComponent = class _CameraComponent extends Component {
      constructor(entityUid, componentSid, entityRepository, isReUse) {
        super(entityUid, componentSid, entityRepository, isReUse);
        __publicField(this, "_eyeInner", MutableVector3.dummy());
        __publicField(this, "_direction", MutableVector3.dummy());
        __publicField(this, "_directionInner", MutableVector3.dummy());
        __publicField(this, "_up", MutableVector3.dummy());
        __publicField(this, "_upInner", MutableVector3.dummy());
        __publicField(this, "_filmWidth", 36);
        __publicField(this, "_filmHeight", 24);
        __publicField(this, "_focalLength", 20);
        __publicField(this, "primitiveMode", false);
        // x: left, y:right, z:top, w: bottom
        __publicField(this, "_corner", MutableVector4.dummy());
        __publicField(this, "_cornerInner", MutableVector4.dummy());
        // x: zNear, y: zFar,
        // if perspective, z: fovy, w: aspect
        // if ortho, z: xmag, w: ymag
        __publicField(this, "_parameters", MutableVector4.dummy());
        __publicField(this, "_parametersInner", MutableVector4.dummy());
        __publicField(this, "__type", CameraType.Perspective);
        __publicField(this, "_projectionMatrix", MutableMatrix44.dummy());
        __publicField(this, "__isProjectionMatrixUpToDate", false);
        __publicField(this, "_viewMatrix", MutableMatrix44.dummy());
        __publicField(this, "__isViewMatrixUpToDate", false);
        __publicField(this, "_xrLeft", false);
        __publicField(this, "_xrRight", false);
        __publicField(this, "isSyncToLight", false);
        __publicField(this, "__frustum", new Frustum2());
        __publicField(this, "__updateCount", 0);
        __publicField(this, "__lastUpdateCount", -1);
        __publicField(this, "__lastTransformComponentsUpdateCount", -1);
        __publicField(this, "__lastLightComponentsUpdateCount", -1);
        __publicField(this, "__lastCameraControllerComponentsUpdateCount", -1);
        this._setMaxNumberOfComponent(Math.max(10, Math.floor(Config.maxEntityNumber / 100)));
        this.setFovyAndChangeFocalLength(90);
        if (_CameraComponent.current === -1) {
          _CameraComponent.current = componentSid;
        }
        this.registerMember(BufferUse.CPUGeneric, "eyeInner", MutableVector3, ComponentType.Float, [
          0,
          0,
          0
        ]);
        this.registerMember(BufferUse.CPUGeneric, "direction", MutableVector3, ComponentType.Float, [
          0,
          0,
          -1
        ]);
        this.registerMember(BufferUse.CPUGeneric, "up", MutableVector3, ComponentType.Float, [
          0,
          1,
          0
        ]);
        this.registerMember(BufferUse.CPUGeneric, "directionInner", MutableVector3, ComponentType.Float, [
          0,
          0,
          -1
        ]);
        this.registerMember(BufferUse.CPUGeneric, "upInner", MutableVector3, ComponentType.Float, [
          0,
          1,
          0
        ]);
        this.registerMember(BufferUse.CPUGeneric, "corner", MutableVector4, ComponentType.Float, [
          -1,
          1,
          1,
          -1
        ]);
        this.registerMember(BufferUse.CPUGeneric, "cornerInner", MutableVector4, ComponentType.Float, [
          -1,
          1,
          1,
          -1
        ]);
        this.registerMember(BufferUse.CPUGeneric, "parameters", MutableVector4, ComponentType.Float, [
          0.1,
          1e4,
          90,
          1
        ]);
        this.registerMember(BufferUse.CPUGeneric, "parametersInner", MutableVector4, ComponentType.Float, [
          0.1,
          1e4,
          90,
          1
        ]);
        this.registerMember(BufferUse.CPUGeneric, "projectionMatrix", MutableMatrix44, ComponentType.Float, [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
        this.registerMember(BufferUse.CPUGeneric, "viewMatrix", MutableMatrix44, ComponentType.Float, [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
        this.submitToAllocation(Config.maxCameraNumber, isReUse);
        if (isReUse) {
          return;
        }
        const globalDataRepository = GlobalDataRepository.getInstance();
        globalDataRepository.takeOne("viewMatrix");
        globalDataRepository.takeOne("projectionMatrix");
        globalDataRepository.takeOne("viewPosition");
      }
      static set current(componentSID) {
        this.__current = componentSID;
      }
      static get current() {
        return this.__current;
      }
      get updateCount() {
        return this.__updateCount;
      }
      static get currentCameraUpdateCount() {
        var _a40;
        const currentCameraComponent = ComponentRepository.getComponent(_CameraComponent, _CameraComponent.current);
        return (_a40 = currentCameraComponent == null ? void 0 : currentCameraComponent.updateCount) != null ? _a40 : 0;
      }
      set type(type) {
        this.__type = type;
        if (type === CameraType.Orthographic) {
          this._parameters.z = 1;
          this._parameters.w = 1;
          this._parametersInner.z = 1;
          this._parametersInner.w = 1;
        } else {
          this.setFovyAndChangeFocalLength(90);
          this._parameters.w = 1;
          this._parametersInner.z = 90;
          this._parametersInner.w = 1;
        }
        this.__updateCount++;
      }
      get type() {
        return this.__type;
      }
      get eye() {
        return _CameraComponent._eye;
      }
      set eye(noUseVec) {
        throw Error("In Rhodonite, eye is always (0,0,0). Use TransformComponent for Camera positioning.");
      }
      get eyeInner() {
        return this._eyeInner;
      }
      /**
      * @internal
      */
      set eyeInner(vec) {
        this._eyeInner.copyComponents(vec);
        this.__updateCount++;
      }
      set upInner(vec) {
        this._upInner.copyComponents(vec);
        this.__updateCount++;
      }
      set up(vec) {
        this._up.copyComponents(vec);
        this.__updateCount++;
      }
      get up() {
        return this._up.clone();
      }
      get upInner() {
        return this._upInner;
      }
      set direction(vec) {
        const oldDirection = this._direction;
        const newDirection = vec;
        const oldUp = this._up;
        const orthogonalVectorNewDirectionAndOldUp = MutableVector3.crossTo(newDirection, oldUp, _CameraComponent.__tmpVector3_0);
        const isOrthogonalNewDirectionAndOldUp = orthogonalVectorNewDirectionAndOldUp.length() === 0;
        let newUpNonNormalize;
        if (isOrthogonalNewDirectionAndOldUp) {
          const relativeXaxis = MutableVector3.crossTo(oldDirection, oldUp, _CameraComponent.__tmpVector3_1);
          newUpNonNormalize = MutableVector3.crossTo(relativeXaxis, newDirection, _CameraComponent.__tmpVector3_2);
        } else {
          const newDirectionComponentInOldUp = MutableVector3.multiplyTo(newDirection, newDirection.dot(oldUp), _CameraComponent.__tmpVector3_1);
          newUpNonNormalize = MutableVector3.subtractTo(oldUp, newDirectionComponentInOldUp, _CameraComponent.__tmpVector3_2);
        }
        this._up.copyComponents(newUpNonNormalize).normalize();
        this._direction.copyComponents(newDirection);
        this.__updateCount++;
      }
      set directionInner(vec) {
        this._directionInner.copyComponents(vec);
        this.__updateCount++;
      }
      get direction() {
        return this._direction.clone();
      }
      get directionInner() {
        return this._directionInner;
      }
      set corner(vec) {
        this._corner.copyComponents(vec);
        this.__updateCount++;
      }
      get corner() {
        return this._corner.clone();
      }
      set left(value) {
        this._corner.x = value;
        this.__updateCount++;
      }
      set leftInner(value) {
        this._cornerInner.x = value;
        this.__updateCount++;
      }
      get left() {
        return this._corner.x;
      }
      set right(value) {
        this._corner.y = value;
        this.__updateCount++;
      }
      set rightInner(value) {
        this._cornerInner.y = value;
        this.__updateCount++;
      }
      get right() {
        return this._corner.y;
      }
      set top(value) {
        this._corner.z = value;
        this.__updateCount++;
      }
      set topInner(value) {
        this._cornerInner.z = value;
        this.__updateCount++;
      }
      get top() {
        return this._corner.z;
      }
      set bottom(value) {
        this._corner.w = value;
        this.__updateCount++;
      }
      set bottomInner(value) {
        this._cornerInner.w = value;
        this.__updateCount++;
      }
      get bottom() {
        return this._corner.w;
      }
      set cornerInner(vec) {
        this._cornerInner.copyComponents(vec);
        this.__updateCount++;
      }
      get cornerInner() {
        return this._cornerInner;
      }
      // set parameters(vec: Vector4) {
      //   this._parameters.copyComponents(vec);
      // }
      set parametersInner(vec) {
        this._parametersInner.copyComponents(vec);
        this.__updateCount++;
      }
      get parametersInner() {
        return this._parametersInner;
      }
      get parameters() {
        return this._parameters.clone();
      }
      set zNear(val) {
        this._parameters.x = val;
        this.__updateCount++;
      }
      set zNearInner(val) {
        this._parametersInner.x = val;
        this.__updateCount++;
      }
      get zNearInner() {
        return this._parametersInner.x;
      }
      get zNear() {
        return this._parameters.x;
      }
      set focalLength(val) {
        this._focalLength = val;
        this._parameters.z = 2 * MathUtil.radianToDegree(Math.atan(this._filmHeight / (val * 2)));
        this.__updateCount++;
      }
      get focalLength() {
        return this._focalLength;
      }
      set focalLengthInner(val) {
        this._parametersInner.z = 2 * MathUtil.radianToDegree(Math.atan(this._filmHeight / (val * 2)));
        this.__updateCount++;
      }
      get focalLengthInner() {
        return this._parametersInner.z;
      }
      set zFar(val) {
        this._parameters.y = val;
        this.__updateCount++;
      }
      set zFarInner(val) {
        this._parametersInner.y = val;
        this.__updateCount++;
      }
      get zFarInner() {
        return this._parametersInner.y;
      }
      get zFar() {
        return this._parameters.y;
      }
      setFovyAndChangeFilmSize(degree) {
        this._parameters.z = degree;
        this._filmHeight = 2 * this.focalLength * Math.tan(MathUtil.degreeToRadian(degree) / 2);
        this._filmWidth = this._filmHeight * this.aspect;
        this.__updateCount++;
      }
      setFovyAndChangeFocalLength(degree) {
        this._parameters.z = degree;
        this._focalLength = this._filmHeight / 2 / Math.tan(MathUtil.degreeToRadian(degree) / 2);
        this.__updateCount++;
      }
      get fovy() {
        return this._parameters.z;
      }
      set fovyInner(val) {
        this._parametersInner.z = val;
        this.__updateCount++;
      }
      set aspect(val) {
        this._parameters.w = val;
        this._filmWidth = this._filmHeight * val;
        this.__updateCount++;
      }
      set aspectInner(val) {
        this._parametersInner.w = val;
        this.__updateCount++;
      }
      get aspectInner() {
        return this._parametersInner.w;
      }
      get aspect() {
        return this._parameters.w;
      }
      set xMag(val) {
        this._parameters.z = val;
        this.__updateCount++;
      }
      get xMag() {
        return this._parameters.z;
      }
      set yMag(val) {
        this._parameters.w = val;
      }
      get yMag() {
        return this._parameters.w;
      }
      static get componentTID() {
        return WellKnownComponentTIDs.CameraComponentTID;
      }
      get componentTID() {
        return WellKnownComponentTIDs.CameraComponentTID;
      }
      calcProjectionMatrix() {
        const zNear = this._parametersInner.x;
        const zFar = this._parametersInner.y;
        if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
          if (this.type === CameraType.Perspective) {
            const fovy = this._parametersInner.z;
            let aspect = this._parametersInner.w;
            if (aspect < 0) {
              aspect = SystemState.viewportAspectRatio;
            }
            const yscale = 1 / Math.tan(0.5 * fovy * Math.PI / 180);
            const xscale = yscale / aspect;
            this._projectionMatrix.m00 = xscale;
            this._projectionMatrix.m01 = 0;
            this._projectionMatrix.m02 = 0;
            this._projectionMatrix.m03 = 0;
            this._projectionMatrix.m10 = 0;
            this._projectionMatrix.m11 = yscale;
            this._projectionMatrix.m12 = 0;
            this._projectionMatrix.m13 = 0;
            this._projectionMatrix.m20 = 0;
            this._projectionMatrix.m21 = 0;
            if (zFar === Infinity) {
              this._projectionMatrix.m22 = -1;
              this._projectionMatrix.m23 = -zNear;
            } else {
              const nf = 1 / (zNear - zFar);
              this._projectionMatrix.m22 = zFar * nf;
              this._projectionMatrix.m23 = zFar * zNear * nf;
            }
            this._projectionMatrix.m30 = 0;
            this._projectionMatrix.m31 = 0;
            this._projectionMatrix.m32 = -1;
            this._projectionMatrix.m33 = 0;
          } else if (this.type === CameraType.Orthographic) {
            const xmag = this._parametersInner.z;
            const ymag = this._parametersInner.w;
            this._projectionMatrix.setComponents(1 / xmag, 0, 0, 0, 0, 1 / ymag, 0, 0, 0, 0, -1 / (zFar - zNear), -zNear / (zFar - zNear), 0, 0, 0, 1);
          } else {
            const left = this._cornerInner.x;
            const right = this._cornerInner.y;
            const top = this._cornerInner.z;
            const bottom = this._cornerInner.w;
            const nf = 1 / (zNear - zFar);
            this._projectionMatrix.setComponents(2 * zNear / (right - left), 0, (right + left) / (right - left), 0, 0, 2 * zNear / (top - bottom), (top + bottom) / (top - bottom), 0, 0, 0, zFar * nf, zFar * zNear * nf, 0, 0, -1, 0);
          }
        } else {
          if (this.type === CameraType.Perspective) {
            const fovy = this._parametersInner.z;
            let aspect = this._parametersInner.w;
            if (aspect < 0) {
              aspect = SystemState.viewportAspectRatio;
            }
            const yscale = 1 / Math.tan(0.5 * fovy * Math.PI / 180);
            const xscale = yscale / aspect;
            this._projectionMatrix.m00 = xscale;
            this._projectionMatrix.m01 = 0;
            this._projectionMatrix.m02 = 0;
            this._projectionMatrix.m03 = 0;
            this._projectionMatrix.m10 = 0;
            this._projectionMatrix.m11 = yscale;
            this._projectionMatrix.m12 = 0;
            this._projectionMatrix.m13 = 0;
            this._projectionMatrix.m20 = 0;
            this._projectionMatrix.m21 = 0;
            if (zFar === Infinity) {
              this._projectionMatrix.m22 = -1;
              this._projectionMatrix.m23 = -2 * zNear;
            } else {
              const nf = 1 / (zNear - zFar);
              this._projectionMatrix.m22 = (zFar + zNear) * nf;
              this._projectionMatrix.m23 = 2 * zFar * zNear * nf;
            }
            this._projectionMatrix.m30 = 0;
            this._projectionMatrix.m31 = 0;
            this._projectionMatrix.m32 = -1;
            this._projectionMatrix.m33 = 0;
          } else if (this.type === CameraType.Orthographic) {
            const xmag = this._parametersInner.z;
            const ymag = this._parametersInner.w;
            this._projectionMatrix.setComponents(1 / xmag, 0, 0, 0, 0, 1 / ymag, 0, 0, 0, 0, -2 / (zFar - zNear), -(zFar + zNear) / (zFar - zNear), 0, 0, 0, 1);
          } else {
            const left = this._cornerInner.x;
            const right = this._cornerInner.y;
            const top = this._cornerInner.z;
            const bottom = this._cornerInner.w;
            const nf = 1 / (zNear - zFar);
            this._projectionMatrix.setComponents(2 * zNear / (right - left), 0, (right + left) / (right - left), 0, 0, 2 * zNear / (top - bottom), (top + bottom) / (top - bottom), 0, 0, 0, (zFar + zNear) * nf, 2 * zFar * zNear * nf, 0, 0, -1, 0);
          }
        }
        return this._projectionMatrix;
      }
      calcViewMatrix() {
        const eye = this.eyeInner;
        const f2 = MutableVector3.subtractTo(this._directionInner, eye, _CameraComponent.__tmpVector3_0).normalize();
        const s2 = MutableVector3.crossTo(f2, this._upInner, _CameraComponent.__tmpVector3_1).normalize();
        const u = MutableVector3.crossTo(s2, f2, _CameraComponent.__tmpVector3_2);
        this._viewMatrix.setComponents(s2.x, s2.y, s2.z, -Vector3.dot(s2, eye), u.x, u.y, u.z, -Vector3.dot(u, eye), -f2.x, -f2.y, -f2.z, Vector3.dot(f2, eye), 0, 0, 0, 1);
        if (!this.primitiveMode) {
          const invertWorldMatrix = MutableMatrix44.invertTo(this.entity.getSceneGraph().matrixInner, _CameraComponent.__tmpMatrix44_0);
          this._viewMatrix.multiply(invertWorldMatrix);
        }
        return this._viewMatrix;
      }
      get viewMatrix() {
        return this._viewMatrix;
      }
      set viewMatrix(viewMatrix) {
        this._viewMatrix.copyComponents(viewMatrix);
        this.__updateCount++;
      }
      get projectionMatrix() {
        if (this._xrLeft || this._xrRight) {
          const rnXRModule = ModuleManager.getInstance().getModule("xr");
          if (rnXRModule == null ? void 0 : rnXRModule.WebXRSystem.getInstance().isWebXRMode) {
            const webXRSystem = rnXRModule.WebXRSystem.getInstance();
            if (this._xrLeft) {
              return webXRSystem.leftProjectionMatrix;
            } else if (this._xrRight) {
              return webXRSystem.rightProjectionMatrix;
            }
          }
        }
        return this._projectionMatrix;
      }
      set projectionMatrix(projectionMatrix) {
        this._projectionMatrix.copyComponents(projectionMatrix);
        this.__updateCount++;
      }
      get viewProjectionMatrix() {
        return MutableMatrix44.multiplyTo(this._projectionMatrix, this._viewMatrix, _CameraComponent.__tmpMatrix44_0);
      }
      get biasViewProjectionMatrix() {
        MutableMatrix44.multiplyTo(this._projectionMatrix, this._viewMatrix, _CameraComponent.__tmpMatrix44_0);
        return MutableMatrix44.multiplyTo(_CameraComponent.__biasMatrix, _CameraComponent.__tmpMatrix44_0, _CameraComponent.__tmpMatrix44_1);
      }
      setValuesToGlobalDataRepositoryOnlyMatrices() {
        _CameraComponent.__globalDataRepository.setValue("viewMatrix", this.componentSID, this.viewMatrix);
        _CameraComponent.__globalDataRepository.setValue("projectionMatrix", this.componentSID, this.projectionMatrix);
      }
      setValuesToGlobalDataRepository() {
        _CameraComponent.__globalDataRepository.setValue("viewMatrix", this.componentSID, this.viewMatrix);
        _CameraComponent.__globalDataRepository.setValue("projectionMatrix", this.componentSID, this.projectionMatrix);
        _CameraComponent.__globalDataRepository.setValue("viewPosition", this.componentSID, this.worldPosition);
      }
      get worldPosition() {
        this.entity.getSceneGraph().matrixInner.multiplyVector3To(this.eyeInner, _CameraComponent.returnVector3);
        return _CameraComponent.returnVector3;
      }
      updateFrustum() {
        this.__frustum.update(this.viewMatrix, this.projectionMatrix);
      }
      get frustum() {
        return this.__frustum;
      }
      $load() {
        this.moveStageTo(ProcessStage.Logic);
      }
      $logic() {
        const lightComponent = this.entity.tryToGetLight();
        let lightComponentUpdateCount = lightComponent != null ? lightComponent.updateCount : -1;
        if (this.__lastUpdateCount === this.__updateCount && this.__lastTransformComponentsUpdateCount === TransformComponent.updateCount && this.__lastLightComponentsUpdateCount === lightComponentUpdateCount && this.__lastCameraControllerComponentsUpdateCount === CameraControllerComponent.updateCount) {
          return;
        }
        if (this.isSyncToLight && Is.exist(lightComponent)) {
          this._eyeInner.copyComponents(_CameraComponent._eye);
          this._directionInner.copyComponents(this._direction);
          this._upInner.copyComponents(this._up);
          if (lightComponent.type === LightType.Spot) {
            this.type = CameraType.Perspective;
            this.setFovyAndChangeFilmSize(MathUtil.radianToDegree(lightComponent.outerConeAngle));
            this._cornerInner.copyComponents(this._corner);
            this.aspect = 1;
            this.zNear = 0.1;
            this.zFar = lightComponent.range !== -1 ? lightComponent.range : 1e4;
            this._parametersInner.copyComponents(this._parameters);
          } else if (lightComponent.type === LightType.Directional) {
            this.type = CameraType.Orthographic;
            const areaSize = lightComponent.shadowAreaSizeForDirectionalLight;
            this._cornerInner.copyComponents(Vector4.fromCopy4(-areaSize, areaSize, areaSize, -areaSize));
            this.aspect = 1;
            this.zNear = 0.1;
            this.zFar = lightComponent.range !== -1 ? lightComponent.range : 100;
            this._parametersInner.copyComponents(this._parameters);
          }
        } else {
          const cameraControllerComponent = this.entity.tryToGetCameraController();
          if (Is.exist(cameraControllerComponent)) {
            this._parametersInner.w = this._parameters.w;
          } else {
            if (!this.primitiveMode) {
              this._eyeInner.copyComponents(_CameraComponent._eye);
              this._directionInner.copyComponents(this._direction);
              this._upInner.copyComponents(this._up);
              this._cornerInner.copyComponents(this._corner);
              this._parametersInner.copyComponents(this._parameters);
            }
          }
        }
        this.calcViewMatrix();
        if (!this._xrLeft && !this._xrRight) {
          this.calcProjectionMatrix();
        }
        this.setValuesToGlobalDataRepository();
        this.__lastUpdateCount = this.__updateCount;
        this.__lastTransformComponentsUpdateCount = TransformComponent.updateCount;
        this.__lastLightComponentsUpdateCount = lightComponentUpdateCount;
        this.__lastCameraControllerComponentsUpdateCount = CameraControllerComponent.updateCount;
      }
      static getCurrentCameraEntity() {
        const currentCameraComponent = ComponentRepository.getComponent(this, this.current);
        return currentCameraComponent.entity;
      }
      /**
      * get the entity which has this component.
      * @returns the entity which has this component
      */
      get entity() {
        return EntityRepository.getEntity(this.__entityUid);
      }
      /**
      * @override
      * Add this component to the entity
      * @param base the target entity
      * @param _componentClass the component class to add
      */
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let CameraEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
          }
          getCamera() {
            return this.getComponentByComponentTID(WellKnownComponentTIDs.CameraComponentTID);
          }
        }, __name(_a40, "CameraEntity"), _a40);
        applyMixins(base, CameraEntity);
        return base;
      }
    };
    __name(_CameraComponent, "CameraComponent");
    __publicField(_CameraComponent, "_eye", Vector3.zero());
    __publicField(_CameraComponent, "__current", -1);
    __publicField(_CameraComponent, "returnVector3", MutableVector3.zero());
    __publicField(_CameraComponent, "__globalDataRepository", GlobalDataRepository.getInstance());
    __publicField(_CameraComponent, "__tmpVector3_0", MutableVector3.zero());
    __publicField(_CameraComponent, "__tmpVector3_1", MutableVector3.zero());
    __publicField(_CameraComponent, "__tmpVector3_2", MutableVector3.zero());
    __publicField(_CameraComponent, "__tmpMatrix44_0", MutableMatrix44.zero());
    __publicField(_CameraComponent, "__tmpMatrix44_1", MutableMatrix44.zero());
    __publicField(_CameraComponent, "__biasMatrix", Matrix44.fromCopy16ColumnMajor(0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1));
    CameraComponent = _CameraComponent;
  }
});

// src/foundation/components/Camera/ICameraEntity.ts
var init_ICameraEntity = __esm({
  "src/foundation/components/Camera/ICameraEntity.ts"() {
    "use strict";
  }
});

// src/foundation/components/Camera/index.ts
var init_Camera = __esm({
  "src/foundation/components/Camera/index.ts"() {
    "use strict";
    init_CameraComponent();
    init_ICameraEntity();
    init_createCameraEntity();
  }
});

// src/foundation/components/CameraController/ICameraControllerEntity.ts
var init_ICameraControllerEntity = __esm({
  "src/foundation/components/CameraController/ICameraControllerEntity.ts"() {
    "use strict";
  }
});

// src/foundation/components/CameraController/createCameraControllerEntity.ts
function createCameraControllerEntity() {
  const entity = createCameraEntity();
  const entityAddedComponent = EntityRepository.tryToAddComponentToEntityByTID(WellKnownComponentTIDs.CameraControllerComponentTID, entity);
  return entityAddedComponent;
}
var init_createCameraControllerEntity = __esm({
  "src/foundation/components/CameraController/createCameraControllerEntity.ts"() {
    "use strict";
    init_EntityRepository();
    init_createCameraEntity();
    init_WellKnownComponentTIDs();
    __name(createCameraControllerEntity, "createCameraControllerEntity");
  }
});

// src/foundation/components/CameraController/index.ts
var init_CameraController = __esm({
  "src/foundation/components/CameraController/index.ts"() {
    "use strict";
    init_CameraControllerComponent();
    init_ICameraControllerEntity();
    init_createCameraControllerEntity();
  }
});

// src/foundation/components/Light/ILightEntity.ts
var init_ILightEntity = __esm({
  "src/foundation/components/Light/ILightEntity.ts"() {
    "use strict";
  }
});

// src/foundation/components/Light/index.ts
var init_Light = __esm({
  "src/foundation/components/Light/index.ts"() {
    "use strict";
    init_ILightEntity();
    init_LightComponent();
    init_createLightEntity();
  }
});

// src/foundation/components/Mesh/IMeshEntity.ts
var init_IMeshEntity = __esm({
  "src/foundation/components/Mesh/IMeshEntity.ts"() {
    "use strict";
  }
});

// src/foundation/components/Mesh/index.ts
var init_Mesh2 = __esm({
  "src/foundation/components/Mesh/index.ts"() {
    "use strict";
    init_IMeshEntity();
    init_MeshComponent();
  }
});

// src/foundation/components/MeshRenderer/IMeshRendererEntity.ts
var init_IMeshRendererEntity = __esm({
  "src/foundation/components/MeshRenderer/IMeshRendererEntity.ts"() {
    "use strict";
  }
});

// src/foundation/components/MeshRenderer/index.ts
var init_MeshRenderer = __esm({
  "src/foundation/components/MeshRenderer/index.ts"() {
    "use strict";
    init_IMeshRendererEntity();
    init_MeshRendererComponent();
    init_createMeshEntity();
  }
});

// src/foundation/components/Physics/IPhysicsEntity.ts
var init_IPhysicsEntity = __esm({
  "src/foundation/components/Physics/IPhysicsEntity.ts"() {
    "use strict";
  }
});

// src/foundation/components/Physics/PhysicsComponent.ts
var _PhysicsComponent, PhysicsComponent;
var init_PhysicsComponent = __esm({
  "src/foundation/components/Physics/PhysicsComponent.ts"() {
    "use strict";
    init_Component();
    init_EntityRepository();
    init_WellKnownComponentTIDs();
    init_ProcessStage();
    init_OimoPhysicsStrategy();
    _PhysicsComponent = class _PhysicsComponent extends Component {
      constructor(entityUid, componentSid, entityComponent, isReUse) {
        super(entityUid, componentSid, entityComponent, isReUse);
        __publicField(this, "__strategy");
        this.moveStageTo(ProcessStage.Logic);
      }
      static get componentTID() {
        return WellKnownComponentTIDs.PhysicsComponentTID;
      }
      get componentTID() {
        return WellKnownComponentTIDs.PhysicsComponentTID;
      }
      setStrategy(strategy) {
        this.__strategy = strategy;
      }
      get strategy() {
        return this.__strategy;
      }
      static common_$logic() {
        OimoPhysicsStrategy.update();
      }
      $logic() {
        var _a40;
        (_a40 = this.__strategy) == null ? void 0 : _a40.update();
      }
      _destroy() {
        super._destroy();
        this.__strategy = void 0;
      }
      /**
      * @override
      * Add this component to the entity
      * @param base the target entity
      * @param _componentClass the component class to add
      */
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let PhysicsEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
          }
          getPhysics() {
            return this.getComponentByComponentTID(WellKnownComponentTIDs.PhysicsComponentTID);
          }
        }, __name(_a40, "PhysicsEntity"), _a40);
        applyMixins(base, PhysicsEntity);
        return base;
      }
    };
    __name(_PhysicsComponent, "PhysicsComponent");
    PhysicsComponent = _PhysicsComponent;
  }
});

// src/foundation/components/Physics/createPhysicsEntity.ts
function createPhysicsEntity() {
  const entity = createGroupEntity();
  const entityAddedComponent = EntityRepository.tryToAddComponentToEntityByTID(WellKnownComponentTIDs.PhysicsComponentTID, entity);
  return entityAddedComponent;
}
var init_createPhysicsEntity = __esm({
  "src/foundation/components/Physics/createPhysicsEntity.ts"() {
    "use strict";
    init_EntityRepository();
    init_createGroupEntity();
    init_WellKnownComponentTIDs();
    __name(createPhysicsEntity, "createPhysicsEntity");
  }
});

// src/foundation/components/Physics/index.ts
var init_Physics = __esm({
  "src/foundation/components/Physics/index.ts"() {
    "use strict";
    init_IPhysicsEntity();
    init_PhysicsComponent();
    init_createPhysicsEntity();
  }
});

// src/foundation/components/SceneGraph/ISceneGraphEntity.ts
var init_ISceneGraphEntity = __esm({
  "src/foundation/components/SceneGraph/ISceneGraphEntity.ts"() {
    "use strict";
  }
});

// src/foundation/components/SceneGraph/index.ts
var init_SceneGraph = __esm({
  "src/foundation/components/SceneGraph/index.ts"() {
    "use strict";
    init_ISceneGraphEntity();
    init_SceneGraphComponent();
    init_createGroupEntity();
    init_SceneGraphOps();
  }
});

// src/foundation/components/Skeletal/AnimationRetarget/AnimationRetarget.ts
var init_AnimationRetarget = __esm({
  "src/foundation/components/Skeletal/AnimationRetarget/AnimationRetarget.ts"() {
    "use strict";
  }
});

// src/foundation/components/Skeletal/AnimationRetarget/GlobalRetarget.ts
var _GlobalRetarget, GlobalRetarget;
var init_GlobalRetarget = __esm({
  "src/foundation/components/Skeletal/AnimationRetarget/GlobalRetarget.ts"() {
    "use strict";
    init_math();
    init_Is();
    _GlobalRetarget = class _GlobalRetarget {
      constructor(srcEntity) {
        __publicField(this, "__srcEntity");
        this.__srcEntity = srcEntity;
      }
      getEntity() {
        return this.__srcEntity;
      }
      getSrcPGRestQ(srcEntity) {
        let srcPGRestQ;
        const parent = srcEntity.getSceneGraph().parent;
        if (Is.exist(parent)) {
          srcPGRestQ = parent.getRotationRest((sg) => {
            const parent2 = sg.parent;
            if (Is.exist(parent2)) {
              const vrm = parent2.entity.tryToGetVrm();
              return Is.exist(vrm);
            } else {
              return true;
            }
          });
        } else {
          srcPGRestQ = Quaternion.identity();
        }
        return srcPGRestQ;
      }
      getDstPGRestQ(dstEntity) {
        let dstPGRestQ;
        const parent = dstEntity.getSceneGraph().parent;
        if (Is.exist(parent)) {
          dstPGRestQ = parent.getRotationRest((sg) => {
            const parent2 = sg.parent;
            if (Is.exist(parent2)) {
              const vrm = parent2.entity.tryToGetVrm();
              return Is.exist(vrm);
            } else {
              return true;
            }
          });
        } else {
          dstPGRestQ = Quaternion.identity();
        }
        return dstPGRestQ;
      }
      retargetQuaternion(dstEntity) {
        const srcEntity = this.__srcEntity;
        const srcPoseQ = srcEntity.getTransform().localRotationInner;
        const srcRestQ = srcEntity.getTransform().localRotationRestInner;
        const srcPGRestQ = this.getSrcPGRestQ(srcEntity);
        const animQ = Quaternion.multiply(srcPGRestQ, Quaternion.multiply(srcPoseQ, Quaternion.multiply(Quaternion.invert(srcRestQ), Quaternion.invert(srcPGRestQ))));
        const dstRestQ = dstEntity.getTransform().localRotationRestInner;
        const dstPgRestQ = this.getDstPGRestQ(dstEntity);
        const tgtPoseQ = Quaternion.multiply(Quaternion.invert(dstPgRestQ), Quaternion.multiply(animQ, Quaternion.multiply(dstPgRestQ, dstRestQ)));
        return tgtPoseQ;
      }
      retargetTranslate(dstEntity) {
        const srcEntity = this.__srcEntity;
        const srcPoseT = srcEntity.getTransform().localPositionInner;
        const srcRestT = srcEntity.getTransform().localPositionRestInner;
        const srcPGRestQ = this.getSrcPGRestQ(srcEntity);
        const srcDelta = Vector3.subtract(srcPoseT, srcRestT);
        const AnimT = srcPGRestQ.transformVector3(srcDelta);
        const dstRestT = dstEntity.getTransform().localPositionRestInner;
        const dstPgRestQ = this.getDstPGRestQ(dstEntity);
        const dstPoseT = Vector3.add(dstPgRestQ.transformVector3Inverse(AnimT), dstRestT);
        if (srcEntity.uniqueName.indexOf("hips") >= 0) {
          return Vector3.multiply(dstPoseT, srcEntity.parent.scale.x);
        }
        return dstPoseT;
      }
      retargetScale(dstEntity) {
        const srcEntity = this.__srcEntity;
        return srcEntity.getTransform().localScaleInner;
      }
    };
    __name(_GlobalRetarget, "GlobalRetarget");
    GlobalRetarget = _GlobalRetarget;
  }
});

// src/foundation/components/Skeletal/AnimationRetarget/GlobalRetargetReverse.ts
var _GlobalRetargetReverse, GlobalRetargetReverse;
var init_GlobalRetargetReverse = __esm({
  "src/foundation/components/Skeletal/AnimationRetarget/GlobalRetargetReverse.ts"() {
    "use strict";
    init_math();
    init_Is();
    _GlobalRetargetReverse = class _GlobalRetargetReverse {
      constructor(srcEntity) {
        __publicField(this, "__srcEntity");
        this.__srcEntity = srcEntity;
      }
      getEntity() {
        return this.__srcEntity;
      }
      getSrcPGRestQ(srcEntity) {
        let srcPGRestQ;
        const parent = srcEntity.getSceneGraph().parent;
        if (Is.exist(parent)) {
          srcPGRestQ = parent.getRotationRest((sg) => {
            const parent2 = sg.parent;
            if (Is.exist(parent2)) {
              const vrm = parent2.entity.tryToGetVrm();
              return Is.exist(vrm);
            } else {
              return true;
            }
          });
        } else {
          srcPGRestQ = Quaternion.identity();
        }
        return srcPGRestQ;
      }
      getDstPGRestQ(dstEntity) {
        let dstPGRestQ;
        const parent = dstEntity.getSceneGraph().parent;
        if (Is.exist(parent)) {
          dstPGRestQ = parent.getRotationRest((sg) => {
            const parent2 = sg.parent;
            if (Is.exist(parent2)) {
              const vrm = parent2.entity.tryToGetVrm();
              return Is.exist(vrm);
            } else {
              return true;
            }
          });
        } else {
          dstPGRestQ = Quaternion.identity();
        }
        return dstPGRestQ;
      }
      retargetQuaternion(dstEntity) {
        const srcEntity = this.__srcEntity;
        const srcPoseQ = srcEntity.getTransform().localRotationInner;
        const srcRestQ = srcEntity.getTransform().localRotationRestInner;
        const srcPGRestQ = this.getSrcPGRestQ(srcEntity);
        const animQ = Quaternion.multiply(srcPGRestQ, Quaternion.multiply(srcPoseQ, Quaternion.multiply(Quaternion.invert(srcRestQ), Quaternion.invert(srcPGRestQ))));
        const dstRestQ = dstEntity.getTransform().localRotationRestInner;
        const dstPgRestQ = this.getDstPGRestQ(dstEntity);
        const tgtPoseQ = Quaternion.multiply(Quaternion.invert(dstPgRestQ), Quaternion.multiply(animQ, Quaternion.multiply(dstPgRestQ, dstRestQ)));
        const tgtPoseQRev = Quaternion.multiply(Quaternion.multiply(_GlobalRetargetReverse.__rev, tgtPoseQ), Quaternion.invert(_GlobalRetargetReverse.__rev));
        return tgtPoseQRev;
      }
      retargetTranslate(dstEntity) {
        const srcEntity = this.__srcEntity;
        const srcPoseT = srcEntity.getTransform().localPositionInner;
        const srcRestT = srcEntity.getTransform().localPositionRestInner;
        const srcPGRestQ = this.getSrcPGRestQ(srcEntity);
        const srcDelta = Vector3.subtract(srcPoseT, srcRestT);
        const AnimT = srcPGRestQ.transformVector3(srcDelta);
        const dstRestT = dstEntity.getTransform().localPositionRestInner;
        const dstPgRestQ = this.getDstPGRestQ(dstEntity);
        const dstPoseT = Vector3.add(dstPgRestQ.transformVector3Inverse(AnimT), dstRestT);
        if (srcEntity.uniqueName.indexOf("hips") >= 0) {
          const dstPoseT2 = Vector3.multiply(dstPoseT, srcEntity.parent.scale.x);
          const dstPoseTRev = _GlobalRetargetReverse.__rev.transformVector3(dstPoseT2);
          return dstPoseTRev;
        }
        return dstPoseT;
      }
      retargetScale(dstEntity) {
        const srcEntity = this.__srcEntity;
        return srcEntity.getTransform().localScaleInner;
      }
    };
    __name(_GlobalRetargetReverse, "GlobalRetargetReverse");
    __publicField(_GlobalRetargetReverse, "__rev", Quaternion.fromAxisAngle(Vector3.fromCopy3(0, 1, 0), Math.PI));
    GlobalRetargetReverse = _GlobalRetargetReverse;
  }
});

// src/foundation/components/Skeletal/AnimationRetarget/AbsoluteAnimation.ts
var _AbsoluteAnimation, AbsoluteAnimation;
var init_AbsoluteAnimation = __esm({
  "src/foundation/components/Skeletal/AnimationRetarget/AbsoluteAnimation.ts"() {
    "use strict";
    _AbsoluteAnimation = class _AbsoluteAnimation {
      constructor(srcEntity) {
        __publicField(this, "__srcEntity");
        this.__srcEntity = srcEntity;
      }
      getEntity() {
        return this.__srcEntity;
      }
      retargetQuaternion(dstEntity) {
        const srcEntity = this.__srcEntity;
        return srcEntity.getTransform().localRotationInner;
      }
      retargetTranslate(dstEntity) {
        const srcEntity = this.__srcEntity;
        return srcEntity.getTransform().localPositionInner;
      }
      retargetScale(dstEntity) {
        const srcEntity = this.__srcEntity;
        return srcEntity.getTransform().localScaleInner;
      }
    };
    __name(_AbsoluteAnimation, "AbsoluteAnimation");
    AbsoluteAnimation = _AbsoluteAnimation;
  }
});

// src/foundation/components/Skeletal/AnimationRetarget/index.ts
var init_AnimationRetarget2 = __esm({
  "src/foundation/components/Skeletal/AnimationRetarget/index.ts"() {
    "use strict";
    init_AnimationRetarget();
    init_GlobalRetarget();
    init_GlobalRetargetReverse();
    init_AbsoluteAnimation();
  }
});

// src/foundation/components/Skeletal/ISkeletalEntity.ts
var init_ISkeletalEntity = __esm({
  "src/foundation/components/Skeletal/ISkeletalEntity.ts"() {
    "use strict";
  }
});

// src/foundation/components/Skeletal/createSkeletalEntity.ts
function createSkeletalEntity() {
  const entity = createGroupEntity();
  const entityAddedComponent = EntityRepository.tryToAddComponentToEntityByTID(WellKnownComponentTIDs.SkeletalComponentTID, entity);
  return entityAddedComponent;
}
var init_createSkeletalEntity = __esm({
  "src/foundation/components/Skeletal/createSkeletalEntity.ts"() {
    "use strict";
    init_EntityRepository();
    init_createGroupEntity();
    init_WellKnownComponentTIDs();
    __name(createSkeletalEntity, "createSkeletalEntity");
  }
});

// src/foundation/components/Skeletal/index.ts
var init_Skeletal = __esm({
  "src/foundation/components/Skeletal/index.ts"() {
    "use strict";
    init_AnimationRetarget2();
    init_ISkeletalEntity();
    init_SkeletalComponent();
    init_createSkeletalEntity();
  }
});

// src/foundation/components/Vrm/IVrmEntity.ts
var init_IVrmEntity = __esm({
  "src/foundation/components/Vrm/IVrmEntity.ts"() {
    "use strict";
  }
});

// src/foundation/components/Vrm/VrmComponent.ts
var _VrmComponent, VrmComponent;
var init_VrmComponent = __esm({
  "src/foundation/components/Vrm/VrmComponent.ts"() {
    "use strict";
    init_Component();
    init_EntityRepository();
    init_ProcessStage();
    init_misc();
    init_WellKnownComponentTIDs();
    _VrmComponent = class _VrmComponent extends Component {
      constructor(entityUid, componentSid, entityComponent, isReUse) {
        super(entityUid, componentSid, entityComponent, isReUse);
        __publicField(this, "__expressions", /* @__PURE__ */ new Map());
        __publicField(this, "__weights", /* @__PURE__ */ new Map());
        __publicField(this, "__blendShapeComponent");
        __publicField(this, "_version", "");
        this.moveStageTo(ProcessStage.Logic);
      }
      static get componentTID() {
        return WellKnownComponentTIDs.VrmComponentTID;
      }
      get componentTID() {
        return WellKnownComponentTIDs.VrmComponentTID;
      }
      setVrmExpressions(expressions) {
        for (const exp of expressions) {
          this.__expressions.set(exp.name, exp);
          this.__weights.set(exp.name, 0);
        }
      }
      setExpressionWeight(expressionName, weight) {
        const expression = this.__expressions.get(expressionName);
        if (Is.not.exist(expression)) {
          return;
        }
        this.__weights.set(expressionName, weight);
        for (const bind of expression.binds) {
          const entity = EntityRepository.getEntity(bind.entityIdx);
          const blendShapeComponent = entity.tryToGetBlendShape();
          if (Is.exist(blendShapeComponent)) {
            blendShapeComponent.setWeightByIndex(bind.blendShapeIdx, weight);
          }
        }
      }
      getExpressionWeight(expressionName) {
        return this.__weights.get(expressionName);
      }
      getExpressionNames() {
        return Array.from(this.__expressions.keys());
      }
      _shallowCopyFrom(component) {
        const vrmComponent = component;
        this.__expressions = new Map(vrmComponent.__expressions);
        this.__weights = new Map(vrmComponent.__weights);
        this._version = vrmComponent._version;
      }
      _destroy() {
        super._destroy();
      }
      /**
      * @override
      * Add this component to the entity
      * @param base the target entity
      * @param _componentClass the component class to add
      */
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let VrmEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
            __publicField(this, "__vrmComponent");
          }
          getVrm() {
            if (this.__vrmComponent === void 0) {
              this.__vrmComponent = this.getComponentByComponentTID(WellKnownComponentTIDs.VrmComponentTID);
            }
            return this.__vrmComponent;
          }
        }, __name(_a40, "VrmEntity"), _a40);
        applyMixins(base, VrmEntity);
        return base;
      }
    };
    __name(_VrmComponent, "VrmComponent");
    VrmComponent = _VrmComponent;
  }
});

// src/foundation/components/Vrm/index.ts
var init_Vrm = __esm({
  "src/foundation/components/Vrm/index.ts"() {
    "use strict";
    init_IVrmEntity();
    init_VrmComponent();
  }
});

// src/foundation/components/ComponentTypes.ts
var init_ComponentTypes = __esm({
  "src/foundation/components/ComponentTypes.ts"() {
    "use strict";
  }
});

// src/foundation/components/Constraint/ConstraintComponent.ts
var _ConstraintComponent, ConstraintComponent;
var init_ConstraintComponent = __esm({
  "src/foundation/components/Constraint/ConstraintComponent.ts"() {
    "use strict";
    init_Component();
    init_EntityRepository();
    init_ProcessStage();
    init_WellKnownComponentTIDs();
    _ConstraintComponent = class _ConstraintComponent extends Component {
      constructor(entityUid, componentSid, entityComponent, isReUse) {
        super(entityUid, componentSid, entityComponent, isReUse);
        __publicField(this, "__vrmConstraint");
        this.moveStageTo(ProcessStage.Logic);
      }
      /**
      * get the entity which has this component.
      * @returns the entity which has this component
      */
      get entity() {
        return EntityRepository.getEntity(this.__entityUid);
      }
      static get componentTID() {
        return WellKnownComponentTIDs.ConstraintComponentTID;
      }
      get componentTID() {
        return WellKnownComponentTIDs.ConstraintComponentTID;
      }
      $logic() {
        if (this.__vrmConstraint) {
          this.__vrmConstraint.update();
        }
      }
      setConstraint(constraint) {
        this.__vrmConstraint = constraint;
      }
      _destroy() {
        super._destroy();
        this.__vrmConstraint = void 0;
      }
      addThisComponentToEntity(base, _componentClass) {
        var _a40;
        let ConstraintEntity = (_a40 = class extends base.constructor {
          constructor(entityUID, isAlive, components) {
            super(entityUID, isAlive, components);
          }
          getConstraint() {
            return this.getComponentByComponentTID(WellKnownComponentTIDs.ConstraintComponentTID);
          }
        }, __name(_a40, "ConstraintEntity"), _a40);
        applyMixins(base, ConstraintEntity);
        return base;
      }
    };
    __name(_ConstraintComponent, "ConstraintComponent");
    ConstraintComponent = _ConstraintComponent;
  }
});

// src/foundation/components/registerComponents.ts
var init_registerComponents = __esm({
  "src/foundation/components/registerComponents.ts"() {
    "use strict";
    init_EffekseerComponent();
    init_ComponentRepository();
    init_AnimationComponent();
    init_AnimationStateComponent();
    init_BlendShapeComponent();
    init_CameraComponent();
    init_CameraControllerComponent();
    init_ConstraintComponent();
    init_LightComponent();
    init_MeshComponent();
    init_MeshRendererComponent();
    init_PhysicsComponent();
    init_SceneGraphComponent();
    init_SkeletalComponent();
    init_TransformComponent();
    init_VrmComponent();
    ComponentRepository.registerComponentClass(AnimationStateComponent);
    ComponentRepository.registerComponentClass(AnimationComponent);
    ComponentRepository.registerComponentClass(TransformComponent);
    ComponentRepository.registerComponentClass(SceneGraphComponent);
    ComponentRepository.registerComponentClass(MeshComponent);
    ComponentRepository.registerComponentClass(MeshRendererComponent);
    ComponentRepository.registerComponentClass(LightComponent);
    ComponentRepository.registerComponentClass(CameraControllerComponent);
    ComponentRepository.registerComponentClass(CameraComponent);
    ComponentRepository.registerComponentClass(SkeletalComponent);
    ComponentRepository.registerComponentClass(BlendShapeComponent);
    ComponentRepository.registerComponentClass(PhysicsComponent);
    ComponentRepository.registerComponentClass(EffekseerComponent);
    ComponentRepository.registerComponentClass(VrmComponent);
    ComponentRepository.registerComponentClass(ConstraintComponent);
  }
});

// src/foundation/components/index.ts
var init_components2 = __esm({
  "src/foundation/components/index.ts"() {
    "use strict";
    init_Animation();
    init_BlendShape();
    init_Camera();
    init_CameraController();
    init_Light();
    init_Mesh2();
    init_MeshRenderer();
    init_Physics();
    init_SceneGraph();
    init_Skeletal();
    init_Transform();
    init_Vrm();
    init_ComponentTypes();
    init_WellKnownComponentTIDs();
    init_registerComponents();
  }
});

// src/import.ts
var import_exports = {};
__export(import_exports, {
  AABB: () => AABB,
  AABBGizmo: () => AABBGizmo,
  AbsoluteAnimation: () => AbsoluteAnimation,
  AbstractArrayBufferBaseMathNumber: () => AbstractArrayBufferBaseMathNumber,
  AbstractCameraController: () => AbstractCameraController,
  AbstractMaterialContent: () => AbstractMaterialContent,
  AbstractMatrix: () => AbstractMatrix,
  AbstractQuaternion: () => AbstractQuaternion,
  AbstractShaderNode: () => AbstractShaderNode,
  AbstractTexture: () => AbstractTexture,
  AbstractVector: () => AbstractVector,
  Accessor: () => Accessor,
  AddShaderNode: () => AddShaderNode,
  AlphaMode: () => AlphaMode,
  AnimationAssigner: () => AnimationAssigner,
  AnimationAttribute: () => AnimationAttribute,
  AnimationComponent: () => AnimationComponent,
  AnimationInterpolation: () => AnimationInterpolation,
  AttributeColorShaderNode: () => AttributeColorShaderNode,
  AttributeNormalShaderNode: () => AttributeNormalShaderNode,
  AttributePositionShaderNode: () => AttributePositionShaderNode,
  AttributeTexcoordShaderNode: () => AttributeTexcoordShaderNode,
  Axis: () => Axis,
  BasisCompressionType: () => BasisCompressionType,
  BlendShapeComponent: () => BlendShapeComponent,
  BlockBeginShader: () => BlockBeginShader,
  BlockBeginShaderNode: () => BlockBeginShaderNode,
  BlockEndShader: () => BlockEndShader,
  BlockEndShaderNode: () => BlockEndShaderNode,
  BoneDataType: () => BoneDataType,
  Buffer: () => Buffer2,
  BufferUse: () => BufferUse,
  BufferView: () => BufferView,
  CGAPIResourceRepository: () => CGAPIResourceRepository,
  Cache: () => Cache,
  CameraComponent: () => CameraComponent,
  CameraControllerComponent: () => CameraControllerComponent,
  CameraControllerType: () => CameraControllerType,
  CameraType: () => CameraType,
  CapsuleCollider: () => CapsuleCollider,
  ClassicShadingShader: () => ClassicShadingShader,
  ColorGradingUsingLUTsMaterialContent: () => ColorGradingUsingLUTsMaterialContent,
  ColorRgb: () => ColorRgb,
  ColorRgba: () => ColorRgba,
  CommonShaderPart: () => CommonShaderPart,
  ComplexVertexAttribute: () => ComplexVertexAttribute,
  Component: () => Component,
  ComponentRepository: () => ComponentRepository,
  ComponentType: () => ComponentType,
  CompositionType: () => CompositionType,
  CompressionTextureType: () => CompressionTextureType,
  Config: () => Config,
  ConstRgbaBlack: () => ConstRgbaBlack,
  ConstRgbaWhite: () => ConstRgbaWhite,
  ConstVector2_0_0: () => ConstVector2_0_0,
  ConstVector2_1_1: () => ConstVector2_1_1,
  ConstVector3_0_0_0: () => ConstVector3_0_0_0,
  ConstVector3_1_1_1: () => ConstVector3_1_1_1,
  ConstVector4_0_0_0_0: () => ConstVector4_0_0_0_0,
  ConstVector4_0_0_0_1: () => ConstVector4_0_0_0_1,
  ConstVector4_1_1_1_1: () => ConstVector4_1_1_1_1,
  ConstantScalarVariableShaderNode: () => ConstantScalarVariableShaderNode,
  ConstantVariableShader: () => ConstantVariableShader,
  ConstantVector2VariableShaderNode: () => ConstantVector2VariableShaderNode,
  ConstantVector3VariableShaderNode: () => ConstantVector3VariableShaderNode,
  ConstantVector4VariableShaderNode: () => ConstantVector4VariableShaderNode,
  Cube: () => Cube,
  CubeTexture: () => CubeTexture,
  CustomMaterialContent: () => CustomMaterialContent,
  DataUtil: () => DataUtil,
  DefaultTextures: () => DefaultTextures,
  DepthEncodeMaterialContent: () => DepthEncodeMaterialContent,
  DetectHighLuminanceMaterialContent: () => DetectHighLuminanceMaterialContent,
  DotProductShaderNode: () => DotProductShaderNode,
  DrcPointCloudImporter: () => DrcPointCloudImporter,
  EVENT_CLICK: () => EVENT_CLICK,
  EVENT_KEY_DOWN: () => EVENT_KEY_DOWN,
  EVENT_KEY_PRESS: () => EVENT_KEY_PRESS,
  EVENT_KEY_UP: () => EVENT_KEY_UP,
  EVENT_MOUSE_DOWN: () => EVENT_MOUSE_DOWN,
  EVENT_MOUSE_ENTER: () => EVENT_MOUSE_ENTER,
  EVENT_MOUSE_LEAVE: () => EVENT_MOUSE_LEAVE,
  EVENT_MOUSE_MOVE: () => EVENT_MOUSE_MOVE,
  EVENT_MOUSE_OVER: () => EVENT_MOUSE_OVER,
  EVENT_MOUSE_UP: () => EVENT_MOUSE_UP,
  EVENT_MOUSE_WHEEL: () => EVENT_MOUSE_WHEEL,
  EVENT_MSPOINTER_DOWN: () => EVENT_MSPOINTER_DOWN,
  EVENT_MSPOINTER_MOVE: () => EVENT_MSPOINTER_MOVE,
  EVENT_MSPOINTER_UP: () => EVENT_MSPOINTER_UP,
  EVENT_ORIENTATION_CHANGE: () => EVENT_ORIENTATION_CHANGE,
  EVENT_POINTER_CANCEL: () => EVENT_POINTER_CANCEL,
  EVENT_POINTER_DOWN: () => EVENT_POINTER_DOWN,
  EVENT_POINTER_ENTER: () => EVENT_POINTER_ENTER,
  EVENT_POINTER_LEAVE: () => EVENT_POINTER_LEAVE,
  EVENT_POINTER_MOVE: () => EVENT_POINTER_MOVE,
  EVENT_POINTER_OUT: () => EVENT_POINTER_OUT,
  EVENT_POINTER_OVER: () => EVENT_POINTER_OVER,
  EVENT_POINTER_UP: () => EVENT_POINTER_UP,
  EVENT_RESIZE: () => EVENT_RESIZE,
  EVENT_TOUCH_CANCEL: () => EVENT_TOUCH_CANCEL,
  EVENT_TOUCH_DOUBLE_TAP: () => EVENT_TOUCH_DOUBLE_TAP,
  EVENT_TOUCH_DRAG: () => EVENT_TOUCH_DRAG,
  EVENT_TOUCH_END: () => EVENT_TOUCH_END,
  EVENT_TOUCH_ENTER: () => EVENT_TOUCH_ENTER,
  EVENT_TOUCH_HOLD: () => EVENT_TOUCH_HOLD,
  EVENT_TOUCH_LEAVE: () => EVENT_TOUCH_LEAVE,
  EVENT_TOUCH_LONG_TAP: () => EVENT_TOUCH_LONG_TAP,
  EVENT_TOUCH_MOVE: () => EVENT_TOUCH_MOVE,
  EVENT_TOUCH_OUT: () => EVENT_TOUCH_OUT,
  EVENT_TOUCH_OVER: () => EVENT_TOUCH_OVER,
  EVENT_TOUCH_PINCH: () => EVENT_TOUCH_PINCH,
  EVENT_TOUCH_START: () => EVENT_TOUCH_START,
  EVENT_TOUCH_SWIPE: () => EVENT_TOUCH_SWIPE,
  EVENT_TOUCH_TAP: () => EVENT_TOUCH_TAP,
  Effekseer: () => Effekseer2,
  EffekseerComponent: () => EffekseerComponent,
  EndShader: () => EndShader,
  Entity: () => Entity,
  EntityRepository: () => EntityRepository,
  EntityUIDOutputMaterialContent: () => EntityUIDOutputMaterialContent,
  EnumClass: () => EnumClass,
  Err: () => Err,
  EventPubSub: () => EventPubSub,
  Expression: () => Expression,
  ExpressionHelper: () => ExpressionHelper,
  FileType: () => FileType,
  ForwardRenderPipeline: () => ForwardRenderPipeline,
  Frame: () => Frame,
  FrameBuffer: () => FrameBuffer,
  Frustum: () => Frustum2,
  FurnaceTestMaterialContent: () => FurnaceTestMaterialContent,
  GLTF2_EXPORT_DRACO: () => GLTF2_EXPORT_DRACO,
  GLTF2_EXPORT_EMBEDDED: () => GLTF2_EXPORT_EMBEDDED,
  GLTF2_EXPORT_GLB: () => GLTF2_EXPORT_GLB,
  GLTF2_EXPORT_GLTF: () => GLTF2_EXPORT_GLTF,
  GLTF2_EXPORT_NO_DOWNLOAD: () => GLTF2_EXPORT_NO_DOWNLOAD,
  GL_ACTIVE_ATTRIBUTES: () => GL_ACTIVE_ATTRIBUTES,
  GL_ACTIVE_TEXTURE: () => GL_ACTIVE_TEXTURE,
  GL_ACTIVE_UNIFORMS: () => GL_ACTIVE_UNIFORMS,
  GL_ACTIVE_UNIFORM_BLOCKS: () => GL_ACTIVE_UNIFORM_BLOCKS,
  GL_ALIASED_LINE_WIDTH_RANGE: () => GL_ALIASED_LINE_WIDTH_RANGE,
  GL_ALIASED_POINT_SIZE_RANGE: () => GL_ALIASED_POINT_SIZE_RANGE,
  GL_ALPHA: () => GL_ALPHA,
  GL_ALPHA_BITS: () => GL_ALPHA_BITS,
  GL_ALREADY_SIGNALED: () => GL_ALREADY_SIGNALED,
  GL_ALWAYS: () => GL_ALWAYS,
  GL_ANY_SAMPLES_PASSED: () => GL_ANY_SAMPLES_PASSED,
  GL_ANY_SAMPLES_PASSED_CONSERVATIVE: () => GL_ANY_SAMPLES_PASSED_CONSERVATIVE,
  GL_ARRAY_BUFFER: () => GL_ARRAY_BUFFER,
  GL_ARRAY_BUFFER_BINDING: () => GL_ARRAY_BUFFER_BINDING,
  GL_ATTACHED_SHADERS: () => GL_ATTACHED_SHADERS,
  GL_BACK: () => GL_BACK,
  GL_BLEND: () => GL_BLEND,
  GL_BLEND_COLOR: () => GL_BLEND_COLOR,
  GL_BLEND_DST_ALPHA: () => GL_BLEND_DST_ALPHA,
  GL_BLEND_DST_RGB: () => GL_BLEND_DST_RGB,
  GL_BLEND_EQUATION: () => GL_BLEND_EQUATION,
  GL_BLEND_EQUATION_ALPHA: () => GL_BLEND_EQUATION_ALPHA,
  GL_BLEND_EQUATION_RGB: () => GL_BLEND_EQUATION_RGB,
  GL_BLEND_SRC_ALPHA: () => GL_BLEND_SRC_ALPHA,
  GL_BLEND_SRC_RGB: () => GL_BLEND_SRC_RGB,
  GL_BLUE_BITS: () => GL_BLUE_BITS,
  GL_BOOL: () => GL_BOOL,
  GL_BOOL_VEC2: () => GL_BOOL_VEC2,
  GL_BOOL_VEC3: () => GL_BOOL_VEC3,
  GL_BOOL_VEC4: () => GL_BOOL_VEC4,
  GL_BROWSER_DEFAULT_WEBGL: () => GL_BROWSER_DEFAULT_WEBGL,
  GL_BUFFER_SIZE: () => GL_BUFFER_SIZE,
  GL_BUFFER_USAGE: () => GL_BUFFER_USAGE,
  GL_CCW: () => GL_CCW,
  GL_CLAMP_TO_EDGE: () => GL_CLAMP_TO_EDGE,
  GL_COLOR: () => GL_COLOR,
  GL_COLOR_ATTACHMENT0: () => GL_COLOR_ATTACHMENT0,
  GL_COLOR_ATTACHMENT0_WEBGL: () => GL_COLOR_ATTACHMENT0_WEBGL,
  GL_COLOR_ATTACHMENT1: () => GL_COLOR_ATTACHMENT1,
  GL_COLOR_ATTACHMENT10: () => GL_COLOR_ATTACHMENT10,
  GL_COLOR_ATTACHMENT10_WEBGL: () => GL_COLOR_ATTACHMENT10_WEBGL,
  GL_COLOR_ATTACHMENT11: () => GL_COLOR_ATTACHMENT11,
  GL_COLOR_ATTACHMENT11_WEBGL: () => GL_COLOR_ATTACHMENT11_WEBGL,
  GL_COLOR_ATTACHMENT12: () => GL_COLOR_ATTACHMENT12,
  GL_COLOR_ATTACHMENT12_WEBGL: () => GL_COLOR_ATTACHMENT12_WEBGL,
  GL_COLOR_ATTACHMENT13: () => GL_COLOR_ATTACHMENT13,
  GL_COLOR_ATTACHMENT13_WEBGL: () => GL_COLOR_ATTACHMENT13_WEBGL,
  GL_COLOR_ATTACHMENT14: () => GL_COLOR_ATTACHMENT14,
  GL_COLOR_ATTACHMENT14_WEBGL: () => GL_COLOR_ATTACHMENT14_WEBGL,
  GL_COLOR_ATTACHMENT15: () => GL_COLOR_ATTACHMENT15,
  GL_COLOR_ATTACHMENT15_WEBGL: () => GL_COLOR_ATTACHMENT15_WEBGL,
  GL_COLOR_ATTACHMENT1_WEBGL: () => GL_COLOR_ATTACHMENT1_WEBGL,
  GL_COLOR_ATTACHMENT2: () => GL_COLOR_ATTACHMENT2,
  GL_COLOR_ATTACHMENT2_WEBGL: () => GL_COLOR_ATTACHMENT2_WEBGL,
  GL_COLOR_ATTACHMENT3: () => GL_COLOR_ATTACHMENT3,
  GL_COLOR_ATTACHMENT3_WEBGL: () => GL_COLOR_ATTACHMENT3_WEBGL,
  GL_COLOR_ATTACHMENT4: () => GL_COLOR_ATTACHMENT4,
  GL_COLOR_ATTACHMENT4_WEBGL: () => GL_COLOR_ATTACHMENT4_WEBGL,
  GL_COLOR_ATTACHMENT5: () => GL_COLOR_ATTACHMENT5,
  GL_COLOR_ATTACHMENT5_WEBGL: () => GL_COLOR_ATTACHMENT5_WEBGL,
  GL_COLOR_ATTACHMENT6: () => GL_COLOR_ATTACHMENT6,
  GL_COLOR_ATTACHMENT6_WEBGL: () => GL_COLOR_ATTACHMENT6_WEBGL,
  GL_COLOR_ATTACHMENT7: () => GL_COLOR_ATTACHMENT7,
  GL_COLOR_ATTACHMENT7_WEBGL: () => GL_COLOR_ATTACHMENT7_WEBGL,
  GL_COLOR_ATTACHMENT8: () => GL_COLOR_ATTACHMENT8,
  GL_COLOR_ATTACHMENT8_WEBGL: () => GL_COLOR_ATTACHMENT8_WEBGL,
  GL_COLOR_ATTACHMENT9: () => GL_COLOR_ATTACHMENT9,
  GL_COLOR_ATTACHMENT9_WEBGL: () => GL_COLOR_ATTACHMENT9_WEBGL,
  GL_COLOR_BUFFER_BIT: () => GL_COLOR_BUFFER_BIT,
  GL_COLOR_CLEAR_VALUE: () => GL_COLOR_CLEAR_VALUE,
  GL_COLOR_WRITEMASK: () => GL_COLOR_WRITEMASK,
  GL_COMPARE_REF_TO_TEXTURE: () => GL_COMPARE_REF_TO_TEXTURE,
  GL_COMPILE_STATUS: () => GL_COMPILE_STATUS,
  GL_COMPRESSED_R11_EAC: () => GL_COMPRESSED_R11_EAC,
  GL_COMPRESSED_RG11_EAC: () => GL_COMPRESSED_RG11_EAC,
  GL_COMPRESSED_RGB8_ETC2: () => GL_COMPRESSED_RGB8_ETC2,
  GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: () => GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
  GL_COMPRESSED_RGBA8_ETC2_EAC: () => GL_COMPRESSED_RGBA8_ETC2_EAC,
  GL_COMPRESSED_RGBA_ASTC_10X10_KHR: () => GL_COMPRESSED_RGBA_ASTC_10X10_KHR,
  GL_COMPRESSED_RGBA_ASTC_10X5_KHR: () => GL_COMPRESSED_RGBA_ASTC_10X5_KHR,
  GL_COMPRESSED_RGBA_ASTC_10X6_KHR: () => GL_COMPRESSED_RGBA_ASTC_10X6_KHR,
  GL_COMPRESSED_RGBA_ASTC_10X8_KHR: () => GL_COMPRESSED_RGBA_ASTC_10X8_KHR,
  GL_COMPRESSED_RGBA_ASTC_12X10_KHR: () => GL_COMPRESSED_RGBA_ASTC_12X10_KHR,
  GL_COMPRESSED_RGBA_ASTC_12X12_KHR: () => GL_COMPRESSED_RGBA_ASTC_12X12_KHR,
  GL_COMPRESSED_RGBA_ASTC_4X4_KHR: () => GL_COMPRESSED_RGBA_ASTC_4X4_KHR,
  GL_COMPRESSED_RGBA_ASTC_5X4_KHR: () => GL_COMPRESSED_RGBA_ASTC_5X4_KHR,
  GL_COMPRESSED_RGBA_ASTC_5X5_KHR: () => GL_COMPRESSED_RGBA_ASTC_5X5_KHR,
  GL_COMPRESSED_RGBA_ASTC_6X5_KHR: () => GL_COMPRESSED_RGBA_ASTC_6X5_KHR,
  GL_COMPRESSED_RGBA_ASTC_6X6_KHR: () => GL_COMPRESSED_RGBA_ASTC_6X6_KHR,
  GL_COMPRESSED_RGBA_ASTC_8X5_KHR: () => GL_COMPRESSED_RGBA_ASTC_8X5_KHR,
  GL_COMPRESSED_RGBA_ASTC_8X6_KHR: () => GL_COMPRESSED_RGBA_ASTC_8X6_KHR,
  GL_COMPRESSED_RGBA_ASTC_8X8_KHR: () => GL_COMPRESSED_RGBA_ASTC_8X8_KHR,
  GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: () => GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
  GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: () => GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL,
  GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: () => GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,
  GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: () => GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
  GL_COMPRESSED_RGBA_S3TC_DXT1_EXT: () => GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
  GL_COMPRESSED_RGBA_S3TC_DXT3_EXT: () => GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
  GL_COMPRESSED_RGBA_S3TC_DXT5_EXT: () => GL_COMPRESSED_RGBA_S3TC_DXT5_EXT,
  GL_COMPRESSED_RGB_ATC_WEBGL: () => GL_COMPRESSED_RGB_ATC_WEBGL,
  GL_COMPRESSED_RGB_ETC1_WEBGL: () => GL_COMPRESSED_RGB_ETC1_WEBGL,
  GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG: () => GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
  GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG: () => GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
  GL_COMPRESSED_RGB_S3TC_DXT1_EXT: () => GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
  GL_COMPRESSED_SIGNED_R11_EAC: () => GL_COMPRESSED_SIGNED_R11_EAC,
  GL_COMPRESSED_SIGNED_RG11_EAC: () => GL_COMPRESSED_SIGNED_RG11_EAC,
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: () => GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR,
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: () => GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR,
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: () => GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR,
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: () => GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR,
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: () => GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR,
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: () => GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR,
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: () => GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR,
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: () => GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR,
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: () => GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR,
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: () => GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR,
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: () => GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR,
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: () => GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR,
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: () => GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR,
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: () => GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR,
  GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: () => GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
  GL_COMPRESSED_SRGB8_ETC2: () => GL_COMPRESSED_SRGB8_ETC2,
  GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: () => GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: () => GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: () => GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: () => GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
  GL_COMPRESSED_SRGB_S3TC_DXT1_EXT: () => GL_COMPRESSED_SRGB_S3TC_DXT1_EXT,
  GL_COMPRESSED_TEXTURE_FORMATS: () => GL_COMPRESSED_TEXTURE_FORMATS,
  GL_CONDITION_SATISFIED: () => GL_CONDITION_SATISFIED,
  GL_CONSTANT_ALPHA: () => GL_CONSTANT_ALPHA,
  GL_CONSTANT_COLOR: () => GL_CONSTANT_COLOR,
  GL_CONTEXT_LOST_WEBGL: () => GL_CONTEXT_LOST_WEBGL,
  GL_COPY_READ_BUFFER: () => GL_COPY_READ_BUFFER,
  GL_COPY_READ_BUFFER_BINDING: () => GL_COPY_READ_BUFFER_BINDING,
  GL_COPY_WRITE_BUFFER: () => GL_COPY_WRITE_BUFFER,
  GL_COPY_WRITE_BUFFER_BINDING: () => GL_COPY_WRITE_BUFFER_BINDING,
  GL_CULL_FACE: () => GL_CULL_FACE,
  GL_CULL_FACE_MODE: () => GL_CULL_FACE_MODE,
  GL_CURRENT_PROGRAM: () => GL_CURRENT_PROGRAM,
  GL_CURRENT_QUERY: () => GL_CURRENT_QUERY,
  GL_CURRENT_QUERY_EXT: () => GL_CURRENT_QUERY_EXT,
  GL_CURRENT_VERTEX_ATTRIB: () => GL_CURRENT_VERTEX_ATTRIB,
  GL_CW: () => GL_CW,
  GL_DATA_BYTE: () => GL_DATA_BYTE,
  GL_DATA_FLOAT: () => GL_DATA_FLOAT,
  GL_DATA_INT: () => GL_DATA_INT,
  GL_DATA_SHORT: () => GL_DATA_SHORT,
  GL_DATA_UNSIGNED_BYTE: () => GL_DATA_UNSIGNED_BYTE,
  GL_DATA_UNSIGNED_INT: () => GL_DATA_UNSIGNED_INT,
  GL_DATA_UNSIGNED_SHORT: () => GL_DATA_UNSIGNED_SHORT,
  GL_DECR: () => GL_DECR,
  GL_DECR_WRAP: () => GL_DECR_WRAP,
  GL_DELETE_STATUS: () => GL_DELETE_STATUS,
  GL_DEPTH: () => GL_DEPTH,
  GL_DEPTH24_STENCIL8: () => GL_DEPTH24_STENCIL8,
  GL_DEPTH32F_STENCIL8: () => GL_DEPTH32F_STENCIL8,
  GL_DEPTH_ATTACHMENT: () => GL_DEPTH_ATTACHMENT,
  GL_DEPTH_BITS: () => GL_DEPTH_BITS,
  GL_DEPTH_BUFFER_BIT: () => GL_DEPTH_BUFFER_BIT,
  GL_DEPTH_CLEAR_VALUE: () => GL_DEPTH_CLEAR_VALUE,
  GL_DEPTH_COMPONENT: () => GL_DEPTH_COMPONENT,
  GL_DEPTH_COMPONENT16: () => GL_DEPTH_COMPONENT16,
  GL_DEPTH_COMPONENT24: () => GL_DEPTH_COMPONENT24,
  GL_DEPTH_COMPONENT32F: () => GL_DEPTH_COMPONENT32F,
  GL_DEPTH_FUNC: () => GL_DEPTH_FUNC,
  GL_DEPTH_RANGE: () => GL_DEPTH_RANGE,
  GL_DEPTH_STENCIL: () => GL_DEPTH_STENCIL,
  GL_DEPTH_STENCIL_ATTACHMENT: () => GL_DEPTH_STENCIL_ATTACHMENT,
  GL_DEPTH_TEST: () => GL_DEPTH_TEST,
  GL_DEPTH_WRITEMASK: () => GL_DEPTH_WRITEMASK,
  GL_DITHER: () => GL_DITHER,
  GL_DONT_CARE: () => GL_DONT_CARE,
  GL_DRAW_BUFFER0: () => GL_DRAW_BUFFER0,
  GL_DRAW_BUFFER0_WEBGL: () => GL_DRAW_BUFFER0_WEBGL,
  GL_DRAW_BUFFER1: () => GL_DRAW_BUFFER1,
  GL_DRAW_BUFFER10: () => GL_DRAW_BUFFER10,
  GL_DRAW_BUFFER10_WEBGL: () => GL_DRAW_BUFFER10_WEBGL,
  GL_DRAW_BUFFER11: () => GL_DRAW_BUFFER11,
  GL_DRAW_BUFFER11_WEBGL: () => GL_DRAW_BUFFER11_WEBGL,
  GL_DRAW_BUFFER12: () => GL_DRAW_BUFFER12,
  GL_DRAW_BUFFER12_WEBGL: () => GL_DRAW_BUFFER12_WEBGL,
  GL_DRAW_BUFFER13: () => GL_DRAW_BUFFER13,
  GL_DRAW_BUFFER13_WEBGL: () => GL_DRAW_BUFFER13_WEBGL,
  GL_DRAW_BUFFER14: () => GL_DRAW_BUFFER14,
  GL_DRAW_BUFFER14_WEBGL: () => GL_DRAW_BUFFER14_WEBGL,
  GL_DRAW_BUFFER15: () => GL_DRAW_BUFFER15,
  GL_DRAW_BUFFER15_WEBGL: () => GL_DRAW_BUFFER15_WEBGL,
  GL_DRAW_BUFFER1_WEBGL: () => GL_DRAW_BUFFER1_WEBGL,
  GL_DRAW_BUFFER2: () => GL_DRAW_BUFFER2,
  GL_DRAW_BUFFER2_WEBGL: () => GL_DRAW_BUFFER2_WEBGL,
  GL_DRAW_BUFFER3: () => GL_DRAW_BUFFER3,
  GL_DRAW_BUFFER3_WEBGL: () => GL_DRAW_BUFFER3_WEBGL,
  GL_DRAW_BUFFER4: () => GL_DRAW_BUFFER4,
  GL_DRAW_BUFFER4_WEBGL: () => GL_DRAW_BUFFER4_WEBGL,
  GL_DRAW_BUFFER5: () => GL_DRAW_BUFFER5,
  GL_DRAW_BUFFER5_WEBGL: () => GL_DRAW_BUFFER5_WEBGL,
  GL_DRAW_BUFFER6: () => GL_DRAW_BUFFER6,
  GL_DRAW_BUFFER6_WEBGL: () => GL_DRAW_BUFFER6_WEBGL,
  GL_DRAW_BUFFER7: () => GL_DRAW_BUFFER7,
  GL_DRAW_BUFFER7_WEBGL: () => GL_DRAW_BUFFER7_WEBGL,
  GL_DRAW_BUFFER8: () => GL_DRAW_BUFFER8,
  GL_DRAW_BUFFER8_WEBGL: () => GL_DRAW_BUFFER8_WEBGL,
  GL_DRAW_BUFFER9: () => GL_DRAW_BUFFER9,
  GL_DRAW_BUFFER9_WEBGL: () => GL_DRAW_BUFFER9_WEBGL,
  GL_DRAW_FRAMEBUFFER: () => GL_DRAW_FRAMEBUFFER,
  GL_DRAW_FRAMEBUFFER_BINDING: () => GL_DRAW_FRAMEBUFFER_BINDING,
  GL_DST_ALPHA: () => GL_DST_ALPHA,
  GL_DST_COLOR: () => GL_DST_COLOR,
  GL_DYNAMIC_COPY: () => GL_DYNAMIC_COPY,
  GL_DYNAMIC_DRAW: () => GL_DYNAMIC_DRAW,
  GL_DYNAMIC_READ: () => GL_DYNAMIC_READ,
  GL_ELEMENT_ARRAY_BUFFER: () => GL_ELEMENT_ARRAY_BUFFER,
  GL_ELEMENT_ARRAY_BUFFER_BINDING: () => GL_ELEMENT_ARRAY_BUFFER_BINDING,
  GL_EQUAL: () => GL_EQUAL,
  GL_FASTEST: () => GL_FASTEST,
  GL_FLOAT_32_UNSIGNED_INT_24_8_REV: () => GL_FLOAT_32_UNSIGNED_INT_24_8_REV,
  GL_FLOAT_MAT2: () => GL_FLOAT_MAT2,
  GL_FLOAT_MAT2X3: () => GL_FLOAT_MAT2X3,
  GL_FLOAT_MAT2X4: () => GL_FLOAT_MAT2X4,
  GL_FLOAT_MAT3: () => GL_FLOAT_MAT3,
  GL_FLOAT_MAT3X2: () => GL_FLOAT_MAT3X2,
  GL_FLOAT_MAT3X4: () => GL_FLOAT_MAT3X4,
  GL_FLOAT_MAT4: () => GL_FLOAT_MAT4,
  GL_FLOAT_MAT4X2: () => GL_FLOAT_MAT4X2,
  GL_FLOAT_MAT4X3: () => GL_FLOAT_MAT4X3,
  GL_FLOAT_VEC2: () => GL_FLOAT_VEC2,
  GL_FLOAT_VEC3: () => GL_FLOAT_VEC3,
  GL_FLOAT_VEC4: () => GL_FLOAT_VEC4,
  GL_FRAGMENT_SHADER: () => GL_FRAGMENT_SHADER,
  GL_FRAGMENT_SHADER_DERIVATIVE_HINT: () => GL_FRAGMENT_SHADER_DERIVATIVE_HINT,
  GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES: () => GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES,
  GL_FRAMEBUFFER: () => GL_FRAMEBUFFER,
  GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: () => GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE,
  GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: () => GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE,
  GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: () => GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING,
  GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: () => GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT,
  GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: () => GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE,
  GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: () => GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT,
  GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: () => GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE,
  GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: () => GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE,
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: () => GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME,
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: () => GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE,
  GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE: () => GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE,
  GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: () => GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE,
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: () => GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE,
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: () => GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER,
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: () => GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL,
  GL_FRAMEBUFFER_BINDING: () => GL_FRAMEBUFFER_BINDING,
  GL_FRAMEBUFFER_COMPLETE: () => GL_FRAMEBUFFER_COMPLETE,
  GL_FRAMEBUFFER_DEFAULT: () => GL_FRAMEBUFFER_DEFAULT,
  GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: () => GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT,
  GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS: () => GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS,
  GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: () => GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT,
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: () => GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE,
  GL_FRAMEBUFFER_UNSUPPORTED: () => GL_FRAMEBUFFER_UNSUPPORTED,
  GL_FRONT: () => GL_FRONT,
  GL_FRONT_AND_BACK: () => GL_FRONT_AND_BACK,
  GL_FRONT_FACE: () => GL_FRONT_FACE,
  GL_FUNC_ADD: () => GL_FUNC_ADD,
  GL_FUNC_REVERSE_SUBTRACT: () => GL_FUNC_REVERSE_SUBTRACT,
  GL_FUNC_SUBSTRACT: () => GL_FUNC_SUBSTRACT,
  GL_GENERATE_MIPMAP_HINT: () => GL_GENERATE_MIPMAP_HINT,
  GL_GEQUAL: () => GL_GEQUAL,
  GL_GPU_DISJOINT_EXT: () => GL_GPU_DISJOINT_EXT,
  GL_GREATER: () => GL_GREATER,
  GL_GREEN_BITS: () => GL_GREEN_BITS,
  GL_HALF_FLOAT: () => GL_HALF_FLOAT,
  GL_HALF_FLOAT_OES: () => GL_HALF_FLOAT_OES,
  GL_HIGH_FLOAT: () => GL_HIGH_FLOAT,
  GL_HIGH_INT: () => GL_HIGH_INT,
  GL_IMPLEMENTATION_COLOR_READ_FORMAT: () => GL_IMPLEMENTATION_COLOR_READ_FORMAT,
  GL_IMPLEMENTATION_COLOR_READ_TYPE: () => GL_IMPLEMENTATION_COLOR_READ_TYPE,
  GL_INCR: () => GL_INCR,
  GL_INCR_WRAP: () => GL_INCR_WRAP,
  GL_INTERLEAVED_ATTRIBS: () => GL_INTERLEAVED_ATTRIBS,
  GL_INT_2_10_10_10_REV: () => GL_INT_2_10_10_10_REV,
  GL_INT_SAMPLER_2D: () => GL_INT_SAMPLER_2D,
  GL_INT_SAMPLER_2D_ARRAY: () => GL_INT_SAMPLER_2D_ARRAY,
  GL_INT_SAMPLER_3D: () => GL_INT_SAMPLER_3D,
  GL_INT_SAMPLER_CUBE: () => GL_INT_SAMPLER_CUBE,
  GL_INT_VEC2: () => GL_INT_VEC2,
  GL_INT_VEC3: () => GL_INT_VEC3,
  GL_INT_VEC4: () => GL_INT_VEC4,
  GL_INVALID_ENUM: () => GL_INVALID_ENUM,
  GL_INVALID_FRAMEBUFFER_OPERATION: () => GL_INVALID_FRAMEBUFFER_OPERATION,
  GL_INVALID_INDEX: () => GL_INVALID_INDEX,
  GL_INVALID_OPERATION: () => GL_INVALID_OPERATION,
  GL_INVALID_VALUE: () => GL_INVALID_VALUE,
  GL_INVERT: () => GL_INVERT,
  GL_KEEP: () => GL_KEEP,
  GL_LEQUAL: () => GL_LEQUAL,
  GL_LESS: () => GL_LESS,
  GL_LINEAR: () => GL_LINEAR,
  GL_LINEAR_MIPMAP_LINEAR: () => GL_LINEAR_MIPMAP_LINEAR,
  GL_LINEAR_MIPMAP_NEAREST: () => GL_LINEAR_MIPMAP_NEAREST,
  GL_LINES: () => GL_LINES,
  GL_LINE_LOOP: () => GL_LINE_LOOP,
  GL_LINE_STRIP: () => GL_LINE_STRIP,
  GL_LINE_WIDTH: () => GL_LINE_WIDTH,
  GL_LINK_STATUS: () => GL_LINK_STATUS,
  GL_LOW_FLOAT: () => GL_LOW_FLOAT,
  GL_LOW_INT: () => GL_LOW_INT,
  GL_LUMINANCE: () => GL_LUMINANCE,
  GL_LUMINANCE_ALPHA: () => GL_LUMINANCE_ALPHA,
  GL_MAX: () => GL_MAX,
  GL_MAX_3D_TEXTURE_SIZE: () => GL_MAX_3D_TEXTURE_SIZE,
  GL_MAX_ARRAY_TEXTURE_LAYERS: () => GL_MAX_ARRAY_TEXTURE_LAYERS,
  GL_MAX_CLIENT_WAIT_TIMEOUT_WEBGL: () => GL_MAX_CLIENT_WAIT_TIMEOUT_WEBGL,
  GL_MAX_COLOR_ATTACHMENTS: () => GL_MAX_COLOR_ATTACHMENTS,
  GL_MAX_COLOR_ATTACHMENTS_WEBGL: () => GL_MAX_COLOR_ATTACHMENTS_WEBGL,
  GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: () => GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS,
  GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: () => GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS,
  GL_MAX_COMBINED_UNIFORM_BLOCKS: () => GL_MAX_COMBINED_UNIFORM_BLOCKS,
  GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: () => GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS,
  GL_MAX_CUBE_MAP_TEXTURE_SIZE: () => GL_MAX_CUBE_MAP_TEXTURE_SIZE,
  GL_MAX_DRAW_BUFFERS: () => GL_MAX_DRAW_BUFFERS,
  GL_MAX_DRAW_BUFFERS_WEBGL: () => GL_MAX_DRAW_BUFFERS_WEBGL,
  GL_MAX_ELEMENTS_INDICES: () => GL_MAX_ELEMENTS_INDICES,
  GL_MAX_ELEMENTS_VERTICES: () => GL_MAX_ELEMENTS_VERTICES,
  GL_MAX_ELEMENT_INDEX: () => GL_MAX_ELEMENT_INDEX,
  GL_MAX_EXT: () => GL_MAX_EXT,
  GL_MAX_FRAGMENT_INPUT_COMPONENTS: () => GL_MAX_FRAGMENT_INPUT_COMPONENTS,
  GL_MAX_FRAGMENT_UNIFORM_BLOCKS: () => GL_MAX_FRAGMENT_UNIFORM_BLOCKS,
  GL_MAX_FRAGMENT_UNIFORM_COMPONENTS: () => GL_MAX_FRAGMENT_UNIFORM_COMPONENTS,
  GL_MAX_FRAGMENT_UNIFORM_VECTORS: () => GL_MAX_FRAGMENT_UNIFORM_VECTORS,
  GL_MAX_PROGRAM_TEXEL_OFFSET: () => GL_MAX_PROGRAM_TEXEL_OFFSET,
  GL_MAX_RENDERBUFFER_SIZE: () => GL_MAX_RENDERBUFFER_SIZE,
  GL_MAX_SAMPLES: () => GL_MAX_SAMPLES,
  GL_MAX_SERVER_WAIT_TIMEOUT: () => GL_MAX_SERVER_WAIT_TIMEOUT,
  GL_MAX_TEXTURE_IMAGE_UNITS: () => GL_MAX_TEXTURE_IMAGE_UNITS,
  GL_MAX_TEXTURE_LOD_BIAS: () => GL_MAX_TEXTURE_LOD_BIAS,
  GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT: () => GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT,
  GL_MAX_TEXTURE_SIZE: () => GL_MAX_TEXTURE_SIZE,
  GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: () => GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS,
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: () => GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS,
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: () => GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS,
  GL_MAX_UNIFORM_BLOCK_SIZE: () => GL_MAX_UNIFORM_BLOCK_SIZE,
  GL_MAX_UNIFORM_BUFFER_BINDINGS: () => GL_MAX_UNIFORM_BUFFER_BINDINGS,
  GL_MAX_VARYING_COMPONENTS: () => GL_MAX_VARYING_COMPONENTS,
  GL_MAX_VARYING_VECTORS: () => GL_MAX_VARYING_VECTORS,
  GL_MAX_VERTEX_ATTRIBS: () => GL_MAX_VERTEX_ATTRIBS,
  GL_MAX_VERTEX_OUTPUT_COMPONENTS: () => GL_MAX_VERTEX_OUTPUT_COMPONENTS,
  GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: () => GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS,
  GL_MAX_VERTEX_UNIFORM_BLOCKS: () => GL_MAX_VERTEX_UNIFORM_BLOCKS,
  GL_MAX_VERTEX_UNIFORM_COMPONENTS: () => GL_MAX_VERTEX_UNIFORM_COMPONENTS,
  GL_MAX_VERTEX_UNIFORM_VECTORS: () => GL_MAX_VERTEX_UNIFORM_VECTORS,
  GL_MAX_VIEWPORT_DIMS: () => GL_MAX_VIEWPORT_DIMS,
  GL_MEDIUM_FLOAT: () => GL_MEDIUM_FLOAT,
  GL_MEDIUM_INT: () => GL_MEDIUM_INT,
  GL_MIN: () => GL_MIN,
  GL_MIN_EXT: () => GL_MIN_EXT,
  GL_MIN_PROGRAM_TEXEL_OFFSET: () => GL_MIN_PROGRAM_TEXEL_OFFSET,
  GL_MIRRORED_REPEAT: () => GL_MIRRORED_REPEAT,
  GL_NEAREST: () => GL_NEAREST,
  GL_NEAREST_MIPMAP_LINEAR: () => GL_NEAREST_MIPMAP_LINEAR,
  GL_NEAREST_MIPMAP_NEAREST: () => GL_NEAREST_MIPMAP_NEAREST,
  GL_NEVER: () => GL_NEVER,
  GL_NICEST: () => GL_NICEST,
  GL_NONE: () => GL_NONE,
  GL_NOTEQUAL: () => GL_NOTEQUAL,
  GL_NO_ERROR: () => GL_NO_ERROR,
  GL_OBJECT_TYPE: () => GL_OBJECT_TYPE,
  GL_ONE: () => GL_ONE,
  GL_ONE_MINUS_CONSTANT_ALPHA: () => GL_ONE_MINUS_CONSTANT_ALPHA,
  GL_ONE_MINUS_CONSTANT_COLOR: () => GL_ONE_MINUS_CONSTANT_COLOR,
  GL_ONE_MINUS_DST_ALPHA: () => GL_ONE_MINUS_DST_ALPHA,
  GL_ONE_MINUS_DST_COLOR: () => GL_ONE_MINUS_DST_COLOR,
  GL_ONE_MINUS_SRC_ALPHA: () => GL_ONE_MINUS_SRC_ALPHA,
  GL_ONE_MINUS_SRC_COLOR: () => GL_ONE_MINUS_SRC_COLOR,
  GL_OUT_OF_MEMORY: () => GL_OUT_OF_MEMORY,
  GL_PACK_ALIGNMENT: () => GL_PACK_ALIGNMENT,
  GL_PACK_ROW_LENGTH: () => GL_PACK_ROW_LENGTH,
  GL_PACK_SKIP_PIXELS: () => GL_PACK_SKIP_PIXELS,
  GL_PACK_SKIP_ROWS: () => GL_PACK_SKIP_ROWS,
  GL_PIXEL_PACK_BUFFER: () => GL_PIXEL_PACK_BUFFER,
  GL_PIXEL_PACK_BUFFER_BINDING: () => GL_PIXEL_PACK_BUFFER_BINDING,
  GL_PIXEL_UNPACK_BUFFER: () => GL_PIXEL_UNPACK_BUFFER,
  GL_PIXEL_UNPACK_BUFFER_BINDING: () => GL_PIXEL_UNPACK_BUFFER_BINDING,
  GL_PIXEL_UNSIGNED_BYTE: () => GL_PIXEL_UNSIGNED_BYTE,
  GL_PIXEL_UNSIGNED_SHORT_4_4_4_4: () => GL_PIXEL_UNSIGNED_SHORT_4_4_4_4,
  GL_PIXEL_UNSIGNED_SHORT_5_5_5_1: () => GL_PIXEL_UNSIGNED_SHORT_5_5_5_1,
  GL_PIXEL_UNSIGNED_SHORT_5_6_5: () => GL_PIXEL_UNSIGNED_SHORT_5_6_5,
  GL_POINTS: () => GL_POINTS,
  GL_POLYGON_OFFSET_FACTOR: () => GL_POLYGON_OFFSET_FACTOR,
  GL_POLYGON_OFFSET_FILL: () => GL_POLYGON_OFFSET_FILL,
  GL_POLYGON_OFFSET_UNITS: () => GL_POLYGON_OFFSET_UNITS,
  GL_QUERY_COUNTER_BITS_EXT: () => GL_QUERY_COUNTER_BITS_EXT,
  GL_QUERY_RESULT: () => GL_QUERY_RESULT,
  GL_QUERY_RESULT_AVAILABLE: () => GL_QUERY_RESULT_AVAILABLE,
  GL_QUERY_RESULT_AVAILABLE_EXT: () => GL_QUERY_RESULT_AVAILABLE_EXT,
  GL_QUERY_RESULT_EXT: () => GL_QUERY_RESULT_EXT,
  GL_R11F_G11F_B10F: () => GL_R11F_G11F_B10F,
  GL_R16F: () => GL_R16F,
  GL_R16I: () => GL_R16I,
  GL_R16UI: () => GL_R16UI,
  GL_R32F: () => GL_R32F,
  GL_R32I: () => GL_R32I,
  GL_R32UI: () => GL_R32UI,
  GL_R8: () => GL_R8,
  GL_R8I: () => GL_R8I,
  GL_R8UI: () => GL_R8UI,
  GL_R8_SNORM: () => GL_R8_SNORM,
  GL_RASTERIZER_DISCARD: () => GL_RASTERIZER_DISCARD,
  GL_READ_BUFFER: () => GL_READ_BUFFER,
  GL_READ_FRAMEBUFFER: () => GL_READ_FRAMEBUFFER,
  GL_READ_FRAMEBUFFER_BINDING: () => GL_READ_FRAMEBUFFER_BINDING,
  GL_RED: () => GL_RED,
  GL_RED_BITS: () => GL_RED_BITS,
  GL_RED_INTEGER: () => GL_RED_INTEGER,
  GL_RENDERBUFFER: () => GL_RENDERBUFFER,
  GL_RENDERBUFFER_ALPHA_SIZE: () => GL_RENDERBUFFER_ALPHA_SIZE,
  GL_RENDERBUFFER_BINDING: () => GL_RENDERBUFFER_BINDING,
  GL_RENDERBUFFER_BLUE_SIZE: () => GL_RENDERBUFFER_BLUE_SIZE,
  GL_RENDERBUFFER_DEPTH_SIZE: () => GL_RENDERBUFFER_DEPTH_SIZE,
  GL_RENDERBUFFER_GREEN_SIZE: () => GL_RENDERBUFFER_GREEN_SIZE,
  GL_RENDERBUFFER_HEIGHT: () => GL_RENDERBUFFER_HEIGHT,
  GL_RENDERBUFFER_INTERNAL_FORMAT: () => GL_RENDERBUFFER_INTERNAL_FORMAT,
  GL_RENDERBUFFER_RED_SIZE: () => GL_RENDERBUFFER_RED_SIZE,
  GL_RENDERBUFFER_SAMPLES: () => GL_RENDERBUFFER_SAMPLES,
  GL_RENDERBUFFER_STENCIL_SIZE: () => GL_RENDERBUFFER_STENCIL_SIZE,
  GL_RENDERBUFFER_WIDTH: () => GL_RENDERBUFFER_WIDTH,
  GL_RENDERER: () => GL_RENDERER,
  GL_REPEAT: () => GL_REPEAT,
  GL_REPLACE: () => GL_REPLACE,
  GL_RG: () => GL_RG,
  GL_RG16F: () => GL_RG16F,
  GL_RG16I: () => GL_RG16I,
  GL_RG16UI: () => GL_RG16UI,
  GL_RG32F: () => GL_RG32F,
  GL_RG32I: () => GL_RG32I,
  GL_RG32UI: () => GL_RG32UI,
  GL_RG8: () => GL_RG8,
  GL_RG8I: () => GL_RG8I,
  GL_RG8UI: () => GL_RG8UI,
  GL_RG8_SNORM: () => GL_RG8_SNORM,
  GL_RGB: () => GL_RGB,
  GL_RGB10_A2: () => GL_RGB10_A2,
  GL_RGB10_A2UI: () => GL_RGB10_A2UI,
  GL_RGB16F: () => GL_RGB16F,
  GL_RGB16I: () => GL_RGB16I,
  GL_RGB16UI: () => GL_RGB16UI,
  GL_RGB32F: () => GL_RGB32F,
  GL_RGB32F_EXT: () => GL_RGB32F_EXT,
  GL_RGB32I: () => GL_RGB32I,
  GL_RGB32UI: () => GL_RGB32UI,
  GL_RGB565: () => GL_RGB565,
  GL_RGB5_A1: () => GL_RGB5_A1,
  GL_RGB8: () => GL_RGB8,
  GL_RGB8I: () => GL_RGB8I,
  GL_RGB8UI: () => GL_RGB8UI,
  GL_RGB8_SNORM: () => GL_RGB8_SNORM,
  GL_RGB9_E5: () => GL_RGB9_E5,
  GL_RGBA: () => GL_RGBA,
  GL_RGBA16F: () => GL_RGBA16F,
  GL_RGBA16I: () => GL_RGBA16I,
  GL_RGBA16UI: () => GL_RGBA16UI,
  GL_RGBA32F: () => GL_RGBA32F,
  GL_RGBA32F_EXT: () => GL_RGBA32F_EXT,
  GL_RGBA32I: () => GL_RGBA32I,
  GL_RGBA32UI: () => GL_RGBA32UI,
  GL_RGBA4: () => GL_RGBA4,
  GL_RGBA8: () => GL_RGBA8,
  GL_RGBA8I: () => GL_RGBA8I,
  GL_RGBA8UI: () => GL_RGBA8UI,
  GL_RGBA8_SNORM: () => GL_RGBA8_SNORM,
  GL_RGBA_INTEGER: () => GL_RGBA_INTEGER,
  GL_RGB_INTEGER: () => GL_RGB_INTEGER,
  GL_RG_INTEGER: () => GL_RG_INTEGER,
  GL_SAMPLER_2D: () => GL_SAMPLER_2D,
  GL_SAMPLER_2D_ARRAY: () => GL_SAMPLER_2D_ARRAY,
  GL_SAMPLER_2D_ARRAY_SHADOW: () => GL_SAMPLER_2D_ARRAY_SHADOW,
  GL_SAMPLER_2D_SHADOW: () => GL_SAMPLER_2D_SHADOW,
  GL_SAMPLER_3D: () => GL_SAMPLER_3D,
  GL_SAMPLER_BINDING: () => GL_SAMPLER_BINDING,
  GL_SAMPLER_CUBE: () => GL_SAMPLER_CUBE,
  GL_SAMPLER_CUBE_SHADOW: () => GL_SAMPLER_CUBE_SHADOW,
  GL_SAMPLES: () => GL_SAMPLES,
  GL_SAMPLE_ALPHA_TO_COVERAGE: () => GL_SAMPLE_ALPHA_TO_COVERAGE,
  GL_SAMPLE_BUFFERS: () => GL_SAMPLE_BUFFERS,
  GL_SAMPLE_COVERAGE: () => GL_SAMPLE_COVERAGE,
  GL_SAMPLE_COVERAGE_INVERT: () => GL_SAMPLE_COVERAGE_INVERT,
  GL_SAMPLE_COVERAGE_VALUE: () => GL_SAMPLE_COVERAGE_VALUE,
  GL_SCISSOR_BOX: () => GL_SCISSOR_BOX,
  GL_SCISSOR_TEST: () => GL_SCISSOR_TEST,
  GL_SEPARATE_ATTRIBS: () => GL_SEPARATE_ATTRIBS,
  GL_SHADER_TYPE: () => GL_SHADER_TYPE,
  GL_SHADING_LANGUAGE_VERSION: () => GL_SHADING_LANGUAGE_VERSION,
  GL_SIGNALED: () => GL_SIGNALED,
  GL_SIGNED_NORMALIZED: () => GL_SIGNED_NORMALIZED,
  GL_SRC_ALPHA: () => GL_SRC_ALPHA,
  GL_SRC_ALPHA_SATURATE: () => GL_SRC_ALPHA_SATURATE,
  GL_SRC_COLOR: () => GL_SRC_COLOR,
  GL_SRGB: () => GL_SRGB,
  GL_SRGB8: () => GL_SRGB8,
  GL_SRGB8_ALPHA8: () => GL_SRGB8_ALPHA8,
  GL_SRGB8_ALPHA8_EXT: () => GL_SRGB8_ALPHA8_EXT,
  GL_SRGB_ALPHA_EXT: () => GL_SRGB_ALPHA_EXT,
  GL_SRGB_EXT: () => GL_SRGB_EXT,
  GL_STATIC_COPY: () => GL_STATIC_COPY,
  GL_STATIC_DRAW: () => GL_STATIC_DRAW,
  GL_STATIC_READ: () => GL_STATIC_READ,
  GL_STENCIL: () => GL_STENCIL,
  GL_STENCIL_ATTACHMENT: () => GL_STENCIL_ATTACHMENT,
  GL_STENCIL_BACK_FAIL: () => GL_STENCIL_BACK_FAIL,
  GL_STENCIL_BACK_FUNC: () => GL_STENCIL_BACK_FUNC,
  GL_STENCIL_BACK_PASS_DEPTH_FAIL: () => GL_STENCIL_BACK_PASS_DEPTH_FAIL,
  GL_STENCIL_BACK_PASS_DEPTH_PASS: () => GL_STENCIL_BACK_PASS_DEPTH_PASS,
  GL_STENCIL_BACK_REF: () => GL_STENCIL_BACK_REF,
  GL_STENCIL_BACK_VALUE_MASK: () => GL_STENCIL_BACK_VALUE_MASK,
  GL_STENCIL_BACK_WRITEMASK: () => GL_STENCIL_BACK_WRITEMASK,
  GL_STENCIL_BITS: () => GL_STENCIL_BITS,
  GL_STENCIL_BUFFER_BIT: () => GL_STENCIL_BUFFER_BIT,
  GL_STENCIL_CLEAR_VALUE: () => GL_STENCIL_CLEAR_VALUE,
  GL_STENCIL_FAIL: () => GL_STENCIL_FAIL,
  GL_STENCIL_FUNC: () => GL_STENCIL_FUNC,
  GL_STENCIL_INDEX: () => GL_STENCIL_INDEX,
  GL_STENCIL_INDEX8: () => GL_STENCIL_INDEX8,
  GL_STENCIL_PASS_DEPTH_FAIL: () => GL_STENCIL_PASS_DEPTH_FAIL,
  GL_STENCIL_PASS_DEPTH_PASS: () => GL_STENCIL_PASS_DEPTH_PASS,
  GL_STENCIL_REF: () => GL_STENCIL_REF,
  GL_STENCIL_TEST: () => GL_STENCIL_TEST,
  GL_STENCIL_VALUE_MASK: () => GL_STENCIL_VALUE_MASK,
  GL_STENCIL_WRITEMASK: () => GL_STENCIL_WRITEMASK,
  GL_STREAM_COPY: () => GL_STREAM_COPY,
  GL_STREAM_DRAW: () => GL_STREAM_DRAW,
  GL_STREAM_READ: () => GL_STREAM_READ,
  GL_SUBPIXEL_BITS: () => GL_SUBPIXEL_BITS,
  GL_SYNC_CONDITION: () => GL_SYNC_CONDITION,
  GL_SYNC_FENCE: () => GL_SYNC_FENCE,
  GL_SYNC_FLAGS: () => GL_SYNC_FLAGS,
  GL_SYNC_FLUSH_COMMANDS_BIT: () => GL_SYNC_FLUSH_COMMANDS_BIT,
  GL_SYNC_GPU_COMMANDS_COMPLETE: () => GL_SYNC_GPU_COMMANDS_COMPLETE,
  GL_SYNC_STATUS: () => GL_SYNC_STATUS,
  GL_TEXTURE: () => GL_TEXTURE,
  GL_TEXTURE0: () => GL_TEXTURE0,
  GL_TEXTURE1: () => GL_TEXTURE1,
  GL_TEXTURE10: () => GL_TEXTURE10,
  GL_TEXTURE11: () => GL_TEXTURE11,
  GL_TEXTURE12: () => GL_TEXTURE12,
  GL_TEXTURE13: () => GL_TEXTURE13,
  GL_TEXTURE14: () => GL_TEXTURE14,
  GL_TEXTURE15: () => GL_TEXTURE15,
  GL_TEXTURE16: () => GL_TEXTURE16,
  GL_TEXTURE17: () => GL_TEXTURE17,
  GL_TEXTURE18: () => GL_TEXTURE18,
  GL_TEXTURE19: () => GL_TEXTURE19,
  GL_TEXTURE2: () => GL_TEXTURE2,
  GL_TEXTURE20: () => GL_TEXTURE20,
  GL_TEXTURE21: () => GL_TEXTURE21,
  GL_TEXTURE22: () => GL_TEXTURE22,
  GL_TEXTURE23: () => GL_TEXTURE23,
  GL_TEXTURE24: () => GL_TEXTURE24,
  GL_TEXTURE25: () => GL_TEXTURE25,
  GL_TEXTURE26: () => GL_TEXTURE26,
  GL_TEXTURE27: () => GL_TEXTURE27,
  GL_TEXTURE28: () => GL_TEXTURE28,
  GL_TEXTURE29: () => GL_TEXTURE29,
  GL_TEXTURE3: () => GL_TEXTURE3,
  GL_TEXTURE30: () => GL_TEXTURE30,
  GL_TEXTURE31: () => GL_TEXTURE31,
  GL_TEXTURE4: () => GL_TEXTURE4,
  GL_TEXTURE5: () => GL_TEXTURE5,
  GL_TEXTURE6: () => GL_TEXTURE6,
  GL_TEXTURE7: () => GL_TEXTURE7,
  GL_TEXTURE8: () => GL_TEXTURE8,
  GL_TEXTURE9: () => GL_TEXTURE9,
  GL_TEXTURE_2D: () => GL_TEXTURE_2D,
  GL_TEXTURE_2D_ARRAY: () => GL_TEXTURE_2D_ARRAY,
  GL_TEXTURE_3D: () => GL_TEXTURE_3D,
  GL_TEXTURE_BASE_LEVEL: () => GL_TEXTURE_BASE_LEVEL,
  GL_TEXTURE_BINDING_2D: () => GL_TEXTURE_BINDING_2D,
  GL_TEXTURE_BINDING_2D_ARRAY: () => GL_TEXTURE_BINDING_2D_ARRAY,
  GL_TEXTURE_BINDING_3D: () => GL_TEXTURE_BINDING_3D,
  GL_TEXTURE_BINDING_CUBE_MAP: () => GL_TEXTURE_BINDING_CUBE_MAP,
  GL_TEXTURE_COMPARE_FUNC: () => GL_TEXTURE_COMPARE_FUNC,
  GL_TEXTURE_COMPARE_MODE: () => GL_TEXTURE_COMPARE_MODE,
  GL_TEXTURE_CUBE_MAP: () => GL_TEXTURE_CUBE_MAP,
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X: () => GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: () => GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: () => GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
  GL_TEXTURE_CUBE_MAP_POSITIVE_X: () => GL_TEXTURE_CUBE_MAP_POSITIVE_X,
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y: () => GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z: () => GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
  GL_TEXTURE_IMMUTABLE_FORMAT: () => GL_TEXTURE_IMMUTABLE_FORMAT,
  GL_TEXTURE_IMMUTABLE_LEVELS: () => GL_TEXTURE_IMMUTABLE_LEVELS,
  GL_TEXTURE_MAG_FILTER: () => GL_TEXTURE_MAG_FILTER,
  GL_TEXTURE_MAX_ANISOTROPY_EXT: () => GL_TEXTURE_MAX_ANISOTROPY_EXT,
  GL_TEXTURE_MAX_LEVEL: () => GL_TEXTURE_MAX_LEVEL,
  GL_TEXTURE_MAX_LOD: () => GL_TEXTURE_MAX_LOD,
  GL_TEXTURE_MIN_FILTER: () => GL_TEXTURE_MIN_FILTER,
  GL_TEXTURE_MIN_LOD: () => GL_TEXTURE_MIN_LOD,
  GL_TEXTURE_WRAP_R: () => GL_TEXTURE_WRAP_R,
  GL_TEXTURE_WRAP_S: () => GL_TEXTURE_WRAP_S,
  GL_TEXTURE_WRAP_T: () => GL_TEXTURE_WRAP_T,
  GL_TIMEOUT_EXPIRED: () => GL_TIMEOUT_EXPIRED,
  GL_TIMEOUT_IGNORED: () => GL_TIMEOUT_IGNORED,
  GL_TIMESTAMP_EXT: () => GL_TIMESTAMP_EXT,
  GL_TIME_ELAPSED_EXT: () => GL_TIME_ELAPSED_EXT,
  GL_TRANSFORM_FEEDBACK: () => GL_TRANSFORM_FEEDBACK,
  GL_TRANSFORM_FEEDBACK_ACTIVE: () => GL_TRANSFORM_FEEDBACK_ACTIVE,
  GL_TRANSFORM_FEEDBACK_BINDING: () => GL_TRANSFORM_FEEDBACK_BINDING,
  GL_TRANSFORM_FEEDBACK_BUFFER: () => GL_TRANSFORM_FEEDBACK_BUFFER,
  GL_TRANSFORM_FEEDBACK_BUFFER_BINDING: () => GL_TRANSFORM_FEEDBACK_BUFFER_BINDING,
  GL_TRANSFORM_FEEDBACK_BUFFER_MODE: () => GL_TRANSFORM_FEEDBACK_BUFFER_MODE,
  GL_TRANSFORM_FEEDBACK_BUFFER_SIZE: () => GL_TRANSFORM_FEEDBACK_BUFFER_SIZE,
  GL_TRANSFORM_FEEDBACK_BUFFER_START: () => GL_TRANSFORM_FEEDBACK_BUFFER_START,
  GL_TRANSFORM_FEEDBACK_PAUSED: () => GL_TRANSFORM_FEEDBACK_PAUSED,
  GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: () => GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN,
  GL_TRANSFORM_FEEDBACK_VARYINGS: () => GL_TRANSFORM_FEEDBACK_VARYINGS,
  GL_TRIANGLES: () => GL_TRIANGLES,
  GL_TRIANGLE_FAN: () => GL_TRIANGLE_FAN,
  GL_TRIANGLE_STRIP: () => GL_TRIANGLE_STRIP,
  GL_UNIFORM_ARRAY_STRIDE: () => GL_UNIFORM_ARRAY_STRIDE,
  GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS: () => GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS,
  GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: () => GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES,
  GL_UNIFORM_BLOCK_BINDING: () => GL_UNIFORM_BLOCK_BINDING,
  GL_UNIFORM_BLOCK_DATA_SIZE: () => GL_UNIFORM_BLOCK_DATA_SIZE,
  GL_UNIFORM_BLOCK_INDEX: () => GL_UNIFORM_BLOCK_INDEX,
  GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: () => GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER,
  GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: () => GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER,
  GL_UNIFORM_BUFFER: () => GL_UNIFORM_BUFFER,
  GL_UNIFORM_BUFFER_BINDING: () => GL_UNIFORM_BUFFER_BINDING,
  GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT: () => GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT,
  GL_UNIFORM_BUFFER_SIZE: () => GL_UNIFORM_BUFFER_SIZE,
  GL_UNIFORM_BUFFER_START: () => GL_UNIFORM_BUFFER_START,
  GL_UNIFORM_IS_ROW_MAJOR: () => GL_UNIFORM_IS_ROW_MAJOR,
  GL_UNIFORM_MATRIX_STRIDE: () => GL_UNIFORM_MATRIX_STRIDE,
  GL_UNIFORM_OFFSET: () => GL_UNIFORM_OFFSET,
  GL_UNIFORM_SIZE: () => GL_UNIFORM_SIZE,
  GL_UNIFORM_TYPE: () => GL_UNIFORM_TYPE,
  GL_UNMASKED_RENDERER_WEBGL: () => GL_UNMASKED_RENDERER_WEBGL,
  GL_UNMASKED_VENDOR_WEBGL: () => GL_UNMASKED_VENDOR_WEBGL,
  GL_UNPACK_ALIGNMENT: () => GL_UNPACK_ALIGNMENT,
  GL_UNPACK_COLORSPACE_CONVERSION_WEBGL: () => GL_UNPACK_COLORSPACE_CONVERSION_WEBGL,
  GL_UNPACK_FLIP_Y_WEBGL: () => GL_UNPACK_FLIP_Y_WEBGL,
  GL_UNPACK_IMAGE_HEIGHT: () => GL_UNPACK_IMAGE_HEIGHT,
  GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL: () => GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL,
  GL_UNPACK_ROW_LENGTH: () => GL_UNPACK_ROW_LENGTH,
  GL_UNPACK_SKIP_IMAGES: () => GL_UNPACK_SKIP_IMAGES,
  GL_UNPACK_SKIP_PIXELS: () => GL_UNPACK_SKIP_PIXELS,
  GL_UNPACK_SKIP_ROWS: () => GL_UNPACK_SKIP_ROWS,
  GL_UNSIGNALED: () => GL_UNSIGNALED,
  GL_UNSIGNED_INT_10F_11F_11F_REV: () => GL_UNSIGNED_INT_10F_11F_11F_REV,
  GL_UNSIGNED_INT_24_8: () => GL_UNSIGNED_INT_24_8,
  GL_UNSIGNED_INT_24_8_WEBGL: () => GL_UNSIGNED_INT_24_8_WEBGL,
  GL_UNSIGNED_INT_2_10_10_10_REV: () => GL_UNSIGNED_INT_2_10_10_10_REV,
  GL_UNSIGNED_INT_5_9_9_9_REV: () => GL_UNSIGNED_INT_5_9_9_9_REV,
  GL_UNSIGNED_INT_SAMPLER_2D: () => GL_UNSIGNED_INT_SAMPLER_2D,
  GL_UNSIGNED_INT_SAMPLER_2D_ARRAY: () => GL_UNSIGNED_INT_SAMPLER_2D_ARRAY,
  GL_UNSIGNED_INT_SAMPLER_3D: () => GL_UNSIGNED_INT_SAMPLER_3D,
  GL_UNSIGNED_INT_SAMPLER_CUBE: () => GL_UNSIGNED_INT_SAMPLER_CUBE,
  GL_UNSIGNED_INT_VEC2: () => GL_UNSIGNED_INT_VEC2,
  GL_UNSIGNED_INT_VEC3: () => GL_UNSIGNED_INT_VEC3,
  GL_UNSIGNED_INT_VEC4: () => GL_UNSIGNED_INT_VEC4,
  GL_UNSIGNED_NORMALIZED: () => GL_UNSIGNED_NORMALIZED,
  GL_UNSIGNED_NORMALIZED_EXT: () => GL_UNSIGNED_NORMALIZED_EXT,
  GL_VALIDATE_STATUS: () => GL_VALIDATE_STATUS,
  GL_VENDOR: () => GL_VENDOR,
  GL_VERSION: () => GL_VERSION,
  GL_VERTEX_ARRAY_BINDING: () => GL_VERTEX_ARRAY_BINDING,
  GL_VERTEX_ARRAY_BINDING_OES: () => GL_VERTEX_ARRAY_BINDING_OES,
  GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: () => GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING,
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR: () => GL_VERTEX_ATTRIB_ARRAY_DIVISOR,
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: () => GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE,
  GL_VERTEX_ATTRIB_ARRAY_ENABLED: () => GL_VERTEX_ATTRIB_ARRAY_ENABLED,
  GL_VERTEX_ATTRIB_ARRAY_INTEGER: () => GL_VERTEX_ATTRIB_ARRAY_INTEGER,
  GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: () => GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
  GL_VERTEX_ATTRIB_ARRAY_POINTER: () => GL_VERTEX_ATTRIB_ARRAY_POINTER,
  GL_VERTEX_ATTRIB_ARRAY_SIZE: () => GL_VERTEX_ATTRIB_ARRAY_SIZE,
  GL_VERTEX_ATTRIB_ARRAY_STRIDE: () => GL_VERTEX_ATTRIB_ARRAY_STRIDE,
  GL_VERTEX_ATTRIB_ARRAY_TYPE: () => GL_VERTEX_ATTRIB_ARRAY_TYPE,
  GL_VERTEX_SHADER: () => GL_VERTEX_SHADER,
  GL_VIEWPORT: () => GL_VIEWPORT,
  GL_WAIT_FAILED: () => GL_WAIT_FAILED,
  GL_ZERO: () => GL_ZERO,
  GetComponentFromEntities: () => GetComponentFromEntities,
  Gizmo: () => Gizmo,
  GlobalDataRepository: () => GlobalDataRepository,
  GlobalRetarget: () => GlobalRetarget,
  GlobalRetargetReverse: () => GlobalRetargetReverse,
  Gltf2Exporter: () => Gltf2Exporter,
  Gltf2Importer: () => Gltf2Importer,
  GltfImporter: () => GltfImporter,
  GreaterShaderNode: () => GreaterShaderNode,
  Grid: () => Grid,
  HdriFormat: () => HdriFormat,
  INPUT_HANDLING_STATE_CAMERA_CONTROLLER: () => INPUT_HANDLING_STATE_CAMERA_CONTROLLER,
  INPUT_HANDLING_STATE_GIZMO_SCALE: () => INPUT_HANDLING_STATE_GIZMO_SCALE,
  INPUT_HANDLING_STATE_GIZMO_TRANSLATION: () => INPUT_HANDLING_STATE_GIZMO_TRANSLATION,
  INPUT_HANDLING_STATE_NONE: () => INPUT_HANDLING_STATE_NONE,
  IShape: () => IShape,
  IdentityMatrix33: () => IdentityMatrix33,
  IdentityMatrix44: () => IdentityMatrix44,
  IfStatementShader: () => IfStatementShader,
  IfStatementShaderNode: () => IfStatementShaderNode,
  ImageUtil: () => ImageUtil,
  InputManager: () => InputManager,
  Is: () => Is,
  IsObj: () => IsObj,
  Joint: () => Joint,
  KTX2TextureLoader: () => KTX2TextureLoader,
  LightComponent: () => LightComponent,
  LightGizmo: () => LightGizmo,
  LightType: () => LightType,
  Line: () => Line,
  LocatorGizmo: () => LocatorGizmo,
  LogLevel: () => LogLevel,
  LogQuaternion: () => LogQuaternion,
  Logger: () => Logger,
  MToon0xMaterialContent: () => MToon0xMaterialContent,
  MToon1MaterialContent: () => MToon1MaterialContent,
  MatCapMaterialContent: () => MatCapMaterialContent,
  Material: () => Material,
  MaterialHelper: () => MaterialHelper,
  MaterialRepository: () => MaterialRepository,
  MathClassUtil: () => MathClassUtil,
  MathUtil: () => MathUtil,
  Matrix22: () => Matrix22,
  Matrix33: () => Matrix33,
  Matrix44: () => Matrix44,
  MemoryManager: () => MemoryManager,
  MergeVectorShaderNode: () => MergeVectorShaderNode,
  Mesh: () => Mesh,
  MeshComponent: () => MeshComponent,
  MeshHelper: () => MeshHelper,
  MeshRendererComponent: () => MeshRendererComponent,
  MiscUtil: () => MiscUtil,
  ModelConverter: () => ModelConverter,
  ModuleManager: () => ModuleManager,
  MultiplyShaderNode: () => MultiplyShaderNode,
  MutableColorRgb: () => MutableColorRgb,
  MutableColorRgba: () => MutableColorRgba,
  MutableMatrix22: () => MutableMatrix22,
  MutableMatrix33: () => MutableMatrix33,
  MutableMatrix44: () => MutableMatrix44,
  MutableQuaternion: () => MutableQuaternion,
  MutableScalar: () => MutableScalar,
  MutableScalar_: () => MutableScalar_,
  MutableScalard: () => MutableScalard,
  MutableVector2: () => MutableVector2,
  MutableVector2_: () => MutableVector2_,
  MutableVector2d: () => MutableVector2d,
  MutableVector3: () => MutableVector3,
  MutableVector3_: () => MutableVector3_,
  MutableVector3d: () => MutableVector3d,
  MutableVector4: () => MutableVector4,
  MutableVector4_: () => MutableVector4_,
  MutableVector4d: () => MutableVector4d,
  None: () => None,
  NormalMatrixShaderNode: () => NormalMatrixShaderNode,
  NormalizeShaderNode: () => NormalizeShaderNode,
  OimoPhysicsStrategy: () => OimoPhysicsStrategy,
  Ok: () => Ok,
  OrbitCameraController: () => OrbitCameraController,
  OutColorShaderNode: () => OutColorShaderNode,
  OutPositionShaderNode: () => OutPositionShaderNode,
  PhysicsComponent: () => PhysicsComponent,
  PixelFormat: () => PixelFormat,
  Plane: () => Plane,
  Primitive: () => Primitive,
  PrimitiveMode: () => PrimitiveMode,
  PrimitiveSortKey_BitLength_Depth: () => PrimitiveSortKey_BitLength_Depth,
  PrimitiveSortKey_BitLength_Material: () => PrimitiveSortKey_BitLength_Material,
  PrimitiveSortKey_BitLength_PrimitiveType: () => PrimitiveSortKey_BitLength_PrimitiveType,
  PrimitiveSortKey_BitLength_TranslucencyType: () => PrimitiveSortKey_BitLength_TranslucencyType,
  PrimitiveSortKey_BitOffset_Material: () => PrimitiveSortKey_BitOffset_Material,
  PrimitiveSortKey_BitOffset_PrimitiveType: () => PrimitiveSortKey_BitOffset_PrimitiveType,
  PrimitiveSortKey_BitOffset_TranslucencyType: () => PrimitiveSortKey_BitOffset_TranslucencyType,
  PrimitiveSortKey_BitOffset_ViewportLayer: () => PrimitiveSortKey_BitOffset_ViewportLayer,
  ProcessApproach: () => ProcessApproach,
  ProcessApproachClass: () => ProcessApproachClass,
  ProcessStage: () => ProcessStage,
  ProjectionMatrixShaderNode: () => ProjectionMatrixShaderNode,
  Quaternion: () => Quaternion,
  RenderBuffer: () => RenderBuffer,
  RenderBufferTarget: () => RenderBufferTarget,
  RenderPass: () => RenderPass,
  RenderPassHelper: () => RenderPassHelper,
  RenderTargetTexture: () => RenderTargetTexture,
  RenderTargetTextureCube: () => RenderTargetTextureCube,
  RenderableHelper: () => RenderableHelper,
  RhodoniteImportExtension: () => RhodoniteImportExtension,
  RnException: () => RnException,
  RnObject: () => RnObject,
  RnPromise: () => RnPromise,
  Sampler: () => Sampler,
  Scalar: () => Scalar2,
  Scalar_: () => Scalar_,
  Scalard: () => Scalard,
  ScaleGizmo: () => ScaleGizmo,
  SceneGraphComponent: () => SceneGraphComponent,
  ShaderGraphResolver: () => ShaderGraphResolver,
  ShaderNode: () => ShaderNode,
  ShaderSemantics: () => ShaderSemantics,
  ShaderSemanticsClass: () => ShaderSemanticsClass,
  ShaderType: () => ShaderType,
  ShaderVariableType: () => ShaderVariableType,
  ShaderityUtilityWebGL: () => ShaderityUtilityWebGL,
  ShadingModel: () => ShadingModel2,
  ShadowMap: () => ShadowMap,
  ShadowMapDecodeClassicMaterialContent: () => ShadowMapDecodeClassicMaterialContent,
  SimpleVertexAttribute: () => SimpleVertexAttribute,
  SkeletalComponent: () => SkeletalComponent,
  Some: () => Some,
  Sphere: () => Sphere,
  SphereCollider: () => SphereCollider,
  SplitVectorShaderNode: () => SplitVectorShaderNode,
  SymbolWeakMap: () => SymbolWeakMap,
  SynthesizeHdrMaterialContent: () => SynthesizeHdrMaterialContent,
  System: () => System,
  SystemState: () => SystemState,
  TagGltf2NodeIndex: () => TagGltf2NodeIndex,
  Texture: () => Texture2,
  TextureDataFloat: () => TextureDataFloat,
  TextureFetchShader: () => TextureFetchShader,
  TextureFormat: () => TextureFormat,
  TextureParameter: () => TextureParameter,
  Time: () => Time,
  ToneMappingType: () => ToneMappingType,
  Transform3D: () => Transform3D,
  TransformComponent: () => TransformComponent,
  TranslationGizmo: () => TranslationGizmo,
  UniformDataShader: () => UniformDataShader,
  UniformDataShaderNode: () => UniformDataShaderNode,
  VERSION: () => VERSION,
  VRMColliderGroup: () => VRMColliderGroup,
  VRMSpring: () => VRMSpring,
  VRMSpringBone: () => VRMSpringBone,
  VRMSpringBonePhysicsStrategy: () => VRMSpringBonePhysicsStrategy,
  VarianceShadowMapDecodeClassicMaterialContent: () => VarianceShadowMapDecodeClassicMaterialContent,
  VaryingVariableShader: () => VaryingVariableShader,
  Vector2: () => Vector2,
  Vector2_: () => Vector2_,
  Vector2d: () => Vector2d,
  Vector3: () => Vector3,
  Vector3_: () => Vector3_,
  Vector3d: () => Vector3d,
  Vector4: () => Vector4,
  Vector4_: () => Vector4_,
  Vector4d: () => Vector4d,
  VectorN: () => VectorN,
  VertexAttribute: () => VertexAttribute,
  VertexAttributeClass: () => VertexAttributeClass,
  VideoTexture: () => VideoTexture,
  ViewMatrixShaderNode: () => ViewMatrixShaderNode,
  Visibility: () => Visibility,
  Vrm0xImporter: () => Vrm0xImporter,
  VrmComponent: () => VrmComponent,
  VrmImporter: () => VrmImporter,
  VrmaImporter: () => VrmaImporter,
  WalkThroughCameraController: () => WalkThroughCameraController,
  WeakNone: () => WeakNone,
  WeakOption: () => WeakOption,
  WeakSome: () => WeakSome,
  WebGLContextWrapper: () => WebGLContextWrapper,
  WebGLExtension: () => WebGLExtension,
  WebGLResourceRepository: () => WebGLResourceRepository,
  WebGLStrategyDataTexture: () => WebGLStrategyDataTexture,
  WebGLStrategyUniform: () => WebGLStrategyUniform,
  WebGpuDeviceWrapper: () => WebGpuDeviceWrapper,
  WebGpuResourceRepository: () => WebGpuResourceRepository,
  WebGpuStrategyBasic: () => WebGpuStrategyBasic,
  WebXRSystem: () => WebXRSystem,
  WellKnownComponentTIDs: () => WellKnownComponentTIDs,
  WireframeMaterialNode: () => WireframeMaterialNode,
  WorldMatrixShaderNode: () => WorldMatrixShaderNode,
  _from: () => _from,
  _fromString: () => _fromString,
  _fromStringCaseSensitively: () => _fromStringCaseSensitively,
  _getPropertyIndex2: () => _getPropertyIndex2,
  add2: () => add2,
  add2_offset: () => add2_offset,
  add3: () => add3,
  add3_offset: () => add3_offset,
  add4: () => add4,
  add4_offset: () => add4_offset,
  addLineNumberToCode: () => addLineNumberToCode,
  applyMixins: () => applyMixins,
  array3_lerp_offsetAsComposition: () => array3_lerp_offsetAsComposition,
  arrayN_lerp_offsetAsComposition: () => arrayN_lerp_offsetAsComposition,
  assertDoesNotHave: () => assertDoesNotHave,
  assertExist: () => assertExist,
  assertHas: () => assertHas,
  assertIsErr: () => assertIsErr,
  assertIsOk: () => assertIsOk,
  calcAlignedByteLength: () => calcAlignedByteLength,
  combineImages: () => combineImages,
  convertHTMLImageElementToCanvas: () => convertHTMLImageElementToCanvas,
  createCameraControllerEntity: () => createCameraControllerEntity,
  createCameraEntity: () => createCameraEntity,
  createEffekseer: () => createEffekseer,
  createEntity: () => createEntity,
  createGroupEntity: () => createGroupEntity,
  createLightEntity: () => createLightEntity,
  createLightWithCameraEntity: () => createLightWithCameraEntity,
  createMeshEntity: () => createMeshEntity,
  createMotionController: () => createMotionController,
  createPhysicsEntity: () => createPhysicsEntity,
  createSkeletalEntity: () => createSkeletalEntity,
  createTransformEntity: () => createTransformEntity,
  deepCopyUsingJsonStringify: () => deepCopyUsingJsonStringify,
  defaultAnimationTrackName: () => defaultAnimationTrackName,
  defaultValue: () => defaultValue,
  detectFormatByArrayBuffers: () => detectFormatByArrayBuffers,
  detectFormatByUri: () => detectFormatByUri,
  downloadArrayBuffer: () => downloadArrayBuffer,
  downloadTypedArray: () => downloadTypedArray,
  dummyAnisotropyTexture: () => dummyAnisotropyTexture,
  dummyBlackCubeTexture: () => dummyBlackCubeTexture,
  dummyBlackTexture: () => dummyBlackTexture,
  dummyBlueTexture: () => dummyBlueTexture,
  dummySRGBGrayTexture: () => dummySRGBGrayTexture,
  dummyWhiteTexture: () => dummyWhiteTexture,
  enhanceArray: () => enhanceArray,
  flattenHierarchy: () => flattenHierarchy,
  fromTensorToCompositionType: () => fromTensorToCompositionType,
  get1: () => get1,
  get1_offset: () => get1_offset,
  get1_offsetAsComposition: () => get1_offsetAsComposition,
  get2: () => get2,
  get2_offset: () => get2_offset,
  get2_offsetAsComposition: () => get2_offsetAsComposition,
  get3: () => get3,
  get3_offset: () => get3_offset,
  get3_offsetAsComposition: () => get3_offsetAsComposition,
  get4: () => get4,
  get4_offset: () => get4_offset,
  get4_offsetAsComposition: () => get4_offsetAsComposition,
  getEvent: () => getEvent,
  getMotionController: () => getMotionController,
  getN_offset: () => getN_offset,
  getN_offsetAsComposition: () => getN_offsetAsComposition,
  getWebXRSystem: () => getWebXRSystem,
  greaterThan: () => greaterThan,
  ifDefinedThen: () => ifDefinedThen,
  ifDefinedThenWithReturn: () => ifDefinedThenWithReturn,
  ifExistsThen: () => ifExistsThen,
  ifExistsThenWithReturn: () => ifExistsThenWithReturn,
  ifNotExistsThen: () => ifNotExistsThen,
  ifNotExistsThenWithReturn: () => ifNotExistsThenWithReturn,
  ifUndefinedThen: () => ifUndefinedThen,
  ifUndefinedThenWithReturn: () => ifUndefinedThenWithReturn,
  initDefaultTextures: () => initDefaultTextures,
  isBlend: () => isBlend,
  isBlendWithZWrite: () => isBlendWithZWrite,
  isBlendWithoutZWrite: () => isBlendWithoutZWrite,
  isOpaque: () => isOpaque,
  isSameGlTF2TextureSampler: () => isSameGlTF2TextureSampler,
  isSkipDrawing: () => isSkipDrawing,
  isTranslucent: () => isTranslucent,
  lessThan: () => lessThan,
  mulArray3WithScalar_offset: () => mulArray3WithScalar_offset,
  mulArray4WithScalar_offset: () => mulArray4WithScalar_offset,
  mulArrayNWithScalar_offset: () => mulArrayNWithScalar_offset,
  mulThatAndThisToOutAsMat44_offsetAsComposition: () => mulThatAndThisToOutAsMat44_offsetAsComposition,
  normalizeArray4: () => normalizeArray4,
  nullishToEmptyArray: () => nullishToEmptyArray,
  nullishToEmptyMap: () => nullishToEmptyMap,
  objectCachify: () => objectCachify,
  primitiveCachify1: () => primitiveCachify1,
  qlerp_offsetAsComposition: () => qlerp_offsetAsComposition,
  scalar_lerp_offsetAsComposition: () => scalar_lerp_offsetAsComposition,
  setupShaderProgram: () => setupShaderProgram,
  sheenLutTexture: () => sheenLutTexture,
  updateGamePad: () => updateGamePad,
  updateMotionControllerModel: () => updateMotionControllerModel,
  updateVBOAndVAO: () => updateVBOAndVAO,
  valueWithCompensation: () => valueWithCompensation,
  valueWithDefault: () => valueWithDefault
});

// src/foundation/cameras/index.ts
init_AbstractCameraController();
init_OrbitCameraController();
init_WalkThroughCameraController();

// src/foundation/index.ts
init_components2();

// src/foundation/core/index.ts
init_Component();
init_ComponentRepository();
init_Config();
init_Entity();
init_EntityRepository();
init_GlobalDataRepository();
init_MemoryManager();
init_RnObject();

// src/foundation/index.ts
init_definitions();

// src/foundation/enhanced_js_objects/Array.ts
var GetComponentFromEntities = Symbol();
var getComponentFromEntitiesStr = "getComponentFromEntities";
function getComponentFromEntities(ComponentClass) {
  const that = this.__raw;
  const components = [];
  that.forEach((entity) => {
    const component = entity.getComponentByComponentTID(ComponentClass.componentTID);
    if (component != null) {
      components.push(component);
    }
  });
  return components;
}
__name(getComponentFromEntities, "getComponentFromEntities");
var _a38;
var EnhancedArrayMethods = (_a38 = class {
  constructor(__raw) {
    __publicField(this, "__raw");
    this.__raw = __raw;
  }
}, __name(_a38, "EnhancedArrayMethods"), _a38);
var enhanceInner = /* @__PURE__ */ __name(() => {
  Object.defineProperty(EnhancedArrayMethods.prototype, getComponentFromEntitiesStr, {
    enumerable: false,
    writable: false,
    configurable: true,
    value: getComponentFromEntities
  });
}, "enhanceInner");
enhanceInner();
var enhanceArray = /* @__PURE__ */ __name(() => {
  Object.defineProperty(Array.prototype, "Rn", {
    enumerable: false,
    configurable: false,
    get() {
      const ret = new EnhancedArrayMethods(this);
      return ret;
    }
  });
}, "enhanceArray");

// src/foundation/exporter/Gltf2Exporter.ts
init_EntityRepository();
init_Is();
init_glTF2();
init_ComponentType();
init_DataUtil();
init_WebGLConstants();
init_CompositionType();
init_SceneGraphComponent();

// src/foundation/exporter/Gltf2ExporterEffekseer.ts
init_WellKnownComponentTIDs();
init_Is();
init_Logger();

// src/foundation/exporter/Gltf2ExporterOps.ts
init_DataUtil();
function createAndAddGltf2BufferView(json, bufferIdx, uint8Array) {
  const bufferViewByteLengthAccumulated = json.extras.bufferViewByteLengthAccumulatedArray[bufferIdx];
  const gltfBufferViewEx = {
    buffer: bufferIdx,
    byteLength: uint8Array.byteLength,
    byteOffset: bufferViewByteLengthAccumulated,
    extras: {
      uint8Array
    }
  };
  const nextBufferViewBytesLengthAccumulated = DataUtil.addPaddingBytes(gltfBufferViewEx.byteLength, 4) + bufferViewByteLengthAccumulated;
  json.bufferViews.push(gltfBufferViewEx);
  json.extras.bufferViewByteLengthAccumulatedArray[bufferIdx] = nextBufferViewBytesLengthAccumulated;
  return gltfBufferViewEx;
}
__name(createAndAddGltf2BufferView, "createAndAddGltf2BufferView");

// src/foundation/exporter/Gltf2ExporterEffekseer.ts
function createEffekseer(json, entities) {
  let effekseerExists = false;
  const bufferIdx = json.extras.bufferViewByteLengthAccumulatedArray.length - 1;
  const effects = [];
  for (let i2 = 0; i2 < entities.length; i2++) {
    const entity = entities[i2];
    const effekseerComponent = entity.getComponentByComponentTID(WellKnownComponentTIDs.EffekseerComponentTID);
    if (Is.exist(effekseerComponent)) {
      effekseerExists = true;
      const effekseer2 = {
        node: i2,
        name: effekseerComponent.uniqueName
      };
      if (Is.exist(effekseerComponent.arrayBuffer)) {
        const gltf2BufferView = createAndAddGltf2BufferView(json, bufferIdx, new Uint8Array(effekseerComponent.arrayBuffer));
        effekseer2.bufferView = json.bufferViews.indexOf(gltf2BufferView);
      } else if (Is.exist(effekseerComponent.uri)) {
        effekseer2.uri = effekseerComponent.uri;
      } else {
        Logger.error("no real effect data.");
      }
      __createEffekseerTimeline(effekseerComponent.entity, effekseer2);
      effects.push(effekseer2);
    }
  }
  if (effekseerExists) {
    json.extensions.RHODONITE_effekseer = {
      version: "1.0",
      effects
    };
    json.extensionsUsed.push("RHODONITE_effekseer");
  }
}
__name(createEffekseer, "createEffekseer");
function __createEffekseerTimeline(entity, effekseer2) {
  const animationComponent = entity.tryToGetAnimation();
  if (Is.exist(animationComponent)) {
    const trackNames = animationComponent.getAnimationTrackNames();
    const timelines = [];
    for (const trackName of trackNames) {
      if (animationComponent.hasAnimation(trackName, "effekseer")) {
        const rnAnimationTrack = animationComponent.getAnimationChannelsOfTrack(trackName);
        if (Is.exist(rnAnimationTrack)) {
          const rnChannels = rnAnimationTrack.values();
          for (const rnChannel of rnChannels) {
            const pathName = rnChannel.target.pathName;
            if (pathName === "effekseer") {
              const inputArray = rnChannel.sampler.input;
              const values = [];
              for (let i2 = 0; i2 < inputArray.length; i2++) {
                const input = inputArray[i2];
                const output = rnChannel.sampler.output[i2];
                const timelineItem = {
                  input,
                  event: output > 0.5 ? "play" : "pause"
                };
                values.push(timelineItem);
              }
              const timeline = {
                name: trackName,
                values
              };
              timelines.push(timeline);
            }
          }
        }
      }
    }
    effekseer2.timelines = timelines;
  }
}
__name(__createEffekseerTimeline, "__createEffekseerTimeline");

// src/foundation/exporter/Gltf2Exporter.ts
init_Vector4();
init_definitions();
init_MathUtil();
init_version();
var GLTF2_EXPORT_GLTF = "glTF";
var GLTF2_EXPORT_GLB = "glTF-Binary";
var GLTF2_EXPORT_DRACO = "glTF-Draco";
var GLTF2_EXPORT_EMBEDDED = "glTF-Embedded";
var GLTF2_EXPORT_NO_DOWNLOAD = "No-Download";
var _Gltf2Exporter = class _Gltf2Exporter {
  constructor() {
  }
  /**
  * Exports scene data in the rhodonite system in glTF2 format.
  * @param filename the target output path
  * @param option a option config
  */
  static async export(filename, option = {
    entities: void 0,
    type: GLTF2_EXPORT_GLB
  }) {
    const { collectedEntities, topLevelEntities } = this.__collectEntities(option);
    const { json, fileName } = this.__createJsonBase(filename);
    this.__createBufferViewsAndAccessors(json, collectedEntities);
    this.__createNodes(json, collectedEntities, topLevelEntities);
    await this.__createMaterials(json, collectedEntities, option);
    createEffekseer(json, collectedEntities);
    const arraybuffer = this.__createBinary(json);
    this.__deleteEmptyArrays(json);
    const glbArrayBuffer = generateGlbArrayBuffer(json, arraybuffer);
    if (option.type === GLTF2_EXPORT_GLB) {
      this.__downloadGlb(json, fileName, glbArrayBuffer);
    } else if (option.type === GLTF2_EXPORT_GLTF) {
      this.__downloadGltf(json, fileName, arraybuffer);
    }
    return glbArrayBuffer;
  }
  static __deleteEmptyArrays(json) {
    if (json.accessors.length === 0) {
      delete json.accessors;
    }
    if (json.bufferViews.length === 0) {
      delete json.bufferViews;
    }
    if (json.materials.length === 0) {
      delete json.materials;
    }
    if (json.meshes.length === 0) {
      delete json.meshes;
    }
    if (json.skins.length === 0) {
      delete json.skins;
    }
    if (json.textures.length === 0) {
      delete json.textures;
    }
    if (json.images.length === 0) {
      delete json.images;
    }
    if (json.animations.length === 0) {
      delete json.animations;
    }
    if (Is.exist(json.extensionsUsed) && json.extensionsUsed.length === 0) {
      delete json.extensionsUsed;
    }
    if (json.cameras.length === 0) {
      delete json.cameras;
    }
    delete json.extras;
  }
  /**
  * collect target entities. This exporter includes their descendants for the output.
  * @param option an option config
  * @returns target entities
  */
  static __collectEntities(option) {
    const checkPassOrNotWithTags = /* @__PURE__ */ __name((entity) => {
      if (Is.exist(option) && Is.exist(option.excludeTags)) {
        for (const tag of option.excludeTags) {
          if (entity.matchTag(tag.tag, tag.value)) {
            return false;
          }
        }
        if (entity.matchTag("Being", "gizmo")) {
          return true;
        }
      }
      return true;
    }, "checkPassOrNotWithTags");
    const excludeWithTags = /* @__PURE__ */ __name((entity) => {
      if (Is.exist(option) && Is.exist(option.excludeTags)) {
        for (const tag of option.excludeTags) {
          if (entity.matchTag(tag.tag, tag.value)) {
            return [];
          }
        }
      }
      return [
        entity
      ];
    }, "excludeWithTags");
    const collectDescendants = /* @__PURE__ */ __name((entity, root) => {
      const sg = entity.getSceneGraph();
      if (sg.children.length > 0) {
        const array = root ? [] : excludeWithTags(entity);
        for (let i2 = 0; i2 < sg.children.length; i2++) {
          const child = sg.children[i2];
          Array.prototype.push.apply(array, collectDescendants(child.entity, false));
        }
        return array;
      } else {
        return root ? [] : excludeWithTags(entity);
      }
    }, "collectDescendants");
    if (Is.exist(option) && Is.exist(option.entities) && option.entities.length > 0) {
      const collectedDescendants = option.entities.flatMap((entity) => collectDescendants(entity, true));
      let topLevelEntities2 = [];
      option.entities.forEach((entity) => {
        if (collectedDescendants.indexOf(entity) === -1 && checkPassOrNotWithTags(entity)) {
          topLevelEntities2.push(entity);
        }
      });
      let collectedEntities2 = option.entities.concat();
      Array.prototype.push.apply(collectedEntities2, collectedDescendants);
      collectedEntities2 = [
        ...new Set(collectedEntities2)
      ];
      if (topLevelEntities2.length === 0) {
        topLevelEntities2 = collectedEntities2;
      }
      return {
        collectedEntities: collectedEntities2,
        topLevelEntities: topLevelEntities2
      };
    }
    let collectedEntities = EntityRepository._getEntities();
    collectedEntities = collectedEntities.filter((entity) => checkPassOrNotWithTags(entity));
    let topLevelEntities = SceneGraphComponent.getTopLevelComponents().flatMap((c2) => c2.entity);
    topLevelEntities = topLevelEntities.filter((entity) => checkPassOrNotWithTags(entity));
    collectedEntities = collectedEntities.flatMap((entity) => collectDescendants(entity, true));
    Array.prototype.push.apply(collectedEntities, topLevelEntities);
    collectedEntities = [
      ...new Set(collectedEntities)
    ];
    return {
      collectedEntities,
      topLevelEntities
    };
  }
  /**
  * create the base of glTF2 JSON
  * @param filename target output path
  * @returns the json and fileName in a object
  */
  static __createJsonBase(filename) {
    const fileName = filename ? filename : "Rhodonite_" + (/* @__PURE__ */ new Date()).getTime();
    const json = {
      asset: {
        version: "2.0",
        generator: `Rhodonite (${VERSION.version})`
      },
      buffers: [
        {
          uri: fileName + ".bin",
          byteLength: 0
        }
      ],
      bufferViews: [],
      accessors: [],
      animations: [],
      meshes: [],
      skins: [],
      materials: [
        {
          pbrMetallicRoughness: {
            baseColorFactor: [
              1,
              1,
              1,
              1
            ]
          }
        }
      ],
      textures: [],
      images: [],
      extensionsUsed: [],
      extensions: {},
      extras: {
        rnSkins: [],
        bufferViewByteLengthAccumulatedArray: []
      },
      cameras: [],
      samplers: []
    };
    return {
      json,
      fileName
    };
  }
  /**
  * create Gltf2BufferViews and Gltf2Accessors for the output glTF2 JSON
  * @param json
  * @param entities
  */
  static __createBufferViewsAndAccessors(json, entities) {
    const existingUniqueRnBuffers = [];
    const existingUniqueRnBufferViews = [];
    const existingUniqueRnAccessors = [];
    __createBufferViewsAndAccessorsOfMesh(json, entities, existingUniqueRnBuffers, existingUniqueRnBufferViews, existingUniqueRnAccessors);
    __createBufferViewsAndAccessorsOfAnimation(json, entities);
    __createBufferViewsAndAccessorsOfSkin(json, entities, existingUniqueRnBuffers, existingUniqueRnBufferViews, existingUniqueRnAccessors);
  }
  /**
  * create Gltf2Nodes for the output glTF2 JSON
  * @param json a glTF2 JSON
  * @param entities target entities
  * @param indicesOfGltfMeshes the indices of Gltf2Meshes
  */
  static __createNodes(json, entities, topLevelEntities) {
    json.nodes = [];
    json.scenes = [
      {
        nodes: []
      }
    ];
    const scene = json.scenes[0];
    for (let i2 = 0; i2 < entities.length; i2++) {
      const entity = entities[i2];
      entity.gltfNodeIndex = i2;
    }
    let meshCount = 0;
    for (let i2 = 0; i2 < entities.length; i2++) {
      const entity = entities[i2];
      json.nodes[i2] = {};
      const node = json.nodes[i2];
      node.name = entity.uniqueName;
      const sceneGraphComponent = entity.getSceneGraph();
      const children = sceneGraphComponent.children;
      if (children.length > 0) {
        node.children = [];
        for (let j = 0; j < children.length; j++) {
          const child = children[j];
          if (Is.exist(child.entity.gltfNodeIndex)) {
            node.children.push(child.entity.gltfNodeIndex);
          }
        }
      }
      if (sceneGraphComponent.isBillboard) {
        node.extensions = {
          RHODONITE_billboard: {
            isBillboard: true
          }
        };
        if (json.extensionsUsed.indexOf("RHODONITE_billboard") === -1) {
          json.extensionsUsed.push("RHODONITE_billboard");
        }
      }
      const transform = entity.getTransform();
      node.rotation = [
        transform.localRotationInner.x,
        transform.localRotationInner.y,
        transform.localRotationInner.z,
        transform.localRotationInner.w
      ];
      node.scale = [
        transform.localScaleInner.x,
        transform.localScaleInner.y,
        transform.localScaleInner.z
      ];
      node.translation = [
        transform.localPositionInner.x,
        transform.localPositionInner.y,
        transform.localPositionInner.z
      ];
      const meshComponent = entity.tryToGetMesh();
      if (Is.exist(meshComponent) && Is.exist(meshComponent.mesh)) {
        node.mesh = meshCount++;
      }
      const blendShapeComponent = entity.tryToGetBlendShape();
      if (Is.exist(blendShapeComponent)) {
        const weights = blendShapeComponent.weights;
        if (weights.length > 0) {
          node.weights = weights;
        }
      }
      const skinComponent = entity.tryToGetSkeletal();
      if (Is.exist(skinComponent)) {
        const entityIdx = json.extras.rnSkins.indexOf(skinComponent.entity);
        if (entityIdx >= 0) {
          node.skin = entityIdx;
        }
      }
      const cameraComponent = entity.tryToGetCamera();
      if (Is.exist(cameraComponent)) {
        let glTF2Camera;
        if (cameraComponent.type === CameraType.Perspective) {
          const originalAspect = cameraComponent.getTagValue("OriginalAspect");
          const originalFovY = cameraComponent.getTagValue("OriginalFovY");
          glTF2Camera = {
            name: cameraComponent.entity.uniqueName,
            type: "perspective",
            perspective: {
              aspectRatio: Is.exist(originalAspect) ? originalAspect : cameraComponent.aspect,
              yfov: Is.exist(originalFovY) ? MathUtil.degreeToRadian(originalFovY) : MathUtil.degreeToRadian(cameraComponent.fovy),
              znear: cameraComponent.zNear,
              zfar: cameraComponent.zFar
            }
          };
        } else if (cameraComponent.type === CameraType.Orthographic) {
          const originalXMag = cameraComponent.getTagValue("OriginalXMag");
          const originalYMag = cameraComponent.getTagValue("OriginalYMag");
          glTF2Camera = {
            name: cameraComponent.entity.uniqueName,
            type: "orthographic",
            orthographic: {
              xmag: Is.exist(originalXMag) ? originalXMag : cameraComponent.xMag,
              ymag: Is.exist(originalYMag) ? originalYMag : cameraComponent.yMag,
              znear: cameraComponent.zNear,
              zfar: cameraComponent.zFar
            }
          };
        }
        json.cameras.push(glTF2Camera);
        node.camera = json.cameras.length - 1;
      }
    }
    topLevelEntities.forEach((entity, i2) => {
      const idx = entities.indexOf(entity);
      if (idx >= 0) {
        scene.nodes.push(idx);
      }
    });
  }
  /**
  * create Gltf2Materials and set them to Gltf2Primitives for the output glTF2 JSON
  * @param json a glTF2 JSON
  * @param entities all target entities
  */
  static async __createMaterials(json, entities, option) {
    let countMesh = 0;
    const promises = [];
    json.extras.bufferViewByteLengthAccumulatedArray.push(0);
    const bufferIdx = json.extras.bufferViewByteLengthAccumulatedArray.length - 1;
    for (let i2 = 0; i2 < entities.length; i2++) {
      const entity = entities[i2];
      const meshComponent = entity.tryToGetMesh();
      if (meshComponent && meshComponent.mesh) {
        const gltf2Mesh = json.meshes[countMesh++];
        const primitiveCount = meshComponent.mesh.getPrimitiveNumber();
        for (let j = 0; j < primitiveCount; j++) {
          const rnPrimitive = meshComponent.mesh.getPrimitiveAt(j);
          const primitive = gltf2Mesh.primitives[j];
          const rnMaterial = rnPrimitive.material;
          const material = {
            pbrMetallicRoughness: {
              metallicFactor: 1,
              roughnessFactor: 1
            }
          };
          let colorParam;
          if (Is.exist(rnMaterial)) {
            if (Is.false(rnMaterial.isLighting)) {
              if (Is.not.exist(material.extensions)) {
                material.extensions = {};
              }
              material.extensions.KHR_materials_unlit = {};
              if (json.extensionsUsed.indexOf("KHR_materials_unlit") < 0) {
                json.extensionsUsed.push("KHR_materials_unlit");
              }
            }
            colorParam = rnMaterial.getParameter("baseColorFactor");
            if (Is.not.exist(colorParam)) {
              colorParam = rnMaterial.getParameter("diffuseColorFactor");
              if (Is.not.exist(colorParam)) {
                colorParam = Vector4.fromCopy4(1, 1, 1, 1);
              }
            } else {
              material.pbrMetallicRoughness.metallicFactor = rnMaterial.getParameter("metallicRoughnessFactor").x;
              material.pbrMetallicRoughness.roughnessFactor = rnMaterial.getParameter("metallicRoughnessFactor").y;
            }
            material.pbrMetallicRoughness.baseColorFactor = Array.prototype.slice.call(colorParam._v);
            material.alphaMode = rnMaterial.alphaMode.toGltfString();
            const existedImages = [];
            const processTexture = /* @__PURE__ */ __name((rnTexture, rnSampler) => {
              if (rnTexture && rnTexture.width > 1 && rnTexture.height > 1) {
                let imageIndex = json.images.length;
                let match = false;
                for (let k = 0; k < json.images.length; k++) {
                  const image = json.images[k];
                  if (Is.exist(image.rnTextureUID) && image.rnTextureUID === rnTexture.textureUID) {
                    imageIndex = k;
                    match = true;
                  }
                }
                let samplerIdx = -1;
                {
                  const gltf2TextureSampler = {
                    magFilter: rnSampler != null ? rnSampler.magFilter.index : TextureParameter.Linear.index,
                    minFilter: rnSampler != null ? rnSampler.minFilter.index : TextureParameter.Linear.index,
                    wrapS: rnSampler != null ? rnSampler.wrapS.index : TextureParameter.TextureWrapS.index,
                    wrapT: rnSampler != null ? rnSampler.wrapT.index : TextureParameter.TextureWrapT.index
                  };
                  samplerIdx = json.samplers.findIndex((sampler) => {
                    return isSameGlTF2TextureSampler(gltf2TextureSampler, sampler);
                  });
                  if (samplerIdx === -1) {
                    json.samplers.push(gltf2TextureSampler);
                    samplerIdx = json.samplers.length - 1;
                  }
                }
                if (!match) {
                  const glTF2ImageEx = {
                    uri: rnTexture.name
                  };
                  glTF2ImageEx.rnTextureUID = rnTexture.textureUID;
                  if (existedImages.indexOf(rnTexture.name) !== -1) {
                    glTF2ImageEx.uri += "_" + rnTexture.textureUID;
                  }
                  existedImages.push(glTF2ImageEx.uri);
                  if (Is.not.exist(glTF2ImageEx.uri.match(/\.(png)/))) {
                    glTF2ImageEx.uri += ".png";
                  }
                  const htmlCanvasElement = rnTexture.htmlCanvasElement;
                  if (htmlCanvasElement) {
                    const promise = new Promise((resolve, rejected) => {
                      htmlCanvasElement.toBlob((blob) => {
                        if (Is.exist(blob)) {
                          handleTextureImage(json, bufferIdx, blob, option, glTF2ImageEx, resolve, rejected);
                        } else {
                          throw Error("canvas to blob error!");
                        }
                      });
                    });
                    promises.push(promise);
                  }
                  json.images.push(glTF2ImageEx);
                }
                const gltf2Texture = {
                  sampler: samplerIdx,
                  source: imageIndex
                };
                const textureIdx = json.textures.indexOf(gltf2Texture);
                if (textureIdx === -1) {
                  json.textures.push(gltf2Texture);
                }
                return json.textures.indexOf(gltf2Texture);
              }
              return void 0;
            }, "processTexture");
            let textureParam = rnMaterial.getParameter("baseColorTexture");
            let textureIndex;
            if (textureParam != null) {
              const rnTexture = textureParam[1];
              const rnSampler = textureParam[2];
              textureIndex = processTexture(rnTexture, rnSampler);
              if (textureIndex != null) {
                material.pbrMetallicRoughness.baseColorTexture = {
                  index: textureIndex
                };
              }
            } else {
              textureParam = rnMaterial.getParameter("diffuseColorTexture");
              if (textureParam != null) {
                const rnTexture = textureParam[1];
                const rnSampler = textureParam[2];
                const textureIndex2 = processTexture(rnTexture, rnSampler);
                if (textureIndex2 != null) {
                  material.pbrMetallicRoughness.diffuseColorTexture = {
                    index: textureIndex2
                  };
                }
              }
            }
            textureParam = rnMaterial.getParameter("metallicRoughnessTexture");
            if (textureParam) {
              const rnTexture = textureParam[1];
              const rnSampler = textureParam[2];
              textureIndex = processTexture(rnTexture, rnSampler);
              if (textureIndex != null) {
                material.pbrMetallicRoughness.metallicRoughnessTexture = {
                  index: textureIndex
                };
              }
            }
            textureParam = rnMaterial.getParameter("normalTexture");
            if (textureParam) {
              const rnTexture = textureParam[1];
              const rnSampler = textureParam[2];
              textureIndex = processTexture(rnTexture, rnSampler);
              if (textureIndex != null) {
                material.normalTexture = {
                  index: textureIndex
                };
              }
            }
            textureParam = rnMaterial.getParameter("occlusionTexture");
            if (textureParam) {
              const rnTexture = textureParam[1];
              const rnSampler = textureParam[2];
              textureIndex = processTexture(rnTexture, rnSampler);
              if (textureIndex != null) {
                material.occlusionTexture = {
                  index: textureIndex
                };
              }
            }
            textureParam = rnMaterial.getParameter("emissiveTexture");
            if (textureParam) {
              const rnTexture = textureParam[1];
              const rnSampler = textureParam[2];
              textureIndex = processTexture(rnTexture, rnSampler);
              if (textureIndex != null) {
                material.emissiveTexture = {
                  index: textureIndex
                };
              }
            }
          }
          const imageIdx = json.materials.indexOf(material);
          if (imageIdx === -1) {
            json.materials.push(material);
          }
          primitive.material = json.materials.indexOf(material);
        }
      }
    }
    return Promise.all(promises);
  }
  /**
  * create the arraybuffer of the glTF2 .bin file and write all accessors data to the arraybuffer
  * @param json a glTF2 JSON
  * @returns A arraybuffer
  */
  static __createBinary(json) {
    if (Is.undefined(json.accessors) || Is.undefined(json.bufferViews)) {
      return new ArrayBuffer(0);
    }
    const byteLengthOfUniteBuffer = json.extras.bufferViewByteLengthAccumulatedArray.reduce((sum, val) => sum + val);
    if (byteLengthOfUniteBuffer > 0) {
      const buffer = json.buffers[0];
      buffer.byteLength = byteLengthOfUniteBuffer + DataUtil.calcPaddingBytes(byteLengthOfUniteBuffer, 4);
    }
    const arrayBuffer = new ArrayBuffer(json.buffers[0].byteLength);
    let lastCopiedByteLengthOfBufferView = 0;
    for (let i2 = 0; i2 < json.bufferViews.length; i2++) {
      const bufferView = json.bufferViews[i2];
      const uint8ArrayOfBufferView = bufferView.extras.uint8Array;
      delete bufferView.extras;
      const distByteOffset = lastCopiedByteLengthOfBufferView;
      DataUtil.copyArrayBufferWithPadding({
        src: uint8ArrayOfBufferView.buffer,
        dist: arrayBuffer,
        srcByteOffset: uint8ArrayOfBufferView.byteOffset,
        copyByteLength: uint8ArrayOfBufferView.byteLength,
        distByteOffset
      });
      lastCopiedByteLengthOfBufferView += DataUtil.addPaddingBytes(uint8ArrayOfBufferView.byteLength, 4);
      bufferView.byteOffset = distByteOffset;
      bufferView.buffer = 0;
    }
    return arrayBuffer;
  }
  /**
  * download the glTF2 files
  * @param json a glTF2 JSON
  * @param filename target output path
  * @param arraybuffer an ArrayBuffer of the .bin file
  */
  static __downloadGlb(json, filename, arraybuffer) {
    {
      const a2 = document.createElement("a");
      a2.download = filename + ".glb";
      const blob = new Blob([
        arraybuffer
      ], {
        type: "octet/stream"
      });
      const url = URL.createObjectURL(blob);
      a2.href = url;
      const e3 = new MouseEvent("click");
      a2.dispatchEvent(e3);
    }
  }
  exportGlbAsArrayBuffer() {
  }
  /**
  * download the glTF2 files
  * @param json a glTF2 JSON
  * @param filename target output path
  * @param arraybuffer an ArrayBuffer of the .bin file
  */
  static __downloadGltf(json, filename, arraybuffer) {
    {
      const a2 = document.createElement("a");
      a2.download = filename + ".gltf";
      const str = JSON.stringify(json, null, 2);
      a2.href = "data:application/octet-stream," + encodeURIComponent(str);
      const e3 = new MouseEvent("click");
      a2.dispatchEvent(e3);
    }
    {
      const a2 = document.createElement("a");
      a2.download = filename + ".bin";
      const blob = new Blob([
        arraybuffer
      ], {
        type: "octet/stream"
      });
      const url = URL.createObjectURL(blob);
      a2.href = url;
      const e3 = new MouseEvent("click");
      a2.dispatchEvent(e3);
    }
  }
};
__name(_Gltf2Exporter, "Gltf2Exporter");
var Gltf2Exporter = _Gltf2Exporter;
function generateGlbArrayBuffer(json, arraybuffer) {
  const headerBytes = 12;
  delete json.buffers[0].uri;
  let jsonStr = JSON.stringify(json, null, 2);
  let jsonArrayBuffer = DataUtil.stringToBuffer(jsonStr);
  const paddingBytes = DataUtil.calcPaddingBytes(jsonArrayBuffer.byteLength, 4);
  if (paddingBytes > 0) {
    for (let i2 = 0; i2 < paddingBytes; i2++) {
      jsonStr += " ";
    }
    jsonArrayBuffer = DataUtil.stringToBuffer(jsonStr);
  }
  const jsonChunkLength = jsonArrayBuffer.byteLength;
  const headerAndChunk0 = headerBytes + 4 + 4 + jsonChunkLength;
  const totalBytes = headerAndChunk0 + 4 + 4 + arraybuffer.byteLength;
  const glbArrayBuffer = new ArrayBuffer(totalBytes);
  const dataView = new DataView(glbArrayBuffer);
  dataView.setUint32(0, 1179937895, true);
  dataView.setUint32(4, 2, true);
  dataView.setUint32(8, totalBytes, true);
  dataView.setUint32(12, jsonArrayBuffer.byteLength, true);
  dataView.setUint32(16, 1313821514, true);
  DataUtil.copyArrayBufferAs4Bytes({
    src: jsonArrayBuffer,
    dist: glbArrayBuffer,
    srcByteOffset: 0,
    copyByteLength: jsonArrayBuffer.byteLength,
    distByteOffset: 20
  });
  DataUtil.copyArrayBufferAs4Bytes({
    src: arraybuffer,
    dist: glbArrayBuffer,
    srcByteOffset: 0,
    copyByteLength: arraybuffer.byteLength,
    distByteOffset: 20 + jsonChunkLength + 8
  });
  dataView.setUint32(headerAndChunk0, arraybuffer.byteLength, true);
  dataView.setUint32(headerAndChunk0 + 4, 5130562, true);
  return glbArrayBuffer;
}
__name(generateGlbArrayBuffer, "generateGlbArrayBuffer");
function __createBufferViewsAndAccessorsOfSkin(json, entities, existingUniqueRnBuffers, existingUniqueRnBufferViews, existingUniqueRnAccessors) {
  for (let i2 = 0; i2 < entities.length; i2++) {
    const entity = entities[i2];
    const skeletalComponent = entity.tryToGetSkeletal();
    if (Is.not.exist(skeletalComponent)) {
      continue;
    }
    json.extras.rnSkins.push(skeletalComponent.entity);
    const jointSceneComponentsOfTheEntity = skeletalComponent.getJoints();
    const jointIndicesOfTheEntity = [];
    for (const jointSceneComponent of jointSceneComponentsOfTheEntity) {
      entities.forEach((entityObj, j) => {
        if (jointSceneComponent.entity === entityObj) {
          jointIndicesOfTheEntity.push(j);
        }
      });
    }
    const inverseBindMatRnAccessor = skeletalComponent.getInverseBindMatricesAccessor();
    if (Is.exist(inverseBindMatRnAccessor)) {
      createOrReuseGltf2BufferView(json, existingUniqueRnBuffers, existingUniqueRnBufferViews, inverseBindMatRnAccessor.bufferView);
      createOrReuseGltf2Accessor(json, json.bufferViews.length - 1, existingUniqueRnAccessors, inverseBindMatRnAccessor);
    }
    const topOfJointsSkeletonSceneComponent = skeletalComponent.topOfJointsHierarchy;
    const bindShapeMatrix = skeletalComponent._bindShapeMatrix;
    let skeletalIdx = -1;
    if (Is.exist(topOfJointsSkeletonSceneComponent)) {
      const skeletalEntity = topOfJointsSkeletonSceneComponent.entity;
      skeletalIdx = entities.indexOf(skeletalEntity);
    } else {
      skeletalIdx = jointIndicesOfTheEntity[0];
    }
    const skinJson = {
      joints: jointIndicesOfTheEntity,
      inverseBindMatrices: json.accessors.length - 1,
      skeleton: skeletalIdx >= 0 ? skeletalIdx : void 0,
      bindShapeMatrix: bindShapeMatrix == null ? void 0 : bindShapeMatrix.flattenAsArray()
    };
    json.skins.push(skinJson);
  }
}
__name(__createBufferViewsAndAccessorsOfSkin, "__createBufferViewsAndAccessorsOfSkin");
function __createBufferViewsAndAccessorsOfMesh(json, entities, existingUniqueRnBuffers, existingUniqueRnBufferViews, existingUniqueRnAccessors) {
  for (let i2 = 0; i2 < entities.length; i2++) {
    const entity = entities[i2];
    const meshComponent = entity.tryToGetMesh();
    if (Is.exist(meshComponent) && meshComponent.mesh) {
      const mesh = {
        primitives: []
      };
      const primitiveCount = meshComponent.mesh.getPrimitiveNumber();
      for (let j = 0; j < primitiveCount; j++) {
        const rnPrimitive = meshComponent.mesh.getPrimitiveAt(j);
        const primitive = {
          attributes: {},
          mode: rnPrimitive.primitiveMode.index
        };
        const rnIndicesAccessor = rnPrimitive.indicesAccessor;
        if (Is.exist(rnIndicesAccessor)) {
          const rnBufferView = rnIndicesAccessor.bufferView;
          const gltf2BufferView = createOrReuseGltf2BufferView(json, existingUniqueRnBuffers, existingUniqueRnBufferViews, rnBufferView, GL_ELEMENT_ARRAY_BUFFER);
          const gltf2Accessor = createOrReuseGltf2Accessor(json, json.bufferViews.indexOf(gltf2BufferView), existingUniqueRnAccessors, rnIndicesAccessor);
          const accessorIdx = json.accessors.indexOf(gltf2Accessor);
          primitive.indices = accessorIdx;
        }
        const attributeAccessors = rnPrimitive.attributeAccessors;
        for (let j2 = 0; j2 < attributeAccessors.length; j2++) {
          const attributeJoinedString = rnPrimitive.attributeSemantics[j2];
          const attributeName = attributeJoinedString.split(".")[0];
          if (attributeName === "BARY_CENTRIC_COORD") {
            continue;
          }
          const rnAttributeAccessor = attributeAccessors[j2];
          const rnBufferView = rnAttributeAccessor.bufferView;
          const gltf2BufferView = createOrReuseGltf2BufferViewForVertexAttributeBuffer(json, existingUniqueRnBuffers, existingUniqueRnBufferViews, rnBufferView, rnAttributeAccessor);
          const gltf2Accessor = createOrReuseGltf2Accessor(json, json.bufferViews.indexOf(gltf2BufferView), existingUniqueRnAccessors, rnAttributeAccessor);
          const accessorIdx = json.accessors.indexOf(gltf2Accessor);
          primitive.attributes[attributeName] = accessorIdx;
        }
        setupBlandShapeData(entity, rnPrimitive, primitive, json, existingUniqueRnBuffers, existingUniqueRnBufferViews, existingUniqueRnAccessors);
        mesh.primitives[j] = primitive;
      }
      json.meshes.push(mesh);
    }
  }
}
__name(__createBufferViewsAndAccessorsOfMesh, "__createBufferViewsAndAccessorsOfMesh");
function setupBlandShapeData(entity, rnPrimitive, primitive, json, existingUniqueRnBuffers, existingUniqueRnBufferViews, existingUniqueRnAccessors) {
  const blendShapeComponent = entity.tryToGetBlendShape();
  if (Is.exist(blendShapeComponent)) {
    const targets = rnPrimitive.getBlendShapeTargets();
    if (Is.not.exist(primitive.targets)) {
      primitive.targets = [];
    }
    for (const target of targets) {
      const targetJson = {};
      for (const [attributeName, rnAccessor] of target.entries()) {
        const gltf2BufferView = createOrReuseGltf2BufferView(json, existingUniqueRnBuffers, existingUniqueRnBufferViews, rnAccessor.bufferView, GL_ARRAY_BUFFER);
        const gltf2Accessor = createOrReuseGltf2Accessor(json, json.bufferViews.indexOf(gltf2BufferView), existingUniqueRnAccessors, rnAccessor);
        const accessorIdx = json.accessors.indexOf(gltf2Accessor);
        const attributeJoinedString = attributeName;
        const attribute = attributeJoinedString.split(".")[0];
        targetJson[attribute] = accessorIdx;
      }
      primitive.targets.push(targetJson);
    }
  }
}
__name(setupBlandShapeData, "setupBlandShapeData");
function __createBufferViewsAndAccessorsOfAnimation(json, entities) {
  let sumOfBufferViewByteLengthAccumulated = 0;
  const bufferIdx = json.extras.bufferViewByteLengthAccumulatedArray.length;
  for (let i2 = 0; i2 < entities.length; i2++) {
    const entity = entities[i2];
    const animationComponent = entity.tryToGetAnimation();
    if (Is.exist(animationComponent)) {
      const trackNames = animationComponent.getAnimationTrackNames();
      for (const trackName of trackNames) {
        const animation = {
          channels: [],
          samplers: []
        };
        json.animations.push(animation);
        let samplerIdx = 0;
        const rnAnimationTrack = animationComponent.getAnimationChannelsOfTrack(trackName);
        if (Is.exist(rnAnimationTrack)) {
          const rnChannels = rnAnimationTrack.values();
          for (const rnChannel of rnChannels) {
            if (rnChannel.target.pathName === "effekseer") {
              continue;
            }
            const { inputAccessorIdx, inputBufferViewByteLengthAccumulated } = createGltf2BufferViewAndGltf2AccessorForInput(json, rnChannel, bufferIdx, sumOfBufferViewByteLengthAccumulated);
            sumOfBufferViewByteLengthAccumulated += inputBufferViewByteLengthAccumulated;
            const { outputAccessorIdx, outputBufferViewByteLengthAccumulated } = createGltf2BufferViewAndGltf2AccessorForOutput(json, rnChannel, bufferIdx, sumOfBufferViewByteLengthAccumulated);
            sumOfBufferViewByteLengthAccumulated += outputBufferViewByteLengthAccumulated;
            samplerIdx = createGltf2AnimationChannel(rnChannel, samplerIdx, animation, i2);
            createGltf2AnimationSampler(inputAccessorIdx, outputAccessorIdx, rnChannel, animation);
          }
        }
      }
    }
  }
  json.extras.bufferViewByteLengthAccumulatedArray.push(sumOfBufferViewByteLengthAccumulated);
}
__name(__createBufferViewsAndAccessorsOfAnimation, "__createBufferViewsAndAccessorsOfAnimation");
function calcAccessorIdxToSet(existingUniqueRnAccessors, rnAccessor) {
  const accessorIdx = existingUniqueRnAccessors.findIndex((accessor) => {
    return accessor.isSame(rnAccessor);
  });
  return accessorIdx;
}
__name(calcAccessorIdxToSet, "calcAccessorIdxToSet");
function createOrReuseGltf2BufferViewForVertexAttributeBuffer(json, existingUniqueRnBuffers, existingUniqueRnBufferViews, rnBufferView, rnAccessor) {
  const bufferViewIdx = findBufferViewIdx(existingUniqueRnBufferViews, rnBufferView);
  if (bufferViewIdx === -1) {
    const bufferIdxToSet = calcBufferIdxToSet(existingUniqueRnBuffers, rnBufferView.buffer);
    const gltf2BufferView2 = {
      buffer: bufferIdxToSet,
      byteLength: rnBufferView.byteLength,
      byteOffset: rnBufferView.byteOffsetInBuffer,
      extras: {
        uint8Array: rnBufferView.getUint8Array()
      }
    };
    gltf2BufferView2.target = GL_ARRAY_BUFFER;
    json.extras.bufferViewByteLengthAccumulatedArray[bufferIdxToSet] = accumulateBufferViewByteLength(json.extras.bufferViewByteLengthAccumulatedArray, bufferIdxToSet, gltf2BufferView2);
    if (Is.exist(gltf2BufferView2.target)) {
      gltf2BufferView2.byteStride = rnAccessor.elementSizeInBytes;
    }
    existingUniqueRnBufferViews.push(rnBufferView);
    json.bufferViews.push(gltf2BufferView2);
    return gltf2BufferView2;
  }
  const gltf2BufferView = json.bufferViews[bufferViewIdx];
  return gltf2BufferView;
}
__name(createOrReuseGltf2BufferViewForVertexAttributeBuffer, "createOrReuseGltf2BufferViewForVertexAttributeBuffer");
function findBufferViewIdx(existingUniqueRnBufferViews, rnBufferView) {
  const bufferViewIdx = existingUniqueRnBufferViews.findIndex((bufferView) => bufferView.isSame(rnBufferView));
  return bufferViewIdx;
}
__name(findBufferViewIdx, "findBufferViewIdx");
function calcBufferIdxToSet(existingUniqueRnBuffers, rnBuffer) {
  if (existingUniqueRnBuffers.length === 0) {
    existingUniqueRnBuffers.push(rnBuffer);
  }
  const bufferIdx = existingUniqueRnBuffers.findIndex((buffer) => buffer.isSame(rnBuffer));
  const bufferIdxToSet = bufferIdx === -1 ? existingUniqueRnBuffers.length : bufferIdx;
  if (bufferIdx === -1) {
    existingUniqueRnBuffers.push(rnBuffer);
  }
  return bufferIdxToSet;
}
__name(calcBufferIdxToSet, "calcBufferIdxToSet");
function accumulateBufferViewByteLength(bufferViewByteLengthAccumulatedArray, bufferIdxToSet, gltf2BufferView) {
  const bufferViewLengthAligned = Is.exist(bufferViewByteLengthAccumulatedArray[bufferIdxToSet]) ? bufferViewByteLengthAccumulatedArray[bufferIdxToSet] + DataUtil.addPaddingBytes(gltf2BufferView.byteLength, 4) : DataUtil.addPaddingBytes(gltf2BufferView.byteLength, 4);
  return bufferViewLengthAligned;
}
__name(accumulateBufferViewByteLength, "accumulateBufferViewByteLength");
function convertToGltfAnimationPathName(path) {
  switch (path) {
    case "translate":
      return "translation";
    case "quaternion":
      return "rotation";
    case "scale":
      return "scale";
    case "weights":
      return "weights";
    // case 'effekseer':
    //   return 'effekseer';
    default:
      throw new Error("Invalid Path Name");
  }
}
__name(convertToGltfAnimationPathName, "convertToGltfAnimationPathName");
function createGltf2AnimationChannel(channel, samplerIdx, animation, entityIdx) {
  const pathName = channel.target.pathName;
  const channelJson = {
    sampler: samplerIdx++,
    target: {
      path: convertToGltfAnimationPathName(pathName),
      node: entityIdx
    }
  };
  animation.channels.push(channelJson);
  return samplerIdx;
}
__name(createGltf2AnimationChannel, "createGltf2AnimationChannel");
function createGltf2AnimationSampler(inputAccessorIdx, outputAccessorIdx, channel, animation) {
  const samplerJson = {
    input: inputAccessorIdx,
    output: outputAccessorIdx,
    interpolation: channel.sampler.interpolationMethod.GltfString
  };
  animation.samplers.push(samplerJson);
}
__name(createGltf2AnimationSampler, "createGltf2AnimationSampler");
function createGltf2BufferViewAndGltf2AccessorForInput(json, rnChannel, bufferIdx, bufferViewByteLengthAccumulated) {
  const componentType = ComponentType.fromTypedArray(ArrayBuffer.isView(rnChannel.sampler.input) ? rnChannel.sampler.input : new Float32Array(rnChannel.sampler.input));
  const accessorCount = rnChannel.sampler.input.length;
  const gltf2BufferView = createGltf2BufferViewForAnimation({
    bufferIdx,
    bufferViewByteOffset: bufferViewByteLengthAccumulated,
    accessorByteOffset: 0,
    accessorCount,
    bufferViewByteStride: ComponentType.Float.getSizeInBytes(),
    componentType,
    compositionType: CompositionType.Scalar,
    uint8Array: new Uint8Array(ArrayBuffer.isView(rnChannel.sampler.input) ? rnChannel.sampler.input.buffer : new Float32Array(rnChannel.sampler.input).buffer)
  });
  json.bufferViews.push(gltf2BufferView);
  const gltf2Accessor = createGltf2AccessorForAnimation({
    bufferViewIdx: json.bufferViews.indexOf(gltf2BufferView),
    accessorByteOffset: 0,
    componentType,
    count: accessorCount,
    compositionType: CompositionType.Scalar,
    min: [
      rnChannel.sampler.input[0]
    ],
    max: [
      rnChannel.sampler.input[rnChannel.sampler.input.length - 1]
    ]
  });
  json.accessors.push(gltf2Accessor);
  bufferViewByteLengthAccumulated = alignBufferViewByteLength(bufferViewByteLengthAccumulated, gltf2BufferView);
  const inputAccessorIdx = json.accessors.indexOf(gltf2Accessor);
  return {
    inputAccessorIdx,
    inputBufferViewByteLengthAccumulated: bufferViewByteLengthAccumulated
  };
}
__name(createGltf2BufferViewAndGltf2AccessorForInput, "createGltf2BufferViewAndGltf2AccessorForInput");
function createGltf2BufferViewAndGltf2AccessorForOutput(json, rnChannel, bufferIdx, bufferViewByteLengthAccumulated) {
  const componentType = ComponentType.fromTypedArray(ArrayBuffer.isView(rnChannel.sampler.output) ? rnChannel.sampler.output : new Float32Array(rnChannel.sampler.output));
  const pathName = rnChannel.target.pathName;
  let compositionType = CompositionType.toGltf2AnimationAccessorCompositionType(rnChannel.sampler.outputComponentN);
  let accessorCount = rnChannel.sampler.output.length / rnChannel.sampler.outputComponentN;
  if (pathName === "weights") {
    compositionType = CompositionType.Scalar;
    accessorCount = rnChannel.sampler.output.length;
  }
  const gltf2BufferView = createGltf2BufferViewForAnimation({
    bufferIdx,
    bufferViewByteOffset: bufferViewByteLengthAccumulated,
    accessorByteOffset: 0,
    accessorCount,
    bufferViewByteStride: componentType.getSizeInBytes() * rnChannel.sampler.outputComponentN,
    componentType,
    compositionType,
    uint8Array: new Uint8Array(ArrayBuffer.isView(rnChannel.sampler.output) ? rnChannel.sampler.output.buffer : new Float32Array(rnChannel.sampler.output).buffer)
  });
  json.bufferViews.push(gltf2BufferView);
  const gltf2Accessor = createGltf2AccessorForAnimation({
    bufferViewIdx: json.bufferViews.indexOf(gltf2BufferView),
    accessorByteOffset: 0,
    componentType,
    count: accessorCount,
    compositionType
  });
  json.accessors.push(gltf2Accessor);
  bufferViewByteLengthAccumulated = alignBufferViewByteLength(bufferViewByteLengthAccumulated, gltf2BufferView);
  const outputAccessorIdx = json.accessors.indexOf(gltf2Accessor);
  return {
    outputAccessorIdx,
    outputBufferViewByteLengthAccumulated: bufferViewByteLengthAccumulated
  };
}
__name(createGltf2BufferViewAndGltf2AccessorForOutput, "createGltf2BufferViewAndGltf2AccessorForOutput");
function alignBufferViewByteLength(bufferViewByteLengthAccumulated, bufferView) {
  bufferViewByteLengthAccumulated = bufferView.byteLength + DataUtil.calcPaddingBytes(bufferView.byteLength, 4);
  return bufferViewByteLengthAccumulated;
}
__name(alignBufferViewByteLength, "alignBufferViewByteLength");
function calcBufferViewByteLengthAndByteOffset({ accessorByteOffset, accessorCount, bufferViewByteStride, bufferViewByteOffset, sizeOfComponent, numberOfComponents }) {
  const effectiveByteStride = bufferViewByteStride === 0 ? sizeOfComponent * numberOfComponents : bufferViewByteStride;
  if (bufferViewByteStride % sizeOfComponent !== 0) {
    throw Error("glTF2: When byteStride is defined, it MUST be a multiple of the size of the accessor\u2019s component type.");
  }
  const effectiveByteStrideAligned = alignBufferViewByteStrideTo4Bytes(effectiveByteStride);
  const alignedAccessorByteOffset = alignAccessorByteOffsetTo4Bytes(accessorByteOffset);
  const bufferViewByteLength = alignedAccessorByteOffset + effectiveByteStrideAligned * (accessorCount - 1) + sizeOfComponent * numberOfComponents;
  const valByteLength = sizeOfComponent * numberOfComponents;
  const sumByteOffset = alignedAccessorByteOffset + bufferViewByteOffset;
  const paddingByte = valByteLength - sumByteOffset % valByteLength;
  const fixedBufferViewByteOffset = bufferViewByteOffset + paddingByte;
  const alignedBufferViewByteOffset = alignAccessorByteOffsetTo4Bytes(fixedBufferViewByteOffset);
  const fixedBufferViewByteLength = bufferViewByteLength;
  return {
    fixedBufferViewByteLength,
    fixedBufferViewByteOffset: alignedBufferViewByteOffset
  };
}
__name(calcBufferViewByteLengthAndByteOffset, "calcBufferViewByteLengthAndByteOffset");
function alignAccessorByteOffsetTo4Bytes(byteOffset) {
  const alignSize = 4;
  if (byteOffset % 4 === 0) {
    return byteOffset;
  }
  return byteOffset + (alignSize - byteOffset % alignSize);
}
__name(alignAccessorByteOffsetTo4Bytes, "alignAccessorByteOffsetTo4Bytes");
function alignBufferViewByteStrideTo4Bytes(byteStride) {
  const alignSize = 4;
  if (byteStride % 4 === 0) {
    return byteStride;
  }
  const byteStrideAlgined = byteStride + (alignSize - byteStride % alignSize);
  return byteStrideAlgined;
}
__name(alignBufferViewByteStrideTo4Bytes, "alignBufferViewByteStrideTo4Bytes");
async function handleTextureImage(json, bufferIdx, blob, option, glTF2ImageEx, resolve, rejected) {
  if (option.type === GLTF2_EXPORT_GLTF) {
    setTimeout(() => {
      const a2 = document.createElement("a");
      const e3 = new MouseEvent("click");
      a2.href = URL.createObjectURL(blob);
      a2.download = glTF2ImageEx.uri;
      a2.dispatchEvent(e3);
      URL.revokeObjectURL(a2.href);
    }, Math.random() * 5e3);
    resolve();
  } else {
    const reader = new FileReader();
    reader.addEventListener("load", () => {
      const arrayBuffer = reader.result;
      const gltf2BufferView = createAndAddGltf2BufferView(json, bufferIdx, new Uint8ClampedArray(arrayBuffer));
      glTF2ImageEx.bufferView = json.bufferViews.indexOf(gltf2BufferView);
      glTF2ImageEx.mimeType = "image/png";
      delete glTF2ImageEx.uri;
      resolve();
    });
    reader.addEventListener("error", () => {
      rejected(reader.error);
    });
    reader.readAsArrayBuffer(blob);
  }
}
__name(handleTextureImage, "handleTextureImage");
function createGltf2BufferViewForAnimation({ bufferIdx, bufferViewByteOffset, accessorByteOffset, accessorCount, bufferViewByteStride, componentType, compositionType, uint8Array }) {
  const alignedAccessorByteOffset = alignAccessorByteOffsetTo4Bytes(accessorByteOffset);
  const { fixedBufferViewByteLength, fixedBufferViewByteOffset } = calcBufferViewByteLengthAndByteOffset({
    accessorByteOffset: alignedAccessorByteOffset,
    accessorCount,
    bufferViewByteStride,
    bufferViewByteOffset,
    sizeOfComponent: componentType.getSizeInBytes(),
    numberOfComponents: compositionType.getNumberOfComponents()
  });
  const gltfBufferViewEx = {
    buffer: bufferIdx,
    byteLength: fixedBufferViewByteLength,
    byteOffset: fixedBufferViewByteOffset,
    extras: {
      uint8Array
    }
  };
  return gltfBufferViewEx;
}
__name(createGltf2BufferViewForAnimation, "createGltf2BufferViewForAnimation");
function createGltf2AccessorForAnimation({ bufferViewIdx, accessorByteOffset, componentType, count, compositionType, min, max }) {
  const alignedAccessorByteOffset = alignAccessorByteOffsetTo4Bytes(accessorByteOffset);
  const gltf2AccessorEx = {
    bufferView: bufferViewIdx,
    byteOffset: alignedAccessorByteOffset,
    componentType: ComponentType.toGltf2AccessorComponentType(componentType),
    count,
    type: compositionType.str,
    min,
    max,
    extras: {}
  };
  return gltf2AccessorEx;
}
__name(createGltf2AccessorForAnimation, "createGltf2AccessorForAnimation");
function createOrReuseGltf2BufferView(json, existingUniqueRnBuffers, existingUniqueRnBufferViews, rnBufferView, target) {
  const bufferViewIdx = findBufferViewIdx(existingUniqueRnBufferViews, rnBufferView);
  if (bufferViewIdx === -1) {
    const bufferIdxToSet = calcBufferIdxToSet(existingUniqueRnBuffers, rnBufferView.buffer);
    const gltf2BufferView2 = {
      buffer: bufferIdxToSet,
      byteLength: rnBufferView.byteLength,
      byteOffset: rnBufferView.byteOffsetInBuffer,
      extras: {
        uint8Array: rnBufferView.getUint8Array()
      }
    };
    if (Is.exist(target)) {
      gltf2BufferView2.target = target;
    }
    json.extras.bufferViewByteLengthAccumulatedArray[bufferIdxToSet] = accumulateBufferViewByteLength(json.extras.bufferViewByteLengthAccumulatedArray, bufferIdxToSet, gltf2BufferView2);
    existingUniqueRnBufferViews.push(rnBufferView);
    json.bufferViews.push(gltf2BufferView2);
    return gltf2BufferView2;
  }
  const gltf2BufferView = json.bufferViews[bufferViewIdx];
  return gltf2BufferView;
}
__name(createOrReuseGltf2BufferView, "createOrReuseGltf2BufferView");
function createOrReuseGltf2Accessor(json, bufferViewIdxToSet, existingUniqueRnAccessors, rnAccessor) {
  const accessorIdx = calcAccessorIdxToSet(existingUniqueRnAccessors, rnAccessor);
  if (accessorIdx === -1) {
    const gltf2Accessor2 = {
      bufferView: bufferViewIdxToSet,
      byteOffset: rnAccessor.byteOffsetInBufferView,
      componentType: ComponentType.toGltf2AccessorComponentType(rnAccessor.componentType),
      count: rnAccessor.elementCount,
      type: CompositionType.toGltf2AccessorCompositionTypeString(rnAccessor.compositionType.getNumberOfComponents()),
      extras: {
        uint8Array: void 0
      }
    };
    if (rnAccessor.compositionType.getNumberOfComponents() <= 4) {
      gltf2Accessor2.max = rnAccessor.max;
      gltf2Accessor2.min = rnAccessor.min;
    }
    existingUniqueRnAccessors.push(rnAccessor);
    json.accessors.push(gltf2Accessor2);
    return gltf2Accessor2;
  }
  const gltf2Accessor = json.accessors[accessorIdx];
  return gltf2Accessor;
}
__name(createOrReuseGltf2Accessor, "createOrReuseGltf2Accessor");

// src/foundation/geometry/shapes/Axis.ts
init_VertexAttribute();
init_PrimitiveMode();
init_IShape();
var _Axis = class _Axis extends IShape {
  /**
  * Generates a axis object
  * @param _desc a descriptor object of a Axis
  */
  generate(_desc) {
    var _a40;
    const desc = {
      length: (_a40 = _desc.length) != null ? _a40 : 1,
      material: _desc.material
    };
    const positions = [
      // X axis
      0,
      0,
      0,
      desc.length,
      0,
      0,
      // Y axis
      0,
      0,
      0,
      0,
      desc.length,
      0,
      // Z axis
      0,
      0,
      0,
      0,
      0,
      desc.length
    ];
    const colors = [
      // X axis as Red
      1,
      0,
      0,
      1,
      0,
      0,
      // Y axis as Green
      0,
      1,
      0,
      0,
      1,
      0,
      // Z axis as Blue
      0,
      0,
      1,
      0,
      0,
      1
    ];
    const attributes = [
      new Float32Array(positions),
      new Float32Array(colors)
    ];
    const attributeSemantics = [
      VertexAttribute.Position.XYZ,
      VertexAttribute.Color0.XYZ
    ];
    this.copyVertexData({
      attributes,
      attributeSemantics,
      primitiveMode: PrimitiveMode.Lines,
      material: desc.material
    });
  }
};
__name(_Axis, "Axis");
var Axis = _Axis;

// src/foundation/geometry/shapes/index.ts
init_Cube();

// src/foundation/geometry/shapes/Grid.ts
init_VertexAttribute();
init_PrimitiveMode();
init_IShape();
var _Grid = class _Grid extends IShape {
  /**
  * Generates a grid object
  * @param _desc a descriptor object of a Grid
  */
  generate(_desc) {
    var _a40, _b, _c, _d, _e;
    const desc = {
      length: (_a40 = _desc.length) != null ? _a40 : 1,
      division: (_b = _desc.division) != null ? _b : 10,
      isXY: (_c = _desc.isXY) != null ? _c : true,
      isXZ: (_d = _desc.isXZ) != null ? _d : true,
      isYZ: (_e = _desc.isYZ) != null ? _e : true,
      material: _desc.material
    };
    const positions = [];
    for (let i2 = 0; i2 < desc.division * 2 + 3; i2++) {
      const start = -desc.length;
      const oneUnitLength = desc.length / (desc.division + 1);
      if (desc.isXZ) {
        positions.push(-desc.length, 0, start + oneUnitLength * i2);
        positions.push(desc.length, 0, start + oneUnitLength * i2);
        positions.push(start + oneUnitLength * i2, 0, -desc.length);
        positions.push(start + oneUnitLength * i2, 0, desc.length);
      }
      if (desc.isXY) {
        positions.push(-desc.length, start + oneUnitLength * i2, 0);
        positions.push(desc.length, start + oneUnitLength * i2, 0);
        positions.push(start + oneUnitLength * i2, -desc.length, 0);
        positions.push(start + oneUnitLength * i2, desc.length, 0);
      }
      if (desc.isYZ) {
        positions.push(0, -desc.length, start + oneUnitLength * i2);
        positions.push(0, desc.length, start + oneUnitLength * i2);
        positions.push(0, start + oneUnitLength * i2, -desc.length);
        positions.push(0, start + oneUnitLength * i2, desc.length);
      }
    }
    const attributes = [
      new Float32Array(positions)
    ];
    const attributeSemantics = [
      VertexAttribute.Position.XYZ
    ];
    this.copyVertexData({
      attributes,
      attributeSemantics,
      primitiveMode: PrimitiveMode.Lines,
      material: desc == null ? void 0 : desc.material
    });
  }
};
__name(_Grid, "Grid");
var Grid = _Grid;

// src/foundation/geometry/shapes/index.ts
init_IShape();

// src/foundation/geometry/shapes/Joint.ts
init_Vector3();
init_PrimitiveMode();
init_VertexAttribute();
init_IShape();
var _Joint = class _Joint extends IShape {
  constructor() {
    super(...arguments);
    __publicField(this, "__worldPositionOfThisJoint", Vector3.fromCopyArray3([
      0,
      0,
      1
    ]));
    __publicField(this, "__worldPositionOfParentJoint", Vector3.fromCopyArray3([
      0,
      0,
      0
    ]));
    __publicField(this, "__width", 1);
  }
  /**
  * Generates a joint object
  */
  generate(desc) {
    const length = Vector3.lengthBtw(this.__worldPositionOfThisJoint, this.__worldPositionOfParentJoint);
    const arrowWidth = this.__width;
    const arrowheadLength = length / 7.5;
    const arrowStickLength = length - arrowheadLength;
    const deltaVec = Vector3.subtract(this.__worldPositionOfParentJoint, this.__worldPositionOfThisJoint);
    let directionToParent = Vector3.fromCopyArray3([
      0,
      1,
      0
    ]);
    if (!deltaVec.isEqual(Vector3.zero())) {
      directionToParent = Vector3.normalize(Vector3.subtract(this.__worldPositionOfParentJoint, this.__worldPositionOfThisJoint));
    }
    const arrowStickPosition = Vector3.add(this.__worldPositionOfThisJoint, Vector3.multiply(directionToParent, arrowStickLength));
    let dummyVector = Vector3.fromCopyArray3([
      0,
      1,
      0
    ]);
    let dummyVector2 = Vector3.fromCopyArray3([
      0,
      -1,
      0
    ]);
    if (Math.abs(Vector3.dot(directionToParent, dummyVector)) > 0.4) {
      dummyVector = Vector3.fromCopyArray3([
        1,
        0,
        0
      ]);
      dummyVector2 = Vector3.fromCopyArray3([
        -1,
        0,
        0
      ]);
    }
    if (Math.abs(Vector3.dot(directionToParent, dummyVector)) > 0.4) {
      dummyVector = Vector3.fromCopyArray3([
        0,
        0,
        1
      ]);
      dummyVector2 = Vector3.fromCopyArray3([
        0,
        0,
        -1
      ]);
    }
    const crossVector = Vector3.multiply(Vector3.normalize(Vector3.cross(directionToParent, dummyVector)), arrowWidth);
    const crossVector2 = Vector3.multiply(Vector3.normalize(Vector3.cross(directionToParent, crossVector)), arrowWidth);
    const crossVector3 = Vector3.multiply(Vector3.normalize(Vector3.cross(directionToParent, dummyVector2)), arrowWidth);
    const crossVector4 = Vector3.multiply(Vector3.normalize(Vector3.cross(directionToParent, crossVector3)), arrowWidth);
    const crossPosition = Vector3.add(arrowStickPosition, crossVector);
    const crossPosition2 = Vector3.add(arrowStickPosition, crossVector2);
    const crossPosition3 = Vector3.add(arrowStickPosition, crossVector3);
    const crossPosition4 = Vector3.add(arrowStickPosition, crossVector4);
    const pos = [];
    pos.push(this.__worldPositionOfThisJoint);
    pos.push(crossPosition);
    pos.push(this.__worldPositionOfThisJoint);
    pos.push(crossPosition2);
    pos.push(this.__worldPositionOfThisJoint);
    pos.push(crossPosition3);
    pos.push(this.__worldPositionOfThisJoint);
    pos.push(crossPosition4);
    pos.push(crossPosition);
    pos.push(crossPosition2);
    pos.push(crossPosition2);
    pos.push(crossPosition3);
    pos.push(crossPosition3);
    pos.push(crossPosition4);
    pos.push(crossPosition4);
    pos.push(crossPosition);
    pos.push(this.__worldPositionOfParentJoint);
    pos.push(crossPosition);
    pos.push(this.__worldPositionOfParentJoint);
    pos.push(crossPosition2);
    pos.push(this.__worldPositionOfParentJoint);
    pos.push(crossPosition3);
    pos.push(this.__worldPositionOfParentJoint);
    pos.push(crossPosition4);
    const positions = [];
    pos.map((vec) => {
      Array.prototype.push.apply(positions, vec.flattenAsArray());
    });
    const attributes = [
      new Float32Array(positions)
    ];
    const attributeSemantics = [
      VertexAttribute.Position.XYZ
    ];
    this.copyVertexData({
      attributes,
      attributeSemantics,
      primitiveMode: PrimitiveMode.Lines,
      material: desc == null ? void 0 : desc.material
    });
  }
};
__name(_Joint, "Joint");
var Joint = _Joint;

// src/foundation/geometry/shapes/Line.ts
init_VertexAttribute();
init_PrimitiveMode();
init_IShape();
init_Vector3();
var _Line = class _Line extends IShape {
  /**
  * Generates a line object
  * @param _desc a descriptor object of a Line
  */
  generate(_desc) {
    var _a40, _b, _c;
    const desc = {
      startPos: (_a40 = _desc.startPos) != null ? _a40 : Vector3.fromCopy3(0, 0, 0),
      endPos: (_b = _desc.endPos) != null ? _b : Vector3.fromCopy3(1, 0, 0),
      hasTerminalMark: (_c = _desc.hasTerminalMark) != null ? _c : true,
      material: _desc.material
    };
    const positions = [];
    positions.push(...desc.startPos.flattenAsArray());
    positions.push(...desc.endPos.flattenAsArray());
    if (desc.hasTerminalMark) {
      const length = desc.startPos.lengthTo(desc.endPos);
      const markSize = length * 0.1;
      positions.push(desc.startPos.x - markSize, desc.startPos.y, desc.startPos.z);
      positions.push(desc.startPos.x + markSize, desc.startPos.y, desc.startPos.z);
      positions.push(desc.startPos.x, desc.startPos.y, desc.startPos.z - markSize);
      positions.push(desc.startPos.x, desc.startPos.y, desc.startPos.z + markSize);
      positions.push(desc.endPos.x - markSize, desc.endPos.y, desc.endPos.z);
      positions.push(desc.endPos.x + markSize, desc.endPos.y, desc.endPos.z);
      positions.push(desc.endPos.x, desc.endPos.y, desc.endPos.z - markSize);
      positions.push(desc.endPos.x, desc.endPos.y, desc.endPos.z + markSize);
    }
    const attributes = [
      new Float32Array(positions)
    ];
    const attributeSemantics = [
      VertexAttribute.Position.XYZ
    ];
    this.copyVertexData({
      attributes,
      attributeSemantics,
      primitiveMode: PrimitiveMode.Lines,
      material: desc.material
    });
  }
};
__name(_Line, "Line");
var Line = _Line;

// src/foundation/geometry/shapes/index.ts
init_Plane();

// src/foundation/geometry/shapes/Sphere.ts
init_VertexAttribute();
init_PrimitiveMode();
init_Vector3();
init_IShape();
init_Logger();
var _Sphere = class _Sphere extends IShape {
  constructor() {
    super();
  }
  generate(_desc) {
    var _a40, _b, _c;
    const desc = {
      radius: (_a40 = _desc.radius) != null ? _a40 : 1,
      widthSegments: (_b = _desc.widthSegments) != null ? _b : 10,
      heightSegments: (_c = _desc.heightSegments) != null ? _c : 10,
      material: _desc.material
    };
    const positions = [];
    const texcoords = [];
    const normals = [];
    if (Math.abs(desc.radius) < Number.EPSILON) {
      Logger.warn("The argument radius is zero / nearly zero. Rn will take the radius as 0.001 for safety. Check your code.");
      desc.radius = 1e-3;
    }
    const shiftValue = 1e-5;
    for (let latNumber = 0; latNumber <= desc.heightSegments; latNumber++) {
      const theta = latNumber * Math.PI / desc.heightSegments + shiftValue;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      for (let longNumber = 0; longNumber <= desc.widthSegments; longNumber++) {
        const phi = longNumber * 2 * Math.PI / desc.widthSegments;
        const sinPhi = Math.sin(phi);
        const cosPhi = Math.cos(phi);
        const x = desc.radius * cosPhi * sinTheta;
        const y = desc.radius * cosTheta;
        const z = desc.radius * sinPhi * sinTheta;
        const position = Vector3.fromCopyArray([
          x,
          y,
          z
        ]);
        positions.push(x);
        positions.push(y);
        positions.push(z);
        const u = 1 - longNumber / desc.widthSegments;
        const v = latNumber / desc.heightSegments;
        texcoords.push(u);
        texcoords.push(v);
        const normal = Vector3.normalize(position);
        normals.push(normal.x);
        normals.push(normal.y);
        normals.push(normal.z);
      }
    }
    const indices = [];
    for (let latNumber = 0; latNumber < desc.heightSegments; latNumber++) {
      for (let longNumber = 0; longNumber < desc.widthSegments; longNumber++) {
        const first = latNumber * (desc.widthSegments + 1) + longNumber;
        const second = first + desc.widthSegments + 1;
        indices.push(first + 1);
        indices.push(second);
        indices.push(first);
        indices.push(first + 1);
        indices.push(second + 1);
        indices.push(second);
      }
    }
    const attributeSemantics = [
      VertexAttribute.Position.XYZ,
      VertexAttribute.Normal.XYZ,
      VertexAttribute.Texcoord0.XY
    ];
    const primitiveMode = PrimitiveMode.Triangles;
    const attributes = [
      new Float32Array(positions),
      new Float32Array(normals),
      new Float32Array(texcoords)
    ];
    this.copyVertexData({
      attributes,
      attributeSemantics,
      primitiveMode,
      indices: new Uint16Array(indices),
      material: desc.material
    });
  }
};
__name(_Sphere, "Sphere");
var Sphere = _Sphere;

// src/foundation/geometry/types/index.ts
init_GeometryTypes();

// src/foundation/geometry/ComplexVertexAttribute.ts
var _ComplexVertexAttribute = class _ComplexVertexAttribute {
  constructor(semanticAttribute, attributes) {
    __publicField(this, "__semantic");
    __publicField(this, "__components", []);
    __publicField(this, "__offsets", []);
    this.__semantic = semanticAttribute;
    this.__offsets = [];
    this.__components = [];
    for (const [joinedString, accessor] of attributes) {
      const split = joinedString.split(",");
      for (let i2 = 0; i2 < split.length; i2++) {
        const attributeComponentName = split[i2];
        if (attributeComponentName === semanticAttribute.X) {
          this.__offsets[0] = i2;
          this.__components[0] = accessor;
        }
        if (attributeComponentName === semanticAttribute.Y) {
          this.__offsets[1] = i2;
          this.__components[1] = accessor;
        }
        if (attributeComponentName === semanticAttribute.Z) {
          this.__offsets[2] = i2;
          this.__components[2] = accessor;
        }
        if (attributeComponentName === semanticAttribute.W) {
          this.__offsets[3] = i2;
          this.__components[3] = accessor;
        }
      }
    }
  }
  get semantic() {
    return this.__semantic;
  }
  getScalarAsArray(i2, option) {
    return [
      this.__components[0].getScalarAt(i2, this.__offsets[0], option)
    ];
  }
  getVec2AsArray(i2, option) {
    return [
      this.__components[0].getScalarAt(i2, this.__offsets[0], option),
      this.__components[1].getScalarAt(i2, this.__offsets[1], option)
    ];
  }
  getVec3AsArray(i2, option) {
    return [
      this.__components[0].getScalarAt(i2, this.__offsets[0], option),
      this.__components[1].getScalarAt(i2, this.__offsets[1], option),
      this.__components[2].getScalarAt(i2, this.__offsets[2], option)
    ];
  }
  getVec4AsArray(i2, option) {
    return [
      this.__components[0].getScalarAt(i2, this.__offsets[0], option),
      this.__components[1].getScalarAt(i2, this.__offsets[1], option),
      this.__components[2].getScalarAt(i2, this.__offsets[2], option),
      this.__components[3].getScalarAt(i2, this.__offsets[3], option)
    ];
  }
};
__name(_ComplexVertexAttribute, "ComplexVertexAttribute");
var ComplexVertexAttribute = _ComplexVertexAttribute;

// src/foundation/geometry/index.ts
init_Frustum();
init_Mesh();
init_Primitive();

// src/foundation/geometry/SimpleVertexAttribute.ts
var _SimpleVertexAttribute = class _SimpleVertexAttribute {
  constructor(semanticAttribute, accessor) {
    __publicField(this, "__semantic");
    __publicField(this, "__accessor");
    this.__semantic = semanticAttribute;
    this.__accessor = accessor;
  }
  get semantic() {
    return this.__semantic;
  }
  getScalarAsArray(i2, option) {
    return [
      this.__accessor.getScalar(i2, option)
    ];
  }
  getVec2AsArray(i2, option) {
    return this.__accessor.getVec2AsArray(i2, option);
  }
  getVec3AsArray(i2, option) {
    return this.__accessor.getVec3AsArray(i2, option);
  }
  getVec4AsArray(i2, option) {
    return this.__accessor.getVec4AsArray(i2, option);
  }
};
__name(_SimpleVertexAttribute, "SimpleVertexAttribute");
var SimpleVertexAttribute = _SimpleVertexAttribute;

// src/foundation/gizmos/index.ts
init_AABBGizmo();
init_Gizmo();
init_LocatorGizmo();
init_LightGizmo();
init_ScaleGizmo();
init_TranslationGizmo();

// src/foundation/helpers/EntityHelper.ts
init_EntityRepository();
init_createGroupEntity();
init_components2();
function createLightWithCameraEntity() {
  const entity = createGroupEntity();
  const entityAddedComponent = EntityRepository.tryToAddComponentToEntityByTID(WellKnownComponentTIDs.LightComponentTID, entity);
  const entityAddedComponent2 = EntityRepository.tryToAddComponentToEntityByTID(WellKnownComponentTIDs.CameraComponentTID, entityAddedComponent);
  entityAddedComponent2.getCamera().isSyncToLight = true;
  return entityAddedComponent2;
}
__name(createLightWithCameraEntity, "createLightWithCameraEntity");

// src/foundation/helpers/ExpressionHelper.ts
init_MaterialHelper();

// src/foundation/helpers/RenderPassHelper.ts
init_TextureParameter();
init_RenderPass();
init_Sampler();
var _sampler;
function createScreenDrawRenderPass(material) {
  const renderPass = new RenderPass();
  renderPass.toClearColorBuffer = false;
  renderPass.toClearDepthBuffer = false;
  renderPass.isDepthTest = false;
  renderPass.setBufferLessFullScreenRendering(material);
  return renderPass;
}
__name(createScreenDrawRenderPass, "createScreenDrawRenderPass");
function createScreenDrawRenderPassWithBaseColorTexture(material, texture, sampler) {
  if (_sampler === void 0) {
    _sampler = new Sampler({
      magFilter: TextureParameter.Linear,
      minFilter: TextureParameter.Linear,
      wrapS: TextureParameter.ClampToEdge,
      wrapT: TextureParameter.ClampToEdge
    });
    _sampler.create();
  }
  material.setTextureParameter("baseColorTexture", texture, sampler != null ? sampler : _sampler);
  const renderPass = new RenderPass();
  renderPass.toClearColorBuffer = false;
  renderPass.toClearDepthBuffer = false;
  renderPass.isDepthTest = false;
  renderPass.setBufferLessFullScreenRendering(material);
  return renderPass;
}
__name(createScreenDrawRenderPassWithBaseColorTexture, "createScreenDrawRenderPassWithBaseColorTexture");
var RenderPassHelper = Object.freeze({
  createScreenDrawRenderPass,
  createScreenDrawRenderPassWithBaseColorTexture
});

// src/foundation/renderer/FrameBuffer.ts
init_RnObject();
init_CGAPIResourceRepository();
init_RenderBufferTarget();
init_RenderTargetTexture();
var _FrameBuffer = class _FrameBuffer extends RnObject {
  constructor() {
    super();
    __publicField(this, "__colorAttachments", []);
    __publicField(this, "__depthAttachment");
    __publicField(this, "__stencilAttachment");
    __publicField(this, "__depthStencilAttachment");
    __publicField(this, "cgApiResourceUid", CGAPIResourceRepository.InvalidCGAPIResourceUid);
    __publicField(this, "width", 0);
    __publicField(this, "height", 0);
    __publicField(this, "__colorAttachmentMap", /* @__PURE__ */ new Map());
  }
  get colorAttachmentsRenderBufferTargets() {
    return Array.from(this.__colorAttachmentMap.keys());
  }
  get colorAttachments() {
    return this.__colorAttachments;
  }
  get depthAttachment() {
    return this.__depthAttachment;
  }
  get stencilAttachment() {
    return this.__stencilAttachment;
  }
  get depthStencilAttachment() {
    return this.__depthStencilAttachment;
  }
  getColorAttachedRenderTargetTexture(index) {
    if (this.__colorAttachments[index] == null || !(this.__colorAttachments[index] instanceof RenderTargetTexture)) {
      return void 0;
    } else {
      return this.__colorAttachments[index];
    }
  }
  getDepthAttachedRenderTargetTexture() {
    if (this.__depthAttachment instanceof RenderTargetTexture) {
      return this.__depthAttachment;
    } else {
      return void 0;
    }
  }
  create(width, height) {
    this.width = width;
    this.height = height;
    const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
    this.cgApiResourceUid = cgApiResourceRepository.createFrameBufferObject();
    return this.cgApiResourceUid;
  }
  get framebufferUID() {
    return this.cgApiResourceUid;
  }
  setColorAttachmentAt(index, renderable) {
    if (renderable.width !== this.width || renderable.height !== this.height) {
      return false;
    }
    this.__colorAttachments[index] = renderable;
    const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
    cgApiResourceRepository.attachColorBufferToFrameBufferObject(this, index, renderable);
    this.__colorAttachmentMap.set(RenderBufferTarget.from(index), renderable);
    return true;
  }
  setColorAttachmentCubeAt(attachmentIndex, faceIndex, mipLevel, renderable) {
    if (renderable.width !== this.width || renderable.height !== this.height) {
      return false;
    }
    this.__colorAttachments[attachmentIndex] = renderable;
    const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
    cgApiResourceRepository.attachColorBufferCubeToFrameBufferObject(this, attachmentIndex, faceIndex, mipLevel, renderable);
    renderable.createCubeTextureViewAsRenderTarget(faceIndex, mipLevel);
    this.__colorAttachmentMap.set(RenderBufferTarget.from(attachmentIndex), renderable);
    return true;
  }
  setDepthAttachment(renderable) {
    if (renderable.width !== this.width || renderable.height !== this.height) {
      return false;
    }
    this.__depthAttachment = renderable;
    const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
    cgApiResourceRepository.attachDepthBufferToFrameBufferObject(this, renderable);
    return true;
  }
  setStencilAttachment(renderable) {
    if (renderable.width !== this.width || renderable.height !== this.height) {
      return false;
    }
    this.__stencilAttachment = renderable;
    const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
    cgApiResourceRepository.attachStencilBufferToFrameBufferObject(this, renderable);
    return true;
  }
  setDepthStencilAttachment(renderable) {
    if (renderable.width !== this.width || renderable.height !== this.height) {
      return false;
    }
    this.__depthStencilAttachment = renderable;
    const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
    cgApiResourceRepository.attachDepthStencilBufferToFrameBufferObject(this, renderable);
    return true;
  }
  resize(width, height) {
    const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
    cgApiResourceRepository.deleteFrameBufferObject(this.cgApiResourceUid);
    this.cgApiResourceUid = CGAPIResourceRepository.InvalidCGAPIResourceUid;
    this.width = 0;
    this.height = 0;
    this.create(width, height);
    if (this.depthAttachment) {
      this.depthAttachment.resize(width, height);
      this.setDepthAttachment(this.depthAttachment);
    }
    if (this.depthStencilAttachment) {
      this.depthStencilAttachment.resize(width, height);
      this.setDepthStencilAttachment(this.depthStencilAttachment);
    }
    if (this.stencilAttachment) {
      this.stencilAttachment.resize(width, height);
      this.setStencilAttachment(this.stencilAttachment);
    }
    for (let i2 = 0; i2 < this.colorAttachments.length; i2++) {
      this.colorAttachments[i2].resize(width, height);
      this.setColorAttachmentAt(i2, this.colorAttachments[i2]);
    }
  }
  destroy3DAPIResources() {
    const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
    cgApiResourceRepository.deleteFrameBufferObject(this.cgApiResourceUid);
    this.cgApiResourceUid = CGAPIResourceRepository.InvalidCGAPIResourceUid;
    this.width = 0;
    this.height = 0;
    if (this.depthAttachment) {
      this.depthAttachment.destroy3DAPIResources();
      this.__depthAttachment = void 0;
    }
    if (this.depthStencilAttachment) {
      this.depthStencilAttachment.destroy3DAPIResources();
      this.__depthStencilAttachment = void 0;
    }
    if (this.stencilAttachment) {
      this.stencilAttachment.destroy3DAPIResources();
      this.__stencilAttachment = void 0;
    }
    for (const colorAttachment of this.colorAttachments) {
      colorAttachment.destroy3DAPIResources();
    }
    this.__colorAttachmentMap = /* @__PURE__ */ new Map();
  }
  whichColorAttachment(renderable) {
    return this.__colorAttachments.indexOf(renderable);
  }
};
__name(_FrameBuffer, "FrameBuffer");
var FrameBuffer = _FrameBuffer;

// src/foundation/helpers/RenderableHelper.ts
init_RenderTargetTexture();
init_ComponentType();
init_PixelFormat();

// src/foundation/textures/RenderBuffer.ts
init_RnObject();
init_CGAPIResourceRepository();
init_SystemState();
init_ProcessApproach();
init_TextureFormat();
var _RenderBuffer = class _RenderBuffer extends RnObject {
  constructor() {
    super();
    __publicField(this, "width", 0);
    __publicField(this, "height", 0);
    __publicField(this, "__internalFormat", TextureFormat.Depth24);
    __publicField(this, "_textureResourceUid", -1);
    __publicField(this, "_textureViewResourceUid", -1);
    __publicField(this, "_textureViewAsRenderTargetResourceUid", -1);
    __publicField(this, "__fbo");
    __publicField(this, "__isMSAA", false);
    __publicField(this, "__sampleCountMSAA", 4);
  }
  set _fbo(fbo) {
    this.__fbo = fbo;
  }
  get fbo() {
    return this.__fbo;
  }
  get sampleCount() {
    return this.__sampleCountMSAA;
  }
  create(width, height, internalFormat, { isMSAA = false, sampleCountMSAA = this.__sampleCountMSAA } = {}) {
    this.width = width;
    this.height = height;
    this.__isMSAA = isMSAA;
    this.__sampleCountMSAA = sampleCountMSAA;
    this.__internalFormat = internalFormat;
    const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
    this._textureResourceUid = cgApiResourceRepository.createRenderBuffer(width, height, internalFormat, isMSAA, sampleCountMSAA);
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      this._textureViewResourceUid = cgApiResourceRepository.createTextureView2d(this._textureResourceUid);
      this._textureViewAsRenderTargetResourceUid = cgApiResourceRepository.createTextureViewAsRenderTarget(this._textureResourceUid);
    }
  }
  createCubeTextureViewAsRenderTarget(faceIdx, mipLevel) {
  }
  resize(width, height) {
    this.destroy3DAPIResources();
    this.create(width, height, this.__internalFormat, {
      isMSAA: this.__isMSAA
    });
  }
  destroy3DAPIResources() {
    this.width = 0;
    this.height = 0;
    const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
    cgApiResourceRepository.deleteRenderBuffer(this._textureResourceUid);
    this._textureResourceUid = CGAPIResourceRepository.InvalidCGAPIResourceUid;
    return true;
  }
};
__name(_RenderBuffer, "RenderBuffer");
var RenderBuffer = _RenderBuffer;

// src/foundation/helpers/RenderableHelper.ts
init_TextureFormat();

// src/foundation/textures/index.ts
init_AbstractTexture();
init_CubeTexture();
init_RenderTargetTexture();
init_RenderTargetTextureCube();
init_Texture();
init_TextureDataFloat();

// src/foundation/textures/VideoTexture.ts
init_PixelFormat();
init_ComponentType();
init_AbstractTexture();
init_CGAPIResourceRepository();
init_DataUtil();
init_TextureFormat();
var _htmlVideoElement;
var _VideoTexture = class _VideoTexture extends AbstractTexture {
  constructor() {
    super();
    __publicField(this, "__imageData");
    __publicField(this, "autoResize", true);
    __publicField(this, "autoDetectTransparency", false);
    __privateAdd(this, _htmlVideoElement);
  }
  __getResizedCanvas(image, maxSize) {
    const canvas = document.createElement("canvas");
    const potWidth = DataUtil.getNearestPowerOfTwo(image.width);
    const potHeight = DataUtil.getNearestPowerOfTwo(image.height);
    const aspect = potHeight / potWidth;
    let dstWidth = 0;
    let dstHeight = 0;
    if (potWidth > potHeight) {
      dstWidth = Math.min(potWidth, maxSize);
      dstHeight = dstWidth * aspect;
    } else {
      dstHeight = Math.min(potHeight, maxSize);
      dstWidth = dstHeight / aspect;
    }
    canvas.width = dstWidth;
    canvas.height = dstHeight;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, dstWidth, dstHeight);
    if (this.autoDetectTransparency) {
      this.__imageData = ctx.getImageData(0, 0, dstWidth, dstHeight);
      for (let y = 0; y < dstHeight; y++) {
        for (let x = 0; x < dstWidth; x++) {
          const alpha = this.__imageData.data[(x + y * dstWidth) * 4 + 3];
          if (alpha < 1) {
            this.__hasTransparentPixels = true;
            return canvas;
          }
        }
      }
      this.__hasTransparentPixels = false;
    }
    return canvas;
  }
  generateTextureFromVideo(video, { level = 0, internalFormat = TextureFormat.RGBA8, format = PixelFormat.RGBA, type = ComponentType.UnsignedByte, generateMipmap = false, mutedAutoPlay = true } = {}) {
    this.__startedToLoad = true;
    __privateSet(this, _htmlVideoElement, video);
    if (mutedAutoPlay) {
      video.autoplay = true;
      video.muted = true;
    }
    const img = video;
    this.__width = img.videoWidth;
    this.__height = img.videoHeight;
    const webGLResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
    const textureHandle = webGLResourceRepository.createTextureFromImageBitmapData(img, {
      level,
      internalFormat,
      width: this.__width,
      height: this.__height,
      border: 0,
      format,
      type,
      generateMipmap
    });
    this._textureResourceUid = textureHandle;
    this.__isTextureReady = true;
    this.__uri = video.src;
  }
  generateTextureFromUri(videoUri, { level = 0, internalFormat = TextureFormat.RGBA8, format = PixelFormat.RGBA, type = ComponentType.UnsignedByte, generateMipmap = false, mutedAutoPlay = true, playButtonDomElement = void 0 } = {}) {
    this.__uri = videoUri;
    this.__startedToLoad = true;
    return new Promise((resolve, reject) => {
      const button = playButtonDomElement;
      const setupTexture = /* @__PURE__ */ __name(() => {
        this.__width = video.videoWidth;
        this.__height = video.videoHeight;
        const webGLResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
        const textureHandle = webGLResourceRepository.createTextureFromImageBitmapData(video, {
          level,
          internalFormat,
          width: this.__width,
          height: this.__height,
          border: 0,
          format,
          type,
          generateMipmap
        });
        this._textureResourceUid = textureHandle;
        this.__isTextureReady = true;
        resolve();
      }, "setupTexture");
      button == null ? void 0 : button.addEventListener("click", () => {
        setupTexture();
        video.play();
      }, true);
      const video = document.createElement("video");
      video.crossOrigin = "anonymous";
      video.setAttribute("playsinline", "playsinline");
      if (mutedAutoPlay) {
        video.autoplay = true;
        video.muted = true;
      }
      video.preload = "auto";
      __privateSet(this, _htmlVideoElement, video);
      video.addEventListener("canplaythrough", () => {
        setupTexture();
        video.play();
      }, true);
      video.addEventListener("ended", () => {
        video.play();
      }, true);
      video.src = videoUri;
    });
  }
  updateTexture() {
    const webGLResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
    if (this.__isTextureReady && __privateGet(this, _htmlVideoElement)) {
      webGLResourceRepository.updateTexture(this._textureResourceUid, __privateGet(this, _htmlVideoElement), {
        level: 0,
        xoffset: 0,
        yoffset: 0,
        width: this.__width,
        height: this.__height,
        format: PixelFormat.RGBA,
        type: ComponentType.UnsignedByte
      });
    }
  }
  getCurrentFramePixelData() {
    let pixel = void 0;
    const webGLResourceRepository = CGAPIResourceRepository.getWebGLResourceRepository();
    if (this.__isTextureReady && __privateGet(this, _htmlVideoElement)) {
      pixel = webGLResourceRepository.getPixelDataFromTexture(this._textureResourceUid, 0, 0, this.width, this.height);
    }
    return [
      pixel,
      this.width,
      this.height
    ];
  }
  set playbackRate(value) {
    if (__privateGet(this, _htmlVideoElement)) {
      __privateGet(this, _htmlVideoElement).playbackRate = value;
    }
  }
  get playbackRate() {
    var _a40;
    const playbackRate = (_a40 = __privateGet(this, _htmlVideoElement)) == null ? void 0 : _a40.playbackRate;
    return playbackRate != null ? playbackRate : 1;
  }
  play() {
    var _a40;
    (_a40 = __privateGet(this, _htmlVideoElement)) == null ? void 0 : _a40.play();
  }
  pause() {
    __privateGet(this, _htmlVideoElement).pause();
  }
};
_htmlVideoElement = new WeakMap();
__name(_VideoTexture, "VideoTexture");
__publicField(_VideoTexture, "__loadedBasisFunc", false);
__publicField(_VideoTexture, "__basisLoadPromise");
var VideoTexture = _VideoTexture;

// src/foundation/textures/index.ts
init_Sampler();

// src/foundation/helpers/RenderableHelper.ts
function createFrameBuffer(desc) {
  var _a40;
  const frameBuffer = new FrameBuffer();
  frameBuffer.create(desc.width, desc.height);
  for (let i2 = 0; i2 < desc.textureNum; i2++) {
    const renderTargetTexture = new RenderTargetTexture();
    renderTargetTexture.create({
      width: desc.width,
      height: desc.height,
      mipLevelCount: desc.mipLevelCount,
      format: desc.textureFormats[i2]
    });
    frameBuffer.setColorAttachmentAt(i2, renderTargetTexture);
  }
  if (desc.createDepthBuffer) {
    const depthTexture = new RenderTargetTexture();
    const depthBufferInternalFormat = (_a40 = desc.depthTextureFormat) != null ? _a40 : TextureFormat.Depth32F;
    depthTexture.create({
      width: desc.width,
      height: desc.height,
      mipLevelCount: 1,
      format: depthBufferInternalFormat
    });
    frameBuffer.setDepthAttachment(depthTexture);
  }
  return frameBuffer;
}
__name(createFrameBuffer, "createFrameBuffer");
function createFrameBufferMSAA(desc) {
  const frameBuffer = new FrameBuffer();
  frameBuffer.create(desc.width, desc.height);
  for (let i2 = 0; i2 < desc.colorBufferNum; i2++) {
    const renderBuffer2 = new RenderBuffer();
    renderBuffer2.create(desc.width, desc.height, desc.colorFormats[i2], {
      isMSAA: true,
      sampleCountMSAA: desc.sampleCountMSAA
    });
    frameBuffer.setColorAttachmentAt(i2, renderBuffer2);
  }
  const renderBuffer = new RenderBuffer();
  renderBuffer.create(desc.width, desc.height, desc.depthBufferFormat, {
    isMSAA: true,
    sampleCountMSAA: desc.sampleCountMSAA
  });
  frameBuffer.setDepthAttachment(renderBuffer);
  return frameBuffer;
}
__name(createFrameBufferMSAA, "createFrameBufferMSAA");
function createFrameBufferTextureArray(desc) {
  const frameBuffer = new FrameBuffer();
  frameBuffer.create(desc.width, desc.height);
  const renderTargetTexture = new RenderTargetTexture();
  renderTargetTexture.createTextureArray({
    width: desc.width,
    height: desc.height,
    level: desc.level,
    internalFormat: desc.internalFormat,
    format: desc.format,
    type: desc.type,
    arrayLength: desc.arrayLength
  });
  frameBuffer.setColorAttachmentAt(0, renderTargetTexture);
  const renderTargetDepthStencilTexture = new RenderTargetTexture();
  renderTargetDepthStencilTexture.createTextureArray({
    width: desc.width,
    height: desc.height,
    level: desc.level,
    internalFormat: TextureFormat.Depth32FStencil8,
    format: PixelFormat.DepthStencil,
    type: ComponentType.Float,
    arrayLength: desc.arrayLength
  });
  frameBuffer.setDepthStencilAttachment(renderTargetDepthStencilTexture);
  return frameBuffer;
}
__name(createFrameBufferTextureArray, "createFrameBufferTextureArray");
function createFrameBufferCubeMap(desc) {
  const frameBuffer = new FrameBuffer();
  frameBuffer.create(desc.width, desc.height);
  const renderTargetTexture = new RenderTargetTextureCube();
  renderTargetTexture.create({
    width: desc.width,
    height: desc.height,
    mipLevelCount: desc.mipLevelCount,
    format: desc.textureFormat
  });
  frameBuffer.setColorAttachmentCubeAt(0, 0, 0, renderTargetTexture);
  return [
    frameBuffer,
    renderTargetTexture
  ];
}
__name(createFrameBufferCubeMap, "createFrameBufferCubeMap");
function createDepthBuffer(width, height, { level = 0, internalFormat = TextureFormat.Depth32F }) {
  const frameBuffer = new FrameBuffer();
  frameBuffer.create(width, height);
  const depthTexture = new RenderTargetTexture();
  depthTexture.create({
    width,
    height,
    mipLevelCount: 1,
    format: internalFormat
  });
  frameBuffer.setDepthAttachment(depthTexture);
  return frameBuffer;
}
__name(createDepthBuffer, "createDepthBuffer");
var RenderableHelper = Object.freeze({
  createFrameBuffer,
  createFrameBufferMSAA,
  createFrameBufferTextureArray,
  createFrameBufferCubeMap,
  createDepthBuffer
});

// src/foundation/helpers/ExpressionHelper.ts
init_MathUtil();
init_Vector2();
init_Expression();
init_VectorN();
init_TextureFormat();
function createBloomExpression({ textureToBloom, parameters: { luminanceCriterion = 1, gaussianBlurLevelHighLuminance = 4, gaussianKernelSize = 10, gaussianVariance = 10, synthesizeCoefficient = [
  1,
  1,
  1,
  1,
  1,
  1
] } }) {
  const renderPassDetectHighLuminance = createRenderPassDetectHighLuminance(textureToBloom, luminanceCriterion);
  const renderPassesBlurredHighLuminance = createRenderPassesBlurredHighLuminance(renderPassDetectHighLuminance, gaussianBlurLevelHighLuminance, gaussianKernelSize, gaussianVariance, textureToBloom.width, textureToBloom.height);
  const renderPassSynthesizeImage = createRenderPassSynthesizeImage(textureToBloom, renderPassesBlurredHighLuminance, synthesizeCoefficient);
  const expression = new Expression();
  expression.addRenderPasses([
    renderPassDetectHighLuminance,
    ...renderPassesBlurredHighLuminance,
    renderPassSynthesizeImage
  ]);
  return {
    bloomExpression: expression,
    bloomedRenderTarget: renderPassSynthesizeImage.getFramebuffer().colorAttachments[0]
  };
}
__name(createBloomExpression, "createBloomExpression");
function createRenderPassDetectHighLuminance(texture, luminanceCriterion) {
  const materialDetectHighLuminance = MaterialHelper.createDetectHighLuminanceMaterial({
    maxInstancesNumber: 1
  }, texture);
  materialDetectHighLuminance.setParameter("luminanceCriterion", luminanceCriterion);
  const renderPassDetectHighLuminance = RenderPassHelper.createScreenDrawRenderPass(materialDetectHighLuminance);
  renderPassDetectHighLuminance.tryToSetUniqueName("renderPassDetectHighLuminance", true);
  const framebufferDetectHighLuminance = RenderableHelper.createFrameBuffer({
    width: texture.width,
    height: texture.height,
    textureNum: 1,
    textureFormats: [
      TextureFormat.RGBA8
    ],
    createDepthBuffer: false
  });
  renderPassDetectHighLuminance.setFramebuffer(framebufferDetectHighLuminance);
  return renderPassDetectHighLuminance;
}
__name(createRenderPassDetectHighLuminance, "createRenderPassDetectHighLuminance");
function createRenderPassesBlurredHighLuminance(renderPassHighLuminance, gaussianBlurLevelHighLuminance, gaussianKernelSize, gaussianVariance, maxResolutionWidth, maxResolutionHeight) {
  const renderPasses = [];
  for (let i2 = 0; i2 < gaussianBlurLevelHighLuminance; i2++) {
    const resolutionWidthBlur = Math.max(maxResolutionWidth >> i2 + 1, 1);
    const resolutionHeightBlur = Math.max(maxResolutionHeight >> i2 + 1, 1);
    let renderPassBlurH;
    if (i2 === 0) {
      renderPassBlurH = createRenderPassGaussianBlur(renderPassHighLuminance, gaussianKernelSize, gaussianVariance, true, resolutionWidthBlur, resolutionHeightBlur);
    } else {
      renderPassBlurH = createRenderPassGaussianBlur(renderPasses[renderPasses.length - 1], gaussianKernelSize, gaussianVariance, true, resolutionWidthBlur, resolutionHeightBlur);
    }
    renderPassBlurH.tryToSetUniqueName("renderPassBlurH_" + i2, true);
    const renderPassBlurHV = createRenderPassGaussianBlur(renderPassBlurH, gaussianKernelSize, gaussianVariance, false, resolutionWidthBlur, resolutionHeightBlur);
    renderPassBlurHV.tryToSetUniqueName("renderPassBlurHV_" + i2, true);
    renderPasses.push(renderPassBlurH, renderPassBlurHV);
  }
  return renderPasses;
}
__name(createRenderPassesBlurredHighLuminance, "createRenderPassesBlurredHighLuminance");
function createRenderPassGaussianBlur(renderPassBlurTarget, gaussianKernelSize, gaussianVariance, isHorizontal, resolutionWidthBlur, resolutionHeightBlur) {
  const material = MaterialHelper.createGaussianBlurMaterial();
  const gaussianDistributionRatio = MathUtil.computeGaussianDistributionRatioWhoseSumIsOne({
    kernelSize: gaussianKernelSize,
    variance: gaussianVariance
  });
  material.setParameter("gaussianKernelSize", gaussianKernelSize);
  material.setParameter("gaussianRatio", new VectorN(new Float32Array(gaussianDistributionRatio)));
  material.setParameter("framebufferSize", Vector2.fromCopy2(resolutionWidthBlur, resolutionHeightBlur));
  if (isHorizontal === false) {
    material.setParameter("isHorizontal", false);
  }
  const framebufferTarget = renderPassBlurTarget.getFramebuffer();
  const TextureTarget = framebufferTarget.colorAttachments[0];
  const renderPass = RenderPassHelper.createScreenDrawRenderPassWithBaseColorTexture(material, TextureTarget);
  const framebuffer = RenderableHelper.createFrameBuffer({
    width: resolutionWidthBlur,
    height: resolutionHeightBlur,
    textureNum: 1,
    textureFormats: [
      TextureFormat.RGBA8
    ],
    createDepthBuffer: false
  });
  renderPass.setFramebuffer(framebuffer);
  return renderPass;
}
__name(createRenderPassGaussianBlur, "createRenderPassGaussianBlur");
function createRenderPassSynthesizeImage(texture, renderPassesBlurredHighLuminance, synthesizeCoefficient) {
  const texturesSynthesize = [
    texture
  ];
  for (let i2 = 1; i2 < renderPassesBlurredHighLuminance.length; i2 += 2) {
    texturesSynthesize.push(renderPassesBlurredHighLuminance[i2].getFramebuffer().colorAttachments[0]);
  }
  const materialSynthesizeTextures = MaterialHelper.createSynthesizeHDRMaterial({
    maxInstancesNumber: 1
  }, texturesSynthesize);
  materialSynthesizeTextures.setParameter("synthesizeCoefficient", synthesizeCoefficient);
  const renderPassSynthesizeGlare = RenderPassHelper.createScreenDrawRenderPass(materialSynthesizeTextures);
  renderPassSynthesizeGlare.tryToSetUniqueName("renderPassSynthesizeGlare", true);
  const framebufferSynthesizeImages = RenderableHelper.createFrameBuffer({
    width: texture.width,
    height: texture.height,
    textureNum: 1,
    textureFormats: [
      TextureFormat.R11F_G11F_B10F
    ],
    createDepthBuffer: false
  });
  renderPassSynthesizeGlare.setFramebuffer(framebufferSynthesizeImages);
  return renderPassSynthesizeGlare;
}
__name(createRenderPassSynthesizeImage, "createRenderPassSynthesizeImage");
var ExpressionHelper = Object.freeze({
  createBloomExpression
});

// src/foundation/helpers/index.ts
init_MaterialHelper();

// src/foundation/helpers/MeshHelper.ts
init_Plane();
init_Mesh();
init_Vector3();
init_Cube();
init_misc();
init_PhysicsComponent();
init_EntityRepository();
init_OimoPhysicsStrategy();

// src/foundation/definitions/PhysicsShapeType.ts
init_EnumIO();
var _a39;
var PhysicsShapeTypeClass = (_a39 = class extends EnumClass {
  constructor({ index, str }) {
    super({
      index,
      str
    });
  }
}, __name(_a39, "PhysicsShapeTypeClass"), _a39);
var Sphere2 = new PhysicsShapeTypeClass({
  index: 0,
  str: "Sphere"
});
var Box = new PhysicsShapeTypeClass({
  index: 1,
  str: "Box"
});
var typeList31 = [
  Sphere2,
  Box
];
function from31(index) {
  return _from({
    typeList: typeList31,
    index
  });
}
__name(from31, "from");
function fromString22(str) {
  return _fromString({
    typeList: typeList31,
    str
  });
}
__name(fromString22, "fromString");
var PhysicsShape = Object.freeze({
  Sphere: Sphere2,
  Box,
  from: from31,
  fromString: fromString22
});

// src/foundation/helpers/MeshHelper.ts
init_createMeshEntity();
var createPlane = /* @__PURE__ */ __name((desc = {}) => {
  const primitive = new Plane();
  primitive.generate(desc);
  const entity = createShape(primitive);
  if (Is.not.exist(desc.direction)) {
    desc.direction = "xz";
  }
  if (desc.direction === "xy") {
    entity.localEulerAngles = Vector3.fromCopy3(Math.PI / 2, 0, 0);
  } else if (desc.direction === "yz") {
    entity.localEulerAngles = Vector3.fromCopy3(0, 0, Math.PI / 2);
  }
  return entity;
}, "createPlane");
var createLine = /* @__PURE__ */ __name((desc = {}) => {
  const primitive = new Line();
  primitive.generate(desc);
  const entity = createShape(primitive);
  return entity;
}, "createLine");
var createGrid = /* @__PURE__ */ __name((desc = {}) => {
  const primitive = new Grid();
  primitive.generate(desc);
  const entity = createShape(primitive);
  return entity;
}, "createGrid");
var createCube = /* @__PURE__ */ __name((desc = {}) => {
  var _a40;
  const primitive = new Cube();
  primitive.generate(desc);
  const entity = createShape(primitive);
  if (Is.exist(desc.physics) && desc.physics.use) {
    const newEntity = EntityRepository.addComponentToEntity(PhysicsComponent, entity);
    const physicsComponent = newEntity.getPhysics();
    const strategy = new OimoPhysicsStrategy();
    const property = {
      type: PhysicsShape.Box,
      size: (_a40 = desc.widthVector) != null ? _a40 : Vector3.fromCopy3(1, 1, 1),
      position: Vector3.fromCopy3(0, 0, 0),
      rotation: Vector3.fromCopy3(0, 0, 0),
      move: desc.physics.move,
      density: desc.physics.density,
      friction: desc.physics.friction,
      restitution: desc.physics.restitution
    };
    strategy.setShape(property, newEntity);
    physicsComponent.setStrategy(strategy);
  }
  return entity;
}, "createCube");
var createCubes = /* @__PURE__ */ __name((numberToCreate, desc = {}) => {
  var _a40;
  const primitive = new Cube();
  primitive.generate(desc);
  const mesh = new Mesh();
  mesh.addPrimitive(primitive);
  const entities = [];
  for (let i2 = 0; i2 < numberToCreate; i2++) {
    const entity = createMeshEntity();
    const meshComponent = entity.getMesh();
    meshComponent.setMesh(mesh);
    if (Is.exist(desc.physics) && desc.physics.use) {
      const newEntity = EntityRepository.addComponentToEntity(PhysicsComponent, entity);
      const physicsComponent = newEntity.getPhysics();
      const strategy = new OimoPhysicsStrategy();
      const property = {
        type: PhysicsShape.Box,
        size: (_a40 = desc.widthVector) != null ? _a40 : Vector3.fromCopy3(1, 1, 1),
        position: Vector3.fromCopy3(0, 0, 0),
        rotation: Vector3.fromCopy3(0, 0, 0),
        move: desc.physics.move,
        density: desc.physics.density,
        friction: desc.physics.friction,
        restitution: desc.physics.restitution
      };
      strategy.setShape(property, newEntity);
      physicsComponent.setStrategy(strategy);
    }
    entities.push(entity);
  }
  return entities;
}, "createCubes");
var createSphere = /* @__PURE__ */ __name((desc = {}) => {
  const primitive = new Sphere();
  primitive.generate(desc);
  const entity = createShape(primitive);
  if (Is.exist(desc.physics) && desc.physics.use) {
    const newEntity = EntityRepository.addComponentToEntity(PhysicsComponent, entity);
    const physicsComponent = newEntity.getPhysics();
    const strategy = new OimoPhysicsStrategy();
    const property = {
      type: PhysicsShape.Sphere,
      size: Is.exist(desc.radius) ? Vector3.fromCopy3(desc.radius, desc.radius, desc.radius) : Vector3.fromCopy3(1, 1, 1),
      position: Vector3.fromCopy3(0, 0, 0),
      rotation: Vector3.fromCopy3(0, 0, 0),
      move: desc.physics.move,
      density: desc.physics.density,
      friction: desc.physics.friction,
      restitution: desc.physics.restitution
    };
    strategy.setShape(property, newEntity);
    physicsComponent.setStrategy(strategy);
  }
  return entity;
}, "createSphere");
var createSpheres = /* @__PURE__ */ __name((numberToCreate, desc = {}) => {
  const primitive = new Sphere();
  primitive.generate(desc);
  const mesh = new Mesh();
  mesh.addPrimitive(primitive);
  const entities = [];
  for (let i2 = 0; i2 < numberToCreate; i2++) {
    const entity = createMeshEntity();
    const meshComponent = entity.getMesh();
    meshComponent.setMesh(mesh);
    if (Is.exist(desc.physics) && desc.physics.use) {
      const newEntity = EntityRepository.addComponentToEntity(PhysicsComponent, entity);
      const physicsComponent = newEntity.getPhysics();
      const strategy = new OimoPhysicsStrategy();
      const property = {
        type: PhysicsShape.Sphere,
        size: Is.exist(desc.radius) ? Vector3.fromCopy3(desc.radius, desc.radius, desc.radius) : Vector3.fromCopy3(1, 1, 1),
        position: Vector3.fromCopy3(0, 0, 0),
        rotation: Vector3.fromCopy3(0, 0, 0),
        move: desc.physics.move,
        density: desc.physics.density,
        friction: desc.physics.friction,
        restitution: desc.physics.restitution
      };
      strategy.setShape(property, newEntity);
      physicsComponent.setStrategy(strategy);
    }
    entities.push(entity);
  }
  return entities;
}, "createSpheres");
var createJoint = /* @__PURE__ */ __name((desc = {}) => {
  const primitive = new Joint();
  primitive.generate(desc);
  const entity = createShape(primitive);
  return entity;
}, "createJoint");
var createAxis = /* @__PURE__ */ __name((desc = {}) => {
  const primitive = new Axis();
  primitive.generate(desc);
  const entity = createShape(primitive);
  return entity;
}, "createAxis");
function createShape(primitive) {
  const entity = createMeshEntity();
  const meshComponent = entity.getMesh();
  const mesh = new Mesh();
  mesh.addPrimitive(primitive);
  meshComponent.setMesh(mesh);
  return entity;
}
__name(createShape, "createShape");
var MeshHelper = Object.freeze({
  createPlane,
  createLine,
  createGrid,
  createCube,
  createCubes,
  createSphere,
  createSpheres,
  createJoint,
  createAxis,
  createShape
});

// src/foundation/importer/AnimationAssigner.ts
init_ModelConverter();
init_EntityRepository();
init_AnimationComponent();
init_AnimationInterpolation();
init_Is();
init_components2();
init_GlobalRetargetReverse();
init_AnimationStateComponent();
init_Logger();
var _AnimationAssigner = class _AnimationAssigner {
  /**
  * Assign Animation Function
  *
  * @param rootEntity - The root entity of the model which you want to assign animation.
  * @param gltfModel - The glTF model that has animation data.
  * @param vrmModel - The corresponding VRM model to the glTF model.
  * @param isSameSkeleton
  * @param retargetMode - Retarget mode. 'none' | 'global' | 'global2' | 'absolute'
  * @param srcRootEntityForRetarget
  * @returns
  */
  assignAnimation(rootEntity, gltfModel, vrmModel, isSameSkeleton, retargetMode) {
    this.__resetAnimationAndPose(rootEntity);
    this.__setupAnimationForSameSkeleton(rootEntity, gltfModel, vrmModel, isSameSkeleton, retargetMode);
    return rootEntity;
  }
  assignAnimationWithVrma(rootEntity, vrmaModel, postfixToTrackName) {
    this.__resetAnimationAndPose(rootEntity, postfixToTrackName);
    let trackNames = /* @__PURE__ */ new Set();
    const setRetarget = /* @__PURE__ */ __name((vrma) => {
      if (vrma.animations == null || vrma.animations.length === 0) {
        return;
      }
      EntityRepository.addComponentToEntity(AnimationStateComponent, rootEntity);
      for (const animation of vrma.animations) {
        for (const sampler of animation.samplers) {
          ModelConverter._readBinaryFromAccessorAndSetItToAccessorExtras(sampler.inputObject);
          ModelConverter._readBinaryFromAccessorAndSetItToAccessorExtras(sampler.outputObject);
        }
      }
      for (const animation of vrma.animations) {
        for (const channel of animation.channels) {
          const rnEntity = this.__getCorrespondingEntityWithVrma(rootEntity, vrma, channel.target.node);
          if (rnEntity) {
            const newRnEntity = EntityRepository.addComponentToEntity(AnimationComponent, rnEntity);
            const animationComponent = newRnEntity.getAnimation();
            const gltfEntity = vrma.extras.rnEntities[channel.target.node];
            const humanBones = vrma.extensions.VRMC_vrm_animation.humanoidBoneNameMap;
            const humanoidBoneName = humanBones.get(channel.target.node);
            gltfEntity.tryToSetUniqueName(humanoidBoneName, true);
            let retarget;
            if (rootEntity.tryToGetVrm()._version === "0.x") {
              retarget = new GlobalRetargetReverse(gltfEntity);
            } else if (rootEntity.tryToGetVrm()._version === "1.0") {
              retarget = new GlobalRetarget(gltfEntity);
            }
            const names = animationComponent._setRetarget(retarget, postfixToTrackName);
            names.forEach((name) => {
              trackNames.add(name);
            });
          }
        }
      }
    }, "setRetarget");
    setRetarget(vrmaModel);
    return Array.from(trackNames);
  }
  constructor() {
  }
  __resetAnimationAndPose(rootEntity, postfixToTrackName) {
    function resetAnimationAndPose(entity, postfixToTrackName2) {
      const animationComponent = entity.tryToGetAnimation();
      if (animationComponent != null) {
        if (postfixToTrackName2 != null) {
          animationComponent.resetAnimationTrackByPostfix(postfixToTrackName2);
        } else {
          animationComponent.resetAnimationTracks();
        }
      }
      entity.getTransform()._restoreTransformFromRest();
      for (const child of entity.children) {
        resetAnimationAndPose(child.entity, postfixToTrackName2);
      }
    }
    __name(resetAnimationAndPose, "resetAnimationAndPose");
    resetAnimationAndPose(rootEntity, postfixToTrackName);
  }
  /**
  * The static method to get singleton instance of this class.
  * @return The singleton instance of ModelConverter class
  */
  static getInstance() {
    if (!this.__instance) {
      this.__instance = new _AnimationAssigner();
    }
    return this.__instance;
  }
  __getCorrespondingEntity(rootEntity, gltfModel, vrmModel, nodeIndex, nodeName, isSameSkeleton) {
    if (isSameSkeleton) {
      const rnEntities = rootEntity.getTagValue("rnEntitiesByNames");
      const node = gltfModel.nodes[nodeIndex];
      const rnEntity = rnEntities.get(node.name);
      return rnEntity;
    } else {
      if (Is.exist(vrmModel.extensions.VRM)) {
        const humanBones = vrmModel.extensions.VRM.humanoid.humanBones;
        let humanoidBoneName;
        const srcMapNodeIdName = /* @__PURE__ */ new Map();
        const srcMapNodeNameName = /* @__PURE__ */ new Map();
        for (const bone of humanBones) {
          srcMapNodeIdName.set(bone.node, bone.bone);
          srcMapNodeNameName.set(bone.name, bone.bone);
        }
        if (nodeName != null) {
          humanoidBoneName = srcMapNodeNameName.get(nodeName);
          if (humanoidBoneName == null) {
            humanoidBoneName = srcMapNodeIdName.get(nodeIndex);
          }
        }
        const dstMapNameNodeId = rootEntity.getTagValue("humanoid_map_name_nodeId");
        const dstBoneNodeId = dstMapNameNodeId.get(humanoidBoneName);
        if (dstBoneNodeId != null) {
          const rnEntities = rootEntity.getTagValue("rnEntities");
          return rnEntities[dstBoneNodeId];
        } else {
          Logger.info(`humanoidBoneName: ${humanoidBoneName}, nodeIndex: ${nodeIndex}, nodeName: ${nodeName}`);
          return void 0;
        }
      } else if (Is.exist(vrmModel.extensions.VRMC_vrm)) {
        const humanBones = vrmModel.extensions.VRMC_vrm.humanoid.humanBones;
        let humanoidBoneName;
        const srcMapNodeIdName = /* @__PURE__ */ new Map();
        for (const boneName in humanBones) {
          const bone = humanBones[boneName];
          srcMapNodeIdName.set(bone.node, boneName);
        }
        if (nodeName != null) {
          humanoidBoneName = srcMapNodeIdName.get(nodeIndex);
        }
        const dstMapNameNodeId = rootEntity.getTagValue("humanoid_map_name_nodeId");
        const dstBoneNodeId = dstMapNameNodeId.get(humanoidBoneName);
        if (dstBoneNodeId != null) {
          const rnEntities = rootEntity.getTagValue("rnEntities");
          return rnEntities[dstBoneNodeId];
        } else {
          Logger.info(`humanoidBoneName: ${humanoidBoneName}, nodeIndex: ${nodeIndex}, nodeName: ${nodeName}`);
          return void 0;
        }
      }
      return void 0;
    }
  }
  __getCorrespondingEntityWithVrma(rootEntity, gltfModel, nodeIndex) {
    const humanBones = gltfModel.extensions.VRMC_vrm_animation.humanoidBoneNameMap;
    const humanoidBoneName = humanBones.get(nodeIndex);
    const dstMapNameNodeId = rootEntity.getTagValue("humanoid_map_name_nodeId");
    const dstBoneNodeId = dstMapNameNodeId.get(humanoidBoneName);
    if (dstBoneNodeId != null) {
      const rnEntities = rootEntity.getTagValue("rnEntities");
      const rnEntity = rnEntities[dstBoneNodeId];
      return rnEntity;
    } else {
      Logger.info(`humanoidBoneName: ${humanoidBoneName}, nodeIndex: ${nodeIndex}`);
      return void 0;
    }
  }
  __isHips(rootEntity, vrmModel, nodeIndex) {
    const srcMapNodeIdName = /* @__PURE__ */ new Map();
    if (Is.exist(vrmModel.extensions.VRM)) {
      const humanBones = vrmModel.extensions.VRM.humanoid.humanBones;
      for (const bone of humanBones) {
        srcMapNodeIdName.set(bone.node, bone.bone);
      }
    } else if (Is.exist(vrmModel.extensions.VRMC_vrm)) {
      const humanBones = vrmModel.extensions.VRMC_vrm.humanoid.humanBones;
      for (const boneName in humanBones) {
        const bone = humanBones[boneName];
        srcMapNodeIdName.set(bone.node, boneName);
      }
    }
    const dstMapNameNodeId = rootEntity.getTagValue("humanoid_map_name_nodeId");
    const humanoidBoneName = srcMapNodeIdName.get(nodeIndex);
    if (humanoidBoneName === "hips") {
      return true;
    } else {
      return false;
    }
  }
  __setupAnimationForSameSkeleton(rootEntity, gltfModel, vrmModel, isSameSkeleton, retargetMode) {
    var _a40, _b, _c, _d;
    if (gltfModel.animations == null || gltfModel.animations.length === 0) {
      return;
    }
    EntityRepository.addComponentToEntity(AnimationStateComponent, rootEntity);
    for (const animation of gltfModel.animations) {
      for (const sampler of animation.samplers) {
        ModelConverter._readBinaryFromAccessorAndSetItToAccessorExtras(sampler.inputObject);
        ModelConverter._readBinaryFromAccessorAndSetItToAccessorExtras(sampler.outputObject);
      }
    }
    for (const animation of gltfModel.animations) {
      for (const channel of animation.channels) {
        const animInputArray = (_b = (_a40 = channel.samplerObject) == null ? void 0 : _a40.inputObject) == null ? void 0 : _b.extras.typedDataArray;
        const animOutputArray = (_d = (_c = channel.samplerObject) == null ? void 0 : _c.outputObject) == null ? void 0 : _d.extras.typedDataArray;
        const interpolation = channel.samplerObject.interpolation != null ? channel.samplerObject.interpolation : "LINEAR";
        const node = gltfModel.nodes[channel.target.node];
        const rnEntity = this.__getCorrespondingEntity(rootEntity, gltfModel, vrmModel, channel.target.node, node.name, isSameSkeleton);
        if (rnEntity) {
          const newRnEntity = EntityRepository.addComponentToEntity(AnimationComponent, rnEntity);
          const animationComponent = newRnEntity.getAnimation();
          if (retargetMode === "none") {
            let animationAttributeType = "translate";
            if (channel.target.path === "translation") {
              animationAttributeType = "translate";
            } else if (channel.target.path === "rotation") {
              animationAttributeType = "quaternion";
            } else {
              animationAttributeType = channel.target.path;
            }
            if (animationAttributeType === "quaternion") {
              animationComponent.setAnimation(Is.exist(animation.name) ? animation.name : "Untitled", animationAttributeType, animInputArray, animOutputArray, 4, AnimationInterpolation.fromString(interpolation));
            } else if (animationAttributeType === "translate" && this.__isHips(rootEntity, vrmModel, channel.target.node)) {
              animationComponent.setAnimation(Is.exist(animation.name) ? animation.name : "Untitled", animationAttributeType, animInputArray, animOutputArray, 3, AnimationInterpolation.fromString(interpolation));
            }
          } else {
            const gltfEntity = gltfModel.extras.rnEntities[channel.target.node];
            let retarget;
            if (retargetMode === "global") {
              retarget = new GlobalRetarget(gltfEntity);
            } else if (retargetMode === "absolute") {
              retarget = new AbsoluteAnimation(gltfEntity);
            } else {
              throw new Error("unknown retarget mode");
            }
            animationComponent._setRetarget(retarget);
          }
        }
      }
    }
  }
};
__name(_AnimationAssigner, "AnimationAssigner");
__publicField(_AnimationAssigner, "__instance");
var AnimationAssigner = _AnimationAssigner;

// src/foundation/importer/DrcPointCloudImporter.ts
init_DataUtil();
init_Primitive();
init_MaterialHelper();
init_CompositionType();
init_PrimitiveMode();
init_VertexAttribute();
init_RnPromise();
init_Is();
init_MiscUtil();
init_MiscUtil();
init_Result();
init_Logger();
var _DrcPointCloudImporter = class _DrcPointCloudImporter {
  constructor() {
  }
  /**
  * Import draco file of point cloud type
  * WEIGHTS_0 and JOINTS_0 attribute and all the mesh type and is not support yet.
  * @param uri - uri of drc file
  * @param options - options for loading process
  * @returns a glTF2 based JSON pre-processed
  */
  async importPointCloud(uri, options) {
    const basePath = uri.substring(0, uri.lastIndexOf("/")) + "/";
    const defaultOptions = DataUtil.createDefaultGltfOptions();
    if (options && options.files) {
      for (const fileName in options.files) {
        const fileExtension = DataUtil.getExtension(fileName);
        if (fileExtension === "drc") {
          const rnm22 = await this.__decodeDraco(options.files[fileName], defaultOptions, basePath, options);
          return new Ok(rnm22);
        }
      }
    }
    const r_arrayBuffer = await DataUtil.fetchArrayBuffer(uri);
    if (r_arrayBuffer.isErr()) {
      return new Err({
        message: "fetchArrayBuffer failed",
        error: r_arrayBuffer
      });
    }
    const rnm2 = await this.__decodeDraco(r_arrayBuffer.get(), defaultOptions, basePath, options);
    return new Ok(rnm2);
  }
  /**
  * Import the specified array buffer of draco file where the type must be point cloud.
  * WEIGHTS_0 and JOINTS_0 attribute and all the mesh type and is not support yet.
  * @param uri - uri of drc file
  * @param arrayBuffer - fetched array buffer of drc file
  * @param options - options for loading process
  * @returns a glTF2 based JSON pre-processed
  */
  importArrayBuffer(uri, arrayBuffer, options) {
    const basePath = uri.substring(0, uri.lastIndexOf("/")) + "/";
    const defaultOptions = DataUtil.createDefaultGltfOptions();
    return this.__decodeDraco(arrayBuffer, defaultOptions, basePath, options).catch((err) => {
      Logger.error("__loadFromArrayBuffer error: " + err);
    });
  }
  async __loadFromArrayBuffer(arrayBuffer, defaultOptions, basePath, options) {
    const dataView = new DataView(arrayBuffer, 0, 20);
    const isLittleEndian = true;
    const magic = dataView.getUint32(0, isLittleEndian);
    let result;
    if (magic !== 1179937895) {
      const gotText = DataUtil.arrayBufferToString(arrayBuffer);
      const json = JSON.parse(gotText);
      result = await this._loadAsTextJson(json, options, defaultOptions, basePath).catch((err) => {
        Logger.error("this.__loadAsTextJson error: " + err);
      });
    } else {
      result = await this._loadAsBinaryJson(dataView, isLittleEndian, arrayBuffer, options, defaultOptions, basePath).catch((err) => {
        Logger.error("this.__loadAsBinaryJson error: " + err);
      });
    }
    return result;
  }
  _getOptions(defaultOptions, json, options) {
    if (json.asset && json.asset.extras && json.asset.extras.rnLoaderOptions) {
      for (const optionName in json.asset.extras.rnLoaderOptions) {
        defaultOptions[optionName] = json.asset.extras.rnLoaderOptions[optionName];
      }
    }
    for (const optionName in options) {
      defaultOptions[optionName] = options[optionName];
    }
    if (options && options.loaderExtensionName && typeof options.loaderExtensionName === "string") {
      if (Rn[options.loaderExtensionName] != null) {
        defaultOptions.loaderExtension = Rn[options.loaderExtensionName].getInstance();
      } else {
        Logger.error(`${options.loaderExtensionName} not found!`);
        defaultOptions.loaderExtension = void 0;
      }
    }
    return defaultOptions;
  }
  async _loadAsBinaryJson(dataView, isLittleEndian, arrayBuffer, options, defaultOptions, basePath) {
    const lengthOfJSonChunkData = dataView.getUint32(12, isLittleEndian);
    const chunkType = dataView.getUint32(16, isLittleEndian);
    if (chunkType !== 1313821514) {
      throw new Error("invalid chunkType of chunk0 in this binary glTF file.");
    }
    const uint8ArrayJSonContent = new Uint8Array(arrayBuffer, 20, lengthOfJSonChunkData);
    const gotText = DataUtil.uint8ArrayToString(uint8ArrayJSonContent);
    const gltfJson = JSON.parse(gotText);
    options = this._getOptions(defaultOptions, gltfJson, options);
    const uint8array = new Uint8Array(arrayBuffer, 20 + lengthOfJSonChunkData + 8);
    if (gltfJson.asset.extras === void 0) {
      gltfJson.asset.extras = {
        fileType: "glTF",
        version: "2"
      };
    }
    this._mergeExtendedJson(gltfJson, options.extendedJson);
    gltfJson.asset.extras.rnLoaderOptions = options;
    try {
      await this._loadInner(uint8array, basePath, gltfJson, options);
    } catch (err) {
      Logger.error("this._loadInner error in _loadAsBinaryJson: " + err);
    }
    return gltfJson;
  }
  async _loadAsTextJson(gltfJson, options, defaultOptions, basePath) {
    if (gltfJson.asset.extras === void 0) {
      gltfJson.asset.extras = {
        fileType: "glTF",
        version: "2"
      };
    }
    options = this._getOptions(defaultOptions, gltfJson, options);
    this._mergeExtendedJson(gltfJson, options.extendedJson);
    gltfJson.asset.extras.rnLoaderOptions = options;
    try {
      await this._loadInner(void 0, basePath, gltfJson, options);
    } catch (err) {
      Logger.error("this._loadInner error in _loadAsTextJson: " + err);
    }
    return gltfJson;
  }
  _loadInner(uint8array, basePath, gltfJson, options) {
    const promises = [];
    const resources = {
      shaders: [],
      buffers: [],
      images: []
    };
    promises.push(this._loadResources(uint8array, basePath, gltfJson, options, resources));
    promises.push(new Promise((resolve, reject) => {
      this._loadJsonContent(gltfJson, options);
      resolve();
    }));
    return Promise.all(promises);
  }
  _loadJsonContent(gltfJson, options) {
    this._loadDependenciesOfScenes(gltfJson);
    this._loadDependenciesOfNodes(gltfJson);
    this._loadDependenciesOfMeshes(gltfJson);
    this._loadDependenciesOfMaterials(gltfJson);
    this._loadDependenciesOfTextures(gltfJson);
    this._loadDependenciesOfJoints(gltfJson);
    this._loadDependenciesOfAnimations(gltfJson);
    this._loadDependenciesOfAccessors(gltfJson);
    this._loadDependenciesOfBufferViews(gltfJson);
    if (gltfJson.asset.extras === void 0) {
      gltfJson.asset.extras = {};
    }
  }
  _loadDependenciesOfScenes(gltfJson) {
    for (const scene of gltfJson.scenes) {
      for (const i2 in scene.nodes) {
        scene.nodesObjects[i2] = gltfJson.nodes[scene.nodes[i2]];
      }
    }
  }
  _loadDependenciesOfNodes(gltfJson) {
    for (const node of gltfJson.nodes) {
      if (node.children) {
        if (Is.not.exist(node.childrenObjects)) {
          node.childrenObjects = [];
        }
        for (const i2 in node.children) {
          node.childrenObjects[i2] = gltfJson.nodes[node.children[i2]];
        }
      }
      if (node.mesh !== void 0 && gltfJson.meshes !== void 0) {
        node.meshObject = gltfJson.meshes[node.mesh];
      }
      if (node.skin !== void 0 && gltfJson.skins !== void 0) {
        node.skinObject = gltfJson.skins[node.skin];
        if (node.meshObject.extras === void 0) {
          node.meshObject.extras = {};
        }
        node.meshObject.extras._skin = node.skin;
      }
      if (node.camera !== void 0 && gltfJson.cameras !== void 0) {
        node.cameraObject = gltfJson.cameras[node.camera];
      }
      if (node.extensions !== void 0 && gltfJson.extensions !== void 0 && gltfJson.extensions.KHR_lights_punctual !== void 0) {
        node.extensions.KHR_lights_punctual.lightIndex = node.extensions.KHR_lights_punctual.light;
        node.extensions.KHR_lights_punctual.light = gltfJson.extensions.KHR_lights_punctual.lights[node.extensions.KHR_lights_punctual.lightIndex];
      }
    }
  }
  _loadDependenciesOfMeshes(gltfJson) {
    for (const mesh of gltfJson.meshes) {
      for (const primitive of mesh.primitives) {
        if (primitive.material !== void 0) {
          primitive.materialObject = gltfJson.materials[primitive.material];
        }
        for (const attributeName in primitive.attributes) {
          const accessorId = primitive.attributes[attributeName];
          const accessor = gltfJson.accessors[accessorId];
          accessor.extras = {
            toGetAsTypedArray: true,
            attributeName
          };
          primitive.attributesObjects[attributeName] = accessor;
        }
        if (primitive.indices != null) {
          primitive.indicesObject = gltfJson.accessors[primitive.indices];
        }
        if (primitive.targets != null) {
          primitive.targetsObjects = [];
          for (const target of primitive.targets) {
            const attributes = {};
            for (const attributeName in target) {
              const targetShapeTargetAccessorId = target[attributeName];
              if (targetShapeTargetAccessorId >= 0) {
                const accessor = gltfJson.accessors[targetShapeTargetAccessorId];
                accessor.extras = {
                  toGetAsTypedArray: true,
                  attributeName
                };
                attributes[attributeName] = accessor;
              }
            }
            primitive.targetsObjects.push(attributes);
          }
        }
      }
    }
  }
  _checkRnGltfLoaderOptionsExist(gltfModel) {
    if (gltfModel.asset.extras && gltfModel.asset.extras.rnLoaderOptions) {
      return true;
    } else {
      return false;
    }
  }
  _loadDependenciesOfMaterials(gltfJson) {
    if (!gltfJson.textures) gltfJson.textures = [];
    if (gltfJson.materials) {
      for (const material of gltfJson.materials) {
        if (material.pbrMetallicRoughness) {
          const baseColorTexture = material.pbrMetallicRoughness.baseColorTexture;
          if (baseColorTexture !== void 0) {
            baseColorTexture.texture = gltfJson.textures[baseColorTexture.index];
          }
          const metallicRoughnessTexture = material.pbrMetallicRoughness.metallicRoughnessTexture;
          if (metallicRoughnessTexture !== void 0) {
            metallicRoughnessTexture.texture = gltfJson.textures[metallicRoughnessTexture.index];
          }
        }
        const normalTexture = material.normalTexture;
        if (normalTexture !== void 0) {
          normalTexture.texture = gltfJson.textures[normalTexture.index];
        }
        const occlusionTexture = material.occlusionTexture;
        if (occlusionTexture !== void 0) {
          occlusionTexture.texture = gltfJson.textures[occlusionTexture.index];
        }
        const emissiveTexture = material.emissiveTexture;
        if (emissiveTexture !== void 0) {
          emissiveTexture.texture = gltfJson.textures[emissiveTexture.index];
        }
        if (this._checkRnGltfLoaderOptionsExist(gltfJson) && gltfJson.asset.extras.rnLoaderOptions.loaderExtension && gltfJson.asset.extras.rnLoaderOptions.loaderExtension.setTextures) {
          gltfJson.asset.extras.rnLoaderOptions.loaderExtension.setTextures(gltfJson, material);
        }
      }
    }
  }
  _loadDependenciesOfTextures(gltfJson) {
    if (gltfJson.textures) {
      for (const texture of gltfJson.textures) {
        ifDefinedThen((v) => {
          texture.samplerObject = gltfJson.samplers[v];
        }, texture.sampler);
        if (texture.source !== void 0) {
          texture.image = gltfJson.images[texture.source];
        }
      }
    }
  }
  _loadDependenciesOfJoints(gltfJson) {
    if (gltfJson.skins) {
      for (const skin of gltfJson.skins) {
        if (Is.exist(skin.skeleton)) {
          skin.skeletonObject = gltfJson.nodes[skin.skeleton];
          ifDefinedThen((v) => skin.inverseBindMatricesObject = gltfJson.accessors[v], skin.inverseBindMatrices);
          ifUndefinedThen(() => skin.skeletonObject = gltfJson.nodes[skin.joints[0]], skin.skeleton);
          skin.jointsObjects = [];
          for (const jointIndex of skin.joints) {
            skin.jointsObjects.push(gltfJson.nodes[jointIndex]);
          }
        }
      }
    }
  }
  _loadDependenciesOfAnimations(gltfJson) {
    if (gltfJson.animations) {
      for (const animation of gltfJson.animations) {
        for (const channel of animation.channels) {
          channel.samplerObject = animation.samplers[channel.sampler];
          channel.target.nodeObject = gltfJson.nodes[channel.target.node];
        }
        for (const channel of animation.channels) {
          if (Is.exist(channel.samplerObject)) {
            channel.samplerObject.inputObject = gltfJson.accessors[channel.samplerObject.input];
            channel.samplerObject.outputObject = gltfJson.accessors[channel.samplerObject.output];
            if (channel.samplerObject.outputObject.extras === void 0) {
              channel.samplerObject.outputObject.extras = {};
            }
            if (channel.target.path === "rotation") {
              channel.samplerObject.outputObject.extras.quaternionIfVec4 = true;
            }
            if (channel.target.path === "weights") {
              const weightsArrayLength = channel.samplerObject.outputObject.count / channel.samplerObject.inputObject.count;
              channel.samplerObject.outputObject.extras.weightsArrayLength = weightsArrayLength;
            }
          }
        }
      }
    }
  }
  _loadDependenciesOfAccessors(gltfJson) {
    for (const accessor of gltfJson.accessors) {
      if (accessor.bufferView == null) {
        accessor.bufferView = 0;
      }
      accessor.bufferViewObject = gltfJson.bufferViews[accessor.bufferView];
      if (accessor.sparse != null) {
        const sparse = accessor.sparse;
        sparse.indices.bufferViewObject = gltfJson.bufferViews[sparse.indices.bufferView];
        sparse.values.bufferViewObject = gltfJson.bufferViews[sparse.values.bufferView];
      }
    }
  }
  _loadDependenciesOfBufferViews(gltfJson) {
    for (const bufferView of gltfJson.bufferViews) {
      if (bufferView.buffer !== void 0) {
        bufferView.bufferObject = gltfJson.buffers[bufferView.buffer];
      }
    }
  }
  _mergeExtendedJson(gltfJson, extendedData) {
    let extendedJson = null;
    if (extendedData instanceof ArrayBuffer) {
      const extendedJsonStr = DataUtil.arrayBufferToString(extendedData);
      extendedJson = JSON.parse(extendedJsonStr);
    } else if (typeof extendedData === "string") {
      extendedJson = JSON.parse(extendedData);
    } else if (typeof extendedData === "object") {
      extendedJson = extendedData;
    }
    Object.assign(gltfJson, extendedJson);
  }
  _loadResources(uint8Array, basePath, gltfJson, options, resources) {
    const promisesToLoadResources = [];
    let rnpArrayBuffer;
    for (const i2 in gltfJson.buffers) {
      const bufferInfo = gltfJson.buffers[i2];
      let splitted;
      let filename;
      if (bufferInfo.uri) {
        splitted = bufferInfo.uri.split("/");
        filename = splitted[splitted.length - 1];
      }
      if (typeof bufferInfo.uri === "undefined") {
        rnpArrayBuffer = new RnPromise((resolve, rejected) => {
          resources.buffers[i2] = uint8Array;
          bufferInfo.buffer = uint8Array;
          resolve(uint8Array);
        });
      } else if (bufferInfo.uri.match(/^data:application\/(.*);base64,/)) {
        rnpArrayBuffer = new RnPromise((resolve, rejected) => {
          const arrayBuffer = DataUtil.dataUriToArrayBuffer(bufferInfo.uri);
          resources.buffers[i2] = new Uint8Array(arrayBuffer);
          bufferInfo.buffer = new Uint8Array(arrayBuffer);
          resolve(arrayBuffer);
        });
      } else if (options.files && options.files[filename]) {
        rnpArrayBuffer = new RnPromise((resolve, rejected) => {
          const arrayBuffer = options.files[filename];
          resources.buffers[i2] = new Uint8Array(arrayBuffer);
          bufferInfo.buffer = new Uint8Array(arrayBuffer);
          resolve(arrayBuffer);
        });
      } else {
        rnpArrayBuffer = new RnPromise(DataUtil.loadResourceAsync(basePath + bufferInfo.uri, true, (resolve, response) => {
          resources.buffers[i2] = new Uint8Array(response);
          bufferInfo.buffer = new Uint8Array(response);
          resolve(response);
        }, (reject, error) => {
        }));
      }
      bufferInfo.bufferPromise = rnpArrayBuffer;
      promisesToLoadResources.push(rnpArrayBuffer);
    }
    for (const _i in gltfJson.images) {
      const i2 = _i;
      const imageJson = gltfJson.images[i2];
      let imageUri;
      if (typeof imageJson.uri === "undefined") {
        let arrayBuffer = uint8Array;
        if (uint8Array == null) {
          const bufferView = gltfJson.bufferViews[imageJson.bufferView];
          arrayBuffer = bufferView.bufferObject.buffer;
        }
        const imageUint8Array = DataUtil.createUint8ArrayFromBufferViewInfo(gltfJson, imageJson.bufferView, uint8Array);
        imageUri = DataUtil.createBlobImageUriFromUint8Array(imageUint8Array, imageJson.mimeType);
      } else {
        const imageFileStr = imageJson.uri;
        const splitted = imageFileStr.split("/");
        const filename = splitted[splitted.length - 1];
        if (options.files && options.files[filename]) {
          const arrayBuffer = options.files[filename];
          imageUri = DataUtil.createBlobImageUriFromUint8Array(new Uint8Array(arrayBuffer), imageJson.mimeType);
        } else if (imageFileStr.match(/^data:/)) {
          imageUri = imageFileStr;
        } else {
          imageUri = basePath + imageFileStr;
        }
      }
      const promise = DataUtil.createImageFromUri(imageUri, imageJson.mimeType).then((image) => {
        image.crossOrigin = "Anonymous";
        resources.images[i2] = image;
        imageJson.image = image;
      });
      promisesToLoadResources.push(promise);
    }
    return Promise.all(promisesToLoadResources).catch((err) => {
      Logger.error("Promise.all error: " + err);
    });
  }
  static getInstance() {
    if (!this.__instance) {
      this.__instance = new _DrcPointCloudImporter();
    }
    return this.__instance;
  }
  __decodeDraco(arrayBuffer, defaultOptions, basePath, options) {
    return this.__decodeBuffer(arrayBuffer).then((json) => {
      const gotText = JSON.stringify(json);
      const gltfJson = JSON.parse(gotText);
      return this._loadAsTextJson(gltfJson, options, defaultOptions, basePath).catch((err) => {
        Logger.error("this.__loadAsTextJson error: " + err);
      });
    });
  }
  __decodeBuffer(arrayBuffer) {
    const draco = new DracoDecoderModule();
    const decoder = new draco.Decoder();
    const dracoGeometry = this.__getGeometryFromDracoBuffer(draco, decoder, arrayBuffer);
    if (dracoGeometry == null) {
      throw new Error("invalid dracoGeometry.");
    }
    if (dracoGeometry.geometryType !== draco.POINT_CLOUD) {
      throw new Error("invalid geometryType of drc file.");
    }
    const posAttId = decoder.GetAttributeId(dracoGeometry, draco.POSITION);
    if (posAttId === -1) {
      draco.destroy(decoder);
      draco.destroy(dracoGeometry);
      throw new Error("Draco: No position attribute found.");
    }
    const attributeNames = [
      "POSITION",
      "NORMAL",
      "COLOR",
      "TEX_COORD",
      "GENERIC"
    ];
    const numPoints = dracoGeometry.num_points();
    const attributeDataAll = [];
    const attributeComponents = [];
    let bufferLength = 0;
    for (let i2 = 0; i2 < attributeNames.length; i2++) {
      const attId = decoder.GetAttributeId(dracoGeometry, draco[attributeNames[i2]]);
      if (attId === -1) {
        attributeNames.splice(i2, 1);
        i2--;
        continue;
      }
      const attribute = decoder.GetAttribute(dracoGeometry, attId);
      const attributeData = new draco.DracoFloat32Array();
      decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, attributeData);
      attributeDataAll[i2] = attributeData;
      const numComponent = attribute.num_components();
      attributeComponents[i2] = numComponent;
      if (attributeNames[i2] === "COLOR") {
        bufferLength += numPoints * 4;
      } else {
        bufferLength += numPoints * numComponent;
      }
    }
    const buffer = new Float32Array(bufferLength);
    for (let i2 = 0, currentBufferIndex = 0; i2 < attributeNames.length; i2++) {
      if (attributeNames[i2] === "COLOR" && attributeComponents[i2] === 3) {
        for (let j = 0; j < numPoints; currentBufferIndex += 4, j += 3) {
          buffer[currentBufferIndex] = attributeDataAll[i2].GetValue(j);
          buffer[currentBufferIndex + 1] = attributeDataAll[i2].GetValue(j + 1);
          buffer[currentBufferIndex + 2] = attributeDataAll[i2].GetValue(j + 2);
          buffer[currentBufferIndex + 3] = 1;
        }
      } else if (attributeNames[i2] === "TEX_COORD") {
        for (let j = 0; j < numPoints; currentBufferIndex += 2, j++) {
          buffer[currentBufferIndex] = attributeDataAll[i2].GetValue(2 * j);
          buffer[currentBufferIndex + 1] = 1 - attributeDataAll[i2].GetValue(2 * j + 1);
        }
      } else {
        for (let j = 0; j < numPoints * attributeComponents[i2]; currentBufferIndex++, j++) {
          buffer[currentBufferIndex] = attributeDataAll[i2].GetValue(j);
        }
      }
      draco.destroy(attributeDataAll[i2]);
    }
    draco.destroy(decoder);
    draco.destroy(dracoGeometry);
    return this.__decodedBufferToJSON(buffer, numPoints, attributeNames, attributeComponents);
  }
  async __decodedBufferToJSON(buffer, numPoints, attributeNames, attributeComponents) {
    const json = {
      asset: {
        version: "2.0"
      },
      extensionsUsed: [
        "KHR_materials_unlit"
      ],
      extensionsRequired: [
        "KHR_materials_unlit"
      ],
      nodes: [
        {
          name: "Node",
          mesh: 0
        }
      ],
      scenes: [
        {
          nodes: [
            0
          ]
        }
      ],
      materials: [
        {
          name: "point-cloud_material",
          pbrMetallicRoughness: {
            baseColorFactor: [
              1,
              1,
              1,
              1
            ]
          },
          extensions: {
            KHR_materials_unlit: {}
          }
        }
      ]
    };
    await this.__setBuffersToJSON(buffer, json);
    this.__setAccessorsAndBufferViewsToJSON(numPoints, attributeNames, attributeComponents, json);
    this.__setMeshesToJSON(attributeNames, json);
    return new Promise((resolve, reject) => {
      resolve(json);
    });
  }
  __setBuffersToJSON(buffer, json) {
    return this.__convertBufferToURI(buffer.buffer).then((uri) => {
      json["buffers"] = [
        {
          name: "input",
          byteLength: buffer.byteLength,
          uri
        }
      ];
    }).catch((err) => {
      Logger.error("this.__convertBufferToURI error: " + err);
    });
  }
  __convertBufferToURI(arrayBuffer) {
    return new Promise((resolve, reject) => {
      const blob = new Blob([
        arrayBuffer
      ], {
        type: "application/octet-stream"
      });
      const fr = new FileReader();
      fr.onload = () => {
        resolve(fr.result);
      };
      fr.onerror = () => {
        reject(fr.error);
      };
      fr.readAsDataURL(blob);
    });
  }
  __setAccessorsAndBufferViewsToJSON(numPoints, attributeNames, attributeComponents, json) {
    const accessors = [];
    const bufferViews = [];
    let byteOffsetOfBufferView = 0;
    for (let i2 = 0, indexOfBufferView = 0; i2 < attributeNames.length; indexOfBufferView++) {
      const numOfComponents = attributeComponents[i2];
      let type;
      if (numOfComponents === 1) {
        type = "SCALAR";
      } else {
        type = "VEC" + numOfComponents;
      }
      let byteOffsetOfAccessor = 0;
      const attributeName = attributeNames[i2];
      while (i2 < attributeNames.length) {
        accessors.push({
          name: "point-cloud_" + attributeName + "_" + i2,
          componentType: 5126,
          count: numPoints,
          type,
          bufferView: indexOfBufferView,
          byteOffset: byteOffsetOfAccessor
        });
        if (attributeNames[i2] === "COLOR") {
          byteOffsetOfAccessor += numPoints * 4 * 4;
        } else {
          byteOffsetOfAccessor += numPoints * numOfComponents * 4;
        }
        i2++;
        if (attributeName != attributeNames[i2]) {
          break;
        }
      }
      bufferViews[indexOfBufferView] = {
        name: "bufferView_" + attributeName,
        buffer: 0,
        byteLength: byteOffsetOfAccessor,
        byteOffset: byteOffsetOfBufferView,
        byteStride: numOfComponents * 4,
        target: 34962
      };
      byteOffsetOfBufferView += byteOffsetOfAccessor;
    }
    json["accessors"] = accessors;
    json["bufferViews"] = bufferViews;
  }
  __setMeshesToJSON(attributeNames, json) {
    const attributes = {};
    for (let i2 = 0; i2 < attributeNames.length; i2++) {
      if (attributeNames[i2] === "TEX_COORD") {
        attributes["TEXCOORD_0"] = i2;
      } else if (attributeNames[i2] === "GENERIC") {
        attributes["TANGENT"] = i2;
      } else {
        attributes[attributeNames[i2]] = i2;
      }
    }
    const mesh = {
      name: "Node-Mesh",
      primitives: [
        {
          mode: 0,
          material: 0,
          attributes
        }
      ]
    };
    json["meshes"] = [
      mesh
    ];
  }
  /**
  * Import Draco file of point cloud type.
  * WEIGHTS_0 and JOINTS_0 attribute and all the mesh type and is not support yet.
  * @param uri - uri of glTF file
  * @returns a primitive of Rhodonite object
  */
  async importPointCloudToPrimitive(uri) {
    const r_arrayBuffer = await DataUtil.fetchArrayBuffer(uri);
    return this.__decodeDracoToPrimitive(r_arrayBuffer.unwrapForce());
  }
  // tangent is not available
  __decodeDracoToPrimitive(arrayBuffer) {
    const draco = new DracoDecoderModule();
    const decoder = new draco.Decoder();
    const dracoGeometry = this.__getGeometryFromDracoBuffer(draco, decoder, arrayBuffer);
    if (dracoGeometry == null) {
      throw new Error("invalid dracoGeometry.");
    }
    if (dracoGeometry.geometryType !== draco.POINT_CLOUD) {
      throw new Error("invalid geometryType of drc file.");
    }
    const attributeCompositionTypes = [];
    const attributeSemantics = [];
    const attributes = [];
    this.__getPositions(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes);
    this.__getColors(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes);
    this.__getNormals(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes);
    this.__getTextureCoords(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes);
    const primitive = Primitive.createPrimitive({
      attributeSemantics,
      attributes,
      material: MaterialHelper.createClassicUberMaterial({
        isSkinning: false,
        isLighting: true
      }),
      primitiveMode: PrimitiveMode.Points
    });
    draco.destroy(decoder);
    draco.destroy(dracoGeometry);
    return primitive;
  }
  __getGeometryFromDracoBuffer(draco, decoder, arrayBuffer) {
    const buffer = new draco.DecoderBuffer();
    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);
    const geometryType = decoder.GetEncodedGeometryType(buffer);
    let dracoGeometry;
    let decodingStatus;
    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
    } else {
      const errorMsg = "Unknown geometry type.";
      Logger.error(errorMsg);
    }
    dracoGeometry.geometryType = geometryType;
    if (!decodingStatus.ok() || dracoGeometry.ptr == 0) {
      let errorMsg = "Decoding failed: ";
      errorMsg += decodingStatus.error_msg();
      Logger.error(errorMsg);
      draco.destroy(decoder);
      draco.destroy(dracoGeometry);
      return void 0;
    }
    draco.destroy(buffer);
    return dracoGeometry;
  }
  __getPositions(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes) {
    const posAttId = decoder.GetAttributeId(dracoGeometry, draco.POSITION);
    if (posAttId === -1) {
      draco.destroy(decoder);
      draco.destroy(dracoGeometry);
      throw new Error("Draco: No position attribute found.");
    }
    const posAttribute = decoder.GetAttribute(dracoGeometry, posAttId);
    const posAttributeData = new draco.DracoFloat32Array();
    decoder.GetAttributeFloatForAllPoints(dracoGeometry, posAttribute, posAttributeData);
    const numPoints = dracoGeometry.num_points();
    const numVertices = numPoints * 3;
    const positions = new Float32Array(numVertices);
    for (let i2 = 0; i2 < numVertices; i2 += 1) {
      positions[i2] = posAttributeData.GetValue(i2);
    }
    attributeCompositionTypes.push(CompositionType.Vec3);
    attributeSemantics.push(VertexAttribute.Position.XYZ);
    attributes.push(positions);
    draco.destroy(posAttributeData);
    return positions;
  }
  __getColors(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes) {
    const colorAttId = decoder.GetAttributeId(dracoGeometry, draco.COLOR);
    if (colorAttId === -1) {
      return null;
    } else {
      const colAttribute = decoder.GetAttribute(dracoGeometry, colorAttId);
      const colAttributeData = new draco.DracoFloat32Array();
      decoder.GetAttributeFloatForAllPoints(dracoGeometry, colAttribute, colAttributeData);
      const numPoints = dracoGeometry.num_points();
      const numComponents = colAttribute.num_components();
      const numVertices = numPoints * 4;
      const colors = new Float32Array(numVertices);
      for (let i2 = 0; i2 < numVertices; i2 += numComponents) {
        colors[i2] = colAttributeData.GetValue(i2);
        colors[i2 + 1] = colAttributeData.GetValue(i2 + 1);
        colors[i2 + 2] = colAttributeData.GetValue(i2 + 2);
        if (numComponents == 4) {
          colors[i2 + 3] = colAttributeData.GetValue(i2 + 3);
        } else {
          colors[i2 + 3] = 1;
        }
      }
      attributeCompositionTypes.push(CompositionType.Vec3);
      attributeSemantics.push(VertexAttribute.Color0.XYZ);
      attributes.push(colors);
      draco.destroy(colAttributeData);
      return colors;
    }
  }
  __getNormals(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes) {
    const normalAttId = decoder.GetAttributeId(dracoGeometry, draco.NORMAL);
    if (normalAttId === -1) {
      return null;
    } else {
      const norAttribute = decoder.GetAttribute(dracoGeometry, normalAttId);
      const norAttributeData = new draco.DracoFloat32Array();
      decoder.GetAttributeFloatForAllPoints(dracoGeometry, norAttribute, norAttributeData);
      const numPoints = dracoGeometry.num_points();
      const numVertices = numPoints * 3;
      const normals = new Float32Array(numVertices);
      for (let i2 = 0; i2 < numVertices; i2 += 1) {
        normals[i2] = norAttributeData.GetValue(i2);
      }
      attributeCompositionTypes.push(CompositionType.Vec3);
      attributeSemantics.push(VertexAttribute.Normal.XYZ);
      attributes.push(normals);
      draco.destroy(norAttributeData);
      return normals;
    }
  }
  __getTextureCoords(draco, decoder, dracoGeometry, attributeCompositionTypes, attributeSemantics, attributes) {
    const texCoordAttId = decoder.GetAttributeId(dracoGeometry, draco.TEX_COORD);
    if (texCoordAttId === -1) {
      return null;
    } else {
      const texCoordAttribute = decoder.GetAttribute(dracoGeometry, texCoordAttId);
      const texCoordAttributeData = new draco.DracoFloat32Array();
      decoder.GetAttributeFloatForAllPoints(dracoGeometry, texCoordAttribute, texCoordAttributeData);
      const numPoints = dracoGeometry.num_points();
      const numVertices = numPoints * 2;
      const texCoords = new Float32Array(numVertices);
      for (let i2 = 0; i2 < numVertices; i2 += 1) {
        texCoords[i2] = texCoordAttributeData.GetValue(i2);
      }
      attributeCompositionTypes.push(CompositionType.Vec2);
      attributeSemantics.push(VertexAttribute.Texcoord0.XY);
      attributes.push(texCoords);
      draco.destroy(texCoordAttributeData);
      return texCoords;
    }
  }
};
__name(_DrcPointCloudImporter, "DrcPointCloudImporter");
__publicField(_DrcPointCloudImporter, "__instance");
var DrcPointCloudImporter = _DrcPointCloudImporter;

// src/foundation/importer/FormatDetector.ts
init_DataUtil();
init_FileType();
function detectFormatByArrayBuffers(files) {
  for (const fileName in files) {
    const fileExtension = DataUtil.getExtension(fileName);
    if (fileExtension === "gltf") {
      return FileType.Gltf;
    } else if (fileExtension === "glb") {
      return FileType.GltfBinary;
    } else if (fileExtension === "vrm") {
      return FileType.VRM;
    } else if (fileExtension === "drc") {
      return FileType.Draco;
    }
  }
  return FileType.Unknown;
}
__name(detectFormatByArrayBuffers, "detectFormatByArrayBuffers");
function detectFormatByUri(uri) {
  const split = uri.split(".");
  const fileExtension = split[split.length - 1];
  if (fileExtension === "efk") {
    return "Effekseer";
  } else if (fileExtension === "drc") {
    return "Draco";
  } else if (fileExtension === "vrm") {
    return "VRM";
  } else if (fileExtension === "gltf") {
    return "glTF";
  }
  return "Unknown";
}
__name(detectFormatByUri, "detectFormatByUri");

// src/foundation/importer/index.ts
init_Gltf2Importer();

// src/foundation/importer/GltfImporter.ts
init_Gltf2Importer();
init_ModelConverter();
init_Expression();
init_RenderPass();
init_DataUtil();
init_FileType();

// src/foundation/importer/Vrm0xImporter.ts
init_Gltf2Importer();
init_ModelConverter();
init_Is();
init_RenderPass();
init_Texture();
init_EntityRepository();

// src/foundation/physics/VRMSpring/VRMSpringBonePhysicsStrategy.ts
init_Vector3();
init_MutableVector3();
init_Quaternion();
init_Time();
init_MutableQuaternion();
init_Is();
init_Config();
var _VRMSpringBonePhysicsStrategy = class _VRMSpringBonePhysicsStrategy {
  constructor() {
    __publicField(this, "__spring");
  }
  getParentRotation(head) {
    return head.parent != null ? head.parent.getRotationTo(_VRMSpringBonePhysicsStrategy.__tmp_getParentRotation_quat_0) : _VRMSpringBonePhysicsStrategy.__tmp_getParentRotation_quat_1_identity;
  }
  update() {
    const spring = this.__spring;
    if (Is.exist(spring)) {
      this.updateInner(spring.bones, spring);
    }
  }
  updateInner(bones, spring) {
    const center = spring.center;
    const collisionGroups = spring.colliderGroups;
    for (const bone of bones) {
      bone.setup(center);
    }
    for (const bone of bones) {
      this.process(collisionGroups, bone, center);
    }
  }
  process(collisionGroups, bone, center) {
    bone._calcWorldSpaceBoneLength();
    const dragForce = bone.dragForce;
    const stiffnessForce = bone.stiffnessForce * Time.intervalProcessBegin * Config.physicsTimeIntervalScale;
    let inertia = MutableVector3.multiplyTo(Vector3.subtractTo(bone.currentTail, bone.prevTail, _VRMSpringBonePhysicsStrategy.__tmp_process_vec3_0), 1 - dragForce, _VRMSpringBonePhysicsStrategy.__tmp_process_vec3_1);
    const currentTailWithInertiaInCenter = Vector3.addTo(bone.currentTail, inertia, _VRMSpringBonePhysicsStrategy.__tmp_process_vec3_2);
    const currentTailWithInertiaInWorld = center != null ? center.getWorldPositionOfTo(currentTailWithInertiaInCenter, _VRMSpringBonePhysicsStrategy.__tmp_process_vec3_3) : currentTailWithInertiaInCenter;
    const rotation = Quaternion.multiplyTo(this.getParentRotation(bone.node.getSceneGraph()), bone.node.localRotationRestInner, _VRMSpringBonePhysicsStrategy.__tmp_process_quat_0);
    const stiffness = Vector3.multiplyTo(rotation.transformVector3To(bone.boneAxis, _VRMSpringBonePhysicsStrategy.__tmp_process_vec3_4), stiffnessForce, _VRMSpringBonePhysicsStrategy.__tmp_process_vec3_5);
    const external = Vector3.multiplyTo(bone.gravityDir, bone.gravityPower * Time.intervalProcessBegin * Config.physicsTimeIntervalScale, _VRMSpringBonePhysicsStrategy.__tmp_process_vec3_6);
    let nextTail = Vector3.addTo(Vector3.addTo(currentTailWithInertiaInWorld, stiffness, _VRMSpringBonePhysicsStrategy.__tmp_process_vec3_7), external, _VRMSpringBonePhysicsStrategy.__tmp_process_vec3_8);
    nextTail = this.normalizeBoneLength(nextTail, bone);
    nextTail = this.collision(collisionGroups, nextTail, bone.hitRadius, bone);
    bone.prevTail = bone.currentTail.clone();
    bone.currentTail = center != null ? center.getLocalPositionOfTo(nextTail, _VRMSpringBonePhysicsStrategy.__tmp_process_vec3_9).clone() : nextTail.clone();
    const resultRotation = this.applyRotation(nextTail, bone);
    bone.node.localRotation = resultRotation;
    bone.node.getSceneGraph().setWorldMatrixDirty();
  }
  normalizeBoneLength(nextTail, bone) {
    const sub = Vector3.normalizeTo(Vector3.subtractTo(nextTail, bone.node.getSceneGraph().getPositionTo(_VRMSpringBonePhysicsStrategy.__tmp_normalizeBoneLength_vec3_4), _VRMSpringBonePhysicsStrategy.__tmp_normalizeBoneLength_vec3_0), _VRMSpringBonePhysicsStrategy.__tmp_normalizeBoneLength_vec3_1);
    return Vector3.addTo(bone.node.getSceneGraph().getPositionTo(_VRMSpringBonePhysicsStrategy.__tmp_normalizeBoneLength_vec3_5), Vector3.multiplyTo(sub, bone.boneLength, _VRMSpringBonePhysicsStrategy.__tmp_normalizeBoneLength_vec3_2), _VRMSpringBonePhysicsStrategy.__tmp_normalizeBoneLength_vec3_3);
  }
  applyRotation(nextTail, bone) {
    const sub = Vector3.subtractTo(nextTail, bone.node.getSceneGraph().getPositionTo(_VRMSpringBonePhysicsStrategy.__tmp_applyRotation_vec3_3), _VRMSpringBonePhysicsStrategy.__tmp_applyRotation_vec3_0);
    const to = Quaternion.invertTo(Quaternion.multiplyTo(bone.node.parent.getRotationTo(_VRMSpringBonePhysicsStrategy.__tmp_applyRotation_quat_4), bone.node.localRotationRestInner, _VRMSpringBonePhysicsStrategy.__tmp_applyRotation_quat_0), _VRMSpringBonePhysicsStrategy.__tmp_applyRotation_quat_1).transformVector3To(sub, _VRMSpringBonePhysicsStrategy.__tmp_applyRotation_vec3_1);
    const rot = Quaternion.fromToRotationTo(bone.boneAxis, Vector3.normalizeTo(to, _VRMSpringBonePhysicsStrategy.__tmp_applyRotation_vec3_2), _VRMSpringBonePhysicsStrategy.__tmp_applyRotation_quat_2);
    const result = Quaternion.multiplyTo(bone.node.localRotationRestInner, rot, _VRMSpringBonePhysicsStrategy.__tmp_applyRotation_quat_3);
    return result;
  }
  collision(collisionGroups, nextTail, boneHitRadius, bone) {
    for (const collisionGroup of collisionGroups) {
      for (const collider of collisionGroup.sphereColliders) {
        const { direction, distance } = collider.collision(nextTail, boneHitRadius);
        if (distance < 0) {
          nextTail = Vector3.addTo(nextTail, Vector3.multiplyTo(direction, -distance, _VRMSpringBonePhysicsStrategy.__tmp_collision_vec3_0), _VRMSpringBonePhysicsStrategy.__tmp_collision_vec3_1);
          nextTail = this.normalizeBoneLength(nextTail, bone);
        }
      }
      for (const collider of collisionGroup.capsuleColliders) {
        const { direction, distance } = collider.collision(nextTail, boneHitRadius);
        if (distance < 0) {
          nextTail = Vector3.addTo(nextTail, Vector3.multiplyTo(direction, -distance, _VRMSpringBonePhysicsStrategy.__tmp_collision_vec3_2), _VRMSpringBonePhysicsStrategy.__tmp_collision_vec3_3);
          nextTail = this.normalizeBoneLength(nextTail, bone);
        }
      }
    }
    return nextTail;
  }
  setSpring(sgs) {
    this.__spring = sgs;
  }
};
__name(_VRMSpringBonePhysicsStrategy, "VRMSpringBonePhysicsStrategy");
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_process_vec3_0", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_process_vec3_1", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_process_vec3_2", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_process_vec3_3", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_process_vec3_4", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_process_vec3_5", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_process_vec3_6", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_process_vec3_7", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_process_vec3_8", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_process_vec3_9", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_process_quat_0", MutableQuaternion.identity());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_normalizeBoneLength_vec3_0", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_normalizeBoneLength_vec3_1", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_normalizeBoneLength_vec3_2", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_normalizeBoneLength_vec3_3", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_normalizeBoneLength_vec3_4", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_normalizeBoneLength_vec3_5", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_applyRotation_vec3_0", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_applyRotation_vec3_1", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_applyRotation_vec3_2", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_applyRotation_vec3_3", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_applyRotation_quat_0", MutableQuaternion.identity());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_applyRotation_quat_1", MutableQuaternion.identity());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_applyRotation_quat_2", MutableQuaternion.identity());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_applyRotation_quat_3", MutableQuaternion.identity());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_applyRotation_quat_4", MutableQuaternion.identity());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_getParentRotation_quat_0", MutableQuaternion.identity());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_getParentRotation_quat_1_identity", MutableQuaternion.identity());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_collision_vec3_0", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_collision_vec3_1", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_collision_vec3_2", MutableVector3.zero());
__publicField(_VRMSpringBonePhysicsStrategy, "__tmp_collision_vec3_3", MutableVector3.zero());
var VRMSpringBonePhysicsStrategy = _VRMSpringBonePhysicsStrategy;

// src/foundation/importer/Vrm0xImporter.ts
init_PhysicsComponent();

// src/foundation/physics/VRMSpring/SphereCollider.ts
init_MutableVector3();
init_Vector3();
var _SphereCollider = class _SphereCollider {
  constructor() {
    __publicField(this, "position", Vector3.zero());
    __publicField(this, "radius", 0);
    __publicField(this, "baseSceneGraph");
  }
  collision(bonePosition, boneRadius) {
    const spherePosWorld = this.baseSceneGraph.getWorldPositionOfTo(this.position, _SphereCollider.__tmp_vec3_0);
    const delta = Vector3.subtractTo(bonePosition, spherePosWorld, _SphereCollider.__tmp_vec3_1);
    const direction = Vector3.normalizeTo(delta, _SphereCollider.__tmp_vec3_2);
    const radius = this.radius + boneRadius;
    const distance = delta.length() - radius;
    return {
      direction,
      distance
    };
  }
};
__name(_SphereCollider, "SphereCollider");
__publicField(_SphereCollider, "__tmp_vec3_0", MutableVector3.zero());
__publicField(_SphereCollider, "__tmp_vec3_1", MutableVector3.zero());
__publicField(_SphereCollider, "__tmp_vec3_2", MutableVector3.zero());
var SphereCollider = _SphereCollider;

// src/foundation/importer/Vrm0xImporter.ts
init_Vector3();

// src/foundation/physics/VRMSpring/VRMColliderGroup.ts
var _VRMColliderGroup = class _VRMColliderGroup {
  constructor() {
    __publicField(this, "sphereColliders", []);
    __publicField(this, "capsuleColliders", []);
  }
};
__name(_VRMColliderGroup, "VRMColliderGroup");
var VRMColliderGroup = _VRMColliderGroup;

// src/foundation/physics/VRMSpring/VRMSpring.ts
init_RnObject();
var _VRMSpring = class _VRMSpring extends RnObject {
  constructor(rootBone) {
    super();
    __publicField(this, "rootBone");
    __publicField(this, "bones", []);
    __publicField(this, "colliderGroups", []);
    __publicField(this, "center");
    this.rootBone = rootBone;
  }
};
__name(_VRMSpring, "VRMSpring");
var VRMSpring = _VRMSpring;

// src/foundation/importer/Vrm0xImporter.ts
init_Result();
init_VrmComponent();
init_Sampler();

// src/foundation/physics/VRMSpring/VRMSpringBone.ts
init_RnObject();
init_math();
init_Vector3();
var _VRMSpringBone = class _VRMSpringBone extends RnObject {
  constructor(node) {
    super();
    __publicField(this, "stiffnessForce", 1);
    __publicField(this, "gravityPower", 0);
    __publicField(this, "gravityDir", Vector3.fromCopyArray([
      0,
      -1,
      0
    ]));
    __publicField(this, "dragForce", 0.4);
    __publicField(this, "hitRadius", 0.02);
    __publicField(this, "node");
    __publicField(this, "currentTail", Vector3.zero());
    __publicField(this, "prevTail", Vector3.zero());
    __publicField(this, "boneAxis", Vector3.zero());
    __publicField(this, "boneLength", 0);
    __publicField(this, "initialLocalChildPosition", Vector3.zero());
    __publicField(this, "initialized", false);
    this.node = node;
  }
  setup(center) {
    if (!this.initialized) {
      this.node.getTransform()._backupTransformAsRest();
      const children = this.node.getSceneGraph().children;
      if (children.length > 0) {
        this.initialLocalChildPosition = children[0].entity.getTransform().localPosition;
      } else {
        this.initialLocalChildPosition = Vector3.multiply(Vector3.normalize(this.node.getTransform().localPosition), 0.07);
      }
      const initialWorldChildPosition = this.node.matrixInner.multiplyVector3(this.initialLocalChildPosition);
      this.currentTail = center != null ? center.getLocalPositionOf(initialWorldChildPosition) : initialWorldChildPosition;
      this.prevTail = this.currentTail.clone();
      this.boneAxis = Vector3.normalize(this.initialLocalChildPosition);
      this.initialized = true;
    }
  }
  _getMatrixCenterToWorld(center) {
    const mat = center != null ? center.matrixInner : Matrix44.identity();
    return mat;
  }
  _getMatrixWorldToCenter(center) {
    const mat = center != null ? Matrix44.invert(center.matrixInner) : Matrix44.identity();
    return mat;
  }
  _calcWorldSpaceBoneLength() {
    const v3A = this.node.getSceneGraph().matrixInner.getTranslateTo(_VRMSpringBone.__tmp_vec3_0);
    let v3B = _VRMSpringBone.__tmp_vec3_2_zero;
    const children = this.node.getSceneGraph().children;
    if (children.length > 0) {
      v3B = children[0].matrixInner.getTranslateTo(_VRMSpringBone.__tmp_vec3_1);
    } else {
      v3B = Vector3.multiplyMatrix4(this.initialLocalChildPosition, this.node.getSceneGraph().matrixInner);
    }
    this.boneLength = Vector3.subtract(v3A, v3B).length();
  }
};
__name(_VRMSpringBone, "VRMSpringBone");
__publicField(_VRMSpringBone, "__tmp_vec3_0", MutableVector3.zero());
__publicField(_VRMSpringBone, "__tmp_vec3_1", MutableVector3.zero());
__publicField(_VRMSpringBone, "__tmp_vec3_2_zero", Vector3.zero());
var VRMSpringBone = _VRMSpringBone;

// src/foundation/importer/Vrm0xImporter.ts
init_definitions();
var _Vrm0xImporter = class _Vrm0xImporter {
  constructor() {
  }
  /**
  * Import VRM file.
  */
  static async importFromUri(uri, options) {
    var _a40, _b;
    options = this._getOptions(options);
    const result = await Gltf2Importer.importFromUri(uri, options);
    if (result.isErr()) {
      return new Err({
        message: "Failed to import VRM file.",
        error: result
      });
    }
    assertIsOk(result);
    const gltfModel = result.get();
    const textures = _Vrm0xImporter._createTextures(gltfModel);
    const samplers = _Vrm0xImporter._createSamplers(gltfModel);
    const defaultMaterialHelperArgumentArray = (_b = (_a40 = gltfModel.asset.extras) == null ? void 0 : _a40.rnLoaderOptions) == null ? void 0 : _b.defaultMaterialHelperArgumentArray;
    if (Is.exist(defaultMaterialHelperArgumentArray)) {
      defaultMaterialHelperArgumentArray[0].textures = textures;
      defaultMaterialHelperArgumentArray[0].samplers = samplers;
    }
    _Vrm0xImporter._initializeMaterialProperties(gltfModel, textures.length);
    let rootGroups;
    const rootGroupMain = ModelConverter.convertToRhodoniteObject(gltfModel);
    const existOutline = _Vrm0xImporter._existOutlineMaterial(gltfModel.extensions.VRM);
    if (existOutline) {
      if (Is.exist(defaultMaterialHelperArgumentArray)) {
        defaultMaterialHelperArgumentArray[0].isOutline = true;
      }
      const rootGroupOutline = ModelConverter.convertToRhodoniteObject(gltfModel);
      rootGroups = [
        rootGroupMain,
        rootGroupOutline
      ];
    } else {
      rootGroups = [
        rootGroupMain
      ];
    }
    _Vrm0xImporter._readSpringBone(gltfModel);
    _Vrm0xImporter._readVRMHumanoidInfo(gltfModel, rootGroupMain);
    return new Ok(rootGroups);
  }
  /**
  * For VRM file only
  * Generate JSON.
  */
  static async importJsonOfVRM(uri, options) {
    options = this._getOptions(options);
    const result = await Gltf2Importer.importFromUri(uri, options);
    if (result.isErr()) {
      return new Err({
        message: "Failed to import VRM file.",
        error: result
      });
    }
    assertIsOk(result);
    const gltfJson = result.get();
    _Vrm0xImporter._readVRMHumanoidInfo(gltfJson);
    return new Ok(gltfJson);
  }
  static async __importVRM0x(gltfModel, renderPasses) {
    var _a40, _b, _c, _d, _e, _f;
    const defaultMaterialHelperArgumentArray = (_b = (_a40 = gltfModel.asset.extras) == null ? void 0 : _a40.rnLoaderOptions) == null ? void 0 : _b.defaultMaterialHelperArgumentArray;
    const textures = this._createTextures(gltfModel);
    const samplers = this._createSamplers(gltfModel);
    if (Is.exist(defaultMaterialHelperArgumentArray)) {
      defaultMaterialHelperArgumentArray[0].textures = (_c = defaultMaterialHelperArgumentArray[0].textures) != null ? _c : textures;
      defaultMaterialHelperArgumentArray[0].samplers = (_d = defaultMaterialHelperArgumentArray[0].samplers) != null ? _d : samplers;
      defaultMaterialHelperArgumentArray[0].isLighting = (_e = defaultMaterialHelperArgumentArray[0].isLighting) != null ? _e : true;
    }
    this._initializeMaterialProperties(gltfModel, textures.length);
    let rootGroup;
    const existOutline = this._existOutlineMaterial(gltfModel.extensions.VRM);
    if (existOutline) {
      renderPasses[1] = (_f = renderPasses[1]) != null ? _f : new RenderPass();
      const renderPassOutline = renderPasses[1];
      renderPassOutline.toClearColorBuffer = false;
      renderPassOutline.toClearDepthBuffer = false;
      gltfModel.extensions.VRM.rnExtension = {
        renderPassOutline
      };
      rootGroup = ModelConverter.convertToRhodoniteObject(gltfModel);
      renderPassOutline.addEntities([
        rootGroup
      ]);
    } else {
      rootGroup = ModelConverter.convertToRhodoniteObject(gltfModel);
    }
    const renderPassMain = renderPasses[0];
    renderPassMain.tryToSetUniqueName("VRM Main RenderPass", true);
    renderPassMain.addEntities([
      rootGroup
    ]);
    this._readSpringBone(gltfModel);
    this._readVRMHumanoidInfo(gltfModel, rootGroup);
    this._readBlendShapeGroup(gltfModel, rootGroup);
  }
  static _readBlendShapeGroup(gltfModel, rootEntity) {
    const vrmExpressions = [];
    const blendShapeGroups = gltfModel.extensions.VRM.blendShapeMaster.blendShapeGroups;
    for (const blendShapeGroup of blendShapeGroups) {
      const vrmExpression = {
        name: blendShapeGroup.presetName,
        isBinary: blendShapeGroup.isBinary,
        binds: blendShapeGroup.binds.map((bind) => {
          for (let i2 = 0; i2 < gltfModel.nodes.length; i2++) {
            const node = gltfModel.nodes[i2];
            if (node.mesh === bind.mesh) {
              const rnEntity = gltfModel.extras.rnEntities[i2];
              return {
                entityIdx: rnEntity.entityUID,
                blendShapeIdx: bind.index,
                weight: bind.weight / 100
              };
            }
          }
          throw new Error("Not Found node in blendShapeGroup Process");
        })
      };
      vrmExpressions.push(vrmExpression);
    }
    const vrmEntity = EntityRepository.addComponentToEntity(VrmComponent, rootEntity);
    vrmEntity.getVrm().setVrmExpressions(vrmExpressions);
    vrmEntity.getVrm()._version = "0.x";
  }
  static _readVRMHumanoidInfo(gltfModel, rootEntity) {
    const humanBones = gltfModel.extensions.VRM.humanoid.humanBones;
    const mapNameNodeId = /* @__PURE__ */ new Map();
    for (const bone of humanBones) {
      mapNameNodeId.set(bone.bone, bone.node);
      const boneNode = gltfModel.nodes[bone.node];
      bone.name = boneNode.name;
    }
    if (rootEntity != null) {
      rootEntity.tryToSetTag({
        tag: "humanoid_map_name_nodeId",
        value: mapNameNodeId
      });
    }
  }
  static _readSpringBone(gltfModel) {
    const colliderGroups = [];
    for (const colliderGroupIdx in gltfModel.extensions.VRM.secondaryAnimation.colliderGroups) {
      const colliderGroup = gltfModel.extensions.VRM.secondaryAnimation.colliderGroups[colliderGroupIdx];
      const vrmColliderGroup = new VRMColliderGroup();
      colliderGroups.push(vrmColliderGroup);
      const colliders = [];
      const baseSg = gltfModel.asset.extras.rnEntities[colliderGroup.node].getSceneGraph();
      for (const collider of colliderGroup.colliders) {
        const sphereCollider = new SphereCollider();
        sphereCollider.baseSceneGraph = baseSg;
        sphereCollider.position = Vector3.fromCopyArray([
          collider.offset.x,
          collider.offset.y,
          collider.offset.z
        ]);
        sphereCollider.radius = collider.radius;
        colliders.push(sphereCollider);
      }
      vrmColliderGroup.sphereColliders = colliders;
    }
    const boneGroups = [];
    for (const boneGroup of gltfModel.extensions.VRM.secondaryAnimation.boneGroups) {
      if (boneGroup.bones.length === 0) continue;
      const jointRootIndex = boneGroup.bones[0];
      const jointRootEntity = gltfModel.asset.extras.rnEntities[jointRootIndex];
      const vrmSpringBoneGroup = new VRMSpring(jointRootEntity.getSceneGraph());
      vrmSpringBoneGroup.tryToSetUniqueName(boneGroup.comment, true);
      vrmSpringBoneGroup.colliderGroups = boneGroup.colliderGroups.map((colliderGroupIndex) => {
        return colliderGroups[colliderGroupIndex];
      });
      const addedEntities = [];
      for (const idxOfArray in boneGroup.bones) {
        const boneNodeIndex = boneGroup.bones[idxOfArray];
        const entity = gltfModel.asset.extras.rnEntities[boneNodeIndex];
        this.__addSpringBoneRecursively(vrmSpringBoneGroup, entity, boneGroup, addedEntities);
      }
      if (boneGroup.center != null && boneGroup.center !== -1) {
        vrmSpringBoneGroup.center = gltfModel.asset.extras.rnEntities[boneGroup.center].getSceneGraph();
      }
      boneGroups.push(vrmSpringBoneGroup);
    }
    for (const boneGroup of boneGroups) {
      this.__addPhysicsComponent(boneGroup, boneGroup.rootBone);
    }
  }
  static __addSpringBoneRecursively(vrmSpring, entity, boneGroup, addedEntities) {
    const sg = entity.getSceneGraph();
    const children = sg.children;
    if (!addedEntities.includes(entity)) {
      const springBone = new VRMSpringBone(entity);
      springBone.dragForce = boneGroup.dragForce;
      springBone.stiffnessForce = boneGroup.stiffiness;
      springBone.gravityPower = boneGroup.gravityPower;
      springBone.gravityDir = Vector3.fromCopyArray([
        boneGroup.gravityDir.x,
        boneGroup.gravityDir.y,
        boneGroup.gravityDir.z
      ]);
      springBone.hitRadius = boneGroup.hitRadius;
      vrmSpring.bones.push(springBone);
      addedEntities.push(entity);
    }
    for (const child of children) {
      this.__addSpringBoneRecursively(vrmSpring, child.entity, boneGroup, addedEntities);
    }
  }
  static __addPhysicsComponent(boneGroup, sg) {
    const entity = sg.entity;
    const newEntity = EntityRepository.addComponentToEntity(PhysicsComponent, entity);
    const physicsComponent = newEntity.getPhysics();
    const strategy = new VRMSpringBonePhysicsStrategy();
    strategy.setSpring(boneGroup);
    physicsComponent.setStrategy(strategy);
  }
  static _createTextures(gltfModel) {
    if (!gltfModel.textures) gltfModel.textures = [];
    const gltfTextures = gltfModel.textures;
    const rnTextures = [];
    for (let i2 = 0; i2 < gltfTextures.length; i2++) {
      const rnTexture = ModelConverter._createTexture(gltfTextures[i2], gltfModel);
      rnTextures[i2] = rnTexture;
    }
    const dummyWhiteTexture2 = new Texture2();
    dummyWhiteTexture2.generate1x1TextureFrom();
    rnTextures.push(dummyWhiteTexture2);
    const dummyBlackTexture2 = new Texture2();
    dummyBlackTexture2.generate1x1TextureFrom("rgba(0, 0, 0, 1)");
    rnTextures.push(dummyBlackTexture2);
    return rnTextures;
  }
  static _createSamplers(gltfModel) {
    if (!gltfModel.textures) gltfModel.textures = [];
    const gltfTextures = gltfModel.textures;
    const rnSamplers = [];
    for (let i2 = 0; i2 < gltfTextures.length; i2++) {
      const rnSampler = ModelConverter._createSampler(gltfTextures[i2]);
      rnSamplers[i2] = rnSampler;
    }
    const dummySampler = new Sampler({
      wrapS: TextureParameter.ClampToEdge,
      wrapT: TextureParameter.ClampToEdge,
      minFilter: TextureParameter.Linear,
      magFilter: TextureParameter.Linear
    });
    dummySampler.create();
    rnSamplers.push(dummySampler);
    rnSamplers.push(dummySampler);
    return rnSamplers;
  }
  static _existOutlineMaterial(extensionsVRM) {
    const materialProperties = extensionsVRM.materialProperties;
    if (materialProperties != null) {
      for (const materialProperty of materialProperties) {
        if (materialProperty.floatProperties._OutlineWidthMode !== 0) {
          return true;
        }
      }
    }
    return false;
  }
  static _initializeMaterialProperties(gltfModel, texturesLength) {
    const materialProperties = gltfModel.extensions.VRM.materialProperties;
    for (const materialProperty of materialProperties) {
      if (materialProperty.shader === "VRM/MToon") {
        this.__initializeMToonMaterialProperties(gltfModel, texturesLength);
        break;
      }
    }
  }
  static __initializeMToonMaterialProperties(gltfModel, texturesLength) {
    const materialProperties = gltfModel.extensions.VRM.materialProperties;
    const dummyWhiteTextureNumber = texturesLength - 2;
    const dummyBlackTextureNumber = texturesLength - 1;
    for (let i2 = 0; i2 < materialProperties.length; i2++) {
      const floatProperties = materialProperties[i2].floatProperties;
      this.__initializeForUndefinedProperty(floatProperties, "_BlendMode", 0);
      this.__initializeForUndefinedProperty(floatProperties, "_BumpScale", 1);
      this.__initializeForUndefinedProperty(floatProperties, "_CullMode", 2);
      this.__initializeForUndefinedProperty(floatProperties, "_Cutoff", 0.5);
      this.__initializeForUndefinedProperty(floatProperties, "_DebugMode", 0);
      this.__initializeForUndefinedProperty(floatProperties, "_DstBlend", 0);
      this.__initializeForUndefinedProperty(floatProperties, "_IndirectLightIntensity", 0.1);
      this.__initializeForUndefinedProperty(floatProperties, "_LightColorAttenuation", 0);
      this.__initializeForUndefinedProperty(floatProperties, "_OutlineColorMode", 0);
      this.__initializeForUndefinedProperty(floatProperties, "_OutlineCullMode", 1);
      this.__initializeForUndefinedProperty(floatProperties, "_OutlineLightingMix", 1);
      this.__initializeForUndefinedProperty(floatProperties, "_OutlineScaledMaxDistance", 1);
      this.__initializeForUndefinedProperty(floatProperties, "_OutlineWidth", 0.5);
      this.__initializeForUndefinedProperty(floatProperties, "_OutlineWidthMode", 0);
      this.__initializeForUndefinedProperty(floatProperties, "_ReceiveShadowRate", 1);
      this.__initializeForUndefinedProperty(floatProperties, "_RimFresnelPower", 1);
      this.__initializeForUndefinedProperty(floatProperties, "_RimLift", 0);
      this.__initializeForUndefinedProperty(floatProperties, "_RimLightingMix", 0);
      this.__initializeForUndefinedProperty(floatProperties, "_ShadeShift", 0);
      this.__initializeForUndefinedProperty(floatProperties, "_ShadeToony", 0.9);
      this.__initializeForUndefinedProperty(floatProperties, "_ShadingGradeRate", 1);
      this.__initializeForUndefinedProperty(floatProperties, "_SrcBlend", 1);
      this.__initializeForUndefinedProperty(floatProperties, "_ZWrite", 1);
      const vectorProperties = materialProperties[i2].vectorProperties;
      this.__initializeForUndefinedProperty(vectorProperties, "_Color", [
        1,
        1,
        1,
        1
      ]);
      this.__initializeForUndefinedProperty(vectorProperties, "_EmissionColor", [
        0,
        0,
        0
      ]);
      this.__initializeForUndefinedProperty(vectorProperties, "_OutlineColor", [
        0,
        0,
        0,
        1
      ]);
      this.__initializeForUndefinedProperty(vectorProperties, "_ShadeColor", [
        0.97,
        0.81,
        0.86,
        1
      ]);
      this.__initializeForUndefinedProperty(vectorProperties, "_RimColor", [
        0,
        0,
        0
      ]);
      const textureProperties = materialProperties[i2].textureProperties;
      this.__initializeForUndefinedProperty(textureProperties, "_BumpMap", dummyWhiteTextureNumber);
      this.__initializeForUndefinedProperty(textureProperties, "_EmissionMap", dummyBlackTextureNumber);
      this.__initializeForUndefinedProperty(textureProperties, "_MainTex", dummyWhiteTextureNumber);
      this.__initializeForUndefinedProperty(textureProperties, "_OutlineWidthTexture", dummyWhiteTextureNumber);
      this.__initializeForUndefinedProperty(textureProperties, "_ReceiveShadowTexture", dummyWhiteTextureNumber);
      this.__initializeForUndefinedProperty(textureProperties, "_RimTexture", dummyBlackTextureNumber);
      this.__initializeForUndefinedProperty(textureProperties, "_ShadeTexture", dummyWhiteTextureNumber);
      this.__initializeForUndefinedProperty(textureProperties, "_ShadingGradeTexture", dummyWhiteTextureNumber);
      this.__initializeForUndefinedProperty(textureProperties, "_SphereAdd", dummyBlackTextureNumber);
    }
    for (let i2 = 0; i2 < gltfModel.materials.length; i2++) {
      const material = gltfModel.materials[i2];
      if (material.extras == null) {
        material.extras = {};
      }
      material.extras.vrm0xMaterialProperty = materialProperties[i2];
    }
  }
  static __initializeForUndefinedProperty(object, propertyName, initialValue) {
    if (object[propertyName] == null) object[propertyName] = initialValue;
  }
  static _getOptions(options) {
    if (options != null) {
      for (const file in options.files) {
        const fileName = file.split(".vrm")[0];
        if (fileName) {
          const arraybuffer = options.files[file];
          options.files[fileName + ".glb"] = arraybuffer;
          delete options.files[file];
        }
      }
      options.__isImportVRM0x = true;
      if (options.defaultMaterialHelperArgumentArray == null) {
        options.defaultMaterialHelperArgumentArray = [
          {}
        ];
      }
      if (!options.defaultMaterialHelperArgumentArray[0].isMorphing) {
        options.maxMorphTargetNumber = 0;
      }
    } else {
      options = {
        files: {},
        loaderExtension: void 0,
        defaultMaterialHelperName: void 0,
        defaultMaterialHelperArgumentArray: [
          {
            isLighting: true,
            isMorphing: true,
            isSkinning: true
          }
        ],
        statesOfElements: [
          {
            targets: [],
            states: {
              enable: [],
              functions: {}
            },
            isTransparent: true,
            opacity: 1,
            isTextureImageToLoadPreMultipliedAlpha: false
          }
        ],
        __isImportVRM0x: true,
        __importedType: "vrm0x"
      };
    }
    return options;
  }
};
__name(_Vrm0xImporter, "Vrm0xImporter");
var Vrm0xImporter = _Vrm0xImporter;

// src/foundation/importer/GltfImporter.ts
init_Result();

// src/foundation/importer/VrmImporter.ts
init_ModelConverter();
init_Is();
init_RenderPass();
init_Texture();
init_EntityRepository();
init_PhysicsComponent();
init_Vector3();
init_Result();
init_Gltf2Importer();
init_Sampler();
init_components2();

// src/foundation/physics/VRMSpring/CapsuleCollider.ts
init_Vector3();
var _CapsuleCollider = class _CapsuleCollider {
  constructor() {
    __publicField(this, "position", Vector3.zero());
    __publicField(this, "radius", 0);
    __publicField(this, "tail", Vector3.zero());
    __publicField(this, "baseSceneGraph");
  }
  collision(bonePosition, boneRadius) {
    const spherePosWorld = this.baseSceneGraph.getWorldPositionOf(this.position);
    let tailPosWorld = this.baseSceneGraph.getWorldPositionOf(this.tail);
    tailPosWorld = Vector3.subtract(tailPosWorld, spherePosWorld);
    const lengthSqCapsule = tailPosWorld.lengthSquared();
    let direction = Vector3.subtract(bonePosition, spherePosWorld);
    const dot = tailPosWorld.dot(direction);
    if (dot <= 0) {
    } else if (lengthSqCapsule <= dot) {
      direction = Vector3.subtract(direction, tailPosWorld);
    } else {
      tailPosWorld = Vector3.multiply(tailPosWorld, dot / lengthSqCapsule);
      direction = Vector3.subtract(direction, tailPosWorld);
    }
    const radius = this.radius + boneRadius;
    const distance = direction.length() - radius;
    direction = Vector3.normalize(direction);
    return {
      direction,
      distance
    };
  }
};
__name(_CapsuleCollider, "CapsuleCollider");
var CapsuleCollider = _CapsuleCollider;

// src/foundation/components/Constraint/index.ts
init_ConstraintComponent();

// src/foundation/constraints/VrmRollConstraint.ts
init_Quaternion();
init_Vector3();
var _VrmRollConstraint = class _VrmRollConstraint {
  constructor(srcEntity, rollAxis, weight, dstEntity) {
    __publicField(this, "__srcEntity");
    __publicField(this, "__dstEntity");
    __publicField(this, "__rollAxis");
    __publicField(this, "__weight");
    this.__srcEntity = srcEntity;
    this.__rollAxis = rollAxis;
    this.__weight = weight;
    this.__dstEntity = dstEntity;
    this.__dstEntity.getTransform()._backupTransformAsRest();
  }
  getAxisVector(rollAxis) {
    switch (rollAxis) {
      case "X":
        return Vector3.fromCopy3(1, 0, 0);
      case "Y":
        return Vector3.fromCopy3(0, 1, 0);
      case "Z":
        return Vector3.fromCopy3(0, 0, 1);
      default:
        throw new Error("Invalid roll axis");
    }
  }
  update() {
    const deltaSrcQuat = Quaternion.multiply(Quaternion.invert(this.__srcEntity.localRotationRestInner), this.__srcEntity.localRotationInner);
    const deltaSrcQuatInParent = Quaternion.multiply(Quaternion.multiply(this.__srcEntity.localRotationRestInner, deltaSrcQuat), Quaternion.invert(this.__srcEntity.localRotationRestInner));
    const deltaSrcQuatInDst = Quaternion.multiply(Quaternion.multiply(Quaternion.invert(this.__dstEntity.localRotationRestInner), deltaSrcQuatInParent), this.__dstEntity.localRotationRestInner);
    const rollAxis = this.getAxisVector(this.__rollAxis);
    const toVec = deltaSrcQuatInDst.transformVector3(rollAxis);
    const fromToQuat = Quaternion.fromToRotation(rollAxis, toVec);
    const targetQuat = Quaternion.lerp(this.__dstEntity.localRotationRestInner, Quaternion.multiply(Quaternion.multiply(this.__dstEntity.localRotationRestInner, Quaternion.invert(fromToQuat)), deltaSrcQuatInDst), this.__weight);
    this.__dstEntity.localRotation = targetQuat;
  }
};
__name(_VrmRollConstraint, "VrmRollConstraint");
var VrmRollConstraint = _VrmRollConstraint;

// src/foundation/constraints/VrmAimConstraint.ts
init_math();
init_Vector3();
init_Is();
var _VrmAimConstraint = class _VrmAimConstraint {
  constructor(srcEntity, aimAxis, weight, dstEntity) {
    __publicField(this, "__srcEntity");
    __publicField(this, "__dstEntity");
    __publicField(this, "__aimAxis");
    __publicField(this, "__weight");
    this.__srcEntity = srcEntity;
    this.__aimAxis = aimAxis;
    this.__weight = weight;
    this.__dstEntity = dstEntity;
    this.__dstEntity.getTransform()._backupTransformAsRest();
  }
  getAxisVector(aimAxis) {
    switch (aimAxis) {
      case "PositiveX":
        return Vector3.fromCopy3(1, 0, 0);
      case "NegativeX":
        return Vector3.fromCopy3(-1, 0, 0);
      case "PositiveY":
        return Vector3.fromCopy3(0, 1, 0);
      case "NegativeY":
        return Vector3.fromCopy3(0, -1, 0);
      case "PositiveZ":
        return Vector3.fromCopy3(0, 0, 1);
      case "NegativeZ":
        return Vector3.fromCopy3(0, 0, -1);
      default:
        throw new Error("Invalid roll axis");
    }
  }
  update() {
    const aimAxis = this.getAxisVector(this.__aimAxis);
    const dstParentWorldQuat = Is.exist(this.__dstEntity.getSceneGraph().parent) ? this.__dstEntity.getSceneGraph().parent.rotation : Quaternion.identity();
    const dstRestQuat = this.__dstEntity.localRotationRestInner;
    const fromVec = Quaternion.multiply(dstParentWorldQuat, dstRestQuat).transformVector3(aimAxis);
    const toVec = Vector3.normalize(Vector3.subtract(this.__srcEntity.position, this.__dstEntity.position));
    const fromToQuat = Quaternion.fromToRotation(fromVec, toVec);
    const targetQuat = Quaternion.lerp(dstRestQuat, Quaternion.multiply(Quaternion.multiply(Quaternion.multiply(Quaternion.invert(dstParentWorldQuat), fromToQuat), dstParentWorldQuat), dstRestQuat), this.__weight);
    this.__dstEntity.localRotation = targetQuat;
  }
};
__name(_VrmAimConstraint, "VrmAimConstraint");
var VrmAimConstraint = _VrmAimConstraint;

// src/foundation/constraints/VrmRotationConstraint.ts
init_math();
var _VrmRotationConstraint = class _VrmRotationConstraint {
  constructor(srcEntity, weight, dstEntity) {
    __publicField(this, "__srcEntity");
    __publicField(this, "__dstEntity");
    __publicField(this, "__weight");
    this.__srcEntity = srcEntity;
    this.__weight = weight;
    this.__dstEntity = dstEntity;
    this.__dstEntity.getTransform()._backupTransformAsRest();
  }
  update() {
    const srcDeltaQuat = Quaternion.multiply(Quaternion.invert(this.__srcEntity.localRotationRestInner), this.__srcEntity.localRotationInner);
    const targetQuat = Quaternion.lerp(this.__dstEntity.localRotationRestInner, Quaternion.multiply(this.__dstEntity.localRotationRestInner, srcDeltaQuat), this.__weight);
    this.__dstEntity.localRotation = targetQuat;
  }
};
__name(_VrmRotationConstraint, "VrmRotationConstraint");
var VrmRotationConstraint = _VrmRotationConstraint;

// src/foundation/importer/VrmImporter.ts
init_TextureParameter();
var _VrmImporter = class _VrmImporter {
  constructor() {
  }
  static async __importVRM(gltfModel, renderPasses) {
    var _a40, _b, _c, _d, _e, _f, _g;
    const defaultMaterialHelperArgumentArray = (_b = (_a40 = gltfModel.asset.extras) == null ? void 0 : _a40.rnLoaderOptions) == null ? void 0 : _b.defaultMaterialHelperArgumentArray;
    const textures = this._createTextures(gltfModel);
    const samplers = this._createSamplers(gltfModel);
    if (Is.exist(defaultMaterialHelperArgumentArray)) {
      defaultMaterialHelperArgumentArray[0].textures = (_c = defaultMaterialHelperArgumentArray[0].textures) != null ? _c : textures;
      defaultMaterialHelperArgumentArray[0].samplers = (_d = defaultMaterialHelperArgumentArray[0].samplers) != null ? _d : samplers;
      defaultMaterialHelperArgumentArray[0].isLighting = (_e = defaultMaterialHelperArgumentArray[0].isLighting) != null ? _e : true;
    }
    const existOutline = this.__initializeMToonMaterialProperties(gltfModel, textures.length);
    let rootGroup;
    if (existOutline) {
      renderPasses[1] = (_f = renderPasses[1]) != null ? _f : new RenderPass();
      const renderPassOutline = renderPasses[1];
      renderPassOutline.toClearColorBuffer = false;
      renderPassOutline.toClearDepthBuffer = false;
      gltfModel.extensions.VRM = {};
      gltfModel.extensions.VRM.rnExtension = {
        renderPassOutline
      };
      rootGroup = ModelConverter.convertToRhodoniteObject(gltfModel);
      renderPassOutline.addEntities([
        rootGroup
      ]);
    } else {
      rootGroup = ModelConverter.convertToRhodoniteObject(gltfModel);
    }
    const renderPassMain = renderPasses[0];
    renderPassMain.tryToSetUniqueName("VRM Main RenderPass", true);
    renderPassMain.addEntities([
      rootGroup
    ]);
    this._readSpringBone(gltfModel);
    this._readVRMHumanoidInfo(gltfModel, rootGroup);
    this._readExpressions(gltfModel, rootGroup);
    this._readConstraints(gltfModel);
    if (((_g = gltfModel.asset.extras) == null ? void 0 : _g.rnLoaderOptions) != null) {
      gltfModel.asset.extras.rnLoaderOptions.defaultMaterialHelperArgumentArray = [];
    }
  }
  static _readConstraints(gltfModel) {
    var _a40, _b;
    for (let i2 = 0; i2 < gltfModel.nodes.length; i2++) {
      const node = gltfModel.nodes[i2];
      const constraint = (_b = (_a40 = node.extensions) == null ? void 0 : _a40.VRMC_node_constraint) == null ? void 0 : _b.constraint;
      if (Is.exist(constraint)) {
        if (Is.exist(constraint.roll)) {
          const roll = constraint.roll;
          const dstEntity_ = gltfModel.extras.rnEntities[i2];
          const srcEntity = gltfModel.extras.rnEntities[roll.source];
          const dstEntity = EntityRepository.addComponentToEntity(ConstraintComponent, dstEntity_);
          const rollConstraint = new VrmRollConstraint(srcEntity, roll.rollAxis, Is.exist(roll.weight) ? roll.weight : 1, dstEntity);
          dstEntity.getConstraint().setConstraint(rollConstraint);
        } else if (Is.exist(constraint.aim)) {
          const aim = constraint.aim;
          const dstEntity_ = gltfModel.extras.rnEntities[i2];
          const srcEntity = gltfModel.extras.rnEntities[aim.source];
          const dstEntity = EntityRepository.addComponentToEntity(ConstraintComponent, dstEntity_);
          const aimConstraint = new VrmAimConstraint(srcEntity, aim.aimAxis, Is.exist(aim.weight) ? aim.weight : 1, dstEntity);
          dstEntity.getConstraint().setConstraint(aimConstraint);
        } else if (Is.exist(constraint.rotation)) {
          const rotation = constraint.rotation;
          const dstEntity_ = gltfModel.extras.rnEntities[i2];
          const srcEntity = gltfModel.extras.rnEntities[rotation.source];
          const dstEntity = EntityRepository.addComponentToEntity(ConstraintComponent, dstEntity_);
          const rotationConstraint = new VrmRotationConstraint(srcEntity, Is.exist(rotation.weight) ? rotation.weight : 1, dstEntity);
          dstEntity.getConstraint().setConstraint(rotationConstraint);
        }
      }
    }
  }
  static _readExpressions(gltfModel, rootEntity) {
    var _a40, _b;
    const vrmExpressions = [];
    if (Is.not.exist((_b = (_a40 = gltfModel.extensions.VRMC_vrm) == null ? void 0 : _a40.expressions) == null ? void 0 : _b.preset)) {
      return;
    }
    const expressions = gltfModel.extensions.VRMC_vrm.expressions.preset;
    for (const expressionName in expressions) {
      const expression = expressions[expressionName];
      let binds = [];
      if (Is.exist(expression.morphTargetBinds)) {
        binds = expression.morphTargetBinds.map((bind) => {
          const rnEntity = gltfModel.extras.rnEntities[bind.node];
          return {
            entityIdx: rnEntity.entityUID,
            blendShapeIdx: bind.index,
            weight: bind.weight
          };
        });
      }
      const vrmExpression = {
        name: expressionName,
        isBinary: expression.isBinary,
        binds
      };
      vrmExpressions.push(vrmExpression);
    }
    const vrmEntity = EntityRepository.addComponentToEntity(VrmComponent, rootEntity);
    vrmEntity.getVrm().setVrmExpressions(vrmExpressions);
    vrmEntity.getVrm()._version = "1.0";
  }
  static _readVRMHumanoidInfo(gltfModel, rootEntity) {
    const humanBones = gltfModel.extensions.VRMC_vrm.humanoid.humanBones;
    const mapNameNodeId = /* @__PURE__ */ new Map();
    for (const boneName in humanBones) {
      const bone = humanBones[boneName];
      mapNameNodeId.set(boneName, bone.node);
    }
    if (rootEntity != null) {
      rootEntity.tryToSetTag({
        tag: "humanoid_map_name_nodeId",
        value: mapNameNodeId
      });
    }
  }
  static _readSpringBone(gltfModel) {
    var _a40, _b;
    const colliderGroups = [];
    if (Is.exist((_a40 = gltfModel.extensions.VRMC_springBone) == null ? void 0 : _a40.colliderGroups)) {
      for (const colliderGroupIdx in gltfModel.extensions.VRMC_springBone.colliderGroups) {
        const colliderGroup = gltfModel.extensions.VRMC_springBone.colliderGroups[colliderGroupIdx];
        const vrmColliderGroup = new VRMColliderGroup();
        colliderGroups.push(vrmColliderGroup);
        for (const colliderIdx of colliderGroup.colliders) {
          const collider = gltfModel.extensions.VRMC_springBone.colliders[colliderIdx];
          const baseSg = gltfModel.asset.extras.rnEntities[collider.node].getSceneGraph();
          if (Is.exist(collider.shape.sphere)) {
            const sphereCollider = new SphereCollider();
            sphereCollider.baseSceneGraph = baseSg;
            sphereCollider.position = Vector3.fromCopyArray([
              collider.shape.sphere.offset[0],
              collider.shape.sphere.offset[1],
              collider.shape.sphere.offset[2]
            ]);
            sphereCollider.radius = collider.shape.sphere.radius;
            vrmColliderGroup.sphereColliders.push(sphereCollider);
          } else if (Is.exist(collider.shape.capsule)) {
            const capsuleCollider = new CapsuleCollider();
            capsuleCollider.baseSceneGraph = baseSg;
            capsuleCollider.position = Vector3.fromCopyArray([
              collider.shape.capsule.offset[0],
              collider.shape.capsule.offset[1],
              collider.shape.capsule.offset[2]
            ]);
            capsuleCollider.radius = collider.shape.capsule.radius;
            capsuleCollider.tail = Vector3.fromCopyArray([
              collider.shape.capsule.tail[0],
              collider.shape.capsule.tail[1],
              collider.shape.capsule.tail[2]
            ]);
            vrmColliderGroup.capsuleColliders.push(capsuleCollider);
          }
        }
      }
    }
    const springs = [];
    if (Is.exist((_b = gltfModel.extensions.VRMC_springBone) == null ? void 0 : _b.springs)) {
      for (const spring of gltfModel.extensions.VRMC_springBone.springs) {
        const jointRoot = spring.joints[0];
        const jointRootEntity = gltfModel.asset.extras.rnEntities[jointRoot.node];
        const vrmSpring = new VRMSpring(jointRootEntity.getSceneGraph());
        vrmSpring.tryToSetUniqueName(spring.name, true);
        const colliderGroupIndices = Is.exist(spring.colliderGroups) ? spring.colliderGroups : [];
        vrmSpring.colliderGroups = colliderGroupIndices.map((colliderGroupIdx) => {
          return colliderGroups[colliderGroupIdx];
        });
        const addedEntities = [];
        for (const jointIdx in spring.joints) {
          const joint = spring.joints[jointIdx];
          const entity = gltfModel.asset.extras.rnEntities[joint.node];
          const springBone = new VRMSpringBone(entity);
          springBone.dragForce = joint.dragForce;
          springBone.stiffnessForce = joint.stiffness;
          springBone.gravityPower = Is.exist(joint.gravityPower) ? joint.gravityPower : 1;
          springBone.gravityDir = Is.exist(joint.gravityDir) ? Vector3.fromCopyArray3([
            joint.gravityDir[0],
            joint.gravityDir[1],
            joint.gravityDir[2]
          ]) : Vector3.fromCopyArray3([
            0,
            -1,
            0
          ]);
          springBone.hitRadius = joint.hitRadius;
          vrmSpring.bones.push(springBone);
          addedEntities.push(entity);
        }
        if (spring.center != null && spring.center !== -1) {
          vrmSpring.center = gltfModel.asset.extras.rnEntities[spring.center].getSceneGraph();
        }
        this.__addSpringBoneRecursively(vrmSpring, jointRootEntity, addedEntities);
        springs.push(vrmSpring);
      }
    }
    for (const spring of springs) {
      this.__addPhysicsComponent(spring, spring.rootBone);
    }
  }
  static __addSpringBoneRecursively(vrmSpring, entity, addedEntities) {
    const sg = entity.getSceneGraph();
    const children = sg.children;
    if (!addedEntities.includes(entity)) {
      const springBone = new VRMSpringBone(entity);
      vrmSpring.bones.push(springBone);
      addedEntities.push(entity);
    }
    for (const child of children) {
      this.__addSpringBoneRecursively(vrmSpring, child.entity, addedEntities);
    }
  }
  static __addPhysicsComponent(spring, sg) {
    const entity = sg.entity;
    const newEntity = EntityRepository.addComponentToEntity(PhysicsComponent, entity);
    const physicsComponent = newEntity.getPhysics();
    const strategy = new VRMSpringBonePhysicsStrategy();
    strategy.setSpring(spring);
    physicsComponent.setStrategy(strategy);
  }
  static _createTextures(gltfModel) {
    if (!gltfModel.textures) gltfModel.textures = [];
    const gltfTextures = gltfModel.textures;
    const rnTextures = [];
    for (let i2 = 0; i2 < gltfTextures.length; i2++) {
      const rnTexture = ModelConverter._createTexture(gltfTextures[i2], gltfModel);
      rnTextures[i2] = rnTexture;
    }
    const dummyWhiteTexture2 = new Texture2();
    dummyWhiteTexture2.generate1x1TextureFrom();
    rnTextures.push(dummyWhiteTexture2);
    const dummyBlackTexture2 = new Texture2();
    dummyBlackTexture2.generate1x1TextureFrom("rgba(0, 0, 0, 1)");
    rnTextures.push(dummyBlackTexture2);
    return rnTextures;
  }
  static _createSamplers(gltfModel) {
    if (!gltfModel.textures) gltfModel.textures = [];
    const gltfTextures = gltfModel.textures;
    const rnSamplers = [];
    for (let i2 = 0; i2 < gltfTextures.length; i2++) {
      const rnTexture = ModelConverter._createSampler(gltfTextures[i2]);
      rnSamplers[i2] = rnTexture;
    }
    const dummySampler = new Sampler({
      wrapS: TextureParameter.ClampToEdge,
      wrapT: TextureParameter.ClampToEdge,
      minFilter: TextureParameter.Linear,
      magFilter: TextureParameter.Linear
    });
    dummySampler.create();
    rnSamplers.push(dummySampler);
    rnSamplers.push(dummySampler);
    return rnSamplers;
  }
  static __initializeMToonMaterialProperties(gltfModel, texturesLength) {
    var _a40;
    let isOutline = false;
    for (const material of gltfModel.materials) {
      const mtoonMaterial = (_a40 = material.extensions) == null ? void 0 : _a40.VRMC_materials_mtoon;
      if (mtoonMaterial == null) {
        continue;
      }
      if (Is.not.exist(material.extras)) {
        material.extras = {};
      }
      if (mtoonMaterial.outlineWidthMode !== "none") {
        isOutline = true;
      }
    }
    return isOutline;
  }
  static _getOptions(options) {
    if (options != null) {
      for (const file in options.files) {
        const fileName = file.split(".vrm")[0];
        if (fileName) {
          const arraybuffer = options.files[file];
          options.files[fileName + ".glb"] = arraybuffer;
          delete options.files[file];
        }
      }
      options.__isImportVRM0x = true;
      if (options.defaultMaterialHelperArgumentArray == null) {
        options.defaultMaterialHelperArgumentArray = [
          {}
        ];
      }
      if (!options.defaultMaterialHelperArgumentArray[0].isMorphing) {
        options.maxMorphTargetNumber = 0;
      }
    } else {
      options = {
        files: {},
        loaderExtension: void 0,
        defaultMaterialHelperName: void 0,
        defaultMaterialHelperArgumentArray: [
          {
            isLighting: true,
            isMorphing: true,
            isSkinning: true
          }
        ],
        statesOfElements: [
          {
            targets: [],
            states: {
              enable: [],
              functions: {}
            },
            isTransparent: true,
            opacity: 1,
            isTextureImageToLoadPreMultipliedAlpha: false
          }
        ],
        __isImportVRM0x: true,
        __importedType: "vrm1"
      };
    }
    return options;
  }
  /**
  * For VRM file only
  * Generate JSON.
  */
  static async importJsonOfVRM(uri, options) {
    options = this._getOptions(options);
    const result = await Gltf2Importer.importFromUri(uri, options);
    if (result.isErr()) {
      return new Err({
        message: "Failed to import VRM file.",
        error: result
      });
    }
    assertIsOk(result);
    const gltfJson = result.get();
    _VrmImporter._readVRMHumanoidInfo(gltfJson);
    return new Ok(gltfJson);
  }
};
__name(_VrmImporter, "VrmImporter");
var VrmImporter = _VrmImporter;

// src/foundation/importer/GltfImporter.ts
var _GltfImporter = class _GltfImporter {
  constructor() {
  }
  /**
  * Import GLTF or VRM file.
  * @param uris uri or array of uri of glTF file
  * @param options options for loading process where the files property is ignored
  * @returns gltf expression where:
  *            renderPasses[0]: model entities
  *            renderPasses[1]: model outlines
  */
  static async importFromUri(uri, options, callback) {
    var _a40;
    options = this.__initOptions(options);
    const renderPasses = ((_a40 = options.expression) == null ? void 0 : _a40.renderPasses) || [];
    if (renderPasses.length === 0) {
      renderPasses.push(new RenderPass());
    }
    const r_arrayBuffer = await DataUtil.fetchArrayBuffer(uri);
    if (r_arrayBuffer.isErr()) {
      return new Err({
        message: "Failed to fetch array buffer",
        error: r_arrayBuffer
      });
    }
    options.files[uri] = r_arrayBuffer.get();
    await this.__detectTheModelFileTypeAndImport(uri, renderPasses, options, uri, callback);
    if (options && options.cameraComponent) {
      for (const renderPass of renderPasses) {
        renderPass.cameraComponent = options.cameraComponent;
      }
    }
    const expression = this.__setRenderPassesToExpression(renderPasses, options);
    return new Ok(expression);
  }
  /**
  * Import GLTF or VRM from ArrayBuffers.
  * @param files ArrayBuffers of glTF/VRM files
  * @param options options for loading process where if you use files option, key name of files must be uri of the value array buffer
  * @returns gltf expression where:
  *            renderPasses[0]: model entities
  *            renderPasses[1]: model outlines
  */
  static async importFromArrayBuffers(files, options, callback) {
    var _a40;
    options = this.__initOptions(options);
    const renderPasses = ((_a40 = options.expression) == null ? void 0 : _a40.renderPasses) || [];
    if (renderPasses.length === 0) {
      renderPasses.push(new RenderPass());
    }
    for (const fileName in files) {
      const fileExtension = DataUtil.getExtension(fileName);
      if (this.__isValidExtension(fileExtension)) {
        await this.__detectTheModelFileTypeAndImport(fileName, renderPasses, options, fileName, callback);
      }
    }
    if (options && options.cameraComponent) {
      for (const renderPass of renderPasses) {
        renderPass.cameraComponent = options.cameraComponent;
      }
    }
    const expression = this.__setRenderPassesToExpression(renderPasses, options);
    return new Ok(expression);
  }
  static __initOptions(options) {
    if (options == null) {
      options = DataUtil.createDefaultGltfOptions();
    } else {
      if (options.files == null) {
        options.files = {};
      }
      for (const file in options.files) {
        if (file.match(/.*\.vrm$/) == null) {
          continue;
        }
        const fileName = file.split(".vrm")[0];
        if (fileName) {
          const arraybuffer = options.files[file];
          options.files[fileName + ".glb"] = arraybuffer;
          delete options.files[file];
        }
      }
      if (Array.isArray(options.defaultMaterialHelperArgumentArray) === false) {
        options.defaultMaterialHelperArgumentArray = [
          {}
        ];
      } else {
        if (options.defaultMaterialHelperArgumentArray[0].isMorphing === false) {
          options.maxMorphTargetNumber = 0;
        }
      }
    }
    return options;
  }
  static __setRenderPassesToExpression(renderPasses, options) {
    var _a40;
    const expression = (_a40 = options.expression) != null ? _a40 : new Expression();
    if (expression.renderPasses !== renderPasses) {
      expression.clearRenderPasses();
      expression.addRenderPasses(renderPasses);
    }
    return expression;
  }
  static __isValidExtension(fileExtension) {
    if (fileExtension === "gltf" || fileExtension === "glb" || fileExtension === "vrm" || fileExtension === "drc") {
      return true;
    } else {
      return false;
    }
  }
  static __isGlb(arrayBuffer) {
    const dataView = new DataView(arrayBuffer, 0, 20);
    const isLittleEndian = true;
    const magic = dataView.getUint32(0, isLittleEndian);
    let result;
    if (magic === 1179937895) {
      return true;
    } else {
      return false;
    }
  }
  static __getGlbVersion(glbArrayBuffer) {
    const dataView = new DataView(glbArrayBuffer, 0, 20);
    const isLittleEndian = true;
    const glbVer = dataView.getUint32(4, isLittleEndian);
    return glbVer;
  }
  static __getGltfVersion(gltfJson) {
    var _a40, _b;
    if (((_b = (_a40 = gltfJson.asset) == null ? void 0 : _a40.version) == null ? void 0 : _b.charAt(0)) === "2") {
      return 2;
    } else {
      return 1;
    }
  }
  static async __detectTheModelFileTypeAndImport(fileName, renderPasses, options, uri, callback) {
    const optionalFileType = options.fileType;
    const fileType = this.__getFileTypeFromFilePromise(fileName, options, optionalFileType);
    const fileArrayBuffer = options.files[fileName];
    options.__isImportVRM0x = false;
    let glTFVer = 0;
    switch (fileType) {
      case FileType.Gltf: {
        const gotText = DataUtil.arrayBufferToString(fileArrayBuffer);
        const json = JSON.parse(gotText);
        glTFVer = this.__getGltfVersion(json);
        const importer = Gltf2Importer;
        const gltfModel = await importer._importGltf(json, options.files, options, fileName, callback);
        const rootGroup = ModelConverter.convertToRhodoniteObject(gltfModel);
        renderPasses[0].addEntities([
          rootGroup
        ]);
        options.__importedType = "gltf2";
        return new Ok();
      }
      case FileType.GltfBinary: {
        glTFVer = this.__getGlbVersion(fileArrayBuffer);
        const importer = Gltf2Importer;
        const gltfModel = await importer._importGlb(fileArrayBuffer, options.files, options);
        const rootGroup = ModelConverter.convertToRhodoniteObject(gltfModel);
        renderPasses[0].addEntities([
          rootGroup
        ]);
        options.__importedType = "glb2";
        return new Ok();
      }
      case FileType.Draco: {
        const importer = DrcPointCloudImporter.getInstance();
        const gltfModel = await importer.importArrayBuffer(uri, fileArrayBuffer, options);
        if (gltfModel == null) {
          return new Err({
            message: "importArrayBuffer error is occurred",
            error: void 0
          });
        } else {
          options.__importedType = "draco";
          const rootGroup = ModelConverter.convertToRhodoniteObject(gltfModel);
          renderPasses[0].addEntities([
            rootGroup
          ]);
          return new Ok();
        }
      }
      case FileType.VRM: {
        options.__isImportVRM0x = true;
        const result = await Gltf2Importer._importGltfOrGlbFromArrayBuffers(fileArrayBuffer, options.files, options);
        if (result.isOk()) {
          const gltfModel = result.get();
          if (gltfModel.extensionsUsed.indexOf("VRMC_vrm") >= 0) {
            options.__isImportVRM0x = false;
            gltfModel.asset.extras.rnLoaderOptions.__isImportVRM0x = false;
            options.__importedType = "vrm1";
            await VrmImporter.__importVRM(gltfModel, renderPasses);
          } else if (gltfModel.extensionsUsed.indexOf("VRM") >= 0) {
            options.__importedType = "vrm0x";
            await Vrm0xImporter.__importVRM0x(gltfModel, renderPasses);
          }
          return new Ok();
        } else {
          assertIsErr(result);
          return new Err({
            message: result.getRnError().message,
            error: void 0
          });
        }
      }
      default:
        return new Err({
          message: "detect invalid format",
          error: void 0
        });
    }
  }
  static __getFileTypeFromFilePromise(fileName, options, optionalFileType) {
    if (optionalFileType != null) {
      return FileType.fromString(optionalFileType);
    } else {
      const fileType = detectFormatByArrayBuffers({
        [fileName]: options.files[fileName]
      });
      return fileType;
    }
  }
};
__name(_GltfImporter, "GltfImporter");
var GltfImporter = _GltfImporter;

// src/foundation/importer/index.ts
init_ModelConverter();
init_RhodoniteImportExtension();

// src/foundation/importer/VrmaImporter.ts
init_Is();
init_Result();
init_Gltf2Importer();
var _VrmaImporter = class _VrmaImporter {
  static async importFromUri(uri) {
    const options = {};
    const result = await Gltf2Importer.importFromUri(uri, options);
    if (result.isErr()) {
      return new Err({
        message: "Failed to import VRM file.",
        error: result
      });
    }
    assertIsOk(result);
    const gltfJson = result.get();
    this.readHumanoid(gltfJson);
    return new Ok(gltfJson);
  }
  static async importFromArrayBuffer(arrayBuffer) {
    const options = {};
    const result = await Gltf2Importer.importFromArrayBuffers({
      "data.glb": arrayBuffer
    }, options);
    if (result.isErr()) {
      return new Err({
        message: "Failed to import VRM file.",
        error: result
      });
    }
    assertIsOk(result);
    const gltfJson = result.get();
    this.readHumanoid(gltfJson);
    return new Ok(gltfJson);
  }
  static readHumanoid(rnm) {
    var _a40;
    const humanBones = (_a40 = rnm.extensions.VRMC_vrm_animation.humanoid) == null ? void 0 : _a40.humanBones;
    if (Is.not.exist(humanBones)) {
      return;
    }
    const humanoidBoneNameMap = /* @__PURE__ */ new Map();
    rnm.extensions.VRMC_vrm_animation.humanoidBoneNameMap = humanoidBoneNameMap;
    for (const boneName in humanBones) {
      const node = humanBones[boneName];
      humanoidBoneNameMap.set(node.node, boneName);
    }
  }
};
__name(_VrmaImporter, "VrmaImporter");
var VrmaImporter = _VrmaImporter;

// src/foundation/materials/core/index.ts
init_AbstractMaterialContent();
init_AbstractShaderNode();
init_Material();
init_MaterialRepository();

// src/foundation/materials/core/ShaderGraphResolver.ts
init_AbstractShaderNode();
init_ShaderType();
init_CompositionType();
init_ComponentType();
init_CommonShaderPart();

// src/foundation/materials/nodes/ConstantScalarVariableShaderNode.ts
init_definitions();

// src/webgl/shaders/nodes/ConstantVariableShader.ts
init_CommonShaderPart();
init_ComponentType();
init_ProcessApproach();
init_SystemState();
var _ConstantVariableShader = class _ConstantVariableShader extends CommonShaderPart {
  constructor(__functionName, __compositionType, __componentType) {
    super();
    __publicField(this, "__functionName");
    __publicField(this, "__compositionType");
    __publicField(this, "__componentType");
    __publicField(this, "__constantValueStr");
    this.__functionName = __functionName;
    this.__compositionType = __compositionType;
    this.__componentType = __componentType;
    this.__constantValueStr = "";
  }
  setConstantValue(value) {
    let constant = "";
    if (this.__componentType.isFloatingPoint()) {
      constant = value.glslStrAsFloat;
    } else if (this.__componentType.isInteger()) {
      constant = value.glslStrAsInt;
    } else if (this.__componentType === ComponentType.Bool) {
      constant = value.x ? "true" : "false";
    }
    this.__constantValueStr = constant;
  }
  get vertexShaderDefinitions() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      return `
      fn ${this.__functionName}(
        outValue: ptr<function, ${this.__compositionType.toWGSLType(this.__componentType)}>) {
        *outValue = ${this.__constantValueStr};
      }
      `;
    } else {
      return `
      void ${this.__functionName}(
        out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
        outValue = ${this.__constantValueStr};
      }
      `;
    }
  }
  get pixelShaderDefinitions() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      return `
      fn ${this.__functionName}(
        outValue: ptr<function, ${this.__compositionType.toWGSLType(this.__componentType)}>) {
        *outValue = ${this.__constantValueStr};
      }
      `;
    } else {
      return `
      void ${this.__functionName}(
        out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
        outValue = ${this.__constantValueStr};
      }
      `;
    }
  }
  get attributeNames() {
    return [];
  }
  get attributeSemantics() {
    return [];
  }
  get attributeCompositions() {
    return [];
  }
};
__name(_ConstantVariableShader, "ConstantVariableShader");
var ConstantVariableShader = _ConstantVariableShader;

// src/foundation/materials/nodes/ConstantVariableShaderNode.ts
init_AbstractShaderNode();

// src/foundation/materials/core/Socket.ts
var _Socket = class _Socket {
  constructor(name, compositionType, componentType) {
    __publicField(this, "name");
    __publicField(this, "compositionType");
    __publicField(this, "componentType");
    this.name = name;
    this.compositionType = compositionType;
    this.componentType = componentType;
  }
};
__name(_Socket, "Socket");
var Socket = _Socket;

// src/foundation/materials/nodes/ConstantVariableShaderNode.ts
var _ConstantVariableShaderNode = class _ConstantVariableShaderNode extends AbstractShaderNode {
  constructor(nodeName, compositionType, componentType) {
    super(nodeName, {});
    this.__shaderFunctionName += "_" + this.__shaderNodeUid;
    this.__commonPart = new ConstantVariableShader(this.__shaderFunctionName, compositionType, componentType);
    this.__outputs.push(new Socket("outValue", compositionType, componentType));
  }
  setDefaultInputValue(value) {
    this.__commonPart.setConstantValue(value);
  }
  getSocketOutput() {
    return this.__outputs[0];
  }
};
__name(_ConstantVariableShaderNode, "ConstantVariableShaderNode");
var ConstantVariableShaderNode = _ConstantVariableShaderNode;

// src/foundation/materials/nodes/ConstantScalarVariableShaderNode.ts
var _ConstantScalarVariableShaderNode = class _ConstantScalarVariableShaderNode extends ConstantVariableShaderNode {
  constructor(componentType) {
    super("ConstantScalar", CompositionType.Scalar, componentType);
  }
  setDefaultInputValue(value) {
    this.__commonPart.setConstantValue(value);
  }
};
__name(_ConstantScalarVariableShaderNode, "ConstantScalarVariableShaderNode");
var ConstantScalarVariableShaderNode = _ConstantScalarVariableShaderNode;

// src/foundation/materials/core/ShaderGraphResolver.ts
init_Scalar();

// src/foundation/materials/nodes/ConstantVector2VariableShaderNode.ts
init_definitions();
var _ConstantVector2VariableShaderNode = class _ConstantVector2VariableShaderNode extends ConstantVariableShaderNode {
  constructor(componentType) {
    super("ConstantVector2", CompositionType.Vec2, componentType);
  }
  setDefaultInputValue(value) {
    this.__commonPart.setConstantValue(value);
  }
};
__name(_ConstantVector2VariableShaderNode, "ConstantVector2VariableShaderNode");
var ConstantVector2VariableShaderNode = _ConstantVector2VariableShaderNode;

// src/foundation/materials/core/ShaderGraphResolver.ts
init_Vector2();

// src/foundation/materials/nodes/ConstantVector3VariableShaderNode.ts
init_definitions();
var _ConstantVector3VariableShaderNode = class _ConstantVector3VariableShaderNode extends ConstantVariableShaderNode {
  constructor(componentType) {
    super("ConstantVector3", CompositionType.Vec3, componentType);
  }
  setDefaultInputValue(value) {
    this.__commonPart.setConstantValue(value);
  }
};
__name(_ConstantVector3VariableShaderNode, "ConstantVector3VariableShaderNode");
var ConstantVector3VariableShaderNode = _ConstantVector3VariableShaderNode;

// src/foundation/materials/core/ShaderGraphResolver.ts
init_Vector3();
init_Vector4();

// src/foundation/materials/nodes/ConstantVector4VariableShaderNode.ts
init_definitions();
var _ConstantVector4VariableShaderNode = class _ConstantVector4VariableShaderNode extends ConstantVariableShaderNode {
  constructor(componentType) {
    super("ConstantVector4", CompositionType.Vec4, componentType);
  }
  setDefaultInputValue(value) {
    this.__commonPart.setConstantValue(value);
  }
};
__name(_ConstantVector4VariableShaderNode, "ConstantVector4VariableShaderNode");
var ConstantVector4VariableShaderNode = _ConstantVector4VariableShaderNode;

// src/webgl/shaders/nodes/UniformDataShader.ts
init_CommonShaderPart();
init_ProcessApproach();
init_SystemState();
var _UniformDataShader = class _UniformDataShader extends CommonShaderPart {
  constructor(__functionName, __compositionType, __componentType) {
    super();
    __publicField(this, "__functionName");
    __publicField(this, "__compositionType");
    __publicField(this, "__componentType");
    __publicField(this, "__variableName");
    __publicField(this, "__valueStr");
    this.__functionName = __functionName;
    this.__compositionType = __compositionType;
    this.__componentType = __componentType;
    this.__variableName = "";
    this.__valueStr = "";
  }
  setVariableName(name) {
    this.__variableName = name;
  }
  setDefaultValue(value) {
    this.__valueStr = value.toString();
  }
  get vertexShaderDefinitions() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      return `
// #param ${this.__variableName}: ${this.__compositionType.toWGSLType(this.__componentType)}; // initialValue=${this.__valueStr}
fn ${this.__functionName}(outValue: ptr<function, ${this.__compositionType.toWGSLType(this.__componentType)}>) {
  *outValue = get_${this.__variableName}(_materialSID, 0);
}
`;
    } else {
      return `
uniform ${this.__compositionType.getGlslStr(this.__componentType)} u_${this.__variableName}; // initialValue=${this.__valueStr}
void ${this.__functionName}(out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
  #ifdef RN_IS_DATATEXTURE_MODE
    float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID
  #else
    float materialSID = u_materialSID;
  #endif

  outValue = get_${this.__variableName}(materialSID, 0);
}
`;
    }
  }
  get pixelShaderDefinitions() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      return `
// #param ${this.__variableName}: ${this.__compositionType.toWGSLType(this.__componentType)}; // initialValue=${this.__valueStr}
fn ${this.__functionName}(outValue: ptr<function, ${this.__compositionType.toWGSLType(this.__componentType)}>) {
  *outValue = get_${this.__variableName}(_materialSID, 0);
}
`;
    } else {
      return `
uniform ${this.__compositionType.getGlslStr(this.__componentType)} u_${this.__variableName}; // initialValue=${this.__valueStr}
void ${this.__functionName}(out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
#ifdef RN_IS_DATATEXTURE_MODE
  float materialSID = u_currentComponentSIDs[0]; // index 0 data is the materialSID
#else
  float materialSID = u_materialSID;
#endif

outValue = get_${this.__variableName}(materialSID, 0);
    }
    `;
    }
  }
  get attributeNames() {
    return [];
  }
  get attributeSemantics() {
    return [];
  }
  get attributeCompositions() {
    return [];
  }
};
__name(_UniformDataShader, "UniformDataShader");
var UniformDataShader = _UniformDataShader;

// src/foundation/materials/nodes/UniformDataShaderNode.ts
init_AbstractShaderNode();
var _UniformDataShaderNode = class _UniformDataShaderNode extends AbstractShaderNode {
  constructor(compositionType, componentType) {
    super("uniformData", {});
    this.__shaderFunctionName += "_" + this.__shaderNodeUid;
    this.__commonPart = new UniformDataShader(this.__shaderFunctionName, compositionType, componentType);
    this.__outputs.push(new Socket("outValue", compositionType, componentType));
  }
  setDefaultInputValue(inputName, value) {
    if (inputName === "value") {
      this.__commonPart.setDefaultValue(value);
    }
  }
  setUniformDataName(value) {
    this.__commonPart.setVariableName(value);
  }
};
__name(_UniformDataShaderNode, "UniformDataShaderNode");
var UniformDataShaderNode = _UniformDataShaderNode;

// src/foundation/materials/nodes/AddShaderNode.ts
init_AbstractShaderNode();
init_CompositionType();
init_ComponentType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/Add.glsl
var Add_default = { code: "\nvoid add(in float lfs, in float rhs, out float outValue) {\n  outValue = lfs + rhs;\n}\nvoid add(in int lfs, in int rhs, out int outValue) {\n  outValue = lfs + rhs;\n}\nvoid add(in vec2 lfs, in vec2 rhs, out vec2 outValue) {\n  outValue = lfs + rhs;\n}\nvoid add(in vec3 lfs, in vec3 rhs, out vec3 outValue) {\n  outValue = lfs + rhs;\n}\nvoid add(in vec4 lfs, in vec4 rhs, out vec4 outValue) {\n  outValue = lfs + rhs;\n}\n", shaderStage: "fragment", isFragmentShader: true };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/Add.wgsl
var Add_default2 = { code: "\nfn addF32F32(lfs: f32, rhs: f32, outValue: ptr<function, f32>) {\n  *outValue = lfs + rhs;\n}\nfn addI32I32(lfs: i32, rhs: i32, outValue: ptr<function, i32>) {\n  *outValue = lfs + rhs;\n}\nfn addVec2fVec2f(lfs: vec2<f32>, rhs: vec2<f32>, outValue: ptr<function, vec2<f32>>) {\n  *outValue = lfs + rhs;\n}\nfn addVec3fVec3f(lfs: vec3<f32>, rhs: vec3<f32>, outValue: ptr<function, vec3<f32>>) {\n  *outValue = lfs + rhs;\n}\nfn addVec4fVec4f(lfs: vec4<f32>, rhs: vec4<f32>, outValue: ptr<function, vec4<f32>>) {\n  *outValue = lfs + rhs;\n}\n", shaderStage: "fragment", isFragmentShader: true };

// src/foundation/materials/nodes/AddShaderNode.ts
init_ProcessApproach();
init_SystemState();
var _AddShaderNode = class _AddShaderNode extends AbstractShaderNode {
  constructor(compositionType, componentType) {
    super("add", {
      codeGLSL: Add_default.code,
      codeWGSL: Add_default2.code
    });
    this.__inputs.push(new Socket("lhs", compositionType, componentType));
    this.__inputs.push(new Socket("rhs", compositionType, componentType));
    this.__outputs.push(new Socket("outValue", compositionType, componentType));
  }
  getSocketInputLhs() {
    return this.__inputs[0];
  }
  getSocketInputRhs() {
    return this.__inputs[1];
  }
  getSocketOutput() {
    return this.__outputs[0];
  }
  getShaderFunctionNameDerivative() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      if (this.__inputs[0].compositionType === CompositionType.Scalar && this.__inputs[1].compositionType === CompositionType.Scalar) {
        if (this.__inputs[0].componentType === ComponentType.Float && this.__inputs[1].componentType === ComponentType.Float) {
          return this.__shaderFunctionName + "F32F32";
        } else if (this.__inputs[0].componentType === ComponentType.Int && this.__inputs[1].componentType === ComponentType.Int) {
          return this.__shaderFunctionName + "I32I32";
        } else {
          throw new Error("Not implemented");
        }
      } else if (this.__inputs[0].compositionType === CompositionType.Vec2 && this.__inputs[1].compositionType === CompositionType.Vec2) {
        return this.__shaderFunctionName + "Vec2fVec2f";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec3 && this.__inputs[1].compositionType === CompositionType.Vec3) {
        return this.__shaderFunctionName + "Vec3fVec3f";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec4 && this.__inputs[1].compositionType === CompositionType.Vec4) {
        return this.__shaderFunctionName + "Vec4fVec4f";
      } else {
        throw new Error("Not implemented");
      }
    } else {
      return this.__shaderFunctionName;
    }
  }
};
__name(_AddShaderNode, "AddShaderNode");
var AddShaderNode = _AddShaderNode;

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/Normalize.glsl
var Normalize_default = { code: "\nvoid _normalize(in vec2 value, out vec2 outValue) {\n  outValue = normalize(value);\n}\n\nvoid _normalize(in vec3 value, out vec3 outValue) {\n  outValue = normalize(value);\n}\n\nvoid _normalize(in vec4 value, out vec4 outValue) {\n  outValue = normalize(value);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/Normalize.wgsl
var Normalize_default2 = { code: "\nfn _normalizeVec2f(value: vec2<f32>, outValue: ptr<function, vec2<f32>>) {\n  *outValue = normalize(value);\n}\n\nfn _normalizeVec3f(value: vec3<f32>, outValue: ptr<function, vec3<f32>>) {\n  *outValue = normalize(value);\n}\n\nfn _normalizeVec4f(value: vec4<f32>, outValue: ptr<function, vec4<f32>>) {\n  *outValue = normalize(value);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// src/foundation/materials/nodes/NormalizeShaderNode.ts
init_CompositionType();
init_AbstractShaderNode();
init_SystemState();
init_ProcessApproach();
var _NormalizeShaderNode = class _NormalizeShaderNode extends AbstractShaderNode {
  constructor(compositionType, componentType) {
    super("_normalize", {
      codeGLSL: Normalize_default.code,
      codeWGSL: Normalize_default2.code
    });
    this.__inputs.push({
      compositionType,
      componentType,
      name: "value"
    });
    this.__outputs.push({
      compositionType,
      componentType,
      name: "outValue"
    });
  }
  getShaderFunctionNameDerivative() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      if (this.__inputs[0].compositionType === CompositionType.Vec2) {
        return this.__shaderFunctionName + "Vec2f";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec3) {
        return this.__shaderFunctionName + "Vec3f";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec4) {
        return this.__shaderFunctionName + "Vec4f";
      } else {
        throw new Error("Not supported composition type.");
      }
    } else {
      return this.__shaderFunctionName;
    }
  }
};
__name(_NormalizeShaderNode, "NormalizeShaderNode");
var NormalizeShaderNode = _NormalizeShaderNode;

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/DotProduct.glsl
var DotProduct_default = { code: "\nvoid dotProduct(in vec2 lfs, in vec2 rhs, out float outValue) {\n  outValue = dot(lfs, rhs);\n}\nvoid dotProduct(in vec3 lfs, in vec3 rhs, out float outValue) {\n  outValue = dot(lfs, rhs);\n}\nvoid dotProduct(in vec4 lfs, in vec4 rhs, out float outValue) {\n  outValue = dot(lfs, rhs);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/DotProduct.wgsl
var DotProduct_default2 = { code: "fn dotProductVec2f(lfs: vec2<f32>, rhs: vec2<f32>, outValue: ptr<function, f32>) {\n  *outValue = dot(lfs, rhs);\n}\nfn dotProductVec3f(lfs: vec3<f32>, rhs: vec3<f32>, outValue: ptr<function, f32>) {\n  *outValue = dot(lfs, rhs);\n}\nfn dotProductVec4f(lfs: vec4<f32>, rhs: vec4<f32>, outValue: ptr<function, f32>) {\n  *outValue = dot(lfs, rhs);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// src/foundation/materials/nodes/DotProductShaderNode.ts
init_AbstractShaderNode();
init_CompositionType();
init_ComponentType();
init_SystemState();
init_ProcessApproach();
var _DotProductShaderNode = class _DotProductShaderNode extends AbstractShaderNode {
  constructor(compositionType, componentType) {
    super("dotProduct", {
      codeGLSL: DotProduct_default.code,
      codeWGSL: DotProduct_default2.code
    });
    this.__inputs.push({
      compositionType,
      componentType,
      name: "lhs"
    });
    this.__inputs.push({
      compositionType,
      componentType: ComponentType.Float,
      name: "rhs"
    });
    this.__outputs.push({
      compositionType: CompositionType.Scalar,
      componentType,
      name: "outValue"
    });
  }
  getShaderFunctionNameDerivative() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      if (this.__inputs[0].compositionType === CompositionType.Vec2) {
        return this.__shaderFunctionName + "Vec2f";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec3) {
        return this.__shaderFunctionName + "Vec3f";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec4) {
        return this.__shaderFunctionName + "Vec4f";
      } else {
        throw new Error("Not supported composition type.");
      }
    } else {
      return this.__shaderFunctionName;
    }
  }
};
__name(_DotProductShaderNode, "DotProductShaderNode");
var DotProductShaderNode = _DotProductShaderNode;

// src/foundation/materials/nodes/MultiplyShaderNode.ts
init_CompositionType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/Multiply.glsl
var Multiply_default = { code: "\nvoid multiply(in float lfs, in float rhs, out float outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in int lfs, in int rhs, out int outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in vec2 lfs, in vec2 rhs, out vec2 outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in vec3 lfs, in vec3 rhs, out vec3 outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in vec4 lfs, in vec4 rhs, out vec4 outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in mat2 lfs, in mat2 rhs, out mat2 outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in mat3 lfs, in mat3 rhs, out mat3 outValue) {\n  outValue = lfs * rhs;\n}\nvoid multiply(in mat4 lfs, in mat4 rhs, out mat4 outValue) {\n  outValue = lfs * rhs;\n}\n", shaderStage: "fragment", isFragmentShader: true };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/Multiply.wgsl
var Multiply_default2 = { code: "fn multiplyF32F32(lfs: f32, rhs: f32, outValue: ptr<function, f32>) {\n  *outValue = lfs * rhs;\n}\nfn multiplyI32I32(lfs: i32, rhs: i32, outValue: ptr<function, i32>) {\n  *outValue = lfs * rhs;\n}\nfn multiplyVec2fVec2f(lfs: vec2<f32>, rhs: vec2<f32>, outValue: ptr<function, vec2<f32>>) {\n  *outValue = lfs * rhs;\n}\nfn multiplyVec3fVec3f(lfs: vec3<f32>, rhs: vec3<f32>, outValue: ptr<function, vec3<f32>>) {\n  *outValue = lfs * rhs;\n}\nfn multiplyVec4fVec4f(lfs: vec4<f32>, rhs: vec4<f32>, outValue: ptr<function, vec4<f32>>) {\n  *outValue = lfs * rhs;\n}\nfn multiplyMat2x2fMat2x2f(lfs: mat2x2<f32>, rhs: mat2x2<f32>, outValue: ptr<function, mat2x2<f32>>) {\n  *outValue = lfs * rhs;\n}\nfn multiplyMat3x3fMat3x3f(lfs: mat3x3<f32>, rhs: mat3x3<f32>, outValue: ptr<function, mat3x3<f32>>) {\n  *outValue = lfs * rhs;\n}\nfn multiplyMat4x4fMat4x4f(lfs: mat4x4<f32>, rhs: mat4x4<f32>, outValue: ptr<function, mat4x4<f32>>) {\n  *outValue = lfs * rhs;\n}\n", shaderStage: "fragment", isFragmentShader: true };

// src/foundation/materials/nodes/MultiplyShaderNode.ts
init_ComponentType();
init_AbstractShaderNode();
init_SystemState();
init_ProcessApproach();
var _MultiplyShaderNode = class _MultiplyShaderNode extends AbstractShaderNode {
  constructor(compositionType, componentType) {
    super("multiply", {
      codeGLSL: Multiply_default.code,
      codeWGSL: Multiply_default2.code
    });
    this.__inputs.push({
      compositionType,
      componentType,
      name: "lhs"
    });
    this.__inputs.push({
      compositionType,
      componentType,
      name: "rhs"
    });
    this.__outputs.push({
      compositionType,
      componentType,
      name: "outValue"
    });
  }
  getShaderFunctionNameDerivative() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      if (this.__inputs[0].compositionType === CompositionType.Scalar && this.__inputs[1].compositionType === CompositionType.Scalar) {
        if (this.__inputs[0].componentType === ComponentType.Float && this.__inputs[1].componentType === ComponentType.Float) {
          return this.__shaderFunctionName + "F32F32";
        } else if (this.__inputs[0].componentType === ComponentType.Int && this.__inputs[1].componentType === ComponentType.Int) {
          return this.__shaderFunctionName + "I32I32";
        } else {
          throw new Error("Not implemented");
        }
      } else if (this.__inputs[0].compositionType === CompositionType.Vec2 && this.__inputs[1].compositionType === CompositionType.Vec2) {
        return this.__shaderFunctionName + "Vec2fVec2f";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec3 && this.__inputs[1].compositionType === CompositionType.Vec3) {
        return this.__shaderFunctionName + "Vec3fVec3f";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec4 && this.__inputs[1].compositionType === CompositionType.Vec4) {
        return this.__shaderFunctionName + "Vec4fVec4f";
      } else if (this.__inputs[0].compositionType === CompositionType.Mat2 && this.__inputs[1].compositionType === CompositionType.Mat2) {
        return this.__shaderFunctionName + "Mat2x2fMat2x2f";
      } else if (this.__inputs[0].compositionType === CompositionType.Mat3 && this.__inputs[1].compositionType === CompositionType.Mat3) {
        return this.__shaderFunctionName + "Mat3x3fMat3x3f";
      } else if (this.__inputs[0].compositionType === CompositionType.Mat4 && this.__inputs[1].compositionType === CompositionType.Mat4) {
        return this.__shaderFunctionName + "Mat4x4fMat4x4f";
      } else {
        throw new Error("Not implemented");
      }
    } else {
      return this.__shaderFunctionName;
    }
  }
};
__name(_MultiplyShaderNode, "MultiplyShaderNode");
var MultiplyShaderNode = _MultiplyShaderNode;

// src/foundation/materials/nodes/AttributeColorShaderNode.ts
init_CompositionType();
init_ComponentType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/AttributeColor.vert
var AttributeColor_default = { code: "\nin vec4 a_color_0;\n\nvoid attributeColor(out vec4 outValue) {\n  outValue = a_color_0;\n}\n", shaderStage: "vertex", isFragmentShader: false };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/AttributeColor.vert.wgsl
var AttributeColor_vert_default = { code: "fn attributeColor(outValue: ptr<function, vec4<f32>>) {\n  *outValue = a_color_0;\n}\n", shaderStage: "vertex", isFragmentShader: false };

// src/foundation/materials/nodes/AttributeColorShaderNode.ts
init_AbstractShaderNode();
var _AttributeColorShaderNode = class _AttributeColorShaderNode extends AbstractShaderNode {
  constructor() {
    super("attributeColor", {
      codeGLSL: AttributeColor_default.code,
      codeWGSL: AttributeColor_vert_default.code
    });
    this.setShaderStage("Vertex");
    this.__outputs.push({
      compositionType: CompositionType.Vec4,
      componentType: ComponentType.Float,
      name: "outValue"
    });
  }
};
__name(_AttributeColorShaderNode, "AttributeColorShaderNode");
var AttributeColorShaderNode = _AttributeColorShaderNode;

// src/foundation/materials/nodes/AttributeNormalShaderNode.ts
init_CompositionType();
init_ComponentType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/AttributeNormal.vert
var AttributeNormal_default = { code: "\nin vec3 a_normal;\n\nvoid attributeNormal(out vec3 outValue) {\n  outValue = a_normal;\n}\n", shaderStage: "vertex", isFragmentShader: false };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/AttributeNormal.vert.wgsl
var AttributeNormal_vert_default = { code: "fn attributeNormal(outValue: ptr<function, vec3<f32>>) {\n  *outValue = a_normal;\n}\n", shaderStage: "vertex", isFragmentShader: false };

// src/foundation/materials/nodes/AttributeNormalShaderNode.ts
init_AbstractShaderNode();
var _AttributeNormalShaderNode = class _AttributeNormalShaderNode extends AbstractShaderNode {
  constructor() {
    super("attributeNormal", {
      codeGLSL: AttributeNormal_default.code,
      codeWGSL: AttributeNormal_vert_default.code
    });
    this.setShaderStage("Vertex");
    this.__outputs.push({
      compositionType: CompositionType.Vec3,
      componentType: ComponentType.Float,
      name: "outValue"
    });
  }
};
__name(_AttributeNormalShaderNode, "AttributeNormalShaderNode");
var AttributeNormalShaderNode = _AttributeNormalShaderNode;

// src/foundation/materials/nodes/AttributePositionShaderNode.ts
init_CompositionType();
init_ComponentType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/AttributePosition.vert
var AttributePosition_default = { code: "\nin vec4 a_position;\n\nvoid attributePosition(out vec4 outValue) {\n  outValue = a_position;\n}\n", shaderStage: "vertex", isFragmentShader: false };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/AttributePosition.vert.wgsl
var AttributePosition_vert_default = { code: "fn attributePosition(outValue: ptr<function, vec4f>) {\n  *outValue = vec4f(a_position, 1.0);\n}\n", shaderStage: "vertex", isFragmentShader: false };

// src/foundation/materials/nodes/AttributePositionShaderNode.ts
init_AbstractShaderNode();
var _AttributePositionShaderNode = class _AttributePositionShaderNode extends AbstractShaderNode {
  constructor() {
    super("attributePosition", {
      codeGLSL: AttributePosition_default.code,
      codeWGSL: AttributePosition_vert_default.code
    });
    this.setShaderStage("Vertex");
    this.__outputs.push(new Socket("outValue", CompositionType.Vec4, ComponentType.Float));
  }
  getSocketOutput() {
    return this.__outputs[0];
  }
};
__name(_AttributePositionShaderNode, "AttributePositionShaderNode");
var AttributePositionShaderNode = _AttributePositionShaderNode;

// src/foundation/materials/nodes/AttributeTexcoordShaderNode.ts
init_CompositionType();
init_ComponentType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/AttributeTexcoord.vert
var AttributeTexcoord_default = { code: "\nin vec2 a_texcoord_0;\n\nvoid attributeTexcoord(out vec2 outValue) {\n  outValue = a_texcoord_0;\n}\n", shaderStage: "vertex", isFragmentShader: false };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/AttributeTexcoord.vert.wgsl
var AttributeTexcoord_vert_default = { code: "\nfn attributeTexcoord(outValue: ptr<function, vec2<f32>>) {\n  *outValue = a_texcoord_0;\n}\n", shaderStage: "vertex", isFragmentShader: false };

// src/foundation/materials/nodes/AttributeTexcoordShaderNode.ts
init_AbstractShaderNode();
var _AttributeTexcoordShaderNode = class _AttributeTexcoordShaderNode extends AbstractShaderNode {
  constructor() {
    super("attributeTexcoord", {
      codeGLSL: AttributeTexcoord_default.code,
      codeWGSL: AttributeTexcoord_vert_default.code
    });
    this.setShaderStage("Vertex");
    this.__outputs.push({
      compositionType: CompositionType.Vec3,
      componentType: ComponentType.Float,
      name: "outValue"
    });
  }
};
__name(_AttributeTexcoordShaderNode, "AttributeTexcoordShaderNode");
var AttributeTexcoordShaderNode = _AttributeTexcoordShaderNode;

// src/foundation/materials/nodes/WorldMatrixShaderNode.ts
init_CompositionType();
init_ComponentType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/WorldMatrix.vert
var WorldMatrix_default = { code: "\nvoid worldMatrix(out mat4 outValue) {\n  outValue = get_worldMatrix(a_instanceInfo.x);\n}\n", shaderStage: "vertex", isFragmentShader: false };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/WorldMatrix.vert.wgsl
var WorldMatrix_vert_default = { code: "\nfn worldMatrix(outValue: ptr<function, mat4x4<f32>>) {\n  *outValue = get_worldMatrix(u32(a_instanceIds.x));\n}\n", shaderStage: "vertex", isFragmentShader: false };

// src/foundation/materials/nodes/WorldMatrixShaderNode.ts
init_AbstractShaderNode();
var _WorldMatrixShaderNode = class _WorldMatrixShaderNode extends AbstractShaderNode {
  constructor() {
    super("worldMatrix", {
      codeGLSL: WorldMatrix_default.code,
      codeWGSL: WorldMatrix_vert_default.code
    });
    this.setShaderStage("Vertex");
    this.__outputs.push({
      compositionType: CompositionType.Mat4,
      componentType: ComponentType.Float,
      name: "outValue"
    });
  }
};
__name(_WorldMatrixShaderNode, "WorldMatrixShaderNode");
var WorldMatrixShaderNode = _WorldMatrixShaderNode;

// src/foundation/materials/nodes/ViewMatrixShaderNode.ts
init_CompositionType();
init_ComponentType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/ViewMatrix.vert
var ViewMatrix_default = { code: "\nvoid viewMatrix(out mat4 outValue) {\n  float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID}*/];\n  outValue = get_viewMatrix(cameraSID, 0);\n}\n", shaderStage: "vertex", isFragmentShader: false };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/ViewMatrix.vert.wgsl
var ViewMatrix_vert_default = { code: "\nfn viewMatrix(outValue: ptr<function, mat4x4<f32>>) {\n  *outValue = get_viewMatrix(_cameraSID, 0);\n}\n", shaderStage: "vertex", isFragmentShader: false };

// src/foundation/materials/nodes/ViewMatrixShaderNode.ts
init_AbstractShaderNode();
var _ViewMatrixShaderNode = class _ViewMatrixShaderNode extends AbstractShaderNode {
  constructor() {
    super("viewMatrix", {
      codeGLSL: ViewMatrix_default.code,
      codeWGSL: ViewMatrix_vert_default.code
    });
    this.setShaderStage("Vertex");
    this.__outputs.push({
      compositionType: CompositionType.Mat4,
      componentType: ComponentType.Float,
      name: "outValue"
    });
  }
};
__name(_ViewMatrixShaderNode, "ViewMatrixShaderNode");
var ViewMatrixShaderNode = _ViewMatrixShaderNode;

// src/foundation/materials/nodes/ProjectionMatrixShaderNode.ts
init_CompositionType();
init_ComponentType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/ProjectionMatrix.vert
var ProjectionMatrix_default = { code: "\nvoid projectionMatrix(out mat4 outValue) {\n  float cameraSID = u_currentComponentSIDs[/* shaderity: @{WellKnownComponentTIDs.CameraComponentTID}*/];\n  outValue = get_projectionMatrix(cameraSID, 0);\n}\n", shaderStage: "vertex", isFragmentShader: false };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/ProjectionMatrix.vert.wgsl
var ProjectionMatrix_vert_default = { code: "\nfn projectionMatrix(outValue: ptr<function, mat4x4<f32>>) {\n  *outValue = get_projectionMatrix(_cameraSID, 0);\n}\n", shaderStage: "vertex", isFragmentShader: false };

// src/foundation/materials/nodes/ProjectionMatrixShaderNode.ts
init_AbstractShaderNode();
var _ProjectionMatrixShaderNode = class _ProjectionMatrixShaderNode extends AbstractShaderNode {
  constructor() {
    super("projectionMatrix", {
      codeGLSL: ProjectionMatrix_default.code,
      codeWGSL: ProjectionMatrix_vert_default.code
    });
    this.setShaderStage("Vertex");
    this.__outputs.push({
      compositionType: CompositionType.Mat4,
      componentType: ComponentType.Float,
      name: "outValue"
    });
  }
};
__name(_ProjectionMatrixShaderNode, "ProjectionMatrixShaderNode");
var ProjectionMatrixShaderNode = _ProjectionMatrixShaderNode;

// src/foundation/materials/nodes/NormalMatrixShaderNode.ts
init_CompositionType();
init_ComponentType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/NormalMatrix.vert
var NormalMatrix_default = { code: "\nvoid normalMatrix(out mat3 outValue) {\n  outValue = get_normalMatrix(a_instanceInfo.x);\n}\n", shaderStage: "vertex", isFragmentShader: false };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/NormalMatrix.vert.wgsl
var NormalMatrix_vert_default = { code: "\nfn normalMatrix(outValue: ptr<function, mat3x3<f32>>) {\n  *outValue = get_normalMatrix(u32(a_instanceIds.x));\n}\n", shaderStage: "vertex", isFragmentShader: false };

// src/foundation/materials/nodes/NormalMatrixShaderNode.ts
init_AbstractShaderNode();
var _NormalMatrixShaderNode = class _NormalMatrixShaderNode extends AbstractShaderNode {
  constructor() {
    super("normalMatrix", {
      codeGLSL: NormalMatrix_default.code,
      codeWGSL: NormalMatrix_vert_default.code
    });
    this.setShaderStage("Vertex");
    this.__outputs.push({
      compositionType: CompositionType.Mat3,
      componentType: ComponentType.Float,
      name: "outValue"
    });
  }
};
__name(_NormalMatrixShaderNode, "NormalMatrixShaderNode");
var NormalMatrixShaderNode = _NormalMatrixShaderNode;

// src/foundation/materials/nodes/GreaterShaderNode.ts
init_AbstractShaderNode();
init_CompositionType();
init_ComponentType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/Greater.glsl
var Greater_default = { code: "\nvoid greater(in float lhs, in float rhs, out bool outValue) {\n  outValue = lhs > rhs;\n}\n\nvoid greater(in int lhs, in int rhs, out bool outValue) {\n  outValue = lhs > rhs;\n}\n", shaderStage: "fragment", isFragmentShader: true };

// src/foundation/materials/nodes/GreaterShaderNode.ts
var _GreaterShaderNode = class _GreaterShaderNode extends AbstractShaderNode {
  constructor(compositionType, componentType) {
    super("greater", {
      codeGLSL: Greater_default.code
    });
    this.__inputs.push({
      compositionType,
      componentType,
      name: "lhs"
    });
    this.__inputs.push({
      compositionType,
      componentType: ComponentType.Float,
      name: "rhs"
    });
    this.__outputs.push({
      compositionType: CompositionType.Scalar,
      componentType: ComponentType.Bool,
      name: "outValue"
    });
  }
};
__name(_GreaterShaderNode, "GreaterShaderNode");
var GreaterShaderNode = _GreaterShaderNode;

// src/foundation/materials/nodes/OutPositionShaderNode.ts
init_CompositionType();
init_ComponentType();

// src/webgl/shaders/nodes/EndShader.ts
init_CommonShaderPart();
init_ShaderNode();
init_ProcessApproach();
init_SystemState();
var _EndShader = class _EndShader extends CommonShaderPart {
  constructor() {
    super();
  }
  static getInstance() {
    if (!this.__instance) {
      this.__instance = new _EndShader();
    }
    return this.__instance;
  }
  get vertexShaderDefinitions() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      return `
      fn outPosition(inPosition: vec4<f32>) {
        output.position = inPosition;
      }
      `;
    } else {
      return `
      void outPosition(in vec4 inPosition) {
        gl_Position = inPosition;
      }
      `;
    }
  }
  get vertexShaderBody() {
    return `

    `;
  }
  get pixelShaderDefinitions() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      return `
      fn outColor(inColor: vec4<f32>) {
        rt0 = inColor;
      }
      `;
    } else {
      return `
      void outColor(in vec4 inColor) {
        rt0 = inColor;
      }
      `;
    }
  }
  getPixelShaderBody() {
    return "";
  }
  get attributeNames() {
    return [];
  }
  get attributeSemantics() {
    return [];
  }
  get attributeCompositions() {
    return [];
  }
};
__name(_EndShader, "EndShader");
__publicField(_EndShader, "__instance");
__publicField(_EndShader, "materialElement", ShaderNode.PBRShading);
var EndShader = _EndShader;

// src/foundation/materials/nodes/OutPositionShaderNode.ts
init_AbstractShaderNode();
var _OutPositionShaderNode = class _OutPositionShaderNode extends AbstractShaderNode {
  constructor() {
    super("outPosition", {
      commonPart: EndShader.getInstance()
    });
    this.__inputs.push(new Socket("value", CompositionType.Vec4, ComponentType.Float));
  }
  getSocketInput() {
    return this.__inputs[0];
  }
};
__name(_OutPositionShaderNode, "OutPositionShaderNode");
var OutPositionShaderNode = _OutPositionShaderNode;

// src/foundation/materials/nodes/OutColorShaderNode.ts
init_CompositionType();
init_ComponentType();
init_AbstractShaderNode();
var _OutColorShaderNode = class _OutColorShaderNode extends AbstractShaderNode {
  constructor() {
    super("outColor", {
      commonPart: EndShader.getInstance()
    });
    this.setShaderStage("Fragment");
    this.__inputs.push(new Socket("value", CompositionType.Vec4, ComponentType.Float));
  }
  getSocketInput() {
    return this.__inputs[0];
  }
};
__name(_OutColorShaderNode, "OutColorShaderNode");
var OutColorShaderNode = _OutColorShaderNode;

// src/foundation/materials/core/ShaderGraphResolver.ts
init_system();
init_ProcessApproach();

// src/foundation/materials/nodes/TransformShaderNode.ts
init_CompositionType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/Transform.glsl
var Transform_default = { code: "void transform(in mat2 lfs, in vec2 rhs, out vec2 outValue) {\n  outValue = lfs * rhs;\n}\nvoid transform(in mat3 lfs, in vec3 rhs, out vec3 outValue) {\n  outValue = lfs * rhs;\n}\nvoid transform(in mat4 lfs, in vec4 rhs, out vec4 outValue) {\n  outValue = lfs * rhs;\n}\n", shaderStage: "fragment", isFragmentShader: true };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/Transform.wgsl
var Transform_default2 = { code: "fn transformMat2x2fVec2f(lfs: mat2x2<f32>, rhs: vec2<f32>, outValue: ptr<function, vec2<f32>>) {\n  *outValue = lfs * rhs;\n}\nfn transformMat3x3fVec3f(lfs: mat3x3<f32>, rhs: vec3<f32>, outValue: ptr<function, vec3<f32>>) {\n  *outValue = lfs * rhs;\n}\nfn transformMat4x4fVec4f(lfs: mat4x4<f32>, rhs: vec4<f32>, outValue: ptr<function, vec4<f32>>) {\n  *outValue = lfs * rhs;\n}\n", shaderStage: "fragment", isFragmentShader: true };

// src/foundation/materials/nodes/TransformShaderNode.ts
init_AbstractShaderNode();
init_SystemState();
init_ProcessApproach();
var _TransformShaderNode = class _TransformShaderNode extends AbstractShaderNode {
  constructor(lhsCompositionType, lhsComponentType, rhsCompositionType, rhsComponentType) {
    super("transform", {
      codeGLSL: Transform_default.code,
      codeWGSL: Transform_default2.code
    });
    let outValueCompositionType = CompositionType.Unknown;
    if (lhsCompositionType === CompositionType.Mat4 && rhsCompositionType === CompositionType.Vec4) {
      outValueCompositionType = CompositionType.Vec4;
    } else if (lhsCompositionType === CompositionType.Mat3 && rhsCompositionType === CompositionType.Vec3) {
      outValueCompositionType = CompositionType.Vec3;
    } else if (lhsCompositionType === CompositionType.Mat2 && rhsCompositionType === CompositionType.Vec2) {
      outValueCompositionType = CompositionType.Vec2;
    }
    this.__inputs.push({
      compositionType: lhsCompositionType,
      componentType: lhsComponentType,
      name: "lhs"
    });
    this.__inputs.push({
      compositionType: rhsCompositionType,
      componentType: rhsComponentType,
      name: "rhs"
    });
    this.__outputs.push({
      compositionType: outValueCompositionType,
      componentType: lhsComponentType,
      name: "outValue"
    });
  }
  getShaderFunctionNameDerivative() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      if (this.__inputs[0].compositionType === CompositionType.Mat2 && this.__inputs[1].compositionType === CompositionType.Vec2) {
        return this.__shaderFunctionName + "Mat2x2fVec2f";
      } else if (this.__inputs[0].compositionType === CompositionType.Mat3 && this.__inputs[1].compositionType === CompositionType.Vec3) {
        return this.__shaderFunctionName + "Mat3x3fVec3f";
      } else if (this.__inputs[0].compositionType === CompositionType.Mat4 && this.__inputs[1].compositionType === CompositionType.Vec4) {
        return this.__shaderFunctionName + "Mat4x4fVec4f";
      } else {
        throw new Error("Not implemented");
      }
    } else {
      return this.__shaderFunctionName;
    }
  }
};
__name(_TransformShaderNode, "TransformShaderNode");
var TransformShaderNode = _TransformShaderNode;

// src/foundation/materials/nodes/BlockBeginShaderNode.ts
init_CompositionType();
init_ComponentType();

// src/webgl/shaders/nodes/BlockBeginShader.ts
init_CommonShaderPart();
var _BlockBeginShader = class _BlockBeginShader extends CommonShaderPart {
  constructor(__functionName, __valueInputs, __valueOutputs) {
    super();
    __publicField(this, "__functionName");
    __publicField(this, "__valueInputs");
    __publicField(this, "__valueOutputs");
    this.__functionName = __functionName;
    this.__valueInputs = __valueInputs;
    this.__valueOutputs = __valueOutputs;
  }
  get vertexShaderDefinitions() {
    let funcStr = `void ${this.__functionName}(
in bool context,
      `;
    for (let i2 = 0; i2 < this.__valueInputs.length; i2++) {
      const input = this.__valueInputs[i2];
      const type = input.compositionType.getGlslStr(input.componentType);
      funcStr += `
        in ${type} value${i2},`;
    }
    for (let i2 = 0; i2 < this.__valueOutputs.length; i2++) {
      const output = this.__valueOutputs[i2];
      const type = output.compositionType.getGlslStr(output.componentType);
      funcStr += `
        out ${type} outValue${i2}` + (i2 === this.__valueOutputs.length - 1 ? "" : ",");
    }
    funcStr += ") {\n";
    for (let i2 = 0; i2 < this.__valueOutputs.length; i2++) {
      funcStr += `
      outValue${i2} = value${i2};
`;
    }
    funcStr += "}";
    return funcStr;
  }
  get pixelShaderDefinitions() {
    return this.vertexShaderDefinitions;
  }
  get attributeNames() {
    return [];
  }
  get attributeSemantics() {
    return [];
  }
  get attributeCompositions() {
    return [];
  }
};
__name(_BlockBeginShader, "BlockBeginShader");
var BlockBeginShader = _BlockBeginShader;

// src/foundation/materials/nodes/BlockBeginShaderNode.ts
init_AbstractShaderNode();
var _BlockBeginShaderNode = class _BlockBeginShaderNode extends AbstractShaderNode {
  constructor() {
    super("blockBegin", {});
    __publicField(this, "__valueInputs", []);
    __publicField(this, "__valueOutputs", []);
    this.__shaderFunctionName += "_" + this.__shaderNodeUid;
    this.__commonPart = new BlockBeginShader(this.__shaderFunctionName, this.__valueInputs, this.__valueOutputs);
    this.__inputs.push({
      compositionType: CompositionType.Scalar,
      componentType: ComponentType.Bool,
      name: "blockStart"
    });
  }
  addInputAndOutput(compositionType, componentType) {
    const input = {
      compositionType,
      componentType,
      name: `value_${this.__valueInputs.length}`
    };
    const output = {
      compositionType,
      componentType,
      name: `outValue_${this.__valueOutputs.length}`
    };
    this.__inputs.push(input);
    this.__outputs.push(output);
    this.__valueInputs.push(input);
    this.__valueOutputs.push(output);
  }
};
__name(_BlockBeginShaderNode, "BlockBeginShaderNode");
var BlockBeginShaderNode = _BlockBeginShaderNode;

// src/foundation/materials/nodes/BlockEndShaderNode.ts
init_AbstractShaderNode();

// src/webgl/shaders/nodes/BlockEndShader.ts
init_CommonShaderPart();
var _BlockEndShader = class _BlockEndShader extends CommonShaderPart {
  constructor(__functionName, __valueInputs, __valueOutputs) {
    super();
    __publicField(this, "__functionName");
    __publicField(this, "__valueInputs");
    __publicField(this, "__valueOutputs");
    this.__functionName = __functionName;
    this.__valueInputs = __valueInputs;
    this.__valueOutputs = __valueOutputs;
  }
  get vertexShaderDefinitions() {
    let funcStr = `void ${this.__functionName}(`;
    for (let i2 = 0; i2 < this.__valueInputs.length; i2++) {
      const input = this.__valueInputs[i2];
      const type = input.compositionType.getGlslStr(input.componentType);
      funcStr += `
        in ${type} value${i2},`;
    }
    for (let i2 = 0; i2 < this.__valueOutputs.length; i2++) {
      const output = this.__valueOutputs[i2];
      const type = output.compositionType.getGlslStr(output.componentType);
      funcStr += `
        out ${type} outValue${i2}` + (i2 === this.__valueOutputs.length - 1 ? "" : ",");
    }
    funcStr += ") {\n";
    for (let i2 = 0; i2 < this.__valueOutputs.length; i2++) {
      funcStr += `
      outValue${i2} = value${i2};
`;
    }
    funcStr += "}";
    return funcStr;
  }
  get pixelShaderDefinitions() {
    return this.vertexShaderDefinitions;
  }
  get attributeNames() {
    return [];
  }
  get attributeSemantics() {
    return [];
  }
  get attributeCompositions() {
    return [];
  }
};
__name(_BlockEndShader, "BlockEndShader");
var BlockEndShader = _BlockEndShader;

// src/foundation/materials/nodes/BlockEndShaderNode.ts
var _BlockEndShaderNode = class _BlockEndShaderNode extends AbstractShaderNode {
  constructor() {
    super("blockEnd", {});
    this.__shaderFunctionName += "_" + this.__shaderNodeUid;
    this.__commonPart = new BlockEndShader(this.__shaderFunctionName, this.__inputs, this.__outputs);
  }
  addInputAndOutput(compositionType, componentType) {
    const input = {
      compositionType,
      componentType,
      name: `value_${this.__inputs.length}`
    };
    const output = {
      compositionType,
      componentType,
      name: `outValue_${this.__outputs.length}`
    };
    this.__inputs.push(input);
    this.__outputs.push(output);
  }
};
__name(_BlockEndShaderNode, "BlockEndShaderNode");
var BlockEndShaderNode = _BlockEndShaderNode;

// src/foundation/materials/nodes/IfStatementShaderNode.ts
init_CompositionType();
init_ComponentType();

// src/webgl/shaders/nodes/IfStatementShader.ts
init_CommonShaderPart();
var _IfStatementShader = class _IfStatementShader extends CommonShaderPart {
  constructor() {
    super();
  }
  get vertexShaderDefinitions() {
    return `
    `;
  }
  get pixelShaderDefinitions() {
    return `
    `;
  }
  get attributeNames() {
    return [];
  }
  get attributeSemantics() {
    return [];
  }
  get attributeCompositions() {
    return [];
  }
};
__name(_IfStatementShader, "IfStatementShader");
var IfStatementShader = _IfStatementShader;

// src/foundation/materials/nodes/IfStatementShaderNode.ts
init_AbstractShaderNode();
var _IfStatementShaderNode = class _IfStatementShaderNode extends AbstractShaderNode {
  constructor() {
    super("ifStatement", {
      commonPart: new IfStatementShader()
    });
    this.__inputs.push({
      compositionType: CompositionType.Scalar,
      componentType: ComponentType.Bool,
      name: "condition"
    });
    this.__outputs.push({
      compositionType: CompositionType.Unknown,
      componentType: ComponentType.Unknown,
      name: "ifStart"
    });
  }
};
__name(_IfStatementShaderNode, "IfStatementShaderNode");
var IfStatementShaderNode = _IfStatementShaderNode;

// src/foundation/materials/nodes/WireframeMaterialNode.ts
init_CompositionType();
init_ComponentType();
init_AbstractShaderNode();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/Wireframe.glsl
var Wireframe_default = { code: "bool wireframe(\n  in vec4 existingFragColor,\n  in vec4 wireframeColor,\n  out vec4 outColor\n) {\n  vec3 wireframeInfo = get_wireframe(a_instanceInfo.x);\n\n  // Wireframe\n  float threshold = 0.001;\n  float wireframeWidthInner = wireframeInfo.z;\n  float wireframeWidthRelativeScale = 1.0;\n  if (wireframeInfo.x > 0.5 && wireframeInfo.y < 0.5) {\n    outColor.a = 0.0;\n  }\n  vec4 wireframeResult = existingFragColor;\n  float edgeRatio = edge_ratio(v_baryCentricCoord, wireframeWidthInner, wireframeWidthRelativeScale);\n  float edgeRatioModified = mix(step(threshold, edgeRatio), clamp(edgeRatio*4.0, 0.0, 1.0), wireframeWidthInner / wireframeWidthRelativeScale/4.0);\n  // if r0.a is 0.0, it is wireframe not on shaded\n  wireframeResult.rgb = wireframeColor.rgb * edgeRatioModified + existingFragColor.rgb * (1.0 - edgeRatioModified);\n  wireframeResult.a = max(existingFragColor.a, wireframeColor.a * mix(edgeRatioModified, pow(edgeRatioModified, 100.0), wireframeWidthInner / wireframeWidthRelativeScale/1.0));\n\n  if (wireframeInfo.x > 0.5) {\n    outColor = wireframeResult;\n    if (wireframeInfo.y < 0.5 && existingFragColor.a == 0.0) {\n      discard;\n    }\n  }\n}\n", shaderStage: "fragment", isFragmentShader: true };

// src/foundation/materials/nodes/WireframeMaterialNode.ts
var _WireframeMaterialNode = class _WireframeMaterialNode extends AbstractShaderNode {
  constructor() {
    super("wireframe", {
      codeGLSL: Wireframe_default.code
    });
    this.__inputs.push({
      compositionType: CompositionType.Vec4,
      componentType: ComponentType.Float,
      name: "existingFragColor"
    });
    this.__inputs.push({
      compositionType: CompositionType.Vec4,
      componentType: ComponentType.Float,
      name: "wireframeColor"
    });
    this.__outputs.push({
      compositionType: CompositionType.Vec4,
      componentType: ComponentType.Float,
      name: "outColor"
    });
  }
};
__name(_WireframeMaterialNode, "WireframeMaterialNode");
var WireframeMaterialNode = _WireframeMaterialNode;

// src/foundation/materials/nodes/SplitVectorShaderNode.ts
init_ComponentType();
init_CompositionType();
init_AbstractShaderNode();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/SplitVector.glsl
var SplitVector_default = { code: "void splitVector(in vec4 xyzw, out vec3 outXYZ, out vec2 outXY, out vec2 outZW, out float outX, out float outY, out float outZ, out float outW) {\n  outX = xyzw.x;\n  outY = xyzw.y;\n  outZ = xyzw.z;\n  outW = xyzw.w;\n  outXYZ = xyzw.xyz;\n  outXY = xyzw.xy;\n  outZW = xyzw.zw;\n}\n\nvoid splitVector(in vec3 xyz, out vec3 outXYZ, out vec2 outXY, out vec2 outZW, out float outX, out float outY, out float outZ, out float outW) {\n  outX = xyz.x;\n  outY = xyz.y;\n  outZ = xyz.z;\n  outW = 0.0;\n  outXYZ = xyz;\n  outXY = xyz.xy;\n  outZW = vec2(xyz.z, 0.0);\n}\n\nvoid splitVector(in vec2 xy, out vec3 outXYZ, out vec2 outXY, out vec2 outZW, out float outX, out float outY, out float outZ, out float outW) {\n  outX = xy.x;\n  outY = xy.y;\n  outZ = 0.0;\n  outW = 0.0;\n  outXYZ = vec3(xy, 0.0);\n  outXY = xy;\n  outZW = vec2(0.0);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/SplitVector.wgsl
var SplitVector_default2 = { code: "fn splitVectorXYZW(xyzw: vec4<f32>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>, outX: ptr<function, f32>, outY: ptr<function, f32>, outZ: ptr<function, f32>, outW: ptr<function, f32>) {\n  *outX = xyzw.x;\n  *outY = xyzw.y;\n  *outZ = xyzw.z;\n  *outW = xyzw.w;\n  *outXYZ = xyzw.xyz;\n  *outXY = xyzw.xy;\n  *outZW = xyzw.zw;\n}\n\nfn splitVectorXYZ(xyz: vec3<f32>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>, outX: ptr<function, f32>, outY: ptr<function, f32>, outZ: ptr<function, f32>, outW: ptr<function, f32>) {\n  *outX = xyz.x;\n  *outY = xyz.y;\n  *outZ = xyz.z;\n  *outW = 0.0;\n  *outXYZ = xyz;\n  *outXY = xyz.xy;\n  *outZW = vec2(xyz.z, 0.0);\n}\n\nfn splitVectorXY(xy: vec2<f32>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>, outX: ptr<function, f32>, outY: ptr<function, f32>, outZ: ptr<function, f32>, outW: ptr<function, f32>) {\n  *outX = xy.x;\n  *outY = xy.y;\n  *outZ = 0.0;\n  *outW = 0.0;\n  *outXYZ = vec3(xy, 0.0);\n  *outXY = xy;\n  *outZW = vec2(0.0);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// src/foundation/materials/nodes/SplitVectorShaderNode.ts
init_SystemState();
init_ProcessApproach();
var _SplitVectorShaderNode = class _SplitVectorShaderNode extends AbstractShaderNode {
  constructor() {
    super("splitVector", {
      codeGLSL: SplitVector_default.code,
      codeWGSL: SplitVector_default2.code
    });
    this.__inputs.push({
      compositionType: CompositionType.Vec4,
      componentType: ComponentType.Float,
      name: "xyzw"
    });
    this.__inputs.push({
      compositionType: CompositionType.Vec3,
      componentType: ComponentType.Float,
      name: "xyz"
    });
    this.__inputs.push({
      compositionType: CompositionType.Vec2,
      componentType: ComponentType.Float,
      name: "xy"
    });
    this.__outputs.push({
      compositionType: CompositionType.Vec3,
      componentType: ComponentType.Float,
      name: "xyz"
    });
    this.__outputs.push({
      compositionType: CompositionType.Vec2,
      componentType: ComponentType.Float,
      name: "xy"
    });
    this.__outputs.push({
      compositionType: CompositionType.Vec2,
      componentType: ComponentType.Float,
      name: "zw"
    });
    this.__outputs.push({
      compositionType: CompositionType.Scalar,
      componentType: ComponentType.Float,
      name: "x"
    });
    this.__outputs.push({
      compositionType: CompositionType.Scalar,
      componentType: ComponentType.Float,
      name: "y"
    });
    this.__outputs.push({
      compositionType: CompositionType.Scalar,
      componentType: ComponentType.Float,
      name: "z"
    });
    this.__outputs.push({
      compositionType: CompositionType.Scalar,
      componentType: ComponentType.Float,
      name: "w"
    });
  }
  getShaderFunctionNameDerivative() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      for (const inputConnection of this.inputConnections) {
        if (inputConnection != null) {
          if (inputConnection.inputNameOfThis === "xyzw") {
            return this.__shaderFunctionName + "XYZW";
          } else if (inputConnection.inputNameOfThis === "xyz") {
            return this.__shaderFunctionName + "XYZ";
          } else if (inputConnection.inputNameOfThis === "xy") {
            return this.__shaderFunctionName + "XY";
          }
        }
      }
      throw new Error("Not implemented");
    } else {
      return this.__shaderFunctionName;
    }
  }
  makeCallStatement(i2, shaderNode, functionName, varInputNames, varOutputNames) {
    let str = "";
    let rowStr = "";
    if (varInputNames[i2].length > 0 && varOutputNames[i2].length > 0) {
      const dummyOutputVarDefines = SystemState.currentProcessApproach === ProcessApproach.WebGPU ? [
        `var dummyXYZ_${i2}: vec3<f32>;`,
        `var dummyXY_${i2}: vec2<f32>;`,
        `var dummyZW_${i2}: vec2<f32>;`,
        `var dummyX_${i2}: f32;`,
        `var dummyY_${i2}: f32;`,
        `var dummyZ_${i2}: f32;`,
        `var dummyW_${i2}: f32;`
      ] : [
        `vec3 dummyXYZ_${i2};`,
        `vec2 dummyXY_${i2};`,
        `vec2 dummyZW_${i2};`,
        `float dummyX_${i2};`,
        `float dummyY_${i2};`,
        `float dummyZ_${i2};`,
        `float dummyW_${i2};`
      ];
      const dummyOutputArguments = [
        `dummyXYZ_${i2}`,
        `dummyXY_${i2}`,
        `dummyZW_${i2}`,
        `dummyX_${i2}`,
        `dummyY_${i2}`,
        `dummyZ_${i2}`,
        `dummyW_${i2}`
      ];
      for (let k = 0; k < varOutputNames[i2].length; k++) {
        const outputName = varOutputNames[i2][k];
        if (outputName.indexOf("xyz") >= 0) {
          dummyOutputVarDefines[0] = "";
          dummyOutputArguments[0] = outputName;
        } else if (outputName.indexOf("xy") >= 0) {
          dummyOutputVarDefines[1] = "";
          dummyOutputArguments[1] = outputName;
        } else if (outputName.indexOf("zw") >= 0) {
          dummyOutputVarDefines[2] = "";
          dummyOutputArguments[2] = outputName;
        } else if (outputName.indexOf("x") >= 0) {
          dummyOutputVarDefines[3] = "";
          dummyOutputArguments[3] = outputName;
        } else if (outputName.indexOf("y") >= 0) {
          dummyOutputVarDefines[4] = "";
          dummyOutputArguments[4] = outputName;
        } else if (outputName.indexOf("z") >= 0) {
          dummyOutputVarDefines[5] = "";
          dummyOutputArguments[5] = outputName;
        } else if (outputName.indexOf("w") >= 0) {
          dummyOutputVarDefines[6] = "";
          dummyOutputArguments[6] = outputName;
        }
      }
      if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
        for (let i3 = 0; i3 < dummyOutputArguments.length; i3++) {
          dummyOutputArguments[i3] = "&" + dummyOutputArguments[i3];
        }
      }
      rowStr += dummyOutputVarDefines.join("\n");
      rowStr += `${functionName}(`;
      const inputName = varInputNames[i2][0];
      rowStr += inputName;
      rowStr += ", " + dummyOutputArguments.join(", ");
      rowStr += ");\n";
    }
    str += rowStr;
    return str;
  }
};
__name(_SplitVectorShaderNode, "SplitVectorShaderNode");
var SplitVectorShaderNode = _SplitVectorShaderNode;

// src/foundation/materials/nodes/MergeVectorShaderNode.ts
init_ComponentType();
init_CompositionType();
init_AbstractShaderNode();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/MergeVector.glsl
var MergeVector_default = { code: "void mergeVectorXYZ_W(in vec3 xyz, in float w, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {\n  outXYZW.x = xyz.x;\n  outXYZW.y = xyz.y;\n  outXYZW.z = xyz.z;\n  outXYZW.w = w;\n  outXYZ = xyz;\n  outXY = xyz.xy;\n  outZW = vec2(xyz.z, w);\n}\n\nvoid mergeVectorXY_ZW(in vec2 xy, in vec2 zw, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {\n  outXYZW.x = xy.x;\n  outXYZW.y = xy.y;\n  outXYZW.z = zw.x;\n  outXYZW.w = zw.y;\n  outXYZ = vec3(xy, zw.x);\n  outXY = xy;\n  outZW = zw;\n}\n\nvoid mergeVectorXY_Z_W(in vec2 xy, in float z, in float w, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {\n  outXYZW.x = xy.x;\n  outXYZW.y = xy.y;\n  outXYZW.z = z;\n  outXYZW.w = w;\n  outXYZ = vec3(xy, z);\n  outXY = xy;\n  outZW = vec2(z, w);\n}\n\nvoid mergeVectorZW_X_Y(in vec2 zw, in float x, in float y, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {\n  outXYZW.x = x;\n  outXYZW.y = y;\n  outXYZW.z = zw.x;\n  outXYZW.w = zw.y;\n  outXYZ = vec3(x, y, zw.x);\n  outXY = vec2(x, y);\n  outZW = zw;\n}\n\nvoid mergeVectorX_Y_Z_W(in float x, in float y, in float z, in float w, out vec4 outXYZW, out vec3 outXYZ, out vec2 outXY, out vec2 outZW) {\n  outXYZW.x = x;\n  outXYZW.y = y;\n  outXYZW.z = z;\n  outXYZW.w = w;\n  outXYZ = vec3(x, y, z);\n  outXY = vec2(x, y);\n  outZW = vec2(z, w);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/MergeVector.wgsl
var MergeVector_default2 = { code: "fn mergeVectorXYZ_W(xyz: vec3<f32>, w: f32, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {\n  *outXYZW = vec4<f32>(xyz, w);\n  *outXYZ = xyz;\n  *outXY = xyz.xy;\n  *outZW = vec2f(xyz.z, w);\n}\n\nfn mergeVectorXY_ZW(xy: vec2<f32>, zw: vec2<f32>, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {\n  *outXYZW = vec4<f32>(xy, zw);\n  *outXYZ = vec3f(xy, zw.x);\n  *outXY = xy;\n  *outZW = zw;\n}\n\nfn mergeVectorXY_Z_W(xy: vec2<f32>, z: f32, w: f32, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {\n  *outXYZW = vec4<f32>(xy.x, xy.y, z, w);\n  *outXYZ = vec3f(xy, z);\n  *outXY = xy;\n  *outZW = vec2f(z, w);\n}\n\nfn mergeVectorZW_X_Y(zw: vec2<f32>, x: f32, y: f32, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {\n  *outXYZW = vec4<f32>(x, y, zw.x, zw.y);\n  *outXYZ = vec3f(x, y, zw.x);\n  *outXY = vec2f(x, y);\n  *outZW = zw;\n}\n\nfn mergeVectorX_Y_Z_W(x: f32, y: f32, z: f32, w: f32, outXYZW: ptr<function, vec4<f32>>, outXYZ: ptr<function, vec3<f32>>, outXY: ptr<function, vec2<f32>>, outZW: ptr<function, vec2<f32>>) {\n  *outXYZW = vec4<f32>(x, y, z, w);\n  *outXYZ = vec3f(x, y, z);\n  *outXY = vec2f(x, y);\n  *outZW = vec2f(z, w);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// src/foundation/materials/nodes/MergeVectorShaderNode.ts
init_SystemState();
init_ProcessApproach();
var _MergeVectorShaderNode = class _MergeVectorShaderNode extends AbstractShaderNode {
  constructor() {
    super("mergeVector", {
      codeGLSL: MergeVector_default.code,
      codeWGSL: MergeVector_default2.code
    });
    this.__inputs.push({
      compositionType: CompositionType.Vec3,
      componentType: ComponentType.Float,
      name: "xyz"
    });
    this.__inputs.push({
      compositionType: CompositionType.Vec2,
      componentType: ComponentType.Float,
      name: "xy"
    });
    this.__inputs.push({
      compositionType: CompositionType.Vec2,
      componentType: ComponentType.Float,
      name: "zw"
    });
    this.__inputs.push({
      compositionType: CompositionType.Scalar,
      componentType: ComponentType.Float,
      name: "x"
    });
    this.__inputs.push({
      compositionType: CompositionType.Scalar,
      componentType: ComponentType.Float,
      name: "y"
    });
    this.__inputs.push({
      compositionType: CompositionType.Scalar,
      componentType: ComponentType.Float,
      name: "z"
    });
    this.__inputs.push({
      compositionType: CompositionType.Scalar,
      componentType: ComponentType.Float,
      name: "w"
    });
    this.__outputs.push({
      compositionType: CompositionType.Vec4,
      componentType: ComponentType.Float,
      name: "xyzw"
    });
    this.__outputs.push({
      compositionType: CompositionType.Vec3,
      componentType: ComponentType.Float,
      name: "xyz"
    });
    this.__outputs.push({
      compositionType: CompositionType.Vec2,
      componentType: ComponentType.Float,
      name: "xy"
    });
    this.__outputs.push({
      compositionType: CompositionType.Vec2,
      componentType: ComponentType.Float,
      name: "zw"
    });
  }
  getShaderFunctionNameDerivative() {
    if (this.inputConnections[0] != null && this.inputConnections[6] != null) {
      return this.__shaderFunctionName + "XYZ_W";
    } else if (this.inputConnections[1] != null && this.inputConnections[2] != null) {
      return this.__shaderFunctionName + "XY_ZW";
    } else if (this.inputConnections[1] != null && this.inputConnections[5] != null && this.inputConnections[6] != null) {
      return this.__shaderFunctionName + "XY_Z_W";
    } else if (this.inputConnections[2] != null && this.inputConnections[3] != null && this.inputConnections[4] != null) {
      return this.__shaderFunctionName + "ZW_X_Y";
    } else if (this.inputConnections[3] != null && this.inputConnections[4] != null && this.inputConnections[5] != null && this.inputConnections[6] != null) {
      return this.__shaderFunctionName + "X_Y_Z_W";
    }
    throw new Error("Not implemented");
  }
  makeCallStatement(i2, shaderNode, functionName, varInputNames, varOutputNames) {
    let str = "";
    let rowStr = "";
    if (varInputNames[i2].length > 0 && varOutputNames[i2].length > 0) {
      const dummyOutputVarDefines = SystemState.currentProcessApproach === ProcessApproach.WebGPU ? [
        `var dummyXYZW_${i2}: vec4<f32>;`,
        `var dummyXYZ_${i2}: vec3<f32>;`,
        `var dummyXY_${i2}: vec2<f32>;`,
        `var dummyZW_${i2}: vec2<f32>;`
      ] : [
        `vec4 dummyXYZW_${i2};`,
        `vec3 dummyXYZ_${i2};`,
        `vec2 dummyXY_${i2};`,
        `vec2 dummyZW_${i2};`
      ];
      const dummyOutputArguments = [
        `dummyXYZW_${i2}`,
        `dummyXYZ_${i2}`,
        `dummyXY_${i2}`,
        `dummyZW_${i2}`
      ];
      for (let k = 0; k < varOutputNames[i2].length; k++) {
        const outputName = varOutputNames[i2][k];
        if (outputName.indexOf("xyzw") >= 0) {
          dummyOutputVarDefines[0] = "";
          dummyOutputArguments[0] = outputName;
        } else if (outputName.indexOf("xyz") >= 0) {
          dummyOutputVarDefines[1] = "";
          dummyOutputArguments[1] = outputName;
        } else if (outputName.indexOf("xy") >= 0) {
          dummyOutputVarDefines[2] = "";
          dummyOutputArguments[2] = outputName;
        } else if (outputName.indexOf("zw") >= 0) {
          dummyOutputVarDefines[3] = "";
          dummyOutputArguments[3] = outputName;
        }
      }
      if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
        for (let i3 = 0; i3 < dummyOutputArguments.length; i3++) {
          dummyOutputArguments[i3] = "&" + dummyOutputArguments[i3];
        }
      }
      rowStr += dummyOutputVarDefines.join("\n");
      rowStr += `${functionName}(`;
      for (let k = 0; k < varInputNames[i2].length; k++) {
        if (k !== 0) {
          rowStr += ", ";
        }
        const inputName = varInputNames[i2][k];
        rowStr += inputName;
      }
      rowStr += ", " + dummyOutputArguments.join(", ");
      rowStr += ");\n";
    }
    str += rowStr;
    return str;
  }
};
__name(_MergeVectorShaderNode, "MergeVectorShaderNode");
var MergeVectorShaderNode = _MergeVectorShaderNode;

// src/foundation/materials/nodes/SinShaderNode.ts
init_AbstractShaderNode();
init_CompositionType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/Sin.glsl
var Sin_default = { code: "void _sin(in float value, out float outValue) {\n  outValue = sin(value);\n}\nvoid _sin(in vec2 value, out vec2 outValue) {\n  outValue = sin(value);\n}\nvoid _sin(in vec3 value, out vec3 outValue) {\n  outValue = sin(value);\n}\nvoid _sin(in vec4 value, out vec4 outValue) {\n  outValue = sin(value);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/Sin.wgsl
var Sin_default2 = { code: "fn _sinF32(value: f32, outValue: ptr<function, f32>) {\n  *outValue = sin(value);\n}\nfn _sinVec2f(value: vec2<f32>, outValue: ptr<function, vec2<f32>>) {\n  *outValue = sin(value);\n}\nfn _sinVec3f(value: vec3<f32>, outValue: ptr<function, vec3<f32>>) {\n  *outValue = sin(value);\n}\nfn _sinVec4f(value: vec4<f32>, outValue: ptr<function, vec4<f32>>) {\n  *outValue = sin(value);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// src/foundation/materials/nodes/SinShaderNode.ts
init_ProcessApproach();
init_SystemState();
var _SinShaderNode = class _SinShaderNode extends AbstractShaderNode {
  constructor(compositionType, componentType) {
    super("_sin", {
      codeGLSL: Sin_default.code,
      codeWGSL: Sin_default2.code
    });
    this.__inputs.push(new Socket("value", compositionType, componentType));
    this.__outputs.push(new Socket("outValue", compositionType, componentType));
  }
  getSocketInputValue() {
    return this.__inputs[0];
  }
  getSocketOutput() {
    return this.__outputs[0];
  }
  getShaderFunctionNameDerivative() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      if (this.__inputs[0].compositionType === CompositionType.Scalar) {
        return this.__shaderFunctionName + "F32";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec2) {
        return this.__shaderFunctionName + "Vec2f";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec3) {
        return this.__shaderFunctionName + "Vec3f";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec4) {
        return this.__shaderFunctionName + "Vec4f";
      } else {
        throw new Error("Not implemented");
      }
    } else {
      return this.__shaderFunctionName;
    }
  }
};
__name(_SinShaderNode, "SinShaderNode");
var SinShaderNode = _SinShaderNode;

// src/foundation/materials/nodes/StepShaderNode.ts
init_AbstractShaderNode();
init_CompositionType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/Step.glsl
var Step_default = { code: "void _step(in float value, in float edge, out float outValue) {\n  outValue = step(edge, value);\n}\nvoid _step(in vec2 value, in vec2 edge, out vec2 outValue) {\n  outValue = step(edge, value);\n}\nvoid _step(in vec3 value, in vec3 edge, out vec3 outValue) {\n  outValue = step(edge, value);\n}\nvoid _step(in vec4 value, in vec4 edge, out vec4 outValue) {\n  outValue = step(edge, value);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/Step.wgsl
var Step_default2 = { code: "fn _stepF32(value: f32, edge: f32, outValue: ptr<function, f32>) {\n  *outValue = step(edge, value);\n}\nfn _stepVec2f(value: vec2<f32>, edge: vec2<f32>, outValue: ptr<function, vec2<f32>>) {\n  *outValue = step(edge, value);\n}\nfn _stepVec3f(value: vec3<f32>, edge: vec3<f32>, outValue: ptr<function, vec3<f32>>) {\n  *outValue = step(edge, value);\n}\nfn _stepVec4f(value: vec4<f32>, edge: vec4<f32>, outValue: ptr<function, vec4<f32>>) {\n  *outValue = step(edge, value);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// src/foundation/materials/nodes/StepShaderNode.ts
init_ProcessApproach();
init_SystemState();
var _StepShaderNode = class _StepShaderNode extends AbstractShaderNode {
  constructor(compositionType, componentType) {
    super("_step", {
      codeGLSL: Step_default.code,
      codeWGSL: Step_default2.code
    });
    this.__inputs.push(new Socket("value", compositionType, componentType));
    this.__inputs.push(new Socket("edge", compositionType, componentType));
    this.__outputs.push(new Socket("outValue", compositionType, componentType));
  }
  getSocketInputValue() {
    return this.__inputs[0];
  }
  getSocketOutput() {
    return this.__outputs[0];
  }
  getShaderFunctionNameDerivative() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      if (this.__inputs[0].compositionType === CompositionType.Scalar) {
        return this.__shaderFunctionName + "F32";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec2) {
        return this.__shaderFunctionName + "Vec2f";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec3) {
        return this.__shaderFunctionName + "Vec3f";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec4) {
        return this.__shaderFunctionName + "Vec4f";
      } else {
        throw new Error("Not implemented");
      }
    } else {
      return this.__shaderFunctionName;
    }
  }
};
__name(_StepShaderNode, "StepShaderNode");
var StepShaderNode = _StepShaderNode;

// src/foundation/materials/nodes/TimeShaderNode.ts
init_CompositionType();
init_ComponentType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/Time.glsl
var Time_default = { code: "\nvoid time(out float outValue) {\n  outValue = get_time(0.0, 0);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/Time.wgsl
var Time_default2 = { code: "fn time(outValue: ptr<function, f32>) {\n  *outValue = get_time(0, 0);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// src/foundation/materials/nodes/TimeShaderNode.ts
init_AbstractShaderNode();
var _TimeShaderNode = class _TimeShaderNode extends AbstractShaderNode {
  constructor() {
    super("time", {
      codeGLSL: Time_default.code,
      codeWGSL: Time_default2.code
    });
    this.__outputs.push({
      compositionType: CompositionType.Scalar,
      componentType: ComponentType.Float,
      name: "outValue"
    });
  }
};
__name(_TimeShaderNode, "TimeShaderNode");
var TimeShaderNode = _TimeShaderNode;

// src/foundation/materials/nodes/SmoothStepShaderNode.ts
init_AbstractShaderNode();
init_CompositionType();

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgl/shaderity_shaders/nodes/SmoothStep.glsl
var SmoothStep_default = { code: "void _smoothstep(in float value, in float edge0, in float edge1, out float outValue) {\n  outValue = smoothstep(edge0, edge1, value);\n}\nvoid _smoothstep(in vec2 value, in vec2 edge0, in vec2 edge1, out vec2 outValue) {\n  outValue = smoothstep(edge0, edge1, value);\n}\nvoid _smoothstep(in vec3 value, in vec3 edge0, in vec3 edge1, out vec3 outValue) {\n  outValue = smoothstep(edge0, edge1, value);\n}\nvoid _smoothstep(in vec4 value, in vec4 edge0, in vec4 edge1, out vec4 outValue) {\n  outValue = smoothstep(edge0, edge1, value);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// shaderity:/Users/emadurandal/ghq/github.com/actnwit/RhodoniteEditor2/submodules/RhodoniteTS/src/webgpu/shaderity_shaders/nodes/SmoothStep.wgsl
var SmoothStep_default2 = { code: "fn _smoothstepF32(value: f32, edge0: f32, edge1: f32, outValue: ptr<function, f32>) {\n  *outValue = smoothstep(edge0, edge1, value);\n}\nfn _smoothstepVec2f(value: vec2<f32>, edge0: vec2<f32>, edge1: vec2<f32>, outValue: ptr<function, vec2<f32>>) {\n  *outValue = smoothstep(edge0, edge1, value);\n}\nfn _smoothstepVec3f(value: vec3<f32>, edge0: vec3<f32>, edge1: vec3<f32>, outValue: ptr<function, vec3<f32>>) {\n  *outValue = smoothstep(edge0, edge1, value);\n}\nfn _smoothstepVec4f(value: vec4<f32>, edge0: vec4<f32>, edge1: vec4<f32>, outValue: ptr<function, vec4<f32>>) {\n  *outValue = smoothstep(edge0, edge1, value);\n}\n", shaderStage: "fragment", isFragmentShader: true };

// src/foundation/materials/nodes/SmoothStepShaderNode.ts
init_ProcessApproach();
init_SystemState();
var _SmoothStepShaderNode = class _SmoothStepShaderNode extends AbstractShaderNode {
  constructor(compositionType, componentType) {
    super("_smoothstep", {
      codeGLSL: SmoothStep_default.code,
      codeWGSL: SmoothStep_default2.code
    });
    this.__inputs.push(new Socket("value", compositionType, componentType));
    this.__inputs.push(new Socket("edge0", compositionType, componentType));
    this.__inputs.push(new Socket("edge1", compositionType, componentType));
    this.__outputs.push(new Socket("outValue", compositionType, componentType));
  }
  getSocketInputValue() {
    return this.__inputs[0];
  }
  getSocketOutput() {
    return this.__outputs[0];
  }
  getShaderFunctionNameDerivative() {
    if (SystemState.currentProcessApproach === ProcessApproach.WebGPU) {
      if (this.__inputs[0].compositionType === CompositionType.Scalar) {
        return this.__shaderFunctionName + "F32";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec2) {
        return this.__shaderFunctionName + "Vec2f";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec3) {
        return this.__shaderFunctionName + "Vec3f";
      } else if (this.__inputs[0].compositionType === CompositionType.Vec4) {
        return this.__shaderFunctionName + "Vec4f";
      } else {
        throw new Error("Not implemented");
      }
    } else {
      return this.__shaderFunctionName;
    }
  }
};
__name(_SmoothStepShaderNode, "SmoothStepShaderNode");
var SmoothStepShaderNode = _SmoothStepShaderNode;

// src/foundation/materials/core/ShaderGraphResolver.ts
init_Logger();
var _ShaderGraphResolver = class _ShaderGraphResolver {
  /**
  * Create a vertex shader code from the given vertex nodes.
  * @param vertexNodes - Vertex nodes
  * @param varyingNodes - Varying nodes
  * @param isFullVersion - Whether to generate a full version of the shader code
  * @returns Vertex shader code
  */
  static createVertexShaderCode(vertexNodes, varyingNodes, isFullVersion = true) {
    const shaderNodes = vertexNodes.concat();
    const sortedShaderNodes = this.__sortTopologically(shaderNodes);
    let vertexShaderPrerequisites = "";
    const nodes = sortedShaderNodes.concat(varyingNodes);
    if (isFullVersion) {
      vertexShaderPrerequisites += CommonShaderPart.getVertexPrerequisites(nodes);
    }
    let shaderBody = "";
    shaderBody += _ShaderGraphResolver.__getFunctionDefinition(
      // sortedShaderNodes,
      sortedShaderNodes.concat(varyingNodes.filter((node) => node.getShaderStage() !== "Fragment")),
      ShaderType.VertexShader
    );
    try {
      shaderBody += _ShaderGraphResolver.__constructShaderWithNodes(nodes, true, isFullVersion);
    } catch (e3) {
      Logger.error(e3);
      return void 0;
    }
    const shader = vertexShaderPrerequisites + shaderBody;
    return shader;
  }
  /**
  * Create a pixel shader code from the given pixel nodes.
  *
  * @param pixelNodes - Pixel nodes
  * @param isFullVersion - Whether to generate a full version of the shader code
  * @returns Pixel shader code
  */
  static createPixelShaderCode(pixelNodes, isFullVersion = true) {
    const shaderNodes = pixelNodes.concat();
    const sortedShaderNodes = this.__sortTopologically(shaderNodes);
    let pixelShaderPrerequisites = "";
    if (isFullVersion) {
      pixelShaderPrerequisites += CommonShaderPart.getPixelPrerequisites(sortedShaderNodes);
    }
    let shaderBody = "";
    shaderBody += _ShaderGraphResolver.__getFunctionDefinition(sortedShaderNodes.filter((node) => node.getShaderStage() !== "Vertex"), ShaderType.PixelShader);
    try {
      shaderBody += _ShaderGraphResolver.__constructShaderWithNodes(sortedShaderNodes, false, isFullVersion);
    } catch (e3) {
      Logger.error(e3);
      return void 0;
    }
    const shader = pixelShaderPrerequisites + shaderBody;
    return shader;
  }
  static __validateShaderNodes(shaderNodes) {
    const shaderNodeUids = [];
    for (let i2 = 0; i2 < shaderNodes.length; i2++) {
      const shaderNode = shaderNodes[i2];
      for (let j = 0; j < shaderNode.inputConnections.length; j++) {
        const inputConnection = shaderNode.inputConnections[j];
        if (inputConnection == null) {
          return false;
        }
      }
    }
    return true;
  }
  /**
  * Sort shader nodes topologically.
  *
  * @param shaderNodes - Shader nodes to sort
  * @returns Sorted shader nodes
  */
  static __sortTopologically(shaderNodes) {
    const sortedNodeArray = [];
    const inputNumArray = [];
    const queue = [];
    for (let i2 = 0; i2 < shaderNodes.length; i2++) {
      const shaderNode = shaderNodes[i2];
      let count = 0;
      for (const inputConnection of shaderNode.inputConnections) {
        if (inputConnection != null) {
          count++;
        }
      }
      inputNumArray[i2] = count;
    }
    const outputNodes = [];
    for (let i2 = 0; i2 < shaderNodes.length; i2++) {
      const shaderNode = shaderNodes[i2];
      for (const inputConnection of shaderNode.inputConnections) {
        if (inputConnection == null) {
          continue;
        }
        const inputNode = AbstractShaderNode.getShaderNodeByUid(inputConnection.shaderNodeUid);
        const inputNodeIdx = shaderNodes.indexOf(inputNode);
        if (outputNodes[inputNodeIdx] == null) {
          outputNodes[inputNodeIdx] = [];
        }
        outputNodes[inputNodeIdx].push(shaderNode);
      }
    }
    for (let i2 = 0; i2 < shaderNodes.length; i2++) {
      if (outputNodes[i2] == null) {
        outputNodes[i2] = [];
      }
    }
    for (let i2 = 0; i2 < shaderNodes.length; i2++) {
      if (inputNumArray[i2] === 0) {
        queue.push(shaderNodes[i2]);
      }
    }
    while (queue.length > 0) {
      const now = queue.shift();
      sortedNodeArray.push(now);
      const nowIdx = shaderNodes.indexOf(now);
      for (const outputNode of outputNodes[nowIdx]) {
        inputNumArray[shaderNodes.indexOf(outputNode)]--;
        if (inputNumArray[shaderNodes.indexOf(outputNode)] === 0) {
          queue.push(outputNode);
        }
      }
    }
    if (sortedNodeArray.length != shaderNodes.length) {
      Logger.error("graph is cyclic");
    }
    return sortedNodeArray;
  }
  /**
  * Get function definition from shader nodes.
  *
  * @param shaderNodes - Shader nodes
  * @param shaderType - Shader type
  * @returns Function definition as a string
  */
  static __getFunctionDefinition(shaderNodes, shaderType) {
    let shaderText = "";
    const existVertexFunctions = [];
    for (let i2 = 0; i2 < shaderNodes.length; i2++) {
      const materialNode = shaderNodes[i2];
      if (existVertexFunctions.indexOf(materialNode.shaderFunctionName) !== -1) {
        continue;
      }
      shaderText += materialNode.getShaderCode(shaderType);
      existVertexFunctions.push(materialNode.shaderFunctionName);
    }
    return shaderText;
  }
  /**
  * Construct shader code with shader nodes.
  *
  * @param shaderNodes - Shader nodes
  * @param isVertexStage - Whether the shader is a vertex shader
  * @param isFullVersion - Whether to generate a full version of the shader code
  * @returns Shader code
  */
  static __constructShaderWithNodes(shaderNodes, isVertexStage, isFullVersion) {
    let shaderBody = "";
    if (SystemState.currentProcessApproach !== ProcessApproach.WebGPU) {
      for (let i2 = 0; i2 < shaderNodes.length; i2++) {
        const shaderNode = shaderNodes[i2];
        for (let j = 0; j < shaderNode.inputConnections.length; j++) {
          const inputConnection = shaderNode.inputConnections[j];
          if (inputConnection == null) {
            continue;
          }
          const input = shaderNode.getInputs()[j];
          const inputNode = AbstractShaderNode.getShaderNodeByUid(inputConnection.shaderNodeUid);
          if (inputNode.getShaderStage() === "Vertex" && shaderNode.getShaderStage() === "Fragment") {
            const type = input.compositionType.getGlslStr(input.componentType);
            shaderBody += `${isVertexStage ? "out" : "in"} ${type} v_${inputNode.shaderFunctionName}_${inputNode.shaderNodeUid};
`;
          }
        }
      }
    }
    shaderBody += CommonShaderPart.getMainBegin(isVertexStage);
    if (isFullVersion) {
      shaderBody += CommonShaderPart.getMainPrerequisites();
    }
    const varInputNames = [];
    const varOutputNames = [];
    {
      const existingInputs = /* @__PURE__ */ new Set();
      const existingOutputs = /* @__PURE__ */ new Set();
      const existingOutputsVarName = /* @__PURE__ */ new Map();
      for (let i2 = 1; i2 < shaderNodes.length; i2++) {
        const shaderNode = shaderNodes[i2];
        if (varInputNames[i2] == null) {
          varInputNames[i2] = [];
        }
        if (i2 - 1 >= 0) {
          if (varOutputNames[i2 - 1] == null) {
            varOutputNames[i2 - 1] = [];
          }
        }
        const inputConnections = shaderNode.inputConnections;
        for (let j = 0; j < inputConnections.length; j++) {
          const inputConnection = inputConnections[j];
          if (inputConnection == null) {
            continue;
          }
          const inputNode = AbstractShaderNode._shaderNodes[inputConnection.shaderNodeUid];
          const outputSocketOfPrev = inputNode.getOutput(inputConnection.outputNameOfPrev);
          const inputSocketOfThis = shaderNode.getInput(inputConnection.inputNameOfThis);
          const varName = `${outputSocketOfPrev.name}_${inputConnection.shaderNodeUid}_to_${shaderNode.shaderNodeUid}`;
          if (!existingInputs.has(`${inputNode.shaderNodeUid}_${inputConnection.outputNameOfPrev}`)) {
            let rowStr = CommonShaderPart.getAssignmentStatement(varName, inputSocketOfThis);
            if (!isVertexStage) {
              if (inputNode.getShaderStage() === "Vertex" && shaderNode.getShaderStage() === "Fragment") {
                rowStr = CommonShaderPart.getAssignmentVaryingStatementInPixelShader(varName, inputSocketOfThis, inputNode);
              }
            }
            shaderBody += rowStr;
          }
          const existVarName = existingOutputsVarName.get(inputNode.shaderNodeUid);
          varInputNames[i2].push(existVarName ? existVarName : varName);
          existingInputs.add(`${inputConnection.shaderNodeUid}_${inputConnection.outputNameOfPrev}`);
        }
        for (let j = i2; j < shaderNodes.length; j++) {
          const targetShaderNode = shaderNodes[j];
          const prevShaderNodeInner = shaderNodes[i2 - 1];
          const targetNodeInputConnections = targetShaderNode.inputConnections;
          for (let k = 0; k < targetNodeInputConnections.length; k++) {
            const inputConnection = targetNodeInputConnections[k];
            if (inputConnection == null) {
              continue;
            }
            if ((prevShaderNodeInner == null ? void 0 : prevShaderNodeInner.shaderNodeUid) !== inputConnection.shaderNodeUid) {
              continue;
            }
            const inputNode = AbstractShaderNode._shaderNodes[inputConnection.shaderNodeUid];
            if (!existingOutputs.has(`${inputNode.shaderNodeUid}_${inputConnection.outputNameOfPrev}`)) {
              const outputSocketOfPrev = inputNode.getOutput(inputConnection.outputNameOfPrev);
              const varName = `${outputSocketOfPrev.name}_${inputConnection.shaderNodeUid}_to_${targetShaderNode.shaderNodeUid}`;
              if (i2 - 1 >= 0) {
                varOutputNames[i2 - 1].push(varName);
              }
              existingOutputsVarName.set(inputConnection.shaderNodeUid, varName);
            }
            existingOutputs.add(`${inputConnection.shaderNodeUid}_${inputConnection.outputNameOfPrev}`);
          }
        }
      }
    }
    for (let i2 = 0; i2 < shaderNodes.length; i2++) {
      const shaderNode = shaderNodes[i2];
      const functionName = shaderNode.getShaderFunctionNameDerivative();
      if (varInputNames[i2] == null) {
        varInputNames[i2] = [];
      }
      if (varOutputNames[i2] == null) {
        varOutputNames[i2] = [];
      }
      if (isVertexStage && shaderNode.getShaderStage() === "Fragment") {
        continue;
      } else if (!isVertexStage && shaderNode.getShaderStage() === "Vertex") {
        continue;
      }
      shaderBody += shaderNode.makeCallStatement(i2, shaderNode, functionName, varInputNames, varOutputNames);
    }
    if (isVertexStage) {
      for (let i2 = 0; i2 < shaderNodes.length; i2++) {
        const shaderNode = shaderNodes[i2];
        const varNames = varInputNames[i2].concat(varOutputNames[i2]);
        for (let j = 0; j < shaderNode.inputConnections.length; j++) {
          const inputConnection = shaderNode.inputConnections[j];
          if (inputConnection == null) {
            continue;
          }
          const inputNode = AbstractShaderNode.getShaderNodeByUid(inputConnection.shaderNodeUid);
          if (inputNode.getShaderStage() === "Vertex" && shaderNode.getShaderStage() === "Fragment") {
            shaderBody += CommonShaderPart.getAssignmentVaryingStatementInVertexShader(inputNode, varNames, j);
          }
        }
      }
    }
    shaderBody += CommonShaderPart.getMainEnd(isVertexStage);
    return shaderBody;
  }
  /**
  * Generate shader code from JSON.
  *
  * @param json - JSON data of a shader node graph
  * @returns Shader code
  */
  static generateShaderCodeFromJson(json) {
    const constructedNodes = Object.values(constructNodes(json));
    const nodes = this.__sortTopologically(constructedNodes);
    resolveShaderStage(nodes);
    const varyingNodes = filterNodesForVarying(nodes, "outColor");
    const vertexNodes = filterNodes(nodes, [
      "outPosition"
    ]);
    const pixelNodes = filterNodes(nodes, [
      "outColor"
    ]);
    if (vertexNodes.length === 0 || pixelNodes.length === 0) {
      return;
    }
    const vertexRet = _ShaderGraphResolver.createVertexShaderCode(vertexNodes, varyingNodes);
    const pixelRet = _ShaderGraphResolver.createPixelShaderCode(pixelNodes);
    if (vertexRet == null || pixelRet == null) {
      return;
    }
    return {
      vertexShader: vertexRet,
      pixelShader: pixelRet
    };
  }
};
__name(_ShaderGraphResolver, "ShaderGraphResolver");
var ShaderGraphResolver = _ShaderGraphResolver;
function filterNodesInner(nodes, endNodeName) {
  let endNode;
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    if (node.shaderFunctionName.toLowerCase().includes(endNodeName.toLowerCase())) {
      endNode = node;
      break;
    }
  }
  if (endNode == null) {
    return [];
  }
  const filteredNodes = [
    endNode
  ];
  function traverseNodes(node) {
    for (let i2 = 0; i2 < node.inputConnections.length; i2++) {
      const inputConnection = node.inputConnections[i2];
      if (inputConnection != null) {
        const inputNode = AbstractShaderNode.getShaderNodeByUid(inputConnection.shaderNodeUid);
        if (inputNode != null) {
          filteredNodes.push(inputNode);
          traverseNodes(inputNode);
        }
      }
    }
  }
  __name(traverseNodes, "traverseNodes");
  traverseNodes(endNode);
  return filteredNodes;
}
__name(filterNodesInner, "filterNodesInner");
function filterNodes(nodes, endNodesName) {
  let finalFilterNodes = [];
  for (let i2 = 0; i2 < endNodesName.length; i2++) {
    const endNodeName = endNodesName[i2];
    const filteredNodes = filterNodesInner(nodes, endNodeName);
    finalFilterNodes = finalFilterNodes.concat(filteredNodes);
  }
  finalFilterNodes = [
    ...new Set(finalFilterNodes)
  ];
  return finalFilterNodes;
}
__name(filterNodes, "filterNodes");
function resolveShaderStage(shaderNodes) {
  for (let i2 = 0; i2 < shaderNodes.length; i2++) {
    const shaderNode = shaderNodes[i2];
    for (const inputConnection of shaderNode.inputConnections) {
      if (inputConnection == null) {
        continue;
      }
      const inputNode = AbstractShaderNode.getShaderNodeByUid(inputConnection.shaderNodeUid);
      if (inputNode.getShaderStage() === "Vertex" && shaderNode.getShaderStage() === "Neutral") {
        shaderNode.setShaderStage("Vertex");
      } else if (inputNode.getShaderStage() === "Fragment") {
        shaderNode.setShaderStage("Fragment");
      }
    }
  }
}
__name(resolveShaderStage, "resolveShaderStage");
function filterNodesForVarying(nodes, endNodeName) {
  let endNode;
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    if (node.shaderFunctionName.toLowerCase().includes(endNodeName.toLowerCase())) {
      endNode = node;
      break;
    }
  }
  if (endNode == null) {
    return [];
  }
  let varyingNodes = [];
  function traverseNodesAll(node) {
    for (let i2 = 0; i2 < node.inputConnections.length; i2++) {
      const inputConnection = node.inputConnections[i2];
      if (inputConnection == null) {
        continue;
      }
      const inputNode = AbstractShaderNode.getShaderNodeByUid(inputConnection.shaderNodeUid);
      varyingNodes.push(inputNode);
      traverseNodesAll(inputNode);
    }
  }
  __name(traverseNodesAll, "traverseNodesAll");
  function traverseNodes(node) {
    for (let i2 = 0; i2 < node.inputConnections.length; i2++) {
      const inputConnection = node.inputConnections[i2];
      if (inputConnection == null) {
        continue;
      }
      const inputNode = AbstractShaderNode.getShaderNodeByUid(inputConnection.shaderNodeUid);
      if (inputNode != null && inputNode.getShaderStage() === "Vertex" && node.getShaderStage() === "Fragment") {
        varyingNodes.push(inputNode);
        if (node.getShaderStage() === "Fragment") {
          varyingNodes.unshift(node);
        }
        traverseNodesAll(inputNode);
        break;
      }
      traverseNodes(inputNode);
    }
  }
  __name(traverseNodes, "traverseNodes");
  traverseNodes(endNode);
  varyingNodes = [
    ...new Set(varyingNodes)
  ];
  return varyingNodes.reverse();
}
__name(filterNodesForVarying, "filterNodesForVarying");
function constructNodes(json) {
  const nodeInstances = {};
  const nodes = {};
  for (const node of json.nodes) {
    nodes[node.id] = node;
    switch (node.name) {
      // case 'ConstantBool': {
      //   const nodeInstance = new ConstantScalarVariableShaderNode(ComponentType.Bool);
      //   nodeInstance.setDefaultInputValue(Scalar.fromCopyNumber(node.data.bool ? 1 : 0));
      //   nodeInstances[node.id] = nodeInstance;
      //   break;
      // }
      case "ConstantScalar": {
        const nodeInstance = new ConstantScalarVariableShaderNode(ComponentType.Float);
        nodeInstance.setDefaultInputValue(Scalar2.fromCopyNumber(node.controls["in1"].value));
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "ConstantVector2": {
        const nodeInstance = new ConstantVector2VariableShaderNode(ComponentType.Float);
        nodeInstance.setDefaultInputValue(Vector2.fromCopy2(node.controls["in1"].value, node.controls["in2"].value));
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "ConstantVector3": {
        const nodeInstance = new ConstantVector3VariableShaderNode(ComponentType.Float);
        nodeInstance.setDefaultInputValue(Vector3.fromCopy3(node.controls["in1"].value, node.controls["in2"].value, node.controls["in3"].value));
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "ConstantVector4": {
        const nodeInstance = new ConstantVector4VariableShaderNode(ComponentType.Float);
        nodeInstance.setDefaultInputValue(Vector4.fromCopy4(node.controls["in1"].value, node.controls["in2"].value, node.controls["in3"].value, node.controls["in4"].value));
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "UniformVector4": {
        const nodeInstance = new UniformDataShaderNode(CompositionType.Vec4, ComponentType.Float);
        nodeInstance.setDefaultInputValue("value", Vector4.fromCopyArray4([
          node.controls["initialX"].value,
          node.controls["initialY"].value,
          node.controls["initialZ"].value,
          node.controls["initialW"].value
        ]));
        nodeInstance.setUniformDataName(node.controls["name"].value);
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "Time": {
        const nodeInstance = new TimeShaderNode();
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "Add": {
        const socketName = node.outputs.out1.socket.name;
        let nodeInstance;
        if (socketName === "Scalar") {
          nodeInstance = new AddShaderNode(CompositionType.Scalar, ComponentType.Float);
        } else if (socketName === "Vector2") {
          nodeInstance = new AddShaderNode(CompositionType.Vec2, ComponentType.Float);
        } else if (socketName === "Vector3") {
          nodeInstance = new AddShaderNode(CompositionType.Vec3, ComponentType.Float);
        } else if (socketName === "Vector4") {
          nodeInstance = new AddShaderNode(CompositionType.Vec4, ComponentType.Float);
        } else {
          Logger.error("Add node: Unknown socket name: " + socketName);
          break;
        }
        nodeInstance.setShaderStage(node.controls["shaderStage"].value);
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "Sin": {
        const socketName = node.outputs.out1.socket.name;
        let nodeInstance;
        if (socketName === "Scalar") {
          nodeInstance = new SinShaderNode(CompositionType.Scalar, ComponentType.Float);
        } else if (socketName === "Vector2") {
          nodeInstance = new SinShaderNode(CompositionType.Vec2, ComponentType.Float);
        } else if (socketName === "Vector3") {
          nodeInstance = new SinShaderNode(CompositionType.Vec3, ComponentType.Float);
        } else if (socketName === "Vector4") {
          nodeInstance = new SinShaderNode(CompositionType.Vec4, ComponentType.Float);
        } else {
          Logger.error("Sin node: Unknown socket name: " + socketName);
          break;
        }
        nodeInstance.setShaderStage(node.controls["shaderStage"].value);
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "Step": {
        const socketName = node.outputs.out1.socket.name;
        let nodeInstance;
        if (socketName === "Scalar") {
          nodeInstance = new StepShaderNode(CompositionType.Scalar, ComponentType.Float);
        } else if (socketName === "Vector2") {
          nodeInstance = new StepShaderNode(CompositionType.Vec2, ComponentType.Float);
        } else if (socketName === "Vector3") {
          nodeInstance = new StepShaderNode(CompositionType.Vec3, ComponentType.Float);
        } else if (socketName === "Vector4") {
          nodeInstance = new StepShaderNode(CompositionType.Vec4, ComponentType.Float);
        } else {
          Logger.error("Add node: Unknown socket name: " + socketName);
          break;
        }
        nodeInstance.setShaderStage(node.controls["shaderStage"].value);
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "SmoothStep": {
        const socketName = node.outputs.out1.socket.name;
        let nodeInstance;
        if (socketName === "Scalar") {
          nodeInstance = new SmoothStepShaderNode(CompositionType.Scalar, ComponentType.Float);
        } else if (socketName === "Vector2") {
          nodeInstance = new SmoothStepShaderNode(CompositionType.Vec2, ComponentType.Float);
        } else if (socketName === "Vector3") {
          nodeInstance = new SmoothStepShaderNode(CompositionType.Vec3, ComponentType.Float);
        } else if (socketName === "Vector4") {
          nodeInstance = new SmoothStepShaderNode(CompositionType.Vec4, ComponentType.Float);
        } else {
          Logger.error("Add node: Unknown socket name: " + socketName);
          break;
        }
        nodeInstance.setShaderStage(node.controls["shaderStage"].value);
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "Normalize": {
        const socketName = node.outputs.out1.socket.name;
        let nodeInstance;
        if (socketName === "Vector2") {
          nodeInstance = new NormalizeShaderNode(CompositionType.Vec2, ComponentType.Float);
        } else if (socketName === "Vector3") {
          nodeInstance = new NormalizeShaderNode(CompositionType.Vec3, ComponentType.Float);
        } else if (socketName === "Vector4") {
          nodeInstance = new NormalizeShaderNode(CompositionType.Vec4, ComponentType.Float);
        } else {
          Logger.error("Normalize node: Unknown socket name: " + socketName);
          break;
        }
        nodeInstance.setShaderStage(node.controls["shaderStage"].value);
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "Dot": {
        const socketName = node.inputs.in1.socket.name;
        let nodeInstance;
        if (socketName === "Vector2") {
          nodeInstance = new DotProductShaderNode(CompositionType.Vec2, ComponentType.Float);
        } else if (socketName === "Vector3") {
          nodeInstance = new DotProductShaderNode(CompositionType.Vec3, ComponentType.Float);
        } else if (socketName === "Vector4") {
          nodeInstance = new DotProductShaderNode(CompositionType.Vec4, ComponentType.Float);
        } else {
          Logger.error("Dot node: Unknown socket name: " + socketName);
          break;
        }
        nodeInstance.setShaderStage(node.controls["shaderStage"].value);
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "Multiply": {
        const socketName = node.outputs.out1.socket.name;
        let nodeInstance;
        if (socketName === "Scalar") {
          nodeInstance = new MultiplyShaderNode(CompositionType.Scalar, ComponentType.Float);
        } else if (socketName === "Vector2") {
          nodeInstance = new MultiplyShaderNode(CompositionType.Vec2, ComponentType.Float);
        } else if (socketName === "Vector3") {
          nodeInstance = new MultiplyShaderNode(CompositionType.Vec3, ComponentType.Float);
        } else if (socketName === "Vector4") {
          nodeInstance = new MultiplyShaderNode(CompositionType.Vec4, ComponentType.Float);
        } else if (socketName === "Matrix2") {
          nodeInstance = new MultiplyShaderNode(CompositionType.Mat2, ComponentType.Float);
        } else if (socketName === "Matrix3") {
          nodeInstance = new MultiplyShaderNode(CompositionType.Mat3, ComponentType.Float);
        } else if (socketName === "Matrix4") {
          nodeInstance = new MultiplyShaderNode(CompositionType.Mat4, ComponentType.Float);
        } else {
          Logger.error("Multiply node: Unknown socket name: " + socketName);
          break;
        }
        nodeInstance.setShaderStage(node.controls["shaderStage"].value);
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "Transform": {
        const socketName = node.outputs.out1.socket.name;
        let nodeInstance;
        if (socketName === "Vector2") {
          nodeInstance = new TransformShaderNode(CompositionType.Mat2, ComponentType.Float, CompositionType.Vec2, ComponentType.Float);
        } else if (socketName === "Vector3") {
          nodeInstance = new TransformShaderNode(CompositionType.Mat3, ComponentType.Float, CompositionType.Vec3, ComponentType.Float);
        } else if (socketName === "Vector4") {
          nodeInstance = new TransformShaderNode(CompositionType.Mat4, ComponentType.Float, CompositionType.Vec4, ComponentType.Float);
        } else {
          Logger.error("Transform node: Unknown socket name: " + socketName);
          break;
        }
        nodeInstance.setShaderStage(node.controls["shaderStage"].value);
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "SplitVector": {
        const nodeInstance = new SplitVectorShaderNode();
        nodeInstance.setShaderStage(node.controls["shaderStage"].value);
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "MergeVector": {
        const nodeInstance = new MergeVectorShaderNode();
        nodeInstance.setShaderStage(node.controls["shaderStage"].value);
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "AttributeColor": {
        const nodeInstance = new AttributeColorShaderNode();
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "AttributeNormal": {
        const nodeInstance = new AttributeNormalShaderNode();
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "AttributePosition": {
        const nodeInstance = new AttributePositionShaderNode();
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "AttributeTexcoord": {
        const nodeInstance = new AttributeTexcoordShaderNode();
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "WorldMatrix": {
        const nodeInstance = new WorldMatrixShaderNode();
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "ViewMatrix": {
        const nodeInstance = new ViewMatrixShaderNode();
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "ProjectionMatrix": {
        const nodeInstance = new ProjectionMatrixShaderNode();
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "NormalMatrix": {
        const nodeInstance = new NormalMatrixShaderNode();
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      // case 'If': {
      //   const nodeInstance = new IfStatementShaderNode();
      //   nodeInstances[node.id] = nodeInstance;
      //   break;
      // }
      // case 'BlockBegin': {
      //   const nodeInstance = new BlockBeginShaderNode();
      //   for (const outputName in node.outputs) {
      //     const compositionType = getCompositionType(outputName);
      //     nodeInstance.addInputAndOutput(compositionType, ComponentType.Float);
      //   }
      //   nodeInstances[node.id] = nodeInstance;
      //   break;
      // }
      // case 'BlockEnd': {
      //   const nodeInstance = new BlockEndShaderNode();
      //   for (const outputName in node.outputs) {
      //     const compositionType = getCompositionType(outputName);
      //     nodeInstance.addInputAndOutput(compositionType, ComponentType.Float);
      //   }
      //   nodeInstances[node.id] = nodeInstance;
      //   break;
      // }
      case "Greater": {
        const nodeInstance = new GreaterShaderNode(CompositionType.Scalar, ComponentType.Float);
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "OutPosition": {
        const nodeInstance = new OutPositionShaderNode();
        nodeInstances[node.id] = nodeInstance;
        break;
      }
      case "OutColor": {
        const nodeInstance = new OutColorShaderNode();
        nodeInstances[node.id] = nodeInstance;
        break;
      }
    }
  }
  for (let i2 = 0; i2 < json.connections.length; i2++) {
    const connection = json.connections[i2];
    const inputNodeInstance = nodeInstances[connection.from.id];
    const outputNodeInstance = nodeInstances[connection.to.id];
    if (inputNodeInstance == null || outputNodeInstance == null) {
      Logger.error("inputNodeInstance or outputNodeInstance is null");
      continue;
    }
    let idx = 0;
    for (const key in nodes[connection.to.id].inputs) {
      if (key === connection.to.portName) {
        break;
      }
      idx++;
    }
    let idx2 = 0;
    for (const key in nodes[connection.from.id].outputs) {
      if (key === connection.from.portName) {
        break;
      }
      idx2++;
    }
    const outputOfInputNode = inputNodeInstance.getOutputs()[idx2];
    const inputOfOutputNode = outputNodeInstance.getInputs()[idx];
    outputNodeInstance.addInputConnection(inputNodeInstance, outputOfInputNode, inputOfOutputNode);
  }
  return nodeInstances;
}
__name(constructNodes, "constructNodes");

// src/foundation/materials/core/index.ts
init_ShaderityUtilityWebGL();
init_DummyTextures();

// src/foundation/materials/contents/index.ts
init_ColorGradingUsingLUTsMaterialContent();
init_CustomMaterialContent();
init_DepthEncodeMaterialContent();
init_DetectHighLuminanceMaterialContent();
init_EntityUIDOutputMaterialContent();
init_FurnaceTestMaterialContent();
init_MToon0xMaterialContent();
init_MToon1MaterialContent();
init_MatCapMaterialContent();
init_ShadowMapDecodeClassicMaterialContent();
init_SynthesizeHdrMaterialContent();
init_VarianceShadowMapDecodeClassicMaterialContent();

// src/foundation/index.ts
init_math();

// src/foundation/memory/index.ts
init_Accessor();
init_Buffer();
init_BufferView();

// src/foundation/index.ts
init_misc();

// src/foundation/physics/Oimo/index.ts
init_OimoPhysicsStrategy();

// src/foundation/renderer/pipelines/ForwardRenderPipeline.ts
init_TextureParameter();
init_Vector4();
init_Option();
init_Is();
init_Expression();
init_Frame();
init_RenderPass();
init_MaterialHelper();
init_Result();
init_System();
init_RnObject();
init_ModuleManager();
init_definitions();
init_Sampler();
init_system();
init_CGAPIResourceRepository();
init_TextureFormat();
var _ForwardRenderPipeline = class _ForwardRenderPipeline extends RnObject {
  constructor() {
    super();
    __publicField(this, "__width", 0);
    __publicField(this, "__height", 0);
    __publicField(this, "__isShadow", false);
    __publicField(this, "__isBloom", false);
    __publicField(this, "__isSimple", false);
    __publicField(this, "__shadowMapSize", 1024);
    __publicField(this, "__oFrame", new None());
    __publicField(this, "__oFrameDepthMoment", new None());
    __publicField(this, "__oFrameBufferMultiView", new None());
    __publicField(this, "__oFrameBufferMultiViewBlit", new None());
    __publicField(this, "__oFrameBufferMultiViewBlitBackBuffer", new None());
    __publicField(this, "__oFrameBufferMsaa", new None());
    __publicField(this, "__oFrameBufferResolve", new None());
    __publicField(this, "__oFrameBufferResolveForReference", new None());
    __publicField(this, "__oInitialExpression", new None());
    /** main expressions */
    __publicField(this, "__expressions", []);
    __publicField(this, "__oGenerateMipmapsExpression", new None());
    __publicField(this, "__oMultiViewBlitBackBufferExpression", new None());
    __publicField(this, "__oMultiViewBlitExpression", new None());
    __publicField(this, "__oCameraComponentOfLight", new None());
    __publicField(this, "__depthMomentExpressions", []);
    __publicField(this, "__oBloomExpression", new None());
    __publicField(this, "__oToneMappingExpression", new None());
    __publicField(this, "__oToneMappingMaterial", new None());
    __publicField(this, "__transparentOnlyExpressions", []);
    __publicField(this, "__oWebXRSystem", new None());
    __publicField(this, "__oDrawFunc", new None());
    __publicField(this, "__oDiffuseCubeTexture", new None());
    __publicField(this, "__oSpecularCubeTexture", new None());
    __publicField(this, "__oSamplerForBackBuffer", new None());
    __publicField(this, "__toneMappingType", ToneMappingType.GT_ToneMap);
  }
  __destroyResources() {
    if (this.__oFrameDepthMoment.has()) {
      this.__oFrameDepthMoment.get().destroy3DAPIResources();
      this.__oFrameDepthMoment = new None();
    }
    if (this.__oFrameBufferMultiView.has()) {
      this.__oFrameBufferMultiView.get().destroy3DAPIResources();
      this.__oFrameBufferMultiView = new None();
    }
    if (this.__oFrameBufferMultiViewBlit.has()) {
      this.__oFrameBufferMultiViewBlit.get().destroy3DAPIResources();
      this.__oFrameBufferMultiViewBlit = new None();
    }
    if (this.__oFrameBufferMsaa.has()) {
      this.__oFrameBufferMsaa.get().destroy3DAPIResources();
      this.__oFrameBufferMsaa = new None();
    }
    if (this.__oFrameBufferResolve.has()) {
      this.__oFrameBufferResolve.get().destroy3DAPIResources();
      this.__oFrameBufferResolve = new None();
    }
    if (this.__oFrameBufferResolveForReference.has()) {
      this.__oFrameBufferResolveForReference.get().destroy3DAPIResources();
      this.__oFrameBufferResolveForReference = new None();
    }
    this.__oFrame = new None();
    this.__oGenerateMipmapsExpression = new None();
    this.__oMultiViewBlitExpression = new None();
    this.__oBloomExpression = new None();
    this.__oToneMappingExpression = new None();
  }
  /**
  * Initializes the pipeline.
  * @param canvasWidth - The width of the canvas.
  * @param canvasHeight - The height of the canvas.
  */
  async setup(canvasWidth, canvasHeight, { isShadow = false, isBloom = false, shadowMapSize = 1024, isSimple = false } = {}) {
    this.__width = canvasWidth;
    this.__height = canvasHeight;
    this.__isBloom = isBloom;
    this.__isShadow = isShadow;
    this.__isSimple = isSimple;
    this.__shadowMapSize = shadowMapSize;
    if (this.__oFrame.has()) {
      return new Err({
        message: "Already setup",
        error: void 0
      });
    }
    const sFrame = new Some(new Frame());
    this.__oFrame = sFrame;
    if (!this.__isSimple) {
      const oSamplerForBackBuffer = new Some(new Sampler({
        wrapS: TextureParameter.Repeat,
        wrapT: TextureParameter.Repeat,
        minFilter: TextureParameter.LinearMipmapLinear,
        magFilter: TextureParameter.Linear
      }));
      oSamplerForBackBuffer.get().create();
      this.__oSamplerForBackBuffer = oSamplerForBackBuffer;
      this.__createRenderTargets(canvasWidth, canvasHeight);
      if (isShadow && !this.__isSimple) {
        this.__oFrameDepthMoment = this.__setupDepthMomentFramebuffer(shadowMapSize);
      }
      if (this.__oFrameBufferResolveForReference.has()) {
        this.__oGenerateMipmapsExpression = this.__setupGenerateMipmapsExpression(this.__oFrameBufferResolveForReference.get());
      }
      if (this.__oFrameBufferMultiView.has()) {
        this.__oMultiViewBlitBackBufferExpression = this.__setupMultiViewBlitBackBufferExpression(this.__oFrameBufferMultiView.get());
        this.__oMultiViewBlitExpression = this.__setupMultiViewBlitExpression(this.__oFrameBufferMultiView.get());
      }
      let toneMappingTargetRenderTargetTexture = this.__getMainFrameBufferResolve().unwrapForce().getColorAttachedRenderTargetTexture(0);
      if (isBloom && !this.__isSimple) {
        const frameBufferToBloom = this.__getMainFrameBufferResolve();
        const textureToBloom = frameBufferToBloom.unwrapForce().getColorAttachedRenderTargetTexture(0);
        const { bloomExpression, bloomedRenderTarget } = ExpressionHelper.createBloomExpression({
          textureToBloom,
          parameters: {}
        });
        this.__oBloomExpression = new Some(bloomExpression);
        toneMappingTargetRenderTargetTexture = bloomedRenderTarget;
      }
      const toneMappingExpression = this.__setupToneMappingExpression(toneMappingTargetRenderTargetTexture);
      this.__oToneMappingExpression = new Some(toneMappingExpression);
    }
    const initialExpression = this.__setupInitialExpression(this.__oFrameDepthMoment);
    this.__oInitialExpression = new Some(initialExpression);
    const rnXRModule = await ModuleManager.getInstance().getModule("xr");
    if (Is.exist(rnXRModule)) {
      this.__oWebXRSystem = new Some(rnXRModule.WebXRSystem.getInstance());
    }
    if (this.__expressions.length > 0) {
      this.setExpressions(this.__expressions);
    }
    return new Ok();
  }
  __getMainFrameBufferBackBuffer() {
    if (this.__oFrameBufferMultiView.has()) {
      return this.__oFrameBufferMultiViewBlitBackBuffer;
    } else {
      return this.__oFrameBufferResolveForReference;
    }
  }
  __getMainFrameBufferResolve() {
    if (this.__oFrameBufferMultiView.has()) {
      return this.__oFrameBufferMultiViewBlit;
    } else {
      return this.__oFrameBufferResolve;
    }
  }
  __getMainFrameBuffer() {
    if (this.__oFrameBufferMultiView.has()) {
      return this.__oFrameBufferMultiView;
    } else {
      return this.__oFrameBufferMsaa;
    }
  }
  /**
  * set Expressions for drawing
  * @param expressions - expressions to draw
  * @param options - option parameters
  */
  setExpressions(expressions, options = {
    isTransmission: true
  }) {
    const expressionsTranslucent = expressions.map((expression) => expression.clone());
    this.__setExpressionsInner(expressions, {
      isTransmission: options.isTransmission
    });
    if (options.isTransmission) {
      this.__setTransparentExpressionsForTransmission(expressionsTranslucent);
    }
    if (SystemState.currentProcessApproach !== ProcessApproach.WebGPU) {
      if (this.__oFrameDepthMoment.has()) {
        this.__setDepthTextureToEntityMaterials();
        if (this.__oCameraComponentOfLight.has()) {
          this.setCameraComponentOfLight(this.__oCameraComponentOfLight.get());
        }
      }
    }
  }
  __setDepthTextureToEntityMaterials() {
    if (Is.false(this.__isShadow)) {
      return;
    }
    this.__depthMomentExpressions = [];
    for (const expression of this.__expressions) {
      this.__depthMomentExpressions.push(expression.clone());
    }
    const depthMomentMaterial = MaterialHelper.createDepthMomentEncodeMaterial();
    for (const expression of this.__depthMomentExpressions) {
      for (const renderPass of expression.renderPasses) {
        renderPass.setFramebuffer(this.__oFrameDepthMoment.unwrapForce());
        renderPass.setResolveFramebuffer(void 0);
        renderPass.setResolveFramebuffer2(void 0);
        renderPass.setToRenderOpaquePrimitives(true);
        renderPass.setToRenderTranslucentPrimitives(true);
        renderPass.setToRenderBlendWithZWritePrimitives(true);
        renderPass.setToRenderBlendWithoutZWritePrimitives(false);
        renderPass.setMaterial(depthMomentMaterial);
      }
    }
    const sampler = new Sampler({
      wrapS: TextureParameter.ClampToEdge,
      wrapT: TextureParameter.ClampToEdge,
      minFilter: TextureParameter.Linear,
      magFilter: TextureParameter.Linear,
      anisotropy: false
    });
    sampler.create();
    for (const expression of this.__expressions) {
      for (const renderPass of expression.renderPasses) {
        const entities = renderPass.entities;
        for (const entity of entities) {
          const meshComponent = entity.tryToGetMesh();
          if (Is.exist(meshComponent)) {
            const mesh = meshComponent.mesh;
            if (Is.exist(mesh)) {
              const primitives = mesh.primitives;
              for (const primitive of primitives) {
                const material = primitive.material;
                material.setTextureParameter("depthTexture", this.__oFrameDepthMoment.unwrapForce().getColorAttachedRenderTargetTexture(0), sampler);
              }
            }
          }
        }
      }
    }
  }
  /**
  * Start rendering loop
  * @param func - function to be called when the frame is rendered
  * @returns RnResult
  */
  startRenderLoop(func) {
    if (this.__oFrame.doesNotHave()) {
      return new Err({
        message: "not initialized.",
        error: void 0
      });
    }
    this.__oDrawFunc = new Some(func);
    System.startRenderLoop(() => {
      this.__setExpressions();
      func(this.__oFrame.unwrapForce());
    });
    return new Ok();
  }
  /**
  * draw with the given function in startRenderLoop method
  */
  draw() {
    this.__oDrawFunc.unwrapForce()(this.__oFrame.unwrapForce());
  }
  /**
  * Resize screen
  * @param width - width of the screen
  * @param height - height of the screen
  * @returns RnResult
  */
  resize(width, height) {
    if (this.__oFrame.doesNotHave()) {
      return new Err({
        message: "not initialized.",
        error: void 0
      });
    }
    const webXRSystem = this.__oWebXRSystem.unwrapOrUndefined();
    if (Is.exist(webXRSystem) && webXRSystem.isWebXRMode) {
      width = webXRSystem.getCanvasWidthForVr();
      height = webXRSystem.getCanvasHeightForVr();
    }
    System.resizeCanvas(width, height);
    this.__destroyResources();
    this.setup(width, height, {
      isShadow: this.__isShadow,
      isBloom: this.__isBloom,
      shadowMapSize: this.__shadowMapSize,
      isSimple: this.__isSimple
    });
    return new Ok();
  }
  /**
  * set IBL cube textures
  * @param diffuse - diffuse IBL Cube Texture
  * @param specular - specular IBL Cube Texture
  */
  async setIBLTextures(diffuse, specular) {
    this.__oDiffuseCubeTexture = new Some(diffuse);
    this.__oSpecularCubeTexture = new Some(specular);
    await this.__setIblInner();
    await this.__setIblInnerForTransparentOnly();
  }
  /**
  * getter of initial expression
  */
  getInitialExpression() {
    return this.__oInitialExpression.unwrapOrUndefined();
  }
  /**
  * getter of ToneMapping expression
  */
  getToneMappingExpression() {
    return this.__oToneMappingExpression.unwrapOrUndefined();
  }
  /**
  * set diffuse IBL contribution
  * @param value - 0.0 ~ 1.0 or greater
  */
  setDiffuseIBLContribution(value) {
    for (const expression of this.__expressions) {
      for (const renderPass of expression.renderPasses) {
        for (const entity of renderPass.entities) {
          const meshRendererComponent = entity.tryToGetMeshRenderer();
          if (Is.exist(meshRendererComponent)) {
            meshRendererComponent.diffuseCubeMapContribution = value;
          }
        }
      }
    }
    for (const expression of this.__transparentOnlyExpressions) {
      for (const renderPass of expression.renderPasses) {
        for (const entity of renderPass.entities) {
          const meshRendererComponent = entity.tryToGetMeshRenderer();
          if (Is.exist(meshRendererComponent)) {
            meshRendererComponent.diffuseCubeMapContribution = value;
          }
        }
      }
    }
  }
  /**
  * set specular IBL contribution
  * @param value - 0.0 ~ 1.0 or greater
  */
  setSpecularIBLContribution(value) {
    for (const expression of this.__expressions) {
      for (const renderPass of expression.renderPasses) {
        for (const entity of renderPass.entities) {
          const meshRendererComponent = entity.tryToGetMeshRenderer();
          if (Is.exist(meshRendererComponent)) {
            meshRendererComponent.specularCubeMapContribution = value;
          }
        }
      }
    }
    for (const expression of this.__transparentOnlyExpressions) {
      for (const renderPass of expression.renderPasses) {
        for (const entity of renderPass.entities) {
          const meshRendererComponent = entity.tryToGetMeshRenderer();
          if (Is.exist(meshRendererComponent)) {
            meshRendererComponent.specularCubeMapContribution = value;
          }
        }
      }
    }
  }
  /**
  * set the rotation of IBL
  * @param radian - rotation in radian
  */
  setIBLRotation(radian) {
    for (const expression of this.__expressions) {
      for (const renderPass of expression.renderPasses) {
        for (const entity of renderPass.entities) {
          const meshRendererComponent = entity.tryToGetMeshRenderer();
          if (Is.exist(meshRendererComponent)) {
            meshRendererComponent.rotationOfCubeMap = radian;
          }
        }
      }
    }
  }
  setCameraComponentOfLight(cameraComponent) {
    if (this.__isShadow) {
      this.__oCameraComponentOfLight = new Some(cameraComponent);
      for (const expression of this.__depthMomentExpressions) {
        for (const renderPass of expression.renderPasses) {
          renderPass.cameraComponent = cameraComponent;
        }
      }
      for (const expression of this.__expressions) {
        for (const renderPass of expression.renderPasses) {
          renderPass.setPostRenderFunction(function() {
            const entities = renderPass.entities;
            for (const entity of entities) {
              const meshComponent = entity.tryToGetMesh();
              if (Is.exist(meshComponent)) {
                const mesh = meshComponent.mesh;
                if (Is.exist(mesh)) {
                  const primitives = mesh.primitives;
                  for (const primitive of primitives) {
                    const material = primitive.material;
                    material.setParameter("depthBiasPV", cameraComponent.biasViewProjectionMatrix);
                  }
                }
              }
            }
          });
        }
      }
    }
  }
  async __setExpressionsInner(expressions, options = {
    isTransmission: true
  }) {
    for (const expression of expressions) {
      for (const rp of expression.renderPasses) {
        rp.setToRenderOpaquePrimitives(true);
        rp.setToRenderBlendWithZWritePrimitives(true);
        rp.setToRenderBlendWithoutZWritePrimitives(true);
        if (options.isTransmission) {
          rp.setToRenderTranslucentPrimitives(false);
        } else {
          rp.setToRenderTranslucentPrimitives(true);
        }
        rp.toClearDepthBuffer = false;
        if (!this.__isSimple) {
          const mainFrameBuffer = this.__getMainFrameBuffer();
          if (mainFrameBuffer.has()) {
            rp.setFramebuffer(mainFrameBuffer.get());
            if (this.__oFrameBufferMsaa.has()) {
              rp.setResolveFramebuffer(this.__oFrameBufferResolve.unwrapForce());
              rp.setResolveFramebuffer2(this.__oFrameBufferResolveForReference.unwrapForce());
            }
          }
        }
      }
    }
    this.__expressions = expressions;
    await this.__setIblInner();
  }
  __setTransparentExpressionsForTransmission(expressions) {
    for (const expression of expressions) {
      expression.tryToSetUniqueName("modelTransparentForTransmission", true);
      for (const rp of expression.renderPasses) {
        rp.setToRenderOpaquePrimitives(false);
        rp.setToRenderTranslucentPrimitives(true);
        rp.setToRenderBlendWithZWritePrimitives(false);
        rp.setToRenderBlendWithoutZWritePrimitives(false);
        rp.toClearDepthBuffer = false;
        if (!this.__isSimple) {
          rp.setFramebuffer(this.__getMainFrameBuffer().unwrapForce());
          if (this.__oFrameBufferResolve.has()) {
            rp.setResolveFramebuffer(this.__oFrameBufferResolve.unwrapForce());
          }
          for (const entity of rp.entities) {
            const meshComponent = entity.tryToGetMesh();
            if (Is.exist(meshComponent)) {
              const mesh = meshComponent.mesh;
              if (Is.exist(mesh)) {
                for (let i2 = 0; i2 < mesh.getPrimitiveNumber(); i2++) {
                  const primitive = mesh.getPrimitiveAt(i2);
                  primitive.material.setTextureParameter("backBufferTexture", this.__getMainFrameBufferBackBuffer().unwrapForce().getColorAttachedRenderTargetTexture(0), this.__oSamplerForBackBuffer.unwrapForce());
                }
              }
            }
          }
        }
      }
    }
    this.__transparentOnlyExpressions = expressions;
    this.__setIblInnerForTransparentOnly();
  }
  __setupInitialExpression(oFrameDepthMoment) {
    const expression = new Expression();
    expression.tryToSetUniqueName("Initial", true);
    const initialRenderPass = new RenderPass();
    initialRenderPass.clearColor = Vector4.fromCopyArray4([
      0,
      0,
      0,
      0
    ]);
    initialRenderPass.toClearColorBuffer = true;
    initialRenderPass.toClearDepthBuffer = true;
    initialRenderPass.tryToSetUniqueName("InitialRenderPass", true);
    expression.addRenderPasses([
      initialRenderPass
    ]);
    if (!this.__isSimple) {
      const initialRenderPassForFrameBuffer = new RenderPass();
      initialRenderPassForFrameBuffer.clearColor = Vector4.fromCopyArray4([
        0,
        0,
        0,
        0
      ]);
      initialRenderPassForFrameBuffer.toClearColorBuffer = true;
      initialRenderPassForFrameBuffer.toClearDepthBuffer = true;
      initialRenderPassForFrameBuffer.setFramebuffer(this.__getMainFrameBuffer().unwrapForce());
      initialRenderPassForFrameBuffer.tryToSetUniqueName("InitialRenderPassForFrameBuffer", true);
      expression.addRenderPasses([
        initialRenderPassForFrameBuffer
      ]);
    }
    if (oFrameDepthMoment.has()) {
      const frameDepthMoment = oFrameDepthMoment.get();
      const initialRenderPassForDepthMoment = new RenderPass();
      initialRenderPassForDepthMoment.clearColor = Vector4.fromCopyArray4([
        1,
        1,
        1,
        1
      ]);
      initialRenderPassForDepthMoment.toClearColorBuffer = true;
      initialRenderPassForDepthMoment.toClearDepthBuffer = true;
      initialRenderPassForDepthMoment.setFramebuffer(frameDepthMoment);
      initialRenderPassForDepthMoment.tryToSetUniqueName("InitialRenderPassForDepthMoment", true);
      expression.addRenderPasses([
        initialRenderPassForDepthMoment
      ]);
    }
    return expression;
  }
  __createRenderTargets(canvasWidth, canvasHeight) {
    const rnXRModule = ModuleManager.getInstance().getModule("xr");
    const webXRSystem = rnXRModule == null ? void 0 : rnXRModule.WebXRSystem.getInstance();
    const cgApiResourceRepository = CGAPIResourceRepository.getCgApiResourceRepository();
    if (Is.exist(webXRSystem) && webXRSystem.isWebXRMode && cgApiResourceRepository.isSupportMultiViewVRRendering()) {
      const framebufferMultiView = RenderableHelper.createFrameBufferTextureArray({
        width: canvasWidth / 2,
        height: canvasHeight,
        arrayLength: 2,
        level: 0,
        internalFormat: this.__isBloom ? TextureFormat.R11F_G11F_B10F : TextureFormat.RGBA8,
        format: this.__isBloom ? PixelFormat.RGB : PixelFormat.RGBA,
        type: this.__isBloom ? ComponentType.Float : ComponentType.UnsignedByte
      });
      framebufferMultiView.tryToSetUniqueName("FramebufferTargetOfToneMappingMultiView", true);
      const framebufferMultiViewBlit = RenderableHelper.createFrameBuffer({
        width: canvasWidth,
        height: canvasHeight,
        textureNum: 1,
        textureFormats: [
          this.__isBloom ? TextureFormat.R11F_G11F_B10F : TextureFormat.RGBA8
        ],
        createDepthBuffer: false
      });
      framebufferMultiViewBlit.tryToSetUniqueName("FramebufferTargetOfToneMappingMultiViewBlit", true);
      const framebufferMultiViewBlitBackBuffer = RenderableHelper.createFrameBuffer({
        width: canvasWidth,
        height: canvasHeight,
        textureNum: 1,
        textureFormats: [
          this.__isBloom ? TextureFormat.R11F_G11F_B10F : TextureFormat.RGBA8
        ],
        createDepthBuffer: false
      });
      framebufferMultiViewBlit.tryToSetUniqueName("FramebufferTargetOfToneMappingMultiViewBlitBackBuffer", true);
      this.__oFrameBufferMultiView = new Some(framebufferMultiView);
      this.__oFrameBufferMultiViewBlit = new Some(framebufferMultiViewBlit);
      this.__oFrameBufferMultiViewBlitBackBuffer = new Some(framebufferMultiViewBlitBackBuffer);
      this.__oFrameBufferMsaa = new None();
      this.__oFrameBufferResolve = new None();
      this.__oFrameBufferResolveForReference = new None();
    } else {
      const framebufferMsaa = RenderableHelper.createFrameBufferMSAA({
        width: canvasWidth,
        height: canvasHeight,
        colorBufferNum: 1,
        colorFormats: [
          this.__isBloom ? TextureFormat.R11F_G11F_B10F : TextureFormat.RGBA8
        ],
        sampleCountMSAA: 4,
        depthBufferFormat: TextureFormat.Depth32F
      });
      framebufferMsaa.tryToSetUniqueName("FramebufferTargetOfToneMappingMsaa", true);
      const framebufferResolve = RenderableHelper.createFrameBuffer({
        width: canvasWidth,
        height: canvasHeight,
        textureNum: 1,
        textureFormats: [
          this.__isBloom ? TextureFormat.R11F_G11F_B10F : TextureFormat.RGBA8
        ],
        createDepthBuffer: true,
        depthTextureFormat: TextureFormat.Depth32F
      });
      framebufferResolve.tryToSetUniqueName("FramebufferTargetOfToneMappingResolve", true);
      const framebufferResolveForReference = RenderableHelper.createFrameBuffer({
        width: canvasWidth,
        height: canvasHeight,
        textureNum: 1,
        textureFormats: [
          this.__isBloom ? TextureFormat.R11F_G11F_B10F : TextureFormat.RGBA8
        ],
        createDepthBuffer: false
      });
      framebufferResolveForReference.tryToSetUniqueName("FramebufferTargetOfToneMappingResolveForReference", true);
      this.__oFrameBufferMultiView = new None();
      this.__oFrameBufferMultiViewBlit = new None();
      this.__oFrameBufferMultiViewBlitBackBuffer = new None();
      this.__oFrameBufferMsaa = new Some(framebufferMsaa);
      this.__oFrameBufferResolve = new Some(framebufferResolve);
      this.__oFrameBufferResolveForReference = new Some(framebufferResolveForReference);
    }
  }
  __setupGenerateMipmapsExpression(resolveFramebuffer2) {
    const expression = new Expression();
    expression.tryToSetUniqueName("GenerateMipmaps", true);
    const renderPass = new RenderPass();
    expression.addRenderPasses([
      renderPass
    ]);
    renderPass.tryToSetUniqueName("GenerateMipmaps", true);
    renderPass.toClearDepthBuffer = false;
    renderPass.setPostRenderFunction(function() {
      const renderTargetTexture = resolveFramebuffer2.getColorAttachedRenderTargetTexture(0);
      renderTargetTexture.generateMipmaps();
    });
    return new Some(expression);
  }
  __setupMultiViewBlitBackBufferExpression(multiViewFrameBuffer) {
    const expression = new Expression();
    expression.tryToSetUniqueName("MultiViewBlitBackBuffer", true);
    const renderPass = new RenderPass();
    expression.addRenderPasses([
      renderPass
    ]);
    renderPass.tryToSetUniqueName("MultiViewBlitBackBuffer", true);
    renderPass.toClearDepthBuffer = false;
    renderPass.setPostRenderFunction(() => {
      if (this.__oFrameBufferMultiViewBlitBackBuffer.has()) {
        const texture = this.__oFrameBufferMultiViewBlitBackBuffer.unwrapForce().colorAttachments[0];
        multiViewFrameBuffer.colorAttachments[0].blitToTexture2dFromTexture2dArrayFake(texture);
        texture.generateMipmaps();
      }
    });
    return new Some(expression);
  }
  __setupMultiViewBlitExpression(multiViewFrameBuffer) {
    const expression = new Expression();
    expression.tryToSetUniqueName("MultiViewBlit", true);
    const renderPass = new RenderPass();
    expression.addRenderPasses([
      renderPass
    ]);
    renderPass.tryToSetUniqueName("MultiViewBlit", true);
    renderPass.toClearDepthBuffer = false;
    renderPass.setPostRenderFunction(() => {
      if (this.__oFrameBufferMultiViewBlit.has()) {
        const texture = this.__oFrameBufferMultiViewBlit.unwrapForce().colorAttachments[0];
        multiViewFrameBuffer.colorAttachments[0].blitToTexture2dFromTexture2dArrayFake(texture);
      }
    });
    return new Some(expression);
  }
  __setupToneMappingExpression(toneMappingTargetRenderTargetTexture) {
    const expressionToneMappingEffect = new Expression();
    const materialToneMapping = MaterialHelper.createToneMappingMaterial();
    this.__oToneMappingMaterial = new Some(materialToneMapping);
    this.setToneMappingType(this.__toneMappingType);
    const renderPassToneMapping = RenderPassHelper.createScreenDrawRenderPassWithBaseColorTexture(materialToneMapping, toneMappingTargetRenderTargetTexture);
    renderPassToneMapping.tryToSetUniqueName("renderPassToneMapping", true);
    renderPassToneMapping.toClearColorBuffer = false;
    renderPassToneMapping.toClearDepthBuffer = false;
    renderPassToneMapping.isDepthTest = false;
    renderPassToneMapping.clearColor = Vector4.fromCopyArray4([
      0,
      0,
      0,
      0
    ]);
    renderPassToneMapping.isVrRendering = false;
    renderPassToneMapping.isOutputForVr = false;
    const renderPassToneMappingVr = RenderPassHelper.createScreenDrawRenderPassWithBaseColorTexture(materialToneMapping, toneMappingTargetRenderTargetTexture);
    renderPassToneMappingVr.tryToSetUniqueName("renderPassToneMappingVr", true);
    renderPassToneMappingVr.toClearColorBuffer = false;
    renderPassToneMappingVr.toClearDepthBuffer = false;
    renderPassToneMappingVr.isDepthTest = false;
    renderPassToneMappingVr.clearColor = Vector4.fromCopyArray4([
      0,
      0,
      0,
      0
    ]);
    renderPassToneMappingVr.isVrRendering = false;
    renderPassToneMappingVr.isOutputForVr = true;
    expressionToneMappingEffect.addRenderPasses([
      renderPassToneMapping,
      renderPassToneMappingVr
    ]);
    return expressionToneMappingEffect;
  }
  __setupDepthMomentFramebuffer(shadowMapSize) {
    return new Some(RenderableHelper.createFrameBuffer({
      width: shadowMapSize,
      height: shadowMapSize,
      textureNum: 1,
      textureFormats: [
        TextureFormat.RG32F
      ],
      createDepthBuffer: true,
      depthTextureFormat: TextureFormat.Depth32F
    }));
  }
  async __setIblInner() {
    for (const expression of this.__expressions) {
      for (const renderPass of expression.renderPasses) {
        for (const entity of renderPass.entities) {
          const meshRendererComponent = entity.tryToGetMeshRenderer();
          if (Is.exist(meshRendererComponent)) {
            await meshRendererComponent.setIBLCubeMap(this.__oDiffuseCubeTexture.unwrapOrUndefined(), this.__oSpecularCubeTexture.unwrapOrUndefined());
          }
        }
      }
    }
  }
  async __setIblInnerForTransparentOnly() {
    for (const expression of this.__transparentOnlyExpressions) {
      for (const renderPass of expression.renderPasses) {
        for (const entity of renderPass.entities) {
          const meshRendererComponent = entity.tryToGetMeshRenderer();
          if (Is.exist(meshRendererComponent)) {
            await meshRendererComponent.setIBLCubeMap(this.__oDiffuseCubeTexture.unwrapOrUndefined(), this.__oSpecularCubeTexture.unwrapOrUndefined());
          }
        }
      }
    }
  }
  setToneMappingType(type) {
    if (!this.__oToneMappingMaterial.has()) {
      return;
    }
    this.__toneMappingType = type;
    this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_KHRONOS_PBR_NEUTRAL");
    this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_REINHARD");
    this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_GT_TONEMAP");
    this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_ACES_NARKOWICZ");
    this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_ACES_HILL");
    this.__oToneMappingMaterial.get().removeShaderDefine("RN_USE_ACES_HILL_EXPOSURE_BOOST");
    if (type === ToneMappingType.KhronosPbrNeutral) {
      this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_KHRONOS_PBR_NEUTRAL");
    } else if (type === ToneMappingType.Reinhard) {
      this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_REINHARD");
    } else if (type === ToneMappingType.GT_ToneMap) {
      this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_GT_TONEMAP");
    } else if (type === ToneMappingType.ACES_Narkowicz) {
      this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_ACES_NARKOWICZ");
    } else if (type === ToneMappingType.ACES_Hill) {
      this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_ACES_HILL");
    } else if (type === ToneMappingType.ACES_Hill_Exposure_Boost) {
      this.__oToneMappingMaterial.get().addShaderDefine("RN_USE_ACES_HILL_EXPOSURE_BOOST");
    }
  }
  /**
  * setUp Frame
  *
  * @remarks
  * This method adds expressions to the frame.
  */
  __setExpressions() {
    if (this.__oFrame.doesNotHave()) {
      console.error("Frame is not set.");
      return;
    }
    const frame = this.__oFrame.get();
    frame.clearExpressions();
    frame.addExpression(this.getInitialExpression());
    if (!this.__isSimple) {
      for (const exp of this.__depthMomentExpressions) {
        frame.addExpression(exp);
      }
    }
    for (const exp of this.__expressions) {
      frame.addExpression(exp);
    }
    if (!this.__isSimple && this.__oGenerateMipmapsExpression.has()) {
      frame.addExpression(this.__oGenerateMipmapsExpression.get());
    }
    if (!this.__isSimple && this.__oMultiViewBlitBackBufferExpression.has()) {
      frame.addExpression(this.__oMultiViewBlitBackBufferExpression.get());
    }
    for (const exp of this.__transparentOnlyExpressions) {
      frame.addExpression(exp);
    }
    if (!this.__isSimple && this.__oMultiViewBlitExpression.has()) {
      frame.addExpression(this.__oMultiViewBlitExpression.get());
    }
    if (!this.__isSimple && this.__isBloom && this.__oBloomExpression.has()) {
      frame.addExpression(this.__oBloomExpression.get());
    }
    if (!this.__isSimple && this.__oToneMappingExpression.has()) {
      frame.addExpression(this.getToneMappingExpression());
    }
  }
};
__name(_ForwardRenderPipeline, "ForwardRenderPipeline");
var ForwardRenderPipeline = _ForwardRenderPipeline;

// src/foundation/renderer/index.ts
init_CGAPIResourceRepository();
init_Expression();
init_Frame();
init_RenderPass();
init_RenderingCommonMethods();

// src/foundation/index.ts
init_system();

// src/webgl/index.ts
init_WebGLContextWrapper();
init_WebGLExtension();
init_WebGLResourceRepository();
init_WebGLStrategyCommonMethod();
init_WebGLStrategyDataTexture();
init_WebGLStrategyUniform();
init_getRenderingStrategy();

// src/webgl/shaders/index.ts
init_CommonShaderPart();

// src/webgl/shaders/nodes/ClassicShadingShader.ts
init_CommonShaderPart();
init_Config();
init_ShaderNode();
var _ClassicShadingShader = class _ClassicShadingShader extends CommonShaderPart {
  constructor() {
    super();
    __publicField(this, "vertexShaderBody", `


  `);
  }
  static getInstance() {
    if (!this.__instance) {
      this.__instance = new _ClassicShadingShader();
    }
    return this.__instance;
  }
  get vertexShaderDefinitions() {
    return `

`;
  }
  get pixelShaderDefinitions() {
    return `
uniform int u_shadingModel;
uniform float u_shininess;

struct Light {
  vec4 lightPosition;
  vec4 lightDirection;
  vec4 lightIntensity;
};
uniform Light u_lights[${Config.maxLightNumberInShader}];
uniform int u_lightNumber;
uniform vec3 u_viewPosition;


bool classicShading(
  in vec3 diffuseColor,
  in vec3 position_inWorld,
  in vec3 normal_inWorld,
  out vec3 outColor
  )
{
  // Lighting
  outColor = vec3(0.0, 0.0, 0.0);
  if (u_shadingModel > 0) {

    vec3 diffuse = vec3(0.0, 0.0, 0.0);
    vec3 specular = vec3(0.0, 0.0, 0.0);
    for (int i = 0; i < ${Config.maxLightNumberInShader}; i++) {
      if (i >= u_lightNumber) {
        break;
      }

      vec3 lightDirection = u_lights[i].lightDirection.xyz;
      float lightType = u_lights[i].lightPosition.w;
      float spotCosCutoff = u_lights[i].lightDirection.w;
      float spotExponent = u_lights[i].lightIntensity.w;

      if (0.75 < lightType) { // is pointlight or spotlight
        lightDirection = normalize(u_lights[i].lightPosition.xyz - position_inWorld.xyz);
      }
      float spotEffect = 1.0;
      if (lightType > 1.75) { // is spotlight
        spotEffect = dot(u_lights[i].lightDirection.xyz, lightDirection);
        if (spotEffect > spotCosCutoff) {
          spotEffect = pow(spotEffect, spotExponent);
        } else {
          spotEffect = 0.0;
        }
      }

      vec3 incidentLight = spotEffect * u_lights[i].lightIntensity.xyz;
//      incidentLight *= M_PI;

      normal_inWorld = normalize(normal_inWorld);

      diffuse += diffuseColor * max(0.0, dot(normal_inWorld, lightDirection)) * incidentLight;

      if (u_shadingModel == 2) {// BLINN
        // ViewDirection
        vec3 viewDirection = normalize(u_viewPosition - position_inWorld.xyz);
        vec3 halfVector = normalize(lightDirection + viewDirection);
        specular += pow(max(0.0, dot(halfVector, normal_inWorld)), u_shininess);
      } else if (u_shadingModel == 3) { // PHONG
        vec3 viewDirection = normalize(u_viewPosition - position_inWorld.xyz);
        vec3 R = reflect(lightDirection, normal_inWorld);
        specular += pow(max(0.0, dot(R, viewDirection)), u_shininess);
      }

    }

    outColor = diffuse + specular;
  } else {
    outColor = diffuseColor;
  }
}

    `;
  }
  get pixelShaderBody() {
    return "";
  }
  get attributeNames() {
    return [];
  }
  get attributeSemantics() {
    return [];
  }
  get attributeCompositions() {
    return [];
  }
};
__name(_ClassicShadingShader, "ClassicShadingShader");
__publicField(_ClassicShadingShader, "__instance");
__publicField(_ClassicShadingShader, "materialElement", ShaderNode.PBRShading);
var ClassicShadingShader = _ClassicShadingShader;

// src/webgl/shaders/nodes/TextureFetchShader.ts
init_CommonShaderPart();
var _TextureFetchShader = class _TextureFetchShader extends CommonShaderPart {
  constructor() {
    super();
    __publicField(this, "__materialNodeUid", 0);
    __publicField(this, "vertexShaderBody", `
  `);
  }
  set materialNodeUid(materialNodeUid) {
    this.__materialNodeUid = materialNodeUid;
  }
  getPixelShaderBody() {
    return `
    `;
  }
  get vertexShaderDefinitions() {
    return "";
  }
  get pixelShaderDefinitions() {
    return "";
  }
  get attributeNames() {
    return [];
  }
  get attributeSemantics() {
    return [];
  }
  get attributeCompositions() {
    return [];
  }
};
__name(_TextureFetchShader, "TextureFetchShader");
__publicField(_TextureFetchShader, "__instance");
var TextureFetchShader = _TextureFetchShader;

// src/webgl/shaders/nodes/VaryingVariableShader.ts
init_CommonShaderPart();
var _VaryingVariableShader = class _VaryingVariableShader extends CommonShaderPart {
  constructor(__functionName, __compositionType, __componentType) {
    super();
    __publicField(this, "__functionName");
    __publicField(this, "__compositionType");
    __publicField(this, "__componentType");
    __publicField(this, "__variableName");
    this.__functionName = __functionName;
    this.__compositionType = __compositionType;
    this.__componentType = __componentType;
    this.__variableName = "";
  }
  setVariableName(name) {
    this.__variableName = name;
  }
  get vertexShaderDefinitions() {
    return `
    out ${this.__compositionType.getGlslStr(this.__componentType)} ${this.__variableName};
    void ${this.__functionName}(
      in ${this.__compositionType.getGlslStr(this.__componentType)} value) {
      ${this.__variableName} = value;
    }
    `;
  }
  get pixelShaderDefinitions() {
    return `
    in ${this.__compositionType.getGlslStr(this.__componentType)} ${this.__variableName};
    void ${this.__functionName}(
      out ${this.__compositionType.getGlslStr(this.__componentType)} outValue) {
      outValue = ${this.__variableName};
    }
    `;
  }
  get attributeNames() {
    return [];
  }
  get attributeSemantics() {
    return [];
  }
  get attributeCompositions() {
    return [];
  }
};
__name(_VaryingVariableShader, "VaryingVariableShader");
var VaryingVariableShader = _VaryingVariableShader;

// src/webgl/textureLoader/index.ts
init_KTX2TextureLoader();

// src/webgpu/index.ts
init_WebGpuDeviceWrapper();
init_WebGpuResourceRepository();
init_WebGpuStrategyBasic();

// src/import.ts
init_types();

// src/effekseer/index.ts
init_main3();
init_EffekseerComponent();

// src/xr/index.ts
init_WebXRInput();
init_WebXRSystem();

// src/xr/getModule.ts
init_ModuleManager();
function getWebXRSystem() {
  const moduleName = "xr";
  const moduleManager = ModuleManager.getInstance();
  const xrModule = moduleManager.getModule(moduleName);
  const webXRSystem = xrModule.WebXRSystem.getInstance();
  return webXRSystem;
}
__name(getWebXRSystem, "getWebXRSystem");

// src/xr/index.ts
init_main5();

// src/import.ts
init_version();

// src/index.ts
var index_default = import_exports;
export {
  index_default as default
};
//# sourceMappingURL=index.js.map