import { ShaderityObject } from 'shaderity';
import { MotionController } from 'webxr-input-profiles/packages/motion-controllers/src/motionController.js';

type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
type FloatTypedArray = Float32Array | Float64Array;
type IntegerTypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array;
type ArrayType = TypedArray | Array<number>;
type TypedArrayConstructor = Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor;
type FloatTypedArrayConstructor = Float32ArrayConstructor | Float64ArrayConstructor;
type Array16<T> = [T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T];
type Array9<T> = [T, T, T, T, T, T, T, T, T];
type primitives = number | string | boolean | null | undefined;
type Array4<T> = [T, T, T, T];
type Array3<T> = [T, T, T];
type Array2<T> = [T, T];
type Array1<T> = [T];
type Array1to4<T> = Array1<T> | Array2<T> | Array3<T> | Array4<T>;
type VectorComponentN = 1 | 2 | 3 | 4;
type VectorAndSquareMatrixComponentN = 1 | 2 | 3 | 4 | 9 | 16;
type SquareMatrixComponentN = 4 | 9 | 16;
type Index = number;
type IndexOf16Bytes = number;
type IndexOf4Bytes = number;
type Offset = number;
type Size = number;
type Count = number;
type Byte$1 = number;
type Second = number;
type MilliSecond = number;
type ObjectUID = Index;
type PrimitiveUID = Index;
type EntityUID = Index;
type ComponentTID = Index;
type ComponentSID = Index;
type MaterialNodeUID$1 = Index;
type MaterialUID = Index;
type MaterialSID = Index;
type MaterialTID = Index;
type TextureUID = Index;
type MeshUID = Index;
type CameraSID = Index;
type RenderPassUID = Index;
type WebGLResourceHandle = number;
type WebGPUResourceHandle = number;
type CGAPIResourceHandle = WebGLResourceHandle;
type RnTags = {
    [s: string]: any;
};
type ColorComponentLetter = 'r' | 'g' | 'b' | 'a';

interface EnumIO {
    readonly index: number;
    readonly str: string;
    readonly symbol: symbol;
    toString(): string;
    toJSON(): number;
}
declare class EnumClass implements EnumIO {
    readonly index: number;
    readonly symbol: symbol;
    readonly str: string;
    private static __indices;
    private static __strings;
    constructor({ index, str, noCheckStrUnique, }: {
        index: number;
        str: string;
        noCheckStrUnique?: boolean;
    });
    toString(): string;
    toJSON(): number;
}
declare function _from({ typeList, index, }: {
    typeList: Array<EnumIO>;
    index: number;
}): EnumIO | undefined;
declare function _fromString({ typeList, str, }: {
    typeList: Array<EnumIO>;
    str: string;
}): EnumIO | undefined;
declare function _fromStringCaseSensitively({ typeList, str, }: {
    typeList: Array<EnumIO>;
    str: string;
}): EnumIO | undefined;

interface CompositionTypeEnum extends EnumIO {
    webgpu: string;
    wgsl: string;
    getNumberOfComponents(): Count;
    getGlslStr(componentType: ComponentTypeEnum): string;
    getGlslInitialValue(componentType: ComponentTypeEnum): string;
    toWGSLType(componentType: ComponentTypeEnum): string;
    getWgslInitialValue(componentType: ComponentTypeEnum): string;
    getVec4SizeOfProperty(): IndexOf16Bytes;
}
declare class CompositionTypeClass<TypeName extends string> extends EnumClass implements CompositionTypeEnum {
    readonly __numberOfComponents: number;
    readonly __glslStr: string;
    readonly __hlslStr: string;
    readonly __webgpuStr: string;
    readonly __wgslStr: string;
    readonly __isArray: boolean;
    readonly __vec4SizeOfProperty: IndexOf16Bytes;
    readonly __dummyStr: TypeName;
    constructor({ index, str, glslStr, hlslStr, wgsl, webgpu, numberOfComponents, vec4SizeOfProperty, isArray, }: {
        index: number;
        str: TypeName;
        glslStr: string;
        hlslStr: string;
        wgsl: string;
        webgpu: string;
        numberOfComponents: number;
        vec4SizeOfProperty: IndexOf16Bytes;
        isArray?: boolean;
    });
    get webgpu(): string;
    get wgsl(): string;
    getNumberOfComponents(): Count;
    getGlslStr(componentType: ComponentTypeEnum): string;
    getGlslInitialValue(componentType: ComponentTypeEnum): string;
    getWgslInitialValue(componentType: ComponentTypeEnum): string;
    toWGSLType(componentType: ComponentTypeEnum): string;
    getVec4SizeOfProperty(): IndexOf16Bytes;
}
declare const Scalar$1: CompositionTypeClass<"SCALAR">;
declare const Vec2: CompositionTypeClass<"VEC2">;
declare const Vec3: CompositionTypeClass<"VEC3">;
declare const Vec4: CompositionTypeClass<"VEC4">;
declare const Mat2: CompositionTypeClass<"MAT2">;
declare const Mat3: CompositionTypeClass<"MAT3">;
declare const Mat4: CompositionTypeClass<"MAT4">;
type VectorCompositionTypes = typeof Scalar$1 | typeof Vec2 | typeof Vec3 | typeof Vec4;
declare function from$u(index: number): CompositionTypeEnum;
declare function fromString$k(str: string): CompositionTypeEnum;
declare function vectorFrom(componentN: number): CompositionTypeEnum;
declare function fromGlslString$1(str_: string): CompositionTypeEnum;
declare function fromWgslString$1(str_: string): CompositionTypeEnum;
declare function toGltf2AccessorCompositionTypeString(componentN: VectorAndSquareMatrixComponentN): Gltf2AccessorCompositionTypeString;
declare function toGltf2AnimationAccessorCompositionTypeString(componentN: VectorComponentN): Gltf2AccessorCompositionTypeString;
declare function toGltf2SquareMatrixAccessorCompositionTypeString(componentN: SquareMatrixComponentN): Gltf2AccessorCompositionTypeString;
type Gltf2AnimationAccessorCompositionType = typeof Scalar$1 | typeof Vec2 | typeof Vec3 | typeof Vec4;
type Gltf2AccessorCompositionType = typeof Scalar$1 | typeof Vec2 | typeof Vec3 | typeof Vec4 | typeof Mat2 | typeof Mat3 | typeof Mat4;
declare function toGltf2AnimationAccessorCompositionType(componentN: VectorComponentN): Gltf2AnimationAccessorCompositionType;
declare function isArray(compositionType: CompositionTypeEnum): boolean;
declare function isTexture(compositionType: CompositionTypeEnum): boolean;
declare const CompositionType: Readonly<{
    Unknown: CompositionTypeClass<"UNKNOWN">;
    Scalar: CompositionTypeClass<"SCALAR">;
    Vec2: CompositionTypeClass<"VEC2">;
    Vec3: CompositionTypeClass<"VEC3">;
    Vec4: CompositionTypeClass<"VEC4">;
    Mat2: CompositionTypeClass<"MAT2">;
    Mat3: CompositionTypeClass<"MAT3">;
    Mat4: CompositionTypeClass<"MAT4">;
    ScalarArray: CompositionTypeClass<"SCALAR_ARRAY">;
    Vec2Array: CompositionTypeClass<"VEC2_ARRAY">;
    Vec3Array: CompositionTypeClass<"VEC3_ARRAY">;
    Vec4Array: CompositionTypeClass<"VEC4_ARRAY">;
    Mat2Array: CompositionTypeClass<"MAT2_ARRAY">;
    Mat3Array: CompositionTypeClass<"MAT3_ARRAY">;
    Mat4Array: CompositionTypeClass<"MAT4_ARRAY">;
    Texture2D: CompositionTypeClass<"TEXTURE_2D">;
    Texture2DShadow: CompositionTypeClass<"TEXTURE_2D_SHADOW">;
    TextureCube: CompositionTypeClass<"TEXTURE_CUBE_MAP">;
    Texture2DRect: CompositionTypeClass<"TEXTURE_2D_RECT">;
    Texture2DArray: CompositionTypeClass<"TEXTURE_2D_ARRAY">;
    Mat4x3Array: CompositionTypeClass<"MAT4x3_ARRAY">;
    from: typeof from$u;
    fromString: typeof fromString$k;
    vectorFrom: typeof vectorFrom;
    fromGlslString: typeof fromGlslString$1;
    fromWgslString: typeof fromWgslString$1;
    isArray: typeof isArray;
    isTexture: typeof isTexture;
    toGltf2AnimationAccessorCompositionType: typeof toGltf2AnimationAccessorCompositionType;
    toGltf2AccessorCompositionTypeString: typeof toGltf2AccessorCompositionTypeString;
    toGltf2AnimationAccessorCompositionTypeString: typeof toGltf2AnimationAccessorCompositionTypeString;
    toGltf2SquareMatrixAccessorCompositionTypeString: typeof toGltf2SquareMatrixAccessorCompositionTypeString;
}>;

type ShaderTypeEnum = EnumIO;
declare function from$t(index: number): ShaderTypeEnum;
declare function fromString$j(str: string): ShaderTypeEnum;
declare const ShaderType: Readonly<{
    VertexShader: EnumIO;
    PixelShader: EnumIO;
    VertexAndPixelShader: EnumIO;
    ComputeShader: EnumIO;
    from: typeof from$t;
    fromString: typeof fromString$j;
}>;

type ShaderSemanticsInfo = {
    semantic: ShaderSemanticsName;
    compositionType: CompositionTypeEnum;
    componentType: ComponentTypeEnum;
    stage: ShaderTypeEnum;
    min: number;
    max: number;
    initialValue?: any;
    isInternalSetting?: boolean;
    arrayLength?: Count;
    soloDatum?: boolean;
    needUniformInDataTextureMode?: boolean;
    valueStep?: number;
    xName?: string;
    yName?: string;
    zName?: string;
    wName?: string;
};
declare function calcAlignedByteLength(semanticInfo: ShaderSemanticsInfo): number;

type ShaderSemanticsIndex = number;
type ShaderSemanticsName = string;
interface ShaderSemanticsEnum extends EnumIO {
    str: string;
}
declare class ShaderSemanticsClass extends EnumClass implements ShaderSemanticsEnum {
    private static __indexCount;
    static readonly _scale = 10000;
    private static __classes;
    constructor({ str }: {
        index?: number;
        str: string;
    });
    static getShaderSemanticByIndex(index: ShaderSemanticsIndex): ShaderSemanticsClass;
    static isNonArrayShaderSemanticIndex(index: ShaderSemanticsIndex): boolean;
    static isArrayAndZeroIndexShaderSemanticIndex(index: ShaderSemanticsIndex): boolean;
    static isArrayAndNonZeroIndexShaderSemanticIndex(index: ShaderSemanticsIndex): boolean;
    static getIndexCount(): number;
}
declare function from$s(index: ShaderSemanticsIndex): ShaderSemanticsEnum;
declare function fromString$i(str: string): ShaderSemanticsEnum;
declare function fromStringCaseSensitively(str: string): ShaderSemanticsEnum;
type getShaderPropertyFunc = (_materialTypeName: string, info: ShaderSemanticsInfo, _isGlobalData: boolean, _isWebGL2: boolean) => string;
/**
 * @internal
 */
declare function _getPropertyIndex2(shaderSemantic: ShaderSemanticsEnum): number;
declare const ShaderSemantics: Readonly<{
    from: typeof from$s;
    fromString: typeof fromString$i;
    fromStringCaseSensitively: typeof fromStringCaseSensitively;
    WorldMatrix: ShaderSemanticsEnum;
    ViewMatrix: ShaderSemanticsEnum;
    IsBillboard: ShaderSemanticsEnum;
    EnableViewMatrix: ShaderSemanticsEnum;
    ProjectionMatrix: ShaderSemanticsEnum;
    NormalMatrix: ShaderSemanticsEnum;
    BoneMatrix: ShaderSemanticsEnum;
    BaseColorFactor: ShaderSemanticsEnum;
    BaseColorTexture: ShaderSemanticsEnum;
    NormalTexture: ShaderSemanticsEnum;
    MetallicRoughnessTexture: ShaderSemanticsEnum;
    OcclusionTexture: ShaderSemanticsEnum;
    EmissiveFactor: ShaderSemanticsEnum;
    EmissiveTexture: ShaderSemanticsEnum;
    LightNumber: ShaderSemanticsEnum;
    LightPosition: ShaderSemanticsEnum;
    LightDirection: ShaderSemanticsEnum;
    LightIntensity: ShaderSemanticsEnum;
    LightProperty: ShaderSemanticsEnum;
    MetallicRoughnessFactor: ShaderSemanticsEnum;
    BrdfLutTexture: ShaderSemanticsEnum;
    DiffuseEnvTexture: ShaderSemanticsEnum;
    SpecularEnvTexture: ShaderSemanticsEnum;
    SheenEnvTexture: ShaderSemanticsEnum;
    InverseEnvironment: ShaderSemanticsEnum;
    IBLParameter: ShaderSemanticsEnum;
    ViewPosition: ShaderSemanticsEnum;
    Wireframe: ShaderSemanticsEnum;
    DiffuseColorFactor: ShaderSemanticsEnum;
    DiffuseColorTexture: ShaderSemanticsEnum;
    Shininess: ShaderSemanticsEnum;
    ShadingModel: ShaderSemanticsEnum;
    SkinningMode: ShaderSemanticsEnum;
    GeneralTexture: ShaderSemanticsEnum;
    VertexAttributesExistenceArray: ShaderSemanticsEnum;
    BoneQuaternion: ShaderSemanticsEnum;
    BoneTranslateScale: ShaderSemanticsEnum;
    BoneTranslatePackedQuat: ShaderSemanticsEnum;
    BoneScalePackedQuat: ShaderSemanticsEnum;
    BoneCompressedChunk: ShaderSemanticsEnum;
    BoneCompressedInfo: ShaderSemanticsEnum;
    PointSize: ShaderSemanticsEnum;
    ColorEnvTexture: ShaderSemanticsEnum;
    PointDistanceAttenuation: ShaderSemanticsEnum;
    HDRIFormat: ShaderSemanticsEnum;
    ScreenInfo: ShaderSemanticsEnum;
    DepthTexture: ShaderSemanticsEnum;
    LightViewProjectionMatrix: ShaderSemanticsEnum;
    Anisotropy: ShaderSemanticsEnum;
    ClearCoatParameter: ShaderSemanticsEnum;
    SheenColorFactor: ShaderSemanticsEnum;
    SheenColorTexture: ShaderSemanticsEnum;
    SheenRoughnessFactor: ShaderSemanticsEnum;
    SheenRoughnessTexture: ShaderSemanticsEnum;
    SheenLutTexture: ShaderSemanticsEnum;
    SpecularGlossinessFactor: ShaderSemanticsEnum;
    SpecularGlossinessTexture: ShaderSemanticsEnum;
    ClearCoatFactor: ShaderSemanticsEnum;
    ClearCoatTexture: ShaderSemanticsEnum;
    ClearCoatRoughnessFactor: ShaderSemanticsEnum;
    ClearCoatRoughnessTexture: ShaderSemanticsEnum;
    ClearCoatNormalTexture: ShaderSemanticsEnum;
    TransmissionFactor: ShaderSemanticsEnum;
    TransmissionTexture: ShaderSemanticsEnum;
    BackBufferTexture: ShaderSemanticsEnum;
    BackBufferTextureSize: ShaderSemanticsEnum;
    ThicknessFactor: ShaderSemanticsEnum;
    ThicknessTexture: ShaderSemanticsEnum;
    AttenuationDistance: ShaderSemanticsEnum;
    AttenuationColor: ShaderSemanticsEnum;
    getShaderProperty: getShaderPropertyFunc;
    EntityUID: ShaderSemanticsEnum;
    MorphTargetNumber: ShaderSemanticsEnum;
    DataTextureMorphOffsetPosition: ShaderSemanticsEnum;
    MorphWeights: ShaderSemanticsEnum;
    CurrentComponentSIDs: ShaderSemanticsEnum;
    AlphaCutoff: ShaderSemanticsEnum;
    AlphaTexture: ShaderSemanticsEnum;
    MakeOutputSrgb: ShaderSemanticsEnum;
    FramebufferSize: ShaderSemanticsEnum;
    IsOutputHDR: ShaderSemanticsClass;
    BaseColorTextureTransform: ShaderSemanticsClass;
    BaseColorTextureRotation: ShaderSemanticsClass;
    NormalTextureTransform: ShaderSemanticsClass;
    NormalTextureRotation: ShaderSemanticsClass;
    MetallicRoughnessTextureTransform: ShaderSemanticsClass;
    MetallicRoughnessTextureRotation: ShaderSemanticsClass;
    NormalTexcoordIndex: ShaderSemanticsClass;
    BaseColorTexcoordIndex: ShaderSemanticsClass;
    MetallicRoughnessTexcoordIndex: ShaderSemanticsClass;
    OcclusionTexcoordIndex: ShaderSemanticsClass;
    OcclusionTextureTransform: ShaderSemanticsClass;
    OcclusionTextureRotation: ShaderSemanticsClass;
    EmissiveTexcoordIndex: ShaderSemanticsClass;
    EmissiveTextureTransform: ShaderSemanticsClass;
    EmissiveTextureRotation: ShaderSemanticsClass;
    NormalScale: ShaderSemanticsClass;
    OcclusionStrength: ShaderSemanticsClass;
    envRotation: ShaderSemanticsClass;
    EnvHdriFormat: ShaderSemanticsClass;
    VrState: ShaderSemanticsClass;
    EnableLinearToSrgb: ShaderSemanticsClass;
    SpecularFactor: ShaderSemanticsClass;
    SpecularTexture: ShaderSemanticsClass;
    SpecularColorFactor: ShaderSemanticsClass;
    SpecularColorTexture: ShaderSemanticsClass;
    Ior: ShaderSemanticsClass;
    DepthBiasPV: ShaderSemanticsClass;
    ClearCoatTextureTransform: ShaderSemanticsClass;
    ClearCoatTextureRotation: ShaderSemanticsClass;
    ClearCoatRoughnessTextureTransform: ShaderSemanticsClass;
    ClearCoatRoughnessTextureRotation: ShaderSemanticsClass;
    ClearCoatNormalTextureTransform: ShaderSemanticsClass;
    ClearCoatNormalTextureRotation: ShaderSemanticsClass;
    ClearCoatTexcoordIndex: ShaderSemanticsClass;
    ClearCoatRoughnessTexcoordIndex: ShaderSemanticsClass;
    ClearCoatNormalTexcoordIndex: ShaderSemanticsClass;
    IridescenceFactor: ShaderSemanticsClass;
    IridescenceTexture: ShaderSemanticsClass;
    IridescenceIor: ShaderSemanticsClass;
    IridescenceThicknessMinimum: ShaderSemanticsClass;
    IridescenceThicknessMaximum: ShaderSemanticsClass;
    IridescenceThicknessTexture: ShaderSemanticsClass;
    GaussianKernelSize: ShaderSemanticsClass;
    GaussianRatio: ShaderSemanticsClass;
    IsHorizontal: ShaderSemanticsClass;
    AnisotropyStrength: ShaderSemanticsClass;
    AnisotropyRotation: ShaderSemanticsClass;
    AnisotropyTexture: ShaderSemanticsClass;
    EmissiveStrength: ShaderSemanticsClass;
    Time: ShaderSemanticsClass;
    CubeMapFaceId: ShaderSemanticsClass;
    Roughness: ShaderSemanticsClass;
    DistributionType: ShaderSemanticsClass;
}>;

interface AnimationInterpolationEnum extends EnumIO {
    GltfString: Gltf2AnimationSamplerInterpolation;
}
declare function from$r(index: number): AnimationInterpolationEnum;
declare function fromString$h(str: string): AnimationInterpolationEnum;
declare const AnimationInterpolation: Readonly<{
    Linear: AnimationInterpolationEnum;
    Step: AnimationInterpolationEnum;
    CubicSpline: AnimationInterpolationEnum;
    from: typeof from$r;
    fromString: typeof fromString$h;
}>;

/**
 * Interface for animated values that can be controlled by animation tracks.
 * Provides functionality for managing animation samplers, time control, and value blending.
 */
interface IAnimatedValue {
    /**
     * Sets the first active animation track name for primary animation.
     * @param animationTrackName - The name of the animation track to set as first active
     */
    setFirstActiveAnimationTrackName(animationTrackName: AnimationTrackName): void;
    /**
     * Sets the second active animation track name for blending with the first track.
     * @param animationTrackName - The name of the animation track to set as second active
     */
    setSecondActiveAnimationTrackName(animationTrackName: AnimationTrackName): void;
    /**
     * Gets the currently active first animation track name.
     * @returns The name of the first active animation track
     */
    getFirstActiveAnimationTrackName(): AnimationTrackName;
    /**
     * Gets the currently active second animation track name.
     * @returns The name of the second active animation track, or undefined if not set
     */
    getSecondActiveAnimationTrackName(): AnimationTrackName | undefined;
    /**
     * Gets the minimum start input time for a specified animation track.
     * @param trackName - The name of the animation track
     * @returns The minimum start time of the track's keyframes
     */
    getMinStartInputTime(trackName: AnimationTrackName): number;
    /**
     * Gets the maximum end input time for a specified animation track.
     * @param trackName - The name of the animation track
     * @returns The maximum end time of the track's keyframes
     */
    getMaxEndInputTime(trackName: AnimationTrackName): number;
    /**
     * Associates an animation sampler with the specified track name.
     * @param animationTrackName - The name of the animation track
     * @param animationSampler - The animation sampler to associate with the track
     */
    setAnimationSampler(animationTrackName: AnimationTrackName, animationSampler: AnimationSampler): void;
    /**
     * The blending ratio between the first and second active animation tracks.
     * Value should be between 0.0 (first track only) and 1.0 (second track only).
     */
    blendingRatio: number;
    /**
     * Whether the animation should loop when it reaches the end.
     */
    isLoop: boolean;
    /**
     * Sets the current animation time.
     * @param time - The time value to set for animation playback
     */
    setTime(time: number): void;
    /**
     * Enables the use of global time for animation synchronization.
     */
    useGlobalTime(): void;
    /**
     * Updates the animated value based on the current time and active animation tracks.
     */
    update(): void;
    /**
     * Gets all available animation track names.
     * @returns An array of all animation track names
     */
    getAllTrackNames(): AnimationTrackName[];
    /**
     * Gets the animation sampler associated with the specified track name.
     * @param trackName - The name of the animation track
     * @returns The animation sampler for the specified track
     */
    getAnimationSampler(trackName: AnimationTrackName): AnimationSampler;
    /**
     * Removes the animation sampler associated with the specified track name.
     * @param trackName - The name of the animation track to remove
     */
    deleteAnimationSampler(trackName: AnimationTrackName): void;
    /**
     * Sets the underlying Float32Array data for the animated value.
     * @param array - The Float32Array to set as the data source
     */
    setFloat32Array(array: Float32Array): void;
    /**
     * Gets the current animated value as an array of numbers.
     * @returns An array of numbers representing the current animated value
     */
    getNumberArray(): number[];
}

/**
 * animation path name
 * type of animation.channel.target.path in glTF2
 * See: https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#_animation_channels
 */
type AnimationPathName = 'undefined' | 'translate' | 'quaternion' | 'scale' | 'weights' | `material/${string}` | 'light_color' | 'light_intensity' | 'light_range' | 'light_spot_innerConeAngle' | 'light_spot_outerConeAngle' | 'camera_znear' | 'camera_zfar' | 'camera_fovy' | 'camera_xmag' | 'camera_ymag' | 'effekseer';
type AnimationTrackName = string;
interface AnimationInfo {
    name: AnimationTrackName;
    minStartInputTime: Second;
    maxEndInputTime: Second;
}
/**
 * Similar to [Animation](https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#reference-animation)
 */
type AnimationTrack = Map<AnimationPathName, AnimationChannel>;
type AnimationSamplers = Map<AnimationTrackName, AnimationSampler>;
/**
 * Similar to [Animation.Channel](https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#reference-animation-channel)
 */
interface AnimationChannel {
    animatedValue: IAnimatedValue;
    target: AnimationChannelTarget;
}
/**
 * Similar to [Animation.Channel.Target](https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#reference-animation-channel-target)
 */
interface AnimationChannelTarget {
    pathName: AnimationPathName;
    entity: ISceneGraphEntity;
}
/**
 * Similar to [Animation.Sampler](https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#reference-animation-sampler)
 */
interface AnimationSampler {
    input: Float32Array;
    output: Float32Array;
    outputComponentN: VectorComponentN;
    interpolationMethod: AnimationInterpolationEnum;
}
interface ChangeAnimationInfoEvent {
    infoMap: Map<AnimationTrackName, AnimationInfo>;
}
type AnimationComponentEventType = symbol;

type RequireOne<T, K extends keyof T = keyof T> = K extends keyof T ? PartialRequire<T, K> : never;
type PartialRequire<O, K extends keyof O> = {
    [P in K]-?: O[P];
} & O;
type MixinBase = new (...args: any[]) => any;
type GetProps<TBase> = TBase extends new (props: infer P) => any ? P : never;
type GetInstance<TBase> = TBase extends new (...args: any[]) => infer I ? I : never;
type MergeCtor<A, B> = new (props: GetProps<A> & GetProps<B>) => GetInstance<A> & GetInstance<B>;

/**
 * The repository class responsible for creating, managing, and deleting entities within the framework.
 * Provides entity lifecycle management, component attachment, and entity querying capabilities.
 *
 * @remarks
 * This class manages entity UIDs, tracks entity relationships, and handles component associations.
 * It also provides functionality for entity copying and cleanup operations.
 */
declare class EntityRepository {
    private static __entity_uid_count;
    private static __entities;
    static _components: Array<Map<ComponentTID, Component>>;
    private static __updateCount;
    private constructor();
    /**
     * Creates a new entity with a unique entity UID.
     *
     * @remarks
     * This method attempts to reuse UIDs from previously deleted entities to optimize memory usage.
     * If no dead entities exist, it generates a new UID by incrementing the counter.
     *
     * @returns A newly created entity with a unique UID
     *
     * @example
     * ```typescript
     * const entity = EntityRepository.createEntity();
     * console.log(entity.entityUID); // Output: unique entity ID
     * ```
     */
    static createEntity(): IEntity;
    /**
     * Deletes an entity and all its associated components.
     *
     * @remarks
     * When deleting an entity with a SceneGraph component, this method automatically
     * deletes all child entities recursively to maintain scene graph integrity.
     *
     * @param entityUid - The unique identifier of the entity to delete
     *
     * @example
     * ```typescript
     * const entity = EntityRepository.createEntity();
     * EntityRepository.deleteEntity(entity.entityUID);
     * ```
     */
    static deleteEntity(entityUid: EntityUID): void;
    /**
     * Recursively deletes an entity and all its descendant entities in the scene graph hierarchy.
     *
     * @remarks
     * This method traverses the entire scene graph tree starting from the specified entity
     * and deletes all entities in the hierarchy. Use this when you want to remove an entire
     * subtree from the scene graph.
     *
     * @param entityUid - The unique identifier of the root entity to delete recursively
     *
     * @example
     * ```typescript
     * // Delete a parent entity and all its children
     * EntityRepository.deleteEntityRecursively(parentEntity.entityUID);
     * ```
     */
    static deleteEntityRecursively(entityUid: EntityUID): void;
    /**
     * Creates a shallow copy of an entity, including all its components and tag data.
     *
     * @remarks
     * This method performs a shallow copy of the entity, its components, and handles
     * special cases like skeletal joints and tag references. The original entity's
     * `_myLatestCopyEntityUID` will be updated to reference the new entity.
     *
     * @param entity - The entity to shallow copy
     * @returns A new entity that is a shallow copy of the input entity
     *
     * @example
     * ```typescript
     * const originalEntity = EntityRepository.createEntity();
     * const copiedEntity = EntityRepository.shallowCopyEntity(originalEntity);
     * ```
     */
    static shallowCopyEntity(entity: IEntity): IEntity;
    /**
     * Sets up joint relationships for SkeletalComponent entities after copying.
     *
     * @remarks
     * This is an internal method used during entity copying to ensure that skeletal
     * joint references are properly updated to point to the copied entities rather
     * than the original entities.
     *
     * @internal
     * @param entity - The original entity whose joints need to be set up in the copy
     */
    private static __setJoints;
    /**
     * Internal method that performs the core shallow copying logic for an entity.
     *
     * @remarks
     * This method creates a new entity, copies tags, and shallow copies all components
     * from the original entity. It processes all well-known component types.
     *
     * @internal
     * @param entity - The entity to shallow copy
     * @returns A new entity that is a shallow copy of the input entity
     */
    static _shallowCopyEntityInner(entity: IEntity): IEntity;
    /**
     * Handles special tag data processing during entity copying operations.
     *
     * @remarks
     * This method processes special tags like 'rnEntities' and 'rnEntitiesByNames'
     * to ensure that entity references within tags are updated to point to copied
     * entities rather than original entities.
     *
     * @internal
     * @param newEntity - The newly copied entity whose tag data needs processing
     */
    private static __handleTagData;
    /**
     * Attempts to add a component to an entity using the component's type ID.
     *
     * @remarks
     * This method looks up the component class by its TID and adds it to the entity
     * if the component class exists. If the component class is not found, the entity
     * is returned unchanged.
     *
     * @param componentTID - The component type identifier
     * @param entity - The entity to add the component to
     * @returns The entity (possibly with the new component added)
     *
     * @example
     * ```typescript
     * const entity = EntityRepository.createEntity();
     * EntityRepository.tryToAddComponentToEntityByTID(
     *   WellKnownComponentTIDs.TransformComponentTID,
     *   entity
     * );
     * ```
     */
    static tryToAddComponentToEntityByTID(componentTID: ComponentTID, entity: IEntity): IEntity;
    /**
     * Adds a specific component class to an entity and returns the enhanced entity.
     *
     * @remarks
     * This method creates a new component instance, associates it with the entity,
     * and returns the entity with enhanced type information that includes the
     * component's methods. If the entity already has this component, a warning
     * is logged and the entity is returned unchanged.
     *
     * @template ComponentType - The component class type
     * @template EntityType - The entity type
     * @param componentClass - The component class to instantiate and add
     * @param entity - The entity to add the component to
     * @returns The entity enhanced with the component's methods
     *
     * @example
     * ```typescript
     * const entity = EntityRepository.createEntity();
     * const enhancedEntity = EntityRepository.addComponentToEntity(
     *   TransformComponent,
     *   entity
     * );
     * // enhancedEntity now has transform-related methods
     * ```
     */
    static addComponentToEntity<ComponentType extends typeof Component, EntityType extends IEntity>(componentClass: ComponentType, entity: EntityType): EntityType & ComponentToComponentMethods<ComponentType>;
    /**
     * Removes a component from an entity and cleans up associated resources.
     *
     * @remarks
     * This method removes the specified component from the entity, calls the component's
     * destroy method, and returns the entity with basic IEntity typing. You may need
     * to cast the returned entity to the appropriate type after component removal.
     *
     * @param componentClass - The component class to remove
     * @param entity - The entity to remove the component from
     * @returns The entity with the component removed (typed as IEntity)
     *
     * @example
     * ```typescript
     * const entity = EntityRepository.createEntity();
     * // Add and later remove a component
     * EntityRepository.removeComponentFromEntity(TransformComponent, entity);
     * ```
     */
    static removeComponentFromEntity(componentClass: typeof Component, entity: IEntity): IEntity;
    /**
     * Retrieves an entity by its unique identifier.
     *
     * @remarks
     * This is a static method that provides access to entities by their UID.
     * The method assumes the entity exists and will throw if the entity is not found.
     *
     * @param entityUid - The unique identifier of the entity to retrieve
     * @returns The entity corresponding to the given UID
     *
     * @throws Will throw if the entity with the given UID does not exist
     *
     * @example
     * ```typescript
     * const entity = EntityRepository.getEntity(entityUID);
     * ```
     */
    static getEntity(entityUid: EntityUID): IEntity;
    /**
     * Instance method to retrieve an entity by its unique identifier.
     *
     * @remarks
     * This is an instance method equivalent of the static getEntity method.
     * Useful when working with EntityRepository instances.
     *
     * @param entityUid - The unique identifier of the entity to retrieve
     * @returns The entity corresponding to the given UID
     *
     * @throws Will throw if the entity with the given UID does not exist
     */
    getEntity(entityUid: EntityUID): IEntity;
    /**
     * Retrieves a specific component from an entity.
     *
     * @remarks
     * This method looks up a component of the specified type from the given entity.
     * Returns null if the entity doesn't exist or doesn't have the requested component.
     *
     * @param entityUid - The unique identifier of the entity
     * @param componentType - The component class to retrieve
     * @returns The component instance if found, null otherwise
     *
     * @example
     * ```typescript
     * const transform = EntityRepository.getComponentOfEntity(
     *   entityUID,
     *   TransformComponent
     * );
     * if (transform) {
     *   // Use the transform component
     * }
     * ```
     */
    static getComponentOfEntity(entityUid: EntityUID, componentType: typeof Component): Component | null;
    /**
     * Searches for entities that match all of the specified tags.
     *
     * @remarks
     * This method performs a tag-based search across all entities in the repository.
     * Only entities that match ALL provided tags will be included in the results.
     *
     * @param tags - The tags to search for (all must match)
     * @returns Array of entities that match all specified tags
     *
     * @example
     * ```typescript
     * const entities = EntityRepository.searchByTags({
     *   category: 'weapon',
     *   type: 'sword'
     * });
     * ```
     */
    static searchByTags(tags: RnTags): IEntity[];
    /**
     * Retrieves an entity by its unique name identifier.
     *
     * @remarks
     * This method searches through all entities to find one with the specified
     * unique name. Returns undefined if no entity with that name is found.
     *
     * @param uniqueName - The unique name of the entity to find
     * @returns The entity with the specified unique name, or undefined if not found
     *
     * @example
     * ```typescript
     * const player = EntityRepository.getEntityByUniqueName('Player');
     * if (player) {
     *   // Found the player entity
     * }
     * ```
     */
    static getEntityByUniqueName(uniqueName: string): IEntity | undefined;
    /**
     * Gets all currently alive entities in the repository.
     *
     * @remarks
     * This method returns a filtered array containing only entities that are
     * not null and are marked as alive. This is an internal method used for
     * repository management and debugging.
     *
     * @internal
     * @returns Array of all alive entities
     */
    static _getEntities(): IEntity[];
    /**
     * Gets the total count of currently alive entities.
     *
     * @remarks
     * This method counts only entities that are not null and are marked as alive.
     * Useful for performance monitoring and debugging entity lifecycle issues.
     *
     * @returns The number of currently alive entities
     *
     * @example
     * ```typescript
     * console.log(`Active entities: ${EntityRepository.getEntitiesNumber()}`);
     * ```
     */
    static getEntitiesNumber(): number;
    /**
     * Gets the current update count for the entity repository.
     *
     * @remarks
     * This counter increments whenever entities are created, deleted, or have
     * components added/removed. Useful for tracking repository state changes
     * and implementing cache invalidation strategies.
     *
     * @returns The current update count
     */
    static get updateCount(): number;
}
/**
 * Applies mixin functionality to enhance an entity with additional capabilities.
 *
 * @remarks
 * This utility function copies all property descriptors from a base constructor's
 * prototype to the derived entity instance. Used internally for entity enhancement
 * when components are added.
 *
 * @param derivedCtor - The entity instance to enhance
 * @param baseCtor - The constructor whose prototype methods to copy
 *
 * @internal
 */
declare function applyMixins(derivedCtor: IEntity, baseCtor: any): void;
/**
 * Convenience function to create a new entity.
 *
 * @remarks
 * This is a simple wrapper around EntityRepository.createEntity() that provides
 * a more convenient API for entity creation without needing to reference the
 * full EntityRepository class.
 *
 * @returns A newly created entity with a unique UID
 *
 * @example
 * ```typescript
 * import { createEntity } from './EntityRepository';
 *
 * const entity = createEntity();
 * ```
 */
declare function createEntity(): IEntity;

/**
 * AnimationStateComponent is a component that manages the state of an animation.
 * It handles animation blending, track transitions, and provides control over animation playback parameters.
 */
declare class AnimationStateComponent extends Component {
    private __activeAnimationTrack;
    private __interpolationStartTime;
    private __blendingDuration;
    private __isBlending;
    private __blendingRatio;
    /**
     * Creates a new AnimationStateComponent instance.
     * @param entityUid - The unique identifier of the entity this component belongs to
     * @param componentSid - The system identifier for this component instance
     * @param entityComponent - The entity repository for component management
     * @param isReUse - Whether this component is being reused from a pool
     */
    constructor(entityUid: EntityUID, componentSid: ComponentSID, entityComponent: EntityRepository, isReUse: boolean);
    /**
     * Gets the component type identifier for AnimationStateComponent.
     * @returns The component type ID for AnimationStateComponent
     */
    static get componentTID(): ComponentTID;
    /**
     * Gets the component type identifier for this component instance.
     * @returns The component type ID for AnimationStateComponent
     */
    get componentTID(): ComponentTID;
    /**
     * Checks if animation blending is currently active.
     * @returns True if animation blending is in progress, false otherwise
     */
    get isBlending(): boolean;
    /**
     * Gets the current blending ratio between animations.
     * @returns The blending ratio value between 0.0 and 1.0
     */
    get blendingRatio(): number;
    /**
     * Logic update method called every frame during the Logic process stage.
     * Handles animation blending calculations and updates the blending ratio over time.
     */
    $logic(): void;
    /**
     * Sets the first active animation track without blending.
     * This is typically used for initial animation setup.
     * @param trackName - The name of the animation track to activate
     */
    setFirstActiveAnimationTrack(trackName: AnimationTrackName): void;
    /**
     * Forces a transition to a new animation track with blending over a specified duration.
     * The previous track will blend out while the new track blends in.
     * @param trackName - The name of the animation track to transition to
     * @param duration - The duration of the blending transition in seconds
     */
    forceTransitionTo(trackName: AnimationTrackName, duration: number): void;
    /**
     * Sets the active animation track for this entity and all its children recursively.
     * @param animationTrackName - The name of the animation track to set as active
     */
    setActiveAnimationTrack(animationTrackName: AnimationTrackName): void;
    /**
     * Sets the second active animation track for blending purposes.
     * This track is used as the target during animation transitions.
     * @param animationTrackName - The name of the animation track to set as the second active track
     */
    setSecondActiveAnimationTrack(animationTrackName: AnimationTrackName): void;
    /**
     * Sets whether animations should use global time for synchronization.
     * Applies the setting recursively to this entity and all its children.
     * @param flg - True to use global time, false to use local time
     */
    setUseGlobalTime(flg: boolean): void;
    /**
     * Sets whether animations should loop when they reach the end.
     * Applies the setting recursively to this entity and all its children.
     * @param flg - True to enable looping, false to disable looping
     */
    setIsLoop(flg: boolean): void;
    /**
     * Sets the current playback time for animations.
     * Applies the time setting recursively to this entity and all its children.
     * @param time - The time value to set for animation playback
     */
    setTime(time: number): void;
    /**
     * Sets the blending ratio between the first and second active animation tracks.
     * Applies the ratio recursively to this entity and all its children.
     * @param ratio - The blending ratio value between 0.0 (first track) and 1.0 (second track)
     */
    setAnimationBlendingRatio(ratio: number): void;
    /**
     * Destroys the component and cleans up resources.
     * @override
     */
    _destroy(): void;
    /**
     * Gets the entity that owns this component.
     * @returns The entity which has this component as an IAnimationStateEntity
     */
    get entity(): IAnimationStateEntity;
    /**
     * Adds this component to an entity by extending the entity with AnimationState-specific methods.
     * This method uses mixins to add the getAnimationState() method to the target entity.
     * @override
     * @template EntityBase - The base entity type
     * @template SomeComponentClass - The component class type
     * @param base - The target entity to extend
     * @param _componentClass - The component class to add (unused in this implementation)
     * @returns The extended entity with AnimationState component methods
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBase, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBase;
}

interface IAnimationStateEntityMethods {
    getAnimationState(): AnimationStateComponent;
}

/**
 * The Component that manages the blend shape.
 * Blend shapes are used for morphing and deformation animations,
 * allowing smooth transitions between different geometric states.
 */
declare class BlendShapeComponent extends Component {
    private __weights;
    private __targetNames;
    private static __updateCount;
    /**
     * Creates a new BlendShapeComponent instance.
     * @param entityUid - The unique identifier of the entity this component belongs to
     * @param componentSid - The component system identifier
     * @param entityComponent - The entity repository for component management
     * @param isReUse - Whether this component is being reused from a pool
     */
    constructor(entityUid: EntityUID, componentSid: ComponentSID, entityComponent: EntityRepository, isReUse: boolean);
    /**
     * Gets the total number of updates performed on all BlendShapeComponent instances.
     * This is useful for tracking changes and optimization purposes.
     * @returns The current update count
     */
    static get updateCount(): number;
    /**
     * Gets the component type identifier for BlendShapeComponent.
     * This is a static method that returns the component type ID.
     * @returns The component type identifier
     */
    static get componentTID(): ComponentTID;
    /**
     * Gets the component type identifier for this BlendShapeComponent instance.
     * @returns The component type identifier
     */
    get componentTID(): ComponentTID;
    /**
     * Sets the blend shape weights array.
     * Each weight value should typically be between 0.0 and 1.0,
     * representing the influence of each blend shape target.
     * @param weights - Array of weight values for blend shape targets
     */
    set weights(weights: number[]);
    /**
     * Gets the current blend shape weights array.
     * @returns Array of weight values for blend shape targets
     */
    get weights(): number[];
    /**
     * Sets the names of blend shape targets.
     * These names correspond to the blend shape targets defined in the mesh.
     * @param names - Array of target names for blend shapes
     */
    set targetNames(names: string[]);
    /**
     * Gets the names of blend shape targets.
     * @returns Array of target names for blend shapes
     */
    get targetNames(): string[];
    /**
     * Sets the weight value for a specific blend shape target by index.
     * @param index - The index of the blend shape target
     * @param weight - The weight value to set (typically between 0.0 and 1.0)
     */
    setWeightByIndex(index: Index, weight: number): void;
    /**
     * Logic processing method called during the logic stage.
     * Currently empty but can be overridden for custom blend shape logic.
     */
    $logic(): void;
    /**
     * Destroys the component and cleans up resources.
     * Calls the parent class destroy method to ensure proper cleanup.
     * @override
     */
    _destroy(): void;
    /**
     * Adds this BlendShapeComponent to an entity by extending the entity class
     * with blend shape-specific methods.
     * This method uses mixins to dynamically add component-specific functionality
     * to the target entity.
     * @template EntityBase - The base entity type
     * @template SomeComponentClass - The component class type
     * @param base - The target entity to extend
     * @param _componentClass - The component class to add (used for type inference)
     * @returns The extended entity with BlendShapeComponent methods
     * @override
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBase, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBase;
}

interface IBlendShapeEntityMethods {
    getBlendShape(): BlendShapeComponent;
}

interface ICameraEntityMethods {
    getCamera(): CameraComponent;
}

interface ICameraController {
    logic(cameraComponent: CameraComponent): void;
    registerEventListeners(eventTargetDom: any): void;
    unregisterEventListeners(): void;
    setTarget(targetEntity: ISceneGraphEntity): void;
    setTargets(targetEntities: ISceneGraphEntity[]): void;
    getTargets(): ISceneGraphEntity[];
    updateCount: number;
}

type CameraControllerTypeEnum = EnumIO;
declare function from$q(index: number): CameraControllerTypeEnum;
declare function fromString$g(str: string): CameraControllerTypeEnum;
declare const CameraControllerType: Readonly<{
    Orbit: EnumIO;
    WalkThrough: EnumIO;
    from: typeof from$q;
    fromString: typeof fromString$g;
}>;

/**
 * A component that manages and controls camera behavior and movement.
 * Supports different camera controller types including Orbit and WalkThrough cameras.
 */
declare class CameraControllerComponent extends Component {
    private __cameraController;
    private static __updateCount;
    /**
     * Creates a new CameraControllerComponent instance.
     *
     * @param entityUid - The unique identifier of the entity
     * @param componentSid - The component system identifier
     * @param entityRepository - The entity repository for component management
     * @param isReUse - Whether this component is being reused
     */
    constructor(entityUid: EntityUID, componentSid: ComponentSID, entityRepository: EntityRepository, isReUse: boolean);
    /**
     * Sets the camera controller type and switches to the appropriate controller implementation.
     * Automatically unregisters event listeners from the previous controller.
     *
     * @param type - The camera controller type to switch to
     */
    set type(type: CameraControllerTypeEnum);
    /**
     * Gets the current camera controller type.
     *
     * @returns The current camera controller type
     */
    get type(): CameraControllerTypeEnum;
    /**
     * Gets the current camera controller instance.
     *
     * @returns The active camera controller instance
     */
    get controller(): ICameraController;
    /**
     * Gets the component type identifier for CameraControllerComponent.
     *
     * @returns The component type identifier
     */
    static get componentTID(): ComponentTID;
    /**
     * Gets the component type identifier for this instance.
     *
     * @returns The component type identifier
     */
    get componentTID(): ComponentTID;
    /**
     * Loads the component and moves it to the Logic processing stage.
     */
    $load(): void;
    /**
     * Executes the camera controller logic during the Logic processing stage.
     * Updates the camera based on the current controller's implementation.
     */
    $logic(): void;
    /**
     * Updates the internal update counter.
     *
     * @param count - The new update count value
     */
    _updateCount(count: number): void;
    /**
     * Gets the current update count.
     *
     * @returns The current update count
     */
    static get updateCount(): number;
    /**
     * Adds camera controller functionality to an entity by creating a mixin class.
     * This method extends the given entity base class with camera controller methods.
     *
     * @template EntityBase - The base entity type
     * @template SomeComponentClass - The component class type
     * @param base - The base entity to extend
     * @param _componentClass - The component class (used for type information)
     * @returns The extended entity with camera controller functionality
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBase, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBase;
}

interface ICameraControllerEntityMethods {
    getCameraController(): CameraControllerComponent;
}

/**
 * IVrmConstraint is an interface for VRM constraints.
 */
interface IVrmConstraint {
    update(): void;
}

/**
 * ConstraintComponent is a component that manages VRM constraints.
 * This component handles the lifecycle and execution of constraint objects,
 * providing functionality to apply VRM-based transformations to entities.
 */
declare class ConstraintComponent extends Component {
    private __vrmConstraint?;
    /**
     * Creates a new ConstraintComponent instance.
     *
     * @param entityUid - The unique identifier of the entity this component belongs to
     * @param componentSid - The unique identifier of this component instance
     * @param entityComponent - The entity repository managing this component
     * @param isReUse - Whether this component is being reused from a pool
     */
    constructor(entityUid: EntityUID, componentSid: ComponentSID, entityComponent: EntityRepository, isReUse: boolean);
    /**
     * Gets the entity that owns this constraint component.
     * The returned entity will have constraint-specific methods available.
     *
     * @returns The entity instance cast as IConstraintEntity
     */
    get entity(): IConstraintEntity;
    /**
     * Gets the component type identifier for ConstraintComponent.
     * This is a static property used for component registration and lookup.
     *
     * @returns The component type ID for constraint components
     */
    static get componentTID(): ComponentTID;
    /**
     * Gets the component type identifier for this component instance.
     *
     * @returns The component type ID for constraint components
     */
    get componentTID(): ComponentTID;
    /**
     * Executes the constraint logic during the Logic process stage.
     * This method is called automatically by the component system and
     * updates the associated VRM constraint if one is set.
     */
    $logic(): void;
    /**
     * Associates a VRM constraint with this component.
     * The constraint will be executed during the logic update phase.
     *
     * @param constraint - The VRM constraint to be managed by this component
     */
    setConstraint(constraint: IVrmConstraint): void;
    /**
     * Cleans up resources when the component is destroyed.
     * This method clears the constraint reference and calls the parent destroy method.
     *
     * @override
     */
    _destroy(): void;
    /**
     * Adds constraint-specific functionality to an entity class through mixin composition.
     * This method extends the base entity class with constraint-related methods,
     * allowing the entity to access its constraint component easily.
     *
     * @template EntityBase - The base entity type to extend
     * @template SomeComponentClass - The component class type being added
     * @param base - The base entity instance to extend
     * @param _componentClass - The component class being mixed in (unused but required for type safety)
     * @returns The enhanced entity with constraint component methods
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBase, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBase;
}

interface IConstraintEntityMethods {
    getConstraint(): ConstraintComponent;
}

/**
 * Base interface for immutable matrix operations.
 * Provides read-only access to matrix data and basic mathematical operations.
 */
interface IMatrix {
    /** Internal typed array storing matrix data in column-major order */
    _v: Float32Array;
    /** Returns the class name of the matrix implementation */
    readonly className: string;
    /**
     * Converts the matrix to a string representation.
     * @returns String representation of the matrix
     */
    toString(): string;
    /**
     * Converts the matrix to an approximate string representation.
     * @returns Approximate string representation with rounded values
     */
    toStringApproximately(): string;
    /**
     * Flattens the matrix into a plain JavaScript array.
     * @returns Array containing all matrix elements
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this is a dummy/placeholder matrix.
     * @returns True if this is a dummy matrix
     */
    isDummy(): boolean;
    /**
     * Gets the value at the specified row and column.
     * @param row_i - Row index (0-based)
     * @param column_i - Column index (0-based)
     * @returns Value at the specified position
     */
    at(row_i: number, column_i: number): number;
    /**
     * Gets the value at the specified linear index.
     * @param i - Linear index in the internal array
     * @returns Value at the specified index
     */
    v(i: number): number;
    /**
     * Calculates the determinant of the matrix.
     * @returns Determinant value
     */
    determinant(): number;
    /** Indicates if this matrix is an identity matrix class */
    readonly isIdentityMatrixClass: boolean;
    /**
     * Checks if the internal array buffer is the same as the provided one.
     * @param arrayBuffer - Array buffer to compare against
     * @returns True if the source is the same
     */
    isTheSourceSame(arrayBuffer: ArrayBuffer): boolean;
}
/**
 * Interface for mutable matrix operations.
 * Extends IMatrix with methods that modify the matrix in place.
 */
interface IMutableMatrix extends IMatrix {
    /**
     * Creates a deep copy of this matrix.
     * @returns New mutable matrix with the same values
     */
    clone(): IMutableMatrix;
    /**
     * Gets the raw typed array containing matrix data.
     * @returns Raw typed array
     */
    raw(): TypedArray;
    /**
     * Sets the value at the specified row and column.
     * @param row_i - Row index (0-based)
     * @param column_i - Column index (0-based)
     * @param value - Value to set
     */
    setAt(row_i: number, column_i: number, value: number): void;
    /**
     * Sets all matrix components from individual values.
     * @param num - Variable number of numeric values
     * @returns This matrix for method chaining
     */
    setComponents(...num: number[]): IMutableMatrix;
    /**
     * Copies components from another matrix.
     * @param mat - Source matrix to copy from
     * @returns This matrix for method chaining
     */
    copyComponents(mat: IMatrix): IMutableMatrix;
    /**
     * Sets all matrix elements to zero.
     * @returns This matrix for method chaining
     */
    zero(): IMutableMatrix;
    /**
     * Sets this matrix to the identity matrix.
     * @returns This matrix for method chaining
     */
    identity(): IMutableMatrix;
    /**
     * Swaps two elements in the internal array.
     * @param l - Left index
     * @param r - Right index
     */
    _swap(l: Index, r: Index): void;
    /**
     * Transposes this matrix in place.
     * @returns This matrix for method chaining
     */
    transpose(): IMutableMatrix;
    /**
     * Inverts this matrix in place.
     * @returns This matrix for method chaining
     */
    invert(): IMutableMatrix;
    /**
     * Applies a rotation to this matrix.
     * @param any - Rotation parameters (type varies by matrix dimension)
     * @returns This matrix for method chaining
     */
    rotate(any: any): IMutableMatrix;
    /**
     * Applies scaling to this matrix.
     * @param vec - Scale vector
     * @returns This matrix for method chaining
     */
    scale(vec: IVector): IMutableMatrix;
    /**
     * Multiplies this matrix by a scale vector.
     * @param vec - Scale vector
     * @returns This matrix for method chaining
     */
    multiplyScale(vec: IVector): IMutableMatrix;
    /**
     * Multiplies this matrix by another matrix.
     * @param mat - Matrix to multiply by
     * @returns This matrix for method chaining
     */
    multiply(mat: IMatrix): IMutableMatrix;
    /**
     * Multiplies this matrix by another matrix from the left.
     * @param mat - Matrix to multiply from the left
     * @returns This matrix for method chaining
     */
    multiplyByLeft(mat: IMatrix): IMutableMatrix;
}
/**
 * Interface for immutable 2x2 matrices.
 * Provides specific operations for 2D transformations.
 */
interface IMatrix22 extends IMatrix {
    /** Element at row 0, column 0 */
    readonly m00: number;
    /** Element at row 0, column 1 */
    readonly m01: number;
    /** Element at row 1, column 0 */
    readonly m10: number;
    /** Element at row 1, column 1 */
    readonly m11: number;
    /**
     * Checks if this matrix is approximately equal to another matrix.
     * @param mat - Matrix to compare against
     * @param delta - Optional tolerance for comparison (default: small epsilon)
     * @returns True if matrices are approximately equal
     */
    isEqual(mat: IMatrix22, delta?: number): boolean;
    /**
     * Checks if this matrix is strictly equal to another matrix.
     * @param mat - Matrix to compare against
     * @returns True if matrices are exactly equal
     */
    isStrictEqual(mat: IMatrix22): boolean;
    /**
     * Calculates the determinant of this 2x2 matrix.
     * @returns Determinant value
     */
    determinant(): number;
    /**
     * Multiplies this matrix by a 2D vector.
     * @param vec - 2D vector to multiply
     * @returns Resulting 2D vector
     */
    multiplyVector(vec: IVector2): IVector2;
    /**
     * Multiplies this matrix by a 2D vector and stores the result in an output vector.
     * @param vec - 2D vector to multiply
     * @param outVec - Output vector to store the result
     * @returns The output vector for method chaining
     */
    multiplyVectorTo(vec: IVector2, outVec: IMutableVector2): IMutableVector2;
    /**
     * Extracts the scale factors from this matrix.
     * @returns 2D vector containing scale factors
     */
    getScale(): IVector2;
    /**
     * Extracts the scale factors from this matrix and stores them in an output vector.
     * @param outVec - Output vector to store the scale factors
     * @returns The output vector for method chaining
     */
    getScaleTo(outVec: IMutableVector2): IMutableVector2;
    /**
     * Creates a deep copy of this matrix.
     * @returns New immutable 2x2 matrix with the same values
     */
    clone(): IMatrix22;
}
/**
 * Interface for mutable 2x2 matrices.
 * Provides modifiable 2x2 matrix operations for 2D transformations.
 */
interface IMutableMatrix22 {
    /** Element at row 0, column 0 */
    m00: number;
    /** Element at row 0, column 1 */
    m01: number;
    /** Element at row 1, column 0 */
    m10: number;
    /** Element at row 1, column 1 */
    m11: number;
    /**
     * Converts the matrix to a string representation.
     * @returns String representation of the matrix
     */
    toString(): string;
    /**
     * Converts the matrix to an approximate string representation.
     * @returns Approximate string representation with rounded values
     */
    toStringApproximately(): string;
    /**
     * Flattens the matrix into a plain JavaScript array.
     * @returns Array containing all matrix elements
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this is a dummy/placeholder matrix.
     * @returns True if this is a dummy matrix
     */
    isDummy(): boolean;
    /**
     * Checks if this matrix is approximately equal to another matrix.
     * @param mat - Matrix to compare against
     * @param delta - Optional tolerance for comparison (default: small epsilon)
     * @returns True if matrices are approximately equal
     */
    isEqual(mat: IMatrix22, delta?: number): boolean;
    /**
     * Checks if this matrix is strictly equal to another matrix.
     * @param mat - Matrix to compare against
     * @returns True if matrices are exactly equal
     */
    isStrictEqual(mat: IMatrix22): boolean;
    /**
     * Gets the value at the specified row and column.
     * @param row_i - Row index (0-based)
     * @param column_i - Column index (0-based)
     * @returns Value at the specified position
     */
    at(row_i: number, column_i: number): number;
    /**
     * Calculates the determinant of this 2x2 matrix.
     * @returns Determinant value
     */
    determinant(): number;
    /**
     * Multiplies this matrix by a 2D vector.
     * @param vec - 2D vector to multiply
     * @returns Resulting 2D vector
     */
    multiplyVector(vec: IVector2): IVector2;
    /**
     * Multiplies this matrix by a 2D vector and stores the result in an output vector.
     * @param vec - 2D vector to multiply
     * @param outVec - Output vector to store the result
     * @returns The output vector for method chaining
     */
    multiplyVectorTo(vec: IVector2, outVec: IMutableVector2): IMutableVector2;
    /**
     * Extracts the scale factors from this matrix.
     * @returns 2D vector containing scale factors
     */
    getScale(): IVector2;
    /**
     * Extracts the scale factors from this matrix and stores them in an output vector.
     * @param outVec - Output vector to store the scale factors
     * @returns The output vector for method chaining
     */
    getScaleTo(outVec: IMutableVector2): IMutableVector2;
    /**
     * Creates a deep copy of this matrix.
     * @returns New mutable 2x2 matrix with the same values
     */
    clone(): IMutableMatrix22;
    /**
     * Gets the raw typed array containing matrix data.
     * @returns Raw typed array
     */
    raw(): TypedArray;
    /**
     * Sets the value at the specified row and column.
     * @param row_i - Row index (0-based)
     * @param column_i - Column index (0-based)
     * @param value - Value to set
     * @returns This matrix for method chaining
     */
    setAt(row_i: number, column_i: number, value: number): IMutableMatrix22;
    /**
     * Sets all matrix components from individual values.
     * @param m00 - Element at row 0, column 0
     * @param m01 - Element at row 0, column 1
     * @param m10 - Element at row 1, column 0
     * @param m11 - Element at row 1, column 1
     * @returns This matrix for method chaining
     */
    setComponents(m00: number, m01: number, m10: number, m11: number): IMutableMatrix22;
    /**
     * Copies components from another matrix.
     * @param mat - Source matrix to copy from
     * @returns This matrix for method chaining
     */
    copyComponents(mat: IMatrix22 | IMatrix33 | IMatrix44): IMutableMatrix22;
    /**
     * Sets all matrix elements to zero.
     * @returns This matrix for method chaining
     */
    zero(): IMutableMatrix22;
    /**
     * Sets this matrix to the identity matrix.
     * @returns This matrix for method chaining
     */
    identity(): IMutableMatrix22;
    /**
     * Swaps two elements in the internal array.
     * @param l - Left index
     * @param r - Right index
     */
    _swap(l: Index, r: Index): void;
    /**
     * Transposes this matrix in place.
     * @returns This matrix for method chaining
     */
    transpose(): IMutableMatrix22;
    /**
     * Inverts this matrix in place.
     * @returns This matrix for method chaining
     */
    invert(): IMutableMatrix22;
    /**
     * Applies a 2D rotation to this matrix.
     * @param radian - Rotation angle in radians
     * @returns This matrix for method chaining
     */
    rotate(radian: number): IMutableMatrix22;
    /**
     * Applies scaling to this matrix.
     * @param vec - 2D scale vector
     * @returns This matrix for method chaining
     */
    scale(vec: IVector2): IMutableMatrix22;
    /**
     * Multiplies this matrix by a scale vector.
     * @param vec - 2D scale vector
     * @returns This matrix for method chaining
     */
    multiplyScale(vec: IVector2): IMutableMatrix22;
    /**
     * Multiplies this matrix by another 2x2 matrix.
     * @param mat - Matrix to multiply by
     * @returns This matrix for method chaining
     */
    multiply(mat: IMatrix22): IMutableMatrix22;
    /**
     * Multiplies this matrix by another 2x2 matrix from the left.
     * @param mat - Matrix to multiply from the left
     * @returns This matrix for method chaining
     */
    multiplyByLeft(mat: IMatrix22): IMutableMatrix22;
}
/**
 * Interface for immutable 3x3 matrices.
 * Provides specific operations for 3D transformations without translation.
 */
interface IMatrix33 extends IMatrix {
    /** Element at row 0, column 0 */
    readonly m00: number;
    /** Element at row 0, column 1 */
    readonly m01: number;
    /** Element at row 0, column 2 */
    readonly m02: number;
    /** Element at row 1, column 0 */
    readonly m10: number;
    /** Element at row 1, column 1 */
    readonly m11: number;
    /** Element at row 1, column 2 */
    readonly m12: number;
    /** Element at row 2, column 0 */
    readonly m20: number;
    /** Element at row 2, column 1 */
    readonly m21: number;
    /** Element at row 2, column 2 */
    readonly m22: number;
    /**
     * Checks if this matrix is approximately equal to another matrix.
     * @param mat - Matrix to compare against
     * @param delta - Optional tolerance for comparison (default: small epsilon)
     * @returns True if matrices are approximately equal
     */
    isEqual(mat: IMatrix33, delta?: number): boolean;
    /**
     * Checks if this matrix is strictly equal to another matrix.
     * @param mat - Matrix to compare against
     * @returns True if matrices are exactly equal
     */
    isStrictEqual(mat: IMatrix33): boolean;
    /**
     * Creates a deep copy of this matrix.
     * @returns New immutable 3x3 matrix with the same values
     */
    clone(): IMatrix33;
}
/**
 * Interface for mutable 3x3 matrices.
 * Provides modifiable 3x3 matrix operations for 3D transformations without translation.
 */
interface IMutableMatrix33 {
    /** Element at row 0, column 0 */
    m00: number;
    /** Element at row 0, column 1 */
    m01: number;
    /** Element at row 0, column 2 */
    m02: number;
    /** Element at row 1, column 0 */
    m10: number;
    /** Element at row 1, column 1 */
    m11: number;
    /** Element at row 1, column 2 */
    m12: number;
    /** Element at row 2, column 0 */
    m20: number;
    /** Element at row 2, column 1 */
    m21: number;
    /** Element at row 2, column 2 */
    m22: number;
    /**
     * Converts the matrix to a string representation.
     * @returns String representation of the matrix
     */
    toString(): string;
    /**
     * Converts the matrix to an approximate string representation.
     * @returns Approximate string representation with rounded values
     */
    toStringApproximately(): string;
    /**
     * Flattens the matrix into a plain JavaScript array.
     * @returns Array containing all matrix elements
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this is a dummy/placeholder matrix.
     * @returns True if this is a dummy matrix
     */
    isDummy(): boolean;
    /**
     * Checks if this matrix is approximately equal to another matrix.
     * @param mat - Matrix to compare against
     * @param delta - Optional tolerance for comparison (default: small epsilon)
     * @returns True if matrices are approximately equal
     */
    isEqual(mat: IMatrix33, delta?: number): boolean;
    /**
     * Checks if this matrix is strictly equal to another matrix.
     * @param mat - Matrix to compare against
     * @returns True if matrices are exactly equal
     */
    isStrictEqual(mat: IMatrix33): boolean;
    /**
     * Gets the value at the specified row and column.
     * @param row_i - Row index (0-based)
     * @param column_i - Column index (0-based)
     * @returns Value at the specified position
     */
    at(row_i: number, column_i: number): number;
    /**
     * Calculates the determinant of this 3x3 matrix.
     * @returns Determinant value
     */
    determinant(): number;
    /**
     * Multiplies this matrix by a 3D vector.
     * @param vec - 3D vector to multiply
     * @returns Resulting 3D vector
     */
    multiplyVector(vec: IVector3): IVector3;
    /**
     * Multiplies this matrix by a 3D vector and stores the result in an output vector.
     * @param vec - 3D vector to multiply
     * @param outVec - Output vector to store the result
     * @returns The output vector for method chaining
     */
    multiplyVectorTo(vec: IVector3, outVec: IMutableVector3): IMutableVector3;
    /**
     * Extracts the scale factors from this matrix.
     * @returns 3D vector containing scale factors
     */
    getScale(): IVector3;
    /**
     * Extracts the scale factors from this matrix and stores them in an output vector.
     * @param outVec - Output vector to store the scale factors
     * @returns The output vector for method chaining
     */
    getScaleTo(outVec: IMutableVector3): IMutableVector3;
    /**
     * Creates a deep copy of this matrix.
     * @returns New mutable 3x3 matrix with the same values
     */
    clone(): IMutableMatrix33;
    /**
     * Gets the raw typed array containing matrix data.
     * @returns Raw typed array
     */
    raw(): TypedArray;
    /**
     * Sets the value at the specified row and column.
     * @param row_i - Row index (0-based)
     * @param column_i - Column index (0-based)
     * @param value - Value to set
     * @returns This matrix for method chaining
     */
    setAt(row_i: number, column_i: number, value: number): IMutableMatrix33;
    /**
     * Sets all matrix components from individual values.
     * @param m00 - Element at row 0, column 0
     * @param m01 - Element at row 0, column 1
     * @param m02 - Element at row 0, column 2
     * @param m10 - Element at row 1, column 0
     * @param m11 - Element at row 1, column 1
     * @param m12 - Element at row 1, column 2
     * @param m20 - Element at row 2, column 0
     * @param m21 - Element at row 2, column 1
     * @param m22 - Element at row 2, column 2
     * @returns This matrix for method chaining
     */
    setComponents(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): IMutableMatrix33;
    /**
     * Copies components from another matrix.
     * @param mat - Source matrix to copy from
     * @returns This matrix for method chaining
     */
    copyComponents(mat: IMatrix33 | IMatrix44): IMutableMatrix33;
    /**
     * Sets all matrix elements to zero.
     * @returns This matrix for method chaining
     */
    zero(): IMutableMatrix33;
    /**
     * Sets this matrix to the identity matrix.
     * @returns This matrix for method chaining
     */
    identity(): IMutableMatrix33;
    /**
     * Swaps two elements in the internal array.
     * @param l - Left index
     * @param r - Right index
     */
    _swap(l: Index, r: Index): void;
    /**
     * Transposes this matrix in place.
     * @returns This matrix for method chaining
     */
    transpose(): IMutableMatrix33;
    /**
     * Inverts this matrix in place.
     * @returns This matrix for method chaining
     */
    invert(): IMutableMatrix33;
    /**
     * Applies a rotation around the X-axis to this matrix.
     * @param radian - Rotation angle in radians
     * @returns This matrix for method chaining
     */
    rotateX(radian: number): IMutableMatrix33;
    /**
     * Applies a rotation around the Y-axis to this matrix.
     * @param radian - Rotation angle in radians
     * @returns This matrix for method chaining
     */
    rotateY(radian: number): IMutableMatrix33;
    /**
     * Applies a rotation around the Z-axis to this matrix.
     * @param radian - Rotation angle in radians
     * @returns This matrix for method chaining
     */
    rotateZ(radian: number): IMutableMatrix33;
    /**
     * Applies rotations around X, Y, and Z axes in that order.
     * @param x - Rotation around X-axis in radians
     * @param y - Rotation around Y-axis in radians
     * @param z - Rotation around Z-axis in radians
     * @returns This matrix for method chaining
     */
    rotateXYZ(x: number, y: number, z: number): IMutableMatrix33;
    /**
     * Applies a rotation specified by a 3D vector (Euler angles).
     * @param vec3 - 3D vector containing rotation angles
     * @returns This matrix for method chaining
     */
    rotate(vec3: IVector3): IMutableMatrix33;
    /**
     * Applies scaling to this matrix.
     * @param vec - 3D scale vector
     * @returns This matrix for method chaining
     */
    scale(vec: IVector3): IMutableMatrix33;
    /**
     * Multiplies this matrix by a scale vector.
     * @param vec - 3D scale vector
     * @returns This matrix for method chaining
     */
    multiplyScale(vec: IVector3): IMutableMatrix33;
    /**
     * Multiplies this matrix by another 3x3 matrix.
     * @param mat - Matrix to multiply by
     * @returns This matrix for method chaining
     */
    multiply(mat: IMatrix33): IMutableMatrix33;
    /**
     * Multiplies this matrix by another 3x3 matrix from the left.
     * @param mat - Matrix to multiply from the left
     * @returns This matrix for method chaining
     */
    multiplyByLeft(mat: IMatrix33): IMutableMatrix33;
}
/**
 * Interface for immutable 4x4 matrices.
 * Provides specific operations for 3D transformations including translation.
 */
interface IMatrix44 extends IMatrix {
    /** Element at row 0, column 0 */
    readonly m00: number;
    /** Element at row 0, column 1 */
    readonly m01: number;
    /** Element at row 0, column 2 */
    readonly m02: number;
    /** Element at row 0, column 3 */
    readonly m03: number;
    /** Element at row 1, column 0 */
    readonly m10: number;
    /** Element at row 1, column 1 */
    readonly m11: number;
    /** Element at row 1, column 2 */
    readonly m12: number;
    /** Element at row 1, column 3 */
    readonly m13: number;
    /** Element at row 2, column 0 */
    readonly m20: number;
    /** Element at row 2, column 1 */
    readonly m21: number;
    /** Element at row 2, column 2 */
    readonly m22: number;
    /** Element at row 2, column 3 */
    readonly m23: number;
    /** Element at row 3, column 0 */
    readonly m30: number;
    /** Element at row 3, column 1 */
    readonly m31: number;
    /** Element at row 3, column 2 */
    readonly m32: number;
    /** Element at row 3, column 3 */
    readonly m33: number;
    /** Translation component along X-axis (same as m03) */
    readonly translateX: number;
    /** Translation component along Y-axis (same as m13) */
    readonly translateY: number;
    /** Translation component along Z-axis (same as m23) */
    readonly translateZ: number;
    /**
     * Gets the value at the specified row and column.
     * @param row_i - Row index (0-based)
     * @param column_i - Column index (0-based)
     * @returns Value at the specified position
     */
    at(row_i: number, column_i: number): number;
    /**
     * Creates a deep copy of this matrix.
     * @returns New immutable 4x4 matrix with the same values
     */
    clone(): IMatrix44;
    /**
     * Extracts the rotation part of this matrix as a 4x4 matrix.
     * @returns 4x4 matrix containing only rotation components
     */
    getRotate(): IMatrix44;
    /**
     * Extracts the translation part of this matrix.
     * @returns 3D vector containing translation components
     */
    getTranslate(): IVector3;
    /**
     * Extracts the scale factors from this matrix.
     * @returns 3D vector containing scale factors
     */
    getScale(): IVector3;
    /**
     * Multiplies this matrix by a 3D vector (treating it as a 4D vector with w=1).
     * @param vec - 3D vector to multiply
     * @returns Resulting 3D vector
     */
    multiplyVector3(vec: IVector3): IVector3;
    /**
     * Multiplies this matrix by a 4D vector.
     * @param vec - 4D vector to multiply
     * @returns Resulting 4D vector
     */
    multiplyVector(vec: IVector4): IVector4;
}
/**
 * Interface for mutable 4x4 matrices.
 * Provides modifiable 4x4 matrix operations for complete 3D transformations.
 */
interface IMutableMatrix44 extends IMatrix {
    /** Element at row 0, column 0 */
    m00: number;
    /** Element at row 0, column 1 */
    m01: number;
    /** Element at row 0, column 2 */
    m02: number;
    /** Element at row 0, column 3 */
    m03: number;
    /** Element at row 1, column 0 */
    m10: number;
    /** Element at row 1, column 1 */
    m11: number;
    /** Element at row 1, column 2 */
    m12: number;
    /** Element at row 1, column 3 */
    m13: number;
    /** Element at row 2, column 0 */
    m20: number;
    /** Element at row 2, column 1 */
    m21: number;
    /** Element at row 2, column 2 */
    m22: number;
    /** Element at row 2, column 3 */
    m23: number;
    /** Element at row 3, column 0 */
    m30: number;
    /** Element at row 3, column 1 */
    m31: number;
    /** Element at row 3, column 2 */
    m32: number;
    /** Element at row 3, column 3 */
    m33: number;
    /** Translation component along X-axis (same as m03) */
    translateX: number;
    /** Translation component along Y-axis (same as m13) */
    translateY: number;
    /** Translation component along Z-axis (same as m23) */
    translateZ: number;
    /**
     * Converts the matrix to a string representation.
     * @returns String representation of the matrix
     */
    toString(): string;
    /**
     * Converts the matrix to an approximate string representation.
     * @returns Approximate string representation with rounded values
     */
    toStringApproximately(): string;
    /**
     * Flattens the matrix into a plain JavaScript array.
     * @returns Array containing all matrix elements
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this is a dummy/placeholder matrix.
     * @returns True if this is a dummy matrix
     */
    isDummy(): boolean;
    /**
     * Checks if this matrix is approximately equal to another matrix.
     * @param mat - Matrix to compare against
     * @param delta - Optional tolerance for comparison (default: small epsilon)
     * @returns True if matrices are approximately equal
     */
    isEqual(mat: IMatrix44, delta?: number): boolean;
    /**
     * Checks if this matrix is strictly equal to another matrix.
     * @param mat - Matrix to compare against
     * @returns True if matrices are exactly equal
     */
    isStrictEqual(mat: IMatrix44): boolean;
    /**
     * Gets the value at the specified row and column.
     * @param row_i - Row index (0-based)
     * @param column_i - Column index (0-based)
     * @returns Value at the specified position
     */
    at(row_i: number, column_i: number): number;
    /**
     * Calculates the determinant of this 4x4 matrix.
     * @returns Determinant value
     */
    determinant(): number;
    /**
     * Multiplies this matrix by a 4D vector.
     * @param vec - 4D vector to multiply
     * @returns Resulting 4D vector
     */
    multiplyVector(vec: IVector4): IVector4;
    /**
     * Multiplies this matrix by a 4D vector and stores the result in an output vector.
     * @param vec - 4D vector to multiply
     * @param outVec - Output vector to store the result
     * @returns The output vector for method chaining
     */
    multiplyVectorTo(vec: IVector4, outVec: IMutableVector4): IMutableVector4;
    /**
     * Multiplies this matrix by a 4D vector and stores the result in a 3D output vector.
     * @param vec - 4D vector to multiply
     * @param outVec - Output 3D vector to store the result
     * @returns The output vector for method chaining
     */
    multiplyVectorToVec3(vec: IVector4, outVec: IMutableVector3): IMutableVector3;
    /**
     * Multiplies this matrix by a 3D vector (treating it as a 4D vector with w=1).
     * @param vec - 3D vector to multiply
     * @returns Resulting 3D vector
     */
    multiplyVector3(vec: IVector3): IVector3;
    /**
     * Multiplies this matrix by a 3D vector and stores the result in an output vector.
     * @param vec - 3D vector to multiply
     * @param outVec - Output vector to store the result
     * @returns The output vector for method chaining
     */
    multiplyVector3To(vec: IVector3, outVec: IMutableVector3): IMutableVector3;
    /**
     * Extracts the translation part of this matrix.
     * @returns 3D vector containing translation components
     */
    getTranslate(): IVector3;
    /**
     * Extracts the translation part of this matrix and stores it in an output vector.
     * @param outVec - Output vector to store the translation
     * @returns The output vector for method chaining
     */
    getTranslateTo(outVec: IMutableVector3): IMutableVector3;
    /**
     * Extracts the scale factors from this matrix.
     * @returns 4D vector containing scale factors
     */
    getScale(): IVector4;
    /**
     * Extracts the scale factors from this matrix and stores them in an output vector.
     * @param outVec - Output vector to store the scale factors
     * @returns The output vector for method chaining
     */
    getScaleTo(outVec: IMutableVector3): IMutableVector3;
    /**
     * Converts the rotation part of this matrix to Euler angles.
     * @returns 3D vector containing Euler angles in radians
     */
    toEulerAngles(): IVector3;
    /**
     * Converts the rotation part of this matrix to Euler angles and stores them in an output vector.
     * @param outVec3 - Output vector to store the Euler angles
     * @returns The output vector for method chaining
     */
    toEulerAnglesTo(outVec3: IMutableVector3): IMutableVector3;
    /**
     * Creates a deep copy of this matrix.
     * @returns New mutable 4x4 matrix with the same values
     */
    clone(): IMutableMatrix44;
    /**
     * Extracts the rotation part of this matrix as a mutable 4x4 matrix.
     * @returns Mutable 4x4 matrix containing only rotation components
     */
    getRotate(): IMutableMatrix44;
    /**
     * Gets the raw typed array containing matrix data.
     * @returns Raw typed array
     */
    raw(): TypedArray;
    /**
     * Sets the value at the specified row and column.
     * @param row_i - Row index (0-based)
     * @param column_i - Column index (0-based)
     * @param value - Value to set
     * @returns This matrix for method chaining
     */
    setAt(row_i: number, column_i: number, value: number): IMutableMatrix44;
    /**
     * Sets all matrix components from individual values.
     * @param m00 - Element at row 0, column 0
     * @param m01 - Element at row 0, column 1
     * @param m02 - Element at row 0, column 2
     * @param m03 - Element at row 0, column 3
     * @param m10 - Element at row 1, column 0
     * @param m11 - Element at row 1, column 1
     * @param m12 - Element at row 1, column 2
     * @param m13 - Element at row 1, column 3
     * @param m20 - Element at row 2, column 0
     * @param m21 - Element at row 2, column 1
     * @param m22 - Element at row 2, column 2
     * @param m23 - Element at row 2, column 3
     * @param m30 - Element at row 3, column 0
     * @param m31 - Element at row 3, column 1
     * @param m32 - Element at row 3, column 2
     * @param m33 - Element at row 3, column 3
     * @returns This matrix for method chaining
     */
    setComponents(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): IMutableMatrix44;
    /**
     * Copies components from another matrix.
     * @param mat - Source matrix to copy from
     * @returns This matrix for method chaining
     */
    copyComponents(mat: IMatrix44): IMutableMatrix44;
    /**
     * Sets all matrix elements to zero.
     * @returns This matrix for method chaining
     */
    zero(): IMutableMatrix44;
    /**
     * Sets this matrix to the identity matrix.
     * @returns This matrix for method chaining
     */
    identity(): IMutableMatrix44;
    /**
     * Swaps two elements in the internal array.
     * @param l - Left index
     * @param r - Right index
     */
    _swap(l: Index, r: Index): void;
    /**
     * Transposes this matrix in place.
     * @returns This matrix for method chaining
     */
    transpose(): IMutableMatrix44;
    /**
     * Inverts this matrix in place.
     * @returns This matrix for method chaining
     */
    invert(): IMutableMatrix44;
    /**
     * Applies a translation to this matrix.
     * @param vec - 3D translation vector
     * @returns This matrix for method chaining
     */
    translate(vec: IVector3): IMutableMatrix44;
    /**
     * Sets the translation part of this matrix.
     * @param vec - 3D translation vector
     * @returns This matrix for method chaining
     */
    putTranslate(vec: IVector3): IMutableMatrix44;
    /**
     * Adds a translation to the existing translation of this matrix.
     * @param vec - 3D translation vector to add
     * @returns This matrix for method chaining
     */
    addTranslate(vec: IVector3): IMutableMatrix44;
    /**
     * Applies a rotation around the X-axis to this matrix.
     * @param radian - Rotation angle in radians
     * @returns This matrix for method chaining
     */
    rotateX(radian: number): IMutableMatrix44;
    /**
     * Applies a rotation around the Y-axis to this matrix.
     * @param radian - Rotation angle in radians
     * @returns This matrix for method chaining
     */
    rotateY(radian: number): IMutableMatrix44;
    /**
     * Applies a rotation around the Z-axis to this matrix.
     * @param radian - Rotation angle in radians
     * @returns This matrix for method chaining
     */
    rotateZ(radian: number): IMutableMatrix44;
    /**
     * Applies rotations around X, Y, and Z axes in that order.
     * @param x - Rotation around X-axis in radians
     * @param y - Rotation around Y-axis in radians
     * @param z - Rotation around Z-axis in radians
     * @returns This matrix for method chaining
     */
    rotateXYZ(x: number, y: number, z: number): IMutableMatrix44;
    /**
     * Applies a rotation specified by a 3D vector (Euler angles).
     * @param vec3 - 3D vector containing rotation angles
     * @returns This matrix for method chaining
     */
    rotate(vec3: IVector3): IMutableMatrix44;
    /**
     * Applies scaling to this matrix.
     * @param vec - 3D scale vector
     * @returns This matrix for method chaining
     */
    scale(vec: IVector3): IMutableMatrix44;
    /**
     * Multiplies this matrix by a scale vector.
     * @param vec - 3D scale vector
     * @returns This matrix for method chaining
     */
    multiplyScale(vec: IVector3): IMutableMatrix44;
    /**
     * Multiplies this matrix by another 4x4 matrix.
     * @param mat - Matrix to multiply by
     * @returns This matrix for method chaining
     */
    multiply(mat: IMatrix44): IMutableMatrix44;
    /**
     * Multiplies this matrix by another 4x4 matrix from the left.
     * @param mat - Matrix to multiply from the left
     * @returns This matrix for method chaining
     */
    multiplyByLeft(mat: IMatrix44): IMutableMatrix44;
    /**
     * Sets this matrix from a quaternion rotation.
     * @param quat - Quaternion representing the rotation
     * @returns This matrix for method chaining
     */
    fromQuaternion(quat: IQuaternion): IMutableMatrix44;
}

/**
 * Immutable quaternion interface representing a rotation in 3D space.
 * Quaternions are a mathematical notation for representing rotations and orientations.
 * They consist of four components: x, y, z (imaginary parts) and w (real part).
 */
interface IQuaternion {
    /** The class name identifier */
    readonly className: string;
    /** Internal Float32Array storage for quaternion components */
    _v: Float32Array;
    /** The x component (i quaternion basis) */
    readonly x: number;
    /** The y component (j quaternion basis) */
    readonly y: number;
    /** The z component (k quaternion basis) */
    readonly z: number;
    /** The w component (real quaternion basis) */
    readonly w: number;
    /**
     * Returns a string representation of the quaternion.
     * @returns String representation of the quaternion
     */
    toString(): string;
    /**
     * Returns an approximate string representation of the quaternion with limited precision.
     * @returns Approximate string representation
     */
    toStringApproximately(): string;
    /**
     * Converts the quaternion to a flat array of numbers.
     * @returns Array containing [x, y, z, w] components
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this quaternion is a dummy/invalid quaternion.
     * @returns True if the quaternion is dummy, false otherwise
     */
    isDummy(): boolean;
    /**
     * Compares this quaternion with another quaternion for equality within a tolerance.
     * @param vec - The quaternion to compare with
     * @param delta - Optional tolerance value for comparison (default uses system epsilon)
     * @returns True if quaternions are equal within tolerance, false otherwise
     */
    isEqual(vec: IQuaternion, delta?: number): boolean;
    /**
     * Compares this quaternion with another quaternion for strict equality.
     * @param vec - The quaternion to compare with
     * @returns True if quaternions are exactly equal, false otherwise
     */
    isStrictEqual(vec: IQuaternion): boolean;
    /**
     * Gets the component value at the specified index.
     * @param i - Index (0=x, 1=y, 2=z, 3=w)
     * @returns The component value at the given index
     */
    at(i: number): number;
    /**
     * Calculates the magnitude (length) of the quaternion.
     * @returns The magnitude of the quaternion
     */
    length(): number;
    /**
     * Calculates the squared magnitude of the quaternion.
     * More efficient than length() when only comparison is needed.
     * @returns The squared magnitude of the quaternion
     */
    lengthSquared(): number;
    /**
     * Calculates the dot product between this quaternion and another.
     * @param vec - The other quaternion
     * @returns The dot product result
     */
    dot(vec: IQuaternion): number;
    /**
     * Converts the quaternion to Euler angles and stores the result in the provided vector.
     * @param out - The output vector to store the Euler angles
     * @returns The output vector containing Euler angles (x=pitch, y=yaw, z=roll)
     */
    toEulerAnglesTo(out: IMutableVector3): IMutableVector3;
    /**
     * Converts the quaternion to Euler angles.
     * @returns A new vector containing Euler angles (x=pitch, y=yaw, z=roll)
     */
    toEulerAngles(): IVector3;
    /**
     * Creates a copy of this quaternion.
     * @returns A new quaternion with the same values
     */
    clone(): IQuaternion;
    /**
     * Transforms a 3D vector by this quaternion rotation.
     * @param vec - The vector to transform
     * @returns A new transformed vector
     */
    transformVector3(vec: IVector3): IVector3;
    /**
     * Transforms a 3D vector by this quaternion rotation and stores the result in the output vector.
     * @param vec - The vector to transform
     * @param out - The output vector to store the result
     * @returns The output vector containing the transformed result
     */
    transformVector3To(vec: IVector3, out: IMutableVector3): IVector3;
    /**
     * Transforms a 3D vector by the inverse of this quaternion rotation.
     * @param vec - The vector to transform
     * @returns A new transformed vector
     */
    transformVector3Inverse(vec: IVector3): IVector3;
}
/**
 * Mutable quaternion interface that extends IQuaternion with modification capabilities.
 * Provides methods to modify quaternion components and perform in-place operations.
 */
interface IMutableQuaternion extends IQuaternion {
    /** The class name identifier */
    readonly className: string;
    /** The x component (i quaternion basis) - mutable */
    x: number;
    /** The y component (j quaternion basis) - mutable */
    y: number;
    /** The z component (k quaternion basis) - mutable */
    z: number;
    /** The w component (real quaternion basis) - mutable */
    w: number;
    /**
     * Returns a string representation of the quaternion.
     * @returns String representation of the quaternion
     */
    toString(): string;
    /**
     * Returns an approximate string representation of the quaternion with limited precision.
     * @returns Approximate string representation
     */
    toStringApproximately(): string;
    /**
     * Converts the quaternion to a flat array of numbers.
     * @returns Array containing [x, y, z, w] components
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this quaternion is a dummy/invalid quaternion.
     * @returns True if the quaternion is dummy, false otherwise
     */
    isDummy(): boolean;
    /**
     * Compares this quaternion with another quaternion for equality within a tolerance.
     * @param vec - The quaternion to compare with
     * @param delta - Optional tolerance value for comparison (default uses system epsilon)
     * @returns True if quaternions are equal within tolerance, false otherwise
     */
    isEqual(vec: IQuaternion, delta?: number): boolean;
    /**
     * Compares this quaternion with another quaternion for strict equality.
     * @param vec - The quaternion to compare with
     * @returns True if quaternions are exactly equal, false otherwise
     */
    isStrictEqual(vec: IQuaternion): boolean;
    /**
     * Gets the component value at the specified index.
     * @param i - Index (0=x, 1=y, 2=z, 3=w)
     * @returns The component value at the given index
     */
    at(i: number): number;
    /**
     * Calculates the magnitude (length) of the quaternion.
     * @returns The magnitude of the quaternion
     */
    length(): number;
    /**
     * Calculates the squared magnitude of the quaternion.
     * More efficient than length() when only comparison is needed.
     * @returns The squared magnitude of the quaternion
     */
    lengthSquared(): number;
    /**
     * Calculates the dot product between this quaternion and another.
     * @param vec - The other quaternion
     * @returns The dot product result
     */
    dot(vec: IQuaternion): number;
    /**
     * Converts the quaternion to Euler angles and stores the result in the provided vector.
     * @param out - The output vector to store the Euler angles
     * @returns The output vector containing Euler angles (x=pitch, y=yaw, z=roll)
     */
    toEulerAnglesTo(out: IMutableVector3): IMutableVector3;
    /**
     * Creates a mutable copy of this quaternion.
     * @returns A new mutable quaternion with the same values
     */
    clone(): IMutableQuaternion;
    /**
     * Gets the raw typed array backing this quaternion.
     * @returns The underlying TypedArray storage
     */
    raw(): TypedArray;
    /**
     * Sets the component value at the specified index.
     * @param i - Index (0=x, 1=y, 2=z, 3=w)
     * @param value - The value to set
     * @returns This quaternion for method chaining
     */
    setAt(i: number, value: number): IMutableQuaternion;
    /**
     * Sets all four components of the quaternion.
     * @param x - The x component value
     * @param y - The y component value
     * @param z - The z component value
     * @param w - The w component value
     * @returns This quaternion for method chaining
     */
    setComponents(x: number, y: number, z: number, w: number): IMutableQuaternion;
    /**
     * Copies the components from another quaternion into this one.
     * @param quat - The source quaternion to copy from
     * @returns This quaternion for method chaining
     */
    copyComponents(quat: IQuaternion): IMutableQuaternion;
    /**
     * Sets this quaternion to the identity quaternion (0, 0, 0, 1).
     * @returns This quaternion for method chaining
     */
    identity(): IMutableQuaternion;
    /**
     * Normalizes this quaternion to unit length in place.
     * @returns This quaternion for method chaining
     */
    normalize(): IMutableQuaternion;
    /**
     * Sets this quaternion to represent a rotation around an axis by a given angle.
     * @param vec - The axis of rotation (should be normalized)
     * @param radian - The angle of rotation in radians
     * @returns This quaternion for method chaining
     */
    axisAngle(vec: IVector3, radian: number): IMutableQuaternion;
    /**
     * Sets this quaternion from a rotation matrix.
     * @param mat - The source rotation matrix
     * @returns This quaternion for method chaining
     */
    fromMatrix(mat: IMatrix44): IMutableQuaternion;
    /**
     * Adds another quaternion to this one in place.
     * @param quat - The quaternion to add
     * @returns This quaternion for method chaining
     */
    add(quat: IQuaternion): IMutableQuaternion;
    /**
     * Subtracts another quaternion from this one in place.
     * @param quat - The quaternion to subtract
     * @returns This quaternion for method chaining
     */
    subtract(quat: IQuaternion): IMutableQuaternion;
    /**
     * Multiplies this quaternion by another quaternion in place (quaternion composition).
     * @param quat - The quaternion to multiply with
     * @returns This quaternion for method chaining
     */
    multiply(quat: IQuaternion): IMutableQuaternion;
    /**
     * Multiplies this quaternion by a scalar value in place.
     * @param value - The scalar value to multiply by
     * @returns This quaternion for method chaining
     */
    multiplyNumber(value: number): IMutableQuaternion;
    /**
     * Divides this quaternion by a scalar value in place.
     * @param value - The scalar value to divide by
     * @returns This quaternion for method chaining
     */
    divideNumber(value: number): IMutableQuaternion;
    /**
     * Creates a mutable copy of this quaternion.
     * @returns A new mutable quaternion with the same values
     */
    clone(): IMutableQuaternion;
}
/**
 * Logarithmic quaternion interface for representing quaternion logarithms.
 * Used in quaternion interpolation and advanced quaternion mathematics.
 */
interface ILogQuaternion {
    /** The class name identifier */
    readonly className: string;
    /** Internal Float32Array storage for logarithmic quaternion components */
    readonly _v: Float32Array;
    /** The x component of the logarithmic quaternion */
    readonly x: number;
    /** The y component of the logarithmic quaternion */
    readonly y: number;
    /** The z component of the logarithmic quaternion */
    readonly z: number;
    /** The w component of the logarithmic quaternion */
    readonly w: number;
}

/**
 * Base interface for immutable vector types.
 * Provides common read-only operations for vector mathematics.
 */
interface IVector {
    /** The x component of the vector */
    readonly x: number;
    /** The underlying typed array containing vector components */
    readonly _v: TypedArray;
    /** The class name identifier */
    readonly className: string;
    /** Number of bytes per component in the underlying array */
    readonly bytesPerComponent: number;
    /** GLSL string representation for float type */
    readonly glslStrAsFloat: string;
    /** GLSL string representation for integer type */
    readonly glslStrAsInt: string;
    /** WGSL string representation for float type */
    readonly wgslStrAsFloat: string;
    /** WGSL string representation for integer type */
    readonly wgslStrAsInt: string;
    /**
     * Returns a string representation of the vector.
     * @returns String representation of the vector
     */
    toString(): string;
    /**
     * Returns an approximate string representation of the vector with rounded values.
     * @returns Approximate string representation
     */
    toStringApproximately(): string;
    /**
     * Converts the vector to a flat array of numbers.
     * @returns Array containing all vector components
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this is a dummy/placeholder vector.
     * @returns True if this is a dummy vector
     */
    isDummy(): boolean;
    /**
     * Checks if this vector is equal to another vector within a tolerance.
     * @param vec - The vector to compare with
     * @param delta - Optional tolerance value (default: small epsilon)
     * @returns True if vectors are approximately equal
     */
    isEqual(vec: IVector, delta?: number): boolean;
    /**
     * Checks if this vector is strictly equal to another vector.
     * @param vec - The vector to compare with
     * @returns True if vectors are exactly equal
     */
    isStrictEqual(vec: IVector): boolean;
    /**
     * Gets the component value at the specified index.
     * @param i - The component index
     * @returns The component value
     */
    at(i: number): number;
    /**
     * Gets the component value at the specified index (alias for at).
     * @param i - The component index
     * @returns The component value
     */
    v(i: number): number;
    /**
     * Calculates the length (magnitude) of the vector.
     * @returns The vector length
     */
    length(): number;
    /**
     * Calculates the squared length of the vector (faster than length).
     * @returns The squared vector length
     */
    lengthSquared(): number;
    /**
     * Calculates the distance to another vector.
     * @param vec - The target vector
     * @returns The distance between vectors
     */
    lengthTo(vec: IVector): number;
    /**
     * Calculates the dot product with another vector.
     * @param vec - The other vector
     * @returns The dot product result
     */
    dot(vec: IVector): number;
    /**
     * Checks if this vector shares the same source array buffer.
     * @param arrayBuffer - The array buffer to check
     * @returns True if using the same source buffer
     */
    isTheSourceSame(arrayBuffer: ArrayBuffer): boolean;
}
/**
 * Base interface for mutable vector types.
 * Extends IVector with mutation operations that modify the vector in-place.
 */
interface IMutableVector extends IVector {
    /** The underlying typed array containing vector components (mutable) */
    _v: TypedArray;
    /** The class name identifier */
    readonly className: string;
    /**
     * Gets the raw underlying typed array.
     * @returns The raw typed array
     */
    raw(): TypedArray;
    /**
     * Sets the component value at the specified index.
     * @param i - The component index
     * @param value - The new value
     * @returns This vector for method chaining
     */
    setAt(i: number, value: number): IMutableVector;
    /**
     * Sets all components of the vector.
     * @param num - The component values
     * @returns This vector for method chaining
     */
    setComponents(...num: number[]): IMutableVector;
    /**
     * Copies components from another vector.
     * @param vec - The source vector
     * @returns This vector for method chaining
     */
    copyComponents(vec: any): IMutableVector;
    /**
     * Sets all components to zero.
     * @returns This vector for method chaining
     */
    zero(): IMutableVector;
    /**
     * Sets all components to one.
     * @returns This vector for method chaining
     */
    one(): IMutableVector;
    /**
     * Normalizes the vector to unit length.
     * @returns This vector for method chaining
     */
    normalize(): IMutableVector;
    /**
     * Adds another vector to this vector.
     * @param vec - The vector to add
     * @returns This vector for method chaining
     */
    add(vec: any): IMutableVector;
    /**
     * Subtracts another vector from this vector.
     * @param vec - The vector to subtract
     * @returns This vector for method chaining
     */
    subtract(vec: any): IMutableVector;
    /**
     * Multiplies this vector by a scalar value.
     * @param value - The scalar multiplier
     * @returns This vector for method chaining
     */
    multiply(value: number): IMutableVector;
    /**
     * Multiplies this vector component-wise by another vector.
     * @param vec - The vector to multiply by
     * @returns This vector for method chaining
     */
    multiplyVector(vec: any): IMutableVector;
    /**
     * Divides this vector by a scalar value.
     * @param value - The scalar divisor
     * @returns This vector for method chaining
     */
    divide(value: number): IMutableVector;
    /**
     * Divides this vector component-wise by another vector.
     * @param vec - The vector to divide by
     * @returns This vector for method chaining
     */
    divideVector(vec: any): IMutableVector;
}
/**
 * Interface for scalar values (1-component vectors).
 */
interface IScalar extends IVector {
    /** The underlying typed array */
    _v: TypedArray;
    /** The scalar value (x component) */
    readonly x: number;
}
/**
 * Interface for mutable scalar values.
 */
interface IMutableScalar extends IMutableVector {
    /** The scalar value (x component) */
    readonly x: number;
}
/**
 * Interface for immutable 2D vectors.
 * Provides operations specific to 2-component vectors.
 */
interface IVector2 extends IVector {
    /** The class name identifier */
    readonly className: string;
    /** The x component */
    readonly x: number;
    /** The y component */
    readonly y: number;
    /**
     * Returns a string representation of the vector.
     * @returns String representation
     */
    toString(): string;
    /**
     * Returns an approximate string representation with rounded values.
     * @returns Approximate string representation
     */
    toStringApproximately(): string;
    /**
     * Converts the vector to a flat array.
     * @returns Array containing [x, y]
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this is a dummy vector.
     * @returns True if dummy
     */
    isDummy(): boolean;
    /**
     * Checks equality with another Vector2 within tolerance.
     * @param vec - Vector to compare with
     * @param delta - Optional tolerance
     * @returns True if approximately equal
     */
    isEqual(vec: IVector2, delta?: number): boolean;
    /**
     * Checks strict equality with another Vector2.
     * @param vec - Vector to compare with
     * @returns True if exactly equal
     */
    isStrictEqual(vec: IVector2): boolean;
    /**
     * Gets component at index.
     * @param i - Component index (0=x, 1=y)
     * @returns Component value
     */
    at(i: number): number;
    /**
     * Calculates vector length.
     * @returns Vector magnitude
     */
    length(): number;
    /**
     * Calculates squared length.
     * @returns Squared magnitude
     */
    lengthSquared(): number;
    /**
     * Calculates distance to another Vector2.
     * @param vec - Target vector
     * @returns Distance
     */
    lengthTo(vec: IVector2): number;
    /**
     * Calculates dot product with another Vector2.
     * @param vec - Other vector
     * @returns Dot product
     */
    dot(vec: IVector2): number;
    /**
     * Creates a copy of this vector.
     * @returns New Vector2 instance
     */
    clone(): IVector2;
}
/**
 * Interface for mutable 2D vectors.
 * Provides in-place operations for 2-component vectors.
 */
interface IMutableVector2 extends IMutableVector {
    /** The class name identifier */
    readonly className: string;
    /** The x component (mutable) */
    x: number;
    /** The y component (mutable) */
    y: number;
    /**
     * Returns a string representation of the vector.
     * @returns String representation
     */
    toString(): string;
    /**
     * Returns an approximate string representation with rounded values.
     * @returns Approximate string representation
     */
    toStringApproximately(): string;
    /**
     * Converts the vector to a flat array.
     * @returns Array containing [x, y]
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this is a dummy vector.
     * @returns True if dummy
     */
    isDummy(): boolean;
    /**
     * Checks equality with another Vector2 within tolerance.
     * @param vec - Vector to compare with
     * @param delta - Optional tolerance
     * @returns True if approximately equal
     */
    isEqual(vec: IVector2, delta?: number): boolean;
    /**
     * Checks strict equality with another Vector2.
     * @param vec - Vector to compare with
     * @returns True if exactly equal
     */
    isStrictEqual(vec: IVector2): boolean;
    /**
     * Gets component at index.
     * @param i - Component index (0=x, 1=y)
     * @returns Component value
     */
    at(i: number): number;
    /**
     * Calculates vector length.
     * @returns Vector magnitude
     */
    length(): number;
    /**
     * Calculates squared length.
     * @returns Squared magnitude
     */
    lengthSquared(): number;
    /**
     * Calculates distance to another Vector2.
     * @param vec - Target vector
     * @returns Distance
     */
    lengthTo(vec: IVector2): number;
    /**
     * Calculates dot product with another Vector2.
     * @param vec - Other vector
     * @returns Dot product
     */
    dot(vec: IVector2): number;
    /**
     * Creates a copy of this vector.
     * @returns New mutable Vector2 instance
     */
    clone(): IMutableVector2;
    /**
     * Gets the raw underlying typed array.
     * @returns The raw typed array
     */
    raw(): TypedArray;
    /**
     * Sets component at index.
     * @param i - Component index (0=x, 1=y)
     * @param value - New value
     * @returns This vector for chaining
     */
    setAt(i: number, value: number): IMutableVector2;
    /**
     * Sets both components.
     * @param x - X component value
     * @param y - Y component value
     * @returns This vector for chaining
     */
    setComponents(x: number, y: number): IMutableVector2;
    /**
     * Copies components from another Vector2.
     * @param vec - Source vector
     * @returns This vector for chaining
     */
    copyComponents(vec: IVector2): IMutableVector2;
    /**
     * Sets vector to (0, 0).
     * @returns This vector for chaining
     */
    zero(): IMutableVector2;
    /**
     * Sets vector to (1, 1).
     * @returns This vector for chaining
     */
    one(): IMutableVector2;
    /**
     * Normalizes vector to unit length.
     * @returns This vector for chaining
     */
    normalize(): IMutableVector2;
    /**
     * Adds another Vector2 to this vector.
     * @param vec - Vector to add
     * @returns This vector for chaining
     */
    add(vec: IVector2): IMutableVector2;
    /**
     * Subtracts another Vector2 from this vector.
     * @param vec - Vector to subtract
     * @returns This vector for chaining
     */
    subtract(vec: IVector2): IMutableVector2;
    /**
     * Multiplies vector by scalar.
     * @param value - Scalar multiplier
     * @returns This vector for chaining
     */
    multiply(value: number): IMutableVector2;
    /**
     * Multiplies vector component-wise by another Vector2.
     * @param vec - Vector to multiply by
     * @returns This vector for chaining
     */
    multiplyVector(vec: IVector2): IMutableVector2;
    /**
     * Divides vector by scalar.
     * @param value - Scalar divisor
     * @returns This vector for chaining
     */
    divide(value: number): IMutableVector2;
    /**
     * Divides vector component-wise by another Vector2.
     * @param vec - Vector to divide by
     * @returns This vector for chaining
     */
    divideVector(vec: IVector2): IMutableVector2;
}
/**
 * Interface for immutable 3D vectors.
 * Provides operations specific to 3-component vectors with homogeneous coordinate support.
 */
interface IVector3 extends IVector {
    /** The class name identifier */
    readonly className: string;
    /** The x component */
    readonly x: number;
    /** The y component */
    readonly y: number;
    /** The z component */
    readonly z: number;
    /** The w component (homogeneous coordinate, typically 1.0 for points, 0.0 for vectors) */
    readonly w: number;
    /**
     * Returns a string representation of the vector.
     * @returns String representation
     */
    toString(): string;
    /**
     * Returns an approximate string representation with rounded values.
     * @returns Approximate string representation
     */
    toStringApproximately(): string;
    /**
     * Converts the vector to a flat array.
     * @returns Array containing [x, y, z]
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this is a dummy vector.
     * @returns True if dummy
     */
    isDummy(): boolean;
    /**
     * Checks equality with another Vector3 within tolerance.
     * @param vec - Vector to compare with
     * @param delta - Optional tolerance
     * @returns True if approximately equal
     */
    isEqual(vec: IVector3, delta?: number): boolean;
    /**
     * Checks strict equality with another Vector3.
     * @param vec - Vector to compare with
     * @returns True if exactly equal
     */
    isStrictEqual(vec: IVector3): boolean;
    /**
     * Gets component at index.
     * @param i - Component index (0=x, 1=y, 2=z)
     * @returns Component value
     */
    at(i: number): number;
    /**
     * Calculates vector length.
     * @returns Vector magnitude
     */
    length(): number;
    /**
     * Calculates squared length.
     * @returns Squared magnitude
     */
    lengthSquared(): number;
    /**
     * Calculates distance to another Vector3.
     * @param vec - Target vector
     * @returns Distance
     */
    lengthTo(vec: IVector3): number;
    /**
     * Calculates dot product with another Vector3.
     * @param vec - Other vector
     * @returns Dot product
     */
    dot(vec: IVector3): number;
    /**
     * Creates a copy of this vector.
     * @returns New Vector3 instance
     */
    clone(): IVector3;
}
/**
 * Interface for mutable 3D vectors.
 * Provides in-place operations for 3-component vectors including cross product and quaternion multiplication.
 */
interface IMutableVector3 extends IMutableVector {
    /** The class name identifier */
    readonly className: string;
    /** The x component (mutable) */
    x: number;
    /** The y component (mutable) */
    y: number;
    /** The z component (mutable) */
    z: number;
    /** The w component (homogeneous coordinate, read-only) */
    readonly w: number;
    /**
     * Returns a string representation of the vector.
     * @returns String representation
     */
    toString(): string;
    /**
     * Returns an approximate string representation with rounded values.
     * @returns Approximate string representation
     */
    toStringApproximately(): string;
    /**
     * Converts the vector to a flat array.
     * @returns Array containing [x, y, z]
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this is a dummy vector.
     * @returns True if dummy
     */
    isDummy(): boolean;
    /**
     * Checks equality with another Vector3 within tolerance.
     * @param vec - Vector to compare with
     * @param delta - Optional tolerance
     * @returns True if approximately equal
     */
    isEqual(vec: IVector3, delta?: number): boolean;
    /**
     * Checks strict equality with another Vector3.
     * @param vec - Vector to compare with
     * @returns True if exactly equal
     */
    isStrictEqual(vec: IVector3): boolean;
    /**
     * Gets component at index.
     * @param i - Component index (0=x, 1=y, 2=z)
     * @returns Component value
     */
    at(i: number): number;
    /**
     * Calculates vector length.
     * @returns Vector magnitude
     */
    length(): number;
    /**
     * Calculates squared length.
     * @returns Squared magnitude
     */
    lengthSquared(): number;
    /**
     * Calculates distance to another Vector3.
     * @param vec - Target vector
     * @returns Distance
     */
    lengthTo(vec: IVector3): number;
    /**
     * Calculates dot product with another Vector3.
     * @param vec - Other vector
     * @returns Dot product
     */
    dot(vec: IVector3): number;
    /**
     * Creates a copy of this vector.
     * @returns New mutable Vector3 instance
     */
    clone(): IMutableVector3;
    /**
     * Gets the raw underlying typed array.
     * @returns The raw typed array
     */
    raw(): TypedArray;
    /**
     * Sets component at index.
     * @param i - Component index (0=x, 1=y, 2=z)
     * @param value - New value
     * @returns This vector for chaining
     */
    setAt(i: number, value: number): IMutableVector3;
    /**
     * Sets all three components.
     * @param x - X component value
     * @param y - Y component value
     * @param z - Z component value
     * @returns This vector for chaining
     */
    setComponents(x: number, y: number, z: number): IMutableVector3;
    /**
     * Copies components from another Vector3.
     * @param vec - Source vector
     * @returns This vector for chaining
     */
    copyComponents(vec: IVector3): IMutableVector3;
    /**
     * Sets vector to (0, 0, 0).
     * @returns This vector for chaining
     */
    zero(): IMutableVector3;
    /**
     * Sets vector to (1, 1, 1).
     * @returns This vector for chaining
     */
    one(): IMutableVector3;
    /**
     * Normalizes vector to unit length.
     * @returns This vector for chaining
     */
    normalize(): IMutableVector3;
    /**
     * Adds another Vector3 to this vector.
     * @param vec - Vector to add
     * @returns This vector for chaining
     */
    add(vec: IVector3): IMutableVector3;
    /**
     * Subtracts another Vector3 from this vector.
     * @param vec - Vector to subtract
     * @returns This vector for chaining
     */
    subtract(vec: IVector3): IMutableVector3;
    /**
     * Multiplies vector by scalar.
     * @param value - Scalar multiplier
     * @returns This vector for chaining
     */
    multiply(value: number): IMutableVector3;
    /**
     * Multiplies vector component-wise by another Vector3.
     * @param vec - Vector to multiply by
     * @returns This vector for chaining
     */
    multiplyVector(vec: IVector3): IMutableVector3;
    /**
     * Divides vector by scalar.
     * @param value - Scalar divisor
     * @returns This vector for chaining
     */
    divide(value: number): IMutableVector3;
    /**
     * Divides vector component-wise by another Vector3.
     * @param vec - Vector to divide by
     * @returns This vector for chaining
     */
    divideVector(vec: IVector3): IMutableVector3;
    /**
     * Calculates the cross product with another Vector3.
     * @param vec - Vector to cross with
     * @returns This vector for chaining
     */
    cross(vec: IVector3): IMutableVector3;
    /**
     * Multiplies this vector by a quaternion rotation.
     * @param quat - Quaternion to multiply by
     * @returns This vector for chaining
     */
    multiplyQuaternion(quat: IQuaternion): IMutableVector3;
}
/**
 * Interface for immutable 4D vectors.
 * Provides operations specific to 4-component vectors (homogeneous coordinates).
 */
interface IVector4 extends IVector {
    /** The class name identifier */
    readonly className: string;
    /** The x component */
    readonly x: number;
    /** The y component */
    readonly y: number;
    /** The z component */
    readonly z: number;
    /** The w component */
    readonly w: number;
    /**
     * Returns a string representation of the vector.
     * @returns String representation
     */
    toString(): string;
    /**
     * Returns an approximate string representation with rounded values.
     * @returns Approximate string representation
     */
    toStringApproximately(): string;
    /**
     * Converts the vector to a flat array.
     * @returns Array containing [x, y, z, w]
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this is a dummy vector.
     * @returns True if dummy
     */
    isDummy(): boolean;
    /**
     * Checks equality with another Vector4 within tolerance.
     * @param vec - Vector to compare with
     * @param delta - Optional tolerance
     * @returns True if approximately equal
     */
    isEqual(vec: IVector4, delta?: number): boolean;
    /**
     * Checks strict equality with another Vector4.
     * @param vec - Vector to compare with
     * @returns True if exactly equal
     */
    isStrictEqual(vec: IVector4): boolean;
    /**
     * Gets component at index.
     * @param i - Component index (0=x, 1=y, 2=z, 3=w)
     * @returns Component value
     */
    at(i: number): number;
    /**
     * Calculates vector length.
     * @returns Vector magnitude
     */
    length(): number;
    /**
     * Calculates squared length.
     * @returns Squared magnitude
     */
    lengthSquared(): number;
    /**
     * Calculates distance to another Vector4.
     * @param vec - Target vector
     * @returns Distance
     */
    lengthTo(vec: IVector4): number;
    /**
     * Calculates dot product with another Vector4.
     * @param vec - Other vector
     * @returns Dot product
     */
    dot(vec: IVector4): number;
    /**
     * Creates a copy of this vector.
     * @returns New Vector4 instance
     */
    clone(): IVector4;
}
/**
 * Interface for mutable 4D vectors.
 * Provides in-place operations for 4-component vectors including 3D normalization.
 */
interface IMutableVector4 extends IMutableVector {
    /** The class name identifier */
    readonly className: string;
    /** The x component (mutable) */
    x: number;
    /** The y component (mutable) */
    y: number;
    /** The z component (mutable) */
    z: number;
    /** The w component (mutable) */
    w: number;
    /**
     * Returns a string representation of the vector.
     * @returns String representation
     */
    toString(): string;
    /**
     * Returns an approximate string representation with rounded values.
     * @returns Approximate string representation
     */
    toStringApproximately(): string;
    /**
     * Converts the vector to a flat array.
     * @returns Array containing [x, y, z, w]
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this is a dummy vector.
     * @returns True if dummy
     */
    isDummy(): boolean;
    /**
     * Checks equality with another Vector4 within tolerance.
     * @param vec - Vector to compare with
     * @param delta - Optional tolerance
     * @returns True if approximately equal
     */
    isEqual(vec: IVector4, delta?: number): boolean;
    /**
     * Checks strict equality with another Vector4.
     * @param vec - Vector to compare with
     * @returns True if exactly equal
     */
    isStrictEqual(vec: IVector4): boolean;
    /**
     * Gets component at index.
     * @param i - Component index (0=x, 1=y, 2=z, 3=w)
     * @returns Component value
     */
    at(i: number): number;
    /**
     * Calculates vector length.
     * @returns Vector magnitude
     */
    length(): number;
    /**
     * Calculates squared length.
     * @returns Squared magnitude
     */
    lengthSquared(): number;
    /**
     * Calculates distance to another Vector4.
     * @param vec - Target vector
     * @returns Distance
     */
    lengthTo(vec: IVector4): number;
    /**
     * Calculates dot product with another Vector4.
     * @param vec - Other vector
     * @returns Dot product
     */
    dot(vec: IVector4): number;
    /**
     * Creates a copy of this vector.
     * @returns New mutable Vector4 instance
     */
    clone(): IMutableVector4;
    /**
     * Gets the raw underlying typed array.
     * @returns The raw typed array
     */
    raw(): TypedArray;
    /**
     * Sets component at index.
     * @param i - Component index (0=x, 1=y, 2=z, 3=w)
     * @param value - New value
     * @returns This vector for chaining
     */
    setAt(i: number, value: number): IMutableVector4;
    /**
     * Sets all four components.
     * @param x - X component value
     * @param y - Y component value
     * @param z - Z component value
     * @param w - W component value
     * @returns This vector for chaining
     */
    setComponents(x: number, y: number, z: number, w: number): IMutableVector4;
    /**
     * Copies components from another Vector4.
     * @param vec - Source vector
     * @returns This vector for chaining
     */
    copyComponents(vec: IVector4): IMutableVector4;
    /**
     * Sets vector to (0, 0, 0, 0).
     * @returns This vector for chaining
     */
    zero(): IMutableVector4;
    /**
     * Sets vector to (1, 1, 1, 1).
     * @returns This vector for chaining
     */
    one(): IMutableVector4;
    /**
     * Normalizes vector to unit length (4D normalization).
     * @returns This vector for chaining
     */
    normalize(): IMutableVector4;
    /**
     * Normalizes only the xyz components, leaving w unchanged (3D normalization).
     * @returns This vector for chaining
     */
    normalize3(): IMutableVector4;
    /**
     * Adds another Vector4 to this vector.
     * @param vec - Vector to add
     * @returns This vector for chaining
     */
    add(vec: IVector4): IMutableVector4;
    /**
     * Subtracts another Vector4 from this vector.
     * @param vec - Vector to subtract
     * @returns This vector for chaining
     */
    subtract(vec: IVector4): IMutableVector4;
    /**
     * Multiplies vector by scalar.
     * @param value - Scalar multiplier
     * @returns This vector for chaining
     */
    multiply(value: number): IMutableVector4;
    /**
     * Multiplies vector component-wise by another Vector4.
     * @param vec - Vector to multiply by
     * @returns This vector for chaining
     */
    multiplyVector(vec: IVector4): IMutableVector4;
    /**
     * Divides vector by scalar.
     * @param value - Scalar divisor
     * @returns This vector for chaining
     */
    divide(value: number): IMutableVector4;
    /**
     * Divides vector component-wise by another Vector4.
     * @param vec - Vector to divide by
     * @returns This vector for chaining
     */
    divideVector(vec: IVector4): IMutableVector4;
}

/**
 * Abstract base class for vector implementations.
 * Provides common functionality and defines the interface that all vector classes must implement.
 * This class handles basic vector operations and serves as a foundation for specific vector types.
 */
declare abstract class AbstractVector implements IVector {
    /** Internal typed array storage for vector components */
    _v: TypedArray;
    /**
     * Gets the x-component (first component) of the vector.
     * @returns The x-component value
     */
    get x(): number;
    /**
     * Gets the GLSL string representation of the vector as float values.
     * @returns GLSL-formatted string for float values
     * @throws Error - Must be implemented by subclasses
     */
    get glslStrAsFloat(): string;
    /**
     * Gets the GLSL string representation of the vector as integer values.
     * @returns GLSL-formatted string for integer values
     * @throws Error - Must be implemented by subclasses
     */
    get glslStrAsInt(): string;
    /**
     * Gets the WGSL string representation of the vector as float values.
     * @returns WGSL-formatted string for float values
     * @throws Error - Must be implemented by subclasses
     */
    get wgslStrAsFloat(): string;
    /**
     * Gets the WGSL string representation of the vector as integer values.
     * @returns WGSL-formatted string for integer values
     * @throws Error - Must be implemented by subclasses
     */
    get wgslStrAsInt(): string;
    /**
     * Checks if this vector is approximately equal to another vector within a specified tolerance.
     * @param vec - The vector to compare against
     * @param delta - Optional tolerance value for comparison
     * @returns True if vectors are approximately equal, false otherwise
     * @throws Error - Must be implemented by subclasses
     */
    isEqual(_vec: IVector, _delta?: number): boolean;
    /**
     * Checks if this vector is strictly equal to another vector (exact equality).
     * @param vec - The vector to compare against
     * @returns True if vectors are exactly equal, false otherwise
     * @throws Error - Must be implemented by subclasses
     */
    isStrictEqual(_vec: IVector): boolean;
    /**
     * Calculates the length (magnitude) of the vector.
     * @returns The length of the vector
     * @throws Error - Must be implemented by subclasses
     */
    length(): number;
    /**
     * Calculates the squared length of the vector.
     * This is more efficient than length() when only relative comparisons are needed.
     * @returns The squared length of the vector
     * @throws Error - Must be implemented by subclasses
     */
    lengthSquared(): number;
    /**
     * Calculates the distance from this vector to another vector.
     * @param vec - The target vector
     * @returns The distance between the vectors
     * @throws Error - Must be implemented by subclasses
     */
    lengthTo(_vec: IVector): number;
    /**
     * Calculates the dot product between this vector and another vector.
     * @param vec - The vector to calculate dot product with
     * @returns The dot product result
     * @throws Error - Must be implemented by subclasses
     */
    dot(_vec: IVector): number;
    /**
     * Gets the component value at the specified index.
     * @param i - The index of the component to retrieve
     * @returns The component value at the given index
     */
    at(i: number): number;
    /**
     * Converts the vector to its string representation.
     * @returns String representation of the vector
     * @throws Error - Must be implemented by subclasses
     */
    toString(): string;
    /**
     * Converts the vector to an approximate string representation.
     * Useful for debugging when exact precision is not required.
     * @returns Approximate string representation of the vector
     * @throws Error - Must be implemented by subclasses
     */
    toStringApproximately(): string;
    /**
     * Converts the vector to a flat array of numbers.
     * @returns Array containing all vector components
     * @throws Error - Must be implemented by subclasses
     */
    flattenAsArray(): number[];
    /**
     * Checks if this vector is a dummy (empty) vector.
     * A dummy vector has no components and is typically used as a placeholder.
     * @returns True if the vector is dummy, false otherwise
     */
    isDummy(): boolean;
    /**
     * Gets the component value at the specified index.
     * Alias for the at() method for convenience.
     * @param i - The index of the component to retrieve
     * @returns The component value at the given index
     */
    v(i: number): number;
    /**
     * Checks if the internal storage shares the same ArrayBuffer as the provided one.
     * Useful for determining if vectors share underlying memory.
     * @param arrayBuffer - The ArrayBuffer to compare against
     * @returns True if the same ArrayBuffer is used, false otherwise
     */
    isTheSourceSame(arrayBuffer: ArrayBuffer): boolean;
    /**
     * Gets the class name of this vector instance.
     * @returns The constructor name of the class
     */
    get className(): string;
    /**
     * Gets the number of bytes per component in the underlying typed array.
     * @returns Bytes per component
     * @throws Error - Must be implemented by subclasses
     */
    get bytesPerComponent(): number;
}

/**
 * Generic base class for 3D vectors with floating-point components.
 * This class provides immutable 3D vector operations and serves as the foundation
 * for both 32-bit and 64-bit precision vector implementations.
 *
 * @template T - The typed array constructor (Float32Array or Float64Array)
 * @internal
 */
declare class Vector3_<T extends FloatTypedArrayConstructor> extends AbstractVector implements IVector, IVector3 {
    /**
     * Creates a new Vector3_ instance.
     * @param v - The typed array containing the vector components
     * @param type - Configuration object containing the typed array constructor
     */
    constructor(v: TypedArray, _options: {
        type: T;
    });
    /**
     * Gets the X component of the vector.
     * @returns The X component value
     */
    get x(): number;
    /**
     * Gets the Y component of the vector.
     * @returns The Y component value
     */
    get y(): number;
    /**
     * Gets the Z component of the vector.
     * @returns The Z component value
     */
    get z(): number;
    /**
     * Gets the W component of the vector (always returns 1 for homogeneous coordinates).
     * @returns Always returns 1
     */
    get w(): number;
    /**
     * Gets the GLSL representation of this vector as a float vec3.
     * @returns A string representation suitable for GLSL shaders
     */
    get glslStrAsFloat(): string;
    /**
     * Gets the GLSL representation of this vector as an integer ivec3.
     * @returns A string representation suitable for GLSL shaders with integer components
     */
    get glslStrAsInt(): string;
    /**
     * Gets the WGSL representation of this vector as a float vec3f.
     * @returns A string representation suitable for WGSL shaders
     */
    get wgslStrAsFloat(): string;
    /**
     * Gets the WGSL representation of this vector as an integer vec3i.
     * @returns A string representation suitable for WGSL shaders with integer components
     */
    get wgslStrAsInt(): string;
    /**
     * Gets the composition type for this vector class.
     * @returns The composition type (Vec3)
     */
    static get compositionType(): {
        readonly __numberOfComponents: number;
        readonly __glslStr: string;
        readonly __hlslStr: string;
        readonly __webgpuStr: string;
        readonly __wgslStr: string;
        readonly __isArray: boolean;
        readonly __vec4SizeOfProperty: IndexOf16Bytes;
        readonly __dummyStr: "VEC3";
        readonly webgpu: string;
        readonly wgsl: string;
        getNumberOfComponents(): Count;
        getGlslStr(componentType: ComponentTypeEnum): string;
        getGlslInitialValue(componentType: ComponentTypeEnum): string;
        getWgslInitialValue(componentType: ComponentTypeEnum): string;
        toWGSLType(componentType: ComponentTypeEnum): string;
        getVec4SizeOfProperty(): IndexOf16Bytes;
        readonly index: number;
        readonly symbol: symbol;
        readonly str: string;
        toString(): string;
        toJSON(): number;
    };
    /**
     * Calculates the squared length of a vector (static version).
     * This is more efficient than calculating the actual length when only comparison is needed.
     * @param vec - The vector to calculate squared length for
     * @returns The squared length of the vector
     */
    static lengthSquared(vec: IVector3): number;
    /**
     * Calculates the distance between two vectors.
     * @param l_vec - The first vector
     * @param r_vec - The second vector
     * @returns The distance between the two vectors
     */
    static lengthBtw(l_vec: IVector3, r_vec: IVector3): number;
    /**
     * Calculates the angle between two vectors in radians.
     * @param l_vec - The first vector
     * @param r_vec - The second vector
     * @returns The angle between the vectors in radians
     * @throws Error if either vector has zero length
     */
    static angleOfVectors(l_vec: IVector3, r_vec: IVector3): number;
    /**
     * Creates a zero vector (0, 0, 0).
     * @param type - The typed array constructor to use
     * @returns A new zero vector
     */
    static _zero(type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Creates a vector with all components set to 1 (1, 1, 1).
     * @param type - The typed array constructor to use
     * @returns A new vector with all components set to 1
     */
    static _one(type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Creates an empty dummy vector for placeholder purposes.
     * @param type - The typed array constructor to use
     * @returns A new dummy vector
     */
    static _dummy(type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Normalizes a vector to unit length (static version).
     * @param vec - The vector to normalize
     * @param type - The typed array constructor to use
     * @returns A new normalized vector
     */
    static _normalize(vec: IVector3, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Normalizes a vector and stores the result in the output vector.
     * @param vec - The vector to normalize
     * @param out - The output vector to store the result
     * @returns The output vector containing the normalized result
     */
    static normalizeTo(vec: IVector3, out: IMutableVector3): IMutableVector3;
    /**
     * Adds two vectors component-wise (static version).
     * @param l_vec - The first vector
     * @param r_vec - The second vector
     * @param type - The typed array constructor to use
     * @returns A new vector containing the sum
     */
    static _add(l_vec: IVector3, r_vec: IVector3, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Adds two vectors and stores the result in the output vector.
     * @param l_vec - The first vector
     * @param r_vec - The second vector
     * @param out - The output vector to store the result
     * @returns The output vector containing the sum
     */
    static addTo(l_vec: IVector3, r_vec: IVector3, out: IMutableVector3): IMutableVector3;
    /**
     * Subtracts the second vector from the first vector (static version).
     * @param l_vec - The vector to subtract from
     * @param r_vec - The vector to subtract
     * @param type - The typed array constructor to use
     * @returns A new vector containing the difference
     */
    static _subtract(l_vec: IVector3, r_vec: IVector3, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Subtracts two vectors and stores the result in the output vector.
     * @param l_vec - The vector to subtract from
     * @param r_vec - The vector to subtract
     * @param out - The output vector to store the result
     * @returns The output vector containing the difference
     */
    static subtractTo(l_vec: IVector3, r_vec: IVector3, out: IMutableVector3): IMutableVector3;
    /**
     * Multiplies a vector by a scalar value (static version).
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @param type - The typed array constructor to use
     * @returns A new vector containing the scaled result
     */
    static _multiply(vec: IVector3, value: number, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Multiplies a vector by a scalar and stores the result in the output vector.
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @param out - The output vector to store the result
     * @returns The output vector containing the scaled result
     */
    static multiplyTo(vec: IVector3, value: number, out: IMutableVector3): IMutableVector3;
    /**
     * Multiplies two vectors component-wise (static version).
     * @param l_vec - The first vector
     * @param r_vec - The second vector
     * @param type - The typed array constructor to use
     * @returns A new vector containing the component-wise product
     */
    static _multiplyVector(l_vec: IVector3, r_vec: IVector3, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Multiplies two vectors component-wise and stores the result in the output vector.
     * @param l_vec - The first vector
     * @param r_vec - The second vector
     * @param out - The output vector to store the result
     * @returns The output vector containing the component-wise product
     */
    static multiplyVectorTo(l_vec: IVector3, r_vec: IVector3, out: IMutableVector3): IMutableVector3;
    /**
     * Transforms a 3D vector by a 4x4 matrix, treating the vector as a point (w=1).
     * The result is perspective-divided if the w component is not 1.
     * @param vec - The vector to transform
     * @param mat - The 4x4 transformation matrix
     * @param type - The typed array constructor to use
     * @returns A new transformed vector
     */
    static _multiplyMatrix4(vec: IVector3, mat: IMatrix44, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Divides a vector by a scalar value (static version).
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @param type - The typed array constructor to use
     * @returns A new vector containing the divided result
     * @throws Error if division by zero occurs
     */
    static _divide(vec: IVector3, value: number, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Divides a vector by a scalar and stores the result in the output vector.
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @param out - The output vector to store the result
     * @returns The output vector containing the divided result
     * @throws Error if division by zero occurs
     */
    static divideTo(vec: IVector3, value: number, out: IMutableVector3): IMutableVector3;
    /**
     * Divides two vectors component-wise (static version).
     * @param l_vec - The vector to divide
     * @param r_vec - The vector to divide by
     * @param type - The typed array constructor to use
     * @returns A new vector containing the component-wise division result
     * @throws Error if division by zero occurs
     */
    static _divideVector(l_vec: IVector3, r_vec: IVector3, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Divides two vectors component-wise and stores the result in the output vector.
     * @param l_vec - The vector to divide
     * @param r_vec - The vector to divide by
     * @param out - The output vector to store the result
     * @returns The output vector containing the component-wise division result
     * @throws Error if division by zero occurs
     */
    static divideVectorTo(l_vec: IVector3, r_vec: IVector3, out: IMutableVector3): IMutableVector3;
    /**
     * Calculates the dot product of two vectors (static version).
     * @param l_vec - The first vector
     * @param r_vec - The second vector
     * @returns The dot product of the two vectors
     */
    static dot(l_vec: IVector3, r_vec: IVector3): number;
    /**
     * Calculates the cross product of two vectors (static version).
     * @param l_vec - The first vector (left operand)
     * @param r_vec - The second vector (right operand)
     * @param type - The typed array constructor to use
     * @returns A new vector containing the cross product result
     */
    static _cross(l_vec: IVector3, r_vec: IVector3, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Calculates the cross product of two vectors and stores the result in the output vector.
     * @param l_vec - The first vector (left operand)
     * @param r_vec - The second vector (right operand)
     * @param out - The output vector to store the result
     * @returns The output vector containing the cross product result
     */
    static crossTo(l_vec: IVector3, r_vec: IVector3, out: IMutableVector3): IMutableVector3;
    /**
     * Transforms a vector by a quaternion rotation (static version).
     * This applies the quaternion rotation to the vector.
     * @param quat - The quaternion to apply
     * @param vec - The vector to transform
     * @param type - The typed array constructor to use
     * @returns A new vector containing the transformed result
     */
    static _multiplyQuaternion(quat: IQuaternion, vec: IVector3, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Transforms a vector by a quaternion rotation and stores the result in the output vector.
     * This applies the quaternion rotation to the vector.
     * @param quat - The quaternion to apply
     * @param vec - The vector to transform
     * @param out - The output vector to store the result
     * @returns The output vector containing the transformed result
     */
    static multiplyQuaternionTo(quat: IQuaternion, vec: IVector3, out: IMutableVector3): IMutableVector3;
    /**
     * Converts the vector to a string representation.
     * @returns A string representation of the vector in the format "(x, y, z)"
     */
    toString(): string;
    /**
     * Converts the vector to an approximate string representation with limited decimal places.
     * @returns A string representation with financial formatting
     */
    toStringApproximately(): string;
    /**
     * Converts the vector to a flat array.
     * @returns An array containing the x, y, and z components
     */
    flattenAsArray(): number[];
    /**
     * Checks if this vector is a dummy vector (empty).
     * @returns True if the vector is dummy (has no components), false otherwise
     */
    isDummy(): boolean;
    /**
     * Checks if this vector is approximately equal to another vector within a tolerance.
     * @param vec - The vector to compare with
     * @param delta - The tolerance for comparison (default: Number.EPSILON)
     * @returns True if vectors are approximately equal, false otherwise
     */
    isEqual(vec: IVector3, delta?: number): boolean;
    /**
     * Checks if this vector is strictly equal to another vector (exact comparison).
     * @param vec - The vector to compare with
     * @returns True if vectors are exactly equal, false otherwise
     */
    isStrictEqual(vec: IVector3): boolean;
    /**
     * Gets the component at the specified index.
     * @param i - The index (0 for x, 1 for y, 2 for z)
     * @returns The component value at the specified index
     */
    at(i: number): number;
    /**
     * Calculates the length (magnitude) of the vector.
     * @returns The length of the vector
     */
    length(): number;
    /**
     * Calculates the squared length of the vector.
     * This is more efficient than calculating the actual length when only comparison is needed.
     * @returns The squared length of the vector
     */
    lengthSquared(): number;
    /**
     * Calculates the distance from this vector to another vector.
     * @param vec - The target vector
     * @returns The distance between the vectors
     */
    lengthTo(vec: IVector3): number;
    /**
     * Calculates the dot product of this vector with another vector.
     * @param vec - The vector to calculate dot product with
     * @returns The dot product result
     */
    dot(vec: IVector3): number;
    /**
     * Gets the class name.
     * @returns The class name "Vector3"
     */
    get className(): string;
    /**
     * Creates a copy of this vector.
     * @returns A new vector with the same components
     */
    clone(): any;
    /**
     * Gets the number of bytes per component.
     * @returns The number of bytes per component (4 for Float32Array, 8 for Float64Array)
     */
    get bytesPerComponent(): number;
    /**
     * Performs linear interpolation between two vectors (static version).
     * @param lhs - The start vector
     * @param rhs - The end vector
     * @param ratio - The interpolation ratio (0.0 to 1.0)
     * @param type - The typed array constructor to use
     * @returns A new vector containing the interpolated result
     */
    static _lerp(lhs: IVector3, rhs: IVector3, ratio: number, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Creates a vector from a 3-element array.
     * @param array - The array containing x, y, z components
     * @param type - The typed array constructor to use
     * @returns A new vector
     */
    static _fromCopyArray3(array: Array3<number>, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Creates a vector from individual x, y, z components.
     * @param x - The x component
     * @param y - The y component
     * @param z - The z component
     * @param type - The typed array constructor to use
     * @returns A new vector
     */
    static _fromCopy3(x: number, y: number, z: number, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Creates a vector from an array (takes first 3 elements).
     * @param array - The array containing the components
     * @param type - The typed array constructor to use
     * @returns A new vector
     */
    static _fromCopyArray(array: Array<number>, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Creates a vector by copying from another Vector3.
     * @param vec3 - The source vector to copy from
     * @param type - The typed array constructor to use
     * @returns A new vector
     */
    static _fromCopyVector3(vec3: IVector3, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Creates a Vector3 from a Vector4 (drops the w component).
     * @param vec4 - The source Vector4 to copy from
     * @param type - The typed array constructor to use
     * @returns A new vector
     */
    static _fromCopyVector4(vec4: IVector4, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
    /**
     * Creates a Vector3 from a Vector2 (sets z component to 0).
     * @param vec2 - The source Vector2 to copy from
     * @param type - The typed array constructor to use
     * @returns A new vector
     */
    static _fromVector2(vec2: IVector2, type: FloatTypedArrayConstructor): Vector3_<FloatTypedArrayConstructor>;
}
/**
 * Immutable 3D vector class with 32-bit float components.
 * This is the standard precision implementation for most 3D graphics operations.
 * Provides efficient vector operations for position, direction, and other 3D calculations.
 *
 * @example
 * ```typescript
 * const v1 = Vector3.fromCopy3(1, 2, 3);
 * const v2 = Vector3.fromCopy3(4, 5, 6);
 * const sum = Vector3.add(v1, v2);
 * ```
 */
declare class Vector3 extends Vector3_<Float32ArrayConstructor> {
    /**
     * Creates a new Vector3 instance from a typed array.
     * @param v - The Float32Array containing the vector components
     */
    constructor(v: TypedArray);
    /**
     * Creates a vector from a 3-element array.
     * @param array - Array containing [x, y, z] components
     * @returns A new Vector3 instance
     */
    static fromCopyArray3(array: Array3<number>): Vector3;
    /**
     * Creates a vector from individual x, y, z components.
     * @param x - The x component
     * @param y - The y component
     * @param z - The z component
     * @returns A new Vector3 instance
     */
    static fromCopy3(x: number, y: number, z: number): Vector3;
    /**
     * Creates a vector with all components set to the same value.
     * @param val - The value to set for all components
     * @returns A new Vector3 instance
     */
    static fromCopy1(val: number): Vector3;
    /**
     * Creates a vector from an array (takes first 3 elements).
     * @param array - The array containing the components
     * @returns A new Vector3 instance
     */
    static fromCopyArray(array: Array<number>): Vector3;
    /**
     * Creates a vector by copying from another Vector3.
     * @param vec3 - The source vector to copy from
     * @returns A new Vector3 instance
     */
    static fromCopyVector3(vec3: IVector3): Vector3;
    /**
     * Creates a Vector3 from a Vector4 (drops the w component).
     * @param vec4 - The source Vector4 to copy from
     * @returns A new Vector3 instance
     */
    static fromCopyVector4(vec4: IVector4): Vector3;
    /**
     * Creates a vector from an ArrayBuffer.
     * @param arrayBuffer - The ArrayBuffer containing the vector data
     * @returns A new Vector3 instance
     */
    static fromArrayBuffer(arrayBuffer: ArrayBuffer): Vector3;
    /**
     * Creates a vector from a Float32Array.
     * @param float32Array - The Float32Array containing the vector data
     * @returns A new Vector3 instance
     */
    static fromFloat32Array(float32Array: Float32Array): Vector3;
    /**
     * Creates a vector by copying data from a Float32Array.
     * @param float32Array - The Float32Array to copy from
     * @returns A new Vector3 instance
     */
    static fromCopyFloat32Array(float32Array: Float32Array): Vector3;
    /**
     * Creates a zero vector (0, 0, 0).
     * @returns A new Vector3 instance with all components set to 0
     */
    static zero(): Vector3;
    /**
     * Creates a vector with all components set to 1 (1, 1, 1).
     * @returns A new Vector3 instance with all components set to 1
     */
    static one(): Vector3;
    /**
     * Creates an empty dummy vector for placeholder purposes.
     * @returns A new dummy Vector3 instance
     */
    static dummy(): Vector3;
    /**
     * Normalizes a vector to unit length.
     * @param vec - The vector to normalize
     * @returns A new normalized Vector3 instance
     */
    static normalize(vec: IVector3): Vector3;
    /**
     * Adds two vectors component-wise.
     * @param l_vec - The first vector
     * @param r_vec - The second vector
     * @returns A new Vector3 instance containing the sum
     */
    static add(l_vec: IVector3, r_vec: IVector3): Vector3;
    /**
     * Subtracts the second vector from the first vector.
     * @param l_vec - The vector to subtract from
     * @param r_vec - The vector to subtract
     * @returns A new Vector3 instance containing the difference
     */
    static subtract(l_vec: IVector3, r_vec: IVector3): Vector3;
    /**
     * Multiplies a vector by a scalar value.
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @returns A new Vector3 instance containing the scaled result
     */
    static multiply(vec: IVector3, value: number): Vector3;
    /**
     * Multiplies two vectors component-wise.
     * @param l_vec - The first vector
     * @param r_vec - The second vector
     * @returns A new Vector3 instance containing the component-wise product
     */
    static multiplyVector(l_vec: IVector3, r_vec: IVector3): Vector3;
    /**
     * Transforms a 3D vector by a 4x4 matrix.
     * @param vec - The vector to transform
     * @param mat - The 4x4 transformation matrix
     * @returns A new Vector3 instance containing the transformed result
     */
    static multiplyMatrix4(vec: IVector3, mat: IMatrix44): Vector3;
    /**
     * Divides a vector by a scalar value.
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @returns A new Vector3 instance containing the divided result
     */
    static divide(vec: IVector3, value: number): Vector3;
    /**
     * Divides two vectors component-wise.
     * @param l_vec - The vector to divide
     * @param r_vec - The vector to divide by
     * @returns A new Vector3 instance containing the component-wise division result
     */
    static divideVector(l_vec: IVector3, r_vec: IVector3): Vector3;
    /**
     * Calculates the cross product of two vectors.
     * @param l_vec - The first vector (left operand)
     * @param r_vec - The second vector (right operand)
     * @returns A new Vector3 instance containing the cross product result
     */
    static cross(l_vec: IVector3, r_vec: IVector3): Vector3;
    /**
     * Transforms a vector by a quaternion rotation.
     * @param quat - The quaternion to apply
     * @param vec - The vector to transform
     * @returns A new Vector3 instance containing the transformed result
     */
    static multiplyQuaternion(quat: IQuaternion, vec: IVector3): Vector3;
    /**
     * Performs linear interpolation between two vectors.
     * @param lhs - The start vector
     * @param rhs - The end vector
     * @param ratio - The interpolation ratio (0.0 to 1.0)
     * @returns A new Vector3 instance containing the interpolated result
     */
    static lerp(lhs: IVector3, rhs: IVector3, ratio: number): Vector3;
}
/**
 * Immutable 3D vector class with 64-bit float components.
 * This high-precision implementation is suitable for applications requiring
 * double precision floating-point calculations, such as scientific computing
 * or when dealing with very large coordinate systems.
 *
 * @example
 * ```typescript
 * const v1 = Vector3d.fromCopy3(1.123456789, 2.987654321, 3.456789123);
 * const v2 = Vector3d.fromCopy3(4.111111111, 5.222222222, 6.333333333);
 * const sum = Vector3d.add(v1, v2);
 * ```
 */
declare class Vector3d extends Vector3_<Float64ArrayConstructor> {
    /**
     * Creates a new Vector3d instance from a typed array.
     * @param v - The Float64Array containing the vector components
     */
    private constructor();
    /**
     * Creates a vector from a 3-element array.
     * @param array - Array containing [x, y, z] components
     * @returns A new Vector3d instance
     */
    static fromCopyArray3(array: Array3<number>): Vector3d;
    /**
     * Creates a vector from individual x, y, z components.
     * @param x - The x component
     * @param y - The y component
     * @param z - The z component
     * @returns A new Vector3d instance
     */
    static fromCopy3(x: number, y: number, z: number): Vector3d;
    /**
     * Creates a vector with all components set to the same value.
     * @param val - The value to set for all components
     * @returns A new Vector3d instance
     */
    static fromCopy1(val: number): Vector3d;
    /**
     * Creates a vector from an array (takes first 3 elements).
     * @param array - The array containing the components
     * @returns A new Vector3d instance
     */
    static fromCopyArray(array: Array<number>): Vector3d;
    /**
     * Creates a vector from an ArrayBuffer.
     * @param arrayBuffer - The ArrayBuffer containing the vector data
     * @returns A new Vector3d instance
     */
    static fromArrayBuffer(arrayBuffer: ArrayBuffer): Vector3d;
    /**
     * Creates a vector from a Float64Array.
     * @param float64Array - The Float64Array containing the vector data
     * @returns A new Vector3d instance
     */
    static fromFloat64Array(float64Array: Float64Array): Vector3d;
    /**
     * Creates a zero vector (0, 0, 0).
     * @returns A new Vector3d instance with all components set to 0
     */
    static zero(): Vector3d;
    /**
     * Creates a vector with all components set to 1 (1, 1, 1).
     * @returns A new Vector3d instance with all components set to 1
     */
    static one(): Vector3d;
    /**
     * Creates an empty dummy vector for placeholder purposes.
     * @returns A new dummy Vector3d instance
     */
    static dummy(): Vector3d;
    /**
     * Normalizes a vector to unit length.
     * @param vec - The vector to normalize
     * @returns A new normalized Vector3d instance
     */
    static normalize(vec: IVector3): Vector3d;
    /**
     * Adds two vectors component-wise.
     * @param l_vec - The first vector
     * @param r_vec - The second vector
     * @returns A new Vector3d instance containing the sum
     */
    static add(l_vec: IVector3, r_vec: IVector3): Vector3d;
    /**
     * Subtracts the second vector from the first vector.
     * @param l_vec - The vector to subtract from
     * @param r_vec - The vector to subtract
     * @returns A new Vector3d instance containing the difference
     */
    static subtract(l_vec: IVector3, r_vec: IVector3): Vector3d;
    /**
     * Multiplies a vector by a scalar value.
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @returns A new Vector3d instance containing the scaled result
     */
    static multiply(vec: IVector3, value: number): Vector3d;
    /**
     * Multiplies two vectors component-wise.
     * @param l_vec - The first vector
     * @param r_vec - The second vector
     * @returns A new Vector3d instance containing the component-wise product
     */
    static multiplyVector(l_vec: IVector3, r_vec: IVector3): Vector3d;
    /**
     * Transforms a 3D vector by a 4x4 matrix.
     * @param vec - The vector to transform
     * @param mat - The 4x4 transformation matrix
     * @returns A new Vector3d instance containing the transformed result
     */
    static multiplyMatrix4(vec: IVector3, mat: IMatrix44): Vector3d;
    /**
     * Divides a vector by a scalar value.
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @returns A new Vector3d instance containing the divided result
     */
    static divide(vec: IVector3, value: number): Vector3d;
    /**
     * Divides two vectors component-wise.
     * @param l_vec - The vector to divide
     * @param r_vec - The vector to divide by
     * @returns A new Vector3d instance containing the component-wise division result
     */
    static divideVector(l_vec: IVector3, r_vec: IVector3): Vector3d;
    /**
     * Calculates the cross product of two vectors.
     * @param l_vec - The first vector (left operand)
     * @param r_vec - The second vector (right operand)
     * @returns A new Vector3d instance containing the cross product result
     */
    static cross(l_vec: IVector3, r_vec: IVector3): Vector3d;
    /**
     * Transforms a vector by a quaternion rotation.
     * @param quat - The quaternion to apply
     * @param vec - The vector to transform
     * @returns A new Vector3d instance containing the transformed result
     */
    static multiplyQuaternion(quat: IQuaternion, vec: IVector3): Vector3d;
    /**
     * Performs linear interpolation between two vectors.
     * @param lhs - The start vector
     * @param rhs - The end vector
     * @param ratio - The interpolation ratio (0.0 to 1.0)
     * @returns A new Vector3d instance containing the interpolated result
     */
    static lerp(lhs: IVector3, rhs: IVector3, ratio: number): Vector3d;
}
/**
 * Type alias for Vector3 with 32-bit float precision.
 * @deprecated Use Vector3 directly instead
 */
type Vector3f = Vector3;
/**
 * Constant vector representing (1, 1, 1).
 * Useful for scaling operations or as a default "one" value.
 */
declare const ConstVector3_1_1_1: Vector3;
/**
 * Constant vector representing (0, 0, 0).
 * Useful as an origin point or for zero/null vector operations.
 */
declare const ConstVector3_0_0_0: Vector3;

/**
 * The Component that represents a light.
 *
 * @remarks
 * the light looks towards the local -Z axis in right hand coordinate system.
 */
declare class LightComponent extends Component {
    type: EnumIO;
    private __color;
    private __intensity;
    private readonly __initialDirection;
    private __direction;
    innerConeAngle: number;
    outerConeAngle: number;
    range: number;
    enable: boolean;
    shadowAreaSizeForDirectionalLight: number;
    castShadow: boolean;
    private static __globalDataRepository;
    private static __tmp_vec4;
    private static __lightPositions;
    private static __lightDirections;
    private static __lightIntensities;
    private static __lightProperties;
    private static __lightNumber;
    private __lightGizmo?;
    private __updateCount;
    private __lastUpdateCount;
    private __lastTransformUpdateCount;
    /**
     * Creates a new LightComponent instance.
     *
     * @param entityUid - The unique identifier of the entity this component belongs to
     * @param componentSid - The component session identifier
     * @param entityRepository - The entity repository instance
     * @param isReUse - Whether this component is being reused
     */
    constructor(entityUid: EntityUID, componentSid: ComponentSID, entityRepository: EntityRepository, isReUse: boolean);
    /**
     * Gets the component type identifier for LightComponent.
     *
     * @returns The component type identifier
     */
    static get componentTID(): ComponentTID;
    /**
     * Gets the component type identifier for this instance.
     *
     * @returns The component type identifier
     */
    get componentTID(): ComponentTID;
    /**
     * Gets the current update count of this light component.
     * The update count is incremented whenever the light properties change.
     *
     * @returns The current update count
     */
    get updateCount(): number;
    /**
     * Gets the current direction vector of the light.
     * This direction is calculated based on the transform component's rotation.
     *
     * @returns The normalized direction vector
     */
    get direction(): Vector3;
    /**
     * Sets the intensity of the light.
     *
     * @param value - The intensity value (typically 0.0 to 1.0, but can be higher for HDR)
     */
    set intensity(value: number);
    /**
     * Gets the intensity of the light.
     *
     * @returns The current intensity value
     */
    get intensity(): number;
    /**
     * Sets the color of the light.
     *
     * @param value - The RGB color vector (values typically 0.0 to 1.0)
     */
    set color(value: Vector3);
    /**
     * Gets the color of the light.
     *
     * @returns The RGB color vector
     */
    get color(): Vector3;
    /**
     * Gets the up vector for the light in local space.
     * This is used for light orientation calculations.
     *
     * @returns The up vector (0, 1, 0)
     */
    get _up(): Vector3;
    /**
     * Sets the visibility of the light gizmo in the editor.
     * When enabled, creates and shows a visual representation of the light.
     *
     * @param flg - True to show the gizmo, false to hide it
     */
    set isLightGizmoVisible(flg: boolean);
    /**
     * Gets the visibility state of the light gizmo.
     *
     * @returns True if the gizmo is visible, false otherwise
     */
    get isLightGizmoVisible(): boolean;
    /**
     * Initializes the light component by loading global data repositories.
     * This method is called during the component loading phase.
     */
    $load(): void;
    /**
     * Updates the light gizmo if it exists and is visible.
     * This is called internally during the logic update phase.
     *
     * @private
     */
    private __updateGizmo;
    /**
     * Common logic update method that runs once per frame for all light components.
     * Updates the global light count for the shader system.
     *
     * @static
     */
    static common_$logic(): void;
    /**
     * Updates the light component's state and uploads data to the GPU.
     * This method calculates the light direction, position, and properties,
     * then stores them in global data arrays for shader access.
     *
     * @remarks
     * This method implements performance optimization by checking update counts
     * to avoid unnecessary recalculations when nothing has changed.
     */
    $logic(): void;
    /**
     * Cleans up the light component when it's being destroyed.
     * Resets the light intensity values in the global data arrays.
     *
     * @override
     */
    _destroy(): void;
    /**
     * Gets the entity that owns this light component.
     *
     * @returns The light entity instance with light-specific methods
     */
    get entity(): ILightEntity;
    /**
     * Adds light-specific methods to an entity class through mixin composition.
     * This method extends the base entity with light component functionality.
     *
     * @template EntityBase - The base entity type
     * @template SomeComponentClass - The component class type
     * @param base - The base entity instance to extend
     * @param _componentClass - The component class (unused but required for type compatibility)
     * @returns The extended entity with light component methods
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBase, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBase;
}

interface ILightEntityMethods {
    getLight(): LightComponent;
}

/**
 * Abstract base class for matrix implementations.
 *
 * This class provides a common interface and basic functionality for all matrix types
 * in the system. It implements the IMatrix interface and serves as the foundation
 * for concrete matrix classes like Matrix44, Matrix33, etc.
 *
 * @abstract
 */
declare abstract class AbstractMatrix implements IMatrix {
    /** Internal Float32Array storage for matrix elements */
    _v: Float32Array;
    /**
     * Gets the matrix element at the specified row and column.
     *
     * @param row_i - The zero-based row index
     * @param column_i - The zero-based column index
     * @returns The matrix element value at the specified position
     * @throws Error when not implemented in derived classes
     */
    at(_row_i: number, _column_i: number): number;
    /**
     * Converts the matrix to a string representation.
     *
     * @returns A string representation of the matrix
     * @throws Error when not implemented in derived classes
     */
    toString(): string;
    /**
     * Converts the matrix to an approximate string representation.
     *
     * This method is useful for displaying matrices with rounded values
     * for better readability in debugging or logging scenarios.
     *
     * @returns An approximate string representation of the matrix
     * @throws Error when not implemented in derived classes
     */
    toStringApproximately(): string;
    /**
     * Flattens the matrix into a one-dimensional array.
     *
     * @returns A flat array containing all matrix elements in row-major order
     * @throws Error when not implemented in derived classes
     */
    flattenAsArray(): number[];
    /**
     * Checks if this matrix is a dummy (uninitialized) matrix.
     *
     * A matrix is considered dummy if its internal storage has zero length,
     * indicating it hasn't been properly initialized with matrix data.
     *
     * @returns True if the matrix is dummy/uninitialized, false otherwise
     */
    isDummy(): boolean;
    /**
     * Gets the matrix element at the specified flat index.
     *
     * This provides direct access to the underlying Float32Array storage
     * using a single index rather than row/column coordinates.
     *
     * @param i - The zero-based flat index into the matrix storage
     * @returns The matrix element value at the specified index
     */
    v(i: number): number;
    /**
     * Calculates the determinant of the matrix.
     *
     * @returns The determinant value of the matrix
     * @throws Error when not implemented in derived classes
     */
    determinant(): number;
    /**
     * Gets the class name of this matrix instance.
     *
     * @returns The name of the constructor function (class name)
     */
    get className(): string;
    /**
     * Indicates whether this matrix is an identity matrix class.
     *
     * This property should be overridden in derived classes that represent
     * identity matrices to return true.
     *
     * @returns False for the base AbstractMatrix class
     */
    get isIdentityMatrixClass(): boolean;
    /**
     * Checks if the matrix's internal storage shares the same ArrayBuffer as the provided one.
     *
     * This method is useful for determining if two matrices share the same underlying
     * memory, which can be important for performance optimizations and avoiding
     * unnecessary data copying.
     *
     * @param arrayBuffer - The ArrayBuffer to compare against
     * @returns True if the internal storage uses the same ArrayBuffer, false otherwise
     */
    isTheSourceSame(arrayBuffer: ArrayBuffer): boolean;
}

declare class _BasisFile {
    constructor(x: Uint8Array);
    close(): void;
    getHasAlpha(): number;
    getNumImages(): number;
    getNumLevels(imageIndex: number): number;
    getImageWidth(imageIndex: number, levelIndex: number): number;
    getImageHeight(imageIndex: number, levelIndex: number): number;
    getImageTranscodedSizeInBytes(imageIndex: number, levelImdex: number, format: number): number;
    startTranscoding(): number;
    transcodeImage(dst: Uint8Array, imageIndex: number, levelIndex: number, format: number, unused: number, getAlphaForOpaqueFormats: number): number;
    delete(): void;
}
type BasisFile = _BasisFile;
type BasisTranscoder = {
    BasisFile: new (x: Uint8Array) => BasisFile;
    initializeBasis: () => void;
};
declare function _BASIS(): {
    then: (callback: (basisTranscoder: BasisTranscoder) => void) => void;
};
type BASIS_TYPE = typeof _BASIS;

type TextureFormat$1 = {
    value: number;
};
type _TextureFormat = {
    ETC1S: TextureFormat$1;
    UASTC4x4: TextureFormat$1;
};
type TranscodeTarget = {
    value: number;
};
type _TranscodeTarget = {
    ETC1_RGB: TranscodeTarget;
    BC1_RGB: TranscodeTarget;
    BC4_R: TranscodeTarget;
    BC5_RG: TranscodeTarget;
    BC3_RGBA: TranscodeTarget;
    PVRTC1_4_RGB: TranscodeTarget;
    PVRTC1_4_RGBA: TranscodeTarget;
    BC7_RGBA: TranscodeTarget;
    BC7_M6_RGB: TranscodeTarget;
    BC7_M5_RGBA: TranscodeTarget;
    ETC2_RGBA: TranscodeTarget;
    ASTC_4x4_RGBA: TranscodeTarget;
    RGBA32: TranscodeTarget;
    RGB565: TranscodeTarget;
    BGR565: TranscodeTarget;
    RGBA4444: TranscodeTarget;
    PVRTC2_4_RGB: TranscodeTarget;
    PVRTC2_4_RGBA: TranscodeTarget;
    EAC_R11: TranscodeTarget;
    EAC_RG11: TranscodeTarget;
};
declare class ImageInfo {
    constructor(textureFormat: TextureFormat$1, levelWidth: number, levelHeight: number, level: number);
    numBlocksX: number;
    numBlocksY: number;
    flags: number;
    rgbByteOffset: number;
    rgbByteLength: number;
    alphaByteOffset: number;
    alphaByteLength: number;
}
type _ImageInfo = new (textureFormat: TextureFormat$1, levelWidth: number, levelHeight: number, level: number) => ImageInfo;
type TranscodedImage = {
    transcodedImage: {
        get_typed_memory_view: () => Uint8Array;
        delete: () => void;
    };
};
declare class UastcImageTranscoder {
    transcodeImage: (transcodeTarget: TranscodeTarget, faceBuffer: Uint8Array, imageInfo: ImageInfo, decodeFlags: 0, hasAlpha: boolean, isVideo: boolean) => TranscodedImage | undefined;
}
declare class BasisLzEtc1sImageTranscoder {
    transcodeImage: (transcodeTarget: TranscodeTarget, faceBuffer: Uint8Array, imageInfo: ImageInfo, decodeFlags: 0, isVideo: boolean) => TranscodedImage | undefined;
    decodePalettes: (numEndpoints: number, endpoints: Uint8Array, numSelectors: number, selectors: Uint8Array) => void;
    decodeTables: (tables: Uint8Array) => void;
}
type MscTranscoderModule = {
    initTranscoders: () => void;
    TextureFormat: _TextureFormat;
    TranscodeTarget: _TranscodeTarget;
    ImageInfo: _ImageInfo;
    UastcImageTranscoder: new () => UastcImageTranscoder;
    BasisLzEtc1sImageTranscoder: new () => BasisLzEtc1sImageTranscoder;
};
type MSC_TRANSCODER_TYPE = () => Promise<MscTranscoderModule>;

declare function fromTensorToCompositionType(vec: any): {
    readonly __numberOfComponents: number;
    readonly __glslStr: string;
    readonly __hlslStr: string;
    readonly __webgpuStr: string;
    readonly __wgslStr: string;
    readonly __isArray: boolean;
    readonly __vec4SizeOfProperty: IndexOf16Bytes;
    readonly __dummyStr: "UNKNOWN";
    readonly webgpu: string;
    readonly wgsl: string;
    getNumberOfComponents(): Count;
    getGlslStr(componentType: ComponentTypeEnum): string;
    getGlslInitialValue(componentType: ComponentTypeEnum): string;
    getWgslInitialValue(componentType: ComponentTypeEnum): string;
    toWGSLType(componentType: ComponentTypeEnum): string;
    getVec4SizeOfProperty(): IndexOf16Bytes;
    readonly index: number;
    readonly symbol: symbol;
    readonly str: string;
    toString(): string;
    toJSON(): number;
} | {
    readonly __numberOfComponents: number;
    readonly __glslStr: string;
    readonly __hlslStr: string;
    readonly __webgpuStr: string;
    readonly __wgslStr: string;
    readonly __isArray: boolean;
    readonly __vec4SizeOfProperty: IndexOf16Bytes;
    readonly __dummyStr: "SCALAR";
    readonly webgpu: string;
    readonly wgsl: string;
    getNumberOfComponents(): Count;
    getGlslStr(componentType: ComponentTypeEnum): string;
    getGlslInitialValue(componentType: ComponentTypeEnum): string;
    getWgslInitialValue(componentType: ComponentTypeEnum): string;
    toWGSLType(componentType: ComponentTypeEnum): string;
    getVec4SizeOfProperty(): IndexOf16Bytes;
    readonly index: number;
    readonly symbol: symbol;
    readonly str: string;
    toString(): string;
    toJSON(): number;
} | {
    readonly __numberOfComponents: number;
    readonly __glslStr: string;
    readonly __hlslStr: string;
    readonly __webgpuStr: string;
    readonly __wgslStr: string;
    readonly __isArray: boolean;
    readonly __vec4SizeOfProperty: IndexOf16Bytes;
    readonly __dummyStr: "VEC2";
    readonly webgpu: string;
    readonly wgsl: string;
    getNumberOfComponents(): Count;
    getGlslStr(componentType: ComponentTypeEnum): string;
    getGlslInitialValue(componentType: ComponentTypeEnum): string;
    getWgslInitialValue(componentType: ComponentTypeEnum): string;
    toWGSLType(componentType: ComponentTypeEnum): string;
    getVec4SizeOfProperty(): IndexOf16Bytes;
    readonly index: number;
    readonly symbol: symbol;
    readonly str: string;
    toString(): string;
    toJSON(): number;
} | {
    readonly __numberOfComponents: number;
    readonly __glslStr: string;
    readonly __hlslStr: string;
    readonly __webgpuStr: string;
    readonly __wgslStr: string;
    readonly __isArray: boolean;
    readonly __vec4SizeOfProperty: IndexOf16Bytes;
    readonly __dummyStr: "VEC3";
    readonly webgpu: string;
    readonly wgsl: string;
    getNumberOfComponents(): Count;
    getGlslStr(componentType: ComponentTypeEnum): string;
    getGlslInitialValue(componentType: ComponentTypeEnum): string;
    getWgslInitialValue(componentType: ComponentTypeEnum): string;
    toWGSLType(componentType: ComponentTypeEnum): string;
    getVec4SizeOfProperty(): IndexOf16Bytes;
    readonly index: number;
    readonly symbol: symbol;
    readonly str: string;
    toString(): string;
    toJSON(): number;
} | {
    readonly __numberOfComponents: number;
    readonly __glslStr: string;
    readonly __hlslStr: string;
    readonly __webgpuStr: string;
    readonly __wgslStr: string;
    readonly __isArray: boolean;
    readonly __vec4SizeOfProperty: IndexOf16Bytes;
    readonly __dummyStr: "VEC4";
    readonly webgpu: string;
    readonly wgsl: string;
    getNumberOfComponents(): Count;
    getGlslStr(componentType: ComponentTypeEnum): string;
    getGlslInitialValue(componentType: ComponentTypeEnum): string;
    getWgslInitialValue(componentType: ComponentTypeEnum): string;
    toWGSLType(componentType: ComponentTypeEnum): string;
    getVec4SizeOfProperty(): IndexOf16Bytes;
    readonly index: number;
    readonly symbol: symbol;
    readonly str: string;
    toString(): string;
    toJSON(): number;
} | {
    readonly __numberOfComponents: number;
    readonly __glslStr: string;
    readonly __hlslStr: string;
    readonly __webgpuStr: string;
    readonly __wgslStr: string;
    readonly __isArray: boolean;
    readonly __vec4SizeOfProperty: IndexOf16Bytes;
    readonly __dummyStr: "MAT2";
    readonly webgpu: string;
    readonly wgsl: string;
    getNumberOfComponents(): Count;
    getGlslStr(componentType: ComponentTypeEnum): string;
    getGlslInitialValue(componentType: ComponentTypeEnum): string;
    getWgslInitialValue(componentType: ComponentTypeEnum): string;
    toWGSLType(componentType: ComponentTypeEnum): string;
    getVec4SizeOfProperty(): IndexOf16Bytes;
    readonly index: number;
    readonly symbol: symbol;
    readonly str: string;
    toString(): string;
    toJSON(): number;
} | {
    readonly __numberOfComponents: number;
    readonly __glslStr: string;
    readonly __hlslStr: string;
    readonly __webgpuStr: string;
    readonly __wgslStr: string;
    readonly __isArray: boolean;
    readonly __vec4SizeOfProperty: IndexOf16Bytes;
    readonly __dummyStr: "MAT3";
    readonly webgpu: string;
    readonly wgsl: string;
    getNumberOfComponents(): Count;
    getGlslStr(componentType: ComponentTypeEnum): string;
    getGlslInitialValue(componentType: ComponentTypeEnum): string;
    getWgslInitialValue(componentType: ComponentTypeEnum): string;
    toWGSLType(componentType: ComponentTypeEnum): string;
    getVec4SizeOfProperty(): IndexOf16Bytes;
    readonly index: number;
    readonly symbol: symbol;
    readonly str: string;
    toString(): string;
    toJSON(): number;
} | {
    readonly __numberOfComponents: number;
    readonly __glslStr: string;
    readonly __hlslStr: string;
    readonly __webgpuStr: string;
    readonly __wgslStr: string;
    readonly __isArray: boolean;
    readonly __vec4SizeOfProperty: IndexOf16Bytes;
    readonly __dummyStr: "MAT4";
    readonly webgpu: string;
    readonly wgsl: string;
    getNumberOfComponents(): Count;
    getGlslStr(componentType: ComponentTypeEnum): string;
    getGlslInitialValue(componentType: ComponentTypeEnum): string;
    getWgslInitialValue(componentType: ComponentTypeEnum): string;
    toWGSLType(componentType: ComponentTypeEnum): string;
    getVec4SizeOfProperty(): IndexOf16Bytes;
    readonly index: number;
    readonly symbol: symbol;
    readonly str: string;
    toString(): string;
    toJSON(): number;
};

type Vrm0xHumanBone = {
    bone: string;
    node: number;
    name?: string;
    useDefaultValues: boolean;
};
type Vrm0xLookAt = {
    curve: number[];
    xRange: number;
    yRange: number;
};
type Vrm0xBlendShapeBind = {
    mesh: number;
    index: number;
    weight: number;
};
type Vrm0xBlendShapeGroup = {
    name: string;
    presetName: string;
    isBinary: boolean;
    binds: Vrm0xBlendShapeBind[];
    materialValues: [];
};
type Vrm0xBoneGroup = {
    comment: string;
    stiffiness: number;
    gravityPower: number;
    gravityDir: {
        x: number;
        y: number;
        z: number;
    };
    dragForce: number;
    center: number;
    hitRadius: number;
    bones: number[];
    colliderGroups: number[];
};
type Vrm0xCollider = {
    offset: {
        x: number;
        y: number;
        z: number;
    };
    radius: number;
};
type Vrm0xColliderGroup = {
    node: number;
    colliders: Vrm0xCollider[];
};
type Vrm0xMaterialProperty = {
    name: string;
    renderQueue: number;
    shader: string;
    floatProperties: {
        _Cutoff: number;
        _BumpScale: number;
        _ReceiveShadowRate: number;
        _ShadingGradeRate: number;
        _ShadeShift: number;
        _ShadeToony: number;
        _LightColorAttenuation: number;
        _IndirectLightIntensity: number;
        _RimLightingMix: number;
        _RimFresnelPower: number;
        _RimLift: number;
        _OutlineWidth: number;
        _OutlineScaledMaxDistance: number;
        _OutlineLightingMix: number;
        _UvAnimScrollX: number;
        _UvAnimScrollY: number;
        _UvAnimRotation: number;
        _DebugMode: number;
        _BlendMode: number;
        _OutlineWidthMode: number;
        _OutlineColorMode: number;
        _CullMode: number;
        _OutlineCullMode: number;
        _SrcBlend: number;
        _DstBlend: number;
        _ZWrite: number;
    };
    vectorProperties: {
        _Color: Array4<number>;
        _ShadeColor: Array3<number>;
        _MainTex: Array4<number>;
        _ShadeTexture: Array4<number>;
        _BumpMap: Array4<number>;
        _ReceiveShadowTexture: Array4<number>;
        _ShadingGradeTexture: Array4<number>;
        _SphereAdd: Array4<number>;
        _EmissionColor: Array3<number>;
        _EmissionMap: Array4<number>;
        _OutlineWidthTexture: Array4<number>;
        _OutlineColor: Array4<number>;
        _RimColor: Array3<number>;
    };
    textureProperties: {
        _MainTex: number;
        _ShadeTexture: number;
        _BumpMap: number;
        _SphereAdd: number;
        _EmissionMap: number;
        _OutlineWidthTexture: number;
        _ReceiveShadowTexture: number;
        _RimTexture: number;
        _ShadingGradeTexture: number;
        _UvAnimMaskTexture: number;
    };
};
interface VRM0x_Extension {
    exporterVersion: string;
    meta: {
        version: string;
        author: string;
        contactInformation: string;
        reference: string;
        title: string;
        texture: 30;
        allowedUserName: string;
        violentUsageName: string;
        sexualUsageName: string;
        commercialUsageName: string;
        otherPermissionUrl: string;
        licenseName: string;
        otherLicenseUrl: string;
    };
    humanoid: {
        humanBones: Vrm0xHumanBone[];
        armStretch: number;
        legStretch: number;
        upperArmTwist: number;
        lowerArmTwist: number;
        upperLegTwist: number;
        lowerLegTwist: number;
        feetSpacing: number;
        hasTranslationDoF: false;
    };
    firstPerson: {
        firstPersonBone: number;
        firstPersonBoneOffset: {
            x: number;
            y: number;
            z: number;
        };
        meshAnnotations: [];
        lookAtTypeName: string;
        lookAtHorizontalInner: Vrm0xLookAt;
        lookAtHorizontalOuter: Vrm0xLookAt;
        lookAtVerticalDown: Vrm0xLookAt;
        lookAtVerticalUP: Vrm0xLookAt;
    };
    blendShapeMaster: {
        blendShapeGroups: Vrm0xBlendShapeGroup[];
    };
    secondaryAnimation: {
        boneGroups: Vrm0xBoneGroup[];
        colliderGroups: Vrm0xColliderGroup[];
    };
    materialProperties: Vrm0xMaterialProperty[];
}
interface Vrm0x extends RnM2 {
    extensions: {
        VRM: VRM0x_Extension;
    };
}

/**
 * Passed to clear to clear the current depth buffer.
 * @constant {number}
 */
declare const GL_DEPTH_BUFFER_BIT = 256;
/**
 * Passed to clear to clear the current stencil buffer.
 * @constant {number}
 */
declare const GL_STENCIL_BUFFER_BIT = 1024;
/**
 * Passed to clear to clear the current color buffer.
 * @constant {number}
 */
declare const GL_COLOR_BUFFER_BIT = 16384;
/**
 * Passed to drawElements or drawArrays to draw single points.
 * @constant {number}
 */
declare const GL_POINTS = 0;
/**
 * Passed to drawElements or drawArrays to draw lines. Each vertex connects to the one after it.
 * @constant {number}
 */
declare const GL_LINES = 1;
/**
 * Passed to drawElements or drawArrays to draw lines. Each set of two vertices is treated as a separate line segment.
 * @constant {number}
 */
declare const GL_LINE_LOOP = 2;
/**
 * Passed to drawElements or drawArrays to draw a connected group of line segments from the first vertex to the last.
 * @constant {number}
 */
declare const GL_LINE_STRIP = 3;
/**
 * Passed to drawElements or drawArrays to draw triangles. Each set of three vertices creates a separate triangle.
 * @constant {number}
 */
declare const GL_TRIANGLES = 4;
/**
 * Passed to drawElements or drawArrays to draw a connected group of triangles.
 * @constant {number}
 */
declare const GL_TRIANGLE_STRIP = 5;
/**
 * Passed to drawElements or drawArrays to draw a connected group of triangles. Each vertex connects to the previous and the first vertex in the fan.
 * @constant {number}
 */
declare const GL_TRIANGLE_FAN = 6;
/**
 * Passed to blendFunc or blendFuncSeparate to turn off a component.
 * @constant {number}
 */
declare const GL_ZERO = 0;
/**
 * Passed to blendFunc or blendFuncSeparate to turn on a component.
 * @constant {number}
 */
declare const GL_ONE = 1;
/**
 * Passed to blendFunc or blendFuncSeparate to multiply a component by the source elements color.
 * @constant {number}
 */
declare const GL_SRC_COLOR = 768;
/**
 * Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the source elements color.
 * @constant {number}
 */
declare const GL_ONE_MINUS_SRC_COLOR = 769;
/**
 * Passed to blendFunc or blendFuncSeparate to multiply a component by the source's alpha.
 * @constant {number}
 */
declare const GL_SRC_ALPHA = 770;
/**
 * Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the source's alpha.
 * @constant {number}
 */
declare const GL_ONE_MINUS_SRC_ALPHA = 771;
/**
 * Passed to blendFunc or blendFuncSeparate to multiply a component by the destination's alpha.
 * @constant {number}
 */
declare const GL_DST_ALPHA = 772;
/**
 * Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the destination's alpha.
 * @constant {number}
 */
declare const GL_ONE_MINUS_DST_ALPHA = 773;
/**
 * Passed to blendFunc or blendFuncSeparate to multiply a component by the destination's color.
 * @constant {number}
 */
declare const GL_DST_COLOR = 774;
/**
 * Passed to blendFunc or blendFuncSeparate to multiply a component by one minus the destination's color.
 * @constant {number}
 */
declare const GL_ONE_MINUS_DST_COLOR = 775;
/**
 * Passed to blendFunc or blendFuncSeparate to multiply a component by the minimum of source's alpha or one minus the destination's alpha.
 * @constant {number}
 */
declare const GL_SRC_ALPHA_SATURATE = 776;
/**
 * Passed to blendFunc or blendFuncSeparate to specify a constant color blend function.
 * @constant {number}
 */
declare const GL_CONSTANT_COLOR = 32769;
/**
 * Passed to blendFunc or blendFuncSeparate to specify one minus a constant color blend function.
 * @constant {number}
 */
declare const GL_ONE_MINUS_CONSTANT_COLOR = 32770;
/**
 * Passed to blendFunc or blendFuncSeparate to specify a constant alpha blend function.
 * @constant {number}
 */
declare const GL_CONSTANT_ALPHA = 32771;
/**
 * Passed to blendFunc or blendFuncSeparate to specify one minus a constant alpha blend function.
 * @constant {number}
 */
declare const GL_ONE_MINUS_CONSTANT_ALPHA = 32772;
/**
 * Passed to blendEquation or blendEquationSeparate to set an addition blend function.
 * @constant {number}
 */
declare const GL_FUNC_ADD = 32774;
/**
 * Passed to blendEquation or blendEquationSeparate to specify a subtraction blend function (source - destination).
 * @constant {number}
 */
declare const GL_FUNC_SUBSTRACT = 32778;
/**
 * Passed to blendEquation or blendEquationSeparate to specify a reverse subtraction blend function (destination - source).
 * @constant {number}
 */
declare const GL_FUNC_REVERSE_SUBTRACT = 32779;
/**
 * Passed to getParameter to get the current RGB blend function.
 * @constant {number}
 */
declare const GL_BLEND_EQUATION = 32777;
/**
 * Passed to getParameter to get the current RGB blend function. Same as BLEND_EQUATION.
 * @constant {number}
 */
declare const GL_BLEND_EQUATION_RGB = 32777;
/**
 * Passed to getParameter to get the current alpha blend function. Same as BLEND_EQUATION.
 * @constant {number}
 */
declare const GL_BLEND_EQUATION_ALPHA = 34877;
/**
 * Passed to getParameter to get the current destination RGB blend function.
 * @constant {number}
 */
declare const GL_BLEND_DST_RGB = 32968;
/**
 * Passed to getParameter to get the current source RGB blend function.
 * @constant {number}
 */
declare const GL_BLEND_SRC_RGB = 32969;
/**
 * Passed to getParameter to get the current destination alpha blend function.
 * @constant {number}
 */
declare const GL_BLEND_DST_ALPHA = 32970;
/**
 * Passed to getParameter to get the current source alpha blend function.
 * @constant {number}
 */
declare const GL_BLEND_SRC_ALPHA = 32971;
/**
 * Passed to getParameter to return a the current blend color.
 * @constant {number}
 */
declare const GL_BLEND_COLOR = 32773;
/**
 * Passed to getParameter to get the array buffer binding.
 * @constant {number}
 */
declare const GL_ARRAY_BUFFER_BINDING = 34964;
/**
 * Passed to getParameter to get the current element array buffer.
 * @constant {number}
 */
declare const GL_ELEMENT_ARRAY_BUFFER_BINDING = 34965;
/**
 * Passed to getParameter to get the current lineWidth (set by the lineWidth method).
 * @constant {number}
 */
declare const GL_LINE_WIDTH = 2849;
/**
 * Passed to getParameter to get the current size of a point drawn with gl.POINTS.
 * @constant {number}
 */
declare const GL_ALIASED_POINT_SIZE_RANGE = 33901;
/**
 * Passed to getParameter to get the range of available widths for a line. Returns a length-2 array with the lo value at 0, and hight at 1.
 * @constant {number}
 */
declare const GL_ALIASED_LINE_WIDTH_RANGE = 33902;
/**
 * Passed to getParameter to get the current value of cullFace. Should return FRONT, BACK, or FRONT_AND_BACK.
 * @constant {number}
 */
declare const GL_CULL_FACE_MODE = 2885;
/**
 * Passed to getParameter to determine the current value of frontFace. Should return CW or CCW.
 * @constant {number}
 */
declare const GL_FRONT_FACE = 2886;
/**
 * Passed to getParameter to return a length-2 array of floats giving the current depth range.
 * @constant {number}
 */
declare const GL_DEPTH_RANGE = 2928;
/**
 * Passed to getParameter to determine if the depth write mask is enabled.
 * @constant {number}
 */
declare const GL_DEPTH_WRITEMASK = 2930;
/**
 * Passed to getParameter to determine the current depth clear value.
 * @constant {number}
 */
declare const GL_DEPTH_CLEAR_VALUE = 2931;
/**
 * Passed to getParameter to get the current depth function. Returns NEVER, ALWAYS, LESS, EQUAL, LEQUAL, GREATER, GEQUAL, or NOTEQUAL.
 * @constant {number}
 */
declare const GL_DEPTH_FUNC = 2932;
/**
 * Passed to getParameter to get the value the stencil will be cleared to.
 * @constant {number}
 */
declare const GL_STENCIL_CLEAR_VALUE = 2961;
/**
 * Passed to getParameter to get the current stencil function. Returns NEVER, ALWAYS, LESS, EQUAL, LEQUAL, GREATER, GEQUAL, or NOTEQUAL.
 * @constant {number}
 */
declare const GL_STENCIL_FUNC = 2962;
/**
 * Passed to getParameter to get the current stencil fail function. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP.
 * @constant {number}
 */
declare const GL_STENCIL_FAIL = 2964;
/**
 * Passed to getParameter to get the current stencil fail function should the depth buffer test fail. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP.
 * @constant {number}
 */
declare const GL_STENCIL_PASS_DEPTH_FAIL = 2965;
/**
 * Passed to getParameter to get the current stencil fail function should the depth buffer test pass. Should return KEEP, REPLACE, INCR, DECR, INVERT, INCR_WRAP, or DECR_WRAP.
 * @constant {number}
 */
declare const GL_STENCIL_PASS_DEPTH_PASS = 2966;
/**
 * Passed to getParameter to get the reference value used for stencil tests.
 * @constant {number}
 */
declare const GL_STENCIL_REF = 2967;
/**
 * @constant {number}
 */
declare const GL_STENCIL_VALUE_MASK = 2963;
/**
 * @constant {number}
 */
declare const GL_STENCIL_WRITEMASK = 2968;
/**
 * @constant {number}
 */
declare const GL_STENCIL_BACK_FUNC = 34816;
/**
 * @constant {number}
 */
declare const GL_STENCIL_BACK_FAIL = 34817;
/**
 * @constant {number}
 */
declare const GL_STENCIL_BACK_PASS_DEPTH_FAIL = 34818;
/**
 * @constant {number}
 */
declare const GL_STENCIL_BACK_PASS_DEPTH_PASS = 34819;
/**
 * @constant {number}
 */
declare const GL_STENCIL_BACK_REF = 36003;
/**
 * @constant {number}
 */
declare const GL_STENCIL_BACK_VALUE_MASK = 36004;
/**
 * @constant {number}
 */
declare const GL_STENCIL_BACK_WRITEMASK = 36005;
/**
 * Returns an Int32Array with four elements for the current viewport dimensions.
 * @constant {number}
 */
declare const GL_VIEWPORT = 2978;
/**
 * Returns an Int32Array with four elements for the current scissor box dimensions.
 * @constant {number}
 */
declare const GL_SCISSOR_BOX = 3088;
/**
 * @constant {number}
 */
declare const GL_COLOR_CLEAR_VALUE = 3106;
/**
 * @constant {number}
 */
declare const GL_COLOR_WRITEMASK = 3107;
/**
 * @constant {number}
 */
declare const GL_UNPACK_ALIGNMENT = 3317;
/**
 * @constant {number}
 */
declare const GL_PACK_ALIGNMENT = 3333;
/**
 * @constant {number}
 */
declare const GL_MAX_TEXTURE_SIZE = 3379;
/**
 * @constant {number}
 */
declare const GL_MAX_VIEWPORT_DIMS = 3386;
/**
 * @constant {number}
 */
declare const GL_SUBPIXEL_BITS = 3408;
/**
 * @constant {number}
 */
declare const GL_RED_BITS = 3410;
/**
 * @constant {number}
 */
declare const GL_GREEN_BITS = 3411;
/**
 * @constant {number}
 */
declare const GL_BLUE_BITS = 3412;
/**
 * @constant {number}
 */
declare const GL_ALPHA_BITS = 3413;
/**
 * @constant {number}
 */
declare const GL_DEPTH_BITS = 3414;
/**
 * @constant {number}
 */
declare const GL_STENCIL_BITS = 3415;
/**
 * @constant {number}
 */
declare const GL_POLYGON_OFFSET_UNITS = 10752;
/**
 * @constant {number}
 */
declare const GL_POLYGON_OFFSET_FACTOR = 32824;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_BINDING_2D = 32873;
/**
 * @constant {number}
 */
declare const GL_SAMPLE_BUFFERS = 32936;
/**
 * @constant {number}
 */
declare const GL_SAMPLES = 32937;
/**
 * @constant {number}
 */
declare const GL_SAMPLE_COVERAGE_VALUE = 32938;
/**
 * @constant {number}
 */
declare const GL_SAMPLE_COVERAGE_INVERT = 32939;
/**
 * @constant {number}
 */
declare const GL_COMPRESSED_TEXTURE_FORMATS = 34467;
/**
 * @constant {number}
 */
declare const GL_VENDOR = 7936;
/**
 * @constant {number}
 */
declare const GL_RENDERER = 7937;
/**
 * @constant {number}
 */
declare const GL_VERSION = 7938;
/**
 * @constant {number}
 */
declare const GL_IMPLEMENTATION_COLOR_READ_TYPE = 35738;
/**
 * @constant {number}
 */
declare const GL_IMPLEMENTATION_COLOR_READ_FORMAT = 35739;
/**
 * @constant {number}
 */
declare const GL_BROWSER_DEFAULT_WEBGL = 37444;
/**
 * Passed to bufferData as a hint about whether the contents of the buffer are likely to be used often and not change often.
 * @constant {number}
 */
declare const GL_STATIC_DRAW = 35044;
/**
 * Passed to bufferData as a hint about whether the contents of the buffer are likely to not be used often.
 * @constant {number}
 */
declare const GL_STREAM_DRAW = 35040;
/**
 * Passed to bufferData as a hint about whether the contents of the buffer are likely to be used often and change often.
 * @constant {number}
 */
declare const GL_DYNAMIC_DRAW = 35048;
/**
 * Passed to bindBuffer or bufferData to specify the type of buffer being used.
 * @constant {number}
 */
declare const GL_ARRAY_BUFFER = 34962;
/**
 * Passed to bindBuffer or bufferData to specify the type of buffer being used.
 * @constant {number}
 */
declare const GL_ELEMENT_ARRAY_BUFFER = 34963;
/**
 * Passed to getBufferParameter to get a buffer's size.
 * @constant {number}
 */
declare const GL_BUFFER_SIZE = 34660;
/**
 * Passed to getBufferParameter to get the hint for the buffer passed in when it was created.
 * @constant {number}
 */
declare const GL_BUFFER_USAGE = 34661;
/**
 * Passed to getVertexAttrib to read back the current vertex attribute.
 * @constant {number}
 */
declare const GL_CURRENT_VERTEX_ATTRIB = 34342;
/**
 * @constant {number}
 */
declare const GL_VERTEX_ATTRIB_ARRAY_ENABLED = 34338;
/**
 * @constant {number}
 */
declare const GL_VERTEX_ATTRIB_ARRAY_SIZE = 34339;
/**
 * @constant {number}
 */
declare const GL_VERTEX_ATTRIB_ARRAY_STRIDE = 34340;
/**
 * @constant {number}
 */
declare const GL_VERTEX_ATTRIB_ARRAY_TYPE = 34341;
/**
 * @constant {number}
 */
declare const GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922;
/**
 * @constant {number}
 */
declare const GL_VERTEX_ATTRIB_ARRAY_POINTER = 34373;
/**
 * @constant {number}
 */
declare const GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975;
/**
 * Passed to enable/disable to turn on/off culling. Can also be used with getParameter to find the current culling method.
 * @constant {number}
 */
declare const GL_CULL_FACE = 2884;
/**
 * Passed to cullFace to specify that only front faces should be culled.
 * @constant {number}
 */
declare const GL_FRONT = 1028;
/**
 * Passed to cullFace to specify that only back faces should be culled.
 * @constant {number}
 */
declare const GL_BACK = 1029;
/**
 * Passed to cullFace to specify that front and back faces should be culled.
 * @constant {number}
 */
declare const GL_FRONT_AND_BACK = 1032;
/**
 * Passed to enable/disable to turn on/off blending. Can also be used with getParameter to find the current blending method.
 * @constant {number}
 */
declare const GL_BLEND = 3042;
/**
 * Passed to enable/disable to turn on/off the depth test. Can also be used with getParameter to query the depth test.
 * @constant {number}
 */
declare const GL_DEPTH_TEST = 2929;
/**
 * Passed to enable/disable to turn on/off dithering. Can also be used with getParameter to find the current dithering method.
 * @constant {number}
 */
declare const GL_DITHER = 3024;
/**
 * Passed to enable/disable to turn on/off the polygon offset. Useful for rendering hidden-line images, decals, and or solids with highlighted edges. Can also be used with getParameter to query the scissor test.
 * @constant {number}
 */
declare const GL_POLYGON_OFFSET_FILL = 32823;
/**
 * Passed to enable/disable to turn on/off the alpha to coverage. Used in multi-sampling alpha channels.
 * @constant {number}
 */
declare const GL_SAMPLE_ALPHA_TO_COVERAGE = 32926;
/**
 * Passed to enable/disable to turn on/off the sample coverage. Used in multi-sampling.
 * @constant {number}
 */
declare const GL_SAMPLE_COVERAGE = 32928;
/**
 * Passed to enable/disable to turn on/off the scissor test. Can also be used with getParameter to query the scissor test.
 * @constant {number}
 */
declare const GL_SCISSOR_TEST = 3089;
/**
 * Passed to enable/disable to turn on/off the stencil test. Can also be used with getParameter to query the stencil test.
 * @constant {number}
 */
declare const GL_STENCIL_TEST = 2960;
/**
 * Returned from getError.
 * @constant {number}
 */
declare const GL_NO_ERROR = 0;
/**
 * Returned from getError.
 * @constant {number}
 */
declare const GL_INVALID_ENUM = 1280;
/**
 * Returned from getError.
 * @constant {number}
 */
declare const GL_INVALID_VALUE = 1281;
/**
 * Returned from getError.
 * @constant {number}
 */
declare const GL_INVALID_OPERATION = 1282;
/**
 * Returned from getError.
 * @constant {number}
 */
declare const GL_OUT_OF_MEMORY = 1285;
/**
 * Returned from getError.
 * @constant {number}
 */
declare const GL_CONTEXT_LOST_WEBGL = 37442;
/**
 * Passed to frontFace to specify the front face of a polygon is drawn in the clockwise direction,
 * @constant {number}
 */
declare const GL_CW = 2304;
/**
 * Passed to frontFace to specify the front face of a polygon is drawn in the counter clockwise direction.
 * @constant {number}
 */
declare const GL_CCW = 2305;
/**
 * There is no preference for this behavior.
 * @constant {number}
 */
declare const GL_DONT_CARE = 4352;
/**
 * The most efficient behavior should be used.
 * @constant {number}
 */
declare const GL_FASTEST = 4353;
/**
 * The most correct or the highest quality option should be used.
 * @constant {number}
 */
declare const GL_NICEST = 4354;
/**
 * Hint for the quality of filtering when generating mipmap images with WebGLRenderingContext.generateMipmap().
 * @constant {number}
 */
declare const GL_GENERATE_MIPMAP_HINT = 33170;
/**
 * @constant {number}
 */
declare const GL_DATA_BYTE = 5120;
/**
 * @constant {number}
 */
declare const GL_DATA_UNSIGNED_BYTE = 5121;
/**
 * @constant {number}
 */
declare const GL_DATA_SHORT = 5122;
/**
 * @constant {number}
 */
declare const GL_DATA_UNSIGNED_SHORT = 5123;
/**
 * @constant {number}
 */
declare const GL_DATA_INT = 5124;
/**
 * @constant {number}
 */
declare const GL_DATA_UNSIGNED_INT = 5125;
/**
 * @constant {number}
 */
declare const GL_DATA_FLOAT = 5126;
/**
 * @constant {number}
 */
declare const GL_DEPTH_COMPONENT = 6402;
/**
 * @constant {number}
 */
declare const GL_ALPHA = 6406;
/**
 * @constant {number}
 */
declare const GL_RGB = 6407;
/**
 * @constant {number}
 */
declare const GL_RGBA = 6408;
/**
 * @constant {number}
 */
declare const GL_LUMINANCE = 6409;
/**
 * @constant {number}
 */
declare const GL_LUMINANCE_ALPHA = 6410;
/**
 * @constant {number}
 */
declare const GL_PIXEL_UNSIGNED_BYTE = 5121;
/**
 * @constant {number}
 */
declare const GL_PIXEL_UNSIGNED_SHORT_4_4_4_4 = 32819;
/**
 * @constant {number}
 */
declare const GL_PIXEL_UNSIGNED_SHORT_5_5_5_1 = 32820;
/**
 * @constant {number}
 */
declare const GL_PIXEL_UNSIGNED_SHORT_5_6_5 = 33635;
/**
 * Passed to createShader to define a fragment shader.
 * @constant {number}
 */
declare const GL_FRAGMENT_SHADER = 35632;
/**
 * Passed to createShader to define a vertex shader.
 * @constant {number}
 */
declare const GL_VERTEX_SHADER = 35633;
/**
 * Passed to getShaderParamter to get the status of the compilation. Returns false if the shader was not compiled. You can then query getShaderInfoLog to find the exact error.
 * @constant {number}
 */
declare const GL_COMPILE_STATUS = 35713;
/**
 * Passed to getShaderParamter to determine if a shader was deleted via deleteShader. Returns true if it was, false otherwise.
 * @constant {number}
 */
declare const GL_DELETE_STATUS = 35712;
/**
 * Passed to getProgramParameter after calling linkProgram to determine if a program was linked correctly. Returns false if there were errors. Use getProgramInfoLog to find the exact error.
 * @constant {number}
 */
declare const GL_LINK_STATUS = 35714;
/**
 * Passed to getProgramParameter after calling validateProgram to determine if it is valid. Returns false if errors were found.
 * @constant {number}
 */
declare const GL_VALIDATE_STATUS = 35715;
/**
 * Passed to getProgramParameter after calling attachShader to determine if the shader was attached correctly. Returns false if errors occurred.
 * @constant {number}
 */
declare const GL_ATTACHED_SHADERS = 35717;
/**
 * Passed to getProgramParameter to get the number of attributes active in a program.
 * @constant {number}
 */
declare const GL_ACTIVE_ATTRIBUTES = 35721;
/**
 * Passed to getProgramParamter to get the number of uniforms active in a program.
 * @constant {number}
 */
declare const GL_ACTIVE_UNIFORMS = 35718;
/**
 * The maximum number of entries possible in the vertex attribute list.
 * @constant {number}
 */
declare const GL_MAX_VERTEX_ATTRIBS = 34921;
/**
 * @constant {number}
 */
declare const GL_MAX_VERTEX_UNIFORM_VECTORS = 36347;
/**
 * @constant {number}
 */
declare const GL_MAX_VARYING_VECTORS = 36348;
/**
 * @constant {number}
 */
declare const GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661;
/**
 * @constant {number}
 */
declare const GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660;
/**
 * Implementation dependent number of maximum texture units. At least 8.
 * @constant {number}
 */
declare const GL_MAX_TEXTURE_IMAGE_UNITS = 34930;
/**
 * @constant {number}
 */
declare const GL_MAX_FRAGMENT_UNIFORM_VECTORS = 36349;
/**
 * @constant {number}
 */
declare const GL_SHADER_TYPE = 35663;
/**
 * @constant {number}
 */
declare const GL_SHADING_LANGUAGE_VERSION = 35724;
/**
 * @constant {number}
 */
declare const GL_CURRENT_PROGRAM = 35725;
/**
 * Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn.
 * @constant {number}
 */
declare const GL_NEVER = 512;
/**
 * Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn.
 * @constant {number}
 */
declare const GL_ALWAYS = 519;
/**
 * Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value.
 * @constant {number}
 */
declare const GL_LESS = 513;
/**
 * Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value.
 * @constant {number}
 */
declare const GL_EQUAL = 514;
/**
 *  Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value.
 * @constant {number}
 */
declare const GL_LEQUAL = 515;
/**
 * Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value.
 * @constant {number}
 */
declare const GL_GREATER = 516;
/**
 * Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value.
 * @constant {number}
 */
declare const GL_GEQUAL = 518;
/**
 * Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value.
 * @constant {number}
 */
declare const GL_NOTEQUAL = 517;
/**
 * @constant {number}
 */
declare const GL_KEEP = 7680;
/**
 * @constant {number}
 */
declare const GL_REPLACE = 7681;
/**
 * @constant {number}
 */
declare const GL_INCR = 7682;
/**
 * @constant {number}
 */
declare const GL_DECR = 7683;
/**
 * @constant {number}
 */
declare const GL_INVERT = 5386;
/**
 * @constant {number}
 */
declare const GL_INCR_WRAP = 34055;
/**
 * @constant {number}
 */
declare const GL_DECR_WRAP = 34056;
/**
 * @constant {number}
 */
declare const GL_NEAREST = 9728;
/**
 * @constant {number}
 */
declare const GL_LINEAR = 9729;
/**
 * @constant {number}
 */
declare const GL_NEAREST_MIPMAP_NEAREST = 9984;
/**
 * @constant {number}
 */
declare const GL_LINEAR_MIPMAP_NEAREST = 9985;
/**
 * @constant {number}
 */
declare const GL_NEAREST_MIPMAP_LINEAR = 9986;
/**
 * @constant {number}
 */
declare const GL_LINEAR_MIPMAP_LINEAR = 9987;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_MAG_FILTER = 10240;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_MIN_FILTER = 10241;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_WRAP_S = 10242;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_WRAP_T = 10243;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_2D = 3553;
/**
 * @constant {number}
 */
declare const GL_TEXTURE = 5890;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_CUBE_MAP = 34067;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_BINDING_CUBE_MAP = 34068;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_CUBE_MAP_POSITIVE_X = 34069;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 34070;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 34071;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 34073;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074;
/**
 * @constant {number}
 */
declare const GL_MAX_CUBE_MAP_TEXTURE_SIZE = 34076;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE0 = 33984;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE1 = 33985;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE2 = 33986;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE3 = 33987;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE4 = 33988;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE5 = 33989;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE6 = 33990;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE7 = 33991;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE8 = 33992;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE9 = 33993;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE10 = 33994;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE11 = 33995;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE12 = 33996;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE13 = 33997;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE14 = 33998;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE15 = 33999;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE16 = 34000;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE17 = 34001;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE18 = 34002;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE19 = 34003;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE20 = 34004;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE21 = 34005;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE22 = 34006;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE23 = 34007;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE24 = 34008;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE25 = 34009;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE26 = 34010;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE27 = 34011;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE28 = 34012;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE29 = 34013;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE30 = 34014;
/**
 * A texture unit.
 * @constant {number}
 */
declare const GL_TEXTURE31 = 34015;
/**
 * The current active texture unit.
 * @constant {number}
 */
declare const GL_ACTIVE_TEXTURE = 34016;
/**
 * @constant {number}
 */
declare const GL_REPEAT = 10497;
/**
 * @constant {number}
 */
declare const GL_CLAMP_TO_EDGE = 33071;
/**
 * @constant {number}
 */
declare const GL_MIRRORED_REPEAT = 33648;
/**
 * @constant {number}
 */
declare const GL_FLOAT_VEC2 = 35664;
/**
 * @constant {number}
 */
declare const GL_FLOAT_VEC3 = 35665;
/**
 * @constant {number}
 */
declare const GL_FLOAT_VEC4 = 35666;
/**
 * @constant {number}
 */
declare const GL_INT_VEC2 = 35667;
/**
 * @constant {number}
 */
declare const GL_INT_VEC3 = 35668;
/**
 * @constant {number}
 */
declare const GL_INT_VEC4 = 35669;
/**
 * @constant {number}
 */
declare const GL_BOOL = 35670;
/**
 * @constant {number}
 */
declare const GL_BOOL_VEC2 = 35671;
/**
 * @constant {number}
 */
declare const GL_BOOL_VEC3 = 35672;
/**
 * @constant {number}
 */
declare const GL_BOOL_VEC4 = 35673;
/**
 * @constant {number}
 */
declare const GL_FLOAT_MAT2 = 35674;
/**
 * @constant {number}
 */
declare const GL_FLOAT_MAT3 = 35675;
/**
 * @constant {number}
 */
declare const GL_FLOAT_MAT4 = 35676;
/**
 * @constant {number}
 */
declare const GL_SAMPLER_2D = 35678;
/**
 * @constant {number}
 */
declare const GL_SAMPLER_CUBE = 35680;
/**
 * @constant {number}
 */
declare const GL_LOW_FLOAT = 36336;
/**
 * @constant {number}
 */
declare const GL_MEDIUM_FLOAT = 36337;
/**
 * @constant {number}
 */
declare const GL_HIGH_FLOAT = 36338;
/**
 * @constant {number}
 */
declare const GL_LOW_INT = 36339;
/**
 * @constant {number}
 */
declare const GL_MEDIUM_INT = 36340;
/**
 * @constant {number}
 */
declare const GL_HIGH_INT = 36341;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER = 36160;
/**
 * @constant {number}
 */
declare const GL_RENDERBUFFER = 36161;
/**
 * @constant {number}
 */
declare const GL_RGBA4 = 32854;
/**
 * @constant {number}
 */
declare const GL_RGB5_A1 = 32855;
/**
 * @constant {number}
 */
declare const GL_RGB565 = 36194;
/**
 * @constant {number}
 */
declare const GL_DEPTH_COMPONENT16 = 33189;
/**
 * @constant {number}
 */
declare const GL_STENCIL_INDEX = 6401;
/**
 * @constant {number}
 */
declare const GL_STENCIL_INDEX8 = 36168;
/**
 * @constant {number}
 */
declare const GL_DEPTH_STENCIL = 34041;
/**
 * @constant {number}
 */
declare const GL_RENDERBUFFER_WIDTH = 36162;
/**
 * @constant {number}
 */
declare const GL_RENDERBUFFER_HEIGHT = 36163;
/**
 * @constant {number}
 */
declare const GL_RENDERBUFFER_INTERNAL_FORMAT = 36164;
/**
 * @constant {number}
 */
declare const GL_RENDERBUFFER_RED_SIZE = 36176;
/**
 * @constant {number}
 */
declare const GL_RENDERBUFFER_GREEN_SIZE = 36177;
/**
 * @constant {number}
 */
declare const GL_RENDERBUFFER_BLUE_SIZE = 36178;
/**
 * @constant {number}
 */
declare const GL_RENDERBUFFER_ALPHA_SIZE = 36179;
/**
 * @constant {number}
 */
declare const GL_RENDERBUFFER_DEPTH_SIZE = 36180;
/**
 * @constant {number}
 */
declare const GL_RENDERBUFFER_STENCIL_SIZE = 36181;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT0 = 36064;
/**
 * @constant {number}
 */
declare const GL_DEPTH_ATTACHMENT = 36096;
/**
 * @constant {number}
 */
declare const GL_STENCIL_ATTACHMENT = 36128;
/**
 * @constant {number}
 */
declare const GL_DEPTH_STENCIL_ATTACHMENT = 33306;
/**
 * @constant {number}
 */
declare const GL_NONE = 0;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_COMPLETE = 36053;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_UNSUPPORTED = 36061;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_BINDING = 36006;
/**
 * @constant {number}
 */
declare const GL_RENDERBUFFER_BINDING = 36007;
/**
 * @constant {number}
 */
declare const GL_MAX_RENDERBUFFER_SIZE = 34024;
/**
 * @constant {number}
 */
declare const GL_INVALID_FRAMEBUFFER_OPERATION = 1286;
/**
 * @constant {number}
 */
declare const GL_UNPACK_FLIP_Y_WEBGL = 37440;
/**
 * @constant {number}
 */
declare const GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441;
/**
 * @constant {number}
 */
declare const GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443;
/**
 * @constant {number}
 */
declare const GL_READ_BUFFER = 3074;
/**
 * @constant {number}
 */
declare const GL_UNPACK_ROW_LENGTH = 3314;
/**
 * @constant {number}
 */
declare const GL_UNPACK_SKIP_ROWS = 3315;
/**
 * @constant {number}
 */
declare const GL_UNPACK_SKIP_PIXELS = 3316;
/**
 * @constant {number}
 */
declare const GL_PACK_ROW_LENGTH = 3330;
/**
 * @constant {number}
 */
declare const GL_PACK_SKIP_ROWS = 3331;
/**
 * @constant {number}
 */
declare const GL_PACK_SKIP_PIXELS = 3332;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_BINDING_3D = 32874;
/**
 * @constant {number}
 */
declare const GL_UNPACK_SKIP_IMAGES = 32877;
/**
 * @constant {number}
 */
declare const GL_UNPACK_IMAGE_HEIGHT = 32878;
/**
 * @constant {number}
 */
declare const GL_MAX_3D_TEXTURE_SIZE = 32883;
/**
 * @constant {number}
 */
declare const GL_MAX_ELEMENTS_VERTICES = 33000;
/**
 * @constant {number}
 */
declare const GL_MAX_ELEMENTS_INDICES = 33001;
/**
 * @constant {number}
 */
declare const GL_MAX_TEXTURE_LOD_BIAS = 34045;
/**
 * @constant {number}
 */
declare const GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657;
/**
 * @constant {number}
 */
declare const GL_MAX_VERTEX_UNIFORM_COMPONENTS = 35658;
/**
 * @constant {number}
 */
declare const GL_MAX_ARRAY_TEXTURE_LAYERS = 35071;
/**
 * @constant {number}
 */
declare const GL_MIN_PROGRAM_TEXEL_OFFSET = 35076;
/**
 * @constant {number}
 */
declare const GL_MAX_PROGRAM_TEXEL_OFFSET = 35077;
/**
 * @constant {number}
 */
declare const GL_MAX_VARYING_COMPONENTS = 35659;
/**
 * @constant {number}
 */
declare const GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723;
/**
 * @constant {number}
 */
declare const GL_RASTERIZER_DISCARD = 35977;
/**
 * @constant {number}
 */
declare const GL_VERTEX_ARRAY_BINDING = 34229;
/**
 * @constant {number}
 */
declare const GL_MAX_VERTEX_OUTPUT_COMPONENTS = 37154;
/**
 * @constant {number}
 */
declare const GL_MAX_FRAGMENT_INPUT_COMPONENTS = 37157;
/**
 * @constant {number}
 */
declare const GL_MAX_SERVER_WAIT_TIMEOUT = 37137;
/**
 * @constant {number}
 */
declare const GL_MAX_ELEMENT_INDEX = 36203;
/**
 * @constant {number}
 */
declare const GL_RED = 6403;
/**
 * @constant {number}
 */
declare const GL_RGB8 = 32849;
/**
 * @constant {number}
 */
declare const GL_RGBA8 = 32856;
/**
 * @constant {number}
 */
declare const GL_RGB10_A2 = 32857;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_3D = 32879;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_WRAP_R = 32882;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_MIN_LOD = 33082;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_MAX_LOD = 33083;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_BASE_LEVEL = 33084;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_MAX_LEVEL = 33085;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_COMPARE_MODE = 34892;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_COMPARE_FUNC = 34893;
/**
 * @constant {number}
 */
declare const GL_SRGB = 35904;
/**
 * @constant {number}
 */
declare const GL_SRGB8 = 35905;
/**
 * @constant {number}
 */
declare const GL_SRGB8_ALPHA8 = 35907;
/**
 * @constant {number}
 */
declare const GL_COMPARE_REF_TO_TEXTURE = 34894;
/**
 * @constant {number}
 */
declare const GL_RGBA32F = 34836;
/**
 * @constant {number}
 */
declare const GL_RGB32F = 34837;
/**
 * @constant {number}
 */
declare const GL_RGBA16F = 34842;
/**
 * @constant {number}
 */
declare const GL_RGB16F = 34843;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_2D_ARRAY = 35866;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_BINDING_2D_ARRAY = 35869;
/**
 * @constant {number}
 */
declare const GL_R11F_G11F_B10F = 35898;
/**
 * @constant {number}
 */
declare const GL_RGB9_E5 = 35901;
/**
 * @constant {number}
 */
declare const GL_RGBA32UI = 36208;
/**
 * @constant {number}
 */
declare const GL_RGB32UI = 36209;
/**
 * @constant {number}
 */
declare const GL_RGBA16UI = 36214;
/**
 * @constant {number}
 */
declare const GL_RGB16UI = 36215;
/**
 * @constant {number}
 */
declare const GL_RGBA8UI = 36220;
/**
 * @constant {number}
 */
declare const GL_RGB8UI = 36221;
/**
 * @constant {number}
 */
declare const GL_RGBA32I = 36226;
/**
 * @constant {number}
 */
declare const GL_RGB32I = 36227;
/**
 * @constant {number}
 */
declare const GL_RGBA16I = 36232;
/**
 * @constant {number}
 */
declare const GL_RGB16I = 36233;
/**
 * @constant {number}
 */
declare const GL_RGBA8I = 36238;
/**
 * @constant {number}
 */
declare const GL_RGB8I = 36239;
/**
 * @constant {number}
 */
declare const GL_RED_INTEGER = 36244;
/**
 * @constant {number}
 */
declare const GL_RGB_INTEGER = 36248;
/**
 * @constant {number}
 */
declare const GL_RGBA_INTEGER = 36249;
/**
 * @constant {number}
 */
declare const GL_R8 = 33321;
/**
 * @constant {number}
 */
declare const GL_RG8 = 33323;
/**
 * @constant {number}
 */
declare const GL_R16F = 33325;
/**
 * @constant {number}
 */
declare const GL_R32F = 33326;
/**
 * @constant {number}
 */
declare const GL_RG16F = 33327;
/**
 * @constant {number}
 */
declare const GL_RG32F = 33328;
/**
 * @constant {number}
 */
declare const GL_R8I = 33329;
/**
 * @constant {number}
 */
declare const GL_R8UI = 33330;
/**
 * @constant {number}
 */
declare const GL_R16I = 33331;
/**
 * @constant {number}
 */
declare const GL_R16UI = 33332;
/**
 * @constant {number}
 */
declare const GL_R32I = 33333;
/**
 * @constant {number}
 */
declare const GL_R32UI = 33334;
/**
 * @constant {number}
 */
declare const GL_RG8I = 33335;
/**
 * @constant {number}
 */
declare const GL_RG8UI = 33336;
/**
 * @constant {number}
 */
declare const GL_RG16I = 33337;
/**
 * @constant {number}
 */
declare const GL_RG16UI = 33338;
/**
 * @constant {number}
 */
declare const GL_RG32I = 33339;
/**
 * @constant {number}
 */
declare const GL_RG32UI = 33340;
/**
 * @constant {number}
 */
declare const GL_R8_SNORM = 36756;
/**
 * @constant {number}
 */
declare const GL_RG8_SNORM = 36757;
/**
 * @constant {number}
 */
declare const GL_RGB8_SNORM = 36758;
/**
 * @constant {number}
 */
declare const GL_RGBA8_SNORM = 36759;
/**
 * @constant {number}
 */
declare const GL_RGB10_A2UI = 36975;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_IMMUTABLE_FORMAT = 37167;
/**
 * @constant {number}
 */
declare const GL_TEXTURE_IMMUTABLE_LEVELS = 33503;
/**
 * @constant {number}
 */
declare const GL_UNSIGNED_INT_2_10_10_10_REV = 33640;
/**
 * @constant {number}
 */
declare const GL_UNSIGNED_INT_10F_11F_11F_REV = 35899;
/**
 * @constant {number}
 */
declare const GL_UNSIGNED_INT_5_9_9_9_REV = 35902;
/**
 * @constant {number}
 */
declare const GL_FLOAT_32_UNSIGNED_INT_24_8_REV = 36269;
/**
 * @constant {number}
 */
declare const GL_UNSIGNED_INT_24_8 = 34042;
/**
 * @constant {number}
 */
declare const GL_HALF_FLOAT = 5131;
/**
 * @constant {number}
 */
declare const GL_RG = 33319;
/**
 * @constant {number}
 */
declare const GL_RG_INTEGER = 33320;
/**
 * @constant {number}
 */
declare const GL_INT_2_10_10_10_REV = 36255;
/**
 * @constant {number}
 */
declare const GL_CURRENT_QUERY = 34917;
/**
 * @constant {number}
 */
declare const GL_QUERY_RESULT = 34918;
/**
 * @constant {number}
 */
declare const GL_QUERY_RESULT_AVAILABLE = 34919;
/**
 * @constant {number}
 */
declare const GL_ANY_SAMPLES_PASSED = 35887;
/**
 * @constant {number}
 */
declare const GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 36202;
/**
 * @constant {number}
 */
declare const GL_MAX_DRAW_BUFFERS = 34852;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER0 = 34853;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER1 = 34854;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER2 = 34855;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER3 = 34856;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER4 = 34857;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER5 = 34858;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER6 = 34859;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER7 = 34860;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER8 = 34861;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER9 = 34862;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER10 = 34863;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER11 = 34864;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER12 = 34865;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER13 = 34866;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER14 = 34867;
/**
 * @constant {number}
 */
declare const GL_DRAW_BUFFER15 = 34868;
/**
 * @constant {number}
 */
declare const GL_MAX_COLOR_ATTACHMENTS = 36063;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT1 = 36065;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT2 = 36066;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT3 = 36067;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT4 = 36068;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT5 = 36069;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT6 = 36070;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT7 = 36071;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT8 = 36072;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT9 = 36073;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT10 = 36074;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT11 = 36075;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT12 = 36076;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT13 = 36077;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT14 = 36078;
/**
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT15 = 36079;
/**
 * @constant {number}
 */
declare const GL_SAMPLER_3D = 35679;
/**
 * @constant {number}
 */
declare const GL_SAMPLER_2D_SHADOW = 35682;
/**
 * @constant {number}
 */
declare const GL_SAMPLER_2D_ARRAY = 36289;
/**
 * @constant {number}
 */
declare const GL_SAMPLER_2D_ARRAY_SHADOW = 36292;
/**
 * @constant {number}
 */
declare const GL_SAMPLER_CUBE_SHADOW = 36293;
/**
 * @constant {number}
 */
declare const GL_INT_SAMPLER_2D = 36298;
/**
 * @constant {number}
 */
declare const GL_INT_SAMPLER_3D = 36299;
/**
 * @constant {number}
 */
declare const GL_INT_SAMPLER_CUBE = 36300;
/**
 * @constant {number}
 */
declare const GL_INT_SAMPLER_2D_ARRAY = 36303;
/**
 * @constant {number}
 */
declare const GL_UNSIGNED_INT_SAMPLER_2D = 36306;
/**
 * @constant {number}
 */
declare const GL_UNSIGNED_INT_SAMPLER_3D = 36307;
/**
 * @constant {number}
 */
declare const GL_UNSIGNED_INT_SAMPLER_CUBE = 36308;
/**
 * @constant {number}
 */
declare const GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311;
/**
 * @constant {number}
 */
declare const GL_MAX_SAMPLES = 36183;
/**
 * @constant {number}
 */
declare const GL_SAMPLER_BINDING = 35097;
/**
 * @constant {number}
 */
declare const GL_PIXEL_PACK_BUFFER = 35051;
/**
 * @constant {number}
 */
declare const GL_PIXEL_UNPACK_BUFFER = 35052;
/**
 * @constant {number}
 */
declare const GL_PIXEL_PACK_BUFFER_BINDING = 35053;
/**
 * @constant {number}
 */
declare const GL_PIXEL_UNPACK_BUFFER_BINDING = 35055;
/**
 * @constant {number}
 */
declare const GL_COPY_READ_BUFFER = 36662;
/**
 * @constant {number}
 */
declare const GL_COPY_WRITE_BUFFER = 36663;
/**
 * @constant {number}
 */
declare const GL_COPY_READ_BUFFER_BINDING = 36662;
/**
 * @constant {number}
 */
declare const GL_COPY_WRITE_BUFFER_BINDING = 36663;
/**
 * @constant {number}
 */
declare const GL_FLOAT_MAT2X3 = 35685;
/**
 * @constant {number}
 */
declare const GL_FLOAT_MAT2X4 = 35686;
/**
 * @constant {number}
 */
declare const GL_FLOAT_MAT3X2 = 35687;
/**
 * @constant {number}
 */
declare const GL_FLOAT_MAT3X4 = 35688;
/**
 * @constant {number}
 */
declare const GL_FLOAT_MAT4X2 = 35689;
/**
 * @constant {number}
 */
declare const GL_FLOAT_MAT4X3 = 35690;
/**
 * @constant {number}
 */
declare const GL_UNSIGNED_INT_VEC2 = 36294;
/**
 * @constant {number}
 */
declare const GL_UNSIGNED_INT_VEC3 = 36295;
/**
 * @constant {number}
 */
declare const GL_UNSIGNED_INT_VEC4 = 36296;
/**
 * @constant {number}
 */
declare const GL_UNSIGNED_NORMALIZED = 35863;
/**
 * @constant {number}
 */
declare const GL_SIGNED_NORMALIZED = 36764;
/**
 * @constant {number}
 */
declare const GL_VERTEX_ATTRIB_ARRAY_INTEGER = 35069;
/**
 * @constant {number}
 */
declare const GL_VERTEX_ATTRIB_ARRAY_DIVISOR = 35070;
/**
 * @constant {number}
 */
declare const GL_TRANSFORM_FEEDBACK_BUFFER_MODE = 35967;
/**
 * @constant {number}
 */
declare const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968;
/**
 * @constant {number}
 */
declare const GL_TRANSFORM_FEEDBACK_VARYINGS = 35971;
/**
 * @constant {number}
 */
declare const GL_TRANSFORM_FEEDBACK_BUFFER_START = 35972;
/**
 * @constant {number}
 */
declare const GL_TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973;
/**
 * @constant {number}
 */
declare const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976;
/**
 * @constant {number}
 */
declare const GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978;
/**
 * @constant {number}
 */
declare const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979;
/**
 * @constant {number}
 */
declare const GL_INTERLEAVED_ATTRIBS = 35980;
/**
 * @constant {number}
 */
declare const GL_SEPARATE_ATTRIBS = 35981;
/**
 * @constant {number}
 */
declare const GL_TRANSFORM_FEEDBACK_BUFFER = 35982;
/**
 * @constant {number}
 */
declare const GL_TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983;
/**
 * @constant {number}
 */
declare const GL_TRANSFORM_FEEDBACK = 36386;
/**
 * @constant {number}
 */
declare const GL_TRANSFORM_FEEDBACK_PAUSED = 36387;
/**
 * @constant {number}
 */
declare const GL_TRANSFORM_FEEDBACK_ACTIVE = 36388;
/**
 * @constant {number}
 */
declare const GL_TRANSFORM_FEEDBACK_BINDING = 36389;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_DEFAULT = 33304;
/**
 * @constant {number}
 */
declare const GL_DEPTH24_STENCIL8 = 35056;
/**
 * @constant {number}
 */
declare const GL_DRAW_FRAMEBUFFER_BINDING = 36006;
/**
 * @constant {number}
 */
declare const GL_READ_FRAMEBUFFER = 36008;
/**
 * @constant {number}
 */
declare const GL_DRAW_FRAMEBUFFER = 36009;
/**
 * @constant {number}
 */
declare const GL_READ_FRAMEBUFFER_BINDING = 36010;
/**
 * @constant {number}
 */
declare const GL_RENDERBUFFER_SAMPLES = 36011;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_BUFFER = 35345;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_BUFFER_BINDING = 35368;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_BUFFER_START = 35369;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_BUFFER_SIZE = 35370;
/**
 * @constant {number}
 */
declare const GL_MAX_VERTEX_UNIFORM_BLOCKS = 35371;
/**
 * @constant {number}
 */
declare const GL_MAX_FRAGMENT_UNIFORM_BLOCKS = 35373;
/**
 * @constant {number}
 */
declare const GL_MAX_COMBINED_UNIFORM_BLOCKS = 35374;
/**
 * @constant {number}
 */
declare const GL_MAX_UNIFORM_BUFFER_BINDINGS = 35375;
/**
 * @constant {number}
 */
declare const GL_MAX_UNIFORM_BLOCK_SIZE = 35376;
/**
 * @constant {number}
 */
declare const GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377;
/**
 * @constant {number}
 */
declare const GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380;
/**
 * @constant {number}
 */
declare const GL_ACTIVE_UNIFORM_BLOCKS = 35382;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_TYPE = 35383;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_SIZE = 35384;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_BLOCK_INDEX = 35386;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_OFFSET = 35387;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_ARRAY_STRIDE = 35388;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_MATRIX_STRIDE = 35389;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_IS_ROW_MAJOR = 35390;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_BLOCK_BINDING = 35391;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_BLOCK_DATA_SIZE = 35392;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396;
/**
 * @constant {number}
 */
declare const GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398;
/**
 * @constant {number}
 */
declare const GL_OBJECT_TYPE = 37138;
/**
 * @constant {number}
 */
declare const GL_SYNC_CONDITION = 37139;
/**
 * @constant {number}
 */
declare const GL_SYNC_STATUS = 37140;
/**
 * @constant {number}
 */
declare const GL_SYNC_FLAGS = 37141;
/**
 * @constant {number}
 */
declare const GL_SYNC_FENCE = 37142;
/**
 * @constant {number}
 */
declare const GL_SYNC_GPU_COMMANDS_COMPLETE = 37143;
/**
 * @constant {number}
 */
declare const GL_UNSIGNALED = 37144;
/**
 * @constant {number}
 */
declare const GL_SIGNALED = 37145;
/**
 * @constant {number}
 */
declare const GL_ALREADY_SIGNALED = 37146;
/**
 * @constant {number}
 */
declare const GL_TIMEOUT_EXPIRED = 37147;
/**
 * @constant {number}
 */
declare const GL_CONDITION_SATISFIED = 37148;
/**
 * @constant {number}
 */
declare const GL_WAIT_FAILED = 37149;
/**
 * @constant {number}
 */
declare const GL_SYNC_FLUSH_COMMANDS_BIT = 1;
/**
 * @constant {number}
 */
declare const GL_COLOR = 6144;
/**
 * @constant {number}
 */
declare const GL_DEPTH = 6145;
/**
 * @constant {number}
 */
declare const GL_STENCIL = 6146;
/**
 * @constant {number}
 */
declare const GL_MIN = 32775;
/**
 * @constant {number}
 */
declare const GL_MAX = 32776;
/**
 * @constant {number}
 */
declare const GL_DEPTH_COMPONENT24 = 33190;
/**
 * @constant {number}
 */
declare const GL_STREAM_READ = 35041;
/**
 * @constant {number}
 */
declare const GL_STREAM_COPY = 35042;
/**
 * @constant {number}
 */
declare const GL_STATIC_READ = 35045;
/**
 * @constant {number}
 */
declare const GL_STATIC_COPY = 35046;
/**
 * @constant {number}
 */
declare const GL_DYNAMIC_READ = 35049;
/**
 * @constant {number}
 */
declare const GL_DYNAMIC_COPY = 35050;
/**
 * @constant {number}
 */
declare const GL_DEPTH_COMPONENT32F = 36012;
/**
 * @constant {number}
 */
declare const GL_DEPTH32F_STENCIL8 = 36013;
/**
 * @constant {number}
 */
declare const GL_INVALID_INDEX = 4294967295;
/**
 * @constant {number}
 */
declare const GL_TIMEOUT_IGNORED = -1;
/**
 * @constant {number}
 */
declare const GL_MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447;
/**
 * Describes the frequency divisor used for instanced rendering.
 * @constant {number}
 */
declare const GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 35070;
/**
 * Passed to getParameter to get the vendor string of the graphics driver.
 * @constant {number}
 */
declare const GL_UNMASKED_VENDOR_WEBGL = 37445;
/**
 * Passed to getParameter to get the renderer string of the graphics driver.
 * @constant {number}
 */
declare const GL_UNMASKED_RENDERER_WEBGL = 37446;
/**
 * Returns the maximum available anisotropy.
 * @constant {number}
 */
declare const GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
/**
 * Passed to texParameter to set the desired maximum anisotropy for a texture.
 * @constant {number}
 */
declare const GL_TEXTURE_MAX_ANISOTROPY_EXT = 34046;
/**
 * A DXT1-compressed image in an RGB image format.
 * @constant {number}
 */
declare const GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 33776;
/**
 * A DXT1-compressed image in an RGB image format with a simple on/off alpha value.
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777;
/**
 * A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression.
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778;
/**
 * A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3 compression in how the alpha compression is done.
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779;
/**
 * A DXT1-compressed image in an sRGB image format.
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916;
/**
 * A DXT1-compressed image in an sRGB image format with a simple on/off alpha value.
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917;
/**
 * A DXT3-compressed image in an sRGBA image format.
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918;
/**
 * A DXT5-compressed image in an sRGBA image format.
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919;
/**
 * One-channel (red) unsigned format compression.
 * @constant {number}
 */
declare const GL_COMPRESSED_R11_EAC = 37488;
/**
 * One-channel (red) signed format compression.
 * @constant {number}
 */
declare const GL_COMPRESSED_SIGNED_R11_EAC = 37489;
/**
 * Two-channel (red and green) unsigned format compression.
 * @constant {number}
 */
declare const GL_COMPRESSED_RG11_EAC = 37490;
/**
 * Two-channel (red and green) signed format compression.
 * @constant {number}
 */
declare const GL_COMPRESSED_SIGNED_RG11_EAC = 37491;
/**
 * Compresses RBG8 data with no alpha channel.
 * @constant {number}
 */
declare const GL_COMPRESSED_RGB8_ETC2 = 37492;
/**
 * Compresses RGBA8 data. The RGB part is encoded the same as RGB_ETC2, but the alpha part is encoded separately.
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA8_ETC2_EAC = 37493;
/**
 * Compresses sRBG8 data with no alpha channel.
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ETC2 = 37494;
/**
 * Compresses sRGBA8 data. The sRGB part is encoded the same as SRGB_ETC2, but the alpha part is encoded separately.
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495;
/**
 * Similar to RGB8_ETC, but with ability to punch through the alpha channel, which means to make it completely opaque or transparent.
 * @constant {number}
 */
declare const GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496;
/**
 * Similar to SRGB8_ETC, but with ability to punch through the alpha channel, which means to make it completely opaque or transparent.
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497;
/**
 * RGB compression in 4-bit mode. One block for each 44 pixels.
 * @constant {number}
 */
declare const GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840;
/**
 * RGBA compression in 4-bit mode. One block for each 44 pixels.
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842;
/**
 * RGB compression in 2-bit mode. One block for each 84 pixels.
 * @constant {number}
 */
declare const GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841;
/**
 * RGBA compression in 2-bit mode. One block for each 84 pixels.
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843;
/**
 * Compresses 24-bit RGB data with no alpha channel.
 * @constant {number}
 */
declare const GL_COMPRESSED_RGB_ETC1_WEBGL = 36196;
/**
 * Compresses RGB textures with no alpha channel.
 * @constant {number}
 */
declare const GL_COMPRESSED_RGB_ATC_WEBGL = 35986;
/**
 * Compresses RGBA textures using explicit alpha encoding (useful when alpha transitions are sharp).
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986;
/**
 * Compresses RGBA textures using interpolated alpha encoding (useful when alpha transitions are gradient).
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798;
/**
 * Compresses RGBA textures using ASTC compression in a blocksize of 4x4
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ASTC_4X4_KHR = 37808;
/**
 * Compresses RGBA textures using ASTC compression in a blocksize of 5x4
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ASTC_5X4_KHR = 37809;
/**
 * Compresses RGBA textures using ASTC compression in a blocksize of 5x5
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ASTC_5X5_KHR = 37810;
/**
 * Compresses RGBA textures using ASTC compression in a blocksize of 6x5
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ASTC_6X5_KHR = 37811;
/**
 * Compresses RGBA textures using ASTC compression in a blocksize of 6x6
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ASTC_6X6_KHR = 37812;
/**
 * Compresses RGBA textures using ASTC compression in a blocksize of 8x5
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ASTC_8X5_KHR = 37813;
/**
 * Compresses RGBA textures using ASTC compression in a blocksize of 8x6
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ASTC_8X6_KHR = 37814;
/**
 * Compresses RGBA textures using ASTC compression in a blocksize of 8x8
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ASTC_8X8_KHR = 37815;
/**
 * Compresses RGBA textures using ASTC compression in a blocksize of 10x5
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ASTC_10X5_KHR = 37816;
/**
 * Compresses RGBA textures using ASTC compression in a blocksize of 10x6
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ASTC_10X6_KHR = 37817;
/**
 * Compresses RGBA textures using ASTC compression in a blocksize of 10x8
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ASTC_10X8_KHR = 37818;
/**
 * Compresses RGBA textures using ASTC compression in a blocksize of 10x10
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ASTC_10X10_KHR = 37819;
/**
 * Compresses RGBA textures using ASTC compression in a blocksize of 12x10
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ASTC_12X10_KHR = 37820;
/**
 * Compresses RGBA textures using ASTC compression in a blocksize of 12x12
 * @constant {number}
 */
declare const GL_COMPRESSED_RGBA_ASTC_12X12_KHR = 37821;
/**
 * Compresses SRGB8 textures using ASTC compression in a blocksize of 4x4
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR = 37840;
/**
 * Compresses SRGB8 textures using ASTC compression in a blocksize of 5x4
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR = 37841;
/**
 * Compresses SRGB8 textures using ASTC compression in a blocksize of 5x5
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR = 37842;
/**
 * Compresses SRGB8 textures using ASTC compression in a blocksize of 6x5
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR = 37843;
/**
 * Compresses SRGB8 textures using ASTC compression in a blocksize of 6x6
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR = 37844;
/**
 * Compresses SRGB8 textures using ASTC compression in a blocksize of 8x5
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR = 37845;
/**
 * Compresses SRGB8 textures using ASTC compression in a blocksize of 8x6
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR = 37846;
/**
 * Compresses SRGB8 textures using ASTC compression in a blocksize of 8x8
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR = 37847;
/**
 * Compresses SRGB8 textures using ASTC compression in a blocksize of 10x5
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR = 37848;
/**
 * Compresses SRGB8 textures using ASTC compression in a blocksize of 10x6
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR = 37849;
/**
 * Compresses SRGB8 textures using ASTC compression in a blocksize of 10x8
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR = 37850;
/**
 * Compresses SRGB8 textures using ASTC compression in a blocksize of 10x10
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR = 37851;
/**
 * Compresses SRGB8 textures using ASTC compression in a blocksize of 12x10
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR = 37852;
/**
 * Compresses SRGB8 textures using ASTC compression in a blocksize of 12x12
 * @constant {number}
 */
declare const GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR = 37853;
/**
 * Unsigned integer type for 24-bit depth texture data.
 * @constant {number}
 */
declare const GL_UNSIGNED_INT_24_8_WEBGL = 34042;
/**
 * Half floating-point type (16-bit).
 * @constant {number}
 */
declare const GL_HALF_FLOAT_OES = 36193;
/**
 * RGBA 32-bit floating-point color-renderable format.
 * @constant {number}
 */
declare const GL_RGBA32F_EXT = 34836;
/**
 * RGB 32-bit floating-point color-renderable format.
 * @constant {number}
 */
declare const GL_RGB32F_EXT = 34837;
/**
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 33297;
/**
 * @constant {number}
 */
declare const GL_UNSIGNED_NORMALIZED_EXT = 35863;
/**
 * Produces the minimum color components of the source and destination colors.
 * @constant {number}
 */
declare const GL_MIN_EXT = 32775;
/**
 * Produces the maximum color components of the source and destination colors.
 * @constant {number}
 */
declare const GL_MAX_EXT = 32776;
/**
 * Unsized sRGB format that leaves the precision up to the driver.
 * @constant {number}
 */
declare const GL_SRGB_EXT = 35904;
/**
 * Unsized sRGB format with unsized alpha component.
 * @constant {number}
 */
declare const GL_SRGB_ALPHA_EXT = 35906;
/**
 * Sized (8-bit) sRGB and alpha formats.
 * @constant {number}
 */
declare const GL_SRGB8_ALPHA8_EXT = 35907;
/**
 * Returns the framebuffer color encoding.
 * @constant {number}
 */
declare const GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT = 33296;
/**
 * Indicates the accuracy of the derivative calculation for the GLSL built-in functions: dFdx, dFdy, and fwidth.
 * @constant {number}
 */
declare const GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 35723;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT0_WEBGL = 36064;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT1_WEBGL = 36065;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT2_WEBGL = 36066;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT3_WEBGL = 36067;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT4_WEBGL = 36068;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT5_WEBGL = 36069;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT6_WEBGL = 36070;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT7_WEBGL = 36071;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT8_WEBGL = 36072;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT9_WEBGL = 36073;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT10_WEBGL = 36074;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT11_WEBGL = 36075;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT12_WEBGL = 36076;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT13_WEBGL = 36077;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT14_WEBGL = 36078;
/**
 * Framebuffer color attachment point.
 * @constant {number}
 */
declare const GL_COLOR_ATTACHMENT15_WEBGL = 36079;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER0_WEBGL = 34853;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER1_WEBGL = 34854;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER2_WEBGL = 34855;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER3_WEBGL = 34856;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER4_WEBGL = 34857;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER5_WEBGL = 34858;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER6_WEBGL = 34859;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER7_WEBGL = 34860;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER8_WEBGL = 34861;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER9_WEBGL = 34862;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER10_WEBGL = 34863;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER11_WEBGL = 34864;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER12_WEBGL = 34865;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER13_WEBGL = 34866;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER14_WEBGL = 34867;
/**
 * Draw buffer.
 * @constant {number}
 */
declare const GL_DRAW_BUFFER15_WEBGL = 34868;
/**
 * Maximum number of framebuffer color attachment points.
 * @constant {number}
 */
declare const GL_MAX_COLOR_ATTACHMENTS_WEBGL = 36063;
/**
 * Maximum number of draw buffers.
 * @constant {number}
 */
declare const GL_MAX_DRAW_BUFFERS_WEBGL = 34852;
/**
 * The bound vertex array object (VAO).
 * @constant {number}
 */
declare const GL_VERTEX_ARRAY_BINDING_OES = 34229;
/**
 * The number of bits used to hold the query result for the given target.
 * @constant {number}
 */
declare const GL_QUERY_COUNTER_BITS_EXT = 34916;
/**
 * The currently active query.
 * @constant {number}
 */
declare const GL_CURRENT_QUERY_EXT = 34917;
/**
 * The query result.
 * @constant {number}
 */
declare const GL_QUERY_RESULT_EXT = 34918;
/**
 * A Boolean indicating whether or not a query result is available.
 * @constant {number}
 */
declare const GL_QUERY_RESULT_AVAILABLE_EXT = 34919;
/**
 * Elapsed time (in nanoseconds).
 * @constant {number}
 */
declare const GL_TIME_ELAPSED_EXT = 35007;
/**
 * The current time.
 * @constant {number}
 */
declare const GL_TIMESTAMP_EXT = 36392;
/**
 * A Boolean indicating whether or not the GPU performed any disjoint operation.
 * @constant {number}
 */
declare const GL_GPU_DISJOINT_EXT = 36795;

type Gltf1AnyObject = {
    [s: string]: any;
};
type glTF1 = {
    asset: {
        extras?: {
            rnLoaderOptions?: any;
            version?: string;
            fileType?: string;
        };
    };
    buffers: any[];
    bufferDic: Gltf1AnyObject;
    scenes: any[];
    sceneDic: Gltf1AnyObject;
    meshes: any[];
    meshDic: Gltf1AnyObject;
    nodesIndices: number[];
    nodes: any[];
    nodeDic: Gltf1AnyObject;
    skins: any[];
    skinDic: Gltf1AnyObject;
    materials: any[];
    materialDic: Gltf1AnyObject;
    cameras: any[];
    cameraDic: Gltf1AnyObject;
    shaders: any[];
    shaderDic: Gltf1AnyObject;
    images: any[];
    imageDic: Gltf1AnyObject;
    animations: Array<{
        channels: any[];
        samplers: any[];
        parameters: Gltf1AnyObject;
    }>;
    animationDic: {
        [s: string]: {
            channels: any[];
            samplers: any[];
        };
    };
    textures: any[];
    textureDic: Gltf1AnyObject;
    samplers: any[];
    samplerDic: Gltf1AnyObject;
    accessors: any[];
    accessorDic: Gltf1AnyObject;
    bufferViews: any[];
    bufferViewDic: Gltf1AnyObject;
    buffer: any[];
    techniques: any[];
};

interface Gltf2BufferViewEx extends Gltf2BufferView {
    buffer: number;
    byteOffset: number;
    extras: {
        uint8Array?: Uint8Array;
    };
}
interface Gltf2AccessorEx extends Gltf2Accessor {
    extras: {
        uint8Array?: Uint8Array;
    };
}
interface Gltf2MaterialEx extends Gltf2Material {
    pbrMetallicRoughness: Gltf2PbrMetallicRoughnessEx;
}
interface Gltf2ImageEx extends Gltf2Image {
    rnTextureUID?: Index;
}
interface Gltf2PbrMetallicRoughnessEx extends Gltf2PbrMetallicRoughness {
    diffuseColorTexture?: Gltf2TextureInfo;
}
interface Gltf2Ex extends Gltf2 {
    asset: {
        version: string;
        generator: string;
    };
    buffers: Gltf2Buffer[];
    bufferViews: Gltf2BufferViewEx[];
    accessors: Gltf2AccessorEx[];
    meshes: Gltf2Mesh[];
    materials: Gltf2Material[];
    animations: Gltf2Animation[];
    textures: Gltf2Texture[];
    images: Gltf2ImageEx[];
    skins: Gltf2Skin[];
    cameras: Gltf2Camera[];
    samplers: Gltf2TextureSampler[];
    extensionsUsed: string[];
    extras: {
        rnSkins: ISkeletalEntity[];
        bufferViewByteLengthAccumulatedArray: Byte$1[];
    };
}

type HumanBoneNames = 'hips' | 'spine' | 'chest' | 'neck' | 'head' | 'leftUpperLeg' | 'leftLowerLeg' | 'leftFoot' | 'leftToes' | 'rightUpperLeg' | 'rightLowerLeg' | 'rightFoot' | 'rightToes' | 'leftShoulder' | 'leftUpperArm' | 'leftLowerArm' | 'leftHand' | 'rightShoulder' | 'rightUpperArm' | 'rightLowerArm' | 'rightHand';
type NodeId = number;
type ExpressionPreset = 'happy' | 'angry' | 'sad' | 'relaxed' | 'surprised' | 'aa' | 'ih' | 'ou' | 'ee' | 'oh' | 'blink' | 'blinkLeft' | 'blinkRight' | 'neutral';
interface VRMC_vrm_animation {
    specVersion: string;
    humanoid?: {
        humanBones: Record<HumanBoneNames, {
            node: number;
        }>;
    };
    expressions?: {
        preset?: Record<ExpressionPreset, {
            node: number;
        }>;
        custom?: Record<string, {
            node: number;
        }>;
    };
    lookAt?: {
        node: number;
        offsetFromHeadBone?: [number, number, number];
    };
}
interface RnM2_VRMC_vrm_animation extends VRMC_vrm_animation {
    humanoidBoneNameMap?: Map<NodeId, HumanBoneNames>;
}

interface RnM2Vrma extends RnM2 {
    extensions: {
        VRMC_vrm_animation: RnM2_VRMC_vrm_animation;
    };
}

interface ShaderNodeJson {
    nodes: ShaderNodeJsonNode[];
    connections: ShaderNodeJsonConnection[];
}
interface ShaderNodeJsonNode {
    id: string;
    name: string;
    inputs: Record<string, ShaderNodeJsonNodeInput>;
    outputs: Record<string, ShaderNodeJsonNodeOutput>;
    position: {
        x: number;
        y: number;
    };
    controls: Record<string, any>;
}
interface ShaderNodeJsonNodeOutput {
    id: string;
    label: string;
    socket: {
        name: string;
    };
}
interface ShaderNodeJsonNodeInput {
    type: string;
    value: any;
    socket: {
        name: string;
    };
}
interface ShaderNodeJsonConnection {
    id: string;
    from: {
        id: string;
        portName: string;
    };
    to: {
        id: string;
        portName: string;
    };
}

interface KHR_interactivity_Type {
    signature: 'bool' | 'custom' | 'float' | 'float2' | 'float3' | 'float4' | 'float2x2' | 'float3x3' | 'float4x4' | 'int';
}
type KHR_interactivity_Variable = {};
type KHR_interactivity_Event = {};
interface KHR_interactivity_Declaration {
    op: string;
    extension?: string;
    inputValueSockets?: object;
    outputValueSockets?: object;
}
interface KHR_interactivity_Flow {
    node: number;
    socket: 'in';
}
interface KHR_interactivity_Value {
    type: number;
    value: number[];
}
type KHR_interactivity_value_type = 'animation' | 'speed' | 'startTIme' | 'endTime';
interface KHR_interactivity_Configuration {
    node: number;
    socket: 'in';
}
interface KHR_interactivity_Configuration {
    nodeIndex: {
        value: number[];
    };
    stopPropagation: {
        value: boolean;
    };
}
interface KHR_interactivity_Node {
    declaration: number;
    configuration: KHR_interactivity_Configuration;
    values: Record<KHR_interactivity_value_type, KHR_interactivity_Value>;
    flows: Record<string, KHR_interactivity_Flow>;
}
interface KHR_interactivity_Graph {
    types: KHR_interactivity_Type[];
    variables: KHR_interactivity_Variable[];
    events: KHR_interactivity_Event[];
    declarations: KHR_interactivity_Declaration[];
    nodes: KHR_interactivity_Node[];
}
interface KHR_interactivity {
    graphs: KHR_interactivity_Graph[];
    graph: number;
}

/**
 * Represents a 4x4 identity matrix that provides optimized operations for identity transformations.
 * This class implements the identity matrix pattern where all diagonal elements are 1 and all other elements are 0.
 * It extends AbstractMatrix and implements both IMatrix and IMatrix44 interfaces.
 *
 * The identity matrix is immutable and provides efficient implementations since the result of many operations
 * can be computed without actual matrix multiplication.
 *
 * @example
 * ```typescript
 * const identity = new IdentityMatrix44();
 * const vector = new Vector4(1, 2, 3, 1);
 * const result = identity.multiplyVector(vector); // Returns the same vector
 * ```
 */
declare class IdentityMatrix44 extends AbstractMatrix implements IMatrix, IMatrix44 {
    /**
     * Static array representing the identity matrix values in column-major order.
     * This is shared across all instances for memory efficiency.
     */
    static readonly __v: Float32Array<ArrayBuffer>;
    /**
     * Creates a new IdentityMatrix44 instance.
     * The internal array reference points to the static identity matrix values.
     */
    constructor();
    /**
     * Returns a string representation of the identity matrix in a readable format.
     * Each row is separated by newlines for visual clarity.
     *
     * @returns A formatted string showing the 4x4 identity matrix
     */
    toString(): string;
    /**
     * Returns an approximate string representation of the matrix.
     * For identity matrix, this is identical to toString() since all values are exact.
     *
     * @returns A formatted string showing the 4x4 identity matrix
     */
    toStringApproximately(): string;
    /**
     * Returns the matrix elements as a flat array in column-major order.
     *
     * @returns An array of 16 numbers representing the identity matrix
     */
    flattenAsArray(): number[];
    /**
     * Indicates whether this matrix is a dummy/placeholder matrix.
     * Identity matrix is not considered a dummy matrix.
     *
     * @returns Always false for identity matrix
     */
    isDummy(): boolean;
    /**
     * Checks if the given matrix is approximately equal to this identity matrix within a tolerance.
     * Compares each element of the input matrix against the corresponding identity matrix element.
     *
     * @param mat - The matrix to compare against this identity matrix
     * @param delta - The tolerance for floating-point comparison (default: Number.EPSILON)
     * @returns True if the matrix is approximately an identity matrix, false otherwise
     */
    isEqual(mat: IMatrix44, delta?: number): boolean;
    /**
     * Performs a strict equality check against another matrix.
     * Uses exact floating-point comparison without tolerance.
     *
     * @param mat - The matrix to compare for strict equality
     * @returns True if the matrix is exactly an identity matrix, false otherwise
     */
    isStrictEqual(mat: IMatrix): boolean;
    /**
     * Gets the matrix element at the specified row and column indices.
     * For identity matrix, returns 1 for diagonal elements and 0 for off-diagonal elements.
     *
     * @param row_i - The row index (0-based)
     * @param column_i - The column index (0-based)
     * @returns 1 if row equals column (diagonal), 0 otherwise
     */
    at(row_i: number, column_i: number): number;
    /**
     * Gets the matrix element at the specified linear index in column-major order.
     * For identity matrix, returns 1 for diagonal positions and 0 elsewhere.
     *
     * @param i - The linear index (0-15) in column-major order
     * @returns 1 for diagonal elements (indices 0, 5, 10, 15), 0 otherwise
     */
    v(i: number): number;
    /**
     * Calculates the determinant of this identity matrix.
     * The determinant of an identity matrix is always 1.
     *
     * @returns Always returns 1
     */
    determinant(): number;
    /**
     * Multiplies this identity matrix with a 4D vector.
     * Since this is an identity matrix, the result is the input vector unchanged.
     *
     * @param vec - The 4D vector to multiply
     * @returns The same vector (identity transformation)
     */
    multiplyVector(vec: IVector4): IVector4;
    /**
     * Multiplies this identity matrix with a 3D vector.
     * Since this is an identity matrix, the result is the input vector unchanged.
     *
     * @param vec - The 3D vector to multiply
     * @returns The same vector (identity transformation)
     */
    multiplyVector3(vec: IVector3): IVector3;
    /**
     * Multiplies this identity matrix with a vector and stores the result in an output vector.
     * Since this is an identity matrix, copies the input vector to the output vector.
     *
     * @param vec - The input vector to multiply
     * @param outVec - The mutable vector to store the result
     * @returns The output vector containing the copied values
     */
    multiplyVectorTo(vec: IVector, outVec: IMutableVector): IMutableVector;
    /**
     * Extracts the scale components from this transformation matrix.
     * For identity matrix, the scale is (1, 1, 1).
     *
     * @returns A Vector3 with all components set to 1
     */
    getScale(): IVector3;
    /**
     * Extracts the scale components and stores them in an output vector.
     * For identity matrix, sets all scale components to 1.
     *
     * @param outVec - The mutable vector to store the scale values
     * @returns The output vector with scale components set to 1
     */
    getScaleTo(outVec: IMutableVector): IMutableVector;
    /**
     * Creates a copy of this identity matrix.
     * Returns a new IdentityMatrix44 instance.
     *
     * @returns A new IdentityMatrix44 instance
     */
    clone(): IMatrix44;
    /**
     * Extracts the rotation part of this transformation matrix.
     * For identity matrix, the rotation is also an identity matrix.
     *
     * @returns A new IdentityMatrix44 representing no rotation
     */
    getRotate(): IMatrix44;
    /**
     * Extracts the translation components from this transformation matrix.
     * For identity matrix, the translation is (0, 0, 0).
     *
     * @returns A Vector3 with all components set to 0
     */
    getTranslate(): IVector3;
    /**
     * Gets the matrix element at row 0, column 0.
     * @returns Always 1 for identity matrix
     */
    get m00(): number;
    /**
     * Gets the matrix element at row 1, column 0.
     * @returns Always 0 for identity matrix
     */
    get m10(): number;
    /**
     * Gets the matrix element at row 2, column 0.
     * @returns Always 0 for identity matrix
     */
    get m20(): number;
    /**
     * Gets the matrix element at row 3, column 0.
     * @returns Always 0 for identity matrix
     */
    get m30(): number;
    /**
     * Gets the matrix element at row 0, column 1.
     * @returns Always 0 for identity matrix
     */
    get m01(): number;
    /**
     * Gets the matrix element at row 1, column 1.
     * @returns Always 1 for identity matrix
     */
    get m11(): number;
    /**
     * Gets the matrix element at row 2, column 1.
     * @returns Always 0 for identity matrix
     */
    get m21(): number;
    /**
     * Gets the matrix element at row 3, column 1.
     * @returns Always 0 for identity matrix
     */
    get m31(): number;
    /**
     * Gets the matrix element at row 0, column 2.
     * @returns Always 0 for identity matrix
     */
    get m02(): number;
    /**
     * Gets the matrix element at row 1, column 2.
     * @returns Always 0 for identity matrix
     */
    get m12(): number;
    /**
     * Gets the matrix element at row 2, column 2.
     * @returns Always 1 for identity matrix
     */
    get m22(): number;
    /**
     * Gets the matrix element at row 3, column 2.
     * @returns Always 0 for identity matrix
     */
    get m32(): number;
    /**
     * Gets the matrix element at row 0, column 3.
     * @returns Always 0 for identity matrix
     */
    get m03(): number;
    /**
     * Gets the matrix element at row 1, column 3.
     * @returns Always 0 for identity matrix
     */
    get m13(): number;
    /**
     * Gets the matrix element at row 2, column 3.
     * @returns Always 0 for identity matrix
     */
    get m23(): number;
    /**
     * Gets the matrix element at row 3, column 3.
     * @returns Always 1 for identity matrix
     */
    get m33(): number;
    /**
     * Gets the X translation component from the matrix.
     * @returns Always 0 for identity matrix
     */
    get translateX(): number;
    /**
     * Gets the Y translation component from the matrix.
     * @returns Always 0 for identity matrix
     */
    get translateY(): number;
    /**
     * Gets the Z translation component from the matrix.
     * @returns Always 0 for identity matrix
     */
    get translateZ(): number;
    /**
     * Gets the class name for debugging and reflection purposes.
     * @returns The string 'IdentityMatrix44'
     */
    get className(): string;
    /**
     * Gets the composition type for this matrix class.
     * @returns CompositionType.Mat4 indicating this is a 4x4 matrix
     */
    static get compositionType(): {
        readonly __numberOfComponents: number;
        readonly __glslStr: string;
        readonly __hlslStr: string;
        readonly __webgpuStr: string;
        readonly __wgslStr: string;
        readonly __isArray: boolean;
        readonly __vec4SizeOfProperty: IndexOf16Bytes;
        readonly __dummyStr: "MAT4";
        readonly webgpu: string;
        readonly wgsl: string;
        getNumberOfComponents(): Count;
        getGlslStr(componentType: ComponentTypeEnum): string;
        getGlslInitialValue(componentType: ComponentTypeEnum): string;
        getWgslInitialValue(componentType: ComponentTypeEnum): string;
        toWGSLType(componentType: ComponentTypeEnum): string;
        getVec4SizeOfProperty(): IndexOf16Bytes;
        readonly index: number;
        readonly symbol: symbol;
        readonly str: string;
        toString(): string;
        toJSON(): number;
    };
    /**
     * Indicates whether this matrix is an identity matrix class.
     * @returns Always true for IdentityMatrix44
     */
    get isIdentityMatrixClass(): boolean;
}

/**
 * Abstract base class for mutable 3D vectors with generic typed array support.
 * Extends the immutable Vector3_ class to provide mutable operations.
 *
 * @template T - The typed array constructor type (Float32Array or Float64Array)
 * @internal
 */
declare class MutableVector3_<T extends FloatTypedArrayConstructor> extends Vector3_<T> implements IMutableVector, IMutableVector3 {
    /**
     * Creates a new MutableVector3_ instance.
     *
     * @param v - The typed array containing the vector components
     * @param options - Configuration object containing the array type
     */
    constructor(v: TypedArray, { type }: {
        type: T;
    });
    /**
     * Sets the x component of the vector.
     *
     * @param x - The new x value
     */
    set x(x: number);
    /**
     * Gets the x component of the vector.
     *
     * @returns The x component value
     */
    get x(): number;
    /**
     * Sets the y component of the vector.
     *
     * @param y - The new y value
     */
    set y(y: number);
    /**
     * Gets the y component of the vector.
     *
     * @returns The y component value
     */
    get y(): number;
    /**
     * Sets the z component of the vector.
     *
     * @param z - The new z value
     */
    set z(z: number);
    /**
     * Gets the z component of the vector.
     *
     * @returns The z component value
     */
    get z(): number;
    /**
     * Gets the w component (always 1 for 3D vectors).
     *
     * @returns Always returns 1
     */
    get w(): number;
    /**
     * Returns the raw typed array containing the vector components.
     *
     * @returns The underlying typed array
     */
    raw(): TypedArray;
    /**
     * Sets the value at the specified index.
     *
     * @param i - The index (0 for x, 1 for y, 2 for z)
     * @param value - The new value to set
     * @returns This vector instance for method chaining
     */
    setAt(i: number, value: number): this;
    /**
     * Sets all three components of the vector.
     *
     * @param x - The x component value
     * @param y - The y component value
     * @param z - The z component value
     * @returns This vector instance for method chaining
     */
    setComponents(x: number, y: number, z: number): this;
    /**
     * Copies the components from another vector.
     *
     * @param vec - The vector to copy from
     * @returns This vector instance for method chaining
     */
    copyComponents(vec: IVector3): this;
    /**
     * Sets all components to zero.
     *
     * @returns This vector instance for method chaining
     */
    zero(): this;
    /**
     * Sets all components to one.
     *
     * @returns This vector instance for method chaining
     */
    one(): this;
    /**
     * Normalizes this vector to unit length.
     * Modifies the vector in place to have a magnitude of 1.
     *
     * @returns This vector instance for method chaining
     */
    normalize(): this;
    /**
     * Adds another vector to this vector.
     * Performs component-wise addition and modifies this vector in place.
     *
     * @param vec - The vector to add
     * @returns This vector instance for method chaining
     */
    add(vec: IVector3): this;
    /**
     * Subtracts another vector from this vector.
     * Performs component-wise subtraction and modifies this vector in place.
     *
     * @param vec - The vector to subtract
     * @returns This vector instance for method chaining
     */
    subtract(vec: IVector3): this;
    /**
     * Multiplies this vector by a scalar value.
     * Scales all components by the given value and modifies this vector in place.
     *
     * @param value - The scalar value to multiply by
     * @returns This vector instance for method chaining
     */
    multiply(value: number): this;
    /**
     * Multiplies this vector by another vector component-wise.
     * Performs element-wise multiplication and modifies this vector in place.
     *
     * @param vec - The vector to multiply by
     * @returns This vector instance for method chaining
     */
    multiplyVector(vec: IVector3): this;
    /**
     * Divides this vector by a scalar value.
     * Scales all components by 1/value and modifies this vector in place.
     * If value is 0, sets all components to Infinity and logs an error.
     *
     * @param value - The scalar value to divide by
     * @returns This vector instance for method chaining
     */
    divide(value: number): this;
    /**
     * Divides this vector by another vector component-wise.
     * Performs element-wise division and modifies this vector in place.
     * If any component of the divisor vector is 0, sets the corresponding component to Infinity.
     *
     * @param vec - The vector to divide by
     * @returns This vector instance for method chaining
     */
    divideVector(vec: IVector3): this;
    /**
     * Computes the cross product of this vector with another vector.
     * Calculates the cross product and modifies this vector in place to store the result.
     * The cross product produces a vector perpendicular to both input vectors.
     *
     * @param vec - The vector to compute cross product with
     * @returns This vector instance for method chaining
     */
    cross(vec: IVector3): this;
    /**
     * Applies a quaternion rotation to this vector.
     * Rotates this vector by the given quaternion and modifies it in place.
     * Equivalent to: quat * vector3 * quat^(-1)
     *
     * @param quat - The quaternion representing the rotation
     * @returns This vector instance for method chaining
     */
    multiplyQuaternion(quat: IQuaternion): this;
    /**
     * Gets the number of bytes per component in the underlying typed array.
     *
     * @returns The number of bytes per element (4 for Float32Array, 8 for Float64Array)
     */
    get bytesPerComponent(): number;
    /**
     * Creates a new vector from three component values.
     *
     * @param x - The x component
     * @param y - The y component
     * @param z - The z component
     * @param type - The typed array constructor
     * @returns A new vector instance
     * @protected
     */
    static _fromCopy3(x: number, y: number, z: number, type: FloatTypedArrayConstructor): MutableVector3_<FloatTypedArrayConstructor>;
}
/**
 * Mutable 3D vector class with 32-bit float precision.
 * Provides in-place vector operations for efficient mathematical computations.
 * All operations modify the vector instance and return it for method chaining.
 */
declare class MutableVector3 extends MutableVector3_<Float32ArrayConstructor> {
    /**
     * Creates a new MutableVector3 instance.
     *
     * @param v - The typed array containing the vector components
     */
    constructor(v: TypedArray);
    /**
     * Creates a zero vector (0, 0, 0).
     *
     * @returns A new zero vector
     */
    static zero(): MutableVector3;
    /**
     * Creates a unit vector (1, 1, 1).
     *
     * @returns A new unit vector
     */
    static one(): MutableVector3;
    /**
     * Creates a dummy vector for initialization purposes.
     *
     * @returns A new dummy vector
     */
    static dummy(): MutableVector3;
    /**
     * Creates a normalized copy of the given vector.
     *
     * @param vec - The vector to normalize
     * @returns A new normalized vector
     */
    static normalize(vec: IVector3): MutableVector3;
    /**
     * Creates a new vector that is the sum of two vectors.
     *
     * @param l_vec - The left vector
     * @param r_vec - The right vector
     * @returns A new vector containing the sum
     */
    static add(l_vec: IVector3, r_vec: IVector3): MutableVector3;
    /**
     * Creates a new vector that is the difference of two vectors.
     *
     * @param l_vec - The left vector (minuend)
     * @param r_vec - The right vector (subtrahend)
     * @returns A new vector containing the difference
     */
    static subtract(l_vec: IVector3, r_vec: IVector3): MutableVector3;
    /**
     * Creates a new vector that is the scalar multiplication of a vector.
     *
     * @param vec - The vector to multiply
     * @param value - The scalar value
     * @returns A new scaled vector
     */
    static multiply(vec: IVector3, value: number): MutableVector3;
    /**
     * Creates a new vector that is the component-wise multiplication of two vectors.
     *
     * @param l_vec - The left vector
     * @param r_vec - The right vector
     * @returns A new vector containing the component-wise product
     */
    static multiplyVector(l_vec: IVector3, r_vec: IVector3): MutableVector3;
    /**
     * Creates a new vector that is the scalar division of a vector.
     *
     * @param vec - The vector to divide
     * @param value - The scalar divisor
     * @returns A new divided vector
     */
    static divide(vec: IVector3, value: number): MutableVector3;
    /**
     * Creates a new vector that is the component-wise division of two vectors.
     *
     * @param l_vec - The dividend vector
     * @param r_vec - The divisor vector
     * @returns A new vector containing the component-wise quotient
     */
    static divideVector(l_vec: IVector3, r_vec: IVector3): MutableVector3;
    /**
     * Creates a new vector that is the cross product of two vectors.
     *
     * @param l_vec - The left vector
     * @param r_vec - The right vector
     * @returns A new vector containing the cross product
     */
    static cross(l_vec: IVector3, r_vec: IVector3): MutableVector3;
    /**
     * Creates a new vector by applying a quaternion rotation to a vector.
     *
     * @param quat - The quaternion representing the rotation
     * @param vec - The vector to rotate
     * @returns A new rotated vector
     */
    static multiplyQuaternion(quat: IQuaternion, vec: IVector3): MutableVector3;
    /**
     * Gets the class name for debugging purposes.
     *
     * @returns The class name string
     */
    get className(): string;
    /**
     * Creates a vector from three component values.
     *
     * @param x - The x component
     * @param y - The y component
     * @param z - The z component
     * @returns A new vector instance
     */
    static fromCopy3(x: number, y: number, z: number): MutableVector3;
    /**
     * Creates a vector with all components set to the same value.
     *
     * @param val - The value for all components
     * @returns A new vector instance
     */
    static fromCopy1(val: number): MutableVector3;
    /**
     * Creates a vector from a 3-element array.
     *
     * @param array - The array containing x, y, z values
     * @returns A new vector instance
     */
    static fromCopyArray3(array: Array3<number>): MutableVector3;
    /**
     * Creates a vector from an array, taking the first 3 elements.
     *
     * @param array - The array containing at least 3 values
     * @returns A new vector instance
     */
    static fromCopyArray(array: Array<number>): MutableVector3;
    /**
     * Creates a vector from an existing Float32Array (shares the same buffer).
     *
     * @param float32Array - The Float32Array to use
     * @returns A new vector instance
     */
    static fromFloat32Array(float32Array: Float32Array): MutableVector3;
    /**
     * Creates a vector by copying from an existing Float32Array.
     *
     * @param float32Array - The Float32Array to copy from
     * @returns A new vector instance with copied data
     */
    static fromCopyFloat32Array(float32Array: Float32Array): MutableVector3;
    /**
     * Creates a vector by copying from another 3D vector.
     *
     * @param vec - The vector to copy from
     * @returns A new vector instance
     */
    static fromCopyVector3(vec: IVector3): MutableVector3;
    /**
     * Creates a 3D vector by copying from a 4D vector (ignoring w component).
     *
     * @param vec - The 4D vector to copy from
     * @returns A new 3D vector instance
     */
    static fromCopyVector4(vec: IVector4): MutableVector3;
    /**
     * Creates a copy of this vector.
     *
     * @returns A new vector instance with the same values
     */
    clone(): MutableVector3;
    /**
     * Rotates a vector around the X-axis and stores the result in the output vector.
     * Only the Y and Z components are affected by X-axis rotation.
     *
     * @param vec3 - The input vector to rotate
     * @param radian - The rotation angle in radians
     * @param outVec - The output vector to store the result
     */
    static rotateX(vec3: IVector3, radian: number, outVec: MutableVector3): void;
    /**
     * Rotates a vector around the Y-axis and stores the result in the output vector.
     * Only the X and Z components are affected by Y-axis rotation.
     *
     * @param vec3 - The input vector to rotate
     * @param radian - The rotation angle in radians
     * @param outVec - The output vector to store the result
     */
    static rotateY(vec3: IVector3, radian: number, outVec: MutableVector3): void;
    /**
     * Rotates a vector around the Z-axis and stores the result in the output vector.
     * Only the X and Y components are affected by Z-axis rotation.
     *
     * @param vec3 - The input vector to rotate
     * @param radian - The rotation angle in radians
     * @param outVec - The output vector to store the result
     */
    static rotateZ(vec3: IVector3, radian: number, outVec: MutableVector3): void;
}
/**
 * Mutable 3D vector class with 64-bit double precision.
 * Provides higher precision vector operations for applications requiring
 * greater numerical accuracy than 32-bit floats.
 */
declare class MutableVector3d extends MutableVector3_<Float64ArrayConstructor> {
    /**
     * Creates a new MutableVector3d instance.
     *
     * @param x - The typed array containing the vector components
     */
    constructor(x: TypedArray);
    /**
     * Creates a zero vector (0, 0, 0) with double precision.
     *
     * @returns A new zero vector
     */
    static zero(): MutableVector3d;
    /**
     * Creates a unit vector (1, 1, 1) with double precision.
     *
     * @returns A new unit vector
     */
    static one(): MutableVector3d;
    /**
     * Creates a dummy vector for initialization purposes with double precision.
     *
     * @returns A new dummy vector
     */
    static dummy(): MutableVector3d;
    /**
     * Creates a normalized copy of the given vector with double precision.
     *
     * @param vec - The vector to normalize
     * @returns A new normalized vector
     */
    static normalize(vec: IVector3): MutableVector3d;
    /**
     * Creates a new vector that is the sum of two vectors with double precision.
     *
     * @param l_vec - The left vector
     * @param r_vec - The right vector
     * @returns A new vector containing the sum
     */
    static add(l_vec: IVector3, r_vec: IVector3): MutableVector3d;
    /**
     * Creates a new vector that is the difference of two vectors with double precision.
     *
     * @param l_vec - The left vector (minuend)
     * @param r_vec - The right vector (subtrahend)
     * @returns A new vector containing the difference
     */
    static subtract(l_vec: IVector3, r_vec: IVector3): MutableVector3d;
    /**
     * Creates a new vector that is the scalar multiplication of a vector with double precision.
     *
     * @param vec - The vector to multiply
     * @param value - The scalar value
     * @returns A new scaled vector
     */
    static multiply(vec: IVector3, value: number): MutableVector3d;
    /**
     * Creates a new vector that is the component-wise multiplication of two vectors with double precision.
     *
     * @param l_vec - The left vector
     * @param r_vec - The right vector
     * @returns A new vector containing the component-wise product
     */
    static multiplyVector(l_vec: IVector3, r_vec: IVector3): MutableVector3d;
    /**
     * Creates a new vector that is the scalar division of a vector with double precision.
     *
     * @param vec - The vector to divide
     * @param value - The scalar divisor
     * @returns A new divided vector
     */
    static divide(vec: IVector3, value: number): MutableVector3d;
    /**
     * Creates a new vector that is the component-wise division of two vectors with double precision.
     *
     * @param l_vec - The dividend vector
     * @param r_vec - The divisor vector
     * @returns A new vector containing the component-wise quotient
     */
    static divideVector(l_vec: IVector3, r_vec: IVector3): MutableVector3d;
    /**
     * Creates a new vector that is the cross product of two vectors with double precision.
     *
     * @param l_vec - The left vector
     * @param r_vec - The right vector
     * @returns A new vector containing the cross product
     */
    static cross(l_vec: IVector3, r_vec: IVector3): MutableVector3d;
    /**
     * Creates a new vector by applying a quaternion rotation to a vector with double precision.
     *
     * @param quat - The quaternion representing the rotation
     * @param vec - The vector to rotate
     * @returns A new rotated vector
     */
    static multiplyQuaternion(quat: IQuaternion, vec: IVector3): MutableVector3d;
    /**
     * Creates a vector from three component values with double precision.
     *
     * @param x - The x component
     * @param y - The y component
     * @param z - The z component
     * @returns A new vector instance
     */
    static fromCopy3(x: number, y: number, z: number): MutableVector3d;
    /**
     * Creates a vector with all components set to the same value with double precision.
     *
     * @param val - The value for all components
     * @returns A new vector instance
     */
    static fromCopy1(val: number): MutableVector3d;
    /**
     * Creates a vector from a 3-element array with double precision.
     *
     * @param array - The array containing x, y, z values
     * @returns A new vector instance
     */
    static fromCopyArray3(array: Array3<number>): MutableVector3d;
    /**
     * Creates a vector from an array, taking the first 3 elements with double precision.
     *
     * @param array - The array containing at least 3 values
     * @returns A new vector instance
     */
    static fromCopyArray(array: Array<number>): MutableVector3d;
    /**
     * Rotates a vector around the X-axis and stores the result in the output vector with double precision.
     * Only the Y and Z components are affected by X-axis rotation.
     *
     * @param vec3 - The input vector to rotate
     * @param radian - The rotation angle in radians
     * @param outVec - The output vector to store the result
     */
    static rotateX(vec3: IVector3, radian: number, outVec: MutableVector3d): void;
    /**
     * Rotates a vector around the Y-axis and stores the result in the output vector with double precision.
     * Only the X and Z components are affected by Y-axis rotation.
     *
     * @param vec3 - The input vector to rotate
     * @param radian - The rotation angle in radians
     * @param outVec - The output vector to store the result
     */
    static rotateY(vec3: IVector3, radian: number, outVec: MutableVector3d): void;
    /**
     * Rotates a vector around the Z-axis and stores the result in the output vector with double precision.
     * Only the X and Y components are affected by Z-axis rotation.
     *
     * @param vec3 - The input vector to rotate
     * @param radian - The rotation angle in radians
     * @param outVec - The output vector to store the result
     */
    static rotateZ(vec3: IVector3, radian: number, outVec: MutableVector3d): void;
    /**
     * Creates a copy of this vector with double precision.
     *
     * @returns A new vector instance with the same values
     */
    clone(): MutableVector3d;
}
/**
 * Type alias for MutableVector3 with single precision (32-bit) floating point components.
 */
type MutableVector3f = MutableVector3;

/**
 * Abstract base class for quaternion implementations.
 *
 * Quaternions are a mathematical system that extends complex numbers and are commonly used
 * in 3D graphics for representing rotations. A quaternion consists of four components (x, y, z, w)
 * where (x, y, z) represents the vector part and w represents the scalar part.
 *
 * This abstract class provides common functionality and interface for all quaternion implementations
 * while leaving specific operations to be implemented by concrete subclasses.
 */
declare abstract class AbstractQuaternion implements IQuaternion {
    /**
     * Gets the class name of the quaternion implementation.
     * @returns The name of the constructor function
     */
    get className(): string;
    /**
     * Gets the x component (i coefficient) of the quaternion.
     * @returns The x component value
     */
    get x(): number;
    /**
     * Gets the y component (j coefficient) of the quaternion.
     * @returns The y component value
     */
    get y(): number;
    /**
     * Gets the z component (k coefficient) of the quaternion.
     * @returns The z component value
     */
    get z(): number;
    /**
     * Gets the w component (scalar part) of the quaternion.
     * @returns The w component value
     */
    get w(): number;
    /**
     * Gets the component at the specified index.
     * @param i - The index (0=x, 1=y, 2=z, 3=w)
     * @returns The component value at the given index
     */
    at(i: number): number;
    /**
     * Calculates the magnitude (length) of the quaternion.
     * @returns The Euclidean norm of the quaternion
     */
    length(): number;
    /**
     * Calculates the squared magnitude of the quaternion.
     * This is more efficient than length() when you only need to compare magnitudes.
     * @returns The squared Euclidean norm of the quaternion
     */
    lengthSquared(): number;
    /**
     * Converts the quaternion to a string representation.
     * @returns String representation of the quaternion
     * @throws Error - Method must be implemented by subclass
     */
    toString(): string;
    /**
     * Converts the quaternion to an approximate string representation.
     * Useful for debugging when exact precision is not required.
     * @returns Approximate string representation of the quaternion
     * @throws Error - Method must be implemented by subclass
     */
    toStringApproximately(): string;
    /**
     * Flattens the quaternion components into a plain number array.
     * @returns Array containing [x, y, z, w] components
     * @throws Error - Method must be implemented by subclass
     */
    flattenAsArray(): number[];
    /**
     * Checks if this quaternion is a dummy/placeholder instance.
     * @returns True if this is a dummy quaternion, false otherwise
     * @throws Error - Method must be implemented by subclass
     */
    isDummy(): boolean;
    /**
     * Checks if this quaternion is approximately equal to another quaternion within a tolerance.
     * @param vec - The quaternion to compare against
     * @param delta - Optional tolerance value for comparison
     * @returns True if quaternions are approximately equal, false otherwise
     * @throws Error - Method must be implemented by subclass
     */
    isEqual(_vec: IQuaternion, _delta?: number): boolean;
    /**
     * Checks if this quaternion is exactly equal to another quaternion.
     * @param vec - The quaternion to compare against
     * @returns True if quaternions are exactly equal, false otherwise
     * @throws Error - Method must be implemented by subclass
     */
    isStrictEqual(_vec: IQuaternion): boolean;
    /**
     * Converts the quaternion to Euler angles and stores the result in the output vector.
     * @param out - The mutable vector to store the resulting Euler angles
     * @returns The output vector containing the Euler angles
     * @throws Error - Method must be implemented by subclass
     */
    toEulerAnglesTo(_out: IMutableVector3): IMutableVector3;
    /**
     * Converts the quaternion to Euler angles.
     * @returns A new vector containing the Euler angles
     * @throws Error - Method must be implemented by subclass
     */
    toEulerAngles(): IVector3;
    /**
     * Transforms a 3D vector by this quaternion rotation.
     * @param vec - The vector to transform
     * @returns A new transformed vector
     * @throws Error - Method must be implemented by subclass
     */
    transformVector3(_vec: IVector3): IVector3;
    /**
     * Transforms a 3D vector by this quaternion rotation and stores the result in the output vector.
     * @param vec - The vector to transform
     * @param out - The mutable vector to store the result
     * @returns The output vector containing the transformed result
     * @throws Error - Method must be implemented by subclass
     */
    transformVector3To(_vec: IVector3, _out: IMutableVector3): IVector3;
    /**
     * Transforms a 3D vector by the inverse of this quaternion rotation.
     * @param vec - The vector to transform
     * @returns A new vector transformed by the inverse rotation
     * @throws Error - Method must be implemented by subclass
     */
    transformVector3Inverse(_vec: IVector3): IVector3;
    /**
     * Calculates the dot product between this quaternion and another quaternion.
     * The dot product of two quaternions gives a scalar value that represents
     * the cosine of half the angle between them when both quaternions are unit quaternions.
     * @param quat - The quaternion to compute the dot product with
     * @returns The dot product result
     */
    dot(quat: IQuaternion): number;
    /**
     * Creates a deep copy of this quaternion.
     * @returns A new quaternion instance with the same values
     * @throws Error - Method must be implemented by subclass
     */
    clone(): IQuaternion;
    /**
     * Internal typed array storage for quaternion components [x, y, z, w].
     * @protected
     */
    _v: Float32Array;
}

/**
 * Represents an immutable quaternion that extends AbstractQuaternion.
 * Quaternions are used to represent rotations in 3D space and offer advantages
 * over Euler angles such as avoiding gimbal lock and providing smooth interpolation.
 *
 * A quaternion consists of four components: x, y, z (vector part) and w (scalar part).
 * For unit quaternions representing rotations: q = w + xi + yj + zk where i = j = k = ijk = -1
 *
 * @example
 * ```typescript
 * // Create identity quaternion (no rotation)
 * const identity = Quaternion.identity();
 *
 * // Create quaternion from axis-angle representation
 * const axis = Vector3.fromCopy3(0, 1, 0); // Y-axis
 * const angle = Math.PI / 4; // 45 degrees
 * const rotation = Quaternion.fromAxisAngle(axis, angle);
 *
 * // Multiply quaternions to combine rotations
 * const combined = Quaternion.multiply(rotation1, rotation2);
 * ```
 */
declare class Quaternion extends AbstractQuaternion implements IQuaternion {
    private static __tmp_upVec;
    private static __tmp_vec3_0;
    private static __tmp_vec3_1;
    private static __tmp_vec3_2;
    private static __tmp_vec3_3;
    private static __tmp_vec3_4;
    private static __tmp_vec3_5;
    /**
     * Creates a new Quaternion instance.
     * @param x - The Float32Array containing the quaternion components [x, y, z, w]
     */
    constructor(x: Float32Array);
    /**
     * Gets the class name for debugging and reflection purposes.
     * @returns The string "Quaternion"
     */
    get className(): string;
    /**
     * Gets the composition type for this quaternion class.
     * @returns CompositionType.Vec4 indicating this is a 4-component vector
     */
    static get compositionType(): {
        readonly __numberOfComponents: number;
        readonly __glslStr: string;
        readonly __hlslStr: string;
        readonly __webgpuStr: string;
        readonly __wgslStr: string;
        readonly __isArray: boolean;
        readonly __vec4SizeOfProperty: IndexOf16Bytes;
        readonly __dummyStr: "VEC4";
        readonly webgpu: string;
        readonly wgsl: string;
        getNumberOfComponents(): Count;
        getGlslStr(componentType: ComponentTypeEnum): string;
        getGlslInitialValue(componentType: ComponentTypeEnum): string;
        getWgslInitialValue(componentType: ComponentTypeEnum): string;
        toWGSLType(componentType: ComponentTypeEnum): string;
        getVec4SizeOfProperty(): IndexOf16Bytes;
        readonly index: number;
        readonly symbol: symbol;
        readonly str: string;
        toString(): string;
        toJSON(): number;
    };
    /**
     * Creates an identity quaternion representing no rotation.
     * The identity quaternion is (0, 0, 0, 1) in (x, y, z, w) format.
     * @returns A new identity quaternion
     */
    static identity(): Quaternion;
    /**
     * Creates a dummy quaternion with zero-length internal array.
     * Used as a placeholder or uninitialized quaternion.
     * @returns A new dummy quaternion
     */
    static dummy(): Quaternion;
    /**
     * Computes the inverse of a quaternion.
     * For a unit quaternion, the inverse is the conjugate divided by the squared magnitude.
     * @param quat - The quaternion to invert
     * @returns The inverted quaternion, or zero quaternion if input has zero length
     */
    static invert(quat: IQuaternion): IQuaternion;
    /**
     * Computes the inverse of a quaternion and stores the result in the output parameter.
     * @param quat - The quaternion to invert
     * @param out - The output quaternion to store the result
     * @returns The output quaternion containing the inverted result
     */
    static invertTo(quat: IQuaternion, out: IMutableQuaternion): IQuaternion;
    /**
     * Performs spherical linear interpolation (SLERP) between two quaternions.
     * SLERP provides smooth rotation interpolation that maintains constant angular velocity.
     * @param l_quat - The starting quaternion
     * @param r_quat - The ending quaternion
     * @param ratio - The interpolation parameter (0.0 = l_quat, 1.0 = r_quat)
     * @returns The interpolated quaternion
     */
    static qlerp(l_quat: IQuaternion, r_quat: IQuaternion, ratio: number): IQuaternion;
    /**
     * Performs spherical linear interpolation (SLERP) and stores the result in the output parameter.
     * @param l_quat - The starting quaternion
     * @param r_quat - The ending quaternion
     * @param ratio - The interpolation parameter (0.0 = l_quat, 1.0 = r_quat)
     * @param out - The output quaternion to store the result
     * @returns The output quaternion containing the interpolated result
     */
    static qlerpTo(l_quat: IQuaternion, r_quat: IQuaternion, ratio: number, out: IMutableQuaternion): IMutableQuaternion;
    /**
     * Performs linear interpolation (LERP) between two quaternions.
     * Note: LERP does not maintain constant angular velocity like SLERP.
     * @param l_quat - The starting quaternion
     * @param r_quat - The ending quaternion
     * @param ratio - The interpolation parameter (0.0 = l_quat, 1.0 = r_quat)
     * @returns The linearly interpolated quaternion
     */
    static lerp(l_quat: IQuaternion, r_quat: IQuaternion, ratio: number): Quaternion;
    /**
     * Performs linear interpolation (LERP) and stores the result in the output parameter.
     * @param l_quat - The starting quaternion
     * @param r_quat - The ending quaternion
     * @param ratio - The interpolation parameter (0.0 = l_quat, 1.0 = r_quat)
     * @param out - The output quaternion to store the result
     * @returns The output quaternion containing the interpolated result
     */
    static lerpTo(l_quat: IQuaternion, r_quat: IQuaternion, ratio: number, out: IMutableQuaternion): IMutableQuaternion;
    /**
     * Creates a quaternion from an axis-angle representation.
     * @param vec - The rotation axis (will be normalized internally)
     * @param radian - The rotation angle in radians
     * @returns A quaternion representing the rotation around the given axis
     */
    static axisAngle(vec: IVector3, radian: number): Quaternion;
    /**
     * Creates a quaternion from a 4x4 rotation matrix.
     * Extracts the rotation component from the matrix and converts it to quaternion form.
     * @param mat - The 4x4 matrix containing rotation information
     * @returns A quaternion representing the same rotation as the matrix
     */
    static fromMatrix(mat: IMatrix44): Quaternion;
    /**
     * Creates a quaternion from a 4x4 rotation matrix and stores it in the output parameter.
     * @param mat - The 4x4 matrix containing rotation information
     * @param out - The output quaternion to store the result
     * @returns The output quaternion containing the extracted rotation
     */
    static fromMatrixTo(mat: IMatrix44, out: IMutableQuaternion): IMutableQuaternion;
    /**
     * Creates a quaternion that rotates from one direction to another.
     * @param fromDirection - The initial direction vector
     * @param toDirection - The target direction vector
     * @returns A quaternion representing the rotation from fromDirection to toDirection
     */
    static lookFromTo(fromDirection: IVector3, toDirection: IVector3): IQuaternion;
    /**
     * Creates a quaternion that looks in the specified forward direction using default up vector (0, 1, 0).
     * @param forward - The forward direction vector
     * @returns A quaternion representing the look rotation
     */
    static lookForward(forward: IVector3): IQuaternion;
    /**
     * Creates a quaternion that looks in the specified forward direction with a custom up vector.
     * @param forward - The forward direction vector
     * @param up - The up direction vector
     * @returns A quaternion representing the look rotation with the specified up vector
     */
    static lookForwardAccordingToThisUp(forward: IVector3, up: IVector3): IQuaternion;
    /**
     * Creates a quaternion from a position vector, with w component set to 0.
     * This is useful for representing pure translations in quaternion form.
     * @param vec - The position vector
     * @returns A quaternion with xyz from the vector and w=0
     */
    static fromPosition(vec: IVector3): Quaternion;
    /**
     * Adds two quaternions component-wise.
     * @param l_quat - The left quaternion
     * @param r_quat - The right quaternion
     * @returns The sum of the two quaternions
     */
    static add(l_quat: IQuaternion, r_quat: IQuaternion): Quaternion;
    /**
     * Adds two quaternions component-wise and stores the result in the output parameter.
     * @param l_quat - The left quaternion
     * @param r_quat - The right quaternion
     * @param out - The output quaternion to store the result
     * @returns The output quaternion containing the sum
     */
    static addTo(l_quat: IQuaternion, r_quat: IQuaternion, out: IMutableQuaternion): IMutableQuaternion;
    /**
     * Subtracts the right quaternion from the left quaternion component-wise.
     * @param l_quat - The left quaternion
     * @param r_quat - The right quaternion
     * @returns The difference of the two quaternions
     */
    static subtract(l_quat: IQuaternion, r_quat: IQuaternion): Quaternion;
    /**
     * Subtracts two quaternions component-wise and stores the result in the output parameter.
     * @param l_quat - The left quaternion
     * @param r_quat - The right quaternion
     * @param out - The output quaternion to store the result
     * @returns The output quaternion containing the difference
     */
    static subtractTo(l_quat: IQuaternion, r_quat: IQuaternion, out: IMutableQuaternion): IMutableQuaternion;
    /**
     * Multiplies two quaternions using Hamilton's quaternion multiplication.
     * This combines the rotations represented by both quaternions.
     * Note: Quaternion multiplication is not commutative (order matters).
     * @param l_quat - The left quaternion
     * @param r_quat - The right quaternion
     * @returns The product of the two quaternions
     */
    static multiply(l_quat: IQuaternion, r_quat: IQuaternion): Quaternion;
    /**
     * Multiplies two quaternions and stores the result in the output parameter.
     * @param l_quat - The left quaternion
     * @param r_quat - The right quaternion
     * @param out - The output quaternion to store the result
     * @returns The output quaternion containing the product
     */
    static multiplyTo(l_quat: IQuaternion, r_quat: IQuaternion, out: IMutableQuaternion): IMutableQuaternion;
    /**
     * Multiplies a quaternion by a scalar value.
     * @param quat - The quaternion to multiply
     * @param value - The scalar value to multiply by
     * @returns A new quaternion with all components multiplied by the scalar
     */
    static multiplyNumber(quat: IQuaternion, value: number): Quaternion;
    /**
     * Multiplies a quaternion by a scalar and stores the result in the output parameter.
     * @param quat - The quaternion to multiply
     * @param value - The scalar value to multiply by
     * @param out - The output quaternion to store the result
     * @returns The output quaternion containing the scaled result
     */
    static multiplyNumberTo(quat: IQuaternion, value: number, out: IMutableQuaternion): IMutableQuaternion;
    /**
     * Divides a quaternion by a scalar value.
     * @param quat - The quaternion to divide
     * @param value - The scalar value to divide by (must not be zero)
     * @returns A new quaternion with all components divided by the scalar
     */
    static divideNumber(quat: IQuaternion, value: number): Quaternion;
    /**
     * Divides a quaternion by a scalar and stores the result in the output parameter.
     * @param quat - The quaternion to divide
     * @param value - The scalar value to divide by (must not be zero)
     * @param out - The output quaternion to store the result
     * @returns The output quaternion containing the divided result
     */
    static divideNumberTo(quat: IQuaternion, value: number, out: IMutableQuaternion): IMutableQuaternion;
    /**
     * Converts the quaternion to a string representation.
     * @returns A string in the format "(x, y, z, w)"
     */
    toString(): string;
    /**
     * Converts the quaternion to an approximately formatted string using financial precision.
     * @returns A formatted string with components separated by spaces and ending with newline
     */
    toStringApproximately(): string;
    /**
     * Converts the quaternion to a flat array representation.
     * @returns An array containing [x, y, z, w] components
     */
    flattenAsArray(): number[];
    /**
     * Checks if this quaternion is a dummy (uninitialized) quaternion.
     * @returns True if the internal array has zero length, false otherwise
     */
    isDummy(): boolean;
    /**
     * Checks if this quaternion is approximately equal to another quaternion within a tolerance.
     * @param quat - The quaternion to compare with
     * @param delta - The tolerance value (default: Number.EPSILON)
     * @returns True if all components are within the tolerance, false otherwise
     */
    isEqual(quat: IQuaternion, delta?: number): boolean;
    /**
     * Checks if this quaternion is exactly equal to another quaternion.
     * @param quat - The quaternion to compare with
     * @returns True if all components are exactly equal, false otherwise
     */
    isStrictEqual(quat: IQuaternion): boolean;
    /**
     * Converts the quaternion to Euler angles and stores the result in the output vector.
     * The rotation order is XYZ (roll, pitch, yaw).
     * @param out - The output vector to store the Euler angles [x, y, z]
     * @returns The output vector containing the Euler angles in radians
     */
    toEulerAnglesTo(out: IMutableVector3): IMutableVector3;
    /**
     * Converts the quaternion to Euler angles.
     * The rotation order is XYZ (roll, pitch, yaw).
     * @returns A new Vector3 containing the Euler angles in radians
     */
    toEulerAngles(): Vector3;
    /**
     * Private helper method for dividing a quaternion by a scalar value.
     * @param vec - The quaternion to divide
     * @param value - The scalar value to divide by
     * @returns A new quaternion with divided components, or Infinity components if division by zero
     */
    private static _divide;
    /**
     * Private helper method for dividing a quaternion by a scalar and storing the result.
     * @param vec - The quaternion to divide
     * @param value - The scalar value to divide by
     * @param out - The output quaternion to store the result
     * @returns The output quaternion with divided components
     */
    private static _divideTo;
    /**
     * Normalizes a quaternion to unit length.
     * @param vec - The quaternion to normalize
     * @returns A new normalized quaternion
     */
    static normalize(vec: IQuaternion): Quaternion;
    /**
     * Normalizes a quaternion to unit length and stores the result in the output parameter.
     * @param vec - The quaternion to normalize
     * @param out - The output quaternion to store the result
     * @returns The output quaternion containing the normalized result
     */
    static normalizeTo(vec: IQuaternion, out: IMutableQuaternion): IMutableQuaternion;
    /**
     * Creates a quaternion representing the rotation from one vector to another.
     * This is an instance method version of the static fromToRotation.
     * @param from - The starting direction vector
     * @param to - The target direction vector
     * @returns The normalized quaternion representing the rotation
     */
    fromToRotation(from: IVector3, to: IVector3): Quaternion;
    /**
     * Creates a quaternion representing the rotation from one vector to another (static version).
     * @param from - The starting direction vector
     * @param to - The target direction vector
     * @returns A normalized quaternion representing the rotation
     */
    static fromToRotation(from: IVector3, to: IVector3): Quaternion;
    /**
     * Creates a quaternion representing the rotation from one vector to another and stores it in the output parameter.
     * @param from - The starting direction vector
     * @param to - The target direction vector
     * @param out - The output quaternion to store the result
     * @returns The output quaternion containing the normalized rotation
     */
    static fromToRotationTo(from: IVector3, to: IVector3, out: IMutableQuaternion): IMutableQuaternion;
    /**
     * Transforms a 3D vector by this quaternion rotation.
     * Applies the rotation represented by this quaternion to the input vector.
     * @param v - The vector to transform
     * @returns A new transformed vector
     */
    transformVector3(v: IVector3): Vector3;
    /**
     * Transforms a 3D vector by this quaternion rotation and stores the result in the output parameter.
     * @param v - The vector to transform
     * @param out - The output vector to store the result
     * @returns The output vector containing the transformed result
     */
    transformVector3To(v: IVector3, out: IMutableVector3): IMutableVector3;
    /**
     * Transforms a 3D vector by the inverse of this quaternion rotation.
     * @param v - The vector to transform
     * @returns A new transformed vector
     */
    transformVector3Inverse(v: IVector3): IVector3;
    /**
     * Creates a deep copy of this quaternion.
     * @returns A new quaternion with the same component values
     */
    clone(): IQuaternion;
    /**
     * Creates a quaternion from a Float32Array.
     * @param array - The Float32Array containing quaternion components
     * @returns A new quaternion using the provided array
     */
    static fromFloat32Array(array: Float32Array): Quaternion;
    /**
     * Creates a quaternion from a 4-element array.
     * @param array - The array containing [x, y, z, w] components
     * @returns A new quaternion with copied components
     */
    static fromCopyArray4(array: Array4<number>): Quaternion;
    /**
     * Creates a quaternion from a variable-length array (taking first 4 elements).
     * @param array - The array containing quaternion components
     * @returns A new quaternion with the first 4 components copied
     */
    static fromCopyArray(array: Array<number>): Quaternion;
    /**
     * Creates a quaternion from individual component values.
     * @param x - The x component
     * @param y - The y component
     * @param z - The z component
     * @param w - The w component
     * @returns A new quaternion with the specified components
     */
    static fromCopy4(x: number, y: number, z: number, w: number): Quaternion;
    /**
     * Creates a quaternion by copying from another quaternion.
     * @param quat - The quaternion to copy from
     * @returns A new quaternion with copied components
     */
    static fromCopyQuaternion(quat: IQuaternion): Quaternion;
    /**
     * Creates a quaternion by copying from a 4D vector.
     * @param vec - The 4D vector to copy from
     * @returns A new quaternion with components copied from the vector
     */
    static fromCopyVector4(vec: IVector4): Quaternion;
    /**
     * Creates a quaternion from a log quaternion representation.
     * @param x - The log quaternion to convert
     * @returns A new quaternion converted from log space
     */
    static fromCopyLogQuaternion(x: ILogQuaternion): Quaternion;
    /**
     * Creates a quaternion from an axis-angle representation.
     * @param axis - The rotation axis vector
     * @param rad - The rotation angle in radians
     * @returns A new quaternion representing the rotation
     */
    static fromAxisAngle(axis: IVector3, rad: number): Quaternion;
    /**
     * Creates a quaternion from an axis-angle representation and stores it in the output parameter.
     * @param axis - The rotation axis vector
     * @param rad - The rotation angle in radians
     * @param out - The output quaternion to store the result
     * @returns The output quaternion containing the rotation
     */
    static fromAxisAngleTo(axis: IVector3, rad: number, out: IMutableQuaternion): IMutableQuaternion;
    /**
     * Gets the rotation angle (0 to ) represented by a quaternion.
     * @param q - The quaternion to analyze (assumed to be normalized)
     * @returns The rotation angle in radians
     */
    static getQuaternionAngle(q: IQuaternion): number;
    /**
     * Clamps the rotation angle of a quaternion to a maximum value.
     * If the quaternion's rotation angle exceeds thetaMax, it scales the rotation down.
     * @param quat - The quaternion to clamp
     * @param thetaMax - The maximum allowed rotation angle in radians
     * @returns A quaternion with rotation angle clamped to thetaMax
     */
    static clampRotation(quat: IQuaternion, thetaMax: number): IQuaternion;
}

/**
 * A mutable 4x4 matrix class that extends the immutable Matrix44 class.
 *
 * This class provides a mutable interface for 4x4 matrix operations commonly used
 * in 3D graphics, including transformations, rotations, scaling, and projections.
 * The matrix is stored in column-major order internally, which is compatible with WebGL.
 *
 * @example
 * ```typescript
 * const matrix = MutableMatrix44.identity();
 * matrix.translate(Vector3.fromCopy(1, 2, 3));
 * matrix.rotateY(Math.PI / 4);
 * ```
 */
declare class MutableMatrix44 extends Matrix44 implements IMutableMatrix, IMutableMatrix44 {
    /**
     * Sets the value at position (0,0) in the matrix.
     *
     * @param val - The value to set
     */
    set m00(val: number);
    /**
     * Gets the value at position (0,0) in the matrix.
     *
     * @returns The value at position (0,0)
     */
    get m00(): number;
    /**
     * Sets the value at position (1,0) in the matrix.
     *
     * @param val - The value to set
     */
    set m10(val: number);
    /**
     * Gets the value at position (1,0) in the matrix.
     *
     * @returns The value at position (1,0)
     */
    get m10(): number;
    /**
     * Sets the value at position (2,0) in the matrix.
     *
     * @param val - The value to set
     */
    set m20(val: number);
    /**
     * Gets the value at position (2,0) in the matrix.
     *
     * @returns The value at position (2,0)
     */
    get m20(): number;
    /**
     * Sets the value at position (3,0) in the matrix.
     *
     * @param val - The value to set
     */
    set m30(val: number);
    /**
     * Gets the value at position (3,0) in the matrix.
     *
     * @returns The value at position (3,0)
     */
    get m30(): number;
    /**
     * Sets the value at position (0,1) in the matrix.
     *
     * @param val - The value to set
     */
    set m01(val: number);
    /**
     * Gets the value at position (0,1) in the matrix.
     *
     * @returns The value at position (0,1)
     */
    get m01(): number;
    /**
     * Sets the value at position (1,1) in the matrix.
     *
     * @param val - The value to set
     */
    set m11(val: number);
    /**
     * Gets the value at position (1,1) in the matrix.
     *
     * @returns The value at position (1,1)
     */
    get m11(): number;
    /**
     * Sets the value at position (2,1) in the matrix.
     *
     * @param val - The value to set
     */
    set m21(val: number);
    /**
     * Gets the value at position (2,1) in the matrix.
     *
     * @returns The value at position (2,1)
     */
    get m21(): number;
    /**
     * Sets the value at position (3,1) in the matrix.
     *
     * @param val - The value to set
     */
    set m31(val: number);
    /**
     * Gets the value at position (3,1) in the matrix.
     *
     * @returns The value at position (3,1)
     */
    get m31(): number;
    /**
     * Sets the value at position (0,2) in the matrix.
     *
     * @param val - The value to set
     */
    set m02(val: number);
    /**
     * Gets the value at position (0,2) in the matrix.
     *
     * @returns The value at position (0,2)
     */
    get m02(): number;
    /**
     * Sets the value at position (1,2) in the matrix.
     *
     * @param val - The value to set
     */
    set m12(val: number);
    /**
     * Gets the value at position (1,2) in the matrix.
     *
     * @returns The value at position (1,2)
     */
    get m12(): number;
    /**
     * Sets the value at position (2,2) in the matrix.
     *
     * @param val - The value to set
     */
    set m22(val: number);
    /**
     * Gets the value at position (2,2) in the matrix.
     *
     * @returns The value at position (2,2)
     */
    get m22(): number;
    /**
     * Sets the value at position (3,2) in the matrix.
     *
     * @param val - The value to set
     */
    set m32(val: number);
    /**
     * Gets the value at position (3,2) in the matrix.
     *
     * @returns The value at position (3,2)
     */
    get m32(): number;
    /**
     * Sets the value at position (0,3) in the matrix.
     *
     * @param val - The value to set
     */
    set m03(val: number);
    /**
     * Gets the value at position (0,3) in the matrix.
     *
     * @returns The value at position (0,3)
     */
    get m03(): number;
    /**
     * Sets the value at position (1,3) in the matrix.
     *
     * @param val - The value to set
     */
    set m13(val: number);
    /**
     * Gets the value at position (1,3) in the matrix.
     *
     * @returns The value at position (1,3)
     */
    get m13(): number;
    /**
     * Sets the value at position (2,3) in the matrix.
     *
     * @param val - The value to set
     */
    set m23(val: number);
    /**
     * Gets the value at position (2,3) in the matrix.
     *
     * @returns The value at position (2,3)
     */
    get m23(): number;
    /**
     * Sets the value at position (3,3) in the matrix.
     *
     * @param val - The value to set
     */
    set m33(val: number);
    /**
     * Gets the value at position (3,3) in the matrix.
     *
     * @returns The value at position (3,3)
     */
    get m33(): number;
    /**
     * Gets the X translation component from the matrix.
     *
     * @returns The X translation value
     */
    get translateX(): number;
    /**
     * Sets the X translation component in the matrix.
     *
     * @param val - The X translation value to set
     */
    set translateX(val: number);
    /**
     * Gets the Y translation component from the matrix.
     *
     * @returns The Y translation value
     */
    get translateY(): number;
    /**
     * Sets the Y translation component in the matrix.
     *
     * @param val - The Y translation value to set
     */
    set translateY(val: number);
    /**
     * Gets the Z translation component from the matrix.
     *
     * @returns The Z translation value
     */
    get translateZ(): number;
    /**
     * Sets the Z translation component in the matrix.
     *
     * @param val - The Z translation value to set
     */
    set translateZ(val: number);
    /**
     * Gets the class name identifier for this matrix type.
     *
     * @returns The string 'MutableMatrix44'
     */
    get className(): string;
    /**
     * Creates a zero matrix (all elements are 0).
     *
     * @returns A new MutableMatrix44 instance with all elements set to 0
     */
    static zero(): MutableMatrix44;
    /**
     * Creates an identity matrix.
     *
     * @returns A new MutableMatrix44 instance representing the 4x4 identity matrix
     */
    static identity(): MutableMatrix44;
    /**
     * Creates a dummy matrix (typically used as a placeholder).
     *
     * @returns A new MutableMatrix44 instance representing a dummy matrix
     */
    static dummy(): MutableMatrix44;
    /**
     * Creates a transposed matrix from the given matrix.
     *
     * @param mat - The matrix to transpose
     * @returns A new MutableMatrix44 instance that is the transpose of the input matrix
     */
    static transpose(mat: Matrix44): Matrix44;
    /**
     * Creates an inverted matrix from the given matrix.
     *
     * @param mat - The matrix to invert
     * @returns A new MutableMatrix44 instance that is the inverse of the input matrix
     */
    static invert(mat: Matrix44): MutableMatrix44;
    /**
     * Creates a translation matrix from the given vector.
     *
     * @param vec - The translation vector
     * @returns A new MutableMatrix44 instance representing the translation transformation
     */
    static translate(vec: Vector3): MutableMatrix44;
    /**
     * Creates a rotation matrix around the X-axis.
     *
     * @param radian - The rotation angle in radians
     * @returns A new MutableMatrix44 instance representing the X-axis rotation
     */
    static rotateX(radian: number): MutableMatrix44;
    /**
     * Creates a rotation matrix around the Y-axis.
     *
     * @param radian - The rotation angle in radians
     * @returns A new MutableMatrix44 instance representing the Y-axis rotation
     */
    static rotateY(radian: number): MutableMatrix44;
    /**
     * Creates a rotation matrix around the Z-axis.
     *
     * @param radian - The rotation angle in radians
     * @returns A new MutableMatrix44 instance representing the Z-axis rotation
     */
    static rotateZ(radian: number): MutableMatrix44;
    /**
     * Creates a rotation matrix with rotations around X, Y, and Z axes in that order.
     *
     * @param x - Rotation angle around X-axis in radians
     * @param y - Rotation angle around Y-axis in radians
     * @param z - Rotation angle around Z-axis in radians
     * @returns A new MutableMatrix44 instance representing the combined rotation
     */
    static rotateXYZ(x: number, y: number, z: number): MutableMatrix44;
    /**
     * Creates a rotation matrix from a vector containing X, Y, Z rotation angles.
     *
     * @param vec - Vector containing rotation angles (x, y, z) in radians
     * @returns A new MutableMatrix44 instance representing the rotation transformation
     */
    static rotate(vec: Vector3): MutableMatrix44;
    /**
     * Creates a scaling matrix from the given vector.
     *
     * @param vec - The scaling factors for X, Y, and Z axes
     * @returns A new MutableMatrix44 instance representing the scaling transformation
     */
    static scale(vec: Vector3): MutableMatrix44;
    /**
     * Multiplies two matrices and returns the result as a new matrix.
     *
     * @param l_mat - The left matrix in the multiplication
     * @param r_mat - The right matrix in the multiplication
     * @returns A new MutableMatrix44 instance representing the product l_mat * r_mat
     */
    static multiply(l_mat: Matrix44, r_mat: Matrix44): MutableMatrix44;
    /**
     * Creates a copy of this matrix.
     *
     * @returns A new MutableMatrix44 instance with the same values as this matrix
     */
    clone(): MutableMatrix44;
    /**
     * Extracts the rotation part of this matrix.
     *
     * @returns A new MutableMatrix44 instance containing only the rotation transformation
     */
    getRotate(): MutableMatrix44;
    /**
     * Extracts the translation part of this matrix.
     *
     * @returns A new MutableVector3 instance containing the translation values
     */
    getTranslate(): MutableVector3;
    /**
     * Extracts the translation part of this matrix into the provided vector.
     *
     * @param outVec - The vector to store the translation values
     * @returns The output vector with translation values
     */
    getTranslateTo(outVec: MutableVector3): MutableVector3;
    /**
     * Extracts the scale part of this matrix.
     *
     * @returns A new MutableVector3 instance containing the scale values for each axis
     */
    getScale(): MutableVector3;
    /**
     * Gets the raw Float32Array containing the matrix data.
     *
     * @returns The internal Float32Array with matrix values in column-major order
     */
    raw(): Float32Array<ArrayBufferLike>;
    /**
     * Sets a value at the specified row and column position.
     *
     * @param row_i - The row index (0-3)
     * @param column_i - The column index (0-3)
     * @param value - The value to set
     * @returns This matrix instance for method chaining
     */
    setAt(row_i: number, column_i: number, value: number): this;
    /**
     * Sets all 16 components of the matrix with individual values.
     * Values are specified in row-major order but stored internally in column-major order.
     *
     * @param m00 - Element at row 0, column 0
     * @param m01 - Element at row 0, column 1
     * @param m02 - Element at row 0, column 2
     * @param m03 - Element at row 0, column 3
     * @param m10 - Element at row 1, column 0
     * @param m11 - Element at row 1, column 1
     * @param m12 - Element at row 1, column 2
     * @param m13 - Element at row 1, column 3
     * @param m20 - Element at row 2, column 0
     * @param m21 - Element at row 2, column 1
     * @param m22 - Element at row 2, column 2
     * @param m23 - Element at row 2, column 3
     * @param m30 - Element at row 3, column 0
     * @param m31 - Element at row 3, column 1
     * @param m32 - Element at row 3, column 2
     * @param m33 - Element at row 3, column 3
     * @returns This matrix instance for method chaining
     */
    setComponents(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): this;
    /**
     * Copies all components from another matrix to this matrix.
     *
     * @param mat - The source matrix to copy from
     * @returns This matrix instance for method chaining
     */
    copyComponents(mat: IMatrix44): this;
    /**
     * Sets this matrix to the zero matrix (all elements are 0).
     *
     * @returns This matrix instance for method chaining
     */
    zero(): this;
    /**
     * Sets this matrix to the identity matrix.
     *
     * @returns This matrix instance for method chaining
     */
    identity(): this;
    _swap(l: Index, r: Index): void;
    /**
     * Transposes this matrix in place (swaps rows and columns).
     *
     * @returns This matrix instance for method chaining
     */
    transpose(): this;
    /**
     * Inverts this matrix in place.
     * The matrix must be invertible (determinant != 0), otherwise an error is logged.
     *
     * @returns This matrix instance for method chaining
     */
    invert(): this;
    /**
     * Sets this matrix to a translation matrix with the given vector.
     *
     * @param vec - The translation vector
     * @returns This matrix instance for method chaining
     */
    translate(vec: Vector3): this;
    /**
     * Sets the translation component of this matrix without affecting other components.
     *
     * @param vec - The translation vector to set
     * @returns This matrix instance for method chaining
     */
    putTranslate(vec: Vector3): this;
    /**
     * Adds the given vector to the current translation component.
     *
     * @param vec - The translation vector to add
     * @returns This matrix instance for method chaining
     */
    addTranslate(vec: Vector3): this;
    /**
     * Sets this matrix to a rotation matrix around the X-axis.
     *
     * @param radian - The rotation angle in radians
     * @returns This matrix instance for method chaining
     */
    rotateX(radian: number): this;
    /**
     * Sets this matrix to a rotation matrix around the Y-axis.
     *
     * @param radian - The rotation angle in radians
     * @returns This matrix instance for method chaining
     */
    rotateY(radian: number): this;
    /**
     * Sets this matrix to a rotation matrix around the Z-axis.
     *
     * @param radian - The rotation angle in radians
     * @returns This matrix instance for method chaining
     */
    rotateZ(radian: number): this;
    /**
     * Sets this matrix to a rotation matrix with rotations around X, Y, and Z axes in that order.
     * The rotation order is: Z * Y * X (applied from right to left).
     *
     * @param x - Rotation angle around X-axis in radians
     * @param y - Rotation angle around Y-axis in radians
     * @param z - Rotation angle around Z-axis in radians
     * @returns This matrix instance for method chaining
     */
    rotateXYZ(x: number, y: number, z: number): this;
    /**
     * Sets this matrix to a rotation matrix from a vector containing X, Y, Z rotation angles.
     *
     * @param vec - Vector containing rotation angles (x, y, z) in radians
     * @returns This matrix instance for method chaining
     */
    rotate(vec: Vector3): this;
    /**
     * Sets this matrix to a scaling matrix with the given vector.
     *
     * @param vec - The scaling factors for X, Y, and Z axes
     * @returns This matrix instance for method chaining
     */
    scale(vec: Vector3): this;
    /**
     * Multiplies the scaling factors to the current matrix.
     * This applies scaling transformation to each column of the matrix.
     *
     * @param vec - The scaling factors for X, Y, and Z axes
     * @returns This matrix instance for method chaining
     */
    multiplyScale(vec: Vector3): this;
    /**
     * Multiplies this matrix by another matrix from the right side (this * mat).
     * This operation transforms this matrix in place.
     *
     * @param mat - The matrix to multiply from the right
     * @returns This matrix instance for method chaining
     */
    multiply(mat: Matrix44): this;
    /**
     * Multiplies this matrix by another matrix from the left side (mat * this).
     * This operation transforms this matrix in place.
     *
     * @param mat - The matrix to multiply from the left
     * @returns This matrix instance for method chaining
     */
    multiplyByLeft(mat: Matrix44): this;
    /**
     * Sets this matrix to a rotation matrix based on the given quaternion.
     *
     * @param quat - The quaternion to convert to a rotation matrix
     * @returns This matrix instance for method chaining
     */
    fromQuaternion(quat: IQuaternion): this;
    /**
     * Creates a matrix from 16 values in row-major order.
     * Values are provided in row-major order but stored internally in column-major order.
     *
     * @param m00-m33 - Matrix elements in row-major order
     * @returns A new MutableMatrix44 instance
     */
    static fromCopy16RowMajor(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): MutableMatrix44;
    /**
     * Creates a matrix from 16 values in column-major order.
     *
     * @param m00-m33 - Matrix elements in column-major order
     * @returns A new MutableMatrix44 instance
     */
    static fromCopy16ColumnMajor(m00: number, m10: number, m20: number, m30: number, m01: number, m11: number, m21: number, m31: number, m02: number, m12: number, m22: number, m32: number, m03: number, m13: number, m23: number, m33: number): MutableMatrix44;
    /**
     * Creates a new MutableMatrix44 from an existing Matrix44 instance.
     * This creates a copy of the matrix data, so modifications to the new matrix
     * will not affect the original.
     *
     * @param mat - The source Matrix44 to copy from
     * @returns A new MutableMatrix44 instance with copied data
     */
    static fromCopyMatrix44(mat: IMatrix44): MutableMatrix44;
    /**
     * Creates a new MutableMatrix44 directly from a Float32Array in column-major order.
     * This method does not copy the array, so the matrix will share the same memory
     * as the input array.
     *
     * @param float32Array - A Float32Array containing 16 elements in column-major order
     * @returns A new MutableMatrix44 instance using the provided array
     */
    static fromFloat32ArrayColumnMajor(float32Array: Float32Array): MutableMatrix44;
    /**
     * Creates a new MutableMatrix44 from a Float32Array in column-major order.
     * This method creates a copy of the input array, so modifications to the matrix
     * will not affect the original array.
     *
     * @param float32Array - A Float32Array containing 16 elements in column-major order
     * @returns A new MutableMatrix44 instance with copied data
     */
    static fromCopyFloat32ArrayColumnMajor(float32Array: Float32Array): MutableMatrix44;
    /**
     * Creates a new MutableMatrix44 from a Float32Array in row-major order.
     * The input data is converted from row-major to column-major order during creation.
     *
     * @param array - A Float32Array containing 16 elements in row-major order
     * @returns A new MutableMatrix44 instance with data converted to column-major order
     */
    static fromCopyFloat32ArrayRowMajor(array: Float32Array): MutableMatrix44;
    /**
     * Creates a new MutableMatrix44 from a 3x3 matrix.
     * The 3x3 matrix is embedded in the upper-left corner of the 4x4 matrix,
     * with the bottom row and right column set to [0, 0, 0, 1].
     *
     * @param mat - The source 3x3 matrix to convert
     * @returns A new MutableMatrix44 instance with the 3x3 matrix embedded
     */
    static fromCopyMatrix33(mat: IMatrix33): MutableMatrix44;
    /**
     * Creates a new MutableMatrix44 from an Array16 in column-major order.
     * This method copies the array data into a new Float32Array.
     *
     * @param array - An Array16 containing 16 elements in column-major order
     * @returns A new MutableMatrix44 instance with copied data
     */
    static fromCopyArray16ColumnMajor(array: Array16<number>): MutableMatrix44;
    /**
     * Creates a new MutableMatrix44 from a regular array in column-major order.
     * Only the first 16 elements are used if the array is larger.
     *
     * @param array - An array containing at least 16 elements in column-major order
     * @returns A new MutableMatrix44 instance with copied data
     */
    static fromCopyArrayColumnMajor(array: Array<number>): MutableMatrix44;
    /**
     * Creates a new MutableMatrix44 from an Array16 in row-major order.
     * The input data is converted from row-major to column-major order during creation.
     *
     * @param array - An Array16 containing 16 elements in row-major order
     * @returns A new MutableMatrix44 instance with data converted to column-major order
     */
    static fromCopyArray16RowMajor(array: Array16<number>): MutableMatrix44;
    /**
     * Creates a new MutableMatrix44 from a regular array in row-major order.
     * The input data is converted from row-major to column-major order during creation.
     * Only the first 16 elements are used if the array is larger.
     *
     * @param array - An array containing at least 16 elements in row-major order
     * @returns A new MutableMatrix44 instance with data converted to column-major order
     */
    static fromCopyArrayRowMajor(array: Array<number>): MutableMatrix44;
    /**
     * Creates a matrix from a quaternion.
     *
     * @param q - The quaternion to convert
     * @returns A new MutableMatrix44 instance representing the rotation
     */
    static fromCopyQuaternion(q: Quaternion): MutableMatrix44;
}

/**
 * Generic 4D vector class that serves as the base implementation for both 32-bit and 64-bit vector types.
 * This class provides immutable vector operations with support for different floating-point precisions.
 *
 * @template T - The typed array constructor type (Float32ArrayConstructor or Float64ArrayConstructor)
 * @internal This class is not intended for direct instantiation by users
 */
declare class Vector4_<T extends FloatTypedArrayConstructor> extends AbstractVector implements IVector4 {
    /**
     * Creates a new Vector4_ instance.
     *
     * @param v - The underlying typed array containing the vector components
     * @param options - Configuration object containing the array type constructor
     * @protected This constructor is protected to prevent direct instantiation
     */
    protected constructor(v: FloatTypedArray, _options: {
        type: T;
    });
    /**
     * Gets the X component of the vector.
     *
     * @returns The X component value
     */
    get x(): number;
    /**
     * Gets the Y component of the vector.
     *
     * @returns The Y component value
     */
    get y(): number;
    /**
     * Gets the Z component of the vector.
     *
     * @returns The Z component value
     */
    get z(): number;
    /**
     * Gets the W component of the vector.
     *
     * @returns The W component value
     */
    get w(): number;
    /**
     * Converts the vector to a GLSL vec4 string representation with float precision.
     *
     * @returns A GLSL-compatible vec4 string (e.g., "vec4(1.0, 2.0, 3.0, 4.0)")
     */
    get glslStrAsFloat(): string;
    /**
     * Converts the vector to a GLSL ivec4 string representation with integer values.
     *
     * @returns A GLSL-compatible ivec4 string (e.g., "ivec4(1, 2, 3, 4)")
     */
    get glslStrAsInt(): string;
    /**
     * Converts the vector to a WGSL vec4f string representation with float precision.
     *
     * @returns A WGSL-compatible vec4f string (e.g., "vec4f(1.0, 2.0, 3.0, 4.0)")
     */
    get wgslStrAsFloat(): string;
    /**
     * Converts the vector to a WGSL vec4i string representation with integer values.
     *
     * @returns A WGSL-compatible vec4i string (e.g., "vec4i(1, 2, 3, 4)")
     */
    get wgslStrAsInt(): string;
    /**
     * Creates a new vector from a 4-element array by copying the values.
     *
     * @param array - Array containing exactly 4 numeric values [x, y, z, w]
     * @param type - The typed array constructor to use for internal storage
     * @returns A new vector instance with the copied values
     * @static
     */
    static _fromCopyArray4(array: Array4<number>, type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Creates a new vector from individual component values.
     *
     * @param x - The X component value
     * @param y - The Y component value
     * @param z - The Z component value
     * @param w - The W component value
     * @param type - The typed array constructor to use for internal storage
     * @returns A new vector instance with the specified component values
     * @static
     */
    static _fromCopy4(x: number, y: number, z: number, w: number, type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Creates a new vector from an array by copying the first 4 values.
     * If the array has fewer than 4 elements, the remaining components will be undefined.
     *
     * @param array - Array containing numeric values (at least 4 elements recommended)
     * @param type - The typed array constructor to use for internal storage
     * @returns A new vector instance with the first 4 values from the array
     * @static
     */
    static _fromCopyArray(array: Array<number>, type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Creates a new vector by copying values from another Vector4.
     *
     * @param vec4 - The source Vector4 to copy from
     * @param type - The typed array constructor to use for internal storage
     * @returns A new vector instance with copied values from the source vector
     * @static
     */
    static _fromCopyVector4(vec4: IVector4, type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Creates a new Vector4 from a Vector3, setting the W component to 1.
     * This is commonly used for converting 3D positions to homogeneous coordinates.
     *
     * @param vec3 - The source Vector3 to copy from
     * @param type - The typed array constructor to use for internal storage
     * @returns A new Vector4 with (vec3.x, vec3.y, vec3.z, 1.0)
     * @static
     */
    static _fromCopyVector3(vec3: IVector3, type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Creates a new Vector4 from a Vector2, setting Z to 0 and W to 1.
     * This is commonly used for converting 2D positions to homogeneous coordinates.
     *
     * @param vec2 - The source Vector2 to copy from
     * @param type - The typed array constructor to use for internal storage
     * @returns A new Vector4 with (vec2.x, vec2.y, 0.0, 1.0)
     * @static
     */
    static _fromVector2(vec2: IVector2, type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Gets the composition type identifier for this vector type.
     *
     * @returns The CompositionType.Vec4 identifier
     * @static
     */
    static get compositionType(): {
        readonly __numberOfComponents: number;
        readonly __glslStr: string;
        readonly __hlslStr: string;
        readonly __webgpuStr: string;
        readonly __wgslStr: string;
        readonly __isArray: boolean;
        readonly __vec4SizeOfProperty: IndexOf16Bytes;
        readonly __dummyStr: "VEC4";
        readonly webgpu: string;
        readonly wgsl: string;
        getNumberOfComponents(): Count;
        getGlslStr(componentType: ComponentTypeEnum): string;
        getGlslInitialValue(componentType: ComponentTypeEnum): string;
        getWgslInitialValue(componentType: ComponentTypeEnum): string;
        toWGSLType(componentType: ComponentTypeEnum): string;
        getVec4SizeOfProperty(): IndexOf16Bytes;
        readonly index: number;
        readonly symbol: symbol;
        readonly str: string;
        toString(): string;
        toJSON(): number;
    };
    /**
     * Calculates the squared length (magnitude) of a vector.
     * This is more efficient than length() when only comparing magnitudes.
     *
     * @param vec - The vector to calculate squared length for
     * @returns The squared length of the vector
     * @static
     */
    static lengthSquared(vec: IVector4): number;
    /**
     * Calculates the distance between two vectors.
     *
     * @param l_vec - The first vector
     * @param r_vec - The second vector
     * @returns The distance between the two vectors
     * @static
     */
    static lengthBtw(l_vec: IVector4, r_vec: IVector4): number;
    /**
     * Creates a zero vector (0, 0, 0, 0).
     *
     * @param type - The typed array constructor to use for internal storage
     * @returns A new zero vector
     * @static
     */
    static _zero(type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Creates a vector with all components set to 1 (1, 1, 1, 1).
     *
     * @param type - The typed array constructor to use for internal storage
     * @returns A new vector with all components set to 1
     * @static
     */
    static _one(type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Creates a dummy vector with no components (empty array).
     * This is used as a placeholder when a vector is needed but not yet initialized.
     *
     * @param type - The typed array constructor to use for internal storage
     * @returns A new dummy vector with empty components
     * @static
     */
    static _dummy(type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Creates a normalized version of the given vector.
     * A normalized vector has a length of 1 while maintaining its direction.
     *
     * @param vec - The vector to normalize
     * @param type - The typed array constructor to use for internal storage
     * @returns A new normalized vector
     * @static
     */
    static _normalize(vec: IVector4, type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Adds two vectors component-wise and returns a new vector.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @param type - The typed array constructor to use for internal storage
     * @returns A new vector containing the sum (l_vec + r_vec)
     * @static
     */
    static _add(l_vec: IVector4, r_vec: IVector4, type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Adds two vectors component-wise and stores the result in the output vector.
     * This method modifies the output vector in-place for better performance.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @param out - The output vector to store the result (will be modified)
     * @returns The modified output vector containing the sum
     * @static
     */
    static addTo(l_vec: IVector4, r_vec: IVector4, out: IMutableVector4): IMutableVector4;
    /**
     * Subtracts the right vector from the left vector component-wise and returns a new vector.
     *
     * @param l_vec - The left operand vector (minuend)
     * @param r_vec - The right operand vector (subtrahend)
     * @param type - The typed array constructor to use for internal storage
     * @returns A new vector containing the difference (l_vec - r_vec)
     * @static
     */
    static _subtract(l_vec: IVector4, r_vec: IVector4, type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Subtracts the right vector from the left vector component-wise and stores the result in the output vector.
     * This method modifies the output vector in-place for better performance.
     *
     * @param l_vec - The left operand vector (minuend)
     * @param r_vec - The right operand vector (subtrahend)
     * @param out - The output vector to store the result (will be modified)
     * @returns The modified output vector containing the difference
     * @static
     */
    static subtractTo(l_vec: IVector4, r_vec: IVector4, out: IMutableVector4): IMutableVector4;
    /**
     * Multiplies a vector by a scalar value and returns a new vector.
     * This operation scales the vector while preserving its direction.
     *
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @param type - The typed array constructor to use for internal storage
     * @returns A new vector with each component multiplied by the scalar
     * @static
     */
    static _multiply(vec: IVector4, value: number, type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Multiplies a vector by a scalar value and stores the result in the output vector.
     * This method modifies the output vector in-place for better performance.
     *
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @param out - The output vector to store the result (will be modified)
     * @returns The modified output vector with each component multiplied by the scalar
     * @static
     */
    static multiplyTo(vec: IVector4, value: number, out: IMutableVector4): IMutableVector4;
    /**
     * Multiplies two vectors component-wise and returns a new vector.
     * This is also known as the Hadamard product or element-wise multiplication.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @param type - The typed array constructor to use for internal storage
     * @returns A new vector with each component being the product of corresponding components
     * @static
     */
    static _multiplyVector(l_vec: IVector4, r_vec: IVector4, type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Multiplies two vectors component-wise and stores the result in the output vector.
     * This method modifies the output vector in-place for better performance.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @param out - The output vector to store the result (will be modified)
     * @returns The modified output vector with component-wise multiplication result
     * @static
     */
    static multiplyVectorTo(l_vec: IVector4, r_vec: IVector4, out: IMutableVector4): IMutableVector4;
    /**
     * Divides a vector by a scalar value and returns a new vector.
     * If the divisor is zero, the result components will be set to Infinity and an error will be logged.
     *
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @param type - The typed array constructor to use for internal storage
     * @returns A new vector with each component divided by the scalar
     * @static
     */
    static _divide(vec: IVector4, value: number, type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Divides a vector by a scalar value and stores the result in the output vector.
     * If the divisor is zero, the result components will be set to Infinity and an error will be logged.
     * This method modifies the output vector in-place for better performance.
     *
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @param out - The output vector to store the result (will be modified)
     * @returns The modified output vector with each component divided by the scalar
     * @static
     */
    static divideTo(vec: IVector4, value: number, out: IMutableVector4): IMutableVector4;
    /**
     * Divides the left vector by the right vector component-wise and returns a new vector.
     * If any component of the right vector is zero, the corresponding result component will be set to Infinity.
     *
     * @param l_vec - The left operand vector (dividend)
     * @param r_vec - The right operand vector (divisor)
     * @param type - The typed array constructor to use for internal storage
     * @returns A new vector with component-wise division result
     * @static
     */
    static _divideVector(l_vec: IVector4, r_vec: IVector4, type: FloatTypedArrayConstructor): Vector4_<FloatTypedArrayConstructor>;
    /**
     * Divides the left vector by the right vector component-wise and stores the result in the output vector.
     * If any component of the right vector is zero, the corresponding result component will be set to Infinity.
     * This method modifies the output vector in-place for better performance.
     *
     * @param l_vec - The left operand vector (dividend)
     * @param r_vec - The right operand vector (divisor)
     * @param out - The output vector to store the result (will be modified)
     * @returns The modified output vector with component-wise division result
     * @static
     */
    static divideVectorTo(l_vec: IVector4, r_vec: IVector4, out: IMutableVector4): IMutableVector4;
    /**
     * Calculates the dot product of two vectors.
     * The dot product is the sum of the products of corresponding components.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns The dot product of the two vectors
     * @static
     */
    static dot(l_vec: IVector4, r_vec: IVector4): number;
    /**
     * Converts the vector to a string representation in the format "(x, y, z, w)".
     *
     * @returns A string representation of the vector
     */
    toString(): string;
    /**
     * Converts the vector to an approximately formatted string representation with financial precision.
     * Each component is formatted to a fixed number of decimal places.
     *
     * @returns A string with space-separated components followed by a newline
     */
    toStringApproximately(): string;
    /**
     * Converts the vector to a flat array representation.
     *
     * @returns An array containing the vector components [x, y, z, w]
     */
    flattenAsArray(): number[];
    /**
     * Checks if this vector is a dummy vector (has no components).
     *
     * @returns True if the vector has no components, false otherwise
     */
    isDummy(): boolean;
    /**
     * Checks if this vector is approximately equal to another vector within a specified tolerance.
     *
     * @param vec - The vector to compare with
     * @param delta - The tolerance value for comparison (default: Number.EPSILON)
     * @returns True if the vectors are approximately equal, false otherwise
     */
    isEqual(vec: IVector4, delta?: number): boolean;
    /**
     * Checks if this vector is strictly equal to another vector (exact component equality).
     *
     * @param vec - The vector to compare with
     * @returns True if all components are exactly equal, false otherwise
     */
    isStrictEqual(vec: IVector4): boolean;
    /**
     * Gets the component value at the specified index.
     *
     * @param i - The index (0=x, 1=y, 2=z, 3=w)
     * @returns The component value at the specified index
     */
    at(i: number): number;
    /**
     * Calculates the length (magnitude) of the vector using the Euclidean norm.
     *
     * @returns The length of the vector
     */
    length(): number;
    /**
     * Calculates the squared length (magnitude) of the vector.
     * This is more efficient than length() when only comparing magnitudes.
     *
     * @returns The squared length of the vector
     */
    lengthSquared(): number;
    /**
     * Calculates the distance from this vector to another vector.
     *
     * @param vec - The target vector to calculate distance to
     * @returns The distance between the two vectors
     */
    lengthTo(vec: IVector4): number;
    /**
     * Calculates the dot product between this vector and another vector.
     * The dot product is the sum of the products of corresponding components.
     *
     * @param vec - The vector to calculate dot product with
     * @returns The dot product of the two vectors
     */
    dot(vec: IVector4): number;
    /**
     * Gets the class name of this vector type.
     *
     * @returns The string "Vector4"
     */
    get className(): string;
    /**
     * Creates a deep copy of this vector.
     *
     * @returns A new vector instance with the same component values
     */
    clone(): any;
    /**
     * Gets the number of bytes per component in the underlying typed array.
     *
     * @returns The number of bytes per element (4 for Float32Array, 8 for Float64Array)
     */
    get bytesPerComponent(): number;
}
/**
 * Immutable 4D(x,y,z,w) Vector class with 32-bit float components.
 *
 * This class provides comprehensive vector operations for 4-dimensional mathematics,
 * commonly used in graphics programming for representing positions, directions,
 * colors (RGBA), and homogeneous coordinates.
 *
 * All operations return new vector instances, preserving immutability.
 * For performance-critical applications where mutation is acceptable,
 * consider using the corresponding mutable vector types or the *To methods.
 *
 * @example Basic usage:
 * ```typescript
 * const vec1 = Vector4.fromCopy4(1, 2, 3, 1);
 * const vec2 = Vector4.fromCopyArray4([2, 3, 3, 1]);
 * const dotProduct = vec1.dot(vec2);
 * const sum = Vector4.add(vec1, vec2);
 * ```
 *
 * @example Creating vectors from different sources:
 * ```typescript
 * const fromArray = Vector4.fromCopyArray([1, 2, 3, 4, 5]); // Takes first 4 elements
 * const fromVec3 = Vector4.fromCopyVector3(someVector3); // W component set to 1
 * const zero = Vector4.zero();
 * const normalized = Vector4.normalize(someVector);
 * ```
 */
declare class Vector4 extends Vector4_<Float32ArrayConstructor> {
    /**
     * Creates a new Vector4 instance from a Float32Array.
     *
     * @param x - The Float32Array containing vector components
     */
    constructor(x: Float32Array);
    /**
     * Creates a new Vector4 by copying values from an array.
     * Takes the first 4 elements from the array. If the array has fewer than 4 elements,
     * the remaining components will be undefined.
     *
     * @param array - Array containing numeric values (at least 4 elements recommended)
     * @returns A new Vector4 instance with copied values
     * @static
     */
    static fromCopyArray(array: Array<number>): Vector4;
    /**
     * Creates a new Vector4 from a 4-element array by copying the values.
     *
     * @param array - Array containing exactly 4 numeric values [x, y, z, w]
     * @returns A new Vector4 instance with the copied values
     * @static
     */
    static fromCopyArray4(array: Array4<number>): Vector4;
    /**
     * Creates a new Vector4 from individual component values.
     *
     * @param x - The X component value
     * @param y - The Y component value
     * @param z - The Z component value
     * @param w - The W component value
     * @returns A new Vector4 instance with the specified component values
     * @static
     */
    static fromCopy4(x: number, y: number, z: number, w: number): Vector4;
    /**
     * Creates a new Vector4 from a Vector3, setting the W component to 1.
     * This is commonly used for converting 3D positions to homogeneous coordinates.
     *
     * @param vec3 - The source Vector3 to copy from
     * @returns A new Vector4 with (vec3.x, vec3.y, vec3.z, 1.0)
     * @static
     */
    static fromCopyVector3(vec3: IVector3): Vector4;
    /**
     * Creates a new Vector4 by copying values from another Vector4.
     *
     * @param vec4 - The source Vector4 to copy from
     * @returns A new Vector4 instance with copied values from the source vector
     * @static
     */
    static fromCopyVector4(vec4: IVector4): Vector4;
    /**
     * Creates a new Vector4 from an ArrayBuffer.
     * The ArrayBuffer should contain at least 16 bytes (4 float32 values).
     *
     * @param arrayBuffer - The ArrayBuffer containing vector data
     * @returns A new Vector4 instance using the ArrayBuffer data
     * @static
     */
    static fromArrayBuffer(arrayBuffer: ArrayBuffer): Vector4;
    /**
     * Creates a new Vector4 from a Float32Array.
     * The Float32Array is used directly without copying.
     *
     * @param float32Array - The Float32Array containing vector components
     * @returns A new Vector4 instance using the provided Float32Array
     * @static
     */
    static fromFloat32Array(float32Array: Float32Array): Vector4;
    /**
     * Creates a new Vector4 by copying from a Float32Array.
     * This creates a new Float32Array copy of the input data.
     *
     * @param float32Array - The Float32Array to copy from
     * @returns A new Vector4 instance with copied Float32Array data
     * @static
     */
    static fromCopyFloat32Array(float32Array: Float32Array): Vector4;
    /**
     * Creates a zero vector (0, 0, 0, 0).
     *
     * @returns A new Vector4 with all components set to zero
     * @static
     */
    static zero(): Vector4;
    /**
     * Creates a vector with all components set to 1 (1, 1, 1, 1).
     *
     * @returns A new Vector4 with all components set to 1
     * @static
     */
    static one(): Vector4;
    /**
     * Creates a dummy vector with no components (empty array).
     * This is used as a placeholder when a vector is needed but not yet initialized.
     *
     * @returns A new dummy Vector4 with empty components
     * @static
     */
    static dummy(): Vector4;
    /**
     * Creates a normalized version of the given vector.
     * A normalized vector has a length of 1 while maintaining its direction.
     *
     * @param vec - The vector to normalize
     * @returns A new normalized Vector4
     * @static
     */
    static normalize(vec: IVector4): Vector4;
    /**
     * Adds two vectors component-wise and returns a new vector.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new Vector4 containing the sum (l_vec + r_vec)
     * @static
     */
    static add(l_vec: IVector4, r_vec: IVector4): Vector4;
    /**
     * Subtracts the right vector from the left vector component-wise and returns a new vector.
     *
     * @param l_vec - The left operand vector (minuend)
     * @param r_vec - The right operand vector (subtrahend)
     * @returns A new Vector4 containing the difference (l_vec - r_vec)
     * @static
     */
    static subtract(l_vec: IVector4, r_vec: IVector4): Vector4;
    /**
     * Multiplies a vector by a scalar value and returns a new vector.
     * This operation scales the vector while preserving its direction.
     *
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @returns A new Vector4 with each component multiplied by the scalar
     * @static
     */
    static multiply(vec: IVector4, value: number): Vector4;
    /**
     * Multiplies two vectors component-wise and returns a new vector.
     * This is also known as the Hadamard product or element-wise multiplication.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new Vector4 with each component being the product of corresponding components
     * @static
     */
    static multiplyVector(l_vec: IVector4, r_vec: IVector4): Vector4;
    /**
     * Divides a vector by a scalar value and returns a new vector.
     * If the divisor is zero, the result components will be set to Infinity and an error will be logged.
     *
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @returns A new Vector4 with each component divided by the scalar
     * @static
     */
    static divide(vec: IVector4, value: number): Vector4;
    /**
     * Divides the left vector by the right vector component-wise and returns a new vector.
     * If any component of the right vector is zero, the corresponding result component will be set to Infinity.
     *
     * @param l_vec - The left operand vector (dividend)
     * @param r_vec - The right operand vector (divisor)
     * @returns A new Vector4 with component-wise division result
     * @static
     */
    static divideVector(l_vec: IVector4, r_vec: IVector4): Vector4;
    /**
     * Creates a deep copy of this vector.
     *
     * @returns A new Vector4 instance with the same component values
     */
    clone(): Vector4;
}
/**
 * Immutable 4D(x,y,z,w) Vector class with 64-bit float components.
 *
 * This class provides the same functionality as Vector4 but with double precision
 * floating-point components. Use this when higher precision is required for
 * mathematical calculations or when working with very large or very small numbers.
 *
 * @example Basic usage:
 * ```typescript
 * const vec1 = Vector4d.fromCopy4(1.0, 2.0, 3.0, 1.0);
 * const vec2 = Vector4d.fromCopyArray4([2.0, 3.0, 3.0, 1.0]);
 * const dotProduct = vec1.dot(vec2);
 * const sum = Vector4d.add(vec1, vec2);
 * ```
 */
declare class Vector4d extends Vector4_<Float64ArrayConstructor> {
    /**
     * Creates a new Vector4d instance from a Float64Array.
     *
     * @param x - The Float64Array containing vector components
     * @private This constructor is private to prevent direct instantiation
     */
    private constructor();
    /**
     * Creates a new Vector4d from a 4-element array by copying the values.
     *
     * @param array - Array containing exactly 4 numeric values [x, y, z, w]
     * @returns A new Vector4d instance with the copied values
     * @static
     */
    static fromCopyArray4(array: Array4<number>): Vector4d;
    /**
     * Creates a new Vector4d from individual component values.
     *
     * @param x - The X component value
     * @param y - The Y component value
     * @param z - The Z component value
     * @param w - The W component value
     * @returns A new Vector4d instance with the specified component values
     * @static
     */
    static fromCopy4(x: number, y: number, z: number, w: number): Vector4d;
    /**
     * Creates a new Vector4d by copying values from an array.
     * Takes the first 4 elements from the array. If the array has fewer than 4 elements,
     * the remaining components will be undefined.
     *
     * @param array - Array containing numeric values (at least 4 elements recommended)
     * @returns A new Vector4d instance with copied values
     * @static
     */
    static fromCopyArray(array: Array4<number>): Vector4d;
    /**
     * Creates a new Vector4d from an ArrayBuffer.
     * The ArrayBuffer should contain at least 32 bytes (4 float64 values).
     *
     * @param arrayBuffer - The ArrayBuffer containing vector data
     * @returns A new Vector4d instance using the ArrayBuffer data
     * @static
     */
    static fromArrayBuffer(arrayBuffer: ArrayBuffer): Vector4d;
    /**
     * Creates a new Vector4d from a Float64Array.
     * The Float64Array is used directly without copying.
     *
     * @param float64Array - The Float64Array containing vector components
     * @returns A new Vector4d instance using the provided Float64Array
     * @static
     */
    static fromFloat64Array(float64Array: Float64Array): Vector4d;
    /**
     * Creates a zero vector (0, 0, 0, 0).
     *
     * @returns A new Vector4d with all components set to zero
     * @static
     */
    static zero(): Vector4d;
    /**
     * Creates a vector with all components set to 1 (1, 1, 1, 1).
     *
     * @returns A new Vector4d with all components set to 1
     * @static
     */
    static one(): Vector4d;
    /**
     * Creates a dummy vector with no components (empty array).
     * This is used as a placeholder when a vector is needed but not yet initialized.
     *
     * @returns A new dummy Vector4d with empty components
     * @static
     */
    static dummy(): Vector4d;
    /**
     * Creates a normalized version of the given vector.
     * A normalized vector has a length of 1 while maintaining its direction.
     *
     * @param vec - The vector to normalize
     * @returns A new normalized Vector4d
     * @static
     */
    static normalize(vec: IVector4): Vector4d;
    /**
     * Adds two vectors component-wise and returns a new vector.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new Vector4d containing the sum (l_vec + r_vec)
     * @static
     */
    static add(l_vec: IVector4, r_vec: IVector4): Vector4d;
    /**
     * Subtracts the right vector from the left vector component-wise and returns a new vector.
     *
     * @param l_vec - The left operand vector (minuend)
     * @param r_vec - The right operand vector (subtrahend)
     * @returns A new Vector4d containing the difference (l_vec - r_vec)
     * @static
     */
    static subtract(l_vec: IVector4, r_vec: IVector4): Vector4d;
    /**
     * Multiplies a vector by a scalar value and returns a new vector.
     * This operation scales the vector while preserving its direction.
     *
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @returns A new Vector4d with each component multiplied by the scalar
     * @static
     */
    static multiply(vec: IVector4, value: number): Vector4d;
    /**
     * Multiplies two vectors component-wise and returns a new vector.
     * This is also known as the Hadamard product or element-wise multiplication.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new Vector4d with each component being the product of corresponding components
     * @static
     */
    static multiplyVector(l_vec: IVector4, r_vec: IVector4): Vector4d;
    /**
     * Divides a vector by a scalar value and returns a new vector.
     * If the divisor is zero, the result components will be set to Infinity and an error will be logged.
     *
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @returns A new Vector4d with each component divided by the scalar
     * @static
     */
    static divide(vec: IVector4, value: number): Vector4d;
    /**
     * Divides the left vector by the right vector component-wise and returns a new vector.
     * If any component of the right vector is zero, the corresponding result component will be set to Infinity.
     *
     * @param l_vec - The left operand vector (dividend)
     * @param r_vec - The right operand vector (divisor)
     * @returns A new Vector4d with component-wise division result
     * @static
     */
    static divideVector(l_vec: IVector4, r_vec: IVector4): Vector4d;
    /**
     * Creates a deep copy of this vector.
     *
     * @returns A new Vector4d instance with the same component values
     */
    clone(): Vector4d;
}
/**
 * Type alias for Vector4 to provide a consistent naming convention.
 * Vector4f explicitly indicates 32-bit float precision.
 */
type Vector4f = Vector4;
/**
 * Constant Vector4 with all components set to 1 (1, 1, 1, 1).
 * Useful for initialization and mathematical operations.
 */
declare const ConstVector4_1_1_1_1: Vector4;
/**
 * Constant Vector4 representing a homogeneous coordinate with W=1 (0, 0, 0, 1).
 * Commonly used for representing positions in homogeneous coordinates.
 */
declare const ConstVector4_0_0_0_1: Vector4;
/**
 * Constant Vector4 with all components set to 0 (0, 0, 0, 0).
 * Represents the zero vector or null vector.
 */
declare const ConstVector4_0_0_0_0: Vector4;

/**
 * Base class for mutable 4D vectors with generic typed array support.
 * Extends Vector4_ to provide mutability capabilities for x, y, z, and w components.
 *
 * @template T - The typed array constructor type (Float32Array or Float64Array)
 * @internal
 */
declare class MutableVector4_<T extends FloatTypedArrayConstructor> extends Vector4_<T> implements IMutableVector, IMutableVector4 {
    /**
     * Creates a new MutableVector4_ instance.
     *
     * @param x - The typed array containing vector components
     * @param type - Object containing the typed array constructor
     */
    constructor(x: FloatTypedArray, { type }: {
        type: T;
    });
    /**
     * Sets the x component of the vector.
     * Automatically increments the update counter for change tracking.
     */
    set x(x: number);
    /**
     * Gets the x component of the vector.
     * @returns The x component value
     */
    get x(): number;
    /**
     * Sets the y component of the vector.
     * Automatically increments the update counter for change tracking.
     */
    set y(y: number);
    /**
     * Gets the y component of the vector.
     * @returns The y component value
     */
    get y(): number;
    /**
     * Sets the z component of the vector.
     * Automatically increments the update counter for change tracking.
     */
    set z(z: number);
    /**
     * Gets the z component of the vector.
     * @returns The z component value
     */
    get z(): number;
    /**
     * Sets the w component of the vector.
     * Automatically increments the update counter for change tracking.
     */
    set w(w: number);
    /**
     * Gets the w component of the vector.
     * @returns The w component value
     */
    get w(): number;
    /**
     * Gets the raw typed array containing the vector components.
     *
     * @returns The underlying typed array [x, y, z, w]
     */
    raw(): TypedArray;
    /**
     * Sets the value at the specified index.
     *
     * @param i - The index (0-3) to set
     * @param value - The value to set at the index
     * @returns This vector instance for method chaining
     */
    setAt(i: number, value: number): this;
    /**
     * Sets all four components of the vector.
     *
     * @param x - The x component value
     * @param y - The y component value
     * @param z - The z component value
     * @param w - The w component value
     * @returns This vector instance for method chaining
     */
    setComponents(x: number, y: number, z: number, w: number): this;
    /**
     * Copies components from another vector to this vector.
     *
     * @param vec - The source vector to copy from
     * @returns This vector instance for method chaining
     */
    copyComponents(vec: IVector4): this;
    /**
     * Sets all components to zero.
     *
     * @returns This vector instance for method chaining
     */
    zero(): this;
    /**
     * Sets all components to one.
     *
     * @returns This vector instance for method chaining
     */
    one(): this;
    /**
     * Gets the number of bytes per component in the underlying typed array.
     *
     * @returns The byte size per component (4 for Float32Array, 8 for Float64Array)
     */
    get bytesPerComponent(): number;
    /**
     * Normalizes the vector to unit length.
     * Modifies this vector in place.
     *
     * @returns This vector instance for method chaining
     */
    normalize(): this;
    /**
     * Normalizes only the x, y, z components (treating as 3D vector).
     * The w component is divided by the same length factor.
     *
     * @returns This vector instance for method chaining
     */
    normalize3(): this;
    /**
     * Adds another vector to this vector component-wise.
     *
     * @param vec - The vector to add
     * @returns This vector instance for method chaining
     */
    add(vec: IVector4): this;
    /**
     * Subtracts another vector from this vector component-wise.
     *
     * @param vec - The vector to subtract
     * @returns This vector instance for method chaining
     */
    subtract(vec: IVector4): this;
    /**
     * Multiplies this vector by a scalar value.
     *
     * @param value - The scalar value to multiply by
     * @returns This vector instance for method chaining
     */
    multiply(value: number): this;
    /**
     * Multiplies this vector by another vector component-wise.
     *
     * @param vec - The vector to multiply by
     * @returns This vector instance for method chaining
     */
    multiplyVector(vec: IVector4): this;
    /**
     * Divides this vector by a scalar value.
     * If the value is zero, sets components to Infinity and logs an error.
     *
     * @param value - The scalar value to divide by
     * @returns This vector instance for method chaining
     */
    divide(value: number): this;
    /**
     * Divides this vector by another vector component-wise.
     * If any component of the divisor is zero, sets the corresponding result to Infinity.
     *
     * @param vec - The vector to divide by
     * @returns This vector instance for method chaining
     */
    divideVector(vec: IVector4): this;
    /**
     * Gets the update counter value.
     * This counter is incremented whenever the vector is modified.
     *
     * @returns The current update count
     */
    get _updateCount(): number;
    private __updateCount;
}
/**
 * Mutable 4D vector class with 32-bit float components.
 * Provides methods for vector operations that modify the vector in place,
 * as well as static factory methods for creating new vectors.
 */
declare class MutableVector4 extends MutableVector4_<Float32ArrayConstructor> {
    /**
     * Creates a new MutableVector4 instance.
     *
     * @param x - Float32Array containing the vector components [x, y, z, w]
     */
    constructor(x: Float32Array);
    /**
     * Creates a new MutableVector4 from an array of numbers.
     * Takes up to 4 elements from the array.
     *
     * @param array - Array of numbers to copy from
     * @returns A new MutableVector4 instance
     */
    static fromCopyArray(array: Array<number>): MutableVector4;
    /**
     * Creates a new MutableVector4 from a 4-element array.
     *
     * @param array - Array of exactly 4 numbers [x, y, z, w]
     * @returns A new MutableVector4 instance
     */
    static fromCopyArray4(array: Array4<number>): MutableVector4;
    /**
     * Creates a new MutableVector4 from individual component values.
     *
     * @param x - The x component
     * @param y - The y component
     * @param z - The z component
     * @param w - The w component
     * @returns A new MutableVector4 instance
     */
    static fromCopy4(x: number, y: number, z: number, w: number): MutableVector4;
    /**
     * Creates a zero vector (0, 0, 0, 0).
     *
     * @returns A new MutableVector4 with all components set to 0
     */
    static zero(): MutableVector4;
    /**
     * Creates a vector with all components set to 1 (1, 1, 1, 1).
     *
     * @returns A new MutableVector4 with all components set to 1
     */
    static one(): MutableVector4;
    /**
     * Creates a dummy vector for placeholder purposes.
     *
     * @returns A new MutableVector4 dummy instance
     */
    static dummy(): MutableVector4;
    /**
     * Creates a normalized copy of the given vector.
     *
     * @param vec - The vector to normalize
     * @returns A new normalized MutableVector4
     */
    static normalize(vec: IVector4): MutableVector4;
    /**
     * Creates a new vector by adding two vectors component-wise.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new MutableVector4 containing the sum
     */
    static add(l_vec: IVector4, r_vec: IVector4): MutableVector4;
    /**
     * Creates a new vector by subtracting the second vector from the first.
     *
     * @param l_vec - The vector to subtract from
     * @param r_vec - The vector to subtract
     * @returns A new MutableVector4 containing the difference
     */
    static subtract(l_vec: IVector4, r_vec: IVector4): MutableVector4;
    /**
     * Creates a new vector by multiplying a vector by a scalar.
     *
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @returns A new MutableVector4 containing the scaled vector
     */
    static multiply(vec: IVector4, value: number): MutableVector4;
    /**
     * Creates a new vector by multiplying two vectors component-wise.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new MutableVector4 containing the component-wise product
     */
    static multiplyVector(l_vec: IVector4, r_vec: IVector4): MutableVector4;
    /**
     * Creates a new vector by dividing a vector by a scalar.
     *
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @returns A new MutableVector4 containing the divided vector
     */
    static divide(vec: IVector4, value: number): MutableVector4;
    /**
     * Creates a new vector by dividing two vectors component-wise.
     *
     * @param l_vec - The dividend vector
     * @param r_vec - The divisor vector
     * @returns A new MutableVector4 containing the component-wise quotient
     */
    static divideVector(l_vec: IVector4, r_vec: IVector4): MutableVector4;
    /**
     * Gets the class name for debugging and identification purposes.
     *
     * @returns The string 'MutableVector4'
     */
    get className(): string;
    /**
     * Creates a deep copy of this vector.
     *
     * @returns A new MutableVector4 instance with copied values
     */
    clone(): any;
}
/**
 * Mutable 4D vector class with 64-bit float components.
 * Provides higher precision arithmetic compared to MutableVector4.
 */
declare class MutableVector4d extends MutableVector4_<Float64ArrayConstructor> {
    /**
     * Creates a new MutableVector4d instance.
     *
     * @param x - Float64Array containing the vector components [x, y, z, w]
     */
    constructor(x: Float64Array);
    /**
     * Creates a zero vector (0, 0, 0, 0) with 64-bit precision.
     *
     * @returns A new MutableVector4d with all components set to 0
     */
    static zero(): MutableVector4d;
    /**
     * Creates a vector with all components set to 1 (1, 1, 1, 1) with 64-bit precision.
     *
     * @returns A new MutableVector4d with all components set to 1
     */
    static one(): MutableVector4d;
    /**
     * Creates a dummy vector for placeholder purposes with 64-bit precision.
     *
     * @returns A new MutableVector4d dummy instance
     */
    static dummy(): MutableVector4d;
    /**
     * Creates a normalized copy of the given vector with 64-bit precision.
     *
     * @param vec - The vector to normalize
     * @returns A new normalized MutableVector4d
     */
    static normalize(vec: IVector4): MutableVector4d;
    /**
     * Creates a new vector by adding two vectors component-wise with 64-bit precision.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new MutableVector4d containing the sum
     */
    static add(l_vec: IVector4, r_vec: IVector4): MutableVector4d;
    /**
     * Creates a new vector by subtracting the second vector from the first with 64-bit precision.
     *
     * @param l_vec - The vector to subtract from
     * @param r_vec - The vector to subtract
     * @returns A new MutableVector4d containing the difference
     */
    static subtract(l_vec: IVector4, r_vec: IVector4): MutableVector4d;
    /**
     * Creates a new vector by multiplying a vector by a scalar with 64-bit precision.
     *
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @returns A new MutableVector4d containing the scaled vector
     */
    static multiply(vec: IVector4, value: number): MutableVector4d;
    /**
     * Creates a new vector by multiplying two vectors component-wise with 64-bit precision.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new MutableVector4d containing the component-wise product
     */
    static multiplyVector(l_vec: IVector4, r_vec: IVector4): MutableVector4d;
    /**
     * Creates a new vector by dividing a vector by a scalar with 64-bit precision.
     *
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @returns A new MutableVector4d containing the divided vector
     */
    static divide(vec: IVector4, value: number): MutableVector4d;
    /**
     * Creates a new vector by dividing two vectors component-wise with 64-bit precision.
     *
     * @param l_vec - The dividend vector
     * @param r_vec - The divisor vector
     * @returns A new MutableVector4d containing the component-wise quotient
     */
    static divideVector(l_vec: IVector4, r_vec: IVector4): MutableVector4d;
    /**
     * Creates a new MutableVector4d from a 4-element array with 64-bit precision.
     *
     * @param array - Array of exactly 4 numbers [x, y, z, w]
     * @returns A new MutableVector4d instance
     */
    static fromCopyArray4(array: Array4<number>): MutableVector4d;
    /**
     * Creates a new MutableVector4d from an array of numbers with 64-bit precision.
     * Takes up to 4 elements from the array.
     *
     * @param array - Array of numbers to copy from
     * @returns A new MutableVector4d instance
     */
    static fromCopyArray(array: Array<number>): MutableVector4d;
    /**
     * Creates a new MutableVector4d from individual component values with 64-bit precision.
     *
     * @param x - The x component
     * @param y - The y component
     * @param z - The z component
     * @param w - The w component
     * @returns A new MutableVector4d instance
     */
    static fromCopy4(x: number, y: number, z: number, w: number): MutableVector4d;
    /**
     * Creates a deep copy of this vector with 64-bit precision.
     *
     * @returns A new MutableVector4d instance with copied values
     */
    clone(): MutableVector4d;
}
/**
 * Type alias for MutableVector4 to indicate 32-bit float precision.
 */
type MutableVector4f = MutableVector4;

/**
 * Represents a 4x4 matrix stored in column-major order (OpenGL/WebGL style).
 * This class provides immutable matrix operations and is used for 3D transformations
 * including translation, rotation, and scaling.
 *
 * @example
 * ```typescript
 * const identity = Matrix44.identity();
 * const translation = Matrix44.translate(Vector3.fromCopyArray([1, 2, 3]));
 * const result = Matrix44.multiply(identity, translation);
 * ```
 */
declare class Matrix44 extends AbstractMatrix implements IMatrix, IMatrix44 {
    /**
     * Creates a new Matrix44 instance.
     * @param m - A Float32Array containing 16 matrix elements in column-major order
     */
    constructor(m: Float32Array);
    /**
     * Gets the matrix element at row 0, column 0.
     * @returns The m00 component of the matrix
     */
    get m00(): number;
    /**
     * Gets the matrix element at row 1, column 0.
     * @returns The m10 component of the matrix
     */
    get m10(): number;
    /**
     * Gets the matrix element at row 2, column 0.
     * @returns The m20 component of the matrix
     */
    get m20(): number;
    /**
     * Gets the matrix element at row 3, column 0.
     * @returns The m30 component of the matrix
     */
    get m30(): number;
    /**
     * Gets the matrix element at row 0, column 1.
     * @returns The m01 component of the matrix
     */
    get m01(): number;
    /**
     * Gets the matrix element at row 1, column 1.
     * @returns The m11 component of the matrix
     */
    get m11(): number;
    /**
     * Gets the matrix element at row 2, column 1.
     * @returns The m21 component of the matrix
     */
    get m21(): number;
    /**
     * Gets the matrix element at row 3, column 1.
     * @returns The m31 component of the matrix
     */
    get m31(): number;
    /**
     * Gets the matrix element at row 0, column 2.
     * @returns The m02 component of the matrix
     */
    get m02(): number;
    /**
     * Gets the matrix element at row 1, column 2.
     * @returns The m12 component of the matrix
     */
    get m12(): number;
    /**
     * Gets the matrix element at row 2, column 2.
     * @returns The m22 component of the matrix
     */
    get m22(): number;
    /**
     * Gets the matrix element at row 3, column 2.
     * @returns The m32 component of the matrix
     */
    get m32(): number;
    /**
     * Gets the matrix element at row 0, column 3.
     * @returns The m03 component of the matrix
     */
    get m03(): number;
    /**
     * Gets the matrix element at row 1, column 3.
     * @returns The m13 component of the matrix
     */
    get m13(): number;
    /**
     * Gets the matrix element at row 2, column 3.
     * @returns The m23 component of the matrix
     */
    get m23(): number;
    /**
     * Gets the matrix element at row 3, column 3.
     * @returns The m33 component of the matrix
     */
    get m33(): number;
    /**
     * Gets the X component of the translation vector from this matrix.
     * @returns The X translation value
     */
    get translateX(): number;
    /**
     * Gets the Y component of the translation vector from this matrix.
     * @returns The Y translation value
     */
    get translateY(): number;
    /**
     * Gets the Z component of the translation vector from this matrix.
     * @returns The Z translation value
     */
    get translateZ(): number;
    /**
     * Gets the composition type for this matrix class.
     * @returns The composition type enum value
     */
    static get compositionType(): {
        readonly __numberOfComponents: number;
        readonly __glslStr: string;
        readonly __hlslStr: string;
        readonly __webgpuStr: string;
        readonly __wgslStr: string;
        readonly __isArray: boolean;
        readonly __vec4SizeOfProperty: IndexOf16Bytes;
        readonly __dummyStr: "MAT4";
        readonly webgpu: string;
        readonly wgsl: string;
        getNumberOfComponents(): Count;
        getGlslStr(componentType: ComponentTypeEnum): string;
        getGlslInitialValue(componentType: ComponentTypeEnum): string;
        getWgslInitialValue(componentType: ComponentTypeEnum): string;
        toWGSLType(componentType: ComponentTypeEnum): string;
        getVec4SizeOfProperty(): IndexOf16Bytes;
        readonly index: number;
        readonly symbol: symbol;
        readonly str: string;
        toString(): string;
        toJSON(): number;
    };
    /**
     * Converts the matrix to a GLSL mat4 string representation with float precision.
     * @returns A GLSL-compatible string representation of the matrix
     */
    get glslStrAsFloat(): string;
    /**
     * Converts the matrix to a GLSL mat4 string representation with integer values.
     * @returns A GLSL-compatible string representation of the matrix with integer values
     */
    get glslStrAsInt(): string;
    /**
     * Converts the matrix to a WGSL mat4x4f string representation with float precision.
     * @returns A WGSL-compatible string representation of the matrix
     */
    get wgslStrAsFloat(): string;
    /**
     * Converts the matrix to a WGSL mat4x4i string representation with integer values.
     * @returns A WGSL-compatible string representation of the matrix with integer values
     */
    get wgslStrAsInt(): string;
    /**
     * Creates a zero matrix (all elements are 0).
     * @returns A new Matrix44 instance with all elements set to 0
     */
    static zero(): Matrix44;
    /**
     * Creates a 4x4 identity matrix.
     * @returns A new IdentityMatrix44 instance representing the identity matrix
     */
    static identity(): IdentityMatrix44;
    /**
     * Creates a dummy matrix with zero-length array (for placeholder purposes).
     * @returns A new Matrix44 instance with an empty array
     */
    static dummy(): Matrix44;
    /**
     * Creates a transpose matrix from the given matrix.
     * For identity matrices, returns the same matrix since transpose of identity is identity.
     * @param mat - The matrix to transpose
     * @returns A new Matrix44 instance representing the transposed matrix
     */
    static transpose(mat: IMatrix44): IMatrix44 | Matrix44;
    /**
     * Creates an inverse matrix from the given matrix.
     * Uses optimized computation for 4x4 matrix inversion.
     * @param mat - The matrix to invert
     * @returns A new Matrix44 instance representing the inverted matrix
     * @throws Logs an error if the matrix is not invertible (determinant is 0)
     */
    static invert(mat: IMatrix44): IMatrix44;
    /**
     * Computes the inverse of a matrix and stores the result in an output matrix.
     * This is the mutable version of the invert method for performance optimization.
     * @param mat - The matrix to invert
     * @param outMat - The output matrix to store the result
     * @returns The output matrix containing the inverted matrix
     * @throws Logs an error if the matrix is not invertible (determinant is 0)
     */
    static invertTo(mat: IMatrix44, outMat: MutableMatrix44): MutableMatrix44;
    /**
     * Creates a translation matrix from a 3D vector.
     * @param vec - The translation vector
     * @returns A new Matrix44 instance representing the translation transformation
     */
    static translate(vec: Vector3): Matrix44;
    /**
     * Creates a rotation matrix around the X-axis.
     * @param radian - The rotation angle in radians
     * @returns A new Matrix44 instance representing the X-axis rotation
     */
    static rotateX(radian: number): Matrix44;
    /**
     * Creates a rotation matrix around the Y-axis.
     * @param radian - The rotation angle in radians
     * @returns A new Matrix44 instance representing the Y-axis rotation
     */
    static rotateY(radian: number): Matrix44;
    /**
     * Creates a rotation matrix around the Z-axis.
     * @param radian - The rotation angle in radians
     * @returns A new Matrix44 instance representing the Z-axis rotation
     */
    static rotateZ(radian: number): Matrix44;
    /**
     * Creates a rotation matrix from Euler angles (XYZ order).
     * Applies rotations in the order: X, then Y, then Z.
     * @param x - Rotation around X-axis in radians
     * @param y - Rotation around Y-axis in radians
     * @param z - Rotation around Z-axis in radians
     * @returns A new Matrix44 instance representing the combined rotation
     */
    static rotateXYZ(x: number, y: number, z: number): Matrix44;
    /**
     * Creates a rotation matrix from a 3D vector containing Euler angles.
     * @param vec - A vector containing rotation angles [x, y, z] in radians
     * @returns A new Matrix44 instance representing the rotation
     */
    static rotate(vec: IVector3): Matrix44;
    /**
     * Creates a scaling matrix from a 3D vector.
     * @param vec - The scaling factors for each axis [x, y, z]
     * @returns A new Matrix44 instance representing the scaling transformation
     */
    static scale(vec: IVector3): Matrix44;
    /**
     * Multiplies two 4x4 matrices and returns the result.
     * Optimized to handle identity matrices efficiently.
     * @param l_mat - The left matrix in the multiplication
     * @param r_mat - The right matrix in the multiplication
     * @returns A new Matrix44 instance representing the matrix product (l_mat * r_mat)
     */
    static multiply(l_mat: IMatrix44, r_mat: IMatrix44): IMatrix44;
    /**
     * Multiplies two 4x4 matrices and stores the result in an output matrix.
     * This is the mutable version of the multiply method for performance optimization.
     * @param l_mat - The left matrix in the multiplication
     * @param r_mat - The right matrix in the multiplication
     * @param outMat - The output matrix to store the result
     * @returns The output matrix containing the multiplication result
     */
    static multiplyTo(l_mat: IMatrix44, r_mat: IMatrix44, outMat: MutableMatrix44): MutableMatrix44;
    /**
     * Multiplies a matrix with data from a typed array and stores the result.
     * This method is optimized for working with raw array data.
     * @param l_mat - The left matrix in the multiplication
     * @param r_array - The right operand as a typed array
     * @param outMat - The output matrix to store the result
     * @param offsetAsComposition - The offset in the array for composition data
     * @returns The output matrix containing the multiplication result
     */
    static multiplyTypedArrayTo(l_mat: IMatrix44, r_array: ArrayType, outMat: MutableMatrix44, offsetAsComposition: number): MutableMatrix44;
    /**
     * Creates a rotation matrix from a quaternion and stores it in an output matrix.
     * @param quat - The quaternion representing the rotation
     * @param outMat - The output matrix to store the result
     * @returns The output matrix containing the rotation matrix
     */
    static fromQuaternionTo(quat: IQuaternion, outMat: MutableMatrix44): MutableMatrix44;
    /**
     * Converts the matrix to a human-readable string representation.
     * Elements are displayed in row-major order for intuitive reading.
     * @returns A formatted string representation of the matrix
     */
    toString(): string;
    /**
     * Converts the matrix to a human-readable string with rounded values.
     * Uses financial rounding for better readability of floating-point numbers.
     * @returns A formatted string representation with approximated values
     */
    toStringApproximately(): string;
    /**
     * Flattens the matrix into a regular JavaScript array.
     * Elements are returned in column-major order (WebGL compatible).
     * @returns An array containing all 16 matrix elements
     */
    flattenAsArray(): number[];
    /**
     * Checks if this is a dummy matrix (empty array).
     * @returns true if the matrix has no elements, false otherwise
     */
    isDummy(): boolean;
    /**
     * Checks if this matrix is approximately equal to another matrix.
     * @param mat - The matrix to compare with
     * @param delta - The tolerance for floating-point comparison (default: Number.EPSILON)
     * @returns true if matrices are approximately equal within the given tolerance
     */
    isEqual(mat: IMatrix44, delta?: number): boolean;
    /**
     * Checks if this matrix is exactly equal to another matrix.
     * Uses strict equality comparison for all elements.
     * @param mat - The matrix to compare with
     * @returns true if matrices are exactly equal, false otherwise
     */
    isStrictEqual(mat: IMatrix44): boolean;
    /**
     * Gets a matrix element at the specified row and column.
     * @param row_i - The row index (0-3)
     * @param column_i - The column index (0-3)
     * @returns The matrix element at the given position
     */
    at(row_i: number, column_i: number): number;
    /**
     * Calculates the determinant of this 4x4 matrix.
     * @returns The determinant value
     */
    determinant(): number;
    /**
     * Multiplies this matrix with a 4D vector and returns the result.
     * @param vec - The 4D vector to multiply
     * @returns A new Vector4 containing the multiplication result
     */
    multiplyVector(vec: IVector4): IVector4;
    /**
     * Multiplies this matrix with a 4D vector and stores the result in an output vector.
     * @param vec - The 4D vector to multiply
     * @param outVec - The output vector to store the result
     * @returns The output vector containing the multiplication result
     */
    multiplyVectorTo(vec: IVector4, outVec: MutableVector4): MutableVector4;
    /**
     * Multiplies this matrix with a 4D vector and stores the XYZ components in a 3D vector.
     * @param vec - The 4D vector to multiply
     * @param outVec - The output 3D vector to store the XYZ components
     * @returns The output vector containing the XYZ components of the result
     */
    multiplyVectorToVec3(vec: IVector4, outVec: MutableVector3): MutableVector3;
    /**
     * Multiplies this matrix with a 3D vector (treating it as a point with w=1).
     * @param vec - The 3D vector to multiply
     * @returns A new Vector3 containing the transformed point
     */
    multiplyVector3(vec: IVector3): IVector3;
    /**
     * Multiplies this matrix with a 3D vector and stores the result (treating it as a point with w=1).
     * @param vec - The 3D vector to multiply
     * @param outVec - The output vector to store the result
     * @returns The output vector containing the transformed point
     */
    multiplyVector3To(vec: IVector3, outVec: MutableVector3): MutableVector3;
    /**
     * Extracts the translation vector from this transformation matrix.
     * @returns A new Vector3 containing the translation components
     */
    getTranslate(): Vector3;
    /**
     * Extracts the translation vector from this matrix and stores it in an output vector.
     * @param outVec - The output vector to store the translation
     * @returns The output vector containing the translation components
     */
    getTranslateTo(outVec: MutableVector3): MutableVector3;
    /**
     * Extracts the scale factors from this transformation matrix.
     * @returns A new Vector3 containing the scale components for each axis
     */
    getScale(): Vector3;
    /**
     * Extracts the scale factors from this matrix and stores them in an output vector.
     * @param outVec - The output vector to store the scale factors
     * @returns The output vector containing the scale components
     */
    getScaleTo(outVec: MutableVector3): MutableVector3;
    /**
     * Converts this transformation matrix to Euler angles (XYZ rotation order).
     * @returns A Vector3 containing the Euler angles [x, y, z] in radians
     */
    toEulerAngles(): Vector3;
    /**
     * Converts this transformation matrix to Euler angles and stores them in an output vector.
     * @param outVec3 - The output vector to store the Euler angles
     * @returns The output vector containing the Euler angles [x, y, z] in radians
     */
    toEulerAnglesTo(outVec3: MutableVector3): MutableVector3;
    /**
     * Creates a deep copy of this matrix.
     * @returns A new Matrix44 instance with the same values
     */
    clone(): Matrix44;
    /**
     * Extracts the rotation part of this transformation matrix.
     * Removes scaling effects to get pure rotation.
     * @returns A new Matrix44 containing only the rotation transformation
     */
    getRotate(): Matrix44;
    /**
     * Creates a matrix from 16 individual values in row-major order.
     * This is the most intuitive way to specify matrix values, as you can
     * write them in the same 4x4 layout as they appear visually.
     * Note that internally, WebGL uses column-major storage.
     *
     * @param m00 - Element at row 0, column 0
     * @param m01 - Element at row 0, column 1
     * @param m02 - Element at row 0, column 2
     * @param m03 - Element at row 0, column 3
     * @param m10 - Element at row 1, column 0
     * @param m11 - Element at row 1, column 1
     * @param m12 - Element at row 1, column 2
     * @param m13 - Element at row 1, column 3
     * @param m20 - Element at row 2, column 0
     * @param m21 - Element at row 2, column 1
     * @param m22 - Element at row 2, column 2
     * @param m23 - Element at row 2, column 3
     * @param m30 - Element at row 3, column 0
     * @param m31 - Element at row 3, column 1
     * @param m32 - Element at row 3, column 2
     * @param m33 - Element at row 3, column 3
     * @returns A new Matrix44 instance
     */
    static fromCopy16RowMajor(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): Matrix44;
    /**
     * Creates a matrix from 16 individual values in column-major order.
     * This matches the internal storage format used by WebGL.
     *
     * @param m00 - Element at row 0, column 0
     * @param m10 - Element at row 1, column 0
     * @param m20 - Element at row 2, column 0
     * @param m30 - Element at row 3, column 0
     * @param m01 - Element at row 0, column 1
     * @param m11 - Element at row 1, column 1
     * @param m21 - Element at row 2, column 1
     * @param m31 - Element at row 3, column 1
     * @param m02 - Element at row 0, column 2
     * @param m12 - Element at row 1, column 2
     * @param m22 - Element at row 2, column 2
     * @param m32 - Element at row 3, column 2
     * @param m03 - Element at row 0, column 3
     * @param m13 - Element at row 1, column 3
     * @param m23 - Element at row 2, column 3
     * @param m33 - Element at row 3, column 3
     * @returns A new Matrix44 instance
     */
    static fromCopy16ColumnMajor(m00: number, m10: number, m20: number, m30: number, m01: number, m11: number, m21: number, m31: number, m02: number, m12: number, m22: number, m32: number, m03: number, m13: number, m23: number, m33: number): Matrix44;
    /**
     * Creates a new matrix by copying another Matrix44 instance.
     * @param mat - The source matrix to copy
     * @returns A new Matrix44 instance with copied values
     */
    static fromCopyMatrix44(mat: Matrix44): Matrix44;
    /**
     * Creates a matrix directly from a Float32Array in column-major order.
     * The array is used directly without copying (shares the same memory).
     * @param float32Array - A Float32Array containing 16 matrix elements
     * @returns A new Matrix44 instance using the provided array
     */
    static fromFloat32ArrayColumnMajor(float32Array: Float32Array): Matrix44;
    /**
     * Creates a matrix from a Float32Array in column-major order with copying.
     * @param float32Array - A Float32Array containing 16 matrix elements
     * @returns A new Matrix44 instance with copied values
     */
    static fromCopyFloat32ArrayColumnMajor(float32Array: Float32Array): Matrix44;
    /**
     * Creates a matrix from a Float32Array in row-major order with copying.
     * The input array is assumed to be in row-major order and will be converted
     * to column-major order for internal storage.
     * @param array - A Float32Array containing 16 matrix elements in row-major order
     * @returns A new Matrix44 instance with converted values
     */
    static fromCopyFloat32ArrayRowMajor(array: Float32Array): Matrix44;
    /**
     * Creates a 4x4 matrix from a 3x3 matrix by embedding it in the upper-left corner.
     * The resulting matrix has the 3x3 matrix in the upper-left, with the bottom-right
     * element set to 1 and other elements set to 0.
     * @param mat - The 3x3 matrix to embed
     * @returns A new Matrix44 instance
     */
    static fromCopyMatrix33(mat: IMatrix33): Matrix44;
    /**
     * Creates a matrix from a fixed-size array (Array16) in column-major order.
     * @param array - An Array16 containing exactly 16 matrix elements
     * @returns A new Matrix44 instance with copied values
     */
    static fromCopyArray16ColumnMajor(array: Array16<number>): Matrix44;
    /**
     * Creates a matrix from a variable-length array in column-major order.
     * @param array - An array containing at least 16 matrix elements
     * @returns A new Matrix44 instance with copied values
     */
    static fromCopyArrayColumnMajor(array: Array<number>): Matrix44;
    /**
     * Creates a matrix from a fixed-size array (Array16) in row-major order.
     * The input array is converted from row-major to column-major order.
     * @param array - An Array16 containing exactly 16 matrix elements in row-major order
     * @returns A new Matrix44 instance with converted values
     */
    static fromCopyArray16RowMajor(array: Array16<number>): Matrix44;
    /**
     * Creates a matrix from a variable-length array in row-major order.
     * The input array is converted from row-major to column-major order.
     * @param array - An array containing at least 16 matrix elements in row-major order
     * @returns A new Matrix44 instance with converted values
     */
    static fromCopyArrayRowMajor(array: Array<number>): Matrix44;
    /**
     * Creates a rotation matrix from a quaternion.
     * @param q - The quaternion representing the rotation
     * @returns A new Matrix44 instance representing the rotation transformation
     */
    static fromCopyQuaternion(q: IQuaternion): Matrix44;
}

/**
 * A 3D axis-aligned bounding box (AABB) class for spatial calculations and collision detection.
 *
 * The AABB represents a rectangular box aligned with the coordinate axes, defined by
 * minimum and maximum points. It provides efficient methods for spatial queries,
 * transformations, and merging operations commonly used in 3D graphics and physics simulations.
 *
 * @example
 * ```typescript
 * const aabb = new AABB();
 * aabb.addPosition(Vector3.fromValues(1, 2, 3));
 * aabb.addPosition(Vector3.fromValues(4, 5, 6));
 * console.log(aabb.centerPoint); // Center of the bounding box
 * ```
 */
declare class AABB {
    private __min;
    private __max;
    private __centerPoint;
    private __lengthCenterToCorner;
    private __isCenterPointDirty;
    private __isLengthCenterToCornerDirty;
    private static __tmpVector3;
    private __isVanilla;
    /**
     * Creates a deep copy of this AABB instance.
     *
     * All internal state including bounds, cached values, and dirty flags
     * are copied to the new instance.
     *
     * @returns A new AABB instance that is an exact copy of this one
     *
     * @example
     * ```typescript
     * const originalAABB = new AABB();
     * originalAABB.addPosition(Vector3.fromValues(1, 1, 1));
     * const clonedAABB = originalAABB.clone();
     * ```
     */
    clone(): AABB;
    /**
     * Copies all components and state from another AABB into this instance.
     *
     * This is a more efficient alternative to creating a new instance when you
     * want to overwrite the current AABB's state.
     *
     * @param aabb - The source AABB to copy from
     * @returns This AABB instance for method chaining
     *
     * @example
     * ```typescript
     * const sourceAABB = new AABB();
     * const targetAABB = new AABB();
     * targetAABB.copyComponents(sourceAABB);
     * ```
     */
    copyComponents(aabb: AABB): this;
    /**
     * Resets this AABB to its initial vanilla state.
     *
     * Clears all bounds, cached values, and marks the AABB as vanilla.
     * After initialization, the AABB will need new positions added to become valid.
     *
     * @example
     * ```typescript
     * const aabb = new AABB();
     * aabb.addPosition(Vector3.fromValues(1, 1, 1));
     * aabb.initialize(); // Reset to vanilla state
     * console.log(aabb.isVanilla()); // true
     * ```
     */
    initialize(): void;
    /**
     * Sets the minimum point of the bounding box.
     *
     * Setting the minimum point will invalidate cached values and mark
     * the AABB as non-vanilla.
     *
     * @param val - The new minimum point vector
     */
    set minPoint(val: Vector3);
    /**
     * Gets the minimum point of the bounding box.
     *
     * @returns The minimum point as a read-only Vector3
     */
    get minPoint(): Vector3;
    /**
     * Sets the maximum point of the bounding box.
     *
     * Setting the maximum point will invalidate cached values and mark
     * the AABB as non-vanilla.
     *
     * @param val - The new maximum point vector
     */
    set maxPoint(val: Vector3);
    /**
     * Gets the maximum point of the bounding box.
     *
     * @returns The maximum point as a read-only Vector3
     */
    get maxPoint(): Vector3;
    /**
     * Checks whether this AABB is in vanilla (uninitialized) state.
     *
     * A vanilla AABB has not had any positions added and contains invalid bounds.
     * Most operations on vanilla AABBs will return early or produce undefined results.
     *
     * @returns True if this AABB is vanilla, false otherwise
     *
     * @example
     * ```typescript
     * const aabb = new AABB();
     * console.log(aabb.isVanilla()); // true
     * aabb.addPosition(Vector3.fromValues(1, 1, 1));
     * console.log(aabb.isVanilla()); // false
     * ```
     */
    isVanilla(): boolean;
    /**
     * Expands the AABB to include the given position.
     *
     * If this is the first position added to a vanilla AABB, it will set both
     * min and max points to this position. Otherwise, it will expand the bounds
     * as necessary to encompass the new position.
     *
     * @param positionVector - The position to include in the bounding box
     * @returns The input position vector for convenience
     *
     * @example
     * ```typescript
     * const aabb = new AABB();
     * aabb.addPosition(Vector3.fromValues(1, 2, 3));
     * aabb.addPosition(Vector3.fromValues(4, 1, 2));
     * // AABB now encompasses both points
     * ```
     */
    addPosition(positionVector: Vector3): Vector3;
    /**
     * Expands the AABB to include a position from an array at the specified index.
     *
     * This is a more efficient way to add positions when working with packed
     * vertex data or other array-based position representations.
     *
     * @param array - The array containing position data
     * @param index - The starting index in the array (x, y, z values at index, index+1, index+2)
     * @returns The input array for convenience
     *
     * @example
     * ```typescript
     * const positions = [1, 2, 3, 4, 5, 6]; // Two 3D positions
     * const aabb = new AABB();
     * aabb.addPositionWithArray(positions, 0); // Add position (1, 2, 3)
     * aabb.addPositionWithArray(positions, 3); // Add position (4, 5, 6)
     * ```
     */
    addPositionWithArray(array: number[], index: Index): number[];
    /**
     * Merges this AABB with another AABB to create a combined bounding volume.
     *
     * The resulting AABB will encompass both the original and the merged AABB.
     * If either AABB is vanilla, special handling is applied.
     *
     * @param aabb - The AABB to merge with this one
     * @returns True if the merge was successful, false if the input AABB is vanilla
     *
     * @example
     * ```typescript
     * const aabb1 = new AABB();
     * const aabb2 = new AABB();
     * aabb1.addPosition(Vector3.fromValues(0, 0, 0));
     * aabb2.addPosition(Vector3.fromValues(5, 5, 5));
     * aabb1.mergeAABB(aabb2); // aabb1 now encompasses both volumes
     * ```
     */
    mergeAABB(aabb: AABB): boolean;
    /**
     * Gets the center point of the bounding box.
     *
     * The center point is calculated as the midpoint between the minimum and maximum points.
     * This value is cached and only recalculated when the bounds change.
     *
     * @returns The center point of the AABB
     *
     * @example
     * ```typescript
     * const aabb = new AABB();
     * aabb.minPoint = Vector3.fromValues(0, 0, 0);
     * aabb.maxPoint = Vector3.fromValues(4, 6, 8);
     * console.log(aabb.centerPoint); // Vector3(2, 3, 4)
     * ```
     */
    get centerPoint(): MutableVector3;
    /**
     * Gets the distance from the center point to any corner of the bounding box.
     *
     * This represents the radius of a sphere that would completely contain the AABB
     * when centered at the AABB's center point. Useful for sphere-based culling operations.
     *
     * @returns The distance from center to corner
     *
     * @example
     * ```typescript
     * const aabb = new AABB();
     * aabb.minPoint = Vector3.fromValues(-1, -1, -1);
     * aabb.maxPoint = Vector3.fromValues(1, 1, 1);
     * console.log(aabb.lengthCenterToCorner); // sqrt(3)  1.732
     * ```
     */
    get lengthCenterToCorner(): number;
    /**
     * Gets the width of the bounding box along the X-axis.
     *
     * @returns The difference between maximum and minimum X coordinates
     *
     * @example
     * ```typescript
     * const aabb = new AABB();
     * aabb.minPoint = Vector3.fromValues(1, 0, 0);
     * aabb.maxPoint = Vector3.fromValues(5, 0, 0);
     * console.log(aabb.sizeX); // 4
     * ```
     */
    get sizeX(): number;
    /**
     * Gets the height of the bounding box along the Y-axis.
     *
     * @returns The difference between maximum and minimum Y coordinates
     *
     * @example
     * ```typescript
     * const aabb = new AABB();
     * aabb.minPoint = Vector3.fromValues(0, 2, 0);
     * aabb.maxPoint = Vector3.fromValues(0, 8, 0);
     * console.log(aabb.sizeY); // 6
     * ```
     */
    get sizeY(): number;
    /**
     * Gets the depth of the bounding box along the Z-axis.
     *
     * @returns The difference between maximum and minimum Z coordinates
     *
     * @example
     * ```typescript
     * const aabb = new AABB();
     * aabb.minPoint = Vector3.fromValues(0, 0, -2);
     * aabb.maxPoint = Vector3.fromValues(0, 0, 3);
     * console.log(aabb.sizeZ); // 5
     * ```
     */
    get sizeZ(): number;
    /**
     * Transforms an AABB by a matrix and stores the result in an output AABB.
     *
     * This method transforms all 8 corners of the input AABB using the given matrix,
     * then calculates the axis-aligned bounding box that encompasses all transformed corners.
     * This is necessary because matrix transformations can rotate the AABB, requiring
     * recalculation of the axis-aligned bounds.
     *
     * @param matrix - The transformation matrix to apply
     * @param aabb - The source AABB to transform
     * @param outAabb - The output AABB to store the result
     * @returns The output AABB for method chaining
     *
     * @example
     * ```typescript
     * const matrix = Matrix44.rotateY(Math.PI / 4); // 45-degree rotation
     * const sourceAABB = new AABB();
     * const resultAABB = new AABB();
     * sourceAABB.addPosition(Vector3.fromValues(1, 1, 1));
     * AABB.multiplyMatrixTo(matrix, sourceAABB, resultAABB);
     * ```
     */
    static multiplyMatrixTo(matrix: Matrix44, aabb: AABB, outAabb: AABB): AABB;
    /**
     * Returns a string representation of the AABB with full precision.
     *
     * Includes minimum and maximum points, center point, and center-to-corner distance.
     *
     * @returns A detailed string representation of the AABB
     *
     * @example
     * ```typescript
     * const aabb = new AABB();
     * aabb.addPosition(Vector3.fromValues(1, 2, 3));
     * console.log(aabb.toString());
     * // Output: "AABB_min: (1, 2, 3)\nAABB_max: (1, 2, 3)\n..."
     * ```
     */
    toString(): string;
    /**
     * Returns a string representation of the AABB with rounded numbers for readability.
     *
     * Similar to toString() but with approximate values that are easier to read.
     * Useful for debugging and logging where exact precision is not required.
     *
     * @returns A string representation with approximated numeric values
     *
     * @example
     * ```typescript
     * const aabb = new AABB();
     * aabb.addPosition(Vector3.fromValues(1.23456789, 2.3456789, 3.456789));
     * console.log(aabb.toStringApproximately());
     * // Output with rounded values for better readability
     * ```
     */
    toStringApproximately(): string;
}

type BlockInfo = {
    byteSize: number;
    width: number;
    height: number;
};
interface CompressionTextureTypeEnum extends EnumIO {
    webgpu?: string;
    blockInfo?: BlockInfo;
}
declare function from$p(index: number): CompressionTextureTypeEnum;
declare function fromString$f(str: string): CompressionTextureTypeEnum;
declare const CompressionTextureType: Readonly<{
    ASTC_RGBA_4x4: CompressionTextureTypeEnum;
    ASTC_RGBA_5x4: CompressionTextureTypeEnum;
    ASTC_RGBA_5x5: CompressionTextureTypeEnum;
    ASTC_RGBA_6x5: CompressionTextureTypeEnum;
    ASTC_RGBA_6x6: CompressionTextureTypeEnum;
    ASTC_RGBA_8x5: CompressionTextureTypeEnum;
    ASTC_RGBA_8x6: CompressionTextureTypeEnum;
    ASTC_RGBA_8x8: CompressionTextureTypeEnum;
    ASTC_RGBA_10x5: CompressionTextureTypeEnum;
    ASTC_RGBA_10x6: CompressionTextureTypeEnum;
    ASTC_RGBA_10x8: CompressionTextureTypeEnum;
    ASTC_RGBA_10x10: CompressionTextureTypeEnum;
    ASTC_RGBA_12x10: CompressionTextureTypeEnum;
    ASTC_RGBA_12x12: CompressionTextureTypeEnum;
    ASTC_SRGB_4x4: CompressionTextureTypeEnum;
    ASTC_SRGB_5x4: CompressionTextureTypeEnum;
    ASTC_SRGB_5x5: CompressionTextureTypeEnum;
    ASTC_SRGB_6x5: CompressionTextureTypeEnum;
    ASTC_SRGB_6x6: CompressionTextureTypeEnum;
    ASTC_SRGB_8x5: CompressionTextureTypeEnum;
    ASTC_SRGB_8x6: CompressionTextureTypeEnum;
    ASTC_SRGB_8x8: CompressionTextureTypeEnum;
    ASTC_SRGB_10x5: CompressionTextureTypeEnum;
    ASTC_SRGB_10x6: CompressionTextureTypeEnum;
    ASTC_SRGB_10x8: CompressionTextureTypeEnum;
    ASTC_SRGB_10x10: CompressionTextureTypeEnum;
    ASTC_SRGB_12x10: CompressionTextureTypeEnum;
    ASTC_SRGB_12x12: CompressionTextureTypeEnum;
    S3TC_RGB_DXT1: CompressionTextureTypeEnum;
    S3TC_RGBA_DXT1: CompressionTextureTypeEnum;
    S3TC_RGBA_DXT3: CompressionTextureTypeEnum;
    S3TC_RGBA_DXT5: CompressionTextureTypeEnum;
    BPTC_RGBA: CompressionTextureTypeEnum;
    PVRTC_RGBA_4BPPV1: CompressionTextureTypeEnum;
    PVRTC_RGB_4BPPV1: CompressionTextureTypeEnum;
    ETC2_RGBA8_EAC: CompressionTextureTypeEnum;
    ETC2_RGB8: CompressionTextureTypeEnum;
    ETC1_RGB: CompressionTextureTypeEnum;
    RGBA8_EXT: CompressionTextureTypeEnum;
    from: typeof from$p;
    fromString: typeof fromString$f;
}>;

type HdriFormatEnum = EnumIO;
declare function from$o(index: number): HdriFormatEnum;
declare function fromString$e(str: string): HdriFormatEnum;
declare const HdriFormat: Readonly<{
    LDR_SRGB: EnumIO;
    LDR_LINEAR: EnumIO;
    HDR_LINEAR: EnumIO;
    RGBE_PNG: EnumIO;
    RGB9_E5_PNG: EnumIO;
    OpenEXR: EnumIO;
    from: typeof from$o;
    fromString: typeof fromString$e;
}>;

type PixelFormatEnum = EnumIO;
declare function getCompositionNumFromPixelFormat(pixelFormat: PixelFormatEnum): number;
declare function from$n(index: number): PixelFormatEnum;
declare const PixelFormat: Readonly<{
    DepthComponent: EnumIO;
    DepthStencil: EnumIO;
    Alpha: EnumIO;
    RG: EnumIO;
    RGB: EnumIO;
    RGBA: EnumIO;
    Luminance: EnumIO;
    LuminanceAlpha: EnumIO;
    from: typeof from$n;
    getCompositionNumFromPixelFormat: typeof getCompositionNumFromPixelFormat;
}>;

interface TextureFormatEnum extends EnumIO {
    webgpu: string;
}
declare function getPixelFormatFromTextureFormat(textureFormat: TextureFormatEnum): PixelFormatEnum;
declare function getPixelFormatAndComponentTypeFromTextureFormat(internalFormat: TextureFormatEnum): {
    format: EnumIO;
    type: ComponentTypeEnum;
};
declare function from$m(index: number): TextureFormatEnum;
declare const TextureFormat: Readonly<{
    RGB8: TextureFormatEnum;
    RGBA8: TextureFormatEnum;
    RGB10_A2: TextureFormatEnum;
    RG16F: TextureFormatEnum;
    RG32F: TextureFormatEnum;
    RGB16F: TextureFormatEnum;
    RGB32F: TextureFormatEnum;
    RGBA16F: TextureFormatEnum;
    RGBA32F: TextureFormatEnum;
    R11F_G11F_B10F: TextureFormatEnum;
    Depth16: TextureFormatEnum;
    Depth24: TextureFormatEnum;
    Depth32F: TextureFormatEnum;
    Depth24Stencil8: TextureFormatEnum;
    Depth32FStencil8: TextureFormatEnum;
    getPixelFormatFromTextureFormat: typeof getPixelFormatFromTextureFormat;
    getPixelFormatAndComponentTypeFromTextureFormat: typeof getPixelFormatAndComponentTypeFromTextureFormat;
    from: typeof from$m;
}>;

interface TextureParameterEnum extends EnumIO {
    webgpu: string;
}
declare function from$l(index: number): TextureParameterEnum;
declare const TextureParameter: Readonly<{
    Nearest: TextureParameterEnum;
    Linear: TextureParameterEnum;
    NearestMipmapNearest: TextureParameterEnum;
    LinearMipmapNearest: TextureParameterEnum;
    NearestMipmapLinear: TextureParameterEnum;
    LinearMipmapLinear: TextureParameterEnum;
    TextureMagFilter: TextureParameterEnum;
    TextureMinFilter: TextureParameterEnum;
    TextureWrapS: TextureParameterEnum;
    TextureWrapT: TextureParameterEnum;
    Texture2D: TextureParameterEnum;
    Texture: TextureParameterEnum;
    Texture0: TextureParameterEnum;
    Texture1: TextureParameterEnum;
    ActiveTexture: TextureParameterEnum;
    Repeat: TextureParameterEnum;
    ClampToEdge: TextureParameterEnum;
    MirroredRepeat: TextureParameterEnum;
    from: typeof from$l;
}>;

type ComponentChar = 'X' | 'Y' | 'Z' | 'W';
type VertexAttributeTypeName = 'UNKNOWN' | 'POSITION' | 'NORMAL' | 'TANGENT' | 'TEXCOORD_0' | 'TEXCOORD_1' | 'TEXCOORD_2' | 'COLOR_0' | 'JOINTS_0' | 'WEIGHTS_0' | 'INSTANCE' | 'FACE_NORMAL' | 'BARY_CENTRIC_COORD';
type VertexAttributeComponent = `${VertexAttributeTypeName}.${ComponentChar}`;
type VertexAttributeSemanticsJoinedString = `${string}.${ComponentChar}` | `${string}.${ComponentChar},${string}.${ComponentChar}` | `${string}.${ComponentChar},${string}.${ComponentChar},${string}.${ComponentChar}` | `${string}.${ComponentChar},${string}.${ComponentChar},${string}.${ComponentChar},${string}.${ComponentChar}`;
interface VertexAttributeEnum extends EnumIO {
    getAttributeSlot(): Index;
    shaderStr: string;
    X: VertexAttributeComponent;
    Y: VertexAttributeComponent;
    Z: VertexAttributeComponent;
    W: VertexAttributeComponent;
    XY: VertexAttributeSemanticsJoinedString;
    XYZ: VertexAttributeSemanticsJoinedString;
    XYZW: VertexAttributeSemanticsJoinedString;
}
type VertexAttributeDescriptor = {
    str: VertexAttributeTypeName;
    shaderStr: string;
    attributeSlot: Index;
    gltfComponentN: Count;
};
declare class VertexAttributeClass extends EnumClass implements VertexAttributeEnum {
    private static __indexCount;
    private __attributeSlot;
    private __shaderStr;
    private __gltfComponentN;
    private constructor();
    getAttributeSlot(): Index;
    get shaderStr(): string;
    get attributeTypeName(): VertexAttributeTypeName;
    _setShaderStr(str: string): void;
    get X(): VertexAttributeComponent;
    get Y(): VertexAttributeComponent;
    get Z(): VertexAttributeComponent;
    get W(): VertexAttributeComponent;
    get XY(): VertexAttributeSemanticsJoinedString;
    get XYZ(): VertexAttributeSemanticsJoinedString;
    get XYZW(): VertexAttributeSemanticsJoinedString;
    getVertexAttributeComponentsAsGltf(): VertexAttributeSemanticsJoinedString;
    static __createVertexAttributeClass(desc: VertexAttributeDescriptor): VertexAttributeClass;
}
declare const Position: VertexAttributeEnum;
declare const Normal: VertexAttributeEnum;
declare const Tangent: VertexAttributeEnum;
declare const Texcoord0: VertexAttributeEnum;
declare const Texcoord1: VertexAttributeEnum;
declare const Color0: VertexAttributeEnum;
declare const Joints0: VertexAttributeEnum;
declare const Weights0: VertexAttributeEnum;
declare function isInstanceOfVertexAttributeClass(obj: unknown): obj is VertexAttributeClass;
declare function from$k(index: number): VertexAttributeEnum;
declare function fromString$d(str: string): VertexAttributeEnum;
type Gltf2VertexAttributeEnums = typeof Position | typeof Color0 | typeof Normal | typeof Tangent | typeof Texcoord0 | typeof Texcoord1 | typeof Joints0 | typeof Weights0;
declare function toVertexAttributeSemanticJoinedStringAsGltfStyle(attribute: Gltf2VertexAttributeEnums): VertexAttributeSemanticsJoinedString;
declare function toAttributeSlotFromJoinedString(str: VertexAttributeSemanticsJoinedString): Index;
declare function toVectorComponentN(joinedString: VertexAttributeSemanticsJoinedString): VectorComponentN;
declare const VertexAttribute: Readonly<{
    Unknown: VertexAttributeEnum;
    Position: VertexAttributeEnum;
    Normal: VertexAttributeEnum;
    Tangent: VertexAttributeEnum;
    Texcoord0: VertexAttributeEnum;
    Texcoord1: VertexAttributeEnum;
    Color0: VertexAttributeEnum;
    Joints0: VertexAttributeEnum;
    Weights0: VertexAttributeEnum;
    Instance: VertexAttributeEnum;
    FaceNormal: VertexAttributeEnum;
    BaryCentricCoord: VertexAttributeEnum;
    AttributeTypeNumber: number;
    isInstanceOfVertexAttributeClass: typeof isInstanceOfVertexAttributeClass;
    toVertexAttributeSemanticJoinedStringAsGltfStyle: typeof toVertexAttributeSemanticJoinedStringAsGltfStyle;
    toAttributeSlotFromJoinedString: typeof toAttributeSlotFromJoinedString;
    toVectorComponentN: typeof toVectorComponentN;
    from: typeof from$k;
    fromString: typeof fromString$d;
}>;

interface RenderBufferTargetEnum extends EnumIO {
    webGLConstantValue(): number;
}
declare function from$j(index: number): RenderBufferTargetEnum;
declare const RenderBufferTarget: Readonly<{
    None: RenderBufferTargetEnum;
    Back: RenderBufferTargetEnum;
    ColorAttachment0: RenderBufferTargetEnum;
    ColorAttachment1: RenderBufferTargetEnum;
    ColorAttachment2: RenderBufferTargetEnum;
    ColorAttachment3: RenderBufferTargetEnum;
    ColorAttachment4: RenderBufferTargetEnum;
    ColorAttachment5: RenderBufferTargetEnum;
    ColorAttachment6: RenderBufferTargetEnum;
    ColorAttachment7: RenderBufferTargetEnum;
    ColorAttachment8: RenderBufferTargetEnum;
    ColorAttachment9: RenderBufferTargetEnum;
    ColorAttachment10: RenderBufferTargetEnum;
    ColorAttachment11: RenderBufferTargetEnum;
    ColorAttachment12: RenderBufferTargetEnum;
    ColorAttachment13: RenderBufferTargetEnum;
    ColorAttachment14: RenderBufferTargetEnum;
    ColorAttachment15: RenderBufferTargetEnum;
    from: typeof from$j;
}>;

type WebGLExtensionEnum = EnumIO;
declare function from$i({ index }: {
    index: number;
}): WebGLExtensionEnum;
declare const WebGLExtension: Readonly<{
    VertexArrayObject: EnumIO;
    TextureFloat: EnumIO;
    TextureHalfFloat: EnumIO;
    TextureFloatLinear: EnumIO;
    TextureHalfFloatLinear: EnumIO;
    InstancedArrays: EnumIO;
    TextureFilterAnisotropic: EnumIO;
    ElementIndexUint: EnumIO;
    ShaderTextureLod: EnumIO;
    ShaderDerivatives: EnumIO;
    DrawBuffers: EnumIO;
    BlendMinmax: EnumIO;
    ColorBufferFloatWebGL1: EnumIO;
    CompressedTextureAstc: EnumIO;
    CompressedTextureS3tc: EnumIO;
    CompressedTexturePvrtc: EnumIO;
    CompressedTextureAtc: EnumIO;
    CompressedTextureEtc: EnumIO;
    CompressedTextureEtc1: EnumIO;
    CompressedTextureBptc: EnumIO;
    ColorBufferFloatWebGL2: EnumIO;
    ColorBufferHalfFloatWebGL2: EnumIO;
    OculusMultiview: EnumIO;
    OvrMultiview2: EnumIO;
    GMAN_WEBGL_MEMORY: EnumIO;
    ClipControl: EnumIO;
    from: typeof from$i;
}>;

interface WEBGL_compressed_texture_etc {
    readonly COMPRESSED_RGBA8_ETC2_EAC: number;
}
interface WEBGL_compressed_texture_bptc {
    readonly COMPRESSED_RGBA_BPTC_UNORM_EXT: number;
}
interface WEBGL_multiview {
    framebufferTextureMultiviewOVR(target: number, attachment: number, texture: WebGLTexture, level: number, baseViewIndex: number, numViews: number): void;
    framebufferTextureMultisampleMultiviewOVR(target: number, attachment: number, texture: WebGLTexture, level: number, samples: number, baseViewIndex: number, numViews: number): void;
    is_multisample: boolean;
}
/**
 * A wrapper class for WebGL context that provides enhanced functionality and state management.
 * This class handles WebGL state optimization, extension management, and provides convenience methods
 * for common WebGL operations while maintaining compatibility with both WebGL1 and WebGL2.
 */
declare class WebGLContextWrapper {
    #private;
    __gl: WebGL2RenderingContext;
    __webglVersion: number;
    width: Size;
    height: Size;
    readonly canvas: HTMLCanvasElement;
    readonly webgl1ExtVAO?: OES_vertex_array_object;
    readonly webgl1ExtIA?: ANGLE_instanced_arrays;
    readonly webgl1ExtTF?: OES_texture_float;
    readonly webgl1ExtTHF?: OES_texture_half_float;
    readonly webgl1ExtTFL?: OES_texture_float_linear;
    readonly webgl1ExtTHFL?: OES_texture_half_float_linear;
    readonly webgl1ExtTFA?: EXT_texture_filter_anisotropic;
    readonly webgl1ExtEIUI?: OES_element_index_uint;
    readonly webgl1ExtSTL?: EXT_shader_texture_lod;
    readonly webgl1ExtDRV?: OES_standard_derivatives;
    readonly webgl1ExtDB?: WEBGL_draw_buffers;
    readonly webgl1ExtBM?: EXT_blend_minmax;
    readonly webgl1ExtCBF?: WEBGL_color_buffer_float;
    readonly webgl1ExtCTAstc?: WEBGL_compressed_texture_astc;
    readonly webgl1ExtCTS3tc?: WEBGL_compressed_texture_s3tc;
    readonly webgl1ExtCTPvrtc?: WEBKIT_WEBGL_compressed_texture_pvrtc;
    readonly webgl1ExtCTAtc?: WEBGL_compressed_texture_atc;
    readonly webgl1ExtCTEtc?: WEBGL_compressed_texture_etc;
    readonly webgl1ExtCTEtc1?: WEBGL_compressed_texture_etc1;
    readonly webgl1ExtCTBptc?: WEBGL_compressed_texture_bptc;
    readonly webgl2ExtTFL?: OES_texture_float_linear;
    readonly webgl2ExtTHFL?: OES_texture_half_float_linear;
    readonly webgl2ExtTFA?: EXT_texture_filter_anisotropic;
    readonly webgl2ExtCBF?: EXT_color_buffer_float;
    readonly webgl2ExtCBHF?: EXT_color_buffer_half_float;
    readonly webgl2ExtCTAstc?: WEBGL_compressed_texture_astc;
    readonly webgl2ExtCTS3tc?: WEBGL_compressed_texture_s3tc;
    readonly webgl2ExtCTPvrtc?: WEBKIT_WEBGL_compressed_texture_pvrtc;
    readonly webgl2ExtCTAtc?: WEBGL_compressed_texture_atc;
    readonly webgl2ExtCTEtc?: WEBGL_compressed_texture_etc;
    readonly webgl2ExtCTEtc1?: WEBGL_compressed_texture_etc1;
    readonly webgl2ExtCTBptc?: WEBGL_compressed_texture_bptc;
    readonly webgl2ExtMLTVIEW?: WEBGL_multiview;
    readonly webgl2ExtClipCtrl?: any;
    readonly webgl2ExtGmanWM?: any;
    private __activeTextureBackup;
    private __activeTextures2D;
    private __activeTextures2DArray;
    private __activeTexturesCube;
    private __boundTextures;
    private __boundSamplers;
    private __viewport_left;
    private __viewport_top;
    private __viewport_width;
    private __viewport_height;
    private __default_viewport_left;
    private __default_viewport_top;
    private __default_viewport_width;
    private __default_viewport_height;
    private __maxVertexUniformVectors;
    private __maxFragmentUniformVectors;
    private readonly __is_multiview;
    _isWebXRMode: boolean;
    __extensions: Map<WebGLExtensionEnum, WebGLObject>;
    /**
     * Creates a new WebGLContextWrapper instance.
     * @param gl - The WebGL2 rendering context to wrap
     * @param canvas - The HTML canvas element associated with the context
     */
    constructor(gl: WebGL2RenderingContext, canvas: HTMLCanvasElement);
    /**
     * Gets the raw WebGL rendering context.
     * @returns The underlying WebGL context (WebGL1 or WebGL2)
     */
    getRawContext(): WebGLRenderingContext | WebGL2RenderingContext;
    /**
     * Gets the raw WebGL context cast as WebGL1.
     * @returns The underlying WebGL context as WebGL1 type
     */
    getRawContextAsWebGL1(): WebGLRenderingContext;
    /**
     * Gets the raw WebGL context cast as WebGL2.
     * @returns The underlying WebGL context as WebGL2 type
     */
    getRawContextAsWebGL2(): WebGL2RenderingContext;
    /**
     * Gets the current viewport settings.
     * @returns A Vector4 containing viewport left, top, width, and height
     */
    get viewport(): Vector4;
    /**
     * Gets the default viewport settings.
     * @returns A Vector4 containing default viewport left, top, width, and height
     */
    get defaultViewport(): Vector4;
    /**
     * Checks if a WebGL1 extension is supported.
     * @param webGLExtension - The WebGL extension to check
     * @returns True if the extension is supported, false otherwise
     */
    isSupportWebGL1Extension(webGLExtension: WebGLExtensionEnum): boolean;
    /**
     * Checks if a WebGL1 extension is not supported.
     * @param webGLExtension - The WebGL extension to check
     * @returns True if the extension is not supported, false otherwise
     */
    isNotSupportWebGL1Extension(webGLExtension: WebGLExtensionEnum): boolean;
    /**
     * Type guard to check if the context is WebGL2.
     * @param gl - The WebGL context to check
     * @returns True if the context is WebGL2, false otherwise
     */
    getIsWebGL2(gl: WebGLRenderingContext | WebGL2RenderingContext): gl is WebGL2RenderingContext;
    /**
     * Checks if the current context is WebGL2.
     * @returns True if WebGL2, false if WebGL1
     */
    get isWebGL2(): boolean;
    /**
     * Creates a new vertex array object.
     * @returns A new WebGL vertex array object
     */
    createVertexArray(): WebGLVertexArrayObject;
    /**
     * Deletes a vertex array object.
     * @param vertexArray - The vertex array object to delete
     */
    deleteVertexArray(vertexArray: WebGLVertexArrayObject | WebGLVertexArrayObjectOES): void;
    /**
     * Binds a vertex array object.
     * @param vao - The vertex array object to bind, or null to unbind
     */
    bindVertexArray(vao: WebGLVertexArrayObjectOES | null): void;
    /**
     * Sets the divisor for instanced rendering for a vertex attribute.
     * @param index - The index of the vertex attribute
     * @param divisor - The divisor value (0 for per-vertex, 1+ for per-instance)
     */
    vertexAttribDivisor(index: number, divisor: number): void;
    /**
     * Draws elements with instancing support.
     * @param primitiveMode - The primitive mode (GL_TRIANGLES, etc.)
     * @param indexCount - The number of indices to draw
     * @param type - The type of the index values
     * @param offset - The offset in the index buffer
     * @param instanceCount - The number of instances to draw
     */
    drawElementsInstanced(primitiveMode: number, indexCount: number, type: number, offset: number, instanceCount: number): void;
    /**
     * Draws arrays with instancing support.
     * @param primitiveMode - The primitive mode (GL_TRIANGLES, etc.)
     * @param first - The starting index in the enabled arrays
     * @param count - The number of vertices to draw
     * @param instanceCount - The number of instances to draw
     */
    drawArraysInstanced(primitiveMode: number, first: number, count: number, instanceCount: number): void;
    /**
     * Gets the color attachment constant for a given index.
     * @param index - The attachment index
     * @returns The WebGL color attachment constant
     */
    colorAttachment(index: Index): number;
    /**
     * Sets the draw buffers for multiple render targets.
     * @param buffers - Array of render buffer targets to draw to
     */
    drawBuffers(buffers: RenderBufferTargetEnum[]): void;
    /**
     * Activates a texture unit for subsequent texture operations.
     * Optimized to avoid redundant state changes.
     * @param activeTextureIndex - The texture unit index to activate
     */
    private __activeTexture;
    /**
     * Binds a 2D texture to a specific texture unit.
     * Optimized to avoid redundant state changes.
     * @param activeTextureIndex - The texture unit index
     * @param texture - The 2D texture to bind
     */
    bindTexture2D(activeTextureIndex: Index, texture: WebGLTexture): void;
    /**
     * Binds a 2D array texture to a specific texture unit.
     * Optimized to avoid redundant state changes.
     * @param activeTextureIndex - The texture unit index
     * @param texture - The 2D array texture to bind
     */
    bindTexture2DArray(activeTextureIndex: Index, texture: WebGLTexture): void;
    /**
     * Binds a sampler object to a specific texture unit.
     * Optimized to avoid redundant state changes.
     * @param activeTextureIndex - The texture unit index
     * @param sampler - The sampler object to bind
     */
    bindTextureSampler(activeTextureIndex: Index, sampler: WebGLSampler): void;
    /**
     * Binds a cube map texture to a specific texture unit.
     * Optimized to avoid redundant state changes.
     * @param activeTextureIndex - The texture unit index
     * @param texture - The cube map texture to bind
     */
    bindTextureCube(activeTextureIndex: Index, texture: WebGLTexture): void;
    /**
     * Unbinds a 2D texture from a specific texture unit.
     * @param activeTextureIndex - The texture unit index
     */
    unbindTexture2D(activeTextureIndex: Index): void;
    /**
     * Unbinds a 2D array texture from a specific texture unit.
     * @param activeTextureIndex - The texture unit index
     */
    unbindTexture2DArray(activeTextureIndex: Index): void;
    /**
     * Unbinds a cube map texture from a specific texture unit.
     * @param activeTextureIndex - The texture unit index
     */
    unbindTextureCube(activeTextureIndex: Index): void;
    /**
     * Unbinds all currently bound textures from all texture units.
     * This is useful for cleanup operations.
     */
    unbindTextures(): void;
    /**
     * Gets a WebGL extension and caches it for future use.
     * @param extension - The extension to retrieve
     * @returns The extension object or null if not available
     */
    private __getExtension;
    /**
     * Gets a compressed texture extension with vendor prefix support.
     * @param extension - The compressed texture extension to retrieve
     * @returns The extension object or null if not available
     */
    private __getCompressedTextureExtension;
    /**
     * Sets the viewport with optimization to avoid redundant state changes.
     * @param left - Left coordinate of the viewport
     * @param top - Top coordinate of the viewport
     * @param width - Width of the viewport
     * @param height - Height of the viewport
     */
    setViewport(left: number, top: number, width: number, height: number): void;
    /**
     * Sets the viewport using a Vector4 with optimization to avoid redundant state changes.
     * @param viewport - Vector4 containing left, top, width, and height
     */
    setViewportAsVector4(viewport: Vector4): void;
    /**
     * Retrieves and caches uniform buffer information for WebGL2.
     * This includes alignment requirements and size limits.
     */
    private __getUniformBufferInfo;
    /**
     * Retrieves and caches the maximum number of uniform vectors for vertex and fragment shaders.
     */
    private __getMaxUniformVectors;
    /**
     * Gets the maximum number of uniform blocks that can be used in both vertex and fragment shaders.
     * @returns The minimum of vertex and fragment shader uniform block limits
     */
    getMaxConventionUniformBlocks(): number;
    /**
     * Gets the maximum uniform block size aligned to the required offset alignment.
     * @returns The aligned maximum uniform block size in bytes
     */
    getAlignedMaxUniformBlockSize(): number;
    /**
     * Gets the maximum number of uniform vectors available in vertex shaders.
     * @returns The maximum vertex uniform vectors
     */
    getMaxVertexUniformVectors(): number;
    /**
     * Gets the maximum number of uniform vectors available in fragment shaders.
     * @returns The maximum fragment uniform vectors
     */
    getMaxFragmentUniformVectors(): number;
    /**
     * Gets WebGL memory usage information if the GMAN_WEBGL_MEMORY extension is available.
     * @returns Memory information object or undefined if extension is not available
     */
    getWebGLMemoryInfo(): any;
    /**
     * Checks if multiview rendering is supported and enabled.
     * @returns True if multiview is available and enabled for WebVR
     */
    isMultiview(): boolean;
}

type ShaderSources = {
    vertex: string;
    pixel: string;
};
interface WebGLStrategy {
    attachGPUData(primitive: Primitive): void;
    attachVertexData(i: number, primitive: Primitive, glw: WebGLContextWrapper, instanceIDBufferUid: WebGLResourceHandle): void;
    setupShaderForMaterial(material: Material, primitive: Primitive): CGAPIResourceHandle;
    _reSetupShaderForMaterialBySpector(material: Material, primitive: Primitive, updatedShaderSources: ShaderSources, onError: (message: string) => void): CGAPIResourceHandle;
}

/**
 * Result of a basic raycast operation against geometry.
 */
interface RaycastResult {
    result: boolean;
    data?: {
        t: number;
        u: number;
        v: number;
    };
}
/**
 * Extended raycast result that includes the intersection position in world space.
 */
interface RaycastResultEx1 {
    result: boolean;
    data?: {
        t: number;
        u: number;
        v: number;
        position: IVector3;
    };
}
/**
 * Extended raycast result that includes the intersection position and the selected mesh component.
 */
interface RaycastResultEx2 {
    result: boolean;
    data?: {
        t: number;
        u: number;
        v: number;
        position: IVector3;
        selectedMeshComponent: MeshComponent;
    };
}
/**
 * Primitive sort key used for depth sorting and rendering order optimization.
 *
 * See: http://realtimecollisiondetection.net/blog/?p=86
 *
 * Bit Field Layout:
 * --- 0
 *  3 bits: Primitive Type (0: POINTS, 1: LINES, 2: LINE_LOOP, 3: LINE_STRIP, 4: TRIANGLES, 5: TRIANGLE_STRIP, 6: TRIANGLE_FAN)
 * 10 bits: Material TID
 *  2 bits: Translucency type (0: Opaque, 1: Translucent, 2: Blend with ZWrite, 3: Blend without ZWrite
 *  3 bits: Viewport layer
 *  3 bits: Viewport
 *  2 bits: Fullscreen layer
 * --- 31
 *
 * Depth Field:
 * 32 bits: Depth
 */
type PrimitiveSortKey = number;
declare const PrimitiveSortKey_BitLength_TranslucencyType = 2;
declare const PrimitiveSortKey_BitLength_Material = 10;
declare const PrimitiveSortKey_BitLength_PrimitiveType = 3;
declare const PrimitiveSortKey_BitOffset_PrimitiveType = 0;
declare const PrimitiveSortKey_BitOffset_Material = 3;
declare const PrimitiveSortKey_BitOffset_TranslucencyType: number;
declare const PrimitiveSortKey_BitOffset_ViewportLayer: number;
type PrimitiveSortKeyLength = typeof PrimitiveSortKey_BitLength_Material | typeof PrimitiveSortKey_BitLength_TranslucencyType | typeof PrimitiveSortKey_BitLength_PrimitiveType;
type PrimitiveSortKeyOffset = typeof PrimitiveSortKey_BitOffset_Material | typeof PrimitiveSortKey_BitOffset_TranslucencyType | typeof PrimitiveSortKey_BitOffset_ViewportLayer;
declare const PrimitiveSortKey_BitLength_Depth = 32;
/**
 * Interface representing a mesh with a unique identifier.
 */
interface IMesh {
    meshUID: MeshUID;
}
/**
 * Checks if the primitive uses blending (either with or without Z-write).
 * @param primitive - The primitive to check
 * @returns True if the primitive uses blending, false otherwise
 */
declare function isBlend(primitive: Primitive): boolean;
/**
 * Checks if the primitive uses blending with Z-write enabled.
 * @param primitive - The primitive to check
 * @returns True if the primitive uses blending with Z-write, false otherwise
 */
declare function isBlendWithZWrite(primitive: Primitive): boolean;
/**
 * Checks if the primitive uses blending without Z-write (depth writing disabled).
 * @param primitive - The primitive to check
 * @returns True if the primitive uses blending without Z-write, false otherwise
 */
declare function isBlendWithoutZWrite(primitive: Primitive): boolean;
/**
 * Checks if the primitive is translucent (partially transparent).
 * @param primitive - The primitive to check
 * @returns True if the primitive is translucent, false otherwise
 */
declare function isTranslucent(primitive: Primitive): boolean;
/**
 * Checks if the primitive is opaque (fully solid, not transparent).
 * @param primitive - The primitive to check
 * @returns True if the primitive is opaque, false otherwise
 */
declare function isOpaque(primitive: Primitive): boolean;

/**
 * Immutable 3x3 matrix class for 3D transformations.
 * Matrix values are stored in column-major order for WebGL compatibility.
 * Provides various matrix operations including rotation, scaling, and multiplication.
 *
 * @example
 * ```typescript
 * // Create identity matrix
 * const identity = Matrix33.identity();
 *
 * // Create rotation matrix
 * const rotation = Matrix33.rotateZ(Math.PI / 4);
 *
 * // Create scale matrix
 * const scale = Matrix33.scale(Vector3.fromCopyArray([2, 2, 2]));
 *
 * // Matrix multiplication
 * const result = Matrix33.multiply(rotation, scale);
 * ```
 */
declare class Matrix33 extends AbstractMatrix implements IMatrix, IMatrix33 {
    /**
     * Creates a new Matrix33 instance.
     * @param m - Float32Array containing 9 matrix values in column-major order
     */
    constructor(m: Float32Array);
    /**
     * Gets the matrix element at row 0, column 0.
     * @returns The m00 component
     */
    get m00(): number;
    /**
     * Gets the matrix element at row 1, column 0.
     * @returns The m10 component
     */
    get m10(): number;
    /**
     * Gets the matrix element at row 2, column 0.
     * @returns The m20 component
     */
    get m20(): number;
    /**
     * Gets the matrix element at row 0, column 1.
     * @returns The m01 component
     */
    get m01(): number;
    /**
     * Gets the matrix element at row 1, column 1.
     * @returns The m11 component
     */
    get m11(): number;
    /**
     * Gets the matrix element at row 2, column 1.
     * @returns The m21 component
     */
    get m21(): number;
    /**
     * Gets the matrix element at row 0, column 2.
     * @returns The m02 component
     */
    get m02(): number;
    /**
     * Gets the matrix element at row 1, column 2.
     * @returns The m12 component
     */
    get m12(): number;
    /**
     * Gets the matrix element at row 2, column 2.
     * @returns The m22 component
     */
    get m22(): number;
    /**
     * Gets the class name.
     * @returns The string "Matrix33"
     */
    get className(): string;
    /**
     * Gets the matrix as a GLSL mat3 string with float precision.
     * @returns GLSL mat3 constructor string
     */
    get glslStrAsFloat(): string;
    /**
     * Gets the matrix as a GLSL mat3 string with integer values.
     * @returns GLSL mat3 constructor string with floored values
     */
    get glslStrAsInt(): string;
    /**
     * Gets the matrix as a WGSL mat3x3f string with float precision.
     * @returns WGSL mat3x3f constructor string
     */
    get wgslStrAsFloat(): string;
    /**
     * Gets the matrix as a WGSL mat3x3i string with integer values.
     * @returns WGSL mat3x3i constructor string with floored values
     */
    get wgslStrAsInt(): string;
    /**
     * Gets the composition type for this matrix.
     * @returns CompositionType.Mat3
     */
    static get compositionType(): {
        readonly __numberOfComponents: number;
        readonly __glslStr: string;
        readonly __hlslStr: string;
        readonly __webgpuStr: string;
        readonly __wgslStr: string;
        readonly __isArray: boolean;
        readonly __vec4SizeOfProperty: IndexOf16Bytes;
        readonly __dummyStr: "MAT3";
        readonly webgpu: string;
        readonly wgsl: string;
        getNumberOfComponents(): Count;
        getGlslStr(componentType: ComponentTypeEnum): string;
        getGlslInitialValue(componentType: ComponentTypeEnum): string;
        getWgslInitialValue(componentType: ComponentTypeEnum): string;
        toWGSLType(componentType: ComponentTypeEnum): string;
        getVec4SizeOfProperty(): IndexOf16Bytes;
        readonly index: number;
        readonly symbol: symbol;
        readonly str: string;
        toString(): string;
        toJSON(): number;
    };
    /**
     * Creates a zero matrix (all elements are 0).
     * @returns A new Matrix33 with all zero elements
     */
    static zero(): Matrix33;
    /**
     * Creates an identity matrix.
     * @returns A new identity matrix (optimized IdentityMatrix33 instance)
     */
    static identity(): IMatrix33;
    /**
     * Creates a dummy matrix with empty data array.
     * Used for placeholder purposes.
     * @returns A new Matrix33 with empty Float32Array
     */
    static dummy(): Matrix33;
    /**
     * Creates the transpose of the given matrix.
     * @param mat - The matrix to transpose
     * @returns A new transposed matrix
     */
    static transpose(mat: IMatrix33): IMatrix33;
    /**
     * Creates the inverse of the given matrix.
     * @param mat - The matrix to invert
     * @returns A new inverted matrix
     * @throws Will log an error if the matrix is not invertible (determinant is 0)
     */
    static invert(mat: IMatrix33): IMatrix33 | Matrix33;
    /**
     * Calculates the inverse of the given matrix and stores the result in the output matrix.
     * @param mat - The matrix to invert
     * @param outMat - The output mutable matrix to store the result
     * @returns The output matrix containing the inverted matrix
     * @throws Will log an error if the matrix is not invertible (determinant is 0)
     */
    static invertTo(mat: IMatrix33, outMat: MutableMatrix33): MutableMatrix33;
    /**
     * Creates a rotation matrix around the X-axis.
     * @param radian - The rotation angle in radians
     * @returns A new rotation matrix
     */
    static rotateX(radian: number): Matrix33;
    /**
     * Creates a rotation matrix around the Y-axis.
     * @param radian - The rotation angle in radians
     * @returns A new rotation matrix
     */
    static rotateY(radian: number): Matrix33;
    /**
     * Creates a rotation matrix around the Z-axis.
     * @param radian - The rotation angle in radians
     * @returns A new rotation matrix
     */
    static rotateZ(radian: number): Matrix33;
    /**
     * Creates a rotation matrix from Euler angles in XYZ order.
     * @param x - Rotation around X-axis in radians
     * @param y - Rotation around Y-axis in radians
     * @param z - Rotation around Z-axis in radians
     * @returns A new rotation matrix representing the combined rotations
     */
    static rotateXYZ(x: number, y: number, z: number): Matrix33;
    /**
     * Creates a rotation matrix from a Vector3 containing Euler angles.
     * @param vec - Vector3 containing rotation angles (x, y, z) in radians
     * @returns A new rotation matrix
     */
    static rotate(vec: Vector3): Matrix33;
    /**
     * Creates a scaling matrix.
     * @param vec - Vector3 containing scale factors for each axis
     * @returns A new scaling matrix
     */
    static scale(vec: IVector3): Matrix33;
    /**
     * Multiplies two matrices together.
     * @param l_mat - The left matrix
     * @param r_mat - The right matrix
     * @returns A new matrix representing l_mat * r_mat
     */
    static multiply(l_mat: IMatrix33, r_mat: IMatrix33): IMatrix33;
    /**
     * Multiplies two matrices and stores the result in an output matrix.
     * @param l_mat - The left matrix
     * @param r_mat - The right matrix
     * @param outMat - The output mutable matrix to store the result
     * @returns The output matrix containing l_mat * r_mat
     */
    static multiplyTo(l_mat: IMatrix33, r_mat: IMatrix33, outMat: MutableMatrix33): MutableMatrix33;
    /**
     * Converts the matrix to a human-readable string representation.
     * @returns A formatted string showing the matrix in 3x3 layout
     */
    toString(): string;
    /**
     * Converts the matrix to a human-readable string with rounded values.
     * @returns A formatted string showing the matrix with financially rounded values
     */
    toStringApproximately(): string;
    /**
     * Converts the matrix to a flat array in column-major order.
     * @returns An array containing all 9 matrix elements
     */
    flattenAsArray(): number[];
    /**
     * Checks if this matrix is a dummy matrix (empty data array).
     * @returns True if the matrix has no data, false otherwise
     */
    isDummy(): boolean;
    /**
     * Checks if this matrix is approximately equal to another matrix.
     * @param mat - The matrix to compare with
     * @param delta - The tolerance for comparison (default: Number.EPSILON)
     * @returns True if matrices are approximately equal, false otherwise
     */
    isEqual(mat: IMatrix33, delta?: number): boolean;
    /**
     * Checks if this matrix is strictly equal to another matrix.
     * @param mat - The matrix to compare with
     * @returns True if all elements are exactly equal, false otherwise
     */
    isStrictEqual(mat: Matrix33): boolean;
    /**
     * Gets the matrix element at the specified row and column.
     * @param row_i - The row index (0-2)
     * @param column_i - The column index (0-2)
     * @returns The matrix element at the specified position
     */
    at(row_i: number, column_i: number): number;
    /**
     * Gets the matrix element at the specified index in the internal array.
     * @param i - The index (0-8)
     * @returns The matrix element at the specified index
     */
    v(i: number): number;
    /**
     * Calculates the determinant of this matrix.
     * @returns The determinant value
     */
    determinant(): number;
    /**
     * Multiplies this matrix with a vector.
     * @param vec - The vector to multiply
     * @returns A new vector representing the result of matrix * vector
     */
    multiplyVector(vec: IVector3): any;
    /**
     * Multiplies this matrix with a vector and stores the result in an output vector.
     * @param vec - The vector to multiply
     * @param outVec - The output mutable vector to store the result
     * @returns The output vector containing the result of matrix * vector
     */
    multiplyVectorTo(vec: IVector3, outVec: IMutableVector3): IMutableVector3;
    /**
     * Extracts the scale factors from this matrix.
     * @returns A new Vector3 containing the scale factors for each axis
     */
    getScale(): Vector3;
    /**
     * Extracts the scale factors from this matrix and stores them in an output vector.
     * @param outVec - The output mutable vector to store the scale factors
     * @returns The output vector containing the scale factors
     */
    getScaleTo(outVec: MutableVector3): MutableVector3;
    /**
     * Creates a deep copy of this matrix.
     * @returns A new Matrix33 instance with the same values
     */
    clone(): any;
    /**
     * Creates a Matrix33 from 9 values in row-major order.
     * Values are stored internally in column-major order for WebGL compatibility.
     * @param m00 - Element at row 0, column 0
     * @param m01 - Element at row 0, column 1
     * @param m02 - Element at row 0, column 2
     * @param m10 - Element at row 1, column 0
     * @param m11 - Element at row 1, column 1
     * @param m12 - Element at row 1, column 2
     * @param m20 - Element at row 2, column 0
     * @param m21 - Element at row 2, column 1
     * @param m22 - Element at row 2, column 2
     * @returns A new Matrix33 instance
     */
    static fromCopy9RowMajor(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): Matrix33;
    /**
     * Creates a Matrix33 from 9 values in column-major order.
     * @param m00 - Element at row 0, column 0
     * @param m10 - Element at row 1, column 0
     * @param m20 - Element at row 2, column 0
     * @param m01 - Element at row 0, column 1
     * @param m11 - Element at row 1, column 1
     * @param m21 - Element at row 2, column 1
     * @param m02 - Element at row 0, column 2
     * @param m12 - Element at row 1, column 2
     * @param m22 - Element at row 2, column 2
     * @returns A new Matrix33 instance
     */
    static fromCopy9ColumnMajor(m00: number, m10: number, m20: number, m01: number, m11: number, m21: number, m02: number, m12: number, m22: number): Matrix33;
    /**
     * Creates a Matrix33 from the upper-left 3x3 portion of a Matrix44.
     * @param mat - The Matrix44 to extract from
     * @returns A new Matrix33 instance
     */
    static fromCopyMatrix44(mat: Matrix44): Matrix33;
    /**
     * Creates a Matrix33 using the provided Float32Array directly (no copy).
     * @param float32Array - The Float32Array in column-major order
     * @returns A new Matrix33 instance
     */
    static fromFloat32ArrayColumnMajor(float32Array: Float32Array): Matrix33;
    /**
     * Creates a Matrix33 by copying from a Float32Array in column-major order.
     * @param float32Array - The Float32Array to copy from
     * @returns A new Matrix33 instance
     */
    static fromCopyFloat32ArrayColumnMajor(float32Array: Float32Array): Matrix33;
    /**
     * Creates a Matrix33 by copying from a Float32Array in row-major order.
     * @param array - The Float32Array in row-major order
     * @returns A new Matrix33 instance
     */
    static fromCopyFloat32ArrayRowMajor(array: Float32Array): Matrix33;
    /**
     * Creates a Matrix33 by copying from another IMatrix33.
     * @param mat - The matrix to copy from
     * @returns A new Matrix33 instance
     */
    static fromCopyMatrix33(mat: IMatrix33): Matrix33;
    /**
     * Creates a Matrix33 from an Array9 in column-major order.
     * @param array - The Array9 containing 9 numbers
     * @returns A new Matrix33 instance
     */
    static fromCopyArray9ColumnMajor(array: Array9<number>): Matrix33;
    /**
     * Creates a Matrix33 from a regular array in column-major order.
     * @param array - The array containing at least 9 numbers
     * @returns A new Matrix33 instance
     */
    static fromCopyArrayColumnMajor(array: Array<number>): Matrix33;
    /**
     * Creates a Matrix33 from an Array9 in row-major order.
     * @param array - The Array9 containing 9 numbers in row-major order
     * @returns A new Matrix33 instance
     */
    static fromCopyArray9RowMajor(array: Array9<number>): Matrix33;
    /**
     * Creates a Matrix33 from a regular array in row-major order.
     * @param array - The array containing at least 9 numbers in row-major order
     * @returns A new Matrix33 instance
     */
    static fromCopyArrayRowMajor(array: Array<number>): Matrix33;
    /**
     * Creates a Matrix33 from a quaternion representing rotation.
     * @param q - The quaternion to convert
     * @returns A new Matrix33 representing the rotation
     */
    static fromCopyQuaternion(q: Quaternion): Matrix33;
}

/**
 * A mutable 3x3 matrix class that extends Matrix33 and provides mutating operations.
 * This class stores matrix data in column-major order as a Float32Array.
 * All transformation methods modify the matrix in place and return the same instance for method chaining.
 *
 * Matrix layout in memory (column-major order):
 * ```
 * [m00, m10, m20, m01, m11, m21, m02, m12, m22]
 *  [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]  [8]
 * ```
 *
 * Which represents the matrix:
 * ```
 * | m00  m01  m02 |
 * | m10  m11  m12 |
 * | m20  m21  m22 |
 * ```
 */
declare class MutableMatrix33 extends Matrix33 implements IMutableMatrix, IMutableMatrix33 {
    /**
     * Sets the matrix element at position (0,0).
     * @param val - The value to set
     */
    set m00(val: number);
    /**
     * Gets the matrix element at position (0,0).
     * @returns The value at position (0,0)
     */
    get m00(): number;
    /**
     * Sets the matrix element at position (1,0).
     * @param val - The value to set
     */
    set m10(val: number);
    /**
     * Gets the matrix element at position (1,0).
     * @returns The value at position (1,0)
     */
    get m10(): number;
    /**
     * Sets the matrix element at position (2,0).
     * @param val - The value to set
     */
    set m20(val: number);
    /**
     * Gets the matrix element at position (2,0).
     * @returns The value at position (2,0)
     */
    get m20(): number;
    /**
     * Sets the matrix element at position (0,1).
     * @param val - The value to set
     */
    set m01(val: number);
    /**
     * Gets the matrix element at position (0,1).
     * @returns The value at position (0,1)
     */
    get m01(): number;
    /**
     * Sets the matrix element at position (1,1).
     * @param val - The value to set
     */
    set m11(val: number);
    /**
     * Gets the matrix element at position (1,1).
     * @returns The value at position (1,1)
     */
    get m11(): number;
    /**
     * Sets the matrix element at position (2,1).
     * @param val - The value to set
     */
    set m21(val: number);
    /**
     * Gets the matrix element at position (2,1).
     * @returns The value at position (2,1)
     */
    get m21(): number;
    /**
     * Sets the matrix element at position (0,2).
     * @param val - The value to set
     */
    set m02(val: number);
    /**
     * Gets the matrix element at position (0,2).
     * @returns The value at position (0,2)
     */
    get m02(): number;
    /**
     * Sets the matrix element at position (1,2).
     * @param val - The value to set
     */
    set m12(val: number);
    /**
     * Gets the matrix element at position (1,2).
     * @returns The value at position (1,2)
     */
    get m12(): number;
    /**
     * Sets the matrix element at position (2,2).
     * @param val - The value to set
     */
    set m22(val: number);
    /**
     * Gets the matrix element at position (2,2).
     * @returns The value at position (2,2)
     */
    get m22(): number;
    /**
     * Gets the class name for debugging purposes.
     * @returns The string 'MutableMatrix33'
     */
    get className(): string;
    /**
     * Creates a new zero matrix (all elements set to 0).
     * @returns A new MutableMatrix33 instance with all elements set to 0
     */
    static zero(): MutableMatrix33;
    /**
     * Creates a new identity matrix.
     * @returns A new MutableMatrix33 instance representing the identity matrix
     */
    static identity(): MutableMatrix33;
    /**
     * Creates a dummy matrix for testing purposes.
     * @returns A new MutableMatrix33 instance with default values
     */
    static dummy(): MutableMatrix33;
    /**
     * Creates a new matrix that is the transpose of the input matrix.
     * @param mat - The matrix to transpose
     * @returns A new MutableMatrix33 instance representing the transposed matrix
     */
    static transpose(mat: IMatrix33): MutableMatrix33;
    /**
     * Creates a new matrix that is the inverse of the input matrix.
     * @param mat - The matrix to invert
     * @returns A new MutableMatrix33 instance representing the inverted matrix
     */
    static invert(mat: IMatrix33): MutableMatrix33;
    /**
     * Creates a rotation matrix around the X-axis.
     * @param radian - The rotation angle in radians
     * @returns A new MutableMatrix33 instance representing the X-axis rotation
     */
    static rotateX(radian: number): MutableMatrix33;
    /**
     * Creates a rotation matrix around the Y-axis.
     * @param radian - The rotation angle in radians
     * @returns A new MutableMatrix33 instance representing the Y-axis rotation
     */
    static rotateY(radian: number): MutableMatrix33;
    /**
     * Creates a rotation matrix around the Z-axis.
     * @param radian - The rotation angle in radians
     * @returns A new MutableMatrix33 instance representing the Z-axis rotation
     */
    static rotateZ(radian: number): MutableMatrix33;
    /**
     * Creates a rotation matrix for combined X, Y, and Z axis rotations applied in that order.
     * @param x - Rotation angle around X-axis in radians
     * @param y - Rotation angle around Y-axis in radians
     * @param z - Rotation angle around Z-axis in radians
     * @returns A new MutableMatrix33 instance representing the combined rotation
     */
    static rotateXYZ(x: number, y: number, z: number): MutableMatrix33;
    /**
     * Creates a rotation matrix from a vector containing rotation angles.
     * @param vec - A vector containing rotation angles for X, Y, and Z axes
     * @returns A new MutableMatrix33 instance representing the rotation
     */
    static rotate(vec: IVector3): MutableMatrix33;
    /**
     * Creates a scaling matrix from a vector.
     * @param vec - A vector containing scale factors for X, Y, and Z axes
     * @returns A new MutableMatrix33 instance representing the scaling transformation
     */
    static scale(vec: IVector3): MutableMatrix33;
    /**
     * Multiplies two matrices and returns the result as a new matrix.
     * @param l_mat - The left matrix operand
     * @param r_mat - The right matrix operand
     * @returns A new MutableMatrix33 instance representing l_mat * r_mat
     */
    static multiply(l_mat: IMatrix33, r_mat: IMatrix33): MutableMatrix33;
    /**
     * Creates a copy of this matrix.
     * @returns A new MutableMatrix33 instance with the same values
     */
    clone(): MutableMatrix33;
    /**
     * Gets the raw Float32Array containing the matrix data.
     * @returns The underlying Float32Array in column-major order
     */
    raw(): Float32Array<ArrayBufferLike>;
    /**
     * Sets a value at the specified row and column position.
     * @param row_i - The row index (0-2)
     * @param column_i - The column index (0-2)
     * @param value - The value to set
     * @returns This matrix instance for method chaining
     */
    setAt(row_i: number, column_i: number, value: number): this;
    /**
     * Sets all matrix components using row-major order parameters.
     * @param m00 - Element at position (0,0)
     * @param m01 - Element at position (0,1)
     * @param m02 - Element at position (0,2)
     * @param m10 - Element at position (1,0)
     * @param m11 - Element at position (1,1)
     * @param m12 - Element at position (1,2)
     * @param m20 - Element at position (2,0)
     * @param m21 - Element at position (2,1)
     * @param m22 - Element at position (2,2)
     * @returns This matrix instance for method chaining
     */
    setComponents(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): MutableMatrix33;
    /**
     * Copies components from another matrix (3x3 or 4x4) into this matrix.
     * For 4x4 matrices, only the upper-left 3x3 portion is copied.
     * @param mat - The source matrix to copy from
     * @returns This matrix instance for method chaining
     */
    copyComponents(mat: IMatrix33 | IMatrix44): this;
    /**
     * Sets this matrix to the zero matrix (all elements set to 0).
     * @returns This matrix instance for method chaining
     */
    zero(): MutableMatrix33;
    /**
     * Sets this matrix to the identity matrix.
     * @returns This matrix instance for method chaining
     */
    identity(): MutableMatrix33;
    /**
     * Swaps two elements in the internal array.
     * @param l - Index of the first element
     * @param r - Index of the second element
     * @private
     */
    _swap(l: Index, r: Index): void;
    /**
     * Transposes this matrix in place.
     * @returns This matrix instance for method chaining
     */
    transpose(): this;
    /**
     * Inverts this matrix in place using the determinant method.
     * Logs an error if the determinant is 0 (matrix is not invertible).
     * @returns This matrix instance for method chaining
     */
    invert(): MutableMatrix33;
    /**
     * Sets this matrix to a rotation matrix around the X-axis.
     * @param radian - The rotation angle in radians
     * @returns This matrix instance for method chaining
     */
    rotateX(radian: number): MutableMatrix33;
    /**
     * Sets this matrix to a rotation matrix around the Y-axis.
     * @param radian - The rotation angle in radians
     * @returns This matrix instance for method chaining
     */
    rotateY(radian: number): MutableMatrix33;
    /**
     * Sets this matrix to a rotation matrix around the Z-axis.
     * @param radian - The rotation angle in radians
     * @returns This matrix instance for method chaining
     */
    rotateZ(radian: number): MutableMatrix33;
    /**
     * Sets this matrix to a rotation matrix for combined X, Y, and Z axis rotations.
     * Rotations are applied in the order: Z * Y * X (which means X is applied first, then Y, then Z).
     * @param x - Rotation angle around X-axis in radians
     * @param y - Rotation angle around Y-axis in radians
     * @param z - Rotation angle around Z-axis in radians
     * @returns This matrix instance for method chaining
     */
    rotateXYZ(x: number, y: number, z: number): MutableMatrix33;
    /**
     * Sets this matrix to a rotation matrix from a vector containing rotation angles.
     * @param vec - A vector containing rotation angles for X, Y, and Z axes in radians
     * @returns This matrix instance for method chaining
     */
    rotate(vec: Vector3): MutableMatrix33;
    /**
     * Sets this matrix to a scaling matrix.
     * @param vec - A vector containing scale factors for X, Y, and Z axes
     * @returns This matrix instance for method chaining
     */
    scale(vec: Vector3): MutableMatrix33;
    /**
     * Multiplies this matrix by a scale matrix, applying scaling to the existing transformation.
     * Each column of the matrix is scaled by the corresponding component of the vector.
     * @param vec - A vector containing scale factors for X, Y, and Z axes
     * @returns This matrix instance for method chaining
     */
    multiplyScale(vec: Vector3): this;
    /**
     * Multiplies this matrix by another matrix from the right side (this = this * mat).
     * If the input matrix is an identity matrix, no operation is performed for optimization.
     * @param mat - The matrix to multiply with from the right
     * @returns This matrix instance for method chaining
     */
    multiply(mat: Matrix33): MutableMatrix33;
    /**
     * Multiplies this matrix by another matrix from the left side (this = mat * this).
     * If the input matrix is an identity matrix, no operation is performed for optimization.
     * @param mat - The matrix to multiply with from the left
     * @returns This matrix instance for method chaining
     */
    multiplyByLeft(mat: Matrix33): MutableMatrix33;
    /**
     * Creates a new matrix from 9 values specified in row-major order.
     * This is more intuitive when writing matrix values as they appear visually.
     * @param m00 - Element at position (0,0)
     * @param m01 - Element at position (0,1)
     * @param m02 - Element at position (0,2)
     * @param m10 - Element at position (1,0)
     * @param m11 - Element at position (1,1)
     * @param m12 - Element at position (1,2)
     * @param m20 - Element at position (2,0)
     * @param m21 - Element at position (2,1)
     * @param m22 - Element at position (2,2)
     * @returns A new MutableMatrix33 instance
     */
    static fromCopy9RowMajor(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): MutableMatrix33;
    /**
     * Creates a new matrix from 9 values specified in column-major order.
     * This matches the internal storage format of WebGL matrices.
     * @param m00 - Element at position (0,0)
     * @param m10 - Element at position (1,0)
     * @param m20 - Element at position (2,0)
     * @param m01 - Element at position (0,1)
     * @param m11 - Element at position (1,1)
     * @param m21 - Element at position (2,1)
     * @param m02 - Element at position (0,2)
     * @param m12 - Element at position (1,2)
     * @param m22 - Element at position (2,2)
     * @returns A new MutableMatrix33 instance
     */
    static fromCopy9ColumnMajor(m00: number, m10: number, m20: number, m01: number, m11: number, m21: number, m02: number, m12: number, m22: number): MutableMatrix33;
    /**
     * Creates a new 3x3 matrix by copying the upper-left 3x3 portion of a 4x4 matrix.
     * @param mat - The 4x4 matrix to copy from
     * @returns A new MutableMatrix33 instance
     */
    static fromCopyMatrix44(mat: Matrix44): MutableMatrix33;
    /**
     * Creates a new matrix using the provided Float32Array directly (no copy).
     * The array should contain 9 elements in column-major order.
     * @param float32Array - A Float32Array containing the matrix data
     * @returns A new MutableMatrix33 instance that shares the array reference
     */
    static fromFloat32ArrayColumnMajor(float32Array: Float32Array): MutableMatrix33;
    /**
     * Creates a new matrix by copying data from a Float32Array in column-major order.
     * @param float32Array - A Float32Array containing the matrix data to copy
     * @returns A new MutableMatrix33 instance with copied data
     */
    static fromCopyFloat32ArrayColumnMajor(float32Array: Float32Array): MutableMatrix33;
    /**
     * Creates a new matrix by copying data from a Float32Array in row-major order.
     * The data is converted to column-major order during the copy process.
     * @param array - A Float32Array containing the matrix data in row-major order
     * @returns A new MutableMatrix33 instance with converted data
     */
    static fromCopyFloat32ArrayRowMajor(array: Float32Array): MutableMatrix33;
    /**
     * Creates a new matrix by copying from another 3x3 matrix.
     * @param mat - The source matrix to copy from
     * @returns A new MutableMatrix33 instance with copied data
     */
    static fromCopyMatrix33(mat: IMatrix33): MutableMatrix33;
    /**
     * Creates a new matrix from a 9-element array in column-major order.
     * @param array - An array containing exactly 9 numbers in column-major order
     * @returns A new MutableMatrix33 instance
     */
    static fromCopyArray9ColumnMajor(array: Array9<number>): MutableMatrix33;
    /**
     * Creates a new matrix from an array in column-major order.
     * Only the first 9 elements are used if the array is larger.
     * @param array - An array containing the matrix data in column-major order
     * @returns A new MutableMatrix33 instance
     */
    static fromCopyArrayColumnMajor(array: Array<number>): MutableMatrix33;
    /**
     * Creates a new matrix from a 9-element array in row-major order.
     * The data is converted to column-major order during the creation process.
     * @param array - An array containing exactly 9 numbers in row-major order
     * @returns A new MutableMatrix33 instance
     */
    static fromCopyArray9RowMajor(array: Array9<number>): MutableMatrix33;
    /**
     * Creates a new matrix from an array in row-major order.
     * Only the first 9 elements are used if the array is larger.
     * The data is converted to column-major order during the creation process.
     * @param array - An array containing the matrix data in row-major order
     * @returns A new MutableMatrix33 instance
     */
    static fromCopyArrayRowMajor(array: Array<number>): MutableMatrix33;
    /**
     * Creates a new rotation matrix from a quaternion.
     * Converts the quaternion representation to its equivalent 3x3 rotation matrix.
     * @param q - The quaternion to convert (should be normalized)
     * @returns A new MutableMatrix33 instance representing the rotation
     */
    static fromCopyQuaternion(q: IQuaternion): MutableMatrix33;
}

/**
 * A mutable quaternion class that extends the immutable Quaternion class.
 * Provides methods for quaternion operations that modify the instance in place.
 * Quaternions are used to represent rotations in 3D space and are particularly
 * useful for avoiding gimbal lock and providing smooth interpolations.
 */
declare class MutableQuaternion extends Quaternion implements IMutableQuaternion {
    /**
     * Sets the x component of the quaternion.
     * @param x - The x component value
     */
    set x(x: number);
    /**
     * Gets the x component of the quaternion.
     * @returns The x component value
     */
    get x(): number;
    /**
     * Sets the y component of the quaternion.
     * @param y - The y component value
     */
    set y(y: number);
    /**
     * Gets the y component of the quaternion.
     * @returns The y component value
     */
    get y(): number;
    /**
     * Sets the z component of the quaternion.
     * @param z - The z component value
     */
    set z(z: number);
    /**
     * Gets the z component of the quaternion.
     * @returns The z component value
     */
    get z(): number;
    /**
     * Sets the w component of the quaternion.
     * @param w - The w component value
     */
    set w(w: number);
    /**
     * Gets the w component of the quaternion.
     * @returns The w component value
     */
    get w(): number;
    /**
     * Gets the class name for identification purposes.
     * @returns The string 'MutableQuaternion'
     */
    get className(): string;
    /**
     * Creates an identity quaternion (0, 0, 0, 1).
     * @returns A new MutableQuaternion representing no rotation
     */
    static identity(): MutableQuaternion;
    /**
     * Creates a dummy quaternion with empty array (for initialization purposes).
     * @returns A new MutableQuaternion with zero-length array
     */
    static dummy(): MutableQuaternion;
    /**
     * Inverts a quaternion and returns a new MutableQuaternion.
     * @param quat - The quaternion to invert
     * @returns A new MutableQuaternion representing the inverse rotation
     */
    static invert(quat: IQuaternion): MutableQuaternion;
    /**
     * Performs spherical linear interpolation (SLERP) between two quaternions.
     * @param l_quat - The starting quaternion
     * @param r_quat - The ending quaternion
     * @param ratio - Interpolation factor (0.0 to 1.0)
     * @returns A new MutableQuaternion representing the interpolated rotation
     */
    static qlerp(l_quat: IQuaternion, r_quat: IQuaternion, ratio: number): MutableQuaternion;
    /**
     * Performs linear interpolation between two quaternions.
     * @param l_quat - The starting quaternion
     * @param r_quat - The ending quaternion
     * @param ratio - Interpolation factor (0.0 to 1.0)
     * @returns A new MutableQuaternion representing the interpolated rotation
     */
    static lerp(l_quat: IQuaternion, r_quat: IQuaternion, ratio: number): MutableQuaternion;
    /**
     * Creates a quaternion from an axis and angle.
     * @param vec - The rotation axis (normalized vector recommended)
     * @param radian - The rotation angle in radians
     * @returns A new MutableQuaternion representing the axis-angle rotation
     */
    static axisAngle(vec: IVector3, radian: number): MutableQuaternion;
    /**
     * Creates a quaternion from a rotation matrix.
     * @param mat - The 4x4 transformation matrix
     * @returns A new MutableQuaternion representing the matrix's rotation
     */
    static fromMatrix(mat: IMatrix44): MutableQuaternion;
    /**
     * Creates a quaternion from a position vector (w component set to 0).
     * @param vec - The position vector
     * @returns A new MutableQuaternion with position data
     */
    static fromPosition(vec: IVector3): MutableQuaternion;
    /**
     * Adds two quaternions component-wise.
     * @param l_quat - The left quaternion
     * @param r_quat - The right quaternion
     * @returns A new MutableQuaternion representing the sum
     */
    static add(l_quat: IQuaternion, r_quat: IQuaternion): MutableQuaternion;
    /**
     * Subtracts the second quaternion from the first component-wise.
     * @param l_quat - The left quaternion
     * @param r_quat - The right quaternion
     * @returns A new MutableQuaternion representing the difference
     */
    static subtract(l_quat: IQuaternion, r_quat: IQuaternion): MutableQuaternion;
    /**
     * Multiplies two quaternions (quaternion composition).
     * @param l_quat - The left quaternion
     * @param r_quat - The right quaternion
     * @returns A new MutableQuaternion representing the composed rotation
     */
    static multiply(l_quat: IQuaternion, r_quat: IQuaternion): MutableQuaternion;
    /**
     * Multiplies a quaternion by a scalar value.
     * @param quat - The quaternion to multiply
     * @param value - The scalar value
     * @returns A new MutableQuaternion representing the scaled quaternion
     */
    static multiplyNumber(quat: IQuaternion, value: number): MutableQuaternion;
    /**
     * Divides a quaternion by a scalar value.
     * @param quat - The quaternion to divide
     * @param value - The scalar value (must not be zero)
     * @returns A new MutableQuaternion representing the scaled quaternion
     */
    static divideNumber(quat: IQuaternion, value: number): MutableQuaternion;
    /**
     * Gets the raw Float32Array containing the quaternion components.
     * @returns The underlying Float32Array [x, y, z, w]
     */
    raw(): Float32Array<ArrayBufferLike>;
    /**
     * Sets a component value at the specified index.
     * @param i - The component index (0=x, 1=y, 2=z, 3=w)
     * @param value - The value to set
     * @returns This instance for method chaining
     */
    setAt(i: number, value: number): this;
    /**
     * Sets all quaternion components.
     * @param x - The x component
     * @param y - The y component
     * @param z - The z component
     * @param w - The w component
     * @returns This instance for method chaining
     */
    setComponents(x: number, y: number, z: number, w: number): this;
    /**
     * Copies components from another quaternion.
     * @param quat - The quaternion to copy from
     * @returns This instance for method chaining
     */
    copyComponents(quat: IQuaternion): this;
    /**
     * Sets this quaternion to the identity quaternion (0, 0, 0, 1).
     * @returns This instance for method chaining
     */
    identity(): this;
    /**
     * Normalizes this quaternion to unit length in place.
     * @returns This instance for method chaining
     */
    normalize(): this;
    /**
     * Inverts this quaternion in place (conjugate divided by magnitude squared).
     * @returns This instance for method chaining
     */
    invert(): this;
    /**
     * Performs spherical linear interpolation (SLERP) and stores the result in this quaternion.
     * @param l_quat - The starting quaternion
     * @param r_quat - The ending quaternion
     * @param ratio - Interpolation factor (0.0 to 1.0)
     * @returns This instance for method chaining
     */
    qlerp(l_quat: IQuaternion, r_quat: IQuaternion, ratio: number): this;
    /**
     * Performs linear interpolation and stores the result in this quaternion.
     * @param l_quat - The starting quaternion
     * @param r_quat - The ending quaternion
     * @param ratio - Interpolation factor (0.0 to 1.0)
     * @returns This instance for method chaining
     */
    lerp(l_quat: IQuaternion, r_quat: IQuaternion, ratio: number): this;
    /**
     * Sets this quaternion from an axis and angle.
     * @param vec - The rotation axis (will be normalized)
     * @param radian - The rotation angle in radians
     * @returns This instance for method chaining
     */
    axisAngle(vec: IVector3, radian: number): this;
    /**
     * Sets this quaternion from a 4x4 transformation matrix.
     * Extracts the rotation component from the matrix, ignoring scale and translation.
     * @param mat - The 4x4 transformation matrix
     * @returns This instance for method chaining
     */
    fromMatrix(mat: IMatrix44): this;
    /**
     * Sets this quaternion from a position vector (w component set to 0).
     * @param vec - The position vector
     * @returns This instance for method chaining
     */
    fromPosition(vec: IVector3): this;
    /**
     * Adds another quaternion to this quaternion component-wise.
     * @param quat - The quaternion to add
     * @returns This instance for method chaining
     */
    add(quat: IQuaternion): this;
    /**
     * Subtracts another quaternion from this quaternion component-wise.
     * @param quat - The quaternion to subtract
     * @returns This instance for method chaining
     */
    subtract(quat: IQuaternion): this;
    /**
     * Multiplies this quaternion by another quaternion (quaternion composition).
     * The result represents the combined rotation.
     * @param quat - The quaternion to multiply by
     * @returns This instance for method chaining
     */
    multiply(quat: IQuaternion): this;
    /**
     * Multiplies this quaternion by a scalar value.
     * @param value - The scalar value to multiply by
     * @returns This instance for method chaining
     */
    multiplyNumber(value: number): this;
    /**
     * Divides this quaternion by a scalar value.
     * @param value - The scalar value to divide by (must not be zero)
     * @returns This instance for method chaining
     */
    divideNumber(value: number): this;
    /**
     * Creates a copy of this quaternion.
     * @returns A new IMutableQuaternion with the same component values
     */
    clone(): IMutableQuaternion;
    /**
     * Creates a MutableQuaternion from an existing Float32Array.
     * @param array - The Float32Array containing quaternion components
     * @returns A new MutableQuaternion instance
     */
    static fromFloat32Array(array: Float32Array): MutableQuaternion;
    /**
     * Creates a MutableQuaternion by copying from a 4-element array.
     * @param array - Array containing [x, y, z, w] components
     * @returns A new MutableQuaternion instance
     */
    static fromCopyArray4(array: Array4<number>): MutableQuaternion;
    /**
     * Creates a MutableQuaternion by copying from an array (takes first 4 elements).
     * @param array - Array containing quaternion components
     * @returns A new MutableQuaternion instance
     */
    static fromCopyArray(array: Array<number>): MutableQuaternion;
    /**
     * Creates a MutableQuaternion from individual component values.
     * @param x - The x component
     * @param y - The y component
     * @param z - The z component
     * @param w - The w component
     * @returns A new MutableQuaternion instance
     */
    static fromCopy4(x: number, y: number, z: number, w: number): MutableQuaternion;
    /**
     * Creates a MutableQuaternion by copying from another quaternion.
     * @param quat - The quaternion to copy from
     * @returns A new MutableQuaternion instance
     */
    static fromCopyQuaternion(quat: IQuaternion): MutableQuaternion;
    /**
     * Creates a MutableQuaternion by copying from a 4D vector.
     * @param vec - The 4D vector to copy from
     * @returns A new MutableQuaternion instance
     */
    static fromCopyVector4(vec: IVector4): MutableQuaternion;
    /**
     * Creates a MutableQuaternion from a logarithmic quaternion.
     * Converts from log space back to quaternion space using exponential map.
     * @param x - The logarithmic quaternion to convert
     * @returns A new MutableQuaternion instance
     */
    static fromCopyLogQuaternion(x: ILogQuaternion): MutableQuaternion;
}

/**
 * SceneGraphComponent is a component that represents a node in the scene graph.
 * It manages hierarchical relationships between entities and handles world matrix calculations.
 */
declare class SceneGraphComponent extends Component {
    private __parent?;
    private __children;
    private __gizmoChildren;
    private _worldMatrix;
    private _worldMatrixRest;
    private _normalMatrix;
    private __isWorldMatrixUpToDate;
    private __isWorldMatrixRestUpToDate;
    private __isNormalMatrixUpToDate;
    private __worldMergedAABBWithSkeletal;
    private __worldMergedAABB;
    private __isWorldAABBDirty;
    private _isVisible;
    private _isBillboard;
    private __aabbGizmo?;
    private __locatorGizmo?;
    private __translationGizmo?;
    private __scaleGizmo?;
    private __transformGizmoSpace;
    private __latestPrimitivePositionAccessorVersion;
    toMakeWorldMatrixTheSameAsLocalMatrix: boolean;
    isRootJoint: boolean;
    jointIndex: number;
    _isCulled: boolean;
    private static readonly __originVector3;
    private static returnVector3;
    private static __sceneGraphs;
    private static isJointAABBShouldBeCalculated;
    private static invertedMatrix44;
    private static __tmp_mat4;
    private static __tmp_mat4_2;
    private static __tmp_mat4_3;
    private static __tmp_quat_0;
    private static __tmp_quat_1;
    private static __updateCount;
    private static __tmpAABB;
    private __lastTransformComponentsUpdateCount;
    /**
     * Creates a new SceneGraphComponent instance.
     * @param entityUid - The unique identifier of the entity this component belongs to
     * @param componentSid - The component instance identifier
     * @param entityRepository - The entity repository managing this component
     * @param isReUse - Whether this component is being reused
     */
    constructor(entityUid: EntityUID, componentSid: ComponentSID, entityRepository: EntityRepository, isReUse: boolean);
    /**
     * Sets the visibility of this scene graph node.
     * @param flg - True to make visible, false to hide
     */
    set isVisible(flg: boolean);
    /**
     * Gets the visibility state of this scene graph node.
     * @returns True if visible, false if hidden
     */
    get isVisible(): boolean;
    /**
     * Gets the current update count for scene graph changes.
     * @returns The current update count
     */
    static get updateCount(): number;
    /**
     * Sets the visibility of this node and all its children recursively.
     * @param flag - True to make visible, false to hide
     */
    setVisibilityRecursively(flag: boolean): void;
    /**
     * Sets the billboard state of this scene graph node.
     * @param flg - True to enable billboard behavior, false to disable
     */
    set isBillboard(flg: boolean);
    /**
     * Gets the billboard state of this scene graph node.
     * @returns True if billboard is enabled, false otherwise
     */
    get isBillboard(): boolean;
    /**
     * Sets the billboard state of this node and all its children recursively.
     * @param flg - True to enable billboard behavior, false to disable
     */
    setIsBillboardRecursively(flg: boolean): void;
    /**
     * Sets the visibility of the AABB (Axis-Aligned Bounding Box) gizmo.
     * @param flg - True to show the AABB gizmo, false to hide it
     */
    set isAABBGizmoVisible(flg: boolean);
    /**
     * Gets the visibility state of the AABB gizmo.
     * @returns True if the AABB gizmo is visible, false otherwise
     */
    get isAABBGizmoVisible(): boolean;
    /**
     * Sets the visibility of the locator gizmo.
     * @param flg - True to show the locator gizmo, false to hide it
     */
    set isLocatorGizmoVisible(flg: boolean);
    /**
     * Gets the visibility state of the locator gizmo.
     * @returns True if the locator gizmo is visible, false otherwise
     */
    get isLocatorGizmoVisible(): boolean;
    /**
     * Sets the visibility of the translation gizmo.
     * @param flg - True to show the translation gizmo, false to hide it
     */
    set isTranslationGizmoVisible(flg: boolean);
    /**
     * Gets the visibility state of the translation gizmo.
     * @returns True if the translation gizmo is visible, false otherwise
     */
    get isTranslationGizmoVisible(): boolean;
    /**
     * Sets the visibility of the scale gizmo.
     * @param flg - True to show the scale gizmo, false to hide it
     */
    set isScaleGizmoVisible(flg: boolean);
    /**
     * Gets the visibility state of the scale gizmo.
     * @returns True if the scale gizmo is visible, false otherwise
     */
    get isScaleGizmoVisible(): boolean;
    /**
     * Gets all top-level scene graph components (nodes without parents).
     * @returns An array of scene graph components that are at the root level
     */
    static getTopLevelComponents(): SceneGraphComponent[];
    /**
     * Checks if this node represents a skeletal joint.
     * @returns True if this is a joint (has a valid joint index), false otherwise
     */
    isJoint(): boolean;
    /**
     * Gets the component type identifier for SceneGraphComponent.
     * @returns The component type ID
     */
    static get componentTID(): ComponentTID;
    /**
     * Gets the component type identifier for this instance.
     * @returns The component type ID
     */
    get componentTID(): ComponentTID;
    /**
     * Marks the world matrix rest state as dirty and propagates to children.
     */
    setWorldMatrixRestDirty(): void;
    /**
     * Recursively marks the world matrix rest state as dirty for this node and all children.
     */
    setWorldMatrixRestDirtyRecursively(): void;
    /**
     * Marks the world matrix as dirty and propagates changes up the hierarchy.
     */
    setWorldMatrixDirty(): void;
    /**
     * Recursively marks the world matrix as dirty for this node and all children.
     */
    setWorldMatrixDirtyRecursively(): void;
    /**
     * Recursively marks the world AABB as dirty up the parent hierarchy.
     */
    setWorldAABBDirtyParentRecursively(): void;
    /**
     * Adds a SceneGraph component as a child of this node.
     * @param sg - The SceneGraph component to add as a child
     */
    addChild(sg: SceneGraphComponent): void;
    /**
     * Removes a child SceneGraph component from this node.
     * @param sg - The SceneGraph component to remove
     */
    removeChild(sg: SceneGraphComponent): void;
    /**
     * Adds a SceneGraph component as a gizmo child (internal use only).
     * @param sg - The SceneGraph component of a gizmo to add
     */
    _addGizmoChild(sg: SceneGraphComponent): void;
    /**
     * Checks if this node is at the top level (has no parent).
     * @returns True if this is a root node, false otherwise
     */
    get isTopLevel(): boolean;
    /**
     * Gets the child scene graph components of this node.
     * @returns An array of child scene graph components
     */
    get children(): SceneGraphComponent[];
    /**
     * Gets the parent scene graph component of this node.
     * @returns The parent component, or undefined if this is a root node
     */
    get parent(): SceneGraphComponent | undefined;
    /**
     * Gets the internal world matrix (mutable reference).
     * @returns The internal world matrix
     */
    get matrixInner(): MutableMatrix44;
    /**
     * Gets a clone of the world matrix.
     * @returns A cloned copy of the world matrix
     */
    get matrix(): MutableMatrix44;
    /**
     * Gets the internal world matrix in rest pose (mutable reference).
     * @returns The internal world matrix in rest pose
     */
    get matrixRestInner(): MutableMatrix44;
    /**
     * Gets a clone of the world matrix in rest pose.
     * @returns A cloned copy of the world matrix in rest pose
     */
    get matrixRest(): MutableMatrix44;
    /**
     * Gets the internal normal matrix (mutable reference).
     * @returns The internal normal matrix
     */
    get normalMatrixInner(): MutableMatrix33;
    /**
     * Gets the entity world matrix with skeletal animation applied.
     * @returns A cloned copy of the entity world matrix with skeletal transformations
     */
    get entityWorldWithSkeletalMatrix(): MutableMatrix44;
    /**
     * Gets the internal entity world matrix with skeletal animation applied.
     * @returns The internal entity world matrix with skeletal transformations
     */
    get entityWorldMatrixWithSkeletalInner(): MutableMatrix44;
    /**
     * Gets a clone of the normal matrix.
     * @returns A cloned copy of the normal matrix
     */
    get normalMatrix(): MutableMatrix33;
    /**
     * Checks if the world matrix is up-to-date recursively up the hierarchy.
     * @returns True if the world matrix is up-to-date for this node and all its ancestors
     */
    isWorldMatrixUpToDateRecursively(): boolean;
    /**
     * Recursively calculates the world matrix from this node up to the root.
     * @returns The calculated world matrix
     */
    private __calcWorldMatrixRecursively;
    /**
     * Recursively calculates the world matrix in rest pose from this node up to the root.
     * @returns The calculated world matrix in rest pose
     */
    private __calcWorldMatrixRestRecursively;
    /**
     * Gets the world rotation quaternion by recursively combining local rotations.
     * @returns The world rotation quaternion
     */
    getQuaternionRecursively(): IQuaternion;
    /**
     * Gets the world position of this node.
     * @returns The world position as a Vector3
     */
    get worldPosition(): Vector3;
    /**
     * Transforms a local position to world space.
     * @param localPosition - The position in local space
     * @returns The position in world space
     */
    getWorldPositionOf(localPosition: Vector3): IVector3;
    /**
     * Transforms a local position to world space and stores the result in the output vector.
     * @param localPosition - The position in local space
     * @param out - The output vector to store the result
     * @returns The output vector containing the world position
     */
    getWorldPositionOfTo(localPosition: Vector3, out: MutableVector3): MutableVector3;
    /**
     * Transforms a world position to local space.
     * @param worldPosition - The position in world space
     * @returns The position in local space
     */
    getLocalPositionOf(worldPosition: Vector3): Vector3;
    /**
     * Transforms a world position to local space and stores the result in the output vector.
     * @param worldPosition - The position in world space
     * @param out - The output vector to store the result
     * @returns The output vector containing the local position
     */
    getLocalPositionOfTo(worldPosition: Vector3, out: MutableVector3): Vector3;
    /**
     * Gets the world-space AABB (Axis-Aligned Bounding Box) of this node.
     * @returns The world AABB of this node
     */
    getWorldAABB(): AABB;
    /**
     * Calculates the merged world AABB including all children.
     * @returns The merged world AABB of this node and all its descendants
     */
    calcWorldMergedAABB(): AABB;
    /**
     * Gets the cached merged world AABB, recalculating if dirty.
     * @returns The merged world AABB of this node and all its descendants
     */
    get worldMergedAABB(): AABB;
    /**
     * Gets the world-space AABB with skeletal animation applied.
     * @returns The world AABB with skeletal transformations
     */
    getWorldAABBWithSkeletal(): AABB;
    /**
     * Calculates the merged world AABB with skeletal animation including all children.
     * @returns The merged world AABB with skeletal transformations
     */
    calcWorldMergedAABBWithSkeletal(): AABB;
    /**
     * Gets the cached merged world AABB with skeletal animation, recalculating if dirty.
     * @returns The merged world AABB with skeletal transformations
     */
    get worldMergedAABBWithSkeletal(): AABB;
    /**
     * Performs ray casting against all mesh components in this hierarchy.
     *
     * @param srcPointInWorld - The ray origin point in world space
     * @param directionInWorld - The ray direction vector in world space (should be normalized)
     * @param dotThreshold - Threshold for triangle-ray intersection angle (default: 0)
     * @param ignoreMeshComponents - Array of mesh components to exclude from ray casting (default: [])
     * @returns Ray casting result containing intersection information
     */
    castRay(srcPointInWorld: Vector3, directionInWorld: Vector3, dotThreshold?: number, ignoreMeshComponents?: MeshComponent[]): RaycastResultEx2;
    /**
     * Performs ray casting from screen coordinates against all mesh components in this hierarchy.
     *
     * @param x - Screen x coordinate
     * @param y - Screen y coordinate
     * @param camera - The camera component to use for screen-to-world projection
     * @param viewport - Viewport rectangle as Vector4 (x, y, width, height)
     * @param dotThreshold - Threshold for triangle-ray intersection angle (default: 0)
     * @param ignoreMeshComponents - Array of mesh components to exclude from ray casting (default: [])
     * @returns Ray casting result containing intersection information in world space
     */
    castRayFromScreen(x: number, y: number, camera: CameraComponent, viewport: Vector4, dotThreshold?: number, ignoreMeshComponents?: MeshComponent[]): RaycastResultEx2;
    /**
     * Loads the component and moves to the Logic stage.
     */
    $load(): void;
    /**
     * Executes logic stage processing including matrix updates and gizmo updates.
     */
    $logic(): void;
    /**
     * Updates all active gizmos for this scene graph node.
     */
    private __updateGizmos;
    /**
     * Sets the world position without updating physics simulation.
     * @param vec - The world position to set
     */
    setPositionWithoutPhysics(vec: IVector3): void;
    /**
     * Sets the world position and updates physics simulation if present.
     * @param vec - The world position to set
     */
    set position(vec: IVector3);
    /**
     * Updates the physics simulation with the new position.
     * @param vec - The world position to set in physics
     */
    setPositionToPhysics(vec: IVector3): void;
    /**
     * Gets the world position of this node.
     * @returns The world position
     */
    get position(): MutableVector3;
    /**
     * Gets the world position and stores it in the output vector.
     * @param outVec - The output vector to store the position
     * @returns The output vector containing the world position
     */
    getPositionTo(outVec: MutableVector3): MutableVector3;
    /**
     * Gets the world position in rest pose.
     * @returns The world position in rest pose
     */
    get positionRest(): MutableVector3;
    /**
     * Gets the world position in rest pose and stores it in the output vector.
     * @param outVec - The output vector to store the position
     * @returns The output vector containing the world position in rest pose
     */
    getPositionRestTo(outVec: MutableVector3): MutableVector3;
    /**
     * Sets the world rotation using Euler angles and updates physics simulation if present.
     * @param vec - The Euler angles (in radians) to set
     */
    set eulerAngles(vec: IVector3);
    /**
     * Updates the physics simulation with the new Euler angles.
     * @param vec - The Euler angles (in radians) to set in physics
     */
    setEulerAnglesToPhysics(vec: IVector3): void;
    /**
     * Gets the world rotation as Euler angles.
     * @returns The world rotation as Euler angles (in radians)
     */
    get eulerAngles(): Vector3;
    /**
     * Sets the world rotation without updating physics simulation.
     * @param quat - The quaternion rotation to set
     */
    setRotationWithoutPhysics(quat: IQuaternion): void;
    /**
     * Sets the world rotation and updates physics simulation if present.
     * @param quat - The quaternion rotation to set
     */
    set rotation(quat: IQuaternion);
    /**
     * Updates the physics simulation with the new rotation.
     * @param quat - The quaternion rotation to set in physics
     */
    setRotationToPhysics(quat: IQuaternion): void;
    /**
     * Gets the world rotation as a quaternion.
     * @returns The world rotation quaternion
     */
    get rotation(): Quaternion;
    /**
     * Gets the world rotation and stores it in the output quaternion.
     * @param outQuat - The output quaternion to store the rotation
     * @returns The output quaternion containing the world rotation
     */
    getRotationTo(outQuat: MutableQuaternion): MutableQuaternion;
    /**
     * Gets the world rotation in rest pose.
     * @returns The world rotation quaternion in rest pose
     */
    get rotationRest(): Quaternion;
    /**
     * Gets the world rotation in rest pose with conditional termination.
     * @param endFn - Function to determine if recursion should stop at this node
     * @returns The world rotation quaternion in rest pose
     */
    getRotationRest(endFn: (sg: SceneGraphComponent) => boolean): Quaternion;
    /**
     * Sets the world scale and updates physics simulation if present.
     * @param vec - The scale vector to set
     */
    set scale(vec: IVector3);
    /**
     * Updates the physics simulation with the new scale.
     * @param vec - The scale vector to set in physics
     */
    setScaleToPhysics(vec: IVector3): void;
    /**
     * Gets the world scale of this node.
     * @returns The world scale vector
     */
    get scale(): MutableVector3;
    /**
     * Creates a shallow copy of a child scene graph component.
     * @param child - The child component to copy
     * @returns A new scene graph entity with copied component
     */
    private __copyChild;
    /**
     * Performs a shallow copy from another SceneGraphComponent.
     * @param component_ - The source component to copy from
     */
    _shallowCopyFrom(component_: Component): void;
    /**
     * Gets the entity which has this component.
     * @returns The entity which has this component
     */
    get entity(): ISceneGraphEntity;
    /**
     * Sets the coordinate space for transformation gizmos.
     * @param space - The coordinate space ('local' or 'world')
     */
    setTransformGizmoSpace(space: 'local' | 'world'): void;
    /**
     * Destroys this component and cleans up resources.
     */
    _destroy(): void;
    /**
     * Adds this component to an entity and extends it with SceneGraph functionality.
     * @param base - The target entity to extend
     * @param _componentClass - The component class being added (unused)
     * @returns The extended entity with SceneGraph methods
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBase, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBase;
}

/**
 * A Tag interface representing a key-value pair for object metadata
 */
type Tag = {
    /** The tag name/key */
    tag: string;
    /** The tag value */
    value: any;
};
/**
 * The Interface of the RnObject defining core object functionality.
 */
interface IRnObject {
    /** Unique identifier for the object */
    objectUID: ObjectUID;
    /** Unique name string for the object */
    uniqueName: string;
    /**
     * Attempts to set a unique name for the object
     * @param name - The desired unique name
     * @param toAddNameIfConflict - Whether to modify the name if it conflicts with existing names
     * @returns True if the name was successfully set, false otherwise
     */
    tryToSetUniqueName(name: string, toAddNameIfConflict: boolean): boolean;
    /**
     * Validates a tag string to ensure it contains only allowed characters
     * @param val - The string to validate
     * @returns True if the string is valid, false otherwise
     */
    validateTagString(val: string): boolean;
    /**
     * Attempts to set a tag on the object
     * @param tag - The tag object containing name and value
     * @returns True if the tag was successfully set, false otherwise
     */
    tryToSetTag(tag: Tag): boolean;
    /**
     * Retrieves the value of a specific tag
     * @param tagName - The name of the tag to retrieve
     * @returns The tag value or undefined if not found
     */
    getTagValue(tagName: string): any;
    /**
     * Checks if an object matches a specific tag name and value
     * @param tagName - The tag name to match
     * @param tagValue - The tag value to match
     * @returns True if the tag matches, false otherwise
     */
    matchTag(tagName: string, tagValue: string): boolean;
    /**
     * Checks if the object's combined tag string contains all provided strings
     * @param stringArray - Array of strings to search for in tags
     * @returns True if all strings are found, false otherwise
     */
    matchTagsAsFreeStrings(stringArray: string[]): boolean;
    /**
     * Checks if the object has all the specified tags with matching values
     * @param tags - The tags object to match against
     * @returns True if all tags match, false otherwise
     */
    matchTags(tags: RnTags): boolean;
    /**
     * Copies properties from another RnObject instance
     * @param rnObject - The source object to copy from
     * @internal
     */
    _copyFrom(rnObject: RnObject): void;
}
/**
 * The root class of all objects in Rhodonite, providing core functionality
 * for object identification, naming, and tagging.
 */
declare class RnObject implements IRnObject {
    /** Invalid object UID constant */
    static readonly InvalidObjectUID = -1;
    /** Current maximum object count for UID generation */
    static currentMaxObjectCount: number;
    /** Array storing all unique names */
    private static __uniqueNames;
    /** Map for quick object lookup by name */
    private static __objectsByNameMap;
    /** Array storing weak references to all objects */
    private static __objects;
    /** Unique identifier for this object instance */
    private readonly __objectUid;
    /** Unique name for this object instance */
    private __uniqueName;
    /** Collection of tags associated with this object */
    _tags: RnTags;
    /** Combined string representation of all tags for efficient searching */
    private __combinedTagString;
    /**
     * Creates a new RnObject instance with auto-generated unique name and UID
     */
    constructor();
    /**
     * Updates the internal object tracking information
     * @param uniqueName - The unique name to register for this object
     * @private
     */
    private __updateInfo;
    /**
     * Unregisters this object from all tracking collections.
     * Should be called when the object is being destroyed.
     */
    unregister(): void;
    /**
     * Searches for the first object that has a specific tag with the given value
     * @param tag - The tag name to search for
     * @param value - The tag value to match
     * @returns WeakRef to the first matching object, or undefined if not found
     */
    static searchByTag(tag: string, value: string): WeakRef<RnObject> | undefined;
    /**
     * Gets the unique object identifier
     * @returns The object's UID
     */
    get objectUID(): ObjectUID;
    /**
     * Retrieves an RnObject instance by its unique identifier
     * @param objectUid - The unique identifier of the object to retrieve
     * @returns The RnObject instance or undefined if not found or garbage collected
     */
    static getRnObject(objectUid: ObjectUID): RnObject | undefined;
    /**
     * Retrieves an RnObject instance by its unique name
     * @param uniqueName - The unique name of the object to retrieve
     * @returns The RnObject instance or undefined if not found or garbage collected
     */
    static getRnObjectByName(uniqueName: string): RnObject | undefined;
    /**
     * Attempts to set a unique name for this object
     * @param name - The desired unique name
     * @param toAddNameIfConflict - If true, appends UID to make name unique when conflicts occur; if false, fails on conflict
     * @returns True if the name was successfully set, false if there was a conflict and toAddNameIfConflict was false
     */
    tryToSetUniqueName(name: string, toAddNameIfConflict: boolean): boolean;
    /**
     * Validates that a tag string contains only allowed characters (alphanumeric and underscore)
     * @param val - The string to validate
     * @returns True if the string contains only valid characters, false if it contains invalid characters
     */
    validateTagString(val: string): boolean;
    /**
     * Attempts to set a tag on this object. If the tag already exists, it will be replaced.
     * @param tag - The tag object containing the name and value to set
     * @returns True if the tag was successfully set, false if the tag name contains invalid characters
     */
    tryToSetTag(tag: Tag): boolean;
    /**
     * Retrieves the value associated with a specific tag name
     * @param tagName - The name of the tag whose value to retrieve
     * @returns The tag value, or undefined if the tag doesn't exist
     */
    getTagValue(tagName: string): any;
    /**
     * Retrieves a complete tag object (name and value) for the specified tag name
     * @param tagName - The name of the tag to retrieve
     * @returns A Tag object containing the name and value
     */
    getTag(tagName: string): Tag;
    /**
     * Checks whether this object has a tag with the specified name
     * @param tagName - The name of the tag to check for
     * @returns True if the tag exists (value is not null/undefined), false otherwise
     */
    hasTag(tagName: string): boolean;
    /**
     * Removes a tag from this object
     * @param tagName - The name of the tag to remove
     */
    removeTag(tagName: string): void;
    /**
     * Checks if this object has a tag with the specified name and value
     * @param tagName - The tag name to match
     * @param tagValue - The tag value to match
     * @returns True if the object has a matching tag, false otherwise
     */
    matchTag(tagName: string, tagValue: string): boolean;
    /**
     * Checks if the object's combined tag string contains all the provided search strings.
     * This allows for flexible searching within tag names and values.
     * @param stringArray - Array of strings that must all be present in the combined tag string
     * @returns True if all strings are found in the combined tag string, false otherwise
     */
    matchTagsAsFreeStrings(stringArray: string[]): boolean;
    /**
     * Checks if this object has all the specified tags with exactly matching values
     * @param tags - Object containing tag names as keys and expected values
     * @returns True if all specified tags exist with matching values, false otherwise
     */
    matchTags(tags: RnTags): boolean;
    /**
     * Gets the unique name of this object
     * @returns The unique name string
     */
    get uniqueName(): string;
    /**
     * Resets all static object tracking data. Used primarily for testing.
     * @internal
     */
    static _reset(): void;
    /**
     * Copies tag data from another RnObject instance to this object
     * @param rnObject - The source RnObject to copy tags from
     * @internal
     */
    _copyFrom(rnObject: RnObject): void;
}

interface PrimitiveModeEnum extends EnumIO {
    getWebGPUTypeStr(): string;
}
declare function from$h(index: number): PrimitiveModeEnum | undefined;
declare const PrimitiveMode: Readonly<{
    Unknown: PrimitiveModeEnum;
    Points: PrimitiveModeEnum;
    Lines: PrimitiveModeEnum;
    LineLoop: PrimitiveModeEnum;
    LineStrip: PrimitiveModeEnum;
    Triangles: PrimitiveModeEnum;
    TriangleStrip: PrimitiveModeEnum;
    TriangleFan: PrimitiveModeEnum;
    from: typeof from$h;
}>;

/**
 * Interface for renderable texture objects that can be used as render targets.
 * This interface defines the contract for objects that can be rendered to,
 * providing texture resources and rendering capabilities.
 */
interface IRenderable {
    /** The width of the renderable texture in pixels */
    width: Size;
    /** The height of the renderable texture in pixels */
    height: Size;
    /** The unique identifier for the underlying texture resource */
    _textureResourceUid: CGAPIResourceHandle;
    /** The unique identifier for the texture view resource */
    _textureViewResourceUid: CGAPIResourceHandle;
    /** The unique identifier for the texture view used as a render target */
    _textureViewAsRenderTargetResourceUid: CGAPIResourceHandle;
    /**
     * Resizes the renderable texture to the specified dimensions.
     * This method should handle the recreation of underlying graphics API resources
     * to accommodate the new size.
     *
     * @param width - The new width in pixels
     * @param height - The new height in pixels
     */
    resize(width: Size, height: Size): void;
    /**
     * Destroys all associated 3D graphics API resources.
     * This method should clean up GPU memory and release all allocated resources
     * to prevent memory leaks.
     *
     * @returns True if the resources were successfully destroyed, false otherwise
     */
    destroy3DAPIResources(): boolean;
    /**
     * Creates a cube texture view as a render target for a specific face and mip level.
     * This is typically used for cube map rendering where each face needs to be
     * rendered to individually.
     *
     * @param faceIdx - The index of the cube face (0-5 for +X, -X, +Y, -Y, +Z, -Z)
     * @param mipLevel - The mip level to create the view for (0 being the base level)
     */
    createCubeTextureViewAsRenderTarget(faceIdx: Index, mipLevel: Index): void;
    /** Optional frame buffer object associated with this renderable */
    fbo?: FrameBuffer;
}

/**
 * Immutable RGB color interface with alpha channel support.
 * Represents a color with red, green, blue components and optional alpha.
 * All components are readonly and cannot be modified after creation.
 */
interface IColorRgb {
    /** Red component of the color (0.0 to 1.0) */
    readonly r: number;
    /** Green component of the color (0.0 to 1.0) */
    readonly g: number;
    /** Blue component of the color (0.0 to 1.0) */
    readonly b: number;
    /** Alpha (transparency) component of the color (0.0 to 1.0) */
    readonly a: number;
    /**
     * Returns a string representation of the color.
     * @returns String representation of the color
     */
    toString(): string;
    /**
     * Returns an approximate string representation of the color with limited precision.
     * @returns Approximate string representation of the color
     */
    toStringApproximately(): string;
    /**
     * Converts the color to a flat array of numbers.
     * @returns Array containing the color components
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this is a dummy/placeholder color instance.
     * @returns True if this is a dummy color, false otherwise
     */
    isDummy(): boolean;
    /**
     * Checks if this color is equal to another vector within a given tolerance.
     * @param vec - The vector to compare with
     * @param delta - The tolerance for comparison
     * @returns True if the colors are equal within the tolerance
     */
    isEqual(vec: IVector3, delta: number): boolean;
    /**
     * Checks if this color is strictly equal to another vector.
     * @param vec - The vector to compare with
     * @returns True if the colors are exactly equal
     */
    isStrictEqual(vec: IVector3): boolean;
    /**
     * Gets the component value at the specified index.
     * @param i - The index (0=r, 1=g, 2=b, 3=a)
     * @returns The component value at the specified index
     */
    at(i: number): number;
    /**
     * Calculates the length (magnitude) of the color vector.
     * @returns The length of the color vector
     */
    length(): number;
    /**
     * Calculates the squared length of the color vector.
     * @returns The squared length of the color vector
     */
    lengthSquared(): number;
    /**
     * Calculates the distance to another vector.
     * @param vec - The target vector
     * @returns The distance to the target vector
     */
    lengthTo(vec: IVector3): number;
    /**
     * Calculates the dot product with another vector.
     * @param vec - The vector to calculate dot product with
     * @returns The dot product result
     */
    dot(vec: IVector3): number;
    /**
     * Creates a copy of this color.
     * @returns A new immutable color instance with the same values
     */
    clone(): IColorRgb;
}
/**
 * Mutable RGB color interface with alpha channel support.
 * Represents a color with red, green, blue components and readonly alpha.
 * RGB components can be modified, but alpha remains readonly.
 */
interface IMutableColorRgb {
    /** Red component of the color (0.0 to 1.0) - mutable */
    r: number;
    /** Green component of the color (0.0 to 1.0) - mutable */
    g: number;
    /** Blue component of the color (0.0 to 1.0) - mutable */
    b: number;
    /** Alpha (transparency) component of the color (0.0 to 1.0) - readonly */
    readonly a: number;
    /**
     * Returns a string representation of the color.
     * @returns String representation of the color
     */
    toString(): string;
    /**
     * Returns an approximate string representation of the color with limited precision.
     * @returns Approximate string representation of the color
     */
    toStringApproximately(): string;
    /**
     * Converts the color to a flat array of numbers.
     * @returns Array containing the color components
     */
    flattenAsArray(): Array<number>;
    /**
     * Checks if this is a dummy/placeholder color instance.
     * @returns True if this is a dummy color, false otherwise
     */
    isDummy(): boolean;
    /**
     * Checks if this color is equal to another vector within a given tolerance.
     * @param vec - The vector to compare with
     * @param delta - The tolerance for comparison
     * @returns True if the colors are equal within the tolerance
     */
    isEqual(vec: IVector3, delta: number): boolean;
    /**
     * Checks if this color is strictly equal to another vector.
     * @param vec - The vector to compare with
     * @returns True if the colors are exactly equal
     */
    isStrictEqual(vec: IVector3): boolean;
    /**
     * Gets the component value at the specified index.
     * @param i - The index (0=r, 1=g, 2=b, 3=a)
     * @returns The component value at the specified index
     */
    at(i: number): number;
    /**
     * Calculates the length (magnitude) of the color vector.
     * @returns The length of the color vector
     */
    length(): number;
    /**
     * Calculates the squared length of the color vector.
     * @returns The squared length of the color vector
     */
    lengthSquared(): number;
    /**
     * Calculates the distance to another vector.
     * @param vec - The target vector
     * @returns The distance to the target vector
     */
    lengthTo(vec: IVector3): number;
    /**
     * Calculates the dot product with another vector.
     * @param vec - The vector to calculate dot product with
     * @returns The dot product result
     */
    dot(vec: IVector3): number;
    /**
     * Creates a copy of this color.
     * @returns A new mutable color instance with the same values
     */
    clone(): IMutableColorRgb;
    /**
     * Gets the raw typed array representation of the color data.
     * @returns The underlying typed array containing color components
     */
    raw(): TypedArray;
    /**
     * Sets the value of a component at the specified index.
     * @param i - The index (0=r, 1=g, 2=b)
     * @param value - The new value for the component
     * @returns This color instance for method chaining
     */
    setAt(i: number, value: number): IMutableColorRgb;
    /**
     * Sets the RGB components of the color.
     * @param x - The red component value
     * @param y - The green component value
     * @param z - The blue component value
     * @returns This color instance for method chaining
     */
    setComponents(x: number, y: number, z: number): IMutableColorRgb;
    /**
     * Copies components from another vector.
     * @param vec - The source vector to copy from
     * @returns This color instance for method chaining
     */
    copyComponents(vec: IVector3): IMutableColorRgb;
    /**
     * Sets all components to zero.
     * @returns This color instance for method chaining
     */
    zero(): IMutableColorRgb;
    /**
     * Sets all components to one.
     * @returns This color instance for method chaining
     */
    one(): IMutableColorRgb;
    /**
     * Normalizes the color vector to unit length.
     * @returns This color instance for method chaining
     */
    normalize(): IMutableColorRgb;
    /**
     * Adds another vector to this color.
     * @param vec - The vector to add
     * @returns This color instance for method chaining
     */
    add(vec: IVector3): IMutableColorRgb;
    /**
     * Subtracts another vector from this color.
     * @param vec - The vector to subtract
     * @returns This color instance for method chaining
     */
    subtract(vec: IVector3): IMutableColorRgb;
    /**
     * Multiplies this color by a scalar value.
     * @param value - The scalar value to multiply by
     * @returns This color instance for method chaining
     */
    multiply(value: number): IMutableColorRgb;
    /**
     * Multiplies this color by another vector component-wise.
     * @param vec - The vector to multiply by
     * @returns This color instance for method chaining
     */
    multiplyVector(vec: IVector3): IMutableColorRgb;
    /**
     * Divides this color by a scalar value.
     * @param value - The scalar value to divide by
     * @returns This color instance for method chaining
     */
    divide(value: number): IMutableColorRgb;
    /**
     * Divides this color by another vector component-wise.
     * @param vec - The vector to divide by
     * @returns This color instance for method chaining
     */
    divideVector(vec: IVector3): IMutableColorRgb;
    /**
     * Calculates the cross product with another vector.
     * @param vec - The vector to calculate cross product with
     * @returns This color instance for method chaining
     */
    cross(vec: IVector3): IMutableColorRgb;
}
/**
 * Immutable RGBA color interface.
 * Represents a color with red, green, blue, and alpha components.
 * All components are readonly and cannot be modified after creation.
 */
interface IColorRgba {
    /** Red component of the color (0.0 to 1.0) */
    readonly r: number;
    /** Green component of the color (0.0 to 1.0) */
    readonly g: number;
    /** Blue component of the color (0.0 to 1.0) */
    readonly b: number;
    /** Alpha (transparency) component of the color (0.0 to 1.0) */
    readonly a: number;
}
/**
 * Mutable RGBA color interface.
 * Represents a color with red, green, blue, and alpha components.
 * All components can be modified after creation.
 */
interface IMutableColorRgba {
    /** Red component of the color (0.0 to 1.0) - mutable */
    r: number;
    /** Green component of the color (0.0 to 1.0) - mutable */
    g: number;
    /** Blue component of the color (0.0 to 1.0) - mutable */
    b: number;
    /** Alpha (transparency) component of the color (0.0 to 1.0) - mutable */
    a: number;
}

/**
 * Represents an RGB color with red, green, and blue components.
 * Extends Vector3 to provide mathematical operations on color values.
 * Each component is stored as a floating-point value, typically in the range [0, 1].
 *
 * @example
 * ```typescript
 * const red = new ColorRgb(new Float32Array([1, 0, 0]));
 * const green = ColorRgb.add(red, new ColorRgb(new Float32Array([0, 1, 0])));
 * ```
 */
declare class ColorRgb extends Vector3 implements IVector3, IColorRgb {
    /**
     * Gets the X component of the color (equivalent to red component).
     *
     * @returns The X/red component value
     */
    get x(): number;
    /**
     * Gets the Y component of the color (equivalent to green component).
     *
     * @returns The Y/green component value
     */
    get y(): number;
    /**
     * Gets the Z component of the color (equivalent to blue component).
     *
     * @returns The Z/blue component value
     */
    get z(): number;
    /**
     * Gets the W component of the color (always 1 for RGB colors).
     *
     * @returns Always returns 1
     */
    get w(): number;
    /**
     * Gets the red component of the color.
     *
     * @returns The red component value
     */
    get r(): number;
    /**
     * Gets the green component of the color.
     *
     * @returns The green component value
     */
    get g(): number;
    /**
     * Gets the blue component of the color.
     *
     * @returns The blue component value
     */
    get b(): number;
    /**
     * Gets the alpha component of the color (always 1 for RGB colors).
     *
     * @returns Always returns 1
     */
    get a(): number;
    /**
     * Creates a ColorRgb with all components set to zero (black).
     *
     * @returns A new ColorRgb instance with values [0, 0, 0]
     */
    static zero(): ColorRgb;
    /**
     * Creates a ColorRgb with all components set to one (white).
     *
     * @returns A new ColorRgb instance with values [1, 1, 1]
     */
    static one(): ColorRgb;
    /**
     * Creates a dummy ColorRgb instance for testing or placeholder purposes.
     *
     * @returns A new ColorRgb instance with dummy values
     */
    static dummy(): ColorRgb;
    /**
     * Normalizes a color vector to unit length.
     *
     * @param vec - The color vector to normalize
     * @returns A new normalized ColorRgb instance
     */
    static normalize(vec: IVector3): ColorRgb;
    /**
     * Adds two color vectors component-wise.
     *
     * @param l_vec - The left operand color vector
     * @param r_vec - The right operand color vector
     * @returns A new ColorRgb instance representing the sum
     */
    static add(l_vec: IVector3, r_vec: IVector3): ColorRgb;
    /**
     * Subtracts one color vector from another component-wise.
     *
     * @param l_vec - The minuend color vector
     * @param r_vec - The subtrahend color vector
     * @returns A new ColorRgb instance representing the difference
     */
    static subtract(l_vec: IVector3, r_vec: IVector3): ColorRgb;
    /**
     * Multiplies a color vector by a scalar value.
     *
     * @param vec - The color vector to multiply
     * @param value - The scalar value to multiply by
     * @returns A new ColorRgb instance representing the scaled color
     */
    static multiply(vec: IVector3, value: number): ColorRgb;
    /**
     * Multiplies two color vectors component-wise.
     *
     * @param l_vec - The left operand color vector
     * @param r_vec - The right operand color vector
     * @returns A new ColorRgb instance representing the component-wise product
     */
    static multiplyVector(l_vec: IVector3, r_vec: IVector3): ColorRgb;
    /**
     * Divides a color vector by a scalar value.
     *
     * @param vec - The color vector to divide
     * @param value - The scalar value to divide by
     * @returns A new ColorRgb instance representing the scaled color
     */
    static divide(vec: IVector3, value: number): ColorRgb;
    /**
     * Divides one color vector by another component-wise.
     *
     * @param l_vec - The dividend color vector
     * @param r_vec - The divisor color vector
     * @returns A new ColorRgb instance representing the component-wise quotient
     */
    static divideVector(l_vec: IVector3, r_vec: IVector3): ColorRgb;
    /**
     * Computes the cross product of two color vectors.
     * Note: Cross product for colors is rarely used but available for completeness.
     *
     * @param l_vec - The left operand color vector
     * @param r_vec - The right operand color vector
     * @returns A new ColorRgb instance representing the cross product
     */
    static cross(l_vec: IVector3, r_vec: IVector3): ColorRgb;
    /**
     * Creates a deep copy of this ColorRgb instance.
     *
     * @returns A new ColorRgb instance with the same values
     */
    clone(): ColorRgb;
}

/**
 * A RGBA color class that extends Vector4 to provide color-specific functionality.
 * Represents colors with red, green, blue, and alpha (transparency) components,
 * each ranging from 0.0 to 1.0.
 *
 * @example
 * ```typescript
 * // Create a red color with full opacity
 * const red = ColorRgba.fromCopy4(1.0, 0.0, 0.0, 1.0);
 *
 * // Create from array
 * const blue = ColorRgba.fromCopyArray([0.0, 0.0, 1.0, 1.0]);
 * ```
 */
declare class ColorRgba extends Vector4 implements IVector4, IColorRgba {
    /**
     * Gets the x component (equivalent to red component).
     *
     * @returns The x/red component value
     */
    get x(): number;
    /**
     * Gets the y component (equivalent to green component).
     *
     * @returns The y/green component value
     */
    get y(): number;
    /**
     * Gets the z component (equivalent to blue component).
     *
     * @returns The z/blue component value
     */
    get z(): number;
    /**
     * Gets the w component (equivalent to alpha component).
     *
     * @returns The w/alpha component value
     */
    get w(): number;
    /**
     * Gets the red component of the color.
     *
     * @returns The red component value (0.0 to 1.0)
     */
    get r(): number;
    /**
     * Gets the green component of the color.
     *
     * @returns The green component value (0.0 to 1.0)
     */
    get g(): number;
    /**
     * Gets the blue component of the color.
     *
     * @returns The blue component value (0.0 to 1.0)
     */
    get b(): number;
    /**
     * Gets the alpha (transparency) component of the color.
     *
     * @returns The alpha component value (0.0 = transparent, 1.0 = opaque)
     */
    get a(): number;
    /**
     * Creates a zero color (black with zero alpha).
     *
     * @returns A new ColorRgba instance with all components set to 0
     */
    static zero(): ColorRgba;
    /**
     * Creates a color with all components set to 1 (white with full opacity).
     *
     * @returns A new ColorRgba instance with all components set to 1
     */
    static one(): ColorRgba;
    /**
     * Creates a dummy color instance for initialization purposes.
     *
     * @returns A new ColorRgba instance with dummy values
     */
    static dummy(): ColorRgba;
    /**
     * Normalizes a color vector to unit length.
     *
     * @param vec - The color vector to normalize
     * @returns A new normalized ColorRgba instance
     */
    static normalize(vec: IVector4): ColorRgba;
    /**
     * Adds two color vectors component-wise.
     *
     * @param l_vec - The left operand color vector
     * @param r_vec - The right operand color vector
     * @returns A new ColorRgba instance representing the sum
     */
    static add(l_vec: IVector4, r_vec: IVector4): ColorRgba;
    /**
     * Subtracts the right color vector from the left color vector component-wise.
     *
     * @param l_vec - The left operand color vector (minuend)
     * @param r_vec - The right operand color vector (subtrahend)
     * @returns A new ColorRgba instance representing the difference
     */
    static subtract(l_vec: IVector4, r_vec: IVector4): ColorRgba;
    /**
     * Multiplies a color vector by a scalar value.
     *
     * @param vec - The color vector to multiply
     * @param value - The scalar value to multiply by
     * @returns A new ColorRgba instance representing the scaled color
     */
    static multiply(vec: IVector4, value: number): ColorRgba;
    /**
     * Multiplies two color vectors component-wise (component multiplication).
     *
     * @param l_vec - The left operand color vector
     * @param r_vec - The right operand color vector
     * @returns A new ColorRgba instance representing the component-wise product
     */
    static multiplyVector(l_vec: IVector4, r_vec: IVector4): ColorRgba;
    /**
     * Divides a color vector by a scalar value.
     *
     * @param vec - The color vector to divide
     * @param value - The scalar value to divide by
     * @returns A new ColorRgba instance representing the scaled color
     * @throws Error if value is zero
     */
    static divide(vec: IVector4, value: number): ColorRgba;
    /**
     * Divides the left color vector by the right color vector component-wise.
     *
     * @param l_vec - The left operand color vector (dividend)
     * @param r_vec - The right operand color vector (divisor)
     * @returns A new ColorRgba instance representing the component-wise quotient
     * @throws Error if any component of r_vec is zero
     */
    static divideVector(l_vec: IVector4, r_vec: IVector4): ColorRgba;
    /**
     * Creates a deep copy of this color.
     *
     * @returns A new ColorRgba instance with the same component values
     */
    clone(): ColorRgba;
    /**
     * Creates a new ColorRgba instance from an array of numbers.
     *
     * @param array - An array containing RGBA values [r, g, b, a]
     * @returns A new ColorRgba instance created from the array
     */
    static fromCopyArray(array: Array<number>): ColorRgba;
    /**
     * Creates a new ColorRgba instance from a 4-element tuple array.
     *
     * @param array - A 4-element tuple containing RGBA values [r, g, b, a]
     * @returns A new ColorRgba instance created from the tuple
     */
    static fromCopyArray4(array: Array4<number>): ColorRgba;
    /**
     * Creates a new ColorRgba instance from individual RGBA component values.
     *
     * @param x - The red component value
     * @param y - The green component value
     * @param z - The blue component value
     * @param w - The alpha component value
     * @returns A new ColorRgba instance with the specified component values
     */
    static fromCopy4(x: number, y: number, z: number, w: number): ColorRgba;
    /**
     * Creates a new ColorRgba instance by copying values from another 4D vector.
     *
     * @param vec4 - The source vector to copy from
     * @returns A new ColorRgba instance with copied values
     */
    static fromCopyVector4(vec4: IVector4): ColorRgba;
}
/**
 * Predefined constant for white color with full opacity (1, 1, 1, 1).
 */
declare const ConstRgbaWhite: ColorRgba;
/**
 * Predefined constant for black color with full opacity (0, 0, 0, 1).
 */
declare const ConstRgbaBlack: ColorRgba;

interface AlphaModeEnum extends EnumIO {
    toGltfString(): string;
}
declare function from$g(index: number): AlphaModeEnum | undefined;
declare function fromString$c(str: string): AlphaModeEnum | undefined;
declare function fromGlTFString(str: string): AlphaModeEnum | undefined;
declare const AlphaMode: Readonly<{
    Opaque: AlphaModeEnum;
    Mask: AlphaModeEnum;
    Blend: AlphaModeEnum;
    from: typeof from$g;
    fromString: typeof fromString$c;
    fromGlTFString: typeof fromGlTFString;
}>;

type AnimationAttributeEnum = EnumIO;
declare function from$f(index: number): AnimationAttributeEnum;
declare function fromString$b(str: string): AnimationAttributeEnum;
declare const AnimationAttribute: Readonly<{
    Quaternion: EnumIO;
    Translate: EnumIO;
    Scale: EnumIO;
    Weights: EnumIO;
    Effekseer: EnumIO;
    Vector4: EnumIO;
    Vector3: EnumIO;
    Vector2: EnumIO;
    Scalar: EnumIO;
    VectorN: EnumIO;
    from: typeof from$f;
    fromString: typeof fromString$b;
}>;

type BasisCompressionTypeEnum = EnumIO;
declare function from$e(index: number): BasisCompressionTypeEnum;
declare function fromString$a(str: string): BasisCompressionTypeEnum;
declare const BasisCompressionType: Readonly<{
    ETC1: EnumIO;
    ETC2: EnumIO;
    BC1: EnumIO;
    BC3: EnumIO;
    BC4: EnumIO;
    BC5: EnumIO;
    BC7_M5: EnumIO;
    BC7_M6_OPAQUE: EnumIO;
    PVRTC1_RGB: EnumIO;
    PVRTC1_RGBA: EnumIO;
    ASTC: EnumIO;
    ATC_RGB: EnumIO;
    ATC_RGBA: EnumIO;
    RGBA32: EnumIO;
    RGB565: EnumIO;
    BGR565: EnumIO;
    RGBA4444: EnumIO;
    from: typeof from$e;
    fromString: typeof fromString$a;
}>;

type BoneDataTypeEnum = EnumIO;
declare function from$d(index: number): BoneDataTypeEnum;
declare function fromString$9(str: string): BoneDataTypeEnum;
declare const BoneDataType: Readonly<{
    Mat43x1: EnumIO;
    Vec4x2: EnumIO;
    Vec4x2Old: EnumIO;
    Vec4x1: EnumIO;
    from: typeof from$d;
    fromString: typeof fromString$9;
}>;

type BufferUseEnum = EnumIO;
declare function from$c(index: number): BufferUseEnum;
declare function fromString$8(str: string): BufferUseEnum;
declare const BufferUse: Readonly<{
    GPUInstanceData: EnumIO;
    GPUVertexData: EnumIO;
    UBOGeneric: EnumIO;
    CPUGeneric: EnumIO;
    from: typeof from$c;
    fromString: typeof fromString$8;
}>;

type CameraTypeEnum = EnumIO;
declare function from$b(index: number): CameraTypeEnum;
declare function fromString$7(str: string): CameraTypeEnum;
declare const CameraType: Readonly<{
    Perspective: EnumIO;
    Orthographic: EnumIO;
    Frustum: EnumIO;
    from: typeof from$b;
    fromString: typeof fromString$7;
}>;

type FileTypeEnum = EnumIO;
declare function from$a(index: number): FileTypeEnum;
declare function fromString$6(str: string): FileTypeEnum;
declare function isGltfOrGlb(file: FileTypeEnum): boolean;
declare const FileType: Readonly<{
    Unknown: EnumIO;
    Gltf: EnumIO;
    GltfBinary: EnumIO;
    VRM: EnumIO;
    Draco: EnumIO;
    EffekseerEffect: EnumIO;
    from: typeof from$a;
    fromString: typeof fromString$6;
    isGltfOrGlb: typeof isGltfOrGlb;
}>;

type LightTypeEnum = EnumIO;
declare function from$9(index: number): LightTypeEnum;
declare function fromString$5(str: string): LightTypeEnum;
declare const LightType: Readonly<{
    Point: EnumIO;
    Directional: EnumIO;
    Spot: EnumIO;
    Ambient: EnumIO;
    from: typeof from$9;
    fromString: typeof fromString$5;
}>;

declare class ProcessApproachClass extends EnumClass implements EnumIO {
    constructor({ index, str }: {
        index: number;
        str: string;
    });
    get webGLVersion(): 2 | 0;
}
type ProcessApproachEnum = ProcessApproachClass;
declare function from$8(index: number): ProcessApproachEnum | undefined;
declare const ProcessApproach: Readonly<{
    isDataTextureApproach: (processApproach: ProcessApproachEnum) => boolean;
    isUniformApproach: (processApproach: ProcessApproachEnum) => boolean;
    isWebGpuApproach: (processApproach: ProcessApproachEnum) => boolean;
    None: ProcessApproachClass;
    Uniform: ProcessApproachClass;
    DataTexture: ProcessApproachClass;
    WebGPU: ProcessApproachClass;
    from: typeof from$8;
    isWebGL2Approach: (processApproach: ProcessApproachEnum) => boolean;
}>;

interface ProcessStageEnum extends EnumIO {
    methodName: string;
}
declare function from$7(index: number): ProcessStageEnum;
declare const ProcessStage: Readonly<{
    Unknown: ProcessStageEnum;
    Create: ProcessStageEnum;
    Load: ProcessStageEnum;
    Mount: ProcessStageEnum;
    Logic: ProcessStageEnum;
    PreRender: ProcessStageEnum;
    Render: ProcessStageEnum;
    Unmount: ProcessStageEnum;
    Discard: ProcessStageEnum;
    from: typeof from$7;
}>;

type ShaderNodeEnum = EnumIO;
declare function from$6(index: number): ShaderNodeEnum;
declare function fromString$4(str: string): ShaderNodeEnum;
declare const ShaderNode: Readonly<{
    ClassicShading: EnumIO;
    PBRShading: EnumIO;
    from: typeof from$6;
    fromString: typeof fromString$4;
}>;

type ShaderVariableTypeEnum = EnumIO;
declare function from$5(index: number): ShaderVariableTypeEnum;
declare function fromString$3(str: string): ShaderVariableTypeEnum;
declare const ShaderVariableType: Readonly<{
    Varying: EnumIO;
    ReadOnlyData: EnumIO;
    from: typeof from$5;
    fromString: typeof fromString$3;
}>;

type ShadingModelEnum = EnumIO;
declare function from$4(index: number): ShadingModelEnum;
declare const ShadingModel: Readonly<{
    Unknown: EnumIO;
    Constant: EnumIO;
    Lambert: EnumIO;
    BlinnPhong: EnumIO;
    Phong: EnumIO;
    from: typeof from$4;
}>;

type ShadowMapEnum = EnumIO;
declare function from$3(index: number): ShadowMapEnum | undefined;
declare function fromString$2(str: string): ShadowMapEnum;
declare const ShadowMapType: Readonly<{
    Standard: EnumIO;
    Variance: EnumIO;
    from: typeof from$3;
    fromString: typeof fromString$2;
}>;

type VisibilityEnum = EnumIO;
declare function from$2(index: number): VisibilityEnum;
declare function fromString$1(str: string): VisibilityEnum;
declare const Visibility: Readonly<{
    Visible: EnumIO;
    Invisible: EnumIO;
    Neutral: EnumIO;
    from: typeof from$2;
    fromString: typeof fromString$1;
}>;

type ToneMappingTypeEnum = EnumIO;
declare function from$1(index: number): ToneMappingTypeEnum;
declare const ToneMappingType: Readonly<{
    None: EnumIO;
    KhronosPbrNeutral: EnumIO;
    Reinhard: EnumIO;
    GT_ToneMap: EnumIO;
    ACES_Narkowicz: EnumIO;
    ACES_Hill: EnumIO;
    ACES_Hill_Exposure_Boost: EnumIO;
    from: typeof from$1;
}>;

/**
 * Descriptor object for configuring a texture sampler.
 */
type SamplerDescriptor = {
    /** Minification filter mode for texture sampling */
    minFilter: TextureParameterEnum;
    /** Magnification filter mode for texture sampling */
    magFilter: TextureParameterEnum;
    /** Texture wrapping mode for S coordinate */
    wrapS: TextureParameterEnum;
    /** Texture wrapping mode for T coordinate */
    wrapT: TextureParameterEnum;
    /** Texture wrapping mode for R coordinate (optional) */
    wrapR?: TextureParameterEnum;
    /** Whether to enable anisotropic filtering (optional) */
    anisotropy?: boolean;
    /** Whether to enable shadow comparison mode (optional) */
    shadowCompareMode?: boolean;
};
/**
 * Represents a texture sampler that defines how textures are sampled during rendering.
 * A sampler encapsulates filtering and wrapping parameters for texture sampling operations.
 */
declare class Sampler {
    private __minFilter;
    private __magFilter;
    private __wrapS;
    private __wrapT;
    private __wrapR;
    private __anisotropy;
    private __shadowCompareMode;
    private __samplerResourceUid;
    /**
     * Creates a new Sampler instance with the specified configuration.
     * @param desc - The sampler descriptor containing filtering and wrapping parameters
     */
    constructor(desc: SamplerDescriptor);
    /**
     * Creates the underlying graphics API sampler resource.
     * This method must be called before the sampler can be used for rendering.
     */
    create(): void;
    /**
     * Checks whether the sampler resource has been created.
     * @returns True if the sampler has been created, false otherwise
     */
    get created(): boolean;
    /**
     * Gets the minification filter mode used when the texture is scaled down.
     * @returns The minification filter parameter
     */
    get minFilter(): TextureParameterEnum;
    /**
     * Gets the magnification filter mode used when the texture is scaled up.
     * @returns The magnification filter parameter
     */
    get magFilter(): TextureParameterEnum;
    /**
     * Gets the texture wrapping mode for the S (horizontal) coordinate.
     * @returns The S-coordinate wrapping parameter
     */
    get wrapS(): TextureParameterEnum;
    /**
     * Gets the texture wrapping mode for the T (vertical) coordinate.
     * @returns The T-coordinate wrapping parameter
     */
    get wrapT(): TextureParameterEnum;
    /**
     * Gets the texture wrapping mode for the R (depth) coordinate.
     * @returns The R-coordinate wrapping parameter
     */
    get wrapR(): TextureParameterEnum;
    /**
     * Gets the internal sampler resource handle used by the graphics API.
     * @returns The sampler resource UID
     * @internal
     */
    get _samplerResourceUid(): CGAPIResourceHandle;
}

/**
 * A class for handling floating-point texture data with support for multi-channel pixels.
 * This class provides methods to manipulate texture data stored as Float32Array,
 * allowing for high-precision color and data storage in textures.
 */
declare class TextureDataFloat {
    private __data;
    private __channels;
    private __width;
    private __height;
    /**
     * Creates a new TextureDataFloat instance with the specified dimensions and channel count.
     * @param width - The width of the texture in pixels
     * @param height - The height of the texture in pixels
     * @param channels - The number of channels per pixel (e.g., 3 for RGB, 4 for RGBA)
     */
    constructor(width: number, height: number, channels: number);
    /**
     * Resizes the texture data to new dimensions and channel count.
     * Existing data is preserved where possible during the resize operation.
     * @param width - The new width of the texture in pixels
     * @param height - The new height of the texture in pixels
     * @param channels - The new number of channels per pixel
     */
    resize(width: number, height: number, channels: number): void;
    /**
     * Sets the value of a specific channel at the given pixel coordinates.
     * @param x - The x-coordinate of the pixel
     * @param y - The y-coordinate of the pixel
     * @param channelIdx - The index of the channel to set (0-based)
     * @param value - The floating-point value to set for the channel
     */
    setPixelAtChannel(x: Index, y: Index, channelIdx: Index, value: number): void;
    /**
     * Gets the width of the texture in pixels.
     * @returns The width of the texture
     */
    get width(): number;
    /**
     * Gets the height of the texture in pixels.
     * @returns The height of the texture
     */
    get height(): number;
    /**
     * Gets the underlying Float32Array containing the texture data.
     * @returns The raw texture data as Float32Array
     */
    get data(): Float32Array<ArrayBufferLike>;
    /**
     * Gets the value of a specific channel at the given pixel coordinates.
     * @param x - The x-coordinate of the pixel
     * @param y - The y-coordinate of the pixel
     * @param channelIdx - The index of the channel to retrieve (0-based)
     * @returns The floating-point value of the specified channel
     */
    getPixel(x: Index, y: Index, channelIdx: Index): number;
    /**
     * Gets pixel data as a color object (ColorRgb or ColorRgba) at the specified coordinates.
     * @param x - The x-coordinate of the pixel
     * @param y - The y-coordinate of the pixel
     * @param channels - The number of channels to read (3 for RGB, 4 for RGBA)
     * @param typeClass - The color class constructor (ColorRgb or ColorRgba)
     * @returns A new instance of the specified color class containing the pixel data
     */
    getPixelAs(x: Index, y: Index, channels: Size, typeClass: typeof ColorRgb | typeof ColorRgba): any;
    /**
     * Gets all channel values for a pixel at the specified coordinates as an array.
     * @param x - The x-coordinate of the pixel
     * @param y - The y-coordinate of the pixel
     * @returns An array containing all channel values for the pixel
     */
    getPixelAsArray(x: Index, y: Index): number[];
    /**
     * Initializes the texture data with new dimensions and channel count.
     * This method creates a new Float32Array, discarding any existing data.
     * @param width - The width of the texture in pixels
     * @param height - The height of the texture in pixels
     * @param channels - The number of channels per pixel
     */
    initialize(width: number, height: number, channels: number): void;
    /**
     * Transfers data from a source ArrayBuffer to a new ArrayBuffer with the specified length.
     * This is a utility method for efficiently copying array buffer data with different word sizes.
     * @param source - The source ArrayBuffer to copy data from
     * @param length - The length of the destination ArrayBuffer in bytes
     * @returns A new ArrayBuffer containing the transferred data
     * @throws {TypeError} If source or destination is not an ArrayBuffer instance
     */
    static transfer(source: any, length: number): ArrayBuffer;
}

/**
 * Abstract base class for all texture types in the Rhodonite engine.
 * Provides common functionality for texture management, pixel manipulation,
 * and resource handling across different texture implementations.
 *
 * @abstract
 * @extends RnObject
 */
declare abstract class AbstractTexture extends RnObject {
    protected __width: Size;
    protected __height: Size;
    protected __level: Index;
    protected __mipLevelCount: Index;
    protected __internalFormat: TextureFormatEnum;
    protected __format: PixelFormatEnum;
    protected __type: ComponentTypeEnum;
    protected __hasTransparentPixels: boolean;
    private static readonly InvalidTextureUid;
    private static __textureUidCount;
    private __textureUid;
    protected __img?: HTMLImageElement;
    protected __isTextureReady: boolean;
    protected __startedToLoad: boolean;
    protected __htmlImageElement?: HTMLImageElement;
    protected __htmlCanvasElement?: HTMLCanvasElement;
    protected __canvasContext?: CanvasRenderingContext2D;
    protected __uri?: string;
    protected __name: string;
    _textureResourceUid: CGAPIResourceHandle;
    _samplerResourceUid: CGAPIResourceHandle;
    _textureViewResourceUid: CGAPIResourceHandle;
    _textureViewAsRenderTargetResourceUid: CGAPIResourceHandle;
    _recommendedTextureSampler?: Sampler;
    /**
     * Creates a new AbstractTexture instance.
     * Automatically assigns a unique texture UID to this texture.
     */
    constructor();
    /**
     * Gets the unique identifier for this texture.
     *
     * @returns The unique texture UID
     */
    get textureUID(): number;
    /**
     * Gets the width of the texture in pixels.
     *
     * @returns The texture width
     */
    get width(): Size;
    /**
     * Calculates the width of the texture at a specific mip level.
     *
     * @param mipLevel - The mip level to calculate width for
     * @returns The width at the specified mip level (minimum 1 pixel)
     */
    getWidthAtMipLevel(mipLevel: Index): number;
    /**
     * Calculates the height of the texture at a specific mip level.
     *
     * @param mipLevel - The mip level to calculate height for
     * @returns The height at the specified mip level (minimum 1 pixel)
     */
    getHeightAtMipLevel(mipLevel: Index): number;
    /**
     * Sets the width of the texture in pixels.
     *
     * @param val - The new width value
     */
    set width(val: Size);
    /**
     * Gets the height of the texture in pixels.
     *
     * @returns The texture height
     */
    get height(): Size;
    /**
     * Sets the height of the texture in pixels.
     *
     * @param val - The new height value
     */
    set height(val: Size);
    /**
     * Checks if the texture is ready for use.
     *
     * @returns True if the texture is ready, false otherwise
     */
    get isTextureReady(): boolean;
    /**
     * Checks if the texture has started loading.
     *
     * @returns True if loading has started, false otherwise
     */
    get startedToLoad(): boolean;
    /**
     * Gets the HTML image element associated with this texture.
     *
     * @returns The HTML image element or undefined if not available
     */
    get htmlImageElement(): HTMLImageElement | undefined;
    /**
     * Gets or creates an HTML canvas element with the texture content.
     * If an image element exists, it will be drawn onto the canvas.
     *
     * @returns The HTML canvas element containing the texture data
     */
    get htmlCanvasElement(): HTMLCanvasElement;
    /**
     * Gets the URI/URL of the texture source.
     *
     * @returns The texture URI or undefined if not set
     */
    get uri(): string | undefined;
    /**
     * Sets the name of the texture.
     *
     * @param name - The new texture name
     */
    set name(name: string);
    /**
     * Gets the name of the texture.
     *
     * @returns The texture name
     */
    get name(): string;
    /**
     * Retrieves image data from a rectangular region of the texture.
     * Creates an internal canvas context if one doesn't exist.
     *
     * @param x - The x-coordinate of the top-left corner
     * @param y - The y-coordinate of the top-left corner
     * @param width - The width of the region
     * @param height - The height of the region
     * @returns ImageData object containing the pixel data
     */
    getImageData(x: Index, y: Index, width: Size, height: Size): ImageData;
    /**
     * Gets a single pixel value at the specified coordinates as a specific type.
     * Supports various color and vector types for different use cases.
     *
     * @param x - The x-coordinate of the pixel
     * @param y - The y-coordinate of the pixel
     * @param typeClass - The class type to return the pixel as (ColorRgb, ColorRgba, Vector3, etc.)
     * @returns An instance of the specified type containing the pixel data
     */
    getPixelAs(x: Index, y: Index, typeClass: typeof ColorRgb | typeof ColorRgba | typeof Vector3 | typeof MutableVector3 | typeof Vector4 | typeof MutableVector4): any;
    /**
     * Gets the pixel data at the specified coordinates as a raw Uint8ClampedArray.
     * This provides direct access to the RGBA values as 8-bit integers.
     *
     * @param x - The x-coordinate of the pixel
     * @param y - The y-coordinate of the pixel
     * @returns A Uint8ClampedArray containing the RGBA pixel data
     */
    getPixelAsArray(x: Index, y: Index): Uint8ClampedArray;
    /**
     * Sets a pixel value at the specified coordinates using a color or vector object.
     * Automatically determines the number of components based on the input type.
     *
     * @param x - The x-coordinate of the pixel
     * @param y - The y-coordinate of the pixel
     * @param value - The color or vector value to set
     */
    setPixel(x: Index, y: Index, value: ColorRgb | ColorRgba | Vector3 | MutableVector3 | Vector4 | MutableVector4): void;
    /**
     * Sets a specific channel value for a pixel at the given coordinates.
     * Useful for modifying individual color channels (R, G, B, A).
     *
     * @param x - The x-coordinate of the pixel
     * @param y - The y-coordinate of the pixel
     * @param channelIdx - The channel index (0=R, 1=G, 2=B, 3=A)
     * @param value - The new value for the channel (0-255)
     */
    setPixelAtChannel(x: Index, y: Index, channelIdx: Index, value: number): void;
    /**
     * Checks if the texture contains transparent pixels.
     *
     * @returns True if the texture has transparency, false otherwise
     */
    get isTransparent(): boolean;
    /**
     * Creates an internal canvas context for pixel manipulation operations.
     * Uses existing canvas element if available, otherwise creates a new one.
     */
    createInternalCanvasContext(): void;
    /**
     * Converts the texture data to a TextureDataFloat object with the specified number of channels.
     * This is useful for processing texture data in floating-point format.
     *
     * @param channels - The number of channels to include in the output (1-4)
     * @returns A TextureDataFloat object containing the converted pixel data
     */
    getTextureDataFloat(channels: Size): TextureDataFloat;
}

/**
 * A texture that can be used as a render target for off-screen rendering.
 * This class extends AbstractTexture and implements IRenderable to provide
 * functionality for rendering to texture, which is commonly used for
 * post-processing effects, shadow mapping, and other advanced rendering techniques.
 */
declare class RenderTargetTexture extends AbstractTexture implements IRenderable {
    private __fbo?;
    /**
     * Creates and initializes the render target texture with the specified parameters.
     *
     * @param params - Configuration object for the render target texture
     * @param params.width - Width of the texture in pixels
     * @param params.height - Height of the texture in pixels
     * @param params.mipLevelCount - Number of mip levels to generate (optional, defaults to full mip chain)
     * @param params.format - Internal format of the texture
     */
    create({ width, height, mipLevelCount, format: internalFormat, }: {
        width: Size;
        height: Size;
        mipLevelCount?: number;
        format: TextureFormatEnum;
    }): void;
    /**
     * Sets the framebuffer object associated with this render target texture.
     *
     * @param fbo - The FrameBuffer object to associate with this texture
     */
    set _fbo(fbo: FrameBuffer);
    /**
     * Gets the framebuffer object associated with this render target texture.
     *
     * @returns The associated FrameBuffer object, or undefined if not set
     */
    get fbo(): FrameBuffer | undefined;
    /**
     * Creates the underlying 3D API resources for the render target texture.
     * This method handles both WebGL and WebGPU resource creation.
     *
     * @private
     */
    private __createRenderTargetTexture;
    /**
     * Resizes the render target texture to the specified dimensions.
     * This operation destroys the existing resources and creates new ones.
     *
     * @param width - New width in pixels
     * @param height - New height in pixels
     */
    resize(width: Size, height: Size): void;
    /**
     * Destroys all 3D API resources associated with this render target texture.
     * This method should be called when the texture is no longer needed to free GPU memory.
     *
     * @returns True if the resources were successfully destroyed
     */
    destroy3DAPIResources(): boolean;
    /**
     * Retrieves the pixel data from the render target texture.
     * This operation reads back the texture data from GPU memory to CPU memory.
     *
     * @returns A promise that resolves to a Uint8Array containing the pixel data
     */
    getTexturePixelData(): Promise<Uint8Array<ArrayBufferLike>>;
    /**
     * Downloads the texture pixel data as a PNG image file.
     * This method creates a canvas, draws the texture data to it, and triggers
     * a download of the resulting image.
     */
    downloadTexturePixelData(): Promise<void>;
    /**
     * Gets the pixel value at the specified coordinates.
     * The coordinate system has its origin at the bottom-left corner.
     *
     * @param x - Horizontal pixel position (0 is left edge)
     * @param y - Vertical pixel position (0 is bottom edge)
     * @param argByteArray - Optional pre-fetched pixel data array to avoid redundant GPU reads
     * @returns A promise that resolves to a Vector4 containing the RGBA pixel values (0-255)
     */
    getPixelValueAt(x: Index, y: Index, argByteArray?: Uint8Array): Promise<Vector4>;
    /**
     * Generates mipmaps for the render target texture.
     * Mipmaps are pre-calculated, optimized sequences of images that accompany
     * a main texture, intended to increase rendering speed and reduce aliasing artifacts.
     */
    generateMipmaps(): void;
    /**
     * Creates a cube texture view as a render target for the specified face and mip level.
     * This method is currently not implemented and serves as a placeholder for future functionality.
     *
     * @param faceIdx - Index of the cube face (0-5)
     * @param mipLevel - Mip level to create the view for
     */
    createCubeTextureViewAsRenderTarget(_faceIdx: Index, _mipLevel: Index): void;
}

/**
 * FrameBuffer class represents a framebuffer object that manages render targets
 * for off-screen rendering operations. It handles color, depth, and stencil attachments
 * and provides methods to configure and manage the framebuffer state.
 */
declare class FrameBuffer extends RnObject {
    private __colorAttachments;
    private __depthAttachment?;
    private __stencilAttachment?;
    private __depthStencilAttachment?;
    cgApiResourceUid: CGAPIResourceHandle;
    width: Size;
    height: Size;
    private __colorAttachmentMap;
    /**
     * Gets the render buffer targets for all color attachments.
     * @returns Array of render buffer target enums for color attachments
     */
    get colorAttachmentsRenderBufferTargets(): RenderBufferTargetEnum[];
    /**
     * Gets all color attachments as an array of renderable objects.
     * @returns Array of color attachment renderables
     */
    get colorAttachments(): IRenderable[];
    /**
     * Gets the depth attachment if one is set.
     * @returns The depth attachment renderable or undefined
     */
    get depthAttachment(): IRenderable | undefined;
    /**
     * Gets the stencil attachment if one is set.
     * @returns The stencil attachment renderable or undefined
     */
    get stencilAttachment(): IRenderable | undefined;
    /**
     * Gets the depth-stencil attachment if one is set.
     * @returns The depth-stencil attachment renderable or undefined
     */
    get depthStencilAttachment(): IRenderable | undefined;
    /**
     * Gets the render target texture attached to the specified color attachment index.
     * @param index - The color attachment index
     * @returns The render target texture or undefined if not found or not a render target texture
     */
    getColorAttachedRenderTargetTexture(index: Index): RenderTargetTexture | undefined;
    /**
     * Gets the render target texture attached as the depth attachment.
     * @returns The depth render target texture or undefined if not found or not a render target texture
     */
    getDepthAttachedRenderTargetTexture(): RenderTargetTexture | undefined;
    /**
     * Creates and initializes the framebuffer with the specified dimensions.
     * @param width - The width of the framebuffer
     * @param height - The height of the framebuffer
     * @returns The CG API resource handle for the created framebuffer
     */
    create(width: Size, height: Size): number;
    /**
     * Gets the unique identifier for this framebuffer.
     * @returns The framebuffer's CG API resource handle
     */
    get framebufferUID(): number;
    /**
     * Sets a color attachment at the specified index.
     * @param index - The color attachment index
     * @param renderable - The renderable object to attach
     * @returns True if the attachment was successful, false if dimensions don't match
     */
    setColorAttachmentAt(index: Index, renderable: IRenderable): boolean;
    /**
     * Sets a color attachment layer at the specified index for array textures.
     * @param index - The color attachment index
     * @param renderable - The renderable object to attach
     * @param layerIndex - The layer index within the array texture
     * @param mipLevel - The mip level to attach
     * @returns True if the attachment was successful, false if dimensions don't match
     */
    setColorAttachmentLayerAt(index: Index, renderable: IRenderable, layerIndex: Index, mipLevel: Index): boolean;
    /**
     * Sets a color attachment for a specific face of a cube texture.
     * @param attachmentIndex - The color attachment index
     * @param faceIndex - The cube face index (0-5)
     * @param mipLevel - The mip level to attach
     * @param renderable - The cube texture renderable to attach
     * @returns True if the attachment was successful, false if dimensions don't match
     */
    setColorAttachmentCubeAt(attachmentIndex: Index, faceIndex: Index, mipLevel: Index, renderable: IRenderable): boolean;
    /**
     * Sets the depth attachment for this framebuffer.
     * @param renderable - The renderable object to use as depth attachment
     * @returns True if the attachment was successful, false if dimensions don't match
     */
    setDepthAttachment(renderable: IRenderable): boolean;
    /**
     * Sets the stencil attachment for this framebuffer.
     * @param renderable - The renderable object to use as stencil attachment
     * @returns True if the attachment was successful, false if dimensions don't match
     */
    setStencilAttachment(renderable: IRenderable): boolean;
    /**
     * Sets the combined depth-stencil attachment for this framebuffer.
     * @param renderable - The renderable object to use as depth-stencil attachment
     * @returns True if the attachment was successful, false if dimensions don't match
     */
    setDepthStencilAttachment(renderable: IRenderable): boolean;
    /**
     * Resizes the framebuffer and all its attachments to the specified dimensions.
     * This method destroys the current framebuffer and recreates it with new dimensions.
     * @param width - The new width
     * @param height - The new height
     */
    resize(width: Size, height: Size): void;
    /**
     * Destroys all 3D API resources associated with this framebuffer and its attachments.
     * This includes the framebuffer object itself and all attached render targets.
     * After calling this method, the framebuffer is no longer usable until recreated.
     */
    destroy3DAPIResources(): void;
    /**
     * Finds the index of the specified renderable in the color attachments array.
     * @param renderable - The renderable object to search for
     * @returns The index of the renderable in color attachments, or -1 if not found
     */
    whichColorAttachment(renderable: IRenderable): number;
}

/**
 * A render pass represents a collection of rendering resources and settings used in the rendering pipeline.
 * It manages entities, materials, framebuffers, and various rendering states to control how objects are rendered.
 *
 * @example
 * ```typescript
 * const renderPass = new RenderPass();
 * renderPass.addEntities([entity1, entity2]);
 * renderPass.setFramebuffer(framebuffer);
 * renderPass.toClearColorBuffer = true;
 * renderPass.clearColor = Vector4.fromCopyArray([0.2, 0.3, 0.4, 1.0]);
 * ```
 */
declare class RenderPass extends RnObject {
    private readonly __renderPassUID;
    private __entities;
    private __sceneGraphDirectlyAdded;
    private __topLevelSceneGraphComponents;
    private __meshComponents;
    private __optimizedMeshComponents;
    private __frameBuffer?;
    private __resolveFrameBuffer?;
    private __resolveFrameBuffer2?;
    private __viewport?;
    private __material?;
    private __primitiveMaterial;
    /** Whether to clear the color buffer before rendering */
    toClearColorBuffer: boolean;
    /** Whether to clear the depth buffer before rendering */
    toClearDepthBuffer: boolean;
    /** Whether to clear the stencil buffer before rendering */
    toClearStencilBuffer: boolean;
    /** Whether to enable depth testing during rendering */
    isDepthTest: boolean;
    /**
     * Depth write mask for primitives drawing.
     * When false, depth values are not written to the depth buffer, but depth clear is still performed.
     */
    depthWriteMask: boolean;
    /** The color value used to clear the color buffer (RGBA format) */
    clearColor: Vector4;
    /** The depth value used to clear the depth buffer (typically 1.0 for far plane) */
    clearDepth: number;
    /** The stencil value used to clear the stencil buffer */
    clearStencil: number;
    /** The camera component used for rendering this pass */
    cameraComponent?: CameraComponent;
    /**
     * If this value is greater than 1, buffer-less rendering is performed with the specified number of vertices.
     * In this case, registered entities are ignored and not rendered.
     */
    _drawVertexNumberForBufferLessRendering: number;
    /** The primitive mode used for buffer-less rendering */
    _primitiveModeForBufferLessRendering: PrimitiveModeEnum;
    /** A dummy primitive used for buffer-less rendering */
    _dummyPrimitiveForBufferLessRendering: Primitive;
    /** Whether VR rendering is enabled for this render pass */
    isVrRendering: boolean;
    /** Whether this render pass outputs for VR display */
    isOutputForVr: boolean;
    /** @internal Last index of opaque primitives in the render queue */
    _lastOpaqueIndex: number;
    /** @internal Last index of translucent primitives in the render queue */
    _lastTranslucentIndex: number;
    /** @internal Last index of blend with Z-write primitives in the render queue */
    _lastBlendWithZWriteIndex: number;
    /** @internal Last index of blend without Z-write primitives in the render queue */
    _lastBlendWithoutZWriteIndex: number;
    /** @internal Array of last primitive UIDs for optimization */
    _lastPrimitiveUids: number[];
    /** @internal Last transform components update count for change detection */
    _lastTransformComponentsUpdateCount: number;
    /** @internal Last camera controller components update count for change detection */
    _lastCameraControllerComponentsUpdateCount: number;
    /** @internal Last scene graph components update count for change detection */
    _lastSceneGraphComponentsUpdateCount: number;
    /** @internal Whether something was rendered in the previous frame */
    _renderedSomethingBefore: boolean;
    /** @internal Whether the sort render result has changed */
    _isChangedSortRenderResult: boolean;
    /** Whether to render opaque primitives contained in this render pass */
    _toRenderOpaquePrimitives: boolean;
    /** Whether to render translucent primitives contained in this render pass */
    _toRenderTranslucentPrimitives: boolean;
    /** Whether to render blend with Z-write primitives contained in this render pass */
    _toRenderBlendWithZWritePrimitives: boolean;
    /** Whether to render blend without Z-write primitives contained in this render pass */
    _toRenderBlendWithoutZWritePrimitives: boolean;
    /** Whether to render Effekseer effects in this render pass */
    toRenderEffekseerEffects: boolean;
    /** @internal Color attachment targets for rendering */
    __renderTargetColorAttachments?: RenderBufferTargetEnum[];
    /** @internal Function called before each render operation */
    private __preEachRenderFunc?;
    /** @internal Function called after each render operation */
    private __postEachRenderFunc?;
    /** @internal Temporary Vector4 for internal calculations */
    private static __tmp_Vector4_0;
    /** @internal Static counter for generating unique mesh UIDs */
    static __mesh_uid_count: number;
    /**
     * Creates a new RenderPass instance.
     * Automatically assigns a unique render pass UID.
     */
    constructor();
    /**
     * Sets whether to render opaque primitives in this render pass.
     * @param toRender - True to render opaque primitives, false to skip them
     */
    setToRenderOpaquePrimitives(toRender: boolean): void;
    /**
     * Sets whether to render blend without Z-write primitives in this render pass.
     * @param toRender - True to render blend without Z-write primitives, false to skip them
     */
    setToRenderBlendWithoutZWritePrimitives(toRender: boolean): void;
    /**
     * Sets whether to render blend with Z-write primitives in this render pass.
     * @param toRender - True to render blend with Z-write primitives, false to skip them
     */
    setToRenderBlendWithZWritePrimitives(toRender: boolean): void;
    /**
     * Sets whether to render translucent primitives in this render pass.
     * @param toRender - True to render translucent primitives, false to skip them
     */
    setToRenderTranslucentPrimitives(toRender: boolean): void;
    /**
     * Checks if this render pass is in buffer-less rendering mode.
     * @returns True if buffer-less rendering is enabled (vertex count > 0)
     */
    isBufferLessRenderingMode(): boolean;
    /**
     * Configures this render pass for buffer-less rendering mode.
     * In buffer-less rendering, vertices are generated procedurally without vertex buffers.
     * This is useful for full-screen effects or procedural geometry.
     * When enabled, registered entities are ignored and not rendered.
     *
     * @param primitiveMode - The primitive mode to use for rendering
     * @param drawVertexNumberWithoutEntities - Number of vertices to generate and render
     * @param material - The material to use for rendering
     */
    setBufferLessRendering(primitiveMode: PrimitiveModeEnum, drawVertexNumberWithoutEntities: number, material: Material): void;
    /**
     * Configures this render pass for full-screen buffer-less rendering.
     * This is a convenience method that sets up triangle-based full-screen rendering
     * with 3 vertices, commonly used for post-processing effects.
     *
     * @param material - The material to use for full-screen rendering
     */
    setBufferLessFullScreenRendering(material: Material): void;
    /**
     * Creates a deep clone of this render pass.
     * All properties and collections are copied, creating an independent instance.
     *
     * @returns A new RenderPass instance that is a copy of this one
     */
    clone(): RenderPass;
    /**
     * Sets a function to be called before each render operation.
     * This can be used for custom setup logic before rendering begins.
     *
     * @param func - The function to call before rendering
     */
    setPreRenderFunction(func: () => void): void;
    /**
     * Sets a function to be called after each render operation.
     * This can be used for custom cleanup logic after rendering completes.
     *
     * @param func - The function to call after rendering
     */
    setPostRenderFunction(func: () => void): void;
    /**
     * Executes the pre-render function if one has been set.
     * This method is called internally by the rendering system.
     *
     * @internal
     */
    doPreRender(): void;
    /**
     * Executes the post-render function if one has been set.
     * This method is called internally by the rendering system.
     *
     * @internal
     */
    doPostRender(): void;
    /**
     * Adds entities to be rendered in this render pass.
     * The entities and their hierarchies are flattened and collected for rendering.
     * Duplicate entities are automatically eliminated.
     *
     * @param entities - An array of scene graph entities to add
     */
    addEntities(entities: ISceneGraphEntity[]): void;
    /**
     * Recalculates and updates the mesh components collections.
     * This includes both the complete list and the optimized list based on rendering flags.
     *
     * @private
     */
    private __calcMeshComponents;
    /**
     * Gets the list of all entities in this render pass.
     * @returns An array of scene graph entities
     */
    get entities(): ISceneGraphEntity[];
    /**
     * Removes all entities from this render pass and clears related collections.
     * This effectively empties the render pass of all renderable content.
     */
    clearEntities(): void;
    /**
     * Collects and organizes the top-level scene graph components.
     * This method traverses the hierarchy to find root-level components.
     *
     * @private
     */
    private __collectTopLevelSceneGraphComponents;
    /**
     * Collects mesh components from entities and creates optimized collections.
     * The optimized collection excludes components based on rendering flags.
     *
     * @private
     */
    private __collectMeshComponents;
    /**
     * Gets all mesh components from entities in this render pass.
     * This includes all mesh components regardless of rendering flags.
     *
     * @returns An array of all mesh components
     */
    get meshComponents(): MeshComponent[];
    /**
     * Gets the optimized mesh components collection for rendering.
     * This collection is filtered based on the rendering flags for different primitive types.
     *
     * @returns An array of mesh components that should be rendered
     * @internal
     */
    get _optimizedMeshComponents(): MeshComponent[];
    /**
     * Gets all top-level scene graph components in this render pass.
     * These are the root components of the scene graph hierarchies.
     *
     * @returns An array of top-level scene graph components
     */
    get sceneTopLevelGraphComponents(): SceneGraphComponent[];
    /**
     * Sets the target framebuffer for this render pass.
     * If multiple render passes share a framebuffer, they will render to the same target.
     * Setting a framebuffer automatically configures the viewport to match the framebuffer size.
     *
     * @param framebuffer - The framebuffer to render to, or undefined to render to the default framebuffer
     */
    setFramebuffer(framebuffer?: FrameBuffer): void;
    /**
     * Sets the color attachment targets for rendering.
     * This specifies which color attachments of the framebuffer should be rendered to.
     *
     * @param indeces - Array of render buffer target enums, or undefined to use default targets
     */
    setRenderTargetColorAttachments(indeces?: RenderBufferTargetEnum[]): void;
    /**
     * Gets the current render target color attachments.
     * @returns Array of render buffer target enums, or undefined if using defaults
     */
    getRenderTargetColorAttachments(): RenderBufferTargetEnum[] | undefined;
    /**
     * Gets the current framebuffer assigned to this render pass.
     * @returns The framebuffer, or undefined if rendering to the default framebuffer
     */
    getFramebuffer(): FrameBuffer | undefined;
    /**
     * Removes the current framebuffer assignment.
     * After calling this, the render pass will render to the default framebuffer.
     */
    removeFramebuffer(): void;
    /**
     * Sets the viewport for this render pass.
     * The viewport defines the rectangular area of the framebuffer that will be rendered to.
     *
     * @param vec - A Vector4 containing (x, y, width, height) of the viewport
     */
    setViewport(vec: IVector4): void;
    /**
     * Gets the current viewport settings.
     * @returns A Vector4 containing (x, y, width, height) of the viewport, or undefined if not set
     */
    getViewport(): MutableVector4 | undefined;
    /**
     * Sets the resolve framebuffer for multisampling.
     * The resolve framebuffer is used as the destination when resolving multisampled content.
     *
     * @param framebuffer - The resolve framebuffer, or undefined to disable resolving
     */
    setResolveFramebuffer(framebuffer?: FrameBuffer): void;
    /**
     * Gets the current resolve framebuffer.
     * @returns The resolve framebuffer, or undefined if not set
     */
    getResolveFramebuffer(): FrameBuffer | undefined;
    /**
     * Sets the secondary resolve framebuffer.
     * This can be used for additional resolve operations or multi-target resolving.
     *
     * @param framebuffer - The secondary resolve framebuffer, or undefined to disable
     */
    setResolveFramebuffer2(framebuffer?: FrameBuffer): void;
    /**
     * Gets the current secondary resolve framebuffer.
     * @returns The secondary resolve framebuffer, or undefined if not set
     */
    getResolveFramebuffer2(): FrameBuffer | undefined;
    /**
     * Copies the main framebuffer content to both resolve framebuffers using WebGL.
     * This method handles the blit operations for multisampling resolve.
     *
     * @internal
     */
    _copyFramebufferToResolveFramebuffersWebGL(): void;
    /**
     * Internal helper method for copying framebuffer content to a resolve framebuffer.
     *
     * @param resolveFrameBuffer - The target resolve framebuffer
     * @private
     */
    private __copyFramebufferToResolveFramebufferInner;
    /**
     * Copies texture data from the first resolve framebuffer to the second using WebGPU.
     * This method handles texture copying operations for WebGPU-based rendering.
     *
     * @internal
     */
    _copyResolve1ToResolve2WebGpu(): void;
    /**
     * Associates a specific material with a primitive for this render pass.
     * When rendering the specified primitive, the render pass will use this material
     * instead of the primitive's default material.
     *
     * @param material - The material to use for the primitive
     * @param primitive - The target primitive to override the material for
     */
    setMaterialForPrimitive(material: Material, primitive: Primitive): void;
    /**
     * Sets a default material for all primitives in this render pass.
     * This material will be used for any primitive that doesn't have a specific
     * material override set via setMaterialForPrimitive().
     *
     * @param material - The default material to use for all primitives
     */
    setMaterial(material: Material): void;
    /**
     * Gets the default material assigned to this render pass.
     * @returns The default material, or undefined if none is set
     */
    get material(): Material | undefined;
    /**
     * Gets the specific material assigned to a primitive, if any.
     *
     * @param primitive - The primitive to get the material for
     * @returns The material assigned to the primitive, or undefined if none is set
     * @internal
     */
    _getMaterialOf(primitive: Primitive): Material | undefined;
    /**
     * Checks if a specific material has been assigned to a primitive.
     *
     * @param primitive - The primitive to check
     * @returns True if the primitive has a specific material assigned
     * @private
     */
    private __hasMaterialOf;
    /**
     * Determines the appropriate material to use for rendering a primitive.
     * The priority order is:
     * 1. Primitive-specific material (set via setMaterialForPrimitive)
     * 2. Render pass default material (set via setMaterial)
     * 3. Primitive's own material
     *
     * @param primitive - The primitive to get the material for
     * @returns The material that should be used for rendering the primitive
     */
    getAppropriateMaterial(primitive: Primitive): Material;
    /**
     * Gets the unique identifier for this render pass.
     * @returns The render pass UID
     */
    get renderPassUID(): number;
}

/**
 * A cube texture class that represents a cubemap texture for 3D rendering.
 * Cube textures are commonly used for environment mapping, skyboxes, and reflection mapping.
 * This class extends AbstractTexture and provides functionality to load cube textures from various sources
 * including files, Basis compressed textures, and typed arrays.
 *
 * @example
 * ```typescript
 * // Load cube texture from files
 * const cubeTexture = await CubeTexture.loadFromUrl({
 *   baseUrl: 'path/to/cubemap',
 *   mipmapLevelNumber: 1,
 *   isNamePosNeg: true,
 *   hdriFormat: HdriFormat.LDR_SRGB
 * });
 *
 * // Create a simple 1x1 cube texture
 * const simpleCube = new CubeTexture();
 * simpleCube.load1x1Texture('rgba(255,0,0,1)');
 * ```
 */
declare class CubeTexture extends AbstractTexture implements Disposable {
    /** The number of mipmap levels for this cube texture */
    mipmapLevelNumber: number;
    /** The HDRI format used for this cube texture */
    hdriFormat: EnumIO;
    /**
     * Registry for automatic cleanup of cube texture resources when objects are garbage collected.
     * This helps prevent memory leaks by automatically releasing WebGL/WebGPU resources.
     */
    private static managedRegistry;
    /**
     * Sets the texture resource UID and registers the texture for automatic cleanup.
     * This is an internal method used by the loading methods.
     *
     * @param textureResourceUid - The unique identifier for the texture resource
     * @param uniqueName - A unique name for the texture used in logging
     * @private
     */
    private __setTextureResourceUid;
    /**
     * Loads cube texture images from files asynchronously.
     * This method loads six cube faces from image files and creates a cube texture.
     *
     * @param options - Configuration options for loading the cube texture
     * @param options.baseUrl - Base URL path to the cube texture files
     * @param options.mipmapLevelNumber - Number of mipmap levels to generate
     * @param options.isNamePosNeg - Whether to use positive/negative naming convention (posX, negX, etc.)
     * @param options.hdriFormat - The HDRI format to use for the texture
     *
     * @example
     * ```typescript
     * const cubeTexture = new CubeTexture();
     * await cubeTexture.loadTextureImages({
     *   baseUrl: 'textures/skybox',
     *   mipmapLevelNumber: 1,
     *   isNamePosNeg: true,
     *   hdriFormat: HdriFormat.LDR_SRGB
     * });
     * ```
     */
    loadTextureImages({ baseUrl, mipmapLevelNumber, isNamePosNeg, hdriFormat, }: {
        baseUrl: string;
        mipmapLevelNumber: number;
        isNamePosNeg: boolean;
        hdriFormat: HdriFormatEnum;
    }): Promise<void>;
    /**
     * Loads cube texture from Basis compressed texture data.
     * Basis is a universal texture compression format that can be transcoded to various GPU formats.
     *
     * @param uint8Array - The Basis compressed texture data as a Uint8Array
     * @param options - Optional texture parameters for filtering and wrapping
     * @param options.magFilter - Magnification filter (default: Linear)
     * @param options.minFilter - Minification filter (default: LinearMipmapLinear)
     * @param options.wrapS - Texture wrapping mode for S coordinate (default: Repeat)
     * @param options.wrapT - Texture wrapping mode for T coordinate (default: Repeat)
     *
     * @throws Will log an error if BASIS transcoder is not available
     *
     * @example
     * ```typescript
     * const cubeTexture = new CubeTexture();
     * const basisData = new Uint8Array(basisFileBuffer);
     * cubeTexture.loadTextureImagesFromBasis(basisData, {
     *   magFilter: TextureParameter.Linear,
     *   minFilter: TextureParameter.LinearMipmapLinear
     * });
     * ```
     */
    loadTextureImagesFromBasis(uint8Array: Uint8Array, { magFilter, minFilter, wrapS, wrapT, }?: {
        magFilter?: TextureParameterEnum | undefined;
        minFilter?: TextureParameterEnum | undefined;
        wrapS?: TextureParameterEnum | undefined;
        wrapT?: TextureParameterEnum | undefined;
    }): void;
    /**
     * Creates a simple 1x1 pixel cube texture with a solid color.
     * This is useful for creating placeholder textures or solid color cube maps.
     *
     * @param rgbaStr - CSS color string in rgba format (default: 'rgba(0,0,0,1)' for black)
     *
     * @example
     * ```typescript
     * const cubeTexture = new CubeTexture();
     * cubeTexture.load1x1Texture('rgba(255,255,255,1)'); // White cube texture
     * cubeTexture.load1x1Texture('rgba(0,128,255,1)');   // Blue cube texture
     * ```
     */
    load1x1Texture(rgbaStr?: string): void;
    /**
     * Generates a cube texture from typed arrays containing raw image data.
     * This method allows creating cube textures from pre-processed image data with multiple mipmap levels.
     *
     * @param typedArrayImages - Array of typed array objects for cubemap textures.
     *                          Each element represents a mipmap level (index 0 is the base level).
     *                          Each object contains six faces: posX, negX, posY, negY, posZ, negZ.
     * @param baseLevelWidth - Width of the base level texture (mipmap level 0)
     * @param baseLevelHeight - Height of the base level texture (mipmap level 0)
     *
     * @example
     * ```typescript
     * const cubeTexture = new CubeTexture();
     * const imageData = [{
     *   posX: new Uint8Array(imageDataPosX),
     *   negX: new Uint8Array(imageDataNegX),
     *   posY: new Uint8Array(imageDataPosY),
     *   negY: new Uint8Array(imageDataNegY),
     *   posZ: new Uint8Array(imageDataPosZ),
     *   negZ: new Uint8Array(imageDataNegZ)
     * }];
     * cubeTexture.generateTextureFromTypedArrays(imageData, 512, 512);
     * ```
     */
    generateTextureFromTypedArrays(typedArrayImages: Array<{
        posX: TypedArray;
        negX: TypedArray;
        posY: TypedArray;
        negY: TypedArray;
        posZ: TypedArray;
        negZ: TypedArray;
    }>, baseLevelWidth: Size, baseLevelHeight: Size): void;
    /**
     * Imports an existing WebGL texture directly into this CubeTexture instance.
     * This method allows wrapping existing WebGL textures without creating new ones.
     *
     * @param webGLTexture - The existing WebGL texture object to import
     * @param width - Optional width of the texture (default: 0)
     * @param height - Optional height of the texture (default: 0)
     *
     * @example
     * ```typescript
     * const cubeTexture = new CubeTexture();
     * const existingTexture = gl.createTexture(); // Assume this is configured
     * cubeTexture.importWebGLTextureDirectly(existingTexture, 512, 512);
     * ```
     */
    importWebGLTextureDirectly(webGLTexture: WebGLTexture, width?: number, height?: number): void;
    /**
     * Deletes the internal texture resource from the graphics API.
     * This is a static utility method used internally for cleanup.
     *
     * @param textureResourceUid - The unique identifier of the texture resource to delete
     * @private
     */
    private static __deleteInternalTexture;
    /**
     * Destroys the 3D API resources associated with this cube texture.
     * This method releases the texture from GPU memory and resets the texture state.
     * After calling this method, the texture cannot be used for rendering until reloaded.
     */
    destroy3DAPIResources(): void;
    /**
     * Implements the Disposable interface for automatic resource cleanup.
     * This method is called when using the 'using' statement in TypeScript.
     *
     * @example
     * ```typescript
     * using cubeTexture = new CubeTexture();
     * // Texture will be automatically disposed when going out of scope
     * ```
     */
    [Symbol.dispose](): void;
    /**
     * Completely destroys this cube texture and releases all associated resources.
     * This method should be called when the texture is no longer needed to prevent memory leaks.
     * After calling destroy(), this texture instance should not be used.
     */
    destroy(): void;
    /**
     * Static factory method to create and load a cube texture from URL in one step.
     * This is a convenience method that combines instantiation and loading.
     *
     * @param options - Configuration options for loading the cube texture
     * @param options.baseUrl - Base URL path to the cube texture files
     * @param options.mipmapLevelNumber - Number of mipmap levels to generate
     * @param options.isNamePosNeg - Whether to use positive/negative naming convention
     * @param options.hdriFormat - The HDRI format to use for the texture
     * @returns Promise that resolves to a loaded CubeTexture instance
     *
     * @example
     * ```typescript
     * const cubeTexture = await CubeTexture.loadFromUrl({
     *   baseUrl: 'assets/skybox/sunset',
     *   mipmapLevelNumber: 1,
     *   isNamePosNeg: true,
     *   hdriFormat: HdriFormat.RGBE_PNG
     * });
     * ```
     */
    static loadFromUrl({ baseUrl, mipmapLevelNumber, isNamePosNeg, hdriFormat, }: {
        baseUrl: string;
        mipmapLevelNumber: number;
        isNamePosNeg: boolean;
        hdriFormat: HdriFormatEnum;
    }): Promise<CubeTexture>;
}

type RenderingArgWebGL = {
    glw: WebGLContextWrapper;
    entity: IMeshEntity;
    primitive: Primitive;
    worldMatrix: Matrix44;
    normalMatrix: IMatrix33;
    isBillboard: boolean;
    lightComponents: LightComponent[];
    renderPass: RenderPass;
    diffuseCube?: CubeTexture | RenderTargetTextureCube;
    specularCube?: CubeTexture | RenderTargetTextureCube;
    sheenCube?: CubeTexture | RenderTargetTextureCube;
    isVr: boolean;
    displayIdx: Index;
    setUniform: boolean;
};
type RenderingArgWebGpu = {
    cameraComponentSid: Index;
    entity: IMeshEntity;
    specularCube?: CubeTexture | RenderTargetTextureCube;
};
type AttributeNames = Array<string>;

interface BlendEnum extends EnumIO {
    webgpu: string;
}

/**
 * Base class for 2D vector implementations with different precision types.
 * This class provides common functionality for both 32-bit and 64-bit floating point vectors.
 *
 * @template T - The typed array constructor type (Float32Array or Float64Array)
 * @internal
 */
declare class Vector2_<T extends FloatTypedArrayConstructor> extends AbstractVector {
    /**
     * Creates a new Vector2_ instance.
     *
     * @param v - The typed array containing the vector components
     * @param options - Configuration object containing the array type
     */
    constructor(v: TypedArray, _options: {
        type: T;
    });
    /**
     * Gets the X component of the vector.
     *
     * @returns The X component value
     */
    get x(): number;
    /**
     * Gets the Y component of the vector.
     *
     * @returns The Y component value
     */
    get y(): number;
    /**
     * Converts the vector to a GLSL vec2 string representation with float precision.
     *
     * @returns GLSL-compatible vec2 string
     */
    get glslStrAsFloat(): string;
    /**
     * Converts the vector to a GLSL ivec2 string representation with integer precision.
     *
     * @returns GLSL-compatible ivec2 string
     */
    get glslStrAsInt(): string;
    /**
     * Converts the vector to a WGSL vec2f string representation with float precision.
     *
     * @returns WGSL-compatible vec2f string
     */
    get wgslStrAsFloat(): string;
    /**
     * Converts the vector to a WGSL vec2i string representation with integer precision.
     *
     * @returns WGSL-compatible vec2i string
     */
    get wgslStrAsInt(): string;
    /**
     * Gets the composition type of this vector.
     *
     * @returns The composition type (Vec2)
     */
    static get compositionType(): {
        readonly __numberOfComponents: number;
        readonly __glslStr: string;
        readonly __hlslStr: string;
        readonly __webgpuStr: string;
        readonly __wgslStr: string;
        readonly __isArray: boolean;
        readonly __vec4SizeOfProperty: IndexOf16Bytes;
        readonly __dummyStr: "VEC2";
        readonly webgpu: string;
        readonly wgsl: string;
        getNumberOfComponents(): Count;
        getGlslStr(componentType: ComponentTypeEnum): string;
        getGlslInitialValue(componentType: ComponentTypeEnum): string;
        getWgslInitialValue(componentType: ComponentTypeEnum): string;
        toWGSLType(componentType: ComponentTypeEnum): string;
        getVec4SizeOfProperty(): IndexOf16Bytes;
        readonly index: number;
        readonly symbol: symbol;
        readonly str: string;
        toString(): string;
        toJSON(): number;
    };
    /**
     * Calculates the squared length of a vector (static version).
     * This is more efficient than calculating the actual length when only comparison is needed.
     *
     * @param vec - The vector to calculate squared length for
     * @returns The squared length of the vector
     */
    static lengthSquared(vec: IVector2): number;
    /**
     * Calculates the distance between two vectors.
     *
     * @param l_vec - The first vector
     * @param r_vec - The second vector
     * @returns The distance between the vectors
     */
    static lengthBtw(l_vec: IVector2, r_vec: IVector2): number;
    /**
     * Calculates the angle between two vectors in radians.
     *
     * @param l_vec - The first vector
     * @param r_vec - The second vector
     * @returns The angle between the vectors in radians
     */
    static angleOfVectors(l_vec: IVector2, r_vec: IVector2): number;
    /**
     * Creates a zero vector (0, 0).
     *
     * @param type - The typed array constructor
     * @returns A new zero vector
     */
    static _zero(type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Creates a one vector (1, 1).
     *
     * @param type - The typed array constructor
     * @returns A new one vector
     */
    static _one(type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Creates a dummy vector with no components.
     *
     * @param type - The typed array constructor
     * @returns A new dummy vector
     */
    static _dummy(type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Normalizes a vector to unit length (static version).
     *
     * @param vec - The vector to normalize
     * @param type - The typed array constructor
     * @returns A new normalized vector
     */
    static _normalize(vec: IVector2, type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Adds two vectors component-wise (static version).
     *
     * @param l_vec - The left vector operand
     * @param r_vec - The right vector operand
     * @param type - The typed array constructor
     * @returns A new vector containing the sum
     */
    static _add(l_vec: IVector2, r_vec: IVector2, type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Adds two vectors component-wise and stores the result in the output vector.
     *
     * @param l_vec - The left vector operand
     * @param r_vec - The right vector operand
     * @param out - The output vector to store the result
     * @returns The output vector containing the sum
     */
    static addTo(l_vec: IVector2, r_vec: IVector2, out: IMutableVector2): IMutableVector2;
    /**
     * Subtracts the right vector from the left vector component-wise (static version).
     *
     * @param l_vec - The left vector operand
     * @param r_vec - The right vector operand
     * @param type - The typed array constructor
     * @returns A new vector containing the difference
     */
    static _subtract(l_vec: IVector2, r_vec: IVector2, type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Subtracts the right vector from the left vector component-wise and stores the result in the output vector.
     *
     * @param l_vec - The left vector operand
     * @param r_vec - The right vector operand
     * @param out - The output vector to store the result
     * @returns The output vector containing the difference
     */
    static subtractTo(l_vec: IVector2, r_vec: IVector2, out: IMutableVector2): IMutableVector2;
    /**
     * Multiplies a vector by a scalar value (static version).
     *
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @param type - The typed array constructor
     * @returns A new vector containing the scaled result
     */
    static _multiply(vec: IVector2, value: number, type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Multiplies a vector by a scalar value and stores the result in the output vector.
     *
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @param out - The output vector to store the result
     * @returns The output vector containing the scaled result
     */
    static multiplyTo(vec: IVector2, value: number, out: IMutableVector2): IMutableVector2;
    /**
     * Multiplies two vectors component-wise (static version).
     *
     * @param l_vec - The left vector operand
     * @param r_vec - The right vector operand
     * @param type - The typed array constructor
     * @returns A new vector containing the component-wise product
     */
    static _multiplyVector(l_vec: IVector2, r_vec: IVector2, type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Multiplies two vectors component-wise and stores the result in the output vector.
     *
     * @param l_vec - The left vector operand
     * @param r_vec - The right vector operand
     * @param out - The output vector to store the result
     * @returns The output vector containing the component-wise product
     */
    static multiplyVectorTo(l_vec: IVector2, r_vec: IVector2, out: IMutableVector2): IMutableVector2;
    /**
     * Divides a vector by a scalar value (static version).
     *
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @param type - The typed array constructor
     * @returns A new vector containing the divided result
     */
    static _divide(vec: IVector2, value: number, type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Divides a vector by a scalar value and stores the result in the output vector.
     *
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @param out - The output vector to store the result
     * @returns The output vector containing the divided result
     */
    static divideTo(vec: IVector2, value: number, out: IMutableVector2): IMutableVector2;
    /**
     * Divides the left vector by the right vector component-wise (static version).
     *
     * @param l_vec - The left vector operand (dividend)
     * @param r_vec - The right vector operand (divisor)
     * @param type - The typed array constructor
     * @returns A new vector containing the component-wise division result
     */
    static _divideVector(l_vec: IVector2, r_vec: IVector2, type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Divides the left vector by the right vector component-wise and stores the result in the output vector.
     *
     * @param l_vec - The left vector operand (dividend)
     * @param r_vec - The right vector operand (divisor)
     * @param out - The output vector to store the result
     * @returns The output vector containing the component-wise division result
     */
    static divideVectorTo(l_vec: IVector2, r_vec: IVector2, out: IMutableVector2): IMutableVector2;
    /**
     * Calculates the dot product of two vectors (static version).
     *
     * @param l_vec - The left vector operand
     * @param r_vec - The right vector operand
     * @returns The dot product of the two vectors
     */
    static dot(l_vec: IVector2, r_vec: IVector2): number;
    /**
     * Converts the vector to a string representation.
     *
     * @returns String representation in the format "(x, y)"
     */
    toString(): string;
    /**
     * Converts the vector to an approximate string representation with financial precision.
     *
     * @returns String representation with reduced decimal places
     */
    toStringApproximately(): string;
    /**
     * Converts the vector to a flat array representation.
     *
     * @returns Array containing [x, y] components
     */
    flattenAsArray(): number[];
    /**
     * Checks if this vector is a dummy (empty) vector.
     *
     * @returns True if the vector has no components, false otherwise
     */
    isDummy(): boolean;
    /**
     * Checks if this vector is approximately equal to another vector within a tolerance.
     *
     * @param vec - The vector to compare with
     * @param delta - The tolerance value (default: Number.EPSILON)
     * @returns True if vectors are approximately equal, false otherwise
     */
    isEqual(vec: IVector2, delta?: number): boolean;
    /**
     * Checks if this vector is strictly equal to another vector (exact comparison).
     *
     * @param vec - The vector to compare with
     * @returns True if vectors are exactly equal, false otherwise
     */
    isStrictEqual(vec: IVector2): boolean;
    /**
     * Gets the component at the specified index.
     *
     * @param i - The index (0 for x, 1 for y)
     * @returns The component value at the specified index
     */
    at(i: number): number;
    /**
     * Calculates the length (magnitude) of the vector.
     *
     * @returns The length of the vector
     */
    length(): number;
    /**
     * Calculates the squared length of the vector.
     * This is more efficient than calculating the actual length when only comparison is needed.
     *
     * @returns The squared length of the vector
     */
    lengthSquared(): number;
    /**
     * Calculates the distance from this vector to another vector.
     *
     * @param vec - The target vector
     * @returns The distance between the vectors
     */
    lengthTo(vec: IVector2): number;
    /**
     * Calculates the dot product with another vector.
     *
     * @param vec - The vector to calculate dot product with
     * @returns The dot product result
     */
    dot(vec: IVector2): number;
    /**
     * Creates a clone of this vector.
     *
     * @returns A new vector with the same components
     */
    clone(): any;
    /**
     * Creates a vector from a 2-element array.
     *
     * @param array - The array containing [x, y] components
     * @param type - The typed array constructor
     * @returns A new vector instance
     */
    static _fromCopyArray2(array: Array2<number>, type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Creates a vector from individual x and y components.
     *
     * @param x - The x component
     * @param y - The y component
     * @param type - The typed array constructor
     * @returns A new vector instance
     */
    static _fromCopy2(x: number, y: number, type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Creates a vector from an array, taking the first 2 elements.
     *
     * @param array - The array containing components
     * @param type - The typed array constructor
     * @returns A new vector instance
     */
    static _fromCopyArray(array: Array<number>, type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Creates a vector from another IVector2 by sharing the underlying array.
     *
     * @param vec2 - The source vector
     * @param type - The typed array constructor
     * @returns A new vector instance
     */
    static _fromVector2(vec2: IVector2, type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Creates a vector by copying components from another IVector2.
     *
     * @param vec2 - The source vector
     * @param type - The typed array constructor
     * @returns A new vector instance
     */
    static _fromCopyVector2(vec2: IVector2, type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Creates a vector by copying the first 2 components from a 3D vector.
     *
     * @param vec3 - The source 3D vector
     * @param type - The typed array constructor
     * @returns A new vector instance
     */
    static _fromCopyVector3(vec3: IVector3, type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Creates a vector by copying the first 2 components from a 4D vector.
     *
     * @param vec4 - The source 4D vector
     * @param type - The typed array constructor
     * @returns A new vector instance
     */
    static _fromCopyVector4(vec4: IVector4, type: FloatTypedArrayConstructor): Vector2_<FloatTypedArrayConstructor>;
    /**
     * Gets the number of bytes per component in the underlying typed array.
     *
     * @returns The number of bytes per component
     */
    get bytesPerComponent(): number;
}
/**
 * Immutable 2D vector class with 32-bit float components.
 * This class provides comprehensive vector operations for 2D graphics and mathematics.
 * All operations return new vector instances, preserving immutability.
 */
declare class Vector2 extends Vector2_<Float32ArrayConstructor> implements IVector, IVector2 {
    /**
     * Creates a new Vector2 instance.
     *
     * @param x - The typed array containing the vector components
     */
    constructor(x: TypedArray);
    /**
     * Creates a vector from a 2-element array.
     *
     * @param array - The array containing [x, y] components
     * @returns A new Vector2 instance
     */
    static fromCopyArray2(array: Array2<number>): Vector2;
    /**
     * Creates a vector from individual x and y components.
     *
     * @param x - The x component
     * @param y - The y component
     * @returns A new Vector2 instance
     */
    static fromCopy2(x: number, y: number): Vector2;
    /**
     * Creates a vector from an array, taking the first 2 elements.
     *
     * @param array - The array containing components
     * @returns A new Vector2 instance
     */
    static fromCopyArray(array: Array<number>): Vector2;
    /**
     * Creates a vector by copying components from another IVector2.
     *
     * @param vec2 - The source vector
     * @returns A new Vector2 instance
     */
    static fromCopyVector2(vec2: IVector2): Vector2;
    /**
     * Creates a vector by copying the first 2 components from a 4D vector.
     *
     * @param vec4 - The source 4D vector
     * @returns A new Vector2 instance
     */
    static fromCopyVector4(vec4: IVector4): Vector2;
    /**
     * Creates a zero vector (0, 0).
     *
     * @returns A new zero Vector2 instance
     */
    static zero(): Vector2;
    /**
     * Creates a one vector (1, 1).
     *
     * @returns A new one Vector2 instance
     */
    static one(): Vector2;
    /**
     * Creates a dummy vector with no components.
     *
     * @returns A new dummy Vector2 instance
     */
    static dummy(): Vector2;
    /**
     * Normalizes a vector to unit length.
     *
     * @param vec - The vector to normalize
     * @returns A new normalized Vector2 instance
     */
    static normalize(vec: IVector2): Vector2;
    /**
     * Adds two vectors component-wise.
     *
     * @param l_vec - The left vector operand
     * @param r_vec - The right vector operand
     * @returns A new Vector2 instance containing the sum
     */
    static add(l_vec: IVector2, r_vec: IVector2): Vector2;
    /**
     * Subtracts the right vector from the left vector component-wise.
     *
     * @param l_vec - The left vector operand
     * @param r_vec - The right vector operand
     * @returns A new Vector2 instance containing the difference
     */
    static subtract(l_vec: IVector2, r_vec: IVector2): Vector2;
    /**
     * Multiplies a vector by a scalar value.
     *
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @returns A new Vector2 instance containing the scaled result
     */
    static multiply(vec: IVector2, value: number): Vector2;
    /**
     * Multiplies two vectors component-wise.
     *
     * @param l_vec - The left vector operand
     * @param r_vec - The right vector operand
     * @returns A new Vector2 instance containing the component-wise product
     */
    static multiplyVector(l_vec: IVector2, r_vec: IVector2): Vector2;
    /**
     * Divides a vector by a scalar value.
     *
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @returns A new Vector2 instance containing the divided result
     */
    static divide(vec: IVector2, value: number): Vector2;
    /**
     * Divides the left vector by the right vector component-wise.
     *
     * @param l_vec - The left vector operand (dividend)
     * @param r_vec - The right vector operand (divisor)
     * @returns A new Vector2 instance containing the component-wise division result
     */
    static divideVector(l_vec: IVector2, r_vec: IVector2): Vector2;
    /**
     * Gets the class name.
     *
     * @returns The string "Vector2"
     */
    get className(): string;
    /**
     * Creates a clone of this vector.
     *
     * @returns A new Vector2 instance with the same components
     */
    clone(): Vector2;
}
/**
 * Immutable 2D vector class with 64-bit float components.
 * This class provides high-precision vector operations for applications requiring double precision.
 * All operations return new vector instances, preserving immutability.
 */
declare class Vector2d extends Vector2_<Float64ArrayConstructor> {
    /**
     * Creates a new Vector2d instance.
     *
     * @param x - The typed array containing the vector components
     */
    constructor(x: TypedArray);
    /**
     * Creates a vector from a 2-element array.
     *
     * @param array - The array containing [x, y] components
     * @returns A new Vector2d instance
     */
    static fromCopyArray2(array: Array2<number>): Vector2d;
    /**
     * Creates a vector from individual x and y components.
     *
     * @param x - The x component
     * @param y - The y component
     * @returns A new Vector2d instance
     */
    static fromCopy2(x: number, y: number): Vector2d;
    /**
     * Creates a vector from an array, taking the first 2 elements.
     *
     * @param array - The array containing components
     * @returns A new Vector2d instance
     */
    static fromCopyArray(array: Array<number>): Vector2d;
    /**
     * Creates a vector from an ArrayBuffer.
     *
     * @param arrayBuffer - The ArrayBuffer containing the vector data
     * @returns A new Vector2d instance
     */
    static fromArrayBuffer(arrayBuffer: ArrayBuffer): Vector2d;
    /**
     * Creates a vector from a Float64Array.
     *
     * @param float64Array - The Float64Array containing the vector data
     * @returns A new Vector2d instance
     */
    static fromFloat64Array(float64Array: Float64Array): Vector2d;
    /**
     * Creates a zero vector (0, 0).
     *
     * @returns A new zero Vector2d instance
     */
    static zero(): Vector2d;
    /**
     * Creates a one vector (1, 1).
     *
     * @returns A new one Vector2d instance
     */
    static one(): Vector2d;
    /**
     * Creates a dummy vector with no components.
     *
     * @returns A new dummy Vector2d instance
     */
    static dummy(): Vector2d;
    /**
     * Normalizes a vector to unit length.
     *
     * @param vec - The vector to normalize
     * @returns A new normalized Vector2d instance
     */
    static normalize(vec: IVector2): Vector2d;
    /**
     * Adds two vectors component-wise.
     *
     * @param l_vec - The left vector operand
     * @param r_vec - The right vector operand
     * @returns A new Vector2d instance containing the sum
     */
    static add(l_vec: IVector2, r_vec: IVector2): Vector2d;
    /**
     * Subtracts the right vector from the left vector component-wise.
     *
     * @param l_vec - The left vector operand
     * @param r_vec - The right vector operand
     * @returns A new Vector2d instance containing the difference
     */
    static subtract(l_vec: IVector2, r_vec: IVector2): Vector2d;
    /**
     * Multiplies a vector by a scalar value.
     *
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @returns A new Vector2d instance containing the scaled result
     */
    static multiply(vec: IVector2, value: number): Vector2d;
    /**
     * Multiplies two vectors component-wise.
     *
     * @param l_vec - The left vector operand
     * @param r_vec - The right vector operand
     * @returns A new Vector2d instance containing the component-wise product
     */
    static multiplyVector(l_vec: IVector2, r_vec: IVector2): Vector2d;
    /**
     * Divides a vector by a scalar value.
     *
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @returns A new Vector2d instance containing the divided result
     */
    static divide(vec: IVector2, value: number): Vector2d;
    /**
     * Divides the left vector by the right vector component-wise.
     *
     * @param l_vec - The left vector operand (dividend)
     * @param r_vec - The right vector operand (divisor)
     * @returns A new Vector2d instance containing the component-wise division result
     */
    static divideVector(l_vec: IVector2, r_vec: IVector2): Vector2d;
    /**
     * Creates a clone of this vector.
     *
     * @returns A new Vector2d instance with the same components
     */
    clone(): Vector2d;
}
/**
 * Type alias for Vector2 using 32-bit float components.
 */
type Vector2f = Vector2;
/**
 * Constant Vector2 instance representing (1, 1).
 */
declare const ConstVector2_1_1: Vector2;
/**
 * Constant Vector2 instance representing (0, 0).
 */
declare const ConstVector2_0_0: Vector2;

/**
 * Base class for mutable 2D vectors with generic typed array support.
 * Provides mutable operations for vector manipulation that modify the vector in place.
 *
 * @template T - The typed array constructor type (Float32Array or Float64Array)
 * @internal
 */
declare class MutableVector2_<T extends FloatTypedArrayConstructor> extends Vector2_<T> {
    /**
     * Creates a new mutable 2D vector instance.
     *
     * @param x - The typed array containing vector components
     * @param options - Configuration object containing the array type
     */
    constructor(x: TypedArray, { type }: {
        type: T;
    });
    /**
     * Sets the x component of the vector.
     *
     * @param x - The new x component value
     */
    set x(x: number);
    /**
     * Gets the x component of the vector.
     *
     * @returns The x component value
     */
    get x(): number;
    /**
     * Sets the y component of the vector.
     *
     * @param y - The new y component value
     */
    set y(y: number);
    /**
     * Gets the y component of the vector.
     *
     * @returns The y component value
     */
    get y(): number;
    /**
     * Gets the z component of the vector (always 0 for 2D vectors).
     *
     * @returns Always returns 0
     */
    get z(): number;
    /**
     * Gets the w component of the vector (always 1 for homogeneous coordinates).
     *
     * @returns Always returns 1
     */
    get w(): number;
    /**
     * Returns the raw typed array containing the vector components.
     *
     * @returns The underlying typed array
     */
    raw(): TypedArray;
    /**
     * Sets the value at the specified index.
     *
     * @param i - The component index (0 for x, 1 for y)
     * @param value - The value to set
     * @returns This vector instance for method chaining
     */
    setAt(i: number, value: number): this;
    /**
     * Sets both x and y components of the vector.
     *
     * @param x - The x component value
     * @param y - The y component value
     * @returns This vector instance for method chaining
     */
    setComponents(x: number, y: number): this;
    /**
     * Copies components from another vector to this vector.
     *
     * @param vec - The source vector to copy from
     * @returns This vector instance for method chaining
     */
    copyComponents(vec: IVector2): this;
    /**
     * Sets both components to zero.
     *
     * @returns This vector instance for method chaining
     */
    zero(): this;
    /**
     * Sets both components to one.
     *
     * @returns This vector instance for method chaining
     */
    one(): this;
    /**
     * Normalizes this vector to unit length (modifies the vector in place).
     * If the vector has zero length, the result is undefined.
     *
     * @returns This vector instance for method chaining
     */
    normalize(): this;
    /**
     * Adds another vector to this vector (modifies this vector in place).
     *
     * @param vec - The vector to add
     * @returns This vector instance for method chaining
     */
    add(vec: IVector2): this;
    /**
     * Subtracts another vector from this vector (modifies this vector in place).
     *
     * @param vec - The vector to subtract
     * @returns This vector instance for method chaining
     */
    subtract(vec: IVector2): this;
    /**
     * Multiplies this vector by a scalar value (modifies this vector in place).
     *
     * @param value - The scalar value to multiply by
     * @returns This vector instance for method chaining
     */
    multiply(value: number): this;
    /**
     * Multiplies this vector component-wise by another vector (modifies this vector in place).
     *
     * @param vec - The vector to multiply by
     * @returns This vector instance for method chaining
     */
    multiplyVector(vec: IVector2): this;
    /**
     * Divides this vector by a scalar value (modifies this vector in place).
     * If the divisor is zero, sets components to Infinity and logs an error.
     *
     * @param value - The scalar value to divide by
     * @returns This vector instance for method chaining
     */
    divide(value: number): this;
    /**
     * Divides this vector component-wise by another vector (modifies this vector in place).
     * If any component of the divisor is zero, sets that component to Infinity and logs an error.
     *
     * @param vec - The vector to divide by
     * @returns This vector instance for method chaining
     */
    divideVector(vec: IVector2): this;
    /**
     * Gets the number of bytes per component in the underlying typed array.
     *
     * @returns The number of bytes per element
     */
    get bytesPerComponent(): number;
}
/**
 * Mutable 2D vector class with 32-bit float components.
 * Provides efficient vector operations that modify the vector in place,
 * implementing both IMutableVector and IMutableVector2 interfaces.
 *
 * @example
 * ```typescript
 * const vec = MutableVector2.zero();
 * vec.setComponents(3, 4);
 * vec.normalize(); // vec is now (0.6, 0.8)
 * ```
 */
declare class MutableVector2 extends MutableVector2_<Float32ArrayConstructor> implements IMutableVector, IMutableVector2 {
    /**
     * Creates a new mutable 2D vector with 32-bit float components.
     *
     * @param x - The typed array containing vector components
     */
    constructor(x: TypedArray);
    /**
     * Creates a new vector from a 2-element array by copying the values.
     *
     * @param array - A 2-element array containing [x, y] components
     * @returns A new MutableVector2 instance
     */
    static fromCopyArray2(array: Array2<number>): MutableVector2;
    /**
     * Creates a new vector from an array by copying the first two values.
     *
     * @param array - An array containing at least 2 numeric values
     * @returns A new MutableVector2 instance
     */
    static fromCopyArray(array: Array<number>): MutableVector2;
    /**
     * Creates a new vector from an existing Float32Array (shares the same buffer).
     *
     * @param float32Array - The Float32Array to use as the vector's data
     * @returns A new MutableVector2 instance
     */
    static fromFloat32Array(float32Array: Float32Array): MutableVector2;
    /**
     * Creates a new vector by copying data from an existing Float32Array.
     *
     * @param float32Array - The Float32Array to copy from
     * @returns A new MutableVector2 instance with copied data
     */
    static fromCopyFloat32Array(float32Array: Float32Array): MutableVector2;
    /**
     * Creates a zero vector (0, 0).
     *
     * @returns A new MutableVector2 instance with zero components
     */
    static zero(): MutableVector2;
    /**
     * Creates a vector with all components set to one (1, 1).
     *
     * @returns A new MutableVector2 instance with components set to 1
     */
    static one(): MutableVector2;
    /**
     * Creates a dummy vector for placeholder purposes.
     *
     * @returns A new MutableVector2 instance
     */
    static dummy(): MutableVector2;
    /**
     * Creates a normalized copy of the given vector.
     *
     * @param vec - The vector to normalize
     * @returns A new normalized MutableVector2 instance
     */
    static normalize(vec: IVector2): MutableVector2;
    /**
     * Creates a new vector by adding two vectors.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new MutableVector2 instance containing the sum
     */
    static add(l_vec: IVector2, r_vec: IVector2): MutableVector2;
    /**
     * Creates a new vector by subtracting the second vector from the first.
     *
     * @param l_vec - The vector to subtract from
     * @param r_vec - The vector to subtract
     * @returns A new MutableVector2 instance containing the difference
     */
    static subtract(l_vec: IVector2, r_vec: IVector2): MutableVector2;
    /**
     * Creates a new vector by multiplying a vector by a scalar.
     *
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @returns A new MutableVector2 instance containing the scaled vector
     */
    static multiply(vec: IVector2, value: number): MutableVector2;
    /**
     * Creates a new vector by multiplying two vectors component-wise.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new MutableVector2 instance containing the component-wise product
     */
    static multiplyVector(l_vec: IVector2, r_vec: IVector2): MutableVector2;
    /**
     * Creates a new vector by dividing a vector by a scalar.
     *
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @returns A new MutableVector2 instance containing the divided vector
     */
    static divide(vec: IVector2, value: number): MutableVector2;
    /**
     * Creates a new vector by dividing two vectors component-wise.
     *
     * @param l_vec - The dividend vector
     * @param r_vec - The divisor vector
     * @returns A new MutableVector2 instance containing the component-wise quotient
     */
    static divideVector(l_vec: IVector2, r_vec: IVector2): MutableVector2;
    /**
     * Gets the class name for debugging and reflection purposes.
     *
     * @returns The string "MutableVector2"
     */
    get className(): string;
    /**
     * Creates a deep copy of this vector.
     *
     * @returns A new MutableVector2 instance with the same component values
     */
    clone(): MutableVector2;
}
/**
 * Mutable 2D vector class with 64-bit float components.
 * Provides high-precision vector operations for applications requiring
 * double-precision floating-point arithmetic.
 *
 * @example
 * ```typescript
 * const vec = MutableVector2d.zero();
 * vec.setComponents(1.23456789012345, 2.34567890123456);
 * ```
 */
declare class MutableVector2d extends MutableVector2_<Float64ArrayConstructor> {
    /**
     * Creates a new mutable 2D vector with 64-bit float components.
     *
     * @param x - The typed array containing vector components
     */
    constructor(x: TypedArray);
    /**
     * Creates a new vector from a 2-element array by copying the values.
     *
     * @param array - A 2-element array containing [x, y] components
     * @returns A new MutableVector2d instance
     */
    static fromCopyArray(array: Array2<number>): MutableVector2d;
    /**
     * Creates a zero vector (0, 0) with double precision.
     *
     * @returns A new MutableVector2d instance with zero components
     */
    static zero(): MutableVector2d;
    /**
     * Creates a vector with all components set to one (1, 1) with double precision.
     *
     * @returns A new MutableVector2d instance with components set to 1
     */
    static one(): MutableVector2d;
    /**
     * Creates a dummy vector for placeholder purposes with double precision.
     *
     * @returns A new MutableVector2d instance
     */
    static dummy(): MutableVector2d;
    /**
     * Creates a normalized copy of the given vector with double precision.
     *
     * @param vec - The vector to normalize
     * @returns A new normalized MutableVector2d instance
     */
    static normalize(vec: IVector2): MutableVector2d;
    /**
     * Creates a new vector by adding two vectors with double precision.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new MutableVector2d instance containing the sum
     */
    static add(l_vec: IVector2, r_vec: IVector2): MutableVector2d;
    /**
     * Creates a new vector by subtracting the second vector from the first with double precision.
     *
     * @param l_vec - The vector to subtract from
     * @param r_vec - The vector to subtract
     * @returns A new MutableVector2d instance containing the difference
     */
    static subtract(l_vec: IVector2, r_vec: IVector2): MutableVector2d;
    /**
     * Creates a new vector by multiplying a vector by a scalar with double precision.
     *
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @returns A new MutableVector2d instance containing the scaled vector
     */
    static multiply(vec: IVector2, value: number): MutableVector2d;
    /**
     * Creates a new vector by multiplying two vectors component-wise with double precision.
     *
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new MutableVector2d instance containing the component-wise product
     */
    static multiplyVector(l_vec: IVector2, r_vec: IVector2): MutableVector2d;
    /**
     * Creates a new vector by dividing a vector by a scalar with double precision.
     *
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @returns A new MutableVector2d instance containing the divided vector
     */
    static divide(vec: IVector2, value: number): MutableVector2d;
    /**
     * Creates a new vector by dividing two vectors component-wise with double precision.
     *
     * @param l_vec - The dividend vector
     * @param r_vec - The divisor vector
     * @returns A new MutableVector2d instance containing the component-wise quotient
     */
    static divideVector(l_vec: IVector2, r_vec: IVector2): MutableVector2d;
    /**
     * Creates a deep copy of this vector with double precision.
     *
     * @returns A new MutableVector2d instance with the same component values
     */
    clone(): MutableVector2d;
}
/**
 * Type alias for MutableVector2 using 32-bit float components.
 * Provides a more explicit name for single-precision mutable vectors.
 */
type MutableVector2f = MutableVector2;

/**
 * Custom exception class for Rhodonite framework errors.
 * This class extends the standard Error class to provide enhanced error handling
 * with structured error information from RnError objects.
 *
 * @template ErrObj - The type of the error object contained within the RnError
 *
 * @example
 * ```typescript
 * const rnError: RnError<string> = {
 *   message: "Operation failed",
 *   error: "Invalid parameter"
 * };
 * const exception = new RnException(rnError);
 * throw exception;
 * ```
 */
declare class RnException<ErrObj> extends Error {
    private err;
    /** Prefix string used in the exception name to identify Rhodonite exceptions */
    static readonly _prefix = "\nRhodonite Exception";
    /**
     * Creates a new RnException instance.
     *
     * @param err - The RnError object containing the error message and details
     *
     * @remarks
     * The constructor automatically formats the error message to include both
     * the message and error details. If the error object contains a nested
     * RnException, it will display "see below Exception " followed by the
     * nested exception's string representation.
     */
    constructor(err: RnError<ErrObj>);
    /**
     * Retrieves the original RnError object that was used to create this exception.
     *
     * @returns The RnError object containing the original error message and details
     *
     * @example
     * ```typescript
     * try {
     *   // some operation that throws RnException
     * } catch (error) {
     *   if (error instanceof RnException) {
     *     const originalError = error.getRnError();
     *     console.log(originalError.message);
     *   }
     * }
     * ```
     */
    getRnError(): RnError<ErrObj>;
}

/**
 * Represents an error object containing a message and error details.
 * @template ErrObj - The type of the error object
 */
interface RnError<ErrObj> {
    /** The error message */
    message: string;
    /** The error object containing additional error details */
    error: ErrObj;
}
/**
 * An interface to handle results in a unified manner,
 * regardless of whether they are successful or not.
 * This follows the Result pattern commonly used in functional programming.
 * @template T - The type of the success value
 * @template ErrObj - The type of the error object
 */
interface IResult<T, ErrObj> {
    /**
     * Chains operations on successful results. If this result is Ok, applies the function
     * to the contained value. If this result is Err, returns the error unchanged.
     * @template U - The type of the new success value
     * @param f - Function to apply to the success value
     * @returns A new Result containing either the transformed value or the original error
     */
    andThen<U>(f: (value: T) => Result<U, ErrObj>): Result<U, ErrObj>;
    /**
     * Provides an alternative result if this result is an error.
     * If this result is Ok, returns this result unchanged.
     * If this result is Err, returns the result of the provided function.
     * @template U - The type of the alternative success value
     * @param f - Function that provides an alternative result
     * @returns This result if Ok, otherwise the alternative result
     */
    orElse<U>(f: () => Result<U, ErrObj>): Result<U, ErrObj>;
    /**
     * Pattern matching for Result types. Executes the appropriate function
     * based on whether this result is Ok or Err.
     * @template R - The type of the return value from the Ok function
     * @template ErrObj2 - The type of the new error object
     * @param obj - Object containing pattern matching functions for Ok and Err cases
     * @param obj.Ok - Function to execute if this result is Ok
     * @param obj.Err - Function to execute if this result is Err
     * @returns A new Result containing the result of the pattern matching
     */
    match<R, ErrObj2>({ Ok, Err, }: {
        Ok: (value: T) => R;
        Err: (value: RnError<ErrObj>) => RnError<ErrObj2>;
    }): Result<R, ErrObj2>;
    /**
     * Safely extracts the inner value with error compensation.
     * If the result is Ok, returns the contained value.
     * If the result is Err, calls the compensation function to provide a fallback value.
     * @param catchFn - Function that provides a fallback value in case of error
     * @returns The success value or the compensated value
     */
    unwrapWithCompensation(catchFn: (err: RnError<ErrObj>) => T): T;
    /**
     * Forcefully extracts the inner value.
     * If the result is Ok, returns the contained value.
     * If the result is Err, throws an exception.
     * @throws {RnException} When called on an Err result
     * @returns The success value
     */
    unwrapForce(): T;
    /**
     * Type guard to check if this result is Ok.
     * @returns True if this result is Ok, false otherwise
     */
    isOk(): this is Ok<T, ErrObj>;
    /**
     * Type guard to check if this result is Err.
     * @returns True if this result is Err, false otherwise
     */
    isErr(): this is Err<T, ErrObj>;
    /**
     * Gets the class name of this result.
     * @returns The name of the class ('Ok' or 'Err')
     */
    name(): string;
}
/**
 * Abstract base class for Result implementations.
 * Provides common functionality for both Ok and Err classes.
 * @template T - The type of the success value
 * @template ErrObj - The type of the error object
 */
declare abstract class CResult<T, ErrObj> {
    protected val?: (T | RnError<ErrObj>) | undefined;
    /**
     * Creates a new CResult instance.
     * @param val - The value to store (either success value or error)
     */
    constructor(val?: (T | RnError<ErrObj>) | undefined);
    /**
     * Pattern matching implementation for Result types.
     * @template R - The type of the return value from the Ok function
     * @template ErrObj2 - The type of the new error object
     * @param obj - Object containing pattern matching functions
     * @param obj.Ok - Function to execute if this result is Ok
     * @param obj.Err - Function to execute if this result is Err
     * @returns A new Result containing the result of the pattern matching
     * @throws {Error} If the result is neither Ok nor Err
     */
    match<R, ErrObj2>(obj: {
        Ok: (value: T) => R;
        Err: (value: RnError<ErrObj>) => RnError<ErrObj2>;
    }): Result<R, ErrObj2>;
    /**
     * Gets the name of this result class.
     * @returns The constructor name ('Ok' or 'Err')
     */
    name(): string;
}
/**
 * Represents a successful result containing a value.
 * This class indicates that an operation completed successfully.
 * @template T - The type of the success value
 * @template ErrObj - The type of the error object (for type compatibility)
 */
declare class Ok<T, ErrObj> extends CResult<T, ErrObj> implements IResult<T, ErrObj> {
    /**
     * Chains operations on this successful result.
     * Applies the provided function to the contained value.
     * @template U - The type of the new success value
     * @param f - Function to apply to the success value
     * @returns The result of applying the function
     */
    andThen<U>(f: (value: T) => Result<U, ErrObj>): Result<U, ErrObj>;
    /**
     * Returns this Ok result unchanged since it's already successful.
     * The alternative function is not called.
     * @template U - The type of the alternative success value
     * @param f - Alternative function (not called for Ok results)
     * @returns This Ok result cast to the new type
     */
    orElse<U>(_f: () => Result<U, ErrObj>): Result<U, ErrObj>;
    /**
     * Returns the contained value since this is a successful result.
     * The compensation function is not called.
     * @param catchFn - Compensation function (not called for Ok results)
     * @returns The contained success value
     */
    unwrapWithCompensation(_catchFn: (err: RnError<ErrObj>) => T): T;
    /**
     * Safely returns the contained value.
     * @returns The contained success value
     */
    unwrapForce(): T;
    /**
     * Always returns true for Ok results.
     * @deprecated Use isOk() instead
     * @returns Always true
     */
    true(): this is Ok<T, ErrObj>;
    /**
     * Type guard indicating this is an Ok result.
     * @returns Always true for Ok instances
     */
    isOk(): this is Ok<T, ErrObj>;
    /**
     * Type guard indicating this is not an Err result.
     * @returns Always false for Ok instances
     */
    isErr(): this is Err<T, ErrObj>;
    /**
     * Safely extracts the contained success value.
     * @returns The contained success value
     */
    get(): T;
}
/**
 * Represents a failed result containing an error.
 * This class indicates that an operation failed with specific error information.
 * @template T - The type of the success value (for type compatibility)
 * @template ErrObj - The type of the error object
 */
declare class Err<T, ErrObj> extends CResult<T, ErrObj> implements IResult<T, ErrObj> {
    /** The RnException instance created from the error */
    _rnException: RnException<ErrObj>;
    /**
     * Creates a new Err result.
     * @param val - The error information to store
     */
    constructor(val: RnError<ErrObj>);
    /**
     * Returns this Err result unchanged since the operation already failed.
     * The chaining function is not called.
     * @template U - The type of the new success value
     * @param f - Chaining function (not called for Err results)
     * @returns This Err result cast to the new type
     */
    andThen<U>(_f: (value: T) => Result<U, ErrObj>): Result<U, ErrObj>;
    /**
     * Provides an alternative result since this result failed.
     * Calls the provided function to get an alternative result.
     * @template U - The type of the alternative success value
     * @param f - Function that provides an alternative result
     * @returns The result of the alternative function
     */
    orElse<U>(f: () => Result<U, ErrObj>): Result<U, ErrObj>;
    /**
     * Calls the compensation function to provide a fallback value.
     * @param catchFn - Function that provides a fallback value based on the error
     * @returns The compensated value from the catch function
     */
    unwrapWithCompensation(catchFn: (err: RnError<ErrObj>) => T): T;
    /**
     * Throws an exception since this result contains an error.
     * @throws {RnException} Always throws the contained exception
     * @returns Never returns (always throws)
     */
    unwrapForce(): never;
    /**
     * Always returns false for Err results.
     * @deprecated This method seems to be unused
     * @returns Always false
     */
    false(): false;
    /**
     * Type guard indicating this is not an Ok result.
     * @returns Always false for Err instances
     */
    isOk(): this is Ok<T, ErrObj>;
    /**
     * Type guard indicating this is an Err result.
     * @returns Always true for Err instances
     */
    isErr(): this is Err<T, ErrObj>;
    /**
     * Gets the contained error information.
     * @returns The RnError object containing error details
     */
    getRnError(): RnError<ErrObj>;
    /**
     * Converts this error to a string representation.
     * @returns The stack trace from the contained exception
     */
    toString(): string;
}
/**
 * Union type representing either a successful result (Ok) or a failed result (Err).
 * @template T - The type of the success value
 * @template ErrObj - The type of the error object
 */
type Result<T, ErrObj> = Ok<T, ErrObj> | Err<T, ErrObj>;
/**
 * Type assertion function to ensure a result is Ok.
 * Throws an error if the result is Err.
 * @param result - The result to check
 * @throws {Error} If the result is Err
 */
declare function assertIsOk(result: IResult<any, any>): asserts result is Ok<any, any>;
/**
 * Type assertion function to ensure a result is Err.
 * Throws an error if the result is Ok.
 * @param result - The result to check
 * @throws {Error} If the result is Ok
 */
declare function assertIsErr(result: IResult<any, any>): asserts result is Err<any, any>;

/**
 * A Buffer class that manages memory allocation and provides BufferView creation functionality.
 * This class wraps an ArrayBuffer and manages byte allocation with alignment considerations.
 * It tracks the used bytes and provides methods to create BufferView instances from the underlying buffer.
 *
 * @example
 * ```typescript
 * const buffer = new Buffer({
 *   byteLength: 1024,
 *   buffer: new ArrayBuffer(1024),
 *   name: 'MyBuffer',
 *   byteAlign: 4
 * });
 *
 * const bufferViewResult = buffer.takeBufferView({
 *   byteLengthToNeed: 64,
 *   byteStride: 16
 * });
 * ```
 */
declare class Buffer {
    private __byteLength;
    private __byteOffset;
    private __takenBytesIndex;
    private __byteAlign;
    private __raw;
    private __name;
    private __bufferViews;
    /**
     * Creates a new Buffer instance.
     *
     * @param options - Configuration object for the buffer
     * @param options.byteLength - The total byte length of the buffer
     * @param options.buffer - The underlying ArrayBuffer or Uint8Array to wrap
     * @param options.name - A descriptive name for the buffer
     * @param options.byteAlign - The byte alignment requirement for memory allocation
     */
    constructor({ byteLength, buffer, name, byteAlign, }: {
        byteLength: Byte$1;
        buffer: ArrayBuffer;
        name: string;
        byteAlign: Byte$1;
    });
    /**
     * Sets the name of the buffer.
     *
     * @param str - The new name for the buffer
     */
    set name(str: string);
    /**
     * Gets the name of the buffer.
     *
     * @returns The current name of the buffer
     */
    get name(): string;
    /**
     * Gets the underlying ArrayBuffer.
     *
     * @returns The raw ArrayBuffer instance
     */
    getArrayBuffer(): ArrayBuffer;
    /**
     * Calculates padding bytes needed for proper alignment.
     *
     * @param byteLengthToNeed - The number of bytes that need to be allocated
     * @param byteAlign - The alignment requirement in bytes
     * @returns The number of padding bytes needed
     * @private
     */
    private __padding;
    /**
     * Creates a new BufferView from the available space in this buffer.
     * This method allocates a portion of the buffer and returns a BufferView that provides
     * typed access to that memory region.
     *
     * @param options - Configuration for the BufferView to create
     * @param options.byteLengthToNeed - The number of bytes needed for the BufferView
     * @param options.byteStride - The stride between elements in bytes
     * @returns A Result containing either the created BufferView or an error with buffer state information
     *
     * @example
     * ```typescript
     * const result = buffer.takeBufferView({
     *   byteLengthToNeed: 256,
     *   byteStride: 16
     * });
     *
     * if (result.isOk()) {
     *   const bufferView = result.get();
     *   // Use the bufferView...
     * }
     * ```
     */
    takeBufferView({ byteLengthToNeed, byteStride, }: {
        byteLengthToNeed: Byte$1;
        byteStride: Byte$1;
    }): Result<BufferView, {
        'Buffer.byteLength': Byte$1;
        'Buffer.takenSizeInByte': Byte$1;
    }>;
    /**
     * Creates a new BufferView at a specific byte offset within this buffer.
     * Unlike takeBufferView, this method allows you to specify the exact offset
     * where the BufferView should be created, which is useful for accessing
     * pre-defined memory layouts.
     *
     * @param options - Configuration for the BufferView to create
     * @param options.byteLengthToNeed - The number of bytes needed for the BufferView
     * @param options.byteStride - The stride between elements in bytes
     * @param options.byteOffset - The specific byte offset within the buffer where the BufferView should start
     * @returns A Result containing either the created BufferView or an error
     *
     * @example
     * ```typescript
     * const result = buffer.takeBufferViewWithByteOffset({
     *   byteLengthToNeed: 128,
     *   byteStride: 8,
     *   byteOffset: 256
     * });
     * ```
     */
    takeBufferViewWithByteOffset({ byteLengthToNeed, byteStride, byteOffset, }: {
        byteLengthToNeed: Byte$1;
        byteStride: Byte$1;
        byteOffset: Byte$1;
    }): Result<BufferView, undefined>;
    /**
     * Manually adds to the taken byte index counter.
     * This is an internal method used to track memory usage.
     *
     * @param value - The number of bytes to add to the taken bytes index
     * @internal
     */
    _addTakenByteIndex(value: Byte$1): void;
    /**
     * Gets the total byte length of the buffer.
     *
     * @returns The total capacity of the buffer in bytes
     */
    get byteLength(): number;
    /**
     * Gets the number of bytes currently allocated from this buffer.
     *
     * @returns The number of bytes that have been taken from the buffer
     */
    get takenSizeInByte(): number;
    /**
     * Gets the byte offset of this buffer within the raw ArrayBuffer.
     * This is useful when the buffer is a view into a larger ArrayBuffer.
     *
     * @returns The byte offset within the raw ArrayBuffer
     */
    get byteOffsetInRawArrayBuffer(): number;
    /**
     * Creates a typed array view into the buffer at a specific offset.
     * This method provides direct access to the buffer data as a typed array,
     * which is useful for reading and writing numeric data efficiently.
     *
     * @param offset4bytesUnit - The offset in 4-byte units from the start of the buffer
     * @param compositionType - The composition type (scalar, vector, matrix, etc.)
     * @param componentType - The component type (float, int, etc.)
     * @param length - The number of elements to include in the typed array (default: 100)
     * @returns A typed array view into the buffer data
     *
     * @example
     * ```typescript
     * const floatArray = buffer.getTypedArray(
     *   0,
     *   CompositionType.Vec3,
     *   ComponentType.Float,
     *   10
     * );
     * ```
     */
    getTypedArray(offset4bytesUnit: number, compositionType: CompositionTypeEnum, componentType: ComponentTypeEnum, length?: number): TypedArray;
    /**
     * Checks if this buffer uses the same underlying ArrayBuffer as another buffer.
     * This is useful for determining if two Buffer instances share the same memory.
     *
     * @param buffer - The other buffer to compare with
     * @returns True if both buffers use the same underlying ArrayBuffer, false otherwise
     *
     * @example
     * ```typescript
     * const buffer1 = new Buffer({...});
     * const buffer2 = new Buffer({...});
     *
     * if (buffer1.isSame(buffer2)) {
     *   console.log('Buffers share the same memory');
     * }
     * ```
     */
    isSame(buffer: Buffer): boolean;
}

declare class Cache<T> {
    private __symbolWeakMap;
    register(value: T): void;
}

/**
 * This is from : https://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/docs/weakmaps.md#so-what-does-a-cache-built-with-a-weakmap-look-like
 * Thank you!
 */

type ObjectFnType = (arg: object) => unknown;
/**
 * Return the caching wrapper function
 * @param fn the target function for caching result
 * @returns
 */
declare const objectCachify: (fn: ObjectFnType) => ObjectFnType;
/**
 * Return the caching wrapper function
 * @param fn the target function for caching result
 * @returns
 */
declare const primitiveCachify1: <P extends primitives>(fn: (arg: P) => unknown) => ((arg: P) => unknown);

declare class SymbolWeakMap<V> {
    private __weakMap;
    /**
     * set key and value
     * @param symbol the key for access
     * @param value the value as a cache item
     * @returns true: succeed to set value, false: not set (already exists)
     */
    set(symbol: Symbol, value: V): boolean;
    /**
     * return the boolean value whether it have the key or not
     * @param symbol the key for access
     * @returns Whether it have the key or not.
     */
    has(symbol: Symbol): boolean;
    /**
     * return the number of this cache items
     * @returns the number of this cache items
     */
    /**
     * return the value in the cache by the key
     * @param symbol the key for access
     * @returns the value in the cache by the key
     */
    get(symbol: Symbol): V | undefined;
    /**
     * delete the value
     * @param symbol the key for access
     * @returns the flag of the deletion was succeed or not
     */
    delete(symbol: Symbol): boolean;
}

type PromiseFn<T> = (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void;
type OnFinallyFn = (() => void) | null | undefined;
/**
 * Callback object containing information about Promise.all execution progress
 */
type RnPromiseCallbackObj = {
    /** Total number of promises in Promise.all */
    promiseAllNum: number;
    /** Number of resolved promises */
    resolvedNum: number;
    /** Number of rejected promises */
    rejectedNum: number;
    /** Number of pending promises */
    pendingNum: number;
    /** Array of processed promises */
    processedPromises: any[];
};
/**
 * Callback function type for monitoring Promise.all progress
 */
type RnPromiseCallback = (obj: RnPromiseCallbackObj) => void;
/**
 * Extended Promise class that provides additional functionality including progress callbacks for Promise.all operations.
 * This class wraps the native Promise and adds monitoring capabilities for batch promise operations.
 *
 * @template T The type of the resolved value
 */
declare class RnPromise<T> extends Promise<T> {
    private __promise;
    private __callback?;
    name: string;
    private __callbackObj;
    /**
     * Creates a new RnPromise instance from an existing Promise
     * @param promise - The Promise to wrap
     */
    constructor(promise: Promise<T>);
    /**
     * Creates a new RnPromise instance from a promise function
     * @param fn - The promise executor function
     */
    constructor(fn: PromiseFn<T>);
    /**
     * Creates a resolved RnPromise with no value
     * @returns A resolved Promise
     */
    static resolve<T>(): Promise<T>;
    /**
     * Creates a resolved RnPromise with the given value
     * @param arg - The value or Promise-like object to resolve with
     * @returns A resolved Promise
     */
    static resolve<T>(arg: T | PromiseLike<T>): Promise<T>;
    /**
     * Creates a Promise that resolves when all input promises resolve, with optional progress callback.
     * The callback function is called whenever a promise in the array resolves or rejects,
     * providing real-time progress information.
     *
     * @param promises - Array of promises to wait for
     * @param callback - Optional callback function to monitor progress
     * @returns A Promise that resolves with an array of all resolved values
     */
    static all(promises: any[], callback?: RnPromiseCallback): RnPromise<any[]>;
    /**
     * Creates a Promise that resolves or rejects as soon as one of the input promises resolves or rejects.
     *
     * @param args - Array of promises to race
     * @returns A Promise that resolves or rejects with the value/reason of the first settled promise
     */
    static race(args: any[]): RnPromise<any>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * This method also handles progress tracking when used with Promise.all and a callback.
     *
     * @param onfulfilled - The callback to execute when the Promise is resolved
     * @param onrejected - The callback to execute when the Promise is rejected
     * @returns A Promise for the completion of which ever callback is executed
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): RnPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     *
     * @param onRejected - The callback to execute when the Promise is rejected
     * @returns A Promise for the completion of the callback
     */
    catch(onRejected?: any): RnPromise<T>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected).
     * The resolved value cannot be modified from the callback.
     *
     * @param onFinally - The callback to execute when the Promise is settled
     * @returns A Promise for the completion of the callback
     */
    finally(onFinally?: OnFinallyFn): Promise<T>;
    /**
     * Creates a Promise that is rejected with the given error.
     *
     * @param e - The error to reject with
     * @returns A rejected Promise
     */
    static reject(e: Error): RnPromise<never>;
}

/**
 * Utility class for data manipulation, conversion, and processing operations.
 * Provides methods for handling various data formats including ArrayBuffer, Uint8Array,
 * base64 encoding/decoding, image processing, and file operations.
 */
declare class DataUtil {
    /**
     * CRC32 lookup table for checksum calculations.
     */
    static crc32table: string[];
    /**
     * Determines if the current environment is Node.js.
     * @returns True if running in Node.js environment, false otherwise
     */
    static isNode(): boolean;
    /**
     * Encodes a string to base64 format, compatible with both browser and Node.js environments.
     * @param str - The string to encode
     * @returns Base64 encoded string
     */
    static btoa(str: string): string;
    /**
     * Decodes a base64 string, compatible with both browser and Node.js environments.
     * @param str - The base64 string to decode
     * @returns Decoded binary string
     */
    static atob(str: string): string;
    /**
     * Converts a data URI to an ArrayBuffer.
     * @param dataUri - The data URI string to convert
     * @returns ArrayBuffer containing the decoded data
     */
    static dataUriToArrayBuffer(dataUri: string): ArrayBuffer;
    /**
     * Converts an ArrayBuffer to a string using TextDecoder when available.
     * @param arrayBuffer - The ArrayBuffer to convert
     * @returns String representation of the buffer data
     */
    static arrayBufferToString(arrayBuffer: ArrayBuffer): string;
    /**
     * Converts a Uint8Array to a string using TextDecoder when available.
     * @param uint8Array - The Uint8Array to convert
     * @returns String representation of the array data
     */
    static uint8ArrayToString(uint8Array: Uint8Array): string;
    /**
     * Converts a string to base64 encoding.
     * @param str - The string to encode
     * @returns Base64 encoded string
     */
    static stringToBase64(str: string): string;
    /**
     * Converts a base64 string to an ArrayBuffer (browser environment only).
     * @param base64 - The base64 string to convert
     * @returns ArrayBuffer containing the decoded data
     * @throws Error if not running in browser environment
     */
    static base64ToArrayBuffer(base64: string): ArrayBuffer;
    /**
     * Converts a Uint8Array to a data URL for image display.
     * @param uint8array - The image data as Uint8Array
     * @param width - Image width in pixels
     * @param height - Image height in pixels
     * @returns Data URL string for the image
     */
    static UInt8ArrayToDataURL(uint8array: Uint8Array, width: number, height: number): string;
    /**
     * Loads a resource asynchronously with support for both binary and text data.
     * @param resourceUri - URI of the resource to load
     * @param isBinary - Whether to load as binary data
     * @param resolveCallback - Callback function for successful loading
     * @param rejectCallback - Callback function for error handling
     * @returns Promise that resolves with the loaded resource
     */
    static loadResourceAsync(resourceUri: string, isBinary: boolean, resolveCallback: Function, rejectCallback: Function): Promise<any>;
    /**
     * Calculates CRC32 checksum for a given string.
     * @param str - The string to calculate checksum for
     * @returns CRC32 checksum as unsigned 32-bit integer
     */
    static toCRC32(str: string): number;
    /**
     * Accesses binary data from a buffer view and converts it to an image data URL.
     * @param bufferViewIndex - Index of the buffer view in the JSON
     * @param json - JSON object containing buffer view information
     * @param buffer - The source buffer data
     * @param mimeType - MIME type of the image
     * @returns Data URL string for the image
     */
    static accessBinaryAsImage(bufferViewIndex: number, json: any, buffer: ArrayBuffer | Uint8Array, mimeType: string): string;
    /**
     * Creates a blob image URI from a Uint8Array.
     * @param uint8Array - The image data as Uint8Array
     * @param mimeType - MIME type of the image
     * @returns Blob URL string for the image
     */
    static createBlobImageUriFromUint8Array(uint8Array: Uint8Array, mimeType: string): string;
    /**
     * Extracts a Uint8Array from a buffer view based on JSON specification.
     * @param json - RnM2 JSON object containing buffer view information
     * @param bufferViewIndex - Index of the buffer view
     * @param buffer - The source buffer data
     * @returns Uint8Array view of the specified buffer region
     */
    static takeBufferViewAsUint8Array(json: RnM2, bufferViewIndex: number, buffer: ArrayBuffer | Uint8Array): Uint8Array;
    /**
     * Converts ArrayBuffer or Uint8Array to an image data URL.
     * @param arrayBuffer - The image data buffer
     * @param imageType - Type/format of the image
     * @returns Data URL string for the image
     */
    static accessArrayBufferAsImage(arrayBuffer: ArrayBuffer | Uint8Array, imageType: string): string;
    /**
     * Internal method to convert Uint8Array to string without TextDecoder.
     * @param uint8 - The Uint8Array to convert
     * @returns String representation of the array data
     */
    static uint8ArrayToStringInner(uint8: Uint8Array): string;
    /**
     * Gets the appropriate data URL prefix for a given image type.
     * @param imageType - The image type or MIME type
     * @returns Data URL prefix string
     */
    static getImageType(imageType: string): string;
    /**
     * Gets the MIME type from a file extension.
     * @param extension - The file extension
     * @returns MIME type string
     */
    static getMimeTypeFromExtension(extension: string): string;
    /**
     * Extracts the file extension from a filename.
     * @param fileName - The filename to extract extension from
     * @returns File extension string
     */
    static getExtension(fileName: string): string;
    /**
     * Creates a Uint8Array from buffer view information in glTF or RnM2 format.
     * @param json - The JSON object containing buffer view information
     * @param bufferViewIndex - Index of the buffer view
     * @param buffer - The source buffer data
     * @returns Uint8Array view of the specified buffer region
     */
    static createUint8ArrayFromBufferViewInfo(json: RnM2 | glTF1, bufferViewIndex: number, buffer: ArrayBuffer | Uint8Array): Uint8Array;
    /**
     * Creates an HTMLImageElement from a URI with proper CORS handling.
     * @param uri - The image URI
     * @param mimeType - MIME type of the image
     * @returns Promise that resolves to the loaded HTMLImageElement
     */
    static createImageFromUri(uri: string, mimeType: string): RnPromise<HTMLImageElement>;
    /**
     * Creates default options for glTF loading operations.
     * @returns Default GltfLoadOption configuration object
     */
    static createDefaultGltfOptions(): GltfLoadOption;
    /**
     * Fetches an ArrayBuffer from a URI using the Fetch API.
     * @param uri - The URI to fetch from
     * @returns Promise that resolves to a Result containing the ArrayBuffer or error
     */
    static fetchArrayBuffer(uri: string): Promise<Result<ArrayBuffer, unknown>>;
    /**
     * Resizes an image to fit within specified dimensions while maintaining aspect ratio.
     * @param image - The source HTMLImageElement
     * @param maxSize - Maximum size for the largest dimension
     * @returns Tuple containing the resized canvas, width, and height
     */
    static getResizedCanvas(image: HTMLImageElement, maxSize: Size): [HTMLCanvasElement, Size, Size];
    /**
     * Detects if an image contains transparent pixels below a specified threshold.
     * @param image - The image to analyze (HTMLImageElement, HTMLCanvasElement, or ImageData)
     * @param threshold - Alpha threshold value (default: 1.0)
     * @returns True if transparent pixels are found, false otherwise
     */
    static detectTransparentPixelExistence(image: HTMLImageElement | HTMLCanvasElement | ImageData, threshold?: number): boolean;
    /**
     * Gets the nearest power of two value for a given number.
     * @param x - The input value
     * @returns The nearest power of two value
     */
    static getNearestPowerOfTwo(x: number): number;
    /**
     * Calculates the number of padding bytes needed for byte alignment.
     * @param originalByteLength - The original byte length
     * @param byteAlign - The byte alignment requirement
     * @returns Number of padding bytes needed
     */
    static calcPaddingBytes(originalByteLength: Byte$1, byteAlign: Byte$1): number;
    /**
     * Adds padding bytes to achieve the specified byte alignment.
     * @param originalByteLength - The original byte length
     * @param byteAlign - The byte alignment requirement
     * @returns The padded byte length
     */
    static addPaddingBytes(originalByteLength: Byte$1, byteAlign: Byte$1): number;
    /**
     * Converts normalized Int8Array values to Float32Array.
     * @param from - Source Int8Array or number array
     * @returns Float32Array with normalized values
     */
    static normalizedInt8ArrayToFloat32Array(from: Int8Array | number[]): Float32Array<ArrayBuffer>;
    /**
     * Converts normalized Uint8Array values to Float32Array.
     * @param from - Source Uint8Array or number array
     * @returns Float32Array with normalized values
     */
    static normalizedUint8ArrayToFloat32Array(from: Uint8Array | number[]): Float32Array<ArrayBuffer>;
    /**
     * Converts normalized Int16Array values to Float32Array.
     * @param from - Source Int16Array or number array
     * @returns Float32Array with normalized values
     */
    static normalizedInt16ArrayToFloat32Array(from: Int16Array | number[]): Float32Array<ArrayBuffer>;
    /**
     * Converts normalized Uint16Array values to Float32Array.
     * @param from - Source Uint16Array or number array
     * @returns Float32Array with normalized values
     */
    static normalizedUint16ArrayToFloat32Array(from: Uint16Array | number[]): Float32Array<ArrayBuffer>;
    /**
     * Creates a copy of an ArrayBuffer with specified parameters.
     * @param param0 - Copy configuration object
     * @param param0.src - Source ArrayBuffer
     * @param param0.srcByteOffset - Byte offset in source buffer
     * @param param0.copyByteLength - Number of bytes to copy
     * @param param0.distByteOffset - Byte offset in destination buffer
     * @returns Copied ArrayBuffer
     */
    static getCopy({ src, srcByteOffset, copyByteLength, distByteOffset, }: {
        src: ArrayBuffer;
        srcByteOffset: Byte$1;
        copyByteLength: Byte$1;
        distByteOffset: Byte$1;
    }): ArrayBuffer;
    /**
     * Creates a copy of an ArrayBuffer using 4-byte aligned operations.
     * @param param0 - Copy configuration object
     * @param param0.src - Source ArrayBuffer
     * @param param0.srcByteOffset - Byte offset in source buffer (must be 4-byte aligned)
     * @param param0.copyByteLength - Number of bytes to copy (must be 4-byte aligned)
     * @param param0.distByteOffset - Byte offset in destination buffer (must be 4-byte aligned)
     * @returns Copied ArrayBuffer
     * @throws Error if byte offsets are not 4-byte aligned
     */
    static getCopyAs4Bytes({ src, srcByteOffset, copyByteLength, distByteOffset, }: {
        src: ArrayBuffer;
        srcByteOffset: Byte$1;
        copyByteLength: Byte$1;
        distByteOffset: Byte$1;
    }): ArrayBuffer;
    /**
     * Copies data from source ArrayBuffer to destination ArrayBuffer.
     * @param param0 - Copy configuration object
     * @param param0.src - Source ArrayBuffer
     * @param param0.dist - Destination ArrayBuffer
     * @param param0.srcByteOffset - Byte offset in source buffer
     * @param param0.copyByteLength - Number of bytes to copy
     * @param param0.distByteOffset - Byte offset in destination buffer (default: 0)
     * @returns The destination ArrayBuffer
     */
    static copyArrayBuffer({ src, dist, srcByteOffset, copyByteLength, distByteOffset, }: {
        src: ArrayBuffer;
        dist: ArrayBuffer;
        srcByteOffset: Byte$1;
        copyByteLength: Byte$1;
        distByteOffset: Byte$1;
    }): ArrayBuffer;
    /**
     * Copies data from source ArrayBuffer to destination ArrayBuffer with padding if needed.
     * @param param0 - Copy configuration object
     * @param param0.src - Source ArrayBuffer
     * @param param0.dist - Destination ArrayBuffer
     * @param param0.srcByteOffset - Byte offset in source buffer
     * @param param0.copyByteLength - Number of bytes to copy
     * @param param0.distByteOffset - Byte offset in destination buffer
     * @returns The destination ArrayBuffer
     */
    static copyArrayBufferWithPadding({ src, dist, srcByteOffset, copyByteLength, distByteOffset, }: {
        src: ArrayBuffer;
        dist: ArrayBuffer;
        srcByteOffset: Byte$1;
        copyByteLength: Byte$1;
        distByteOffset: Byte$1;
    }): ArrayBuffer;
    /**
     * Copies data using 4-byte aligned operations from source to destination ArrayBuffer.
     * @param param0 - Copy configuration object
     * @param param0.src - Source ArrayBuffer
     * @param param0.dist - Destination ArrayBuffer
     * @param param0.srcByteOffset - Byte offset in source buffer (must be 4-byte aligned)
     * @param param0.copyByteLength - Number of bytes to copy (must be 4-byte aligned)
     * @param param0.distByteOffset - Byte offset in destination buffer (must be 4-byte aligned)
     * @returns The destination ArrayBuffer
     * @throws Error if byte offsets are not 4-byte aligned
     */
    static copyArrayBufferAs4Bytes({ src, dist, srcByteOffset, copyByteLength, distByteOffset, }: {
        src: ArrayBuffer;
        dist: ArrayBuffer;
        srcByteOffset: Byte$1;
        copyByteLength: Byte$1;
        distByteOffset: Byte$1;
    }): ArrayBuffer;
    /**
     * Copies data using 4-byte aligned operations with padding to achieve 4-byte alignment.
     * @param param0 - Copy configuration object
     * @param param0.src - Source ArrayBuffer
     * @param param0.dist - Destination ArrayBuffer
     * @param param0.srcByteOffset - Byte offset in source buffer
     * @param param0.copyByteLength - Number of bytes to copy
     * @param param0.distByteOffset - Byte offset in destination buffer
     * @returns The destination ArrayBuffer
     */
    static copyArrayBufferAs4BytesWithPadding({ src, dist, srcByteOffset, copyByteLength, distByteOffset, }: {
        src: ArrayBuffer;
        dist: ArrayBuffer;
        srcByteOffset: Byte$1;
        copyByteLength: Byte$1;
        distByteOffset: Byte$1;
    }): ArrayBuffer;
    /**
     * Converts a string to an ArrayBuffer using TextEncoder.
     * @param src - The string to convert
     * @returns ArrayBuffer containing the encoded string data
     */
    static stringToBuffer(src: string): ArrayBuffer;
}

/**
 * Data structure containing all precomputed data needed for seamless texture synthesis.
 */
type SeamlessTextureData = {
    input: TextureDataFloat;
    Tinput: TextureDataFloat;
    Tinv: TextureDataFloat;
    colorSpaceVector1: MutableVector3;
    colorSpaceVector2: MutableVector3;
    colorSpaceVector3: MutableVector3;
    colorSpaceOrigin: MutableVector3;
    lutWidth: Size;
};
/**
 * Performs all necessary precomputations for seamless texture synthesis.
 * This includes color space decorrelation, histogram transformation, and LUT prefiltering.
 *
 * @param input - The input example texture
 * @param LUT_WIDTH - The width of the Look-Up Table (default: 128)
 * @returns SeamlessTextureData containing all precomputed data
 */
declare function precomputations(input: TextureDataFloat, // input: example image
LUT_WIDTH?: Size): SeamlessTextureData;
/**
 * Converts an HTMLImageElement to a Canvas with specified dimensions.
 * The image is scaled to fit the target width and height.
 *
 * @param image - The source HTML image element
 * @param width - The target canvas width
 * @param height - The target canvas height
 * @returns A new Canvas element containing the scaled image
 */
declare function convertHTMLImageElementToCanvas(image: HTMLImageElement, width: number, height: number): HTMLCanvasElement;
/**
 * Combines multiple single-channel images into a single RGBA image.
 * Each input image contributes to one color channel of the output.
 *
 * @param data - Configuration object containing:
 *   - r_image: Optional canvas for red channel
 *   - g_image: Optional canvas for green channel
 *   - b_image: Optional canvas for blue channel
 *   - a_image: Optional canvas for alpha channel
 *   - width: Output image width
 *   - height: Output image height
 * @returns A new Canvas containing the combined RGBA image
 */
declare function combineImages(data: {
    r_image?: HTMLCanvasElement;
    g_image?: HTMLCanvasElement;
    b_image?: HTMLCanvasElement;
    a_image?: HTMLCanvasElement;
    width: number;
    height: number;
}): HTMLCanvasElement;
/**
 * Utility class for image processing operations.
 * Provides methods for seamless texture synthesis and image manipulation.
 */
declare const ImageUtil: Readonly<{
    precomputations: typeof precomputations;
}>;

/**
 * A utility object containing various type checking and validation functions.
 * Provides methods to check if values are defined, null, functions, truthy/falsy, etc.
 * Also includes derivative methods like `not`, `all`, and `any` for more complex validations.
 */
declare const IsObj: {
    /**
     * Checks if a value is defined (not undefined).
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is not undefined
     */
    defined(val: unknown, ..._args: unknown[]): val is Exclude<Object, undefined>;
    /**
     * Checks if a value is undefined.
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is undefined
     */
    undefined(val: unknown, ..._args: unknown[]): val is undefined;
    /**
     * Checks if a value is null.
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is null
     */
    null(val: unknown, ..._args: unknown[]): val is null;
    /**
     * Checks if a value exists (is neither null nor undefined).
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is not null and not undefined
     */
    exist(val?: unknown, ..._args: unknown[]): val is Object;
    /**
     * Checks if a value is a function.
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is a function
     */
    function(val: unknown, ..._args: unknown[]): val is Function;
    /**
     * Checks if a value is strictly equal to true.
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is exactly true
     */
    true(val: unknown, ..._args: unknown[]): boolean;
    /**
     * Checks if a value is truthy (converts to true in boolean context).
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is truthy
     */
    truly(val: unknown, ..._args: unknown[]): boolean;
    /**
     * Checks if a value is strictly equal to false.
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is exactly false
     */
    false(val: unknown, ..._args: unknown[]): boolean;
    /**
     * Checks if a value is falsy (converts to false in boolean context).
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is falsy
     */
    falsy(val: unknown, ..._args: unknown[]): boolean;
    /**
     * Checks if a string contains another string.
     * @param thisStr - The string to search in
     * @param queryStr - The string to search for
     * @returns True if thisStr contains queryStr
     */
    stringContaining(thisStr: string, queryStr: string): boolean;
};
/**
 * Negated versions of the base validation functions.
 * Each method returns the opposite result of its corresponding method in IsObj.
 */
declare const NotObj: {
    /**
     * Checks if a value is undefined (negated version of defined).
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is undefined
     */
    defined(val: unknown, ..._args: unknown[]): val is undefined;
    /**
     * Checks if a value is defined (negated version of undefined).
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is not undefined
     */
    undefined(val: unknown, ..._args: unknown[]): val is Object;
    /**
     * Checks if a value is not null.
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is not null
     */
    null(val: unknown, ..._args: unknown[]): val is Object;
    /**
     * Checks if a value does not exist (is null or undefined).
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is null or undefined
     */
    exist(val?: unknown, ..._args: unknown[]): val is undefined | null;
    /**
     * Checks if a value is not a function.
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is not a function
     */
    function(val: unknown, ..._args: unknown[]): val is Exclude<unknown, Function>;
    /**
     * Checks if a value is not strictly equal to true.
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is not exactly true
     */
    true(val: unknown, ..._args: unknown[]): boolean;
    /**
     * Checks if a value is not truthy (negated version of truly).
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is not truthy
     */
    truly(val: unknown, ..._args: unknown[]): boolean;
    /**
     * Checks if a value is not strictly equal to false.
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is not exactly false
     */
    false(val: unknown, ..._args: unknown[]): boolean;
    /**
     * Checks if a value is not falsy (negated version of falsy).
     * @param val - The value to check
     * @param args - Additional arguments (unused)
     * @returns True if the value is not falsy
     */
    falsy(val: unknown, ..._args: unknown[]): boolean;
};
type IsImplType = typeof IsObj;
/**
 * Extended interface that includes the base validation methods plus derivative methods.
 * Provides `not`, `all`, and `any` modifiers for complex validation scenarios.
 */
interface IsType extends IsImplType {
    not: typeof NotObj;
    all: typeof IsObj;
    any: typeof IsObj;
}
/**
 * Main export providing comprehensive type checking and validation utilities.
 *
 * @example
 * ```typescript
 * import { Is } from './Is';
 *
 * // Basic usage
 * Is.defined(value);        // Check if value is defined
 * Is.null(value);           // Check if value is null
 * Is.function(value);       // Check if value is a function
 *
 * // Negated checks
 * Is.not.defined(value);    // Check if value is undefined
 * Is.not.null(value);       // Check if value is not null
 *
 * // Array validation
 * Is.all.defined([1, 2, 3]); // Check if all values are defined
 * Is.any.null([1, null, 3]); // Check if any value is null
 * ```
 */
declare const Is: IsType;

/**
 * Returns a value if it exists, otherwise returns a default value
 * @template T - The type of the value
 * @param params - Configuration object
 * @param params.value - The value to check (optional)
 * @param params.defaultValue - The default value to return if value is null/undefined
 * @returns The value if it exists, otherwise the default value
 */
declare const valueWithDefault: <T>({ value, defaultValue }: {
    value?: T;
    defaultValue: T;
}) => T;
/**
 * Executes a callback if the value exists
 * @template T - The type of the value
 * @param callback - The callback function to execute
 * @param value - The value to check (optional)
 * @returns True if the value exists and callback was executed, false otherwise
 */
declare const ifExistsThen: <T>(callback: (value: T) => void, value?: T) => value is T;
/**
 * Executes a callback if the value exists and returns the result
 * @template T - The type of the value
 * @param callback - The callback function to execute that returns a value
 * @param value - The value to check (optional)
 * @returns The result of the callback if value exists, otherwise undefined
 */
declare const ifExistsThenWithReturn: <T>(callback: (value: T) => T, value?: T) => T | undefined;
/**
 * Executes a callback if the value is defined
 * @template T - The type of the value
 * @param callback - The callback function to execute
 * @param value - The value to check (optional)
 * @returns True if the value is defined and callback was executed, false otherwise
 */
declare const ifDefinedThen: <T>(callback: (value: T) => void, value?: T) => value is T;
/**
 * Executes a callback if the value is defined and returns the result
 * @template T - The type of the value
 * @param callback - The callback function to execute that returns a value
 * @param value - The value to check (optional)
 * @returns The result of the callback if value is defined, otherwise undefined
 */
declare const ifDefinedThenWithReturn: <T>(callback: (value: T) => T, value?: T) => T | undefined;
/**
 * Executes a callback if the value is undefined
 * @template T - The type of the value
 * @param callback - The callback function to execute
 * @param value - The value to check (optional)
 * @returns False if the value is undefined and callback was executed, true otherwise
 */
declare const ifUndefinedThen: <T>(callback: () => void, value?: T) => value is T;
/**
 * Executes a callback if the value is undefined and returns the result
 * @template T - The type of the value
 * @param callback - The callback function to execute that returns a value
 * @param value - The value to check (optional)
 * @returns The result of the callback if value is undefined, otherwise the original value
 */
declare const ifUndefinedThenWithReturn: <T>(callback: () => T, value?: T) => T;
/**
 * Executes a callback if the value does not exist (is null or undefined)
 * @template T - The type of the value
 * @param callback - The callback function to execute
 * @param value - The value to check (optional)
 */
declare const ifNotExistsThen: <T>(callback: () => void, value?: T) => void;
/**
 * Executes a callback if the value does not exist and returns the result
 * @template T - The type of the value
 * @param callback - The callback function to execute that returns a value
 * @param value - The value to check (optional)
 * @returns The result of the callback if value doesn't exist, otherwise the original value
 */
declare const ifNotExistsThenWithReturn: <T>(callback: () => T, value?: T) => T;
/**
 * Returns a default value if the provided value is null or undefined
 * @template T - The type of the value
 * @param defaultValue - The default value to return
 * @param value - The value to check (optional)
 * @returns The value if it exists, otherwise the default value
 */
declare const defaultValue: <T>(defaultValue: T, value?: T) => T;
/**
 * Returns a value if it exists, otherwise executes a compensation function
 * @template T - The type of the value
 * @param params - Configuration object
 * @param params.value - The value to check (optional)
 * @param params.compensation - Function to execute if value doesn't exist
 * @returns The value if it exists, otherwise the result of the compensation function
 */
declare const valueWithCompensation: <T>({ value, compensation, }: {
    value?: T;
    compensation: () => T;
}) => T;
/**
 * Converts a nullish array to an empty array
 * @template T - The type of array elements
 * @param value - The array value to check (optional or null)
 * @returns The original array if it exists, otherwise an empty array
 */
declare const nullishToEmptyArray: <T>(value?: T[] | null) => T[];
/**
 * Converts a nullish Map to an empty Map
 * @template M - The type of Map keys
 * @template N - The type of Map values
 * @param value - The Map value to check (optional or null)
 * @returns The original Map if it exists, otherwise an empty Map
 */
declare const nullishToEmptyMap: <M, N>(value?: Map<M, N> | null) => Map<M, N>;
/**
 * Interface representing the result of a comparison operation
 */
interface CompareResult {
    /** Whether the comparison condition was met */
    result: boolean;
    /** The greater value in the comparison */
    greater: number;
    /** The lesser value in the comparison */
    less: number;
}
/**
 * Compares if one number is greater than another
 * @param it - The number to compare
 * @param than - The number to compare against
 * @returns A CompareResult object with comparison details
 */
declare const greaterThan: (it: number, than: number) => CompareResult;
/**
 * Compares if one number is less than another
 * @param it - The number to compare
 * @param than - The number to compare against
 * @returns A CompareResult object with comparison details
 */
declare const lessThan: (it: number, than: number) => CompareResult;
/**
 * Adds line numbers to a code string for debugging purposes
 * @param shaderString - The code string to add line numbers to
 * @returns The code string with line numbers prepended to each line
 */
declare const addLineNumberToCode: (shaderString: string) => string;
/**
 * Asserts that a value exists (is not null or undefined) and throws an error if it doesn't
 * @template T - The type of the value
 * @param val - The value to assert existence for
 * @throws Error if the value is null or undefined
 */
declare function assertExist<T>(val: T): asserts val is NonNullable<T>;
/**
 * Creates a deep copy of an object using JSON stringify/parse
 * @param obj - The object to deep copy
 * @returns A deep copy of the input object
 * @warning This method has limitations with functions, undefined values, symbols, etc.
 */
declare function deepCopyUsingJsonStringify(obj: {
    [k: string]: any;
}): {
    [k: string]: any;
};
/**
 * Downloads an ArrayBuffer as a file in the browser
 * @param fileNameToDownload - The name of the file to download
 * @param arrayBuffer - The ArrayBuffer data to download
 */
declare function downloadArrayBuffer(fileNameToDownload: string, arrayBuffer: ArrayBuffer): void;
/**
 * Downloads a TypedArray as a file in the browser
 * @param fileNameToDownload - The name of the file to download
 * @param typedArray - The TypedArray data to download
 */
declare function downloadTypedArray(fileNameToDownload: string, typedArray: TypedArray): void;
/**
 * Collection of miscellaneous utility functions for various common operations
 * including device detection, array buffer manipulation, conditional execution,
 * and file operations
 */
declare const MiscUtil: Readonly<{
    isMobileVr: () => boolean;
    isMobile: () => boolean;
    isIOS: () => boolean;
    isSafari: () => boolean;
    preventDefaultForDesktopOnly: (e: Event) => void;
    isObject: (o: any) => boolean;
    fillTemplate: (templateString: string, templateVars: string) => string;
    isNode: () => boolean;
    concatArrayBuffers: (segments: ArrayBuffer[], sizes: Byte$1[], offsets: Byte$1[], finalSize?: Byte$1) => ArrayBufferLike;
    concatArrayBuffers2: ({ finalSize, srcs, srcsOffset, srcsCopySize, }: {
        finalSize: Byte$1;
        srcs: ArrayBuffer[];
        srcsOffset: Byte$1[];
        srcsCopySize: Byte$1[];
    }) => ArrayBuffer;
    addLineNumberToCode: (shaderString: string) => string;
    downloadArrayBuffer: typeof downloadArrayBuffer;
    downloadTypedArray: typeof downloadTypedArray;
}>;

interface IOption<T> {
    /**
     * Applies a function to the contained value if it exists, otherwise returns None.
     * This is a monadic bind operation for chaining optional computations.
     *
     * @template U The type of the value returned by the function
     * @param f Function to apply to the contained value
     * @returns A new Option containing the result of the function, or None if this Option is None
     */
    andThen<U>(f: (value: NonNullable<T>) => Option<NonNullable<U>>): Option<NonNullable<U>>;
    /**
     * Returns this Option if it contains a value, otherwise returns the result of the provided function.
     * This provides a way to chain alternative Option computations.
     *
     * @template U The type of the alternative Option
     * @param f Function that returns an alternative Option
     * @returns This Option if it has a value, otherwise the result of f()
     */
    orElse<U>(f: () => Option<NonNullable<U>>): Option<NonNullable<U>>;
    /**
     * Pattern matches on the Option, executing the appropriate function based on whether it contains a value.
     * This provides a functional way to handle both Some and None cases.
     *
     * @template U The return type of the match functions
     * @param obj Object containing Some and None handler functions
     * @returns The result of executing the appropriate handler function
     */
    match<U>(obj: {
        Some: (value: NonNullable<T>) => NonNullable<U> | U;
        None: () => NonNullable<U> | U;
    }): NonNullable<U> | U;
    /**
     * Returns the contained value if it exists, otherwise returns the provided default value.
     *
     * @param altValue The default value to return if this Option is None
     * @returns The contained value or the default value
     */
    unwrapOrDefault(altValue: NonNullable<T>): NonNullable<T>;
    /**
     * Returns the contained value if it exists, otherwise returns the result of the provided function.
     *
     * @param f Function that returns a default value
     * @returns The contained value or the result of f()
     */
    unwrapOrElse(f: () => NonNullable<T>): NonNullable<T>;
    /**
     * Returns the contained value if it exists, otherwise returns undefined.
     * This is useful for interoperability with standard JavaScript nullable patterns.
     *
     * @returns The contained value or undefined
     */
    unwrapOrUndefined(): NonNullable<T> | undefined;
    /**
     * Returns the contained value, throwing an error if it doesn't exist.
     * Use this only when you're certain the value exists.
     *
     * @throws {ReferenceError} If the Option is None
     * @returns The contained value
     */
    unwrapForce(): NonNullable<T>;
    /**
     * Type guard that checks if this Option contains a value.
     *
     * @returns true if this is a Some instance, false if None
     */
    has(): this is Some<NonNullable<T>>;
    /**
     * Type guard that checks if this Option does not contain a value.
     *
     * @returns true if this is a None instance, false if Some
     */
    doesNotHave(): this is None;
}
/**
 * A class representing an Option that contains a value.
 * This is the "Some" variant of the Option type, indicating that a value exists.
 *
 * @template T The type of the contained value
 */
declare class Some<T> implements IOption<T> {
    private value;
    /**
     * Creates a new Some instance with the provided value.
     *
     * @param value The non-null value to wrap
     */
    constructor(value: NonNullable<T>);
    /**
     * Applies a function to the contained value and returns the result.
     * This method is essentially the same as Some::and_then() in Rust language.
     *
     * @template U The type of the value returned by the function
     * @param f Function to apply to the contained value
     * @returns The result of applying f to the contained value
     */
    andThen<U>(f: (value: NonNullable<T>) => Option<NonNullable<U>>): Option<NonNullable<U>>;
    /**
     * Returns this Some instance, ignoring the provided function.
     * Since this Option already contains a value, the alternative is not needed.
     *
     * @template U The type of the alternative Option (unused)
     * @param f Function that returns an alternative Option (unused)
     * @returns This Some instance cast to the appropriate type
     */
    orElse<U>(_f: () => Option<NonNullable<U>>): Option<NonNullable<U>>;
    /**
     * Executes the Some handler function with the contained value.
     *
     * @template U The return type of the match functions
     * @param obj Object containing Some and None handler functions
     * @returns The result of executing obj.Some with the contained value
     */
    match<U>(obj: {
        Some: (value: NonNullable<T>) => NonNullable<U> | U;
        None: () => NonNullable<U> | U;
    }): NonNullable<U> | U;
    /**
     * Returns the contained value, ignoring the provided default.
     * Since this Option contains a value, the alternative is not needed.
     *
     * @param altValue The default value (unused)
     * @returns The contained value
     */
    unwrapOrDefault(_altValue: NonNullable<T>): NonNullable<T>;
    /**
     * Returns the contained value, ignoring the provided function.
     * Since this Option contains a value, the alternative is not needed.
     *
     * @param f Function that returns a default value (unused)
     * @returns The contained value
     */
    unwrapOrElse(_f: () => NonNullable<T>): NonNullable<T>;
    /**
     * Returns the contained value.
     * This method never throws since Some always contains a value.
     *
     * @returns The contained value
     */
    unwrapForce(): NonNullable<T>;
    /**
     * Returns the contained value.
     * This method never returns undefined since Some always contains a value.
     *
     * @returns The contained value
     */
    unwrapOrUndefined(): NonNullable<T> | undefined;
    /**
     * Gets the contained value directly.
     * This is a convenience method for accessing the wrapped value.
     *
     * @returns The contained value
     */
    get(): NonNullable<T>;
    /**
     * Type guard that always returns true for Some instances.
     *
     * @returns Always true, indicating this Option contains a value
     */
    has(): this is Some<NonNullable<T>>;
    /**
     * Type guard that always returns false for Some instances.
     *
     * @returns Always false, indicating this Option contains a value
     */
    doesNotHave(): this is None;
}
/**
 * A class representing an Option that does not contain a value.
 * This is the "None" variant of the Option type, indicating the absence of a value.
 */
declare class None implements IOption<never> {
    /**
     * Returns this None instance, ignoring the provided function.
     * Since there's no value to apply the function to, None is returned.
     *
     * @template U The type of the value that would be returned by the function
     * @param f Function to apply (unused)
     * @returns This None instance
     */
    andThen<U>(_f: (value: never) => Option<NonNullable<U>>): Option<NonNullable<U>>;
    /**
     * Returns the result of the provided function since this Option has no value.
     * This provides an alternative Option when the current one is None.
     *
     * @template U The type of the alternative Option
     * @param f Function that returns an alternative Option
     * @returns The result of executing f()
     */
    orElse<U>(f: () => Option<NonNullable<U>>): Option<NonNullable<U>>;
    /**
     * Executes the None handler function since this Option contains no value.
     *
     * @template U The return type of the match functions
     * @param obj Object containing Some and None handler functions
     * @returns The result of executing obj.None
     */
    match<U>(obj: {
        Some: (value: NonNullable<never>) => NonNullable<U> | U;
        None: () => NonNullable<U> | U;
    }): NonNullable<U> | U;
    /**
     * Returns the provided default value since this Option contains no value.
     *
     * @template T The type of the default value
     * @param value The default value to return
     * @returns The provided default value
     */
    unwrapOrDefault<T>(value: NonNullable<T>): NonNullable<T>;
    /**
     * Returns the result of the provided function since this Option contains no value.
     *
     * @template T The type of the value returned by the function
     * @param f Function that returns a default value
     * @returns The result of executing f()
     */
    unwrapOrElse<T>(f: () => NonNullable<T>): NonNullable<T>;
    /**
     * Throws an error since this Option contains no value.
     * This method should only be called when you're certain the Option contains a value.
     *
     * @throws {ReferenceError} Always throws since None has no value
     * @returns Never returns (always throws)
     */
    unwrapForce(): never;
    /**
     * Returns undefined since this Option contains no value.
     * This provides interoperability with standard JavaScript nullable patterns.
     *
     * @returns Always undefined
     */
    unwrapOrUndefined(): never;
    /**
     * Type guard that always returns false for None instances.
     *
     * @returns Always false, indicating this Option contains no value
     */
    has(): this is Some<never>;
    /**
     * Type guard that always returns true for None instances.
     *
     * @returns Always true, indicating this Option contains no value
     */
    doesNotHave(): this is None;
}
/**
 * Union type representing either a Some or None value.
 * This is the main Option type that provides type-safe nullable value handling.
 *
 * @template T The type of the value that may or may not exist
 */
type Option<T> = Some<T> | None;
/**
 * Assertion function that throws if the provided Option is None.
 * This is useful for cases where you need to assert that an Option contains a value.
 *
 * @param value The Option to check
 * @throws {ReferenceError} If the Option is None
 */
declare function assertHas(value: Option<any>): asserts value is Some<any>;
/**
 * Assertion function that throws if the provided Option is Some.
 * This is useful for cases where you need to assert that an Option does not contain a value.
 *
 * @param value The Option to check
 * @throws {ReferenceError} If the Option is Some
 */
declare function assertDoesNotHave(value: Option<any>): asserts value is None;

/**
 * A utility class for managing time-related operations and measurements.
 * Provides functionality to track process timing, system uptime, and frame intervals.
 *
 * @example
 * ```typescript
 * // Get current system uptime
 * const uptime = Time.timeFromSystemStart;
 *
 * // Get last frame duration
 * const frameTime = Time.lastTickTimeInterval;
 * ```
 */
declare class Time {
    private static __currentProcessBeginTime;
    private static __lastProcessBeginTime;
    private static __lastProcessEndTime;
    private static __lastTickTimeInterval;
    private static __systemStartTime;
    private static __intervalProcessBegin;
    /**
     * Marks the beginning of a process cycle and updates timing measurements.
     * This method should be called at the start of each frame or processing cycle.
     *
     * @internal
     * @remarks
     * This method updates the current process begin time, calculates the interval
     * since the last process began, and initializes the system start time if needed.
     */
    static _processBegin(): void;
    /**
     * Marks the end of a process cycle and calculates the processing duration.
     * This method should be called at the end of each frame or processing cycle.
     *
     * @internal
     * @remarks
     * This method records the process end time and calculates the duration
     * of the current processing cycle (tick time interval).
     */
    static _processEnd(): void;
    /**
     * Gets the timestamp when the current process cycle began.
     *
     * @returns The time in milliseconds when the current process began
     * @readonly
     */
    static get timeAtProcessBeginMilliseconds(): number;
    /**
     * Gets the timestamp when the last process cycle ended.
     *
     * @returns The time in milliseconds when the last process ended
     * @readonly
     */
    static get timeAtProcessEndMilliseconds(): number;
    /**
     * Gets the elapsed time since the system started.
     *
     * @returns The elapsed time in seconds since system initialization
     * @readonly
     * @remarks
     * This value represents the total uptime of the system and is useful
     * for animations, timing calculations, and performance measurements.
     */
    static get timeFromSystemStart(): number;
    /**
     * Gets the duration of the last completed processing cycle.
     *
     * @returns The last tick time interval in seconds
     * @readonly
     * @remarks
     * This value represents the frame time or delta time, which is commonly
     * used for frame-rate independent animations and physics calculations.
     */
    static get lastTickTimeInterval(): number;
    /**
     * Gets the time interval between the start of consecutive process cycles.
     *
     * @returns The interval between process beginnings in seconds
     * @readonly
     * @remarks
     * This value indicates the time gap between when consecutive processing
     * cycles started, which can be useful for measuring frame rate consistency.
     */
    static get intervalProcessBegin(): number;
    /**
     * Gets the duration of the last completed processing cycle in milliseconds.
     *
     * @returns The last tick time interval in milliseconds
     * @readonly
     * @remarks
     * This is the millisecond version of {@link lastTickTimeInterval}.
     * Useful when higher precision timing is needed.
     */
    static get lastTimeTimeIntervalInMilliseconds(): number;
}

interface IWeakOption<B extends object, T> {
    /**
     * Unwraps the value or returns a default value if it doesn't exist.
     *
     * @param base - The base object used as a key
     * @param altValue - The alternative value to return if the value doesn't exist
     * @returns The stored value or the alternative value
     */
    unwrapOrDefault(base: B, altValue: T): T;
    /**
     * Unwraps the value or executes a function to get an alternative value.
     *
     * @param base - The base object used as a key
     * @param f - Function to execute if the value doesn't exist
     * @returns The stored value or the result of the function
     */
    unwrapOrElse(base: B, f: (...vals: any) => T): T;
    /**
     * Forcefully unwraps the value, throwing an error if it doesn't exist.
     *
     * @param base - The base object used as a key
     * @returns The stored value
     * @throws {ReferenceError} When the value doesn't exist
     */
    unwrapForce(base: B): T;
    /**
     * Unwraps the value or returns undefined if it doesn't exist.
     *
     * @param base - The base object used as a key
     * @returns The stored value or undefined
     */
    unwrapOrUndefined(base: B): T | undefined;
    /**
     * Checks if a value exists for the given base object.
     *
     * @param base - The base object used as a key
     * @returns True if the value exists, false otherwise
     */
    has(base: B): boolean;
}
/**
 * A WeakMap-based implementation of the Option pattern for handling optional values.
 * This class provides safe access to values that may or may not exist, using WeakMap
 * for automatic garbage collection when the base object is no longer referenced.
 *
 * @template B - The base object type used as a key in the WeakMap
 * @template T - The type of the value being stored
 *
 * @example
 * ```typescript
 * const option = new WeakOption<MyObject, string>();
 * const obj = new MyObject();
 * option.set(obj, "hello");
 * const value = option.unwrapOrDefault(obj, "default"); // Returns "hello"
 * ```
 */
declare class WeakOption<B extends object, T> implements IWeakOption<B, T> {
    private __weakMap;
    /**
     * Sets a value for the given base object.
     *
     * @param base - The base object to use as a key
     * @param val - The value to store
     */
    set(base: B, val: T): void;
    /**
     * Unwraps the value or returns a default value if it doesn't exist.
     *
     * @param base - The base object used as a key
     * @param altValue - The alternative value to return if the value doesn't exist
     * @returns The stored value or the alternative value
     */
    unwrapOrDefault(base: B, altValue: T): T;
    /**
     * Unwraps the value or executes a function to get an alternative value.
     *
     * @param base - The base object used as a key
     * @param f - Function to execute if the value doesn't exist
     * @returns The stored value or the result of the function
     */
    unwrapOrElse(base: B, f: (...vals: any) => T): T;
    /**
     * Forcefully unwraps the value, throwing an error if it doesn't exist.
     *
     * @param base - The base object used as a key
     * @returns The stored value
     * @throws {ReferenceError} When the value doesn't exist
     */
    unwrapForce(base: B): T;
    /**
     * Unwraps the value or returns undefined if it doesn't exist.
     *
     * @param base - The base object used as a key
     * @returns The stored value or undefined
     */
    unwrapOrUndefined(base: B): T | undefined;
    /**
     * Checks if a value exists for the given base object.
     *
     * @param base - The base object used as a key
     * @returns True if the value exists, false otherwise
     */
    has(base: B): boolean;
}
/**
 * A WeakMap-based implementation representing a value that definitely exists.
 * This class is used when you know a value exists and want to provide
 * type-safe access to it through the WeakOption interface.
 *
 * @template B - The base object type used as a key in the WeakMap
 * @template T - The type of the value being stored
 *
 * @example
 * ```typescript
 * const obj = new MyObject();
 * const some = new WeakSome(obj, "definite value");
 * const value = some.unwrapForce(obj); // Always returns "definite value"
 * ```
 */
declare class WeakSome<B extends object, T> implements IWeakOption<B, T> {
    private __weakMap;
    /**
     * Creates a new WeakSome instance with a guaranteed value.
     *
     * @param base - The base object to use as a key
     * @param value - The value to store (guaranteed to exist)
     */
    constructor(base: B, value: T);
    /**
     * Unwraps the value, ignoring the alternative value since this value always exists.
     *
     * @param base - The base object used as a key
     * @param altValue - The alternative value (ignored)
     * @returns The stored value
     */
    unwrapOrDefault(base: B, _altValue: T): T;
    /**
     * Unwraps the value, ignoring the function since this value always exists.
     *
     * @param base - The base object used as a key
     * @param f - Function to execute (ignored)
     * @returns The stored value
     */
    unwrapOrElse(base: B, _f: (value: T) => T): T;
    /**
     * Forcefully unwraps the value (always succeeds since the value exists).
     *
     * @param base - The base object used as a key
     * @returns The stored value
     */
    unwrapForce(base: B): T;
    /**
     * Gets the value directly (convenience method).
     *
     * @param base - The base object used as a key
     * @returns The stored value
     */
    get(base: B): T;
    /**
     * Unwraps the value or returns undefined (always returns the value).
     *
     * @param base - The base object used as a key
     * @returns The stored value
     */
    unwrapOrUndefined(base: B): T | undefined;
    /**
     * Checks if a value exists (always returns true).
     *
     * @param base - The base object used as a key (unused)
     * @returns Always true
     */
    has(_base: B): true;
}
/**
 * A class representing the absence of a value in the WeakOption pattern.
 * This class implements the "None" case of the Option pattern, providing
 * safe handling when no value exists.
 *
 * @template B - The base object type used as a key
 *
 * @example
 * ```typescript
 * const none = new WeakNone<MyObject>();
 * const obj = new MyObject();
 * const value = none.unwrapOrDefault(obj, "default"); // Always returns "default"
 * ```
 */
declare class WeakNone<B extends object> implements IWeakOption<B, never> {
    /**
     * Returns this instance (for chaining operations).
     *
     * @returns This WeakNone instance
     */
    then(): WeakNone<B>;
    /**
     * Returns the default value since no value exists.
     *
     * @template T - The type of the default value
     * @param base - The base object used as a key (unused)
     * @param value - The default value to return
     * @returns The default value
     */
    unwrapOrDefault<T>(_base: B, value: T): T;
    /**
     * Executes the function since no value exists.
     *
     * @param base - The base object used as a key (unused)
     * @param f - Function to execute
     * @returns The result of the function
     */
    unwrapOrElse(_base: B, f: (...vals: any) => never): never;
    /**
     * Throws an error since no value exists.
     *
     * @param base - The base object used as a key (unused)
     * @throws {ReferenceError} Always throws since no value exists
     */
    unwrapForce(_base: B): never;
    /**
     * Returns undefined since no value exists.
     *
     * @param base - The base object used as a key (unused)
     * @returns Always undefined
     */
    unwrapOrUndefined(_base: B): never;
    /**
     * Checks if a value exists (always returns false).
     *
     * @returns Always false
     */
    has(): false;
}

/**
 * Enumeration of log levels in ascending order of severity.
 * Lower numeric values represent less severe log levels.
 */
declare enum LogLevel {
    Debug = 0,
    Info = 1,
    Warn = 2,
    Error = 3,
    Assert = 4
}
/**
 * A comprehensive logging utility class that provides various log levels,
 * message formatting, and log accumulation capabilities.
 *
 * Features:
 * - Multiple log levels (Debug, Info, Warn, Error, Assert)
 * - Rich formatting with timestamps
 * - Log accumulation for later retrieval
 * - Configurable log level filtering
 *
 * @example
 * ```typescript
 * // Configure logger
 * Logger.logLevel = LogLevel.Info;
 * Logger.isRichLog = true;
 * Logger.isAccumulateLog = true;
 *
 * // Use logging methods
 * Logger.info("Application started");
 * Logger.warn("This is a warning");
 * Logger.error("An error occurred");
 *
 * // Retrieve accumulated logs
 * const logs = Logger.getAccumulatedLog();
 * ```
 */
declare class Logger {
    private static __messages;
    /** The minimum log level that will be output. Messages below this level are ignored. */
    static logLevel: LogLevel;
    /** Whether to format log messages with timestamps and log level prefixes. */
    static isRichLog: boolean;
    /** Whether to store log messages in memory for later retrieval. */
    static isAccumulateLog: boolean;
    /**
     * Common processing for all log methods. Handles message formatting and storage.
     *
     * @param message - The log message to process
     * @param logLevel - The severity level of the log message
     * @returns The formatted log message
     * @private
     */
    private static __common;
    /**
     * Clears all accumulated log messages from memory.
     *
     * @private
     */
    private static __clearAccumulatedLog;
    /**
     * Formats a log entry with timestamp and log level information if rich logging is enabled.
     *
     * @param log - The log entry to format
     * @returns The formatted log message string
     * @private
     */
    private static __formatLogs;
    /**
     * Converts a LogLevel enum value to its string representation.
     *
     * @param logLevel - The log level to convert
     * @returns The string name of the log level
     * @private
     */
    private static __getLogLevelText;
    /**
     * Logs an error message to the console if the current log level permits it.
     * Error messages indicate serious problems that should be addressed immediately.
     *
     * @param message - The error message to log
     * @returns The formatted message if logged, undefined if filtered out
     *
     * @example
     * ```typescript
     * Logger.error("Database connection failed");
     * ```
     */
    static error(message: string): string | undefined;
    /**
     * Logs a warning message to the console if the current log level permits it.
     * Warning messages indicate potential issues that should be monitored.
     *
     * @param message - The warning message to log
     * @returns The formatted message if logged, undefined if filtered out
     *
     * @example
     * ```typescript
     * Logger.warn("API response time is slower than expected");
     * ```
     */
    static warn(message: string): string | undefined;
    /**
     * Logs an informational message to the console if the current log level permits it.
     * Info messages provide general information about application flow and state.
     *
     * @param message - The informational message to log
     * @returns The formatted message if logged, undefined if filtered out
     *
     * @example
     * ```typescript
     * Logger.info("User authentication successful");
     * ```
     */
    static info(message: string): string | undefined;
    /**
     * Logs a debug message to the console if the current log level permits it.
     * Debug messages provide detailed information useful for troubleshooting and development.
     *
     * @param message - The debug message to log
     * @returns The formatted message if logged, undefined if filtered out
     *
     * @example
     * ```typescript
     * Logger.debug("Processing user input: " + JSON.stringify(input));
     * ```
     */
    static debug(message: string): string | undefined;
    /**
     * Performs a console assertion and logs a message if the condition is false.
     * Assert messages are used for debugging and testing critical assumptions.
     *
     * @param condition - The condition to test; if false, the assertion fails
     * @param message - The message to log when the assertion fails
     * @returns The formatted message if logged, undefined if filtered out
     *
     * @example
     * ```typescript
     * Logger.assert(user !== null, "User object should not be null at this point");
     * ```
     */
    static assert(condition: boolean, message: string): string | undefined;
    /**
     * Retrieves all accumulated log messages as formatted strings.
     * Only available when `isAccumulateLog` is enabled.
     *
     * @returns An array of formatted log message strings
     *
     * @example
     * ```typescript
     * Logger.isAccumulateLog = true;
     * Logger.info("First message");
     * Logger.warn("Second message");
     *
     * const logs = Logger.getAccumulatedLog();
     * console.log(logs); // Array of formatted log messages
     * ```
     */
    static getAccumulatedLog(): string[];
}

/**
 * BufferView represents a view into a Buffer with specific byte offset and length.
 * It manages memory allocation for Accessors and provides methods to create Accessors
 * that read data from the underlying buffer in various formats.
 *
 * BufferView acts as an intermediate layer between Buffer and Accessor, allowing
 * multiple Accessors to share the same buffer memory while maintaining proper
 * byte alignment and bounds checking.
 */
declare class BufferView {
    private __buffer;
    private __byteOffsetInRawArrayBufferOfBuffer;
    private __byteOffsetInBuffer;
    private __byteLength;
    private __defaultByteStride;
    private __takenByte;
    private __takenAccessorCount;
    private __raw;
    private __accessors;
    /**
     * Creates a new BufferView instance.
     *
     * @param params - Configuration object for the BufferView
     * @param params.buffer - The parent Buffer that this BufferView references
     * @param params.byteOffsetInBuffer - Byte offset within the parent buffer
     * @param params.defaultByteStride - Default stride in bytes between elements
     * @param params.byteLength - Total byte length of this BufferView
     * @param params.raw - The underlying ArrayBuffer containing the actual data
     */
    constructor({ buffer, byteOffsetInBuffer, defaultByteStride, byteLength, raw, }: {
        buffer: Buffer;
        byteOffsetInBuffer: Byte$1;
        defaultByteStride: Byte$1;
        byteLength: Byte$1;
        raw: ArrayBuffer;
    });
    /**
     * Gets the default byte stride for this BufferView.
     * The stride determines the number of bytes between consecutive elements.
     *
     * @returns The default byte stride in bytes
     */
    get defaultByteStride(): number;
    /**
     * Gets the total byte length of this BufferView.
     *
     * @returns The byte length of this BufferView
     */
    get byteLength(): number;
    /**
     * Gets the byte offset of this BufferView within its parent Buffer.
     * This is the relative offset from the start of the Buffer.
     *
     * @returns The byte offset within the parent Buffer
     */
    get byteOffsetInBuffer(): Byte$1;
    /**
     * Gets the absolute byte offset in the raw ArrayBuffer.
     * This includes the Buffer's own offset within the raw ArrayBuffer.
     *
     * @returns The absolute byte offset in the raw ArrayBuffer
     */
    get byteOffsetInRawArrayBufferOfBuffer(): number;
    /**
     * Gets the parent Buffer that this BufferView references.
     *
     * @returns The parent Buffer instance
     */
    get buffer(): Buffer;
    /**
     * Checks if this BufferView uses Structure of Arrays (SoA) layout.
     * SoA layout stores each component type in separate arrays.
     *
     * @returns True if using SoA layout, false otherwise
     */
    get isSoA(): boolean;
    /**
     * Checks if this BufferView uses Array of Structures (AoS) layout.
     * AoS layout interleaves different component types within the same array.
     *
     * @returns True if any accessor uses AoS layout, false otherwise
     */
    get isAoS(): boolean;
    /**
     * Creates a Uint8Array view of this BufferView's memory area.
     * This provides direct access to the raw bytes within the BufferView's bounds.
     *
     * @returns A Uint8Array representing the BufferView's memory area
     */
    getUint8Array(): Uint8Array;
    /**
     * Creates and allocates a new Accessor within this BufferView.
     * The Accessor will be positioned at the current end of allocated space.
     *
     * @param params - Configuration object for the Accessor
     * @param params.compositionType - The composition type (e.g., SCALAR, VEC2, VEC3, VEC4, MAT4)
     * @param params.componentType - The component data type (e.g., FLOAT, UNSIGNED_SHORT)
     * @param params.count - Number of elements in the accessor
     * @param params.byteStride - Optional byte stride between elements (defaults to defaultByteStride)
     * @param params.max - Optional maximum values for each component
     * @param params.min - Optional minimum values for each component
     * @param params.arrayLength - Optional array length for array attributes (defaults to 1)
     * @param params.normalized - Whether integer values should be normalized to [0,1] or [-1,1] range
     * @returns A Result containing the created Accessor on success, or an error on failure
     */
    takeAccessor({ compositionType, componentType, count, byteStride, max, min, arrayLength, normalized, }: {
        compositionType: CompositionTypeEnum;
        componentType: ComponentTypeEnum;
        count: Count;
        byteStride?: Byte$1;
        max?: number[];
        min?: number[];
        arrayLength?: Size;
        normalized?: boolean;
    }): Result<Accessor, undefined>;
    /**
     * Creates and allocates a new Accessor at a specific byte offset within this BufferView.
     * Unlike takeAccessor, this method allows specifying the exact position within the BufferView.
     *
     * @param params - Configuration object for the Accessor
     * @param params.compositionType - The composition type (e.g., SCALAR, VEC2, VEC3, VEC4, MAT4)
     * @param params.componentType - The component data type (e.g., FLOAT, UNSIGNED_SHORT)
     * @param params.count - Number of elements in the accessor
     * @param params.byteOffsetInBufferView - Specific byte offset within this BufferView
     * @param params.byteStride - Optional byte stride between elements (defaults to defaultByteStride)
     * @param params.max - Optional maximum values for each component
     * @param params.min - Optional minimum values for each component
     * @param params.normalized - Whether integer values should be normalized to [0,1] or [-1,1] range
     * @returns A Result containing the created Accessor on success, or an error on failure
     */
    takeAccessorWithByteOffset({ compositionType, componentType, count, byteOffsetInBufferView, byteStride, max, min, normalized, }: {
        compositionType: CompositionTypeEnum;
        componentType: ComponentTypeEnum;
        count: Count;
        byteOffsetInBufferView: Byte$1;
        byteStride?: Byte$1;
        max?: number[];
        min?: number[];
        normalized?: boolean;
    }): Result<Accessor, undefined>;
    /**
     * Internal method to create an Accessor at the current allocation position.
     * Performs bounds checking and updates the internal allocation state.
     *
     * @param params - Configuration parameters for the Accessor
     * @returns A Result containing the created Accessor on success, or an error on failure
     * @private
     */
    private __takeAccessorInner;
    /**
     * Internal method to create an Accessor at a specific byte offset.
     * Performs bounds checking but does not update the internal allocation state.
     *
     * @param params - Configuration parameters for the Accessor
     * @returns A Result containing the created Accessor on success, or an error on failure
     * @private
     */
    private __takeAccessorInnerWithByteOffset;
    /**
     * Compares this BufferView with another BufferView for equality.
     * Two BufferViews are considered the same if they have identical byte length,
     * byte offset, default byte stride, and reference the same underlying ArrayBuffer.
     *
     * @param rnBufferView - The BufferView to compare with
     * @returns True if the BufferViews are identical, false otherwise
     */
    isSame(rnBufferView: BufferView): boolean;
}

type IndicesAccessOption = {
    indicesAccessor?: Accessor;
    endian?: boolean;
};
/**
 * Accessor class provides a high-level interface for reading and writing data from/to a BufferView.
 * It handles different data types (scalar, vector, matrix) and provides type-safe access to buffer data.
 * This class is commonly used in 3D graphics applications for managing vertex attributes, indices, and other buffer data.
 */
declare class Accessor {
    private __bufferView;
    private __byteOffsetInRawArrayBufferOfBuffer;
    private __compositionType;
    private __componentType;
    private __count;
    private __raw;
    private __dataView?;
    private __typedArray;
    private __takenCount;
    private __byteStride;
    private __typedArrayClass?;
    private __dataViewGetter;
    private __dataViewSetter;
    private __max;
    private __min;
    private __arrayLength;
    private __normalized;
    private __isMinMixDirty;
    private static __tmpVector4_0;
    private static __tmpVector3_0;
    private static __tmpVector2_0;
    private __version;
    _primitive?: WeakRef<Primitive>;
    /**
     * Creates a new Accessor instance.
     * @param params - Configuration object for the accessor
     * @param params.bufferView - The BufferView that contains the data
     * @param params.byteOffsetInBufferView - Byte offset within the buffer view
     * @param params.compositionType - Type of data composition (scalar, vec2, vec3, vec4, mat3, mat4)
     * @param params.componentType - Component data type (byte, short, int, float, etc.)
     * @param params.byteStride - Byte stride between elements (0 for tightly packed)
     * @param params.count - Number of elements
     * @param params.raw - Raw ArrayBuffer containing the data
     * @param params.max - Optional maximum values for each component
     * @param params.min - Optional minimum values for each component
     * @param params.arrayLength - Length of array for each element
     * @param params.normalized - Whether integer values should be normalized to [0,1] or [-1,1]
     */
    constructor({ bufferView, byteOffsetInBufferView, compositionType, componentType, byteStride, count, raw, max, min, arrayLength, normalized, }: {
        bufferView: BufferView;
        byteOffsetInBufferView: Byte$1;
        compositionType: CompositionTypeEnum;
        componentType: ComponentTypeEnum;
        byteStride: Byte$1;
        count: Count;
        raw: ArrayBuffer;
        max?: number[];
        min?: number[];
        arrayLength: Size;
        normalized: boolean;
    });
    /**
     * Copies buffer data to a typed array when byte alignment doesn't match.
     * This is necessary when the buffer offset is not aligned with the typed array's BYTES_PER_ELEMENT.
     * @private
     */
    private __copyBufferDataToTypedArray;
    /**
     * Called when the accessor data is updated. Increments version and notifies associated primitives.
     * @private
     */
    private __onUpdated;
    /**
     * Gets the appropriate TypedArray constructor for the given component type.
     * @param componentType - The component type to get the constructor for
     * @returns The TypedArray constructor class, or undefined if unknown
     */
    getTypedArrayClass(componentType: ComponentTypeEnum): TypedArrayConstructor | undefined;
    /**
     * Gets the DataView getter method name for the given component type.
     * @param componentType - The component type to get the getter for
     * @returns The DataView getter method name, or undefined if unknown
     */
    getDataViewGetter(componentType: ComponentTypeEnum): string | undefined;
    /**
     * Gets the DataView setter method name for the given component type.
     * @param componentType - The component type to get the setter for
     * @returns The DataView setter method name, or undefined if unknown
     */
    getDataViewSetter(componentType: ComponentTypeEnum): string | undefined;
    /**
     * Takes one element from the accessor and returns a TypedArray view of it.
     * This method allocates a new view for the next available element.
     * @returns A TypedArray view of the taken element
     * @throws Error if trying to allocate more elements than available
     */
    takeOne(): TypedArray;
    /**
     * Takes an existing element at the specified index and returns a TypedArray view of it.
     * This method creates a view for an element that has already been allocated.
     * @param idx - The index of the element to take
     * @returns A TypedArray view of the element at the specified index
     * @throws Error if the index exceeds the available element count
     * @private
     */
    _takeExistedOne(idx: number): TypedArray;
    /**
     * Gets the number of elements that have been taken from this accessor.
     * @returns The count of taken elements
     */
    get takenCount(): Count;
    /**
     * Gets the number of components per element (e.g., 3 for Vec3, 4 for Vec4).
     * @returns The number of components
     */
    get numberOfComponents(): number;
    /**
     * Gets the size in bytes of each component.
     * @returns The component size in bytes
     */
    get componentSizeInBytes(): number;
    /**
     * Gets the size in bytes of each element (numberOfComponents * componentSizeInBytes).
     * @returns The element size in bytes
     */
    get elementSizeInBytes(): number;
    /**
     * Gets the total number of elements in this accessor.
     * Each element may be a scalar, vec2, vec3, vec4, matrix, etc.
     * @returns The element count
     */
    get elementCount(): Count;
    /**
     * Gets the total byte length of all data in this accessor.
     * @returns The byte length
     */
    get byteLength(): Byte$1;
    /**
     * Gets the component type of this accessor.
     * @returns The component type enum
     */
    get componentType(): ComponentTypeEnum;
    /**
     * Gets the composition type of this accessor.
     * @returns The composition type enum
     */
    get compositionType(): CompositionTypeEnum;
    /**
     * Gets the underlying TypedArray for this accessor.
     * Note: If the buffer view uses interleaved data (AoS), direct access may not work as expected.
     * @returns The TypedArray containing the data
     */
    getTypedArray(): TypedArray;
    /**
     * Sets the data from a TypedArray into this accessor.
     * If the provided array uses the same buffer, no copying is needed.
     * Otherwise, data is copied element by element with proper type conversion.
     * @param typedArray - The TypedArray to copy data from
     */
    setTypedArray(typedArray: TypedArray): void;
    /**
     * Gets a Uint8Array view of this accessor's data.
     * Useful for raw byte-level access to the buffer data.
     * @returns A Uint8Array view of the accessor's data
     */
    getUint8Array(): Uint8Array;
    /**
     * Checks if this accessor uses Array of Structures (AoS) layout.
     * AoS means data is interleaved (e.g., XYZXYZXYZ for positions).
     * @returns True if using AoS layout
     */
    get isAoS(): boolean;
    /**
     * Checks if this accessor uses Structure of Arrays (SoA) layout.
     * SoA means data is tightly packed (e.g., XXXYYYZZZ for positions).
     * @returns True if using SoA layout
     */
    get isSoA(): boolean;
    /**
     * Gets the byte stride between elements.
     * For tightly packed data, this equals elementSizeInBytes.
     * For interleaved data, this may be larger.
     * @returns The byte stride
     */
    get byteStride(): number;
    /**
     * Gets a scalar value at the specified index.
     * @param i - The element index
     * @param options - Access options including indices accessor and endianness
     * @returns The scalar value
     */
    getScalar(i: Index, { indicesAccessor, endian }: IndicesAccessOption): number;
    /**
     * Gets a scalar value at the specified index with a composition offset.
     * @param i - The element index
     * @param compositionOffset - Byte offset within the element
     * @param options - Access options including indices accessor and endianness
     * @returns The scalar value
     */
    getScalarAt(i: Index, compositionOffset: Index, { indicesAccessor, endian }: IndicesAccessOption): number;
    /**
     * Gets a 2D vector as an array at the specified index.
     * @param i - The element index
     * @param options - Access options including indices accessor and endianness
     * @returns A 2-element array containing the vector components
     */
    getVec2AsArray(i: Index, { indicesAccessor, endian }: IndicesAccessOption): Array2<number>;
    /**
     * Gets a 3D vector as an array at the specified index.
     * @param i - The element index
     * @param options - Access options including indices accessor and endianness
     * @returns A 3-element array containing the vector components
     */
    getVec3AsArray(i: Index, { indicesAccessor, endian }: IndicesAccessOption): Array3<number>;
    /**
     * Gets a 4D vector as an array at the specified index.
     * @param i - The element index
     * @param options - Access options including indices accessor and endianness
     * @returns A 4-element array containing the vector components
     */
    getVec4AsArray(i: Index, { indicesAccessor, endian }: IndicesAccessOption): Array4<number>;
    /**
     * Gets a 3x3 matrix as an array at the specified index.
     * @param i - The element index
     * @param options - Access options including indices accessor and endianness
     * @returns A 9-element array containing the matrix components in row-major order
     */
    getMat3AsArray(i: Index, { indicesAccessor, endian }: IndicesAccessOption): Array<number>;
    /**
     * Gets a 4x4 matrix as an array at the specified index.
     * @param i - The element index
     * @param options - Access options including indices accessor and endianness
     * @returns A 16-element array containing the matrix components in row-major order
     */
    getMat4AsArray(i: Index, { indicesAccessor, endian }: IndicesAccessOption): Array<number>;
    /**
     * Gets a 2D vector object at the specified index.
     * @param i - The element index
     * @param options - Access options including indices accessor and endianness
     * @returns A Vector2 object containing the vector components
     */
    getVec2(i: Index, { indicesAccessor, endian }: IndicesAccessOption): Vector2;
    /**
     * Gets a 3D vector object at the specified index.
     * @param i - The element index
     * @param options - Access options including indices accessor and endianness
     * @returns A Vector3 object containing the vector components
     */
    getVec3(i: Index, { indicesAccessor, endian }: IndicesAccessOption): Vector3;
    /**
     * Gets a 4D vector object at the specified index.
     * @param i - The element index
     * @param options - Access options including indices accessor and endianness
     * @returns A Vector4 object containing the vector components
     */
    getVec4(i: Index, { indicesAccessor, endian }: IndicesAccessOption): Vector4;
    /**
     * Gets a 3x3 matrix object at the specified index.
     * @param i - The element index
     * @param options - Access options including indices accessor and endianness
     * @returns A Matrix33 object containing the matrix components
     */
    getMat3(i: Index, { indicesAccessor, endian }: IndicesAccessOption): Matrix33;
    /**
     * Gets a 4x4 matrix object at the specified index.
     * @param i - The element index
     * @param options - Access options including indices accessor and endianness
     * @returns A MutableMatrix44 object containing the matrix components
     */
    getMat4(i: Index, { indicesAccessor, endian }: IndicesAccessOption): MutableMatrix44;
    /**
     * Gets a 2D vector at the specified index and stores it in the provided output object.
     * This method avoids creating new objects and is more memory-efficient.
     * @param i - The element index
     * @param out - The output MutableVector2 object to store the result
     * @param options - Access options including indices accessor and endianness
     * @returns The output Vector2 object (same as the out parameter)
     */
    getVec2To(i: Index, out: MutableVector2, { indicesAccessor, endian }: IndicesAccessOption): Vector2;
    /**
     * Gets a 3D vector at the specified index and stores it in the provided output object.
     * This method avoids creating new objects and is more memory-efficient.
     * @param i - The element index
     * @param out - The output MutableVector3 object to store the result
     * @param options - Access options including indices accessor and endianness
     * @returns The output Vector3 object (same as the out parameter)
     */
    getVec3To(i: Index, out: MutableVector3, { indicesAccessor, endian }: IndicesAccessOption): Vector3;
    /**
     * Gets a 4D vector at the specified index and stores it in the provided output object.
     * This method avoids creating new objects and is more memory-efficient.
     * @param i - The element index
     * @param out - The output MutableVector4 object to store the result
     * @param options - Access options including indices accessor and endianness
     * @returns The output Vector4 object (same as the out parameter)
     */
    getVec4To(i: Index, out: MutableVector4, { indicesAccessor, endian }: IndicesAccessOption): Vector4;
    /**
     * Gets a 3x3 matrix at the specified index and stores it in the provided output object.
     * This method avoids creating new objects and is more memory-efficient.
     * @param i - The element index
     * @param out - The output MutableMatrix33 object to store the result
     * @param options - Access options including indices accessor and endianness
     * @returns The output Matrix33 object (same as the out parameter)
     */
    getMat3To(i: Index, out: MutableMatrix33, { indicesAccessor, endian }: {
        indicesAccessor?: Accessor | undefined;
        endian?: boolean;
    }): Matrix33;
    /**
     * Gets a 4x4 matrix at the specified index and stores it in the provided output object.
     * This method avoids creating new objects and is more memory-efficient.
     * @param i - The element index
     * @param out - The output MutableMatrix44 object to store the result
     * @param options - Access options including indices accessor and endianness
     * @returns The output MutableMatrix44 object (same as the out parameter)
     */
    getMat4To(i: Index, out: MutableMatrix44, { indicesAccessor, endian }: IndicesAccessOption): MutableMatrix44;
    /**
     * Sets a scalar value at the specified index.
     * @param i - The element index
     * @param value - The scalar value to set
     * @param options - Access options including indices accessor and endianness
     */
    setScalar(i: Index, value: number, { indicesAccessor, endian }: IndicesAccessOption): void;
    /**
     * Sets a 2D vector at the specified index.
     * @param i - The element index
     * @param x - The X component value
     * @param y - The Y component value
     * @param options - Access options including indices accessor and endianness
     */
    setVec2(i: Index, x: number, y: number, { indicesAccessor, endian }: IndicesAccessOption): void;
    /**
     * Sets a 3D vector at the specified index.
     * @param i - The element index
     * @param x - The X component value
     * @param y - The Y component value
     * @param z - The Z component value
     * @param options - Access options including indices accessor and endianness
     */
    setVec3(i: Index, x: number, y: number, z: number, { indicesAccessor, endian }: IndicesAccessOption): void;
    /**
     * Sets a 4D vector at the specified index.
     * @param i - The element index
     * @param x - The X component value
     * @param y - The Y component value
     * @param z - The Z component value
     * @param w - The W component value
     * @param options - Access options including indices accessor and endianness
     */
    setVec4(i: Index, x: number, y: number, z: number, w: number, { indicesAccessor, endian }: IndicesAccessOption): void;
    /**
     * Sets a 3x3 matrix at the specified index.
     * @param i - The element index
     * @param v0 - Matrix component at position [0,0]
     * @param v1 - Matrix component at position [0,1]
     * @param v2 - Matrix component at position [0,2]
     * @param v3 - Matrix component at position [1,0]
     * @param v4 - Matrix component at position [1,1]
     * @param v5 - Matrix component at position [1,2]
     * @param v6 - Matrix component at position [2,0]
     * @param v7 - Matrix component at position [2,1]
     * @param v8 - Matrix component at position [2,2]
     * @param options - Access options including indices accessor and endianness
     */
    setMat3(i: Index, v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, { indicesAccessor, endian }: IndicesAccessOption): void;
    /**
     * Sets a 4x4 matrix at the specified index.
     * @param i - The element index
     * @param v0 - Matrix component at position [0,0]
     * @param v1 - Matrix component at position [0,1]
     * @param v2 - Matrix component at position [0,2]
     * @param v3 - Matrix component at position [0,3]
     * @param v4 - Matrix component at position [1,0]
     * @param v5 - Matrix component at position [1,1]
     * @param v6 - Matrix component at position [1,2]
     * @param v7 - Matrix component at position [1,3]
     * @param v8 - Matrix component at position [2,0]
     * @param v9 - Matrix component at position [2,1]
     * @param v10 - Matrix component at position [2,2]
     * @param v11 - Matrix component at position [2,3]
     * @param v12 - Matrix component at position [3,0]
     * @param v13 - Matrix component at position [3,1]
     * @param v14 - Matrix component at position [3,2]
     * @param v15 - Matrix component at position [3,3]
     * @param options - Access options including indices accessor and endianness
     */
    setMat4(i: Index, v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number, { indicesAccessor, endian }: IndicesAccessOption): void;
    /**
     * Sets a 2D vector at the specified index using a Vector2 object.
     * @param i - The element index
     * @param vec - The Vector2 object containing the values to set
     * @param options - Access options including indices accessor and endianness
     */
    setVec2AsVector(i: Index, vec: Vector2, { indicesAccessor, endian }: IndicesAccessOption): void;
    /**
     * Sets a 3D vector at the specified index using a Vector3 object.
     * @param i - The element index
     * @param vec - The Vector3 object containing the values to set
     * @param options - Access options including indices accessor and endianness
     */
    setVec3AsVector(i: Index, vec: Vector3, { indicesAccessor, endian }: IndicesAccessOption): void;
    /**
     * Sets a 4D vector at the specified index using a Vector4 object.
     * @param i - The element index
     * @param vec - The Vector4 object containing the values to set
     * @param options - Access options including indices accessor and endianness
     */
    setVec4AsVector(i: Index, vec: Vector4, { indicesAccessor, endian }: IndicesAccessOption): void;
    /**
     * Sets a 4x4 matrix at the specified index using a Matrix44 object.
     * @param i - The element index
     * @param mat - The Matrix44 object containing the values to set
     * @param options - Access options including indices accessor and endianness
     */
    setMat4AsMatrix44(i: Index, mat: Matrix44, { indicesAccessor, endian }: IndicesAccessOption): void;
    /**
     * Copies data from a TypedArray into this accessor.
     * The data is copied element by element with proper type conversion.
     * @param typedArray - The TypedArray to copy data from
     */
    copyFromTypedArray(typedArray: TypedArray): void;
    /**
     * Sets a scalar value at the specified index with a composition offset.
     * @param i - The element index
     * @param compositionOffset - Byte offset within the element
     * @param value - The scalar value to set
     * @param options - Access options including indices accessor and endianness
     */
    setScalarAt(i: Index, compositionOffset: Index, value: number, { indicesAccessor, endian }: IndicesAccessOption): void;
    /**
     * Sets an element from another accessor with the same composition type.
     * @param i - The target element index
     * @param accessor - The source accessor to copy from
     * @param secondIdx - Optional source index (defaults to i)
     */
    setElementFromSameCompositionAccessor(i: Index, accessor: Accessor, secondIdx?: Index): void;
    /**
     * Copies the entire buffer from another accessor.
     * @param accessor - The source accessor to copy the buffer from
     */
    copyBuffer(accessor: Accessor): void;
    /**
     * Sets an element from another accessor, handling different composition types.
     * Automatically converts between different vector/scalar types as needed.
     * @param i - The target element index
     * @param accessor - The source accessor to copy from
     * @param secondIdx - Optional source index (defaults to i)
     */
    setElementFromAccessor(i: Index, accessor: Accessor, secondIdx?: Index): void;
    /**
     * Adds an element from another accessor with the same composition type, scaled by a coefficient.
     * @param i - The target element index
     * @param accessor - The source accessor to add from
     * @param coeff - The coefficient to multiply the source values by
     * @param secondIdx - Optional source index (defaults to i)
     */
    addElementFromSameCompositionAccessor(i: Index, accessor: Accessor, coeff: number, secondIdx?: Index): void;
    /**
     * Gets the underlying ArrayBuffer of the buffer view.
     * @returns The ArrayBuffer containing the data
     */
    get arrayBufferOfBufferView(): ArrayBuffer;
    /**
     * Gets the DataView of the buffer view.
     * @returns The DataView for accessing the buffer data
     */
    get dataViewOfBufferView(): DataView;
    /**
     * Gets the byte offset within the buffer view.
     * @returns The byte offset in the buffer view
     */
    get byteOffsetInBufferView(): Byte$1;
    /**
     * Gets the byte offset within the buffer.
     * @returns The byte offset in the buffer
     */
    get byteOffsetInBuffer(): Byte$1;
    /**
     * Gets the byte offset in the raw ArrayBuffer of the buffer.
     * @returns The byte offset in the raw ArrayBuffer
     */
    get byteOffsetInRawArrayBufferOfBuffer(): number;
    /**
     * Gets the BufferView that contains this accessor's data.
     * @returns The BufferView object
     */
    get bufferView(): BufferView;
    /**
     * Sets the minimum and maximum values for this accessor.
     * @param min - Array of minimum values for each component
     * @param max - Array of maximum values for each component
     */
    setMinMax(min: number[], max: number[]): void;
    /**
     * Gets the minimum values for each component.
     * Calculates min/max if dirty.
     * @returns Array of minimum values
     */
    get min(): number[];
    /**
     * Gets the maximum values for each component.
     * Calculates min/max if dirty.
     * @returns Array of maximum values
     */
    get max(): number[];
    /**
     * Gets whether the data should be normalized.
     * @returns True if data should be normalized
     */
    get normalized(): boolean;
    /**
     * Calculates the minimum and maximum values for all elements.
     * @private
     */
    private __calcMinMax;
    /**
     * Gets whether the min/max values are dirty and need recalculation.
     * @returns True if min/max values are dirty
     */
    get isMinMaxDirty(): boolean;
    /**
     * Gets the version number of this accessor.
     * Increments when data is modified.
     * @returns The version number
     */
    get version(): number;
    /**
     * Gets the actual byte stride, accounting for zero stride.
     * @returns The actual byte stride
     */
    get actualByteStride(): number;
    /**
     * Checks if this accessor is the same as another accessor.
     * Compares byte length, offset, and underlying buffer.
     * @param rnAccessor - The accessor to compare with
     * @returns True if the accessors are the same
     */
    isSame(rnAccessor: Accessor): boolean;
}

/**
 * SkeletalComponent manages skeletal animation for entities.
 * This component handles bone transformations, joint matrices, and skinning calculations
 * for 3D models with skeletal animation systems.
 */
declare class SkeletalComponent extends Component {
    _jointIndices: Index[];
    private __joints;
    private __inverseBindMatricesAccessor?;
    _bindShapeMatrix?: Matrix44;
    private __jointMatrices?;
    topOfJointsHierarchy?: SceneGraphComponent;
    isSkinning: boolean;
    private __qArray;
    private __tsArray;
    private __tqArray;
    private __sqArray;
    private __qtsArray;
    private __qtsInfo;
    private __matArray;
    private __worldMatrix;
    private __isWorldMatrixVanilla;
    _isCulled: boolean;
    private static __globalDataRepository;
    private static __tookGlobalDataNum;
    private static __tmpVec3_0;
    private static __tmp_mat4;
    private static __tmp_q;
    private static __identityMat;
    /**
     * Creates a new SkeletalComponent instance.
     * Initializes the component with skeletal animation capabilities and reserves global data resources.
     *
     * @param entityUid - The unique identifier of the entity this component belongs to
     * @param componentSid - The component's system identifier
     * @param entityRepository - The repository managing entities
     * @param isReUse - Whether this component is being reused from a pool
     */
    constructor(entityUid: EntityUID, componentSid: ComponentSID, entityRepository: EntityRepository, isReUse: boolean);
    /**
     * Gets the static component type identifier for SkeletalComponent.
     *
     * @returns The component type identifier
     */
    static get componentTID(): ComponentTID;
    /**
     * Gets the component type identifier for this instance.
     *
     * @returns The component type identifier
     */
    get componentTID(): ComponentTID;
    /**
     * Sets the accessor for inverse bind matrices used in skeletal animation.
     * These matrices transform vertices from model space to bone space.
     *
     * @param inverseBindMatricesAccessor - The accessor containing inverse bind matrices data
     */
    setInverseBindMatricesAccessor(inverseBindMatricesAccessor: Accessor): void;
    /**
     * Sets the joint hierarchy for this skeletal component.
     * Initializes the appropriate data arrays based on the configured bone data type.
     *
     * @param joints - Array of SceneGraphComponents representing the joints/bones
     */
    setJoints(joints: SceneGraphComponent[]): void;
    /**
     * Gets a copy of the joints array.
     *
     * @returns A copy of the SceneGraphComponents representing the joints
     */
    getJoints(): SceneGraphComponent[];
    /**
     * Gets the world matrix of the root joint in the hierarchy.
     *
     * @returns The world matrix of the top joint, or undefined if no top joint exists
     */
    get rootJointWorldMatrixInner(): MutableMatrix44 | undefined;
    /**
     * Gets the computed joint matrices array.
     *
     * @returns The joint matrices array
     */
    get jointMatrices(): number[] | undefined;
    /**
     * Gets the quaternion array for joints (used in Vec4x2Old bone data type).
     *
     * @returns The Float32Array containing joint quaternions
     */
    get jointQuaternionArray(): Float32Array<ArrayBuffer>;
    /**
     * Gets the translate-scale array for joints.
     *
     * @returns The Float32Array containing joint translation and scale data
     */
    get jointTranslateScaleArray(): Float32Array<ArrayBuffer>;
    /**
     * Gets the translate-packed quaternion array for joints (used in Vec4x2 bone data type).
     *
     * @returns The Float32Array containing translation and packed quaternion data
     */
    get jointTranslatePackedQuat(): Float32Array<ArrayBuffer>;
    /**
     * Gets the scale-packed quaternion array for joints (used in Vec4x2 bone data type).
     *
     * @returns The Float32Array containing scale and packed quaternion data
     */
    get jointScalePackedQuat(): Float32Array<ArrayBuffer>;
    /**
     * Gets the joint matrices array (used in Mat43x1 bone data type).
     *
     * @returns The Float32Array containing joint matrices
     */
    get jointMatricesArray(): Float32Array<ArrayBuffer>;
    /**
     * Gets the compressed joint data chunk (used in Vec4x1 bone data type).
     *
     * @returns The Float32Array containing compressed joint data
     */
    get jointCompressedChunk(): Float32Array<ArrayBuffer>;
    /**
     * Gets the compression information for joint data (used in Vec4x1 bone data type).
     *
     * @returns The compression information vector
     */
    get jointCompressedInfo(): MutableVector4;
    /**
     * Gets a copy of the world matrix.
     *
     * @returns A cloned copy of the world matrix
     */
    get worldMatrix(): MutableMatrix44;
    /**
     * Gets the internal world matrix (direct reference).
     *
     * @returns The internal world matrix
     */
    get worldMatrixInner(): MutableMatrix44;
    /**
     * Checks if the world matrix has been updated from its initial state.
     *
     * @returns True if the world matrix has been modified, false otherwise
     */
    get isWorldMatrixUpdated(): boolean;
    /**
     * Performs the logic update for skeletal animation.
     * Calculates joint transformations and updates bone data arrays based on the configured bone data type.
     * This method is called during the Logic processing stage.
     */
    $logic(): void;
    /**
     * Copies matrix data to the matrix array in a specific format.
     * Extracts the first 3 rows of a 4x4 matrix (Mat43 format) for efficient GPU storage.
     *
     * @param m - The source matrix to copy from
     * @param i - The index of the joint/bone
     * @private
     */
    private __copyToMatArray;
    /**
     * Gets the inverse bind matrices accessor.
     *
     * @returns The accessor containing inverse bind matrices, or undefined if not set
     */
    getInverseBindMatricesAccessor(): Accessor | undefined;
    /**
     * Performs a shallow copy from another SkeletalComponent.
     * Copies all relevant skeletal data without deep cloning complex objects.
     *
     * @param component_ - The source component to copy from
     * @protected
     */
    _shallowCopyFrom(component_: Component): void;
    /**
     * Gets the entity that owns this component.
     *
     * @returns The entity with skeletal capabilities that has this component
     */
    get entity(): ISkeletalEntity;
    /**
     * Destroys this component and cleans up resources.
     *
     * @protected
     */
    _destroy(): void;
    /**
     * Adds this component to an entity, extending it with skeletal functionality.
     * This method uses mixins to add skeletal-specific methods to the target entity.
     *
     * @param base - The target entity to extend
     * @param _componentClass - The component class being added
     * @returns The entity extended with skeletal component methods
     * @override
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBase, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBase;
    /**
     * Gets the inverse bind matrix for a specific joint.
     *
     * @param sg - The SceneGraphComponent representing the joint
     * @returns The inverse bind matrix for the specified joint
     * @private
     */
    _getInverseBindMatrices(sg: SceneGraphComponent): IMatrix44;
}

type MaterialNodeUID = number;
/**
 * Abstract base class for material content that provides common functionality for material rendering.
 * This class handles shader semantics, rendering setup, and GPU parameter management for materials.
 */
declare abstract class AbstractMaterialContent extends RnObject {
    protected __semantics: ShaderSemanticsInfo[];
    static materialNodes: AbstractMaterialContent[];
    protected __materialName: string;
    protected static __gl?: WebGLRenderingContext;
    protected __definitions: string;
    protected static __tmp_vector4: MutableVector4;
    protected static __tmp_vector2: MutableVector2;
    private __isMorphing;
    private __isSkinning;
    private __isLighting;
    private static __lightPositions;
    private static __lightDirections;
    private static __lightIntensities;
    private static __lightProperties;
    private static __materialContentCount;
    private __materialContentUid;
    private static __vertexShaderityObjectMap;
    private static __pixelShaderityObjectMap;
    private static __reflectedShaderSemanticsInfoArrayMap;
    shaderType: ShaderTypeEnum;
    private __materialSemanticsVariantName;
    /**
     * Constructs a new AbstractMaterialContent instance.
     * @param materialName - The unique name identifier for this material
     * @param options - Configuration options for the material
     * @param options.isMorphing - Whether this material supports morph target animation
     * @param options.isSkinning - Whether this material supports skeletal animation
     * @param options.isLighting - Whether this material supports lighting calculations
     * @param vertexShaderityObject - Optional vertex shader object
     * @param pixelShaderityObject - Optional pixel shader object
     */
    constructor(materialName: string, { isMorphing, isSkinning, isLighting }?: {
        isMorphing?: boolean | undefined;
        isSkinning?: boolean | undefined;
        isLighting?: boolean | undefined;
    }, vertexShaderityObject?: ShaderityObject, pixelShaderityObject?: ShaderityObject);
    /**
     * Sets the vertex shader object for this material.
     * @param vertexShaderityObject - The vertex shader object to set
     */
    protected setVertexShaderityObject(vertexShaderityObject?: ShaderityObject): void;
    /**
     * Sets the pixel shader object for this material.
     * @param pixelShaderityObject - The pixel shader object to set
     */
    protected setPixelShaderityObject(pixelShaderityObject?: ShaderityObject): void;
    /**
     * Generates a unique variant name for this material based on its shader semantics.
     * This name is used to differentiate materials with different semantic configurations.
     */
    makeMaterialSemanticsVariantName(): void;
    /**
     * Gets the material semantics variant name for this material.
     * @returns The unique variant name string
     */
    getMaterialSemanticsVariantName(): string;
    /**
     * Gets the vertex shader object associated with this material.
     * @returns The vertex shader object or undefined if not set
     */
    get vertexShaderityObject(): ShaderityObject | undefined;
    /**
     * Gets the pixel shader object associated with this material.
     * @returns The pixel shader object or undefined if not set
     */
    get pixelShaderityObject(): ShaderityObject | undefined;
    /**
     * Gets the shader definitions string for this material.
     * @returns The definitions string
     */
    getDefinitions(): string;
    /**
     * Retrieves a material node by its unique identifier.
     * @param materialNodeUid - The unique identifier of the material node
     * @returns The material node instance
     */
    static getMaterialNode(materialNodeUid: MaterialNodeUID): AbstractMaterialContent;
    /**
     * Gets the shader semantics information array for this material.
     * @returns Array of shader semantics information
     */
    get _semanticsInfoArray(): ShaderSemanticsInfo[];
    /**
     * Checks if this material supports skeletal animation.
     * @returns True if skinning is enabled
     */
    get isSkinning(): boolean;
    /**
     * Checks if this material supports morph target animation.
     * @returns True if morphing is enabled
     */
    get isMorphing(): boolean;
    /**
     * Checks if this material supports lighting calculations.
     * @returns True if lighting is enabled
     */
    get isLighting(): boolean;
    /**
     * Sets the shader semantics information array for this material.
     * @param shaderSemanticsInfoArray - Array of shader semantics information to set
     */
    setShaderSemanticsInfoArray(shaderSemanticsInfoArray: ShaderSemanticsInfo[]): void;
    /**
     * Sets up basic rendering information including matrices, camera, and lighting.
     * @param args - WebGL rendering arguments
     * @param shaderProgram - The WebGL shader program
     * @param firstTime - Whether this is the first time setup
     * @param material - The material instance
     * @param CameraComponentClass - The camera component class
     */
    protected setupBasicInfo(args: RenderingArgWebGL, shaderProgram: WebGLProgram, firstTime: boolean, material: Material, CameraComponentClass: typeof CameraComponent): void;
    /**
     * Sets the world transformation matrix uniform in the shader.
     * @param shaderProgram - The WebGL shader program
     * @param worldMatrix - The world transformation matrix
     */
    protected setWorldMatrix(shaderProgram: WebGLProgram, worldMatrix: Matrix44): void;
    /**
     * Sets the normal transformation matrix uniform in the shader.
     * @param shaderProgram - The WebGL shader program
     * @param normalMatrix - The normal transformation matrix
     */
    protected setNormalMatrix(shaderProgram: WebGLProgram, normalMatrix: IMatrix33): void;
    /**
     * Sets the billboard flag uniform in the shader.
     * @param shaderProgram - The WebGL shader program
     * @param isBillboard - Whether the object should be rendered as a billboard
     */
    protected setIsBillboard(shaderProgram: WebGLProgram, isBillboard: boolean): void;
    /**
     * Sets view-related uniforms including view matrix and camera position.
     * @param shaderProgram - The WebGL shader program
     * @param cameraComponent - The camera component
     * @param isVr - Whether rendering in VR mode
     * @param displayIdx - The display index for VR rendering
     */
    protected setViewInfo(shaderProgram: WebGLProgram, cameraComponent: CameraComponent, isVr: boolean, displayIdx: number): void;
    /**
     * Sets the projection matrix uniform in the shader.
     * @param shaderProgram - The WebGL shader program
     * @param cameraComponent - The camera component
     * @param isVr - Whether rendering in VR mode
     * @param displayIdx - The display index for VR rendering
     */
    protected setProjection(shaderProgram: WebGLProgram, cameraComponent: CameraComponent, isVr: boolean, displayIdx: number): void;
    /**
     * Sets skeletal animation uniforms in the shader.
     * @param shaderProgram - The WebGL shader program
     * @param setUniform - Whether to set uniform values
     * @param skeletalComponent - The skeletal component containing bone data
     */
    protected setSkinning(shaderProgram: WebGLProgram, setUniform: boolean, skeletalComponent?: SkeletalComponent): void;
    /**
     * Sets lighting information uniforms in the shader.
     * @param shaderProgram - The WebGL shader program
     * @param lightComponents - Array of light components
     * @param material - The material instance
     * @param setUniform - Whether to set uniform values
     */
    protected setLightsInfo(shaderProgram: WebGLProgram, lightComponents: LightComponent[], _material: Material, setUniform: boolean): void;
    /**
     * Sets morph target animation uniforms in the shader.
     * @param shaderProgram - The WebGL shader program
     * @param meshComponent - The mesh component
     * @param primitive - The primitive containing morph targets
     * @param blendShapeComponent - The blend shape component containing weights
     */
    setMorphInfo(shaderProgram: WebGLProgram, _meshComponent: MeshComponent, primitive: Primitive, blendShapeComponent?: BlendShapeComponent): void;
    /**
     * Sets internal setting parameters to GPU for WebGL per shader program.
     * This method should be overridden by derived classes to provide specific parameter handling.
     * @param params - Object containing material, shader program, firstTime flag, and rendering arguments
     */
    _setInternalSettingParametersToGpuWebGLPerShaderProgram(_params: {}): void;
    /**
     * Sets internal setting parameters to GPU for WebGL per material.
     * This method should be overridden by derived classes to provide specific parameter handling.
     * @param params - Object containing material, shader program, firstTime flag, and rendering arguments
     */
    _setInternalSettingParametersToGpuWebGLPerMaterial(_params: {}): void;
    /**
     * Sets internal setting parameters to GPU for WebGL per primitive.
     * This method should be overridden by derived classes to provide specific parameter handling.
     * @param params - Object containing material, shader program, firstTime flag, and rendering arguments
     */
    _setInternalSettingParametersToGpuWebGLPerPrimitive(_params: {}): void;
    /**
     * Sets internal setting parameters to GPU for WebGPU.
     * This method should be overridden by derived classes to provide specific parameter handling.
     * @param params - Object containing material and WebGPU rendering arguments
     */
    _setInternalSettingParametersToGpuWebGpu(_params: {}): void;
    /**
     * Gets the shader definition string for this material.
     * This method should be overridden by derived classes to provide specific definitions.
     * @returns Empty string by default
     */
    getDefinition(): string;
    /**
     * Performs shader reflection to extract semantics information from vertex and pixel shaders.
     * @param vertexShader - The vertex shader object for WebGL
     * @param pixelShader - The pixel shader object for WebGL
     * @param vertexShaderWebGpu - The vertex shader object for WebGPU
     * @param pixelShaderWebGpu - The pixel shader object for WebGPU
     * @param definitions - Array of shader definitions
     * @returns Array of shader semantics information
     */
    protected doShaderReflection(vertexShader: ShaderityObject, pixelShader: ShaderityObject, vertexShaderWebGpu: ShaderityObject, pixelShaderWebGpu: ShaderityObject, definitions: string[]): ShaderSemanticsInfo[];
}

type MaterialTypeName = string;
type ShaderVariable = {
    value: any;
    info: ShaderSemanticsInfo;
};

/**
 * The Material class represents a material definition for 3D rendering in the Rhodonite engine.
 *
 * A material defines how a 3D object's surface appears when rendered, including:
 * - Shader programs and their parameters
 * - Texture bindings and sampling configurations
 * - Blending and transparency settings
 * - Rendering state configuration (culling, depth testing, etc.)
 *
 * ## Key Features:
 * - **Shader Management**: Automatically compiles and caches shader programs per primitive
 * - **Parameter Binding**: Supports both static and animated shader parameters
 * - **Texture Handling**: Manages texture bindings with customizable samplers
 * - **Blending Control**: Fine-grained control over alpha blending operations
 * - **Multi-API Support**: Compatible with both WebGL and WebGPU rendering backends
 * - **Performance Optimization**: Fingerprint-based caching and state versioning
 *
 * ## Material Types:
 * Materials are categorized by type (e.g., PBR, Phong, Custom) and can support:
 * - Skinning animations for skeletal meshes
 * - Morphing animations for vertex-based deformations
 * - Lighting calculations with various models
 *
 * ## Usage Examples:
 * ```typescript
 * // Set a basic parameter
 * material.setParameter('baseColorFactor', [1.0, 0.5, 0.0, 1.0]);
 *
 * // Assign a texture with custom sampler
 * const sampler = new Sampler({ magFilter: TextureParameter.Linear });
 * material.setTextureParameter('baseColorTexture', texture, sampler);
 *
 * // Configure blending for transparency
 * material.alphaMode = AlphaMode.Blend;
 * material.setBlendFuncFactor(Blend.SrcAlpha, Blend.OneMinusSrcAlpha);
 * ```
 *
 * ## State Management:
 * The material maintains internal state versioning for efficient change detection
 * and shader program invalidation when parameters change.
 *
 * @see {@link AbstractMaterialContent} for material-specific implementations
 * @see {@link AlphaMode} for transparency configuration options
 * @see {@link Primitive} for geometry that uses materials
 */
declare class Material extends RnObject {
    __materialTypeName: MaterialTypeName;
    _materialContent: AbstractMaterialContent;
    _allFieldVariables: Map<ShaderSemanticsName, ShaderVariable>;
    _autoFieldVariablesOnly: Map<ShaderSemanticsName, ShaderVariable>;
    _autoTextureFieldVariablesOnly: Map<ShaderSemanticsName, ShaderVariable>;
    _autoUniformFieldVariablesOnly: Map<ShaderSemanticsName, ShaderVariable>;
    _allFieldsInfo: Map<ShaderSemanticsName, ShaderSemanticsInfo>;
    private __belongPrimitives;
    private _shaderProgramUidMap;
    __materialUid: MaterialUID;
    private __materialTid;
    __materialSid: MaterialSID;
    private __alphaMode;
    zWriteWhenBlend: boolean;
    colorWriteMask: boolean[];
    isTranslucent: boolean;
    cullFace: boolean;
    cullFrontFaceCCW: boolean;
    cullFaceBack: boolean;
    private __alphaToCoverage;
    private __blendEquationMode;
    private __blendEquationModeAlpha;
    private __blendFuncSrcFactor;
    private __blendFuncDstFactor;
    private __blendFuncAlphaSrcFactor;
    private __blendFuncAlphaDstFactor;
    private __stateVersion;
    private static __stateVersion;
    private __fingerPrint;
    private __shaderDefines;
    private static __webglResourceRepository?;
    private static __defaultSampler;
    static _soloDatumFields: Map<MaterialTypeName, Map<ShaderSemanticsName, ShaderVariable>>;
    /**
     * Creates a new Material instance.
     * @param materialTid - The material type ID
     * @param materialUid - The unique material ID
     * @param materialSid - The material serial ID within the material type
     * @param materialTypeName - The name of the material type
     * @param materialNode - The abstract material content associated with this material
     */
    constructor(materialTid: Index, materialUid: MaterialUID, materialSid: MaterialSID, materialTypeName: string, materialNode: AbstractMaterialContent);
    /**
     * Adds a shader define directive that will be included in shader compilation.
     * This will invalidate existing shaders and require recompilation.
     * @param define - The define directive to add (e.g., "USE_NORMAL_MAPPING")
     */
    addShaderDefine(define: string): void;
    /**
     * Removes a shader define directive from the material.
     * This will invalidate existing shaders and require recompilation.
     * @param define - The define directive to remove
     */
    removeShaderDefine(define: string): void;
    /**
     * Gets all shader define directives currently set on this material.
     * @returns A Set containing all shader defines
     */
    getShaderDefines(): Set<string>;
    /**
     * Checks if a specific shader define directive is set on this material.
     * @param define - The define directive to check for
     * @returns True if the define is set, false otherwise
     */
    isShaderDefine(define: string): boolean;
    /**
     * Calculates and updates the material's fingerprint based on current state.
     * The fingerprint is used for shader program caching and state comparison.
     * @internal
     */
    calcFingerPrint(): void;
    /**
     * Gets the current fingerprint of the material.
     * @returns The material's fingerprint string
     * @internal
     */
    _getFingerPrint(): string;
    /**
     * Gets the global state version for all materials.
     * This is incremented whenever any material's state changes.
     * @returns The global state version number
     */
    static get stateVersion(): number;
    /**
     * Checks if a value is an animated value (implements IAnimatedValue).
     * @param value - The value to check
     * @returns True if the value is an animated value, false otherwise
     */
    _isAnimatedValue(value: any): value is IAnimatedValue;
    /**
     * Sets a parameter value for the specified shader semantic.
     * The parameter can be a static value or an animated value.
     * @param shaderSemanticName - The shader semantic name to set the parameter for
     * @param value - The value to set (can be static or animated)
     */
    setParameter(shaderSemanticName: ShaderSemanticsName, value: any): void;
    /**
     * Sets a texture parameter for the specified shader semantic.
     * If the texture has transparency, the material's alpha mode may be automatically set to Blend.
     * @param shaderSemantic - The shader semantic name for the texture
     * @param texture - The texture to assign
     * @param sampler - Optional sampler to use with the texture. If not provided, uses default sampler
     */
    setTextureParameter(shaderSemantic: ShaderSemanticsName, texture: AbstractTexture, sampler?: Sampler): void;
    /**
     * Gets the texture parameter for the specified shader semantic.
     * @param shaderSemantic - The shader semantic name to get the texture for
     * @returns The texture parameter array or undefined if not found
     */
    getTextureParameter(shaderSemantic: ShaderSemanticsName): any;
    /**
     * Sets a texture parameter from a Promise that resolves to a texture.
     * This is useful for asynchronous texture loading.
     * @param shaderSemantic - The shader semantic name for the texture
     * @param promise - A Promise that resolves to the texture
     */
    setTextureParameterAsPromise(shaderSemantic: ShaderSemanticsName, promise: Promise<AbstractTexture>): void;
    /**
     * Gets the parameter value for the specified shader semantic.
     * @param shaderSemantic - The shader semantic name to get the parameter for
     * @returns The parameter value or undefined if not found
     */
    getParameter(shaderSemantic: ShaderSemanticsName): any;
    /**
     * Checks if the shader program is ready for the given primitive.
     * @param primitive - The primitive to check shader readiness for
     * @returns True if the shader program is ready, false otherwise
     */
    isShaderProgramReady(primitive: Primitive): boolean;
    /**
     * Sets up uniform locations for material nodes in the shader program.
     * @internal Called from WebGLStrategyDataTexture and WebGLStrategyUniform only
     * @param isUniformOnlyMode - Whether to operate in uniform-only mode
     * @param primitive - The primitive to set up uniforms for
     */
    _setUniformLocationsOfMaterialNodes(isUniformOnlyMode: boolean, primitive: Primitive): void;
    /**
     * Gets the shader program UID for the given primitive.
     * @param primitive - The primitive to get the shader program UID for
     * @returns The shader program UID or -1 if not found
     */
    getShaderProgramUid(primitive: Primitive): CGAPIResourceHandle;
    /**
     * Adds a primitive to the list of primitives that belong to this material.
     * @internal Called from Primitive class only
     * @param primitive - The primitive to add
     */
    _addBelongPrimitive(primitive: Primitive): void;
    /**
     * Gets all primitives that belong to this material.
     * @returns A Map of primitive UIDs to Primitive objects
     */
    getBelongPrimitives(): Map<number, Primitive>;
    /**
     * Creates a WebGL shader program for this material and the given primitive.
     * @internal Called from WebGLStrategyDataTexture and WebGLStrategyUniform
     * @param vertexShaderMethodDefinitions_uniform - Vertex shader method definitions for uniforms
     * @param propertySetter - Function to set shader properties
     * @param primitive - The primitive to create the program for
     * @param isWebGL2 - Whether to create a WebGL2 program
     * @returns A tuple containing the program UID and whether it's a new program
     */
    _createProgramWebGL(vertexShaderMethodDefinitions_uniform: string, propertySetter: getShaderPropertyFunc, primitive: Primitive, isWebGL2: boolean): [CGAPIResourceHandle, boolean];
    /**
     * Creates a WebGPU shader program for this material and the given primitive.
     * @param primitive - The primitive to create the program for
     * @param vertexShaderMethodDefinitions - Vertex shader method definitions
     * @param propertySetter - Function to set shader properties
     */
    _createProgramWebGpu(primitive: Primitive, vertexShaderMethodDefinitions: string, propertySetter: getShaderPropertyFunc): void;
    /**
     * Creates a shader program using updated shader source code.
     * @internal Called from WebGLStrategyDataTexture and WebGLStrategyUniform
     * @param updatedShaderSources - The updated shader source code
     * @param primitive - The primitive to create the program for
     * @param onError - Optional error callback function
     * @returns A tuple containing the program UID and whether it's a new program
     */
    _createProgramByUpdatedSources(updatedShaderSources: ShaderSources, primitive: Primitive, onError?: (message: string) => void): [CGAPIResourceHandle, boolean];
    /**
     * Sets up basic uniform locations in the shader program.
     * @internal Called by WebGLStrategyDataTexture and WebGLStrategyUniform only
     * @param primitive - The primitive to set up uniforms for
     */
    _setupBasicUniformsLocations(primitive: Primitive): void;
    /**
     * Sets up additional uniform locations in the shader program.
     * @internal Called by WebGLStrategyDataTexture and WebGLStrategyUniform only
     * @param shaderSemantics - Array of shader semantics to set up
     * @param isUniformOnlyMode - Whether to operate in uniform-only mode
     * @param primitive - The primitive to set up uniforms for
     */
    _setupAdditionalUniformLocations(shaderSemantics: ShaderSemanticsInfo[], isUniformOnlyMode: boolean, primitive: Primitive): void;
    /**
     * Sets internal setting parameters to GPU for WebGPU rendering.
     * @param params - Object containing material and rendering arguments
     */
    _setInternalSettingParametersToGpuWebGpu({ material, args, }: {
        material: Material;
        args: RenderingArgWebGpu;
    }): void;
    /**
     * Sets parameters to GPU for WebGL rendering per material.
     * @internal Called from WebGLStrategyDataTexture and WebGLStrategyUniform only
     * @param params - Object containing rendering parameters
     */
    _setParametersToGpuWebGL({ material, shaderProgram, firstTime, args, }: {
        material: Material;
        shaderProgram: WebGLProgram;
        firstTime: boolean;
        args: RenderingArgWebGL;
    }): void;
    /**
     * Sets parameters to GPU for WebGL rendering per shader program.
     * @param params - Object containing rendering parameters
     */
    _setParametersToGpuWebGLPerShaderProgram({ material, shaderProgram, firstTime, args, }: {
        material: Material;
        shaderProgram: WebGLProgram;
        firstTime: boolean;
        args: RenderingArgWebGL;
    }): void;
    /**
     * Sets parameters to GPU for WebGL rendering per primitive.
     * @param params - Object containing rendering parameters
     */
    _setParametersToGpuWebGLPerPrimitive({ material, shaderProgram, firstTime, args, }: {
        material: Material;
        shaderProgram: WebGLProgram;
        firstTime: boolean;
        args: RenderingArgWebGL;
    }): void;
    /**
     * Sets parameters to GPU for WebGL rendering without internal settings.
     * @param params - Object containing rendering parameters
     */
    _setParametersToGpuWebGLWithOutInternalSetting({ shaderProgram, firstTime, isUniformMode, }: {
        shaderProgram: WebGLProgram;
        firstTime: boolean;
        isUniformMode: boolean;
    }): void;
    /**
     * Gets shader property strings for vertex and pixel shaders.
     * @internal
     * @param propertySetter - Function to set shader properties
     * @param isWebGL2 - Whether to generate WebGL2-compatible properties
     * @returns Object containing vertex and pixel property strings
     */
    _getProperties(propertySetter: getShaderPropertyFunc, isWebGL2: boolean): {
        vertexPropertiesStr: string;
        pixelPropertiesStr: string;
    };
    /**
     * Sets automatic parameters to GPU for WebGL rendering.
     * @private
     * @param isUniformMode - Whether to operate in uniform mode
     * @param firstTime - Whether this is the first time setting parameters
     * @param shaderProgram - The WebGL shader program
     */
    private __setAutoParametersToGpuWebGL;
    /**
     * Sets solo datum parameters to GPU for WebGL rendering.
     * @private
     * @param params - Object containing rendering parameters
     */
    private __setSoloDatumParametersToGpuWebGL;
    /**
     * Sets the blend equation mode for blending operations.
     * This method only works if the alpha mode is set to blend.
     * @param blendEquationMode - The blend equation mode (e.g., gl.FUNC_ADD)
     * @param blendEquationModeAlpha - Optional separate blend equation mode for alpha channel
     */
    setBlendEquationMode(blendEquationMode: BlendEnum, blendEquationModeAlpha?: BlendEnum): void;
    /**
     * Handles special cases for Min/Max blend equations due to WebGPU limitations.
     * @private
     */
    private __treatForMinMax;
    /**
     * Sets separate blend function factors for RGB and alpha channels.
     * This method only works if the alpha mode is set to blend.
     * @param blendFuncSrcFactor - Source blend factor for RGB
     * @param blendFuncDstFactor - Destination blend factor for RGB
     * @param blendFuncAlphaSrcFactor - Source blend factor for alpha
     * @param blendFuncAlphaDstFactor - Destination blend factor for alpha
     */
    setBlendFuncSeparateFactor(blendFuncSrcFactor: BlendEnum, blendFuncDstFactor: BlendEnum, blendFuncAlphaSrcFactor: BlendEnum, blendFuncAlphaDstFactor: BlendEnum): void;
    /**
     * Sets blend function factors for both RGB and alpha channels.
     * This method only works if the alpha mode is set to blend.
     * @param blendFuncSrcFactor - Source blend factor
     * @param blendFuncDstFactor - Destination blend factor
     */
    setBlendFuncFactor(blendFuncSrcFactor: BlendEnum, blendFuncDstFactor: BlendEnum): void;
    /**
     * Checks if the material is in blend mode.
     * @returns True if alpha mode is Blend, false otherwise
     */
    isBlend(): boolean;
    /**
     * Checks if the material is translucent but not in blend mode.
     * @returns True if alpha mode is Opaque or Mask and the material is translucent
     */
    isTranslucentOpaque(): boolean;
    /**
     * Checks if the material is either in blend mode or translucent.
     * @returns True if in blend mode or translucent, false otherwise
     */
    isBlendOrTranslucent(): boolean;
    /**
     * Checks if the material is in opaque mode.
     * @returns True if alpha mode is Opaque, false otherwise
     */
    isOpaque(): boolean;
    /**
     * Checks if the material is in mask mode.
     * @returns True if alpha mode is Mask, false otherwise
     */
    isMask(): boolean;
    /**
     * Sets whether alpha-to-coverage is enabled for this material.
     * NOTE: To apply alpha-to-coverage, the output alpha value must not be fixed to a constant value.
     * However, some shaders in Rhodonite fix the output alpha value to 1 by setAlphaIfNotInAlphaBlendMode.
     * The shader needs to be improved to properly use alpha-to-coverage.
     * @param alphaToCoverage - Whether to apply alpha-to-coverage to this material
     */
    set alphaToCoverage(alphaToCoverage: boolean);
    /**
     * Gets whether alpha-to-coverage is enabled for this material.
     * @returns True if alpha-to-coverage is enabled, false otherwise
     */
    get alphaToCoverage(): boolean;
    /**
     * Gets the material type ID.
     * @returns The material type ID
     */
    get materialTID(): MaterialTID;
    /**
     * Gets an array of all field information for this material.
     * @returns Array of shader semantics information
     */
    get fieldsInfoArray(): ShaderSemanticsInfo[];
    /**
     * Gets the blend equation mode for RGB channels.
     * @returns The blend equation mode
     */
    get blendEquationMode(): BlendEnum;
    /**
     * Gets the blend equation mode for the alpha channel.
     * @returns The alpha blend equation mode
     */
    get blendEquationModeAlpha(): BlendEnum;
    /**
     * Gets the source blend factor for RGB channels.
     * @returns The source blend factor
     */
    get blendFuncSrcFactor(): BlendEnum;
    /**
     * Gets the destination blend factor for RGB channels.
     * @returns The destination blend factor
     */
    get blendFuncDstFactor(): BlendEnum;
    /**
     * Gets the source blend factor for the alpha channel.
     * @returns The alpha source blend factor
     */
    get blendFuncAlphaSrcFactor(): BlendEnum;
    /**
     * Gets the destination blend factor for the alpha channel.
     * @returns The alpha destination blend factor
     */
    get blendFuncAlphaDstFactor(): BlendEnum;
    /**
     * Gets the current alpha mode of the material.
     * @returns The alpha mode
     */
    get alphaMode(): AlphaModeEnum;
    /**
     * Sets the alpha mode of the material.
     * This will invalidate shaders and recalculate the fingerprint.
     * @param mode - The alpha mode to set
     */
    set alphaMode(mode: AlphaModeEnum);
    /**
     * Gets the unique material ID.
     * @returns The material UID
     */
    get materialUID(): MaterialUID;
    /**
     * Gets the material serial ID within the material type.
     * @returns The material SID
     */
    get materialSID(): MaterialSID;
    /**
     * Checks if this material supports skinning.
     * @returns True if skinning is supported, false otherwise
     */
    get isSkinning(): boolean;
    /**
     * Checks if this material supports morphing.
     * @returns True if morphing is supported, false otherwise
     */
    get isMorphing(): boolean;
    /**
     * Checks if this material supports lighting.
     * @returns True if lighting is supported, false otherwise
     */
    get isLighting(): boolean;
    /**
     * Gets the material type name.
     * @returns The material type name
     */
    get materialTypeName(): string;
    /**
     * Gets the current state version of this material.
     * This is incremented whenever the material's state changes.
     * @returns The state version number
     */
    get stateVersion(): number;
    /**
     * Invalidates all shader programs associated with this material.
     * This forces shader recompilation on the next render.
     */
    makeShadersInvalidate(): void;
}

/**
 * A cube texture that can be used as a render target for rendering operations.
 * This class extends AbstractTexture and implements IRenderable to provide
 * cube map rendering capabilities with support for multiple mip levels.
 *
 * @example
 * ```typescript
 * const cubeTexture = new RenderTargetTextureCube();
 * cubeTexture.create({
 *   width: 512,
 *   height: 512,
 *   format: TextureFormat.RGBA8
 * });
 * ```
 */
declare class RenderTargetTextureCube extends AbstractTexture implements IRenderable {
    private __fbo?;
    hdriFormat: EnumIO;
    _textureViewAsRenderTargetResourceUid: number;
    /**
     * Creates and initializes the cube render target texture with the specified parameters.
     * This method sets up the internal texture resources and calculates mip levels if not provided.
     *
     * @param params - Configuration object for texture creation
     * @param params.width - Width of each cube face in pixels
     * @param params.height - Height of each cube face in pixels (should equal width for proper cube)
     * @param params.mipLevelCount - Optional number of mip levels. If not provided, calculates automatically
     * @param params.format - Internal texture format to use
     *
     * @example
     * ```typescript
     * cubeTexture.create({
     *   width: 1024,
     *   height: 1024,
     *   mipLevelCount: 10,
     *   format: TextureFormat.RGBA16F
     * });
     * ```
     */
    create({ width, height, mipLevelCount, format: internalFormat, }: {
        width: number;
        height: number;
        mipLevelCount?: number;
        format: TextureFormatEnum;
    }): void;
    /**
     * Creates the underlying 3D API texture resources for the cube render target.
     * This method handles both WebGL and WebGPU resource creation and sets up
     * appropriate texture views for rendering operations.
     *
     * @private
     */
    private __createRenderTargetTexture;
    /**
     * Generates mipmaps for the cube texture using the graphics API.
     * This method creates a complete mipmap chain for all faces of the cube texture,
     * which is useful for proper filtering and rendering quality.
     *
     * @remarks
     * This operation should be called after rendering to the base level (mip 0)
     * to ensure proper mipmap generation from the rendered content.
     */
    generateMipmaps(): void;
    /**
     * Resizes the cube texture to new dimensions.
     * This method destroys the current texture resources and recreates them
     * with the specified width and height.
     *
     * @param width - New width for each cube face in pixels
     * @param height - New height for each cube face in pixels
     *
     * @remarks
     * All existing texture content will be lost during the resize operation.
     * The mip level count will be recalculated based on the new dimensions.
     */
    resize(width: Size, height: Size): void;
    /**
     * Destroys all 3D API resources associated with this texture.
     * This method releases GPU memory and invalidates the texture resource UID.
     *
     * @returns Always returns true to indicate successful cleanup
     *
     * @remarks
     * After calling this method, the texture cannot be used until recreated.
     * This is automatically called during resize operations.
     */
    destroy3DAPIResources(): boolean;
    /**
     * Creates a texture view for a specific cube face and mip level that can be used as a render target.
     * This method is WebGPU-specific and allows rendering to individual faces of the cube texture.
     *
     * @param faceIdx - Index of the cube face (0-5: +X, -X, +Y, -Y, +Z, -Z)
     * @param mipLevel - Mip level to create the view for (0 = base level)
     *
     * @remarks
     * This method only works when using the WebGPU rendering backend.
     * For WebGL, face-specific rendering is handled differently through framebuffer operations.
     */
    createCubeTextureViewAsRenderTarget(faceIdx: Index, mipLevel: Index): void;
    /**
     * Sets the framebuffer object associated with this render target texture.
     *
     * @param fbo - The framebuffer object to associate with this texture
     *
     * @internal
     */
    set _fbo(fbo: FrameBuffer);
    /**
     * Gets the framebuffer object associated with this render target texture.
     *
     * @returns The associated framebuffer object, or undefined if none is set
     */
    get fbo(): FrameBuffer | undefined;
    /**
     * Gets the number of mip levels in this cube texture.
     *
     * @returns The total number of mip levels, including the base level
     */
    get mipmapLevelNumber(): number;
    /**
     * Marks the texture as ready for use.
     * This method sets the internal ready state flag to indicate that
     * the texture has been properly initialized and can be used for rendering.
     *
     * @remarks
     * This is typically called internally after successful texture creation
     * and resource allocation.
     */
    setIsTextureReady(): void;
}

/**
 * A wrapper class for WebGPU device management and canvas context configuration.
 * This class encapsulates the WebGPU adapter, device, and canvas context,
 * providing a convenient interface for WebGPU rendering operations.
 */
declare class WebGpuDeviceWrapper {
    private __canvas;
    private __gpuAdapter;
    private __gpuDevice;
    private __context;
    /**
     * Creates a new WebGpuDeviceWrapper instance.
     * Initializes the WebGPU context and configures the canvas with the provided device.
     *
     * @param canvas - The HTML canvas element to be used for WebGPU rendering
     * @param gpuAdapter - The WebGPU adapter for the graphics hardware
     * @param gpuDevice - The WebGPU device for executing GPU operations
     */
    constructor(canvas: HTMLCanvasElement, gpuAdapter: GPUAdapter, gpuDevice: GPUDevice);
    /**
     * Gets the HTML canvas element associated with this wrapper.
     *
     * @returns The canvas element used for WebGPU rendering
     */
    get canvas(): HTMLCanvasElement;
    /**
     * Gets the WebGPU adapter associated with this wrapper.
     *
     * @returns The WebGPU adapter representing the graphics hardware
     */
    get gpuAdapter(): GPUAdapter;
    /**
     * Gets the WebGPU device associated with this wrapper.
     *
     * @returns The WebGPU device for executing GPU operations
     */
    get gpuDevice(): GPUDevice;
    /**
     * Gets the WebGPU canvas context associated with this wrapper.
     *
     * @returns The configured WebGPU canvas context for rendering
     */
    get context(): GPUCanvasContext;
}

type WebGpuResource = GPUTexture | GPUBuffer | GPUSampler | GPUTextureView | GPUBufferBinding | GPURenderPipeline | GPUComputePipeline | GPUBindGroupLayout | GPUBindGroup | GPUShaderModule | GPUCommandEncoder | GPUComputePassEncoder | GPURenderPassEncoder | GPUComputePipeline | GPURenderPipeline | GPUQuerySet | object;
type DRAW_PARAMETERS_IDENTIFIER = string;
/**
 * WebGPU Resource Repository that manages WebGPU resources and provides rendering functionality.
 * This class serves as a central hub for creating, managing, and utilizing WebGPU resources
 * such as textures, buffers, pipelines, and render passes.
 *
 * @extends CGAPIResourceRepository
 * @implements ICGAPIResourceRepository
 */
declare class WebGpuResourceRepository extends CGAPIResourceRepository implements ICGAPIResourceRepository {
    private static __instance;
    private __webGpuResources;
    private __resourceCounter;
    private __webGpuDeviceWrapper?;
    private __storageBuffer?;
    private __storageBlendShapeBuffer?;
    private __bindGroupStorageBuffer?;
    private __bindGroupLayoutStorageBuffer?;
    private __webGpuRenderPipelineMap;
    private __materialStateVersionMap;
    private __bindGroupTextureMap;
    private __bindGroupLayoutTextureMap;
    private __bindGroupSamplerMap;
    private __bindGroupLayoutSamplerMap;
    private __bindGroupsUniformDrawParameters;
    private __bindGroupLayoutUniformDrawParameters?;
    private __uniformDrawParametersBuffers;
    private __commandEncoder?;
    private __renderBundles;
    private __renderBundleEncoder?;
    private __systemDepthTexture?;
    private __systemDepthTextureView?;
    private __uniformMorphOffsetsBuffer?;
    private __uniformMorphWeightsBuffer?;
    private __renderPassEncoder?;
    private __generateMipmapsShaderModule?;
    private __generateMipmapsPipeline?;
    private __generateMipmapsFormat?;
    private __generateMipmapsSampler?;
    private __generateMipmapsBindGroupLayout?;
    private __contextCurrentTextureView?;
    private __lastMaterialsUpdateCount;
    private __lastCurrentCameraComponentSid;
    private __lastEntityRepositoryUpdateCount;
    private __lastPrimitivesMaterialVariantUpdateCount;
    private __lastMeshRendererComponentsUpdateCount;
    private __srcTextureViewsForGeneratingMipmaps;
    private __dstTextureViewsForGeneratingMipmaps;
    private __bindGroupsForGeneratingMipmaps;
    private static __drawParametersUint32Array;
    private constructor();
    /**
     * Clears all cached resources including render pipelines, bind groups, and render bundles.
     * This method should be called when resources need to be recreated or when the rendering context changes.
     */
    clearCache(): void;
    /**
     * Adds a WebGPU device wrapper to the repository and initializes the command encoder.
     * This must be called before using any WebGPU functionality.
     *
     * @param webGpuDeviceWrapper - The WebGPU device wrapper containing the device and context
     */
    addWebGpuDeviceWrapper(webGpuDeviceWrapper: WebGpuDeviceWrapper): void;
    /**
     * Returns the WebGPU device wrapper instance.
     *
     * @returns The WebGPU device wrapper
     * @throws Error if the device wrapper has not been initialized
     */
    getWebGpuDeviceWrapper(): WebGpuDeviceWrapper;
    /**
     * Returns the singleton instance of WebGpuResourceRepository.
     * Creates a new instance if one doesn't exist.
     *
     * @returns The singleton instance
     */
    static getInstance(): WebGpuResourceRepository;
    /**
     * Generates a unique resource number for tracking WebGPU resources.
     *
     * @returns A unique resource handle number
     */
    private getResourceNumber;
    /**
     * Registers a WebGPU resource and assigns it a unique handle.
     *
     * @param obj - The WebGPU resource to register
     * @returns The unique handle for the registered resource
     */
    private __registerResource;
    /**
     * Gets the current canvas size as a tuple of width and height.
     *
     * @returns A tuple containing [width, height] of the canvas
     */
    getCanvasSize(): [Size, Size];
    /**
     * Creates a WebGPU texture from ImageBitmap data with specified parameters.
     * This method handles texture creation, data upload, and optional mipmap generation.
     *
     * @param imageData - The ImageBitmap data to create the texture from
     * @param params - Configuration object containing texture parameters
     * @param params.level - Mipmap level (typically 0 for base level)
     * @param params.internalFormat - Internal format of the texture
     * @param params.width - Width of the texture in pixels
     * @param params.height - Height of the texture in pixels
     * @param params.border - Border width (must be 0 for WebGPU)
     * @param params.format - Pixel format of the source data
     * @param params.type - Component type of the source data
     * @param params.generateMipmap - Whether to generate mipmaps automatically
     * @returns Promise that resolves to the texture resource handle
     */
    createTextureFromImageBitmapData(imageData: ImageBitmapData, { internalFormat, width, height, generateMipmap, }: {
        internalFormat: TextureParameterEnum;
        width: Size;
        height: Size;
        generateMipmap: boolean;
    }): Promise<WebGPUResourceHandle>;
    /**
     * Creates a WebGPU texture from a data URI string.
     * This method loads the image from the data URI and creates a texture from it.
     *
     * @param dataUri - The data URI string containing the image data
     * @param params - Configuration object containing texture parameters
     * @param params.internalFormat - Internal format of the texture
     * @param params.generateMipmap - Whether to generate mipmaps automatically
     * @returns Promise that resolves to the texture resource handle
     */
    createTextureFromDataUri(dataUri: string, { internalFormat, generateMipmap, }: {
        internalFormat: TextureParameterEnum;
        generateMipmap: boolean;
    }): Promise<WebGPUResourceHandle>;
    /**
     * Generates mipmaps for a 2D texture using the specified dimensions.
     * This method creates all mipmap levels from the base texture.
     *
     * @param textureHandle - Handle to the texture resource
     * @param width - Width of the base texture level
     * @param height - Height of the base texture level
     */
    generateMipmaps2d(textureHandle: WebGPUResourceHandle, width: number, height: number): void;
    /**
     * Generates mipmaps for a cube texture using the specified dimensions.
     * This method creates all mipmap levels for all 6 faces of the cube texture.
     *
     * @param textureHandle - Handle to the cube texture resource
     * @param width - Width of the base texture level
     * @param height - Height of the base texture level
     */
    generateMipmapsCube(textureHandle: WebGPUResourceHandle, width: number, height: number): void;
    /**
     * Reads pixel data from a texture and returns it as a Uint8Array.
     * This method is useful for debugging or post-processing texture data.
     *
     * @param textureHandle - Handle to the texture resource
     * @param width - Width of the texture region to read
     * @param height - Height of the texture region to read
     * @param frameBufferUid - Handle to the framebuffer (if applicable)
     * @param colorAttachmentIndex - Index of the color attachment to read from
     * @returns Promise that resolves to the pixel data as Uint8Array
     */
    getTexturePixelData(textureHandle: WebGPUResourceHandle, width: number, height: number, _frameBufferUid: WebGPUResourceHandle, _colorAttachmentIndex: number): Promise<Uint8Array>;
    /**
     * Generates mipmaps for a texture using render passes (including CubeMap support).
     * This is an optimized method adapted from WebGPU best practices that uses
     * a custom shader to generate each mipmap level from the previous one.
     *
     * @remarks
     * Adapted from: https://toji.dev/webgpu-best-practices/img-textures#generating-mipmaps
     * @param texture - The GPU texture to generate mipmaps for
     * @param textureDescriptor - Descriptor containing texture format and dimensions
     */
    generateMipmaps(texture: GPUTexture, textureDescriptor: GPUTextureDescriptor): void;
    /**
     * Creates a texture sampler with the specified filtering and wrapping parameters.
     * The sampler defines how textures are filtered and wrapped when accessed in shaders.
     *
     * @param params - Configuration object for the sampler
     * @param params.magFilter - Magnification filter mode
     * @param params.minFilter - Minification filter mode
     * @param params.wrapS - Wrapping mode for S (U) texture coordinate
     * @param params.wrapT - Wrapping mode for T (V) texture coordinate
     * @param params.wrapR - Wrapping mode for R (W) texture coordinate
     * @param params.anisotropy - Whether to enable anisotropic filtering
     * @returns Handle to the created sampler resource
     */
    createTextureSampler({ magFilter, minFilter, wrapS, wrapT, wrapR, anisotropy, }: {
        magFilter: TextureParameterEnum;
        minFilter: TextureParameterEnum;
        wrapS: TextureParameterEnum;
        wrapT: TextureParameterEnum;
        wrapR: TextureParameterEnum;
        anisotropy: boolean;
    }): WebGPUResourceHandle;
    /**
     * Creates a WebGPU vertex buffer from an accessor containing vertex data.
     * The buffer is created with the appropriate size and the data is uploaded immediately.
     *
     * @param accessor - Accessor containing the vertex data to upload
     * @returns Handle to the created vertex buffer
     */
    createVertexBuffer(accessor: Accessor): WebGPUResourceHandle;
    /**
     * Creates a WebGPU vertex buffer from a typed array.
     * This is a more direct method when you have raw typed array data.
     *
     * @param typedArray - The typed array containing vertex data
     * @returns Handle to the created vertex buffer resource
     */
    createVertexBufferFromTypedArray(typedArray: TypedArray): WebGPUResourceHandle;
    /**
     * Creates a WebGPU index buffer from an accessor containing index data.
     * Automatically converts UnsignedByte indices to UnsignedShort since WebGPU
     * doesn't support 8-bit index buffers.
     *
     * @param accessor - Accessor containing the index data to upload
     * @returns Handle to the created index buffer resource
     */
    createIndexBuffer(accessor: Accessor): WebGPUResourceHandle;
    /**
     * Updates the data in an existing vertex buffer with new data from an accessor.
     * This method maps the buffer for writing and uploads the new data.
     *
     * @param accessor - Accessor containing the new vertex data
     * @param resourceHandle - Handle to the existing vertex buffer to update
     * @throws Error if the vertex buffer is not found
     */
    updateVertexBuffer(accessor: Accessor, resourceHandle: WebGPUResourceHandle): void;
    /**
     * Updates the data in an existing index buffer with new data from an accessor.
     * Automatically handles conversion of UnsignedByte indices to UnsignedShort if needed.
     *
     * @param accessor - Accessor containing the new index data
     * @param resourceHandle - Handle to the existing index buffer to update
     * @throws Error if the index buffer is not found
     */
    updateIndexBuffer(accessor: Accessor, resourceHandle: WebGPUResourceHandle): void;
    /**
     * Deletes a vertex buffer and removes it from the resource registry.
     * This destroys the GPU buffer and frees its memory.
     *
     * @param resourceHandle - Handle to the vertex buffer to delete
     * @throws Error if the vertex buffer is not found
     */
    deleteVertexBuffer(resourceHandle: WebGPUResourceHandle): void;
    /**
     * Creates vertex and index buffers for a primitive and returns their handles.
     * This method processes all vertex attributes and creates appropriate buffers
     * while tracking which attributes are present.
     *
     * @param primitive - The primitive containing vertex and index data
     * @returns Object containing buffer handles and attribute flags
     */
    createVertexBufferAndIndexBuffer(primitive: Primitive): VertexHandles;
    /**
     * Updates the vertex and index buffers for a primitive with new data.
     * This method updates all existing buffers with fresh data from the primitive.
     *
     * @param primitive - The primitive containing the updated vertex and index data
     * @param vertexHandles - Object containing the handles to the buffers to update
     */
    updateVertexBufferAndIndexBuffer(primitive: Primitive, vertexHandles: VertexHandles): void;
    /**
     * Deletes all vertex data resources (vertex and index buffers) associated with vertex handles.
     * This method destroys both vertex buffers and index buffers to free GPU memory.
     *
     * @param vertexHandles - Object containing handles to the vertex data resources to delete
     */
    deleteVertexDataResources(vertexHandles: VertexHandles): void;
    /**
     * Configures vertex data layout for the rendering pipeline.
     * This method sets up vertex buffer layouts including both per-vertex and per-instance data.
     *
     * @param bufferHandles - Object containing vertex array object, index buffer, and vertex buffer handles
     * @param bufferHandles.vboHandles - Array of vertex buffer handles
     * @param primitive - The primitive containing vertex attribute information
     */
    setVertexDataToPipeline({ vboHandles, }: {
        vboHandles: Array<WebGPUResourceHandle>;
    }, primitive: Primitive): void;
    /**
     * Checks and logs shader compilation status and error messages.
     * This method provides detailed debugging information when shader compilation fails.
     *
     * @param materialTypeName - Name of the material type for debugging
     * @param shaderText - The shader source code that was compiled
     * @param info - WebGPU compilation info containing messages and errors
     * @returns True if compilation was successful, false otherwise
     */
    private __checkShaderCompileStatus;
    /**
     * Creates shader modules (vertex and fragment) from shader source code.
     * This method compiles both vertex and fragment shaders and returns their handles.
     *
     * @param params - Configuration object for shader creation
     * @param params.material - The material that will use these shaders
     * @param params.vertexShaderStr - WGSL vertex shader source code
     * @param params.fragmentShaderStr - WGSL fragment shader source code
     * @returns Handle to the shader program containing both modules
     */
    createShaderProgram({ material, vertexShaderStr, fragmentShaderStr, }: {
        material: Material;
        vertexShaderStr: string;
        fragmentShaderStr: string;
    }): number;
    /**
     * Clears the framebuffer with the specified clear values.
     * This method is executed when the render pass has no entities to render,
     * but still needs to perform clear operations.
     *
     * @param renderPass - The render pass containing clear settings and target framebuffer
     */
    clearFrameBuffer(renderPass: RenderPass): void;
    /**
     * Executes a draw call for rendering a primitive with the specified material and render pass.
     * This is the core rendering method that sets up the render pipeline, bind groups,
     * and executes the actual GPU draw commands.
     *
     * @param primitive - The geometric primitive to render (vertices, indices, attributes)
     * @param material - The material containing shaders and rendering properties
     * @param renderPass - The render pass defining render targets and clear operations
     * @param cameraId - Identifier for the camera used for rendering
     * @param zWrite - Whether to enable depth writing during rendering
     */
    draw(primitive: Primitive, material: Material, renderPass: RenderPass, cameraId: number, zWrite: boolean): void;
    /**
     * Creates a render bundle encoder for efficient rendering.
     * Render bundles allow pre-recording of rendering commands for better performance.
     *
     * @param renderPass - The render pass that will use this render bundle encoder
     */
    private createRenderBundleEncoder;
    /**
     * Creates a render pass encoder for immediate rendering commands.
     * This encoder is used for recording rendering commands that will be executed immediately.
     *
     * @param renderPass - The render pass configuration including targets and clear values
     */
    private createRenderPassEncoder;
    private __toClearRenderBundles;
    executeRenderBundle(renderPass: RenderPass): boolean;
    finishRenderBundleEncoder(renderPass: RenderPass): void;
    getOrCreateRenderPipeline(renderPipelineId: string, bindGroupId: string, primitive: Primitive, material: Material, renderPass: RenderPass, zWrite: boolean, _diffuseCubeMap?: CubeTexture | RenderTargetTextureCube, _specularCubeMap?: CubeTexture | RenderTargetTextureCube, _sheenCubeMap?: CubeTexture | RenderTargetTextureCube): [GPURenderPipeline, boolean];
    /**
     * Submits all recorded commands to the GPU queue and resets the command encoder.
     * This method must be called to execute any recorded rendering commands.
     */
    flush(): void;
    setColorWriteMask(material: Material): GPUColorWriteFlags;
    /**
     * Create Cube Texture from image files.
     * @param baseUri the base uri to load images;
     * @param mipLevelCount the number of mip levels (include root level). if no mipmap, the value should be 1;
     * @returns the WebGLResourceHandle for the generated Cube Texture
     */
    createCubeTextureFromFiles(baseUri: string, mipLevelCount: Count, isNamePosNeg: boolean, hdriFormat: HdriFormatEnum): Promise<[number, Sampler]>;
    /**
     * create a CubeTexture
     *
     * @param mipLevelCount
     * @param images
     * @param width
     * @param height
     * @returns resource handle
     */
    createCubeTexture(mipLevelCount: Count, images: Array<{
        posX: DirectTextureData;
        negX: DirectTextureData;
        posY: DirectTextureData;
        negY: DirectTextureData;
        posZ: DirectTextureData;
        negZ: DirectTextureData;
    }>, width: Size, height: Size): [number, Sampler];
    /**
     * create a TextureArray
     * @param width
     * @param height
     * @param arrayLength
     * @param mipLevelCount
     * @param internalFormat
     * @param format
     * @param type
     * @returns texture handle
     */
    createTextureArray(width: Size, height: Size, arrayLength: Size, mipLevelCount: Size, internalFormat: TextureFormatEnum, _format: PixelFormatEnum, _type: ComponentTypeEnum, imageData: TypedArray): WebGPUResourceHandle;
    /**
     * Creates a storage buffer from a Float32Array and registers it as a WebGPU resource.
     * Storage buffers are used for storing large amounts of data accessible from shaders.
     *
     * @param inputArray - The Float32Array containing the data to store
     * @returns Handle to the created storage buffer resource
     */
    createStorageBuffer(inputArray: Float32Array): number;
    /**
     * Updates an existing storage buffer with new data.
     * Only updates the specified number of components to optimize data transfer.
     *
     * @param storageBufferHandle - Handle to the storage buffer to update
     * @param inputArray - New data to write to the buffer
     * @param updateComponentSize - Number of components to update
     */
    updateStorageBuffer(storageBufferHandle: WebGPUResourceHandle, inputArray: Float32Array, updateComponentSize: Count): void;
    /**
     * Updates a portion of a storage buffer with new data at a specific offset.
     * This allows for efficient partial updates of large storage buffers.
     *
     * @param storageBufferHandle - Handle to the storage buffer to update
     * @param inputArray - New data to write to the buffer
     * @param offsetOfStorageBufferInByte - Byte offset in the storage buffer where to start writing
     * @param offsetOfInputArrayInElement - Element offset in the input array where to start reading
     * @param updateComponentSize - Number of components to update
     */
    updateStorageBufferPartially(storageBufferHandle: WebGPUResourceHandle, inputArray: Float32Array, offsetOfStorageBufferInByte: Count, offsetOfInputArrayInElement: Count, updateComponentSize: Count): void;
    createStorageBlendShapeBuffer(inputArray: Float32Array): number;
    updateStorageBlendShapeBuffer(storageBufferHandle: WebGPUResourceHandle, inputArray: Float32Array, updateComponentSize: Count): void;
    createBindGroupLayoutForDrawParameters(): void;
    updateUniformBufferForDrawParameters(identifier: DRAW_PARAMETERS_IDENTIFIER, materialSid: Index, cameraSID: Index, currentPrimitiveIdx: Index, morphTargetNumber: Count): void;
    createUniformMorphOffsetsBuffer(): number;
    updateUniformMorphOffsetsBuffer(inputArray: Uint32Array, elementNum: Count): void;
    createUniformMorphWeightsBuffer(): number;
    updateUniformMorphWeightsBuffer(inputArray: Float32Array, elementNum: Count): void;
    private __createBindGroup;
    /**
     * create a Texture
     * @param imageData
     * @param param1
     * @returns
     */
    createTextureFromHTMLImageElement(imageData: HTMLImageElement, { internalFormat, width, height, generateMipmap, }: {
        internalFormat: TextureParameterEnum;
        width: Size;
        height: Size;
        generateMipmap: boolean;
    }): Promise<WebGPUResourceHandle>;
    /**
     * create CompressedTextureFromBasis
     * @param basisFile
     * @returns
     */
    createCompressedTextureFromBasis(basisFile: BasisFile): WebGPUResourceHandle;
    /**
     * decode the BasisImage
     * @param basisFile
     * @param basisCompressionType
     * @param imageIndex
     * @param levelIndex
     * @returns
     */
    private decodeBasisImage;
    /**
     * Create and bind compressed texture object
     * @param textureDataArray transcoded texture data for each mipmaps(levels)
     * @param compressionTextureType
     */
    createCompressedTexture(textureDataArray: TextureData[], compressionTextureType: CompressionTextureTypeEnum): Promise<WebGPUResourceHandle>;
    /**
     * allocate a Texture
     * @param format - the format of the texture
     * @param width - the width of the texture
     * @param height - the height of the texture
     * @param mipmapCount - the number of mipmap levels
     * @returns the handle of the texture
     */
    allocateTexture({ format, width, height, mipLevelCount, }: {
        format: TextureFormatEnum;
        width: Size;
        height: Size;
        mipLevelCount: Count;
    }): WebGPUResourceHandle;
    /**
     * Load an image to a specific mip level of a texture
     * @param mipLevel - the mip level to load the image to
     * @param textureUid - the handle of the texture
     * @param format - the format of the image
     * @param type - the type of the data
     * @param xOffset - the x offset of copy region
     * @param yOffset - the y offset of copy region
     * @param width - the width of the image
     * @param height - the height of the image
     * @param data - the typedarray data of the image
     */
    loadImageToMipLevelOfTexture2D({ mipLevel, textureUid, format, type, xOffset, yOffset, width, height, rowSizeByPixel, data, }: {
        mipLevel: Index;
        textureUid: WebGLResourceHandle;
        format: TextureFormatEnum;
        type: ComponentTypeEnum;
        xOffset: number;
        yOffset: number;
        width: number;
        height: number;
        rowSizeByPixel: number;
        data: TypedArray;
    }): Promise<void>;
    private __createTextureInner;
    /**
     * Creates a render target texture that can be used as a color attachment in framebuffers.
     * This texture can be rendered to and also used as a texture input in shaders.
     *
     * @param params - Configuration for the render target texture
     * @param params.width - Width of the texture in pixels
     * @param params.height - Height of the texture in pixels
     * @param params.mipLevelCount - Number of mipmap levels to create
     * @param params.format - Texture format for the render target
     * @returns Handle to the created render target texture resource
     */
    createRenderTargetTexture({ width, height, mipLevelCount, format, }: {
        width: Size;
        height: Size;
        mipLevelCount: Count;
        format: TextureParameterEnum;
    }): WebGPUResourceHandle;
    /**
     * Creates a render target texture array that can hold multiple 2D textures.
     * Useful for techniques like shadow mapping with multiple lights or layered rendering.
     *
     * @param params - Configuration for the render target texture array
     * @param params.width - Width of each texture layer in pixels
     * @param params.height - Height of each texture layer in pixels
     * @param params.internalFormat - Internal format of the texture
     * @param params.arrayLength - Number of texture layers in the array
     * @returns Handle to the created render target texture array resource
     */
    createRenderTargetTextureArray({ width, height, internalFormat, arrayLength, }: {
        width: Size;
        height: Size;
        internalFormat: TextureParameterEnum;
        arrayLength: Count;
    }): WebGPUResourceHandle;
    /**
     * Creates a render target cube texture for environment mapping or omnidirectional shadow mapping.
     * This creates a cube texture with 6 faces that can be rendered to.
     *
     * @param params - Configuration for the render target cube texture
     * @param params.width - Width of each cube face in pixels
     * @param params.height - Height of each cube face in pixels
     * @param params.mipLevelCount - Number of mipmap levels to create
     * @param params.format - Texture format for the render target
     * @returns Handle to the created render target cube texture resource
     */
    createRenderTargetTextureCube({ width, height, mipLevelCount, format, }: {
        width: Size;
        height: Size;
        mipLevelCount: Count;
        format: TextureParameterEnum;
    }): WebGPUResourceHandle;
    /**
     * Creates a render buffer for multisampling (MSAA) or as a render attachment.
     * Render buffers are textures that are only used for rendering and cannot be sampled in shaders.
     *
     * @param width - Width of the render buffer in pixels
     * @param height - Height of the render buffer in pixels
     * @param internalFormat - Internal format of the render buffer
     * @param isMSAA - Whether to enable multisampling
     * @param sampleCountMSAA - Number of samples for MSAA (ignored if isMSAA is false)
     * @returns Handle to the created render buffer resource
     */
    createRenderBuffer(width: Size, height: Size, internalFormat: TextureParameterEnum, isMSAA: boolean, sampleCountMSAA: Count): WebGPUResourceHandle;
    /**
     * delete a RenderBuffer
     * @param renderBufferUid
     */
    deleteRenderBuffer(renderBufferUid: WebGPUResourceHandle): void;
    /**
     * copy Texture Data
     * @param fromTexture
     * @param toTexture
     */
    copyTextureData(fromTexture: WebGPUResourceHandle, toTexture: WebGPUResourceHandle): void;
    isMippmappedTexture(textureHandle: WebGPUResourceHandle): boolean;
    duplicateTextureAsMipmapped(fromTexture: WebGPUResourceHandle): [WebGPUResourceHandle, WebGPUResourceHandle];
    /**
     * attach the DepthBuffer to the FrameBufferObject
     * @param framebuffer a Framebuffer
     * @param renderable a DepthBuffer
     */
    attachDepthBufferToFrameBufferObject(_framebuffer: FrameBuffer, _renderable: IRenderable): void;
    /**
     * attach the StencilBuffer to the FrameBufferObject
     * @param framebuffer a Framebuffer
     * @param renderable a StencilBuffer
     */
    attachStencilBufferToFrameBufferObject(_framebuffer: FrameBuffer, _renderable: IRenderable): void;
    /**
     * attach the depthStencilBuffer to the FrameBufferObject
     * @param framebuffer a Framebuffer
     * @param renderable a depthStencilBuffer
     */
    attachDepthStencilBufferToFrameBufferObject(_framebuffer: FrameBuffer, _renderable: IRenderable): void;
    /**
     * create a FrameBufferObject
     * @returns
     */
    createFrameBufferObject(): number;
    /**
     * delete a FrameBufferObject
     * @param frameBufferObjectHandle
     */
    deleteFrameBufferObject(_frameBufferObjectHandle: WebGPUResourceHandle): void;
    /**
     * attach the ColorBuffer to the FrameBufferObject
     * @param framebuffer a Framebuffer
     * @param attachmentIndex a attachment index
     * @param renderable a ColorBuffer
     */
    attachColorBufferToFrameBufferObject(_framebuffer: FrameBuffer, _attachmentIndex: Index, _renderable: IRenderable): void;
    /**
     * attach the ColorBuffer to the FrameBufferObject
     * @param framebuffer a Framebuffer
     * @param attachmentIndex a attachment index
     * @param renderable a ColorBuffer
     * @param layerIndex a layer index
     * @param mipLevel a mip level
     */
    attachColorBufferLayerToFrameBufferObject(_framebuffer: FrameBuffer, _attachmentIndex: Index, _renderable: IRenderable, _layerIndex: Index, _mipLevel: Index): void;
    /**
     * attach the ColorBuffer to the FrameBufferObject
     * @param framebuffer a Framebuffer
     * @param attachmentIndex a attachment index
     * @param faceIndex a face index
     * @param mipLevel a mip level
     * @param renderable a ColorBuffer
     */
    attachColorBufferCubeToFrameBufferObject(_framebuffer: FrameBuffer, _attachmentIndex: Index, _faceIndex: Index, _mipLevel: Index, _renderable: IRenderable): void;
    /**
     * Creates a 2D texture view from a texture resource.
     * This view can be used for sampling the texture in shaders.
     *
     * @param textureHandle - Handle to the source texture
     * @returns Handle to the created texture view
     */
    createTextureView2d(textureHandle: WebGPUResourceHandle): WebGPUResourceHandle;
    /**
     * Creates a texture view suitable for use as a render target.
     * This view targets only the base mip level and first array layer.
     *
     * @param textureHandle - Handle to the source texture
     * @returns Handle to the created render target texture view
     */
    createTextureViewAsRenderTarget(textureHandle: WebGPUResourceHandle): WebGPUResourceHandle;
    /**
     * Creates a cube texture view from a cube texture resource.
     * This view exposes all 6 faces of the cube texture for sampling.
     *
     * @param textureHandle - Handle to the source cube texture
     * @returns Handle to the created cube texture view
     */
    createTextureViewCube(textureHandle: WebGPUResourceHandle): WebGPUResourceHandle;
    createTextureView2dArray(textureHandle: WebGPUResourceHandle, arrayLayerCount: Count): WebGPUResourceHandle;
    createTextureView2dArrayAsRenderTarget(textureHandle: WebGPUResourceHandle, arrayIdx: Index, mipLevel: Index): WebGPUResourceHandle;
    createCubeTextureViewAsRenderTarget(textureHandle: WebGPUResourceHandle, faceIdx: Index, mipLevel: Index): WebGPUResourceHandle;
    deleteTexture(textureHandle: WebGLResourceHandle): void;
    /**
     * Recreates the system depth texture with the current canvas dimensions.
     * This is called when the canvas is resized or initialized.
     */
    recreateSystemDepthTexture(): void;
    /**
     * Resizes the canvas and recreates the system depth texture.
     * This method should be called when the window or viewport size changes.
     *
     * @param width - New canvas width in pixels
     * @param height - New canvas height in pixels
     */
    resizeCanvas(width: Size, height: Size): void;
    /**
     * Sets the viewport for rendering (currently not implemented in WebGPU version).
     *
     * @param viewport - Optional viewport rectangle (x, y, width, height)
     */
    setViewport(_viewport?: Vector4): void;
    /**
     * Checks if the implementation supports multi-view VR rendering.
     *
     * @returns Always false for WebGPU implementation (not yet supported)
     */
    isSupportMultiViewVRRendering(): boolean;
}

/**
 * Union type representing direct texture data that can be used for texture creation.
 * Includes typed arrays and various HTML/browser elements that can serve as texture sources.
 */
type DirectTextureData = TypedArray | HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap;
/**
 * Union type representing image bitmap data sources.
 * Includes HTML elements and ImageBitmap that can be converted to texture data.
 */
type ImageBitmapData = HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap;
/**
 * Abstract base class for Computer Graphics API Resource Repository.
 * Provides a unified interface for managing graphics resources across different APIs (WebGL, WebGPU).
 * This class serves as a factory and utility provider for accessing the appropriate resource repository
 * based on the current graphics API approach.
 */
declare abstract class CGAPIResourceRepository {
    /** Invalid resource handle constant used to indicate failed resource creation or invalid resources */
    static readonly InvalidCGAPIResourceUid = -1;
    /**
     * Gets the appropriate Computer Graphics API Resource Repository instance based on the current process approach.
     * Automatically selects between WebGL and WebGPU implementations.
     *
     * @returns The active ICGAPIResourceRepository implementation
     * @throws Error if the required module is not available
     */
    static getCgApiResourceRepository(): ICGAPIResourceRepository;
    /**
     * Gets the WebGL-specific resource repository instance.
     * Use this method when you specifically need WebGL functionality.
     *
     * @returns The WebGLResourceRepository singleton instance
     * @throws Error if the WebGL module is not available
     */
    static getWebGLResourceRepository(): WebGLResourceRepository;
    /**
     * Gets the WebGPU-specific resource repository instance.
     * Use this method when you specifically need WebGPU functionality.
     *
     * @returns The WebGpuResourceRepository singleton instance
     * @throws Error if the WebGPU module is not available
     */
    static getWebGpuResourceRepository(): WebGpuResourceRepository;
}
/**
 * Interface defining the contract for Computer Graphics API Resource Repository implementations.
 * This interface abstracts graphics resource management operations across different APIs (WebGL, WebGPU).
 * Implementations handle creation, management, and deletion of graphics resources like textures,
 * buffers, shaders, and framebuffers.
 */
interface ICGAPIResourceRepository {
    /**
     * Retrieves the current canvas dimensions.
     *
     * @returns A tuple containing [width, height] of the canvas
     */
    getCanvasSize(): [Size, Size];
    /**
     * Resizes the canvas to the specified dimensions.
     * This operation may trigger viewport adjustments and resource reallocation.
     *
     * @param width - The new canvas width in pixels
     * @param height - The new canvas height in pixels
     */
    resizeCanvas(width: Size, height: Size): void;
    /**
     * Clears the framebuffer associated with the given render pass.
     * This operation clears color, depth, and/or stencil buffers as configured in the render pass.
     *
     * @param renderPass - The render pass containing clear configuration
     */
    clearFrameBuffer(renderPass: RenderPass): void;
    /**
     * Creates a texture from image bitmap data with specified parameters.
     * This method handles various image sources and converts them to GPU textures.
     *
     * @param imageData - The source image data (HTMLImageElement, HTMLVideoElement, etc.)
     * @param options - Texture creation parameters
     * @param options.level - Mipmap level (typically 0 for base level)
     * @param options.internalFormat - Internal texture format for GPU storage
     * @param options.width - Texture width in pixels
     * @param options.height - Texture height in pixels
     * @param options.border - Border width (typically 0)
     * @param options.format - Pixel data format
     * @param options.type - Component data type
     * @param options.generateMipmap - Whether to automatically generate mipmaps
     * @returns Promise resolving to the texture resource handle
     */
    createTextureFromImageBitmapData(imageData: ImageBitmapData, { level, internalFormat, width, height, border, format, type, generateMipmap, }: {
        level: Index;
        internalFormat: TextureParameterEnum;
        width: Size;
        height: Size;
        border: Size;
        format: PixelFormatEnum;
        type: ComponentTypeEnum;
        generateMipmap: boolean;
    }): Promise<CGAPIResourceHandle>;
    /**
     * Creates a compressed texture from a Basis Universal file.
     * Basis Universal provides efficient texture compression that can be transcoded
     * to various GPU-specific formats at runtime.
     *
     * @param basisFile - The Basis Universal file containing compressed texture data
     * @param options - Texture creation parameters
     * @param options.border - Border width (typically 0)
     * @param options.format - Target pixel format after transcoding
     * @param options.type - Component data type
     * @returns The texture resource handle
     */
    createCompressedTextureFromBasis(basisFile: BasisFile, { border, format, type, }: {
        border: Size;
        format: PixelFormatEnum;
        type: ComponentTypeEnum;
    }): CGAPIResourceHandle;
    /**
     * Creates a compressed texture from pre-transcoded texture data.
     * This method handles already transcoded compressed texture data for multiple mipmap levels.
     *
     * @param textureDataArray - Array of texture data for each mipmap level
     * @param compressionTextureType - The specific compression format type
     * @returns Promise resolving to the texture resource handle
     */
    createCompressedTexture(textureDataArray: TextureData[], compressionTextureType: CompressionTextureTypeEnum): Promise<CGAPIResourceHandle>;
    /**
     * Creates a vertex buffer from an accessor containing vertex data.
     * The accessor provides metadata about the data layout and type information.
     *
     * @param accessor - Accessor containing vertex data and metadata
     * @returns The vertex buffer resource handle
     */
    createVertexBuffer(accessor: Accessor): CGAPIResourceHandle;
    /**
     * Creates a vertex buffer directly from a typed array.
     * This is a more direct approach when you have raw vertex data without accessor metadata.
     *
     * @param typedArray - The typed array containing vertex data
     * @returns The vertex buffer resource handle
     */
    createVertexBufferFromTypedArray(typedArray: TypedArray): CGAPIResourceHandle;
    /**
     * Creates an index buffer from an accessor containing index data.
     * Index buffers are used to define the order in which vertices are processed.
     *
     * @param accessor - Accessor containing index data and metadata
     * @returns The index buffer resource handle
     */
    createIndexBuffer(accessor: Accessor): CGAPIResourceHandle;
    /**
     * Creates both vertex and index buffers for a primitive geometry.
     * This is a convenience method that handles the creation of all necessary buffers
     * for rendering a geometric primitive.
     *
     * @param primitive - The primitive geometry containing vertex and index data
     * @returns Object containing handles for all created vertex-related resources
     */
    createVertexBufferAndIndexBuffer(primitive: Primitive): VertexHandles;
    /**
     * Updates an existing vertex buffer with new data from an accessor.
     * This allows for dynamic modification of vertex data without recreating the buffer.
     *
     * @param accessor - Accessor containing the new vertex data
     * @param resourceHandle - Handle to the existing vertex buffer to update
     */
    updateVertexBuffer(accessor: Accessor, resourceHandle: CGAPIResourceHandle): void;
    /**
     * Updates an existing index buffer with new data from an accessor.
     * This allows for dynamic modification of index data without recreating the buffer.
     *
     * @param accessor - Accessor containing the new index data
     * @param resourceHandle - Handle to the existing index buffer to update
     */
    updateIndexBuffer(accessor: Accessor, resourceHandle: CGAPIResourceHandle): void;
    /**
     * Updates both vertex and index buffers for a primitive geometry.
     * This is a convenience method for updating all vertex-related data at once.
     *
     * @param primitive - The primitive geometry containing updated vertex and index data
     * @param vertexHandles - Object containing handles to the buffers to update
     */
    updateVertexBufferAndIndexBuffer(primitive: Primitive, vertexHandles: VertexHandles): void;
    /**
     * Deletes all vertex-related resources (vertex buffers, index buffers, VAOs).
     * This method ensures proper cleanup of all resources associated with vertex data.
     *
     * @param vertexHandles - Object containing handles to all vertex-related resources to delete
     */
    deleteVertexDataResources(vertexHandles: VertexHandles): void;
    /**
     * Deletes a specific vertex buffer resource.
     *
     * @param resourceHandle - Handle to the vertex buffer to delete
     */
    deleteVertexBuffer(resourceHandle: CGAPIResourceHandle): void;
    /**
     * Configures the graphics pipeline with vertex data for rendering.
     * This method sets up the vertex array object (VAO) and binds the necessary buffers.
     *
     * @param bufferHandles - Object containing buffer handles
     * @param bufferHandles.vaoHandle - Vertex Array Object handle
     * @param bufferHandles.iboHandle - Index Buffer Object handle (optional)
     * @param bufferHandles.vboHandles - Array of Vertex Buffer Object handles
     * @param primitive - The primitive geometry defining vertex layout
     * @param instanceIDBufferUid - Handle to instance ID buffer for instanced rendering
     */
    setVertexDataToPipeline({ vaoHandle, iboHandle, vboHandles, }: {
        vaoHandle: CGAPIResourceHandle;
        iboHandle?: CGAPIResourceHandle;
        vboHandles: Array<CGAPIResourceHandle>;
    }, primitive: Primitive, instanceIDBufferUid: CGAPIResourceHandle): void;
    /**
     * Creates a shader program from vertex and fragment shader source code.
     * This method compiles, links, and validates the shader program for use in rendering.
     *
     * @param options - Shader program creation parameters
     * @param options.material - Material that will use this shader program
     * @param options.primitive - Primitive geometry that will be rendered with this shader
     * @param options.vertexShaderStr - Vertex shader source code
     * @param options.fragmentShaderStr - Fragment shader source code
     * @param options.attributeNames - Names of vertex attributes
     * @param options.attributeSemantics - Semantic meanings of vertex attributes
     * @param options.onError - Optional error callback for compilation/linking errors
     * @returns The shader program resource handle
     */
    createShaderProgram({ material, primitive, vertexShaderStr, fragmentShaderStr, attributeNames, attributeSemantics, onError, }: {
        material: Material;
        primitive: Primitive;
        vertexShaderStr: string;
        fragmentShaderStr: string;
        attributeNames: AttributeNames;
        attributeSemantics: VertexAttributeEnum[];
        onError?: (message: string) => void;
    }): CGAPIResourceHandle;
    /**
     * Creates a cube texture from image files with automatic loading.
     * This method handles the loading and assembly of 6 cube faces from file sources.
     *
     * @param baseUri - Base URI for the cube texture files
     * @param mipLevelCount - Number of mipmap levels to generate
     * @param isNamePosNeg - Whether to use positive/negative naming convention
     * @param hdriFormat - HDRI format specification for high dynamic range textures
     * @returns Promise resolving to a tuple of [texture handle, sampler]
     */
    createCubeTextureFromFiles(baseUri: string, mipLevelCount: Count, isNamePosNeg: boolean, hdriFormat: HdriFormatEnum): Promise<[number, Sampler]>;
    /**
     * Allocates a texture with specified dimensions and format without initial data.
     * This creates an empty texture that can be filled later or used as a render target.
     *
     * @param options - Texture allocation parameters
     * @param options.format - Internal texture format
     * @param options.width - Texture width in pixels
     * @param options.height - Texture height in pixels
     * @param options.mipLevelCount - Number of mipmap levels to allocate
     * @returns The texture resource handle
     */
    allocateTexture({ format, width, height, mipLevelCount, }: {
        format: TextureFormatEnum;
        width: Size;
        height: Size;
        mipLevelCount: Count;
    }): CGAPIResourceHandle;
    /**
     * Loads image data to a specific mipmap level of an existing texture.
     * This method allows for partial texture updates and mipmap level management.
     *
     * @param options - Image loading parameters
     * @param options.mipLevel - Target mipmap level
     * @param options.textureUid - Handle to the target texture
     * @param options.format - Format of the source image data
     * @param options.type - Data type of the source image
     * @param options.xOffset - X offset within the texture for the copy region
     * @param options.yOffset - Y offset within the texture for the copy region
     * @param options.width - Width of the image data to copy
     * @param options.height - Height of the image data to copy
     * @param options.rowSizeByPixel - Size of each row in pixels
     * @param options.data - The actual image data as a typed array
     */
    loadImageToMipLevelOfTexture2D({ mipLevel, textureUid, format, type, xOffset, yOffset, width, height, rowSizeByPixel, data, }: {
        mipLevel: Index;
        textureUid: CGAPIResourceHandle;
        format: TextureFormatEnum;
        type: ComponentTypeEnum;
        xOffset: number;
        yOffset: number;
        width: number;
        height: number;
        rowSizeByPixel: number;
        data: TypedArray;
    }): void;
    /**
     * Creates a cube texture from provided image data for all six faces.
     * This method assembles a complete cube texture from individual face images.
     *
     * @param mipLevelCount - Number of mipmap levels to generate
     * @param images - Array of image data objects, each containing all six cube faces
     * @param width - Width of each cube face in pixels
     * @param height - Height of each cube face in pixels
     * @returns Tuple containing [texture handle, sampler]
     */
    createCubeTexture(mipLevelCount: Count, images: Array<{
        posX: DirectTextureData;
        negX: DirectTextureData;
        posY: DirectTextureData;
        negY: DirectTextureData;
        posZ: DirectTextureData;
        negZ: DirectTextureData;
    }>, width: Size, height: Size): [number, Sampler];
    /**
     * Creates a texture sampler with specified filtering and wrapping parameters.
     * Samplers define how textures are filtered and addressed during rendering.
     *
     * @param options - Sampler creation parameters
     * @param options.magFilter - Magnification filter mode
     * @param options.minFilter - Minification filter mode
     * @param options.wrapS - Texture wrapping mode for S coordinate
     * @param options.wrapT - Texture wrapping mode for T coordinate
     * @param options.wrapR - Texture wrapping mode for R coordinate
     * @param options.anisotropy - Whether to enable anisotropic filtering
     * @param options.isPremultipliedAlpha - Whether the texture uses premultiplied alpha
     * @param options.shadowCompareMode - Whether to enable shadow comparison mode
     * @returns The texture sampler resource handle
     */
    createTextureSampler({ magFilter, minFilter, wrapS, wrapT, wrapR, anisotropy, isPremultipliedAlpha, shadowCompareMode, }: {
        magFilter: TextureParameterEnum;
        minFilter: TextureParameterEnum;
        wrapS: TextureParameterEnum;
        wrapT: TextureParameterEnum;
        wrapR: TextureParameterEnum;
        anisotropy: boolean;
        isPremultipliedAlpha?: boolean;
        shadowCompareMode: boolean;
    }): CGAPIResourceHandle;
    /**
     * Creates a texture from an HTML image element with specified parameters.
     * This method handles the conversion of HTML image elements to GPU textures.
     *
     * @param imageData - The HTML image element containing the texture data
     * @param options - Texture creation parameters
     * @param options.level - Mipmap level (typically 0 for base level)
     * @param options.internalFormat - Internal texture format for GPU storage
     * @param options.width - Texture width in pixels
     * @param options.height - Texture height in pixels
     * @param options.border - Border width (typically 0)
     * @param options.format - Pixel data format
     * @param options.type - Component data type
     * @param options.generateMipmap - Whether to automatically generate mipmaps
     * @returns Promise resolving to the texture resource handle
     */
    createTextureFromHTMLImageElement(imageData: HTMLImageElement, { level, internalFormat, width, height, border, format, type, generateMipmap, }: {
        level: Index;
        internalFormat: TextureParameterEnum;
        width: Size;
        height: Size;
        border: Size;
        format: PixelFormatEnum;
        type: ComponentTypeEnum;
        generateMipmap: boolean;
    }): Promise<CGAPIResourceHandle>;
    /**
     * Creates a texture from a data URI string.
     * This method decodes base64-encoded image data and creates a GPU texture.
     *
     * @param dataUri - The data URI string containing encoded image data
     * @param options - Texture creation parameters
     * @param options.level - Mipmap level (typically 0 for base level)
     * @param options.internalFormat - Internal texture format for GPU storage
     * @param options.border - Border width (typically 0)
     * @param options.format - Pixel data format
     * @param options.type - Component data type
     * @param options.generateMipmap - Whether to automatically generate mipmaps
     * @returns Promise resolving to the texture resource handle
     */
    createTextureFromDataUri(dataUri: string, { level, internalFormat, border, format, type, generateMipmap, }: {
        level: Index;
        internalFormat: TextureParameterEnum;
        border: Size;
        format: PixelFormatEnum;
        type: ComponentTypeEnum;
        generateMipmap: boolean;
    }): Promise<CGAPIResourceHandle>;
    /**
     * Creates a render target texture for off-screen rendering.
     * This texture can be used as a color attachment in framebuffers for rendering operations.
     *
     * @param options - Render target creation parameters
     * @param options.width - Texture width in pixels
     * @param options.height - Texture height in pixels
     * @param options.mipLevelCount - Number of mipmap levels
     * @param options.format - Internal texture format
     * @returns The render target texture resource handle
     */
    createRenderTargetTexture({ width, height, mipLevelCount, format, }: {
        width: Size;
        height: Size;
        mipLevelCount: Count;
        format: TextureParameterEnum;
    }): CGAPIResourceHandle;
    /**
     * Creates a render target texture array for layered rendering.
     * This allows rendering to multiple texture layers in a single pass.
     *
     * @param options - Render target array creation parameters
     * @param options.width - Texture width in pixels
     * @param options.height - Texture height in pixels
     * @param options.level - Mipmap level
     * @param options.internalFormat - Internal texture format
     * @param options.format - Pixel data format
     * @param options.type - Component data type
     * @param options.arrayLength - Number of texture layers
     * @returns The render target texture array resource handle
     */
    createRenderTargetTextureArray({ width, height, level, internalFormat, format, type, arrayLength, }: {
        width: Size;
        height: Size;
        level: Index;
        internalFormat: TextureParameterEnum;
        format: PixelFormatEnum;
        type: ComponentTypeEnum;
        arrayLength: Count;
    }): CGAPIResourceHandle;
    /**
     * Creates a render target cube texture for environment mapping and shadow mapping.
     * This allows rendering to all six faces of a cube texture.
     *
     * @param options - Render target cube creation parameters
     * @param options.width - Texture width in pixels
     * @param options.height - Texture height in pixels
     * @param options.mipLevelCount - Number of mipmap levels
     * @param options.format - Internal texture format
     * @returns The render target cube texture resource handle
     */
    createRenderTargetTextureCube({ width, height, mipLevelCount, format, }: {
        width: Size;
        height: Size;
        mipLevelCount: Size;
        format: TextureParameterEnum;
    }): CGAPIResourceHandle;
    /**
     * Creates a texture array from provided image data.
     * Texture arrays allow efficient rendering of multiple related textures.
     *
     * @param width - Texture width in pixels
     * @param height - Texture height in pixels
     * @param arrayLength - Number of textures in the array
     * @param mipLevelCount - Number of mipmap levels
     * @param internalFormat - Internal texture format
     * @param format - Pixel data format
     * @param type - Component data type
     * @param imageData - The texture data as a typed array
     * @returns The texture array resource handle
     */
    createTextureArray(width: Size, height: Size, arrayLength: Size, mipLevelCount: Size, internalFormat: TextureFormatEnum, format: PixelFormatEnum, type: ComponentTypeEnum, imageData: TypedArray): CGAPIResourceHandle;
    /**
     * Deletes a texture resource and frees associated GPU memory.
     *
     * @param textureHandle - Handle to the texture to delete
     */
    deleteTexture(textureHandle: CGAPIResourceHandle): void;
    /**
     * Generates mipmaps for a 2D texture.
     * Mipmaps improve rendering quality and performance by providing pre-filtered texture versions.
     *
     * @param textureHandle - Handle to the texture
     * @param width - Base texture width in pixels
     * @param height - Base texture height in pixels
     */
    generateMipmaps2d(textureHandle: CGAPIResourceHandle, width: number, height: number): void;
    /**
     * Generates mipmaps for a cube texture.
     * This creates mipmaps for all six faces of the cube texture.
     *
     * @param textureHandle - Handle to the cube texture
     * @param width - Base texture width in pixels
     * @param height - Base texture height in pixels
     */
    generateMipmapsCube(textureHandle: CGAPIResourceHandle, width: number, height: number): void;
    /**
     * Reads pixel data from a texture attached to a framebuffer.
     * This allows CPU access to rendered texture data for analysis or processing.
     *
     * @param textureHandle - Handle to the texture to read from
     * @param width - Width of the region to read
     * @param height - Height of the region to read
     * @param frameBufferUid - Handle to the framebuffer containing the texture
     * @param colorAttachmentIndex - Index of the color attachment to read from
     * @returns Promise resolving to the pixel data as a Uint8Array
     */
    getTexturePixelData(textureHandle: CGAPIResourceHandle, width: number, height: number, frameBufferUid: CGAPIResourceHandle, colorAttachmentIndex: number): Promise<Uint8Array>;
    /**
     * Creates a framebuffer object for off-screen rendering.
     * Framebuffers allow rendering to textures instead of the default screen buffer.
     *
     * @returns The framebuffer object resource handle
     */
    createFrameBufferObject(): CGAPIResourceHandle;
    /**
     * Attaches a color buffer (texture or renderbuffer) to a framebuffer object.
     * This allows the framebuffer to render color data to the attached buffer.
     *
     * @param framebuffer - The target framebuffer
     * @param attachmentIndex - Color attachment index (0-based)
     * @param renderable - The color buffer to attach
     */
    attachColorBufferToFrameBufferObject(framebuffer: FrameBuffer, attachmentIndex: Index, renderable: IRenderable): void;
    /**
     * Attaches a specific layer of a texture array as a color buffer to a framebuffer.
     * This enables layered rendering to texture arrays.
     *
     * @param framebuffer - The target framebuffer
     * @param attachmentIndex - Color attachment index (0-based)
     * @param renderable - The texture array to attach
     * @param layerIndex - Index of the layer to attach
     * @param mipLevel - Mipmap level to attach
     */
    attachColorBufferLayerToFrameBufferObject(framebuffer: FrameBuffer, attachmentIndex: Index, renderable: IRenderable, layerIndex: Index, mipLevel: Index): void;
    /**
     * Attaches a specific face of a cube texture as a color buffer to a framebuffer.
     * This enables rendering to individual faces of cube textures.
     *
     * @param framebuffer - The target framebuffer
     * @param attachmentIndex - Color attachment index (0-based)
     * @param faceIndex - Cube face index (0-5)
     * @param mipLevel - Mipmap level to attach
     * @param renderable - The cube texture to attach
     */
    attachColorBufferCubeToFrameBufferObject(framebuffer: FrameBuffer, attachmentIndex: Index, faceIndex: Index, mipLevel: Index, renderable: IRenderable): void;
    /**
     * Creates a renderbuffer for use as a framebuffer attachment.
     * Renderbuffers are optimized for use as render targets but cannot be sampled as textures.
     *
     * @param width - Renderbuffer width in pixels
     * @param height - Renderbuffer height in pixels
     * @param internalFormat - Internal format of the renderbuffer
     * @param isMSAA - Whether to enable multi-sample anti-aliasing
     * @param sampleCountMSAA - Number of MSAA samples (if MSAA is enabled)
     * @returns The renderbuffer resource handle
     */
    createRenderBuffer(width: Size, height: Size, internalFormat: TextureParameterEnum, isMSAA: boolean, sampleCountMSAA: Count): CGAPIResourceHandle;
    /**
     * Deletes a renderbuffer resource and frees associated GPU memory.
     *
     * @param renderBufferUid - Handle to the renderbuffer to delete
     */
    deleteRenderBuffer(renderBufferUid: CGAPIResourceHandle): void;
    /**
     * Attaches a depth buffer to a framebuffer object.
     * The depth buffer stores per-pixel depth information for depth testing.
     *
     * @param framebuffer - The target framebuffer
     * @param renderable - The depth buffer to attach
     */
    attachDepthBufferToFrameBufferObject(framebuffer: FrameBuffer, renderable: IRenderable): void;
    /**
     * Attaches a stencil buffer to a framebuffer object.
     * The stencil buffer enables stencil testing for advanced rendering effects.
     *
     * @param framebuffer - The target framebuffer
     * @param renderable - The stencil buffer to attach
     */
    attachStencilBufferToFrameBufferObject(framebuffer: FrameBuffer, renderable: IRenderable): void;
    /**
     * Attaches a combined depth-stencil buffer to a framebuffer object.
     * This is more efficient than separate depth and stencil buffers when both are needed.
     *
     * @param framebuffer - The target framebuffer
     * @param renderable - The depth-stencil buffer to attach
     */
    attachDepthStencilBufferToFrameBufferObject(framebuffer: FrameBuffer, renderable: IRenderable): void;
    /**
     * Deletes a framebuffer object and frees associated resources.
     *
     * @param frameBufferObjectHandle - Handle to the framebuffer to delete
     */
    deleteFrameBufferObject(frameBufferObjectHandle: CGAPIResourceHandle): void;
    /**
     * Checks if the current graphics API supports multi-view VR rendering.
     * Multi-view rendering allows efficient stereo rendering for VR applications.
     *
     * @returns True if multi-view VR rendering is supported, false otherwise
     */
    isSupportMultiViewVRRendering(): boolean;
    /**
     * Sets the viewport for rendering operations.
     * The viewport defines the area of the framebuffer that will be rendered to.
     *
     * @param viewport - Optional viewport rectangle as [x, y, width, height]. If not provided, uses full framebuffer
     */
    setViewport(viewport?: Vector4): void;
}

interface RnWebGLProgram extends WebGLProgram {
    _gl: WebGLRenderingContext | WebGL2RenderingContext;
    _materialTypeName: string;
    _vertexShaderStr: string;
    _fragmentShaderStr: string;
    _shaderSemanticsInfoMap: Map<ShaderSemanticsName, ShaderSemanticsInfo>;
    __SPECTOR_rebuildProgram: unknown;
    _material: WeakRef<Material>;
    _primitive: WeakRef<Primitive>;
}
interface RnWebGLTexture extends WebGLTexture {
    _resourceUid: number;
}

type VertexHandles = {
    vaoHandle: CGAPIResourceHandle;
    iboHandle?: CGAPIResourceHandle;
    vboHandles: Array<CGAPIResourceHandle>;
    attributesFlags: Array<boolean>;
    setComplete: boolean;
};
type TextureData = {
    level: Count;
    width: Count;
    height: Count;
    buffer: ArrayBufferView;
};
type WebGLResource = WebGLBuffer | WebGLFramebuffer | WebGLObject | WebGLProgram | WebGLRenderbuffer | WebGLTexture | WebGLTransformFeedback;
/**
 * A comprehensive repository for managing WebGL resources including buffers, textures, shaders, and framebuffers.
 * This class provides a centralized interface for creating, managing, and disposing of WebGL resources
 * while maintaining resource handles for efficient memory management.
 *
 * @example
 * ```typescript
 * const repository = WebGLResourceRepository.getInstance();
 * const textureHandle = repository.createTextureFromImageBitmapData(imageData, options);
 * ```
 */
declare class WebGLResourceRepository extends CGAPIResourceRepository implements ICGAPIResourceRepository {
    private static __instance;
    private __webglContexts;
    private __glw?;
    private __resourceCounter;
    private __webglResources;
    private __samplerClampToEdgeLinearUid;
    private __samplerClampToEdgeNearestUid;
    private __samplerRepeatNearestUid;
    private __samplerRepeatLinearUid;
    private __samplerShadowUid;
    private __samplerRepeatTriLinearUid;
    private __samplerRepeatAnisotropyLinearUid;
    private constructor();
    /**
     * Gets the singleton instance of WebGLResourceRepository.
     *
     * @returns The singleton instance of WebGLResourceRepository
     */
    static getInstance(): WebGLResourceRepository;
    /**
     * Adds an existing WebGL2 context to the repository.
     *
     * @param gl - The WebGL2 rendering context to add
     * @param canvas - The HTML canvas element associated with the context
     * @param asCurrent - Whether to set this context as the current active context
     */
    addWebGLContext(gl: WebGL2RenderingContext, canvas: HTMLCanvasElement, asCurrent: boolean): void;
    /**
     * Generates a new WebGL2 context for the given canvas element.
     *
     * @param canvas - The HTML canvas element to create the context for
     * @param asCurrent - Whether to set this context as the current active context
     * @param webglOption - Optional WebGL context attributes for context creation
     * @returns The created WebGL2 rendering context
     */
    generateWebGLContext(canvas: HTMLCanvasElement, asCurrent: boolean, webglOption?: WebGLContextAttributes): WebGL2RenderingContext;
    /**
     * Gets the current WebGL context wrapper.
     *
     * @returns The current WebGLContextWrapper instance or undefined if none is set
     */
    get currentWebGLContextWrapper(): WebGLContextWrapper | undefined;
    /**
     * Generates a unique resource handle for WebGL objects.
     *
     * @returns A unique WebGL resource handle
     */
    private getResourceNumber;
    /**
     * Registers a WebGL object and assigns it a unique handle.
     *
     * @param obj - The WebGL object to register
     * @returns The assigned resource handle
     */
    private __registerResource;
    /**
     * Retrieves a WebGL resource by its handle.
     *
     * @param WebGLResourceHandle - The handle of the resource to retrieve
     * @returns The WebGL resource or null if not found
     */
    getWebGLResource(WebGLResourceHandle: WebGLResourceHandle): WebGLResource | null;
    /**
     * Creates an index buffer from the provided accessor data.
     *
     * @param accessor - The accessor containing index data
     * @returns The handle of the created index buffer
     * @throws Error if no WebGL context is available
     */
    createIndexBuffer(accessor: Accessor): number;
    /**
     * Updates an existing index buffer with new data from the accessor.
     *
     * @param accessor - The accessor containing new index data
     * @param resourceHandle - The handle of the index buffer to update
     * @throws Error if no WebGL context is available or IBO not found
     */
    updateIndexBuffer(accessor: Accessor, resourceHandle: number): void;
    /**
     * Creates a vertex buffer from the provided accessor data.
     *
     * @param accessor - The accessor containing vertex data
     * @returns The handle of the created vertex buffer
     * @throws Error if no WebGL context is available
     */
    createVertexBuffer(accessor: Accessor): number;
    /**
     * Creates a vertex buffer directly from a typed array.
     *
     * @param typedArray - The typed array containing vertex data
     * @returns The handle of the created vertex buffer
     * @throws Error if no WebGL context is available
     */
    createVertexBufferFromTypedArray(typedArray: TypedArray): number;
    /**
     * Updates an existing vertex buffer with new data from the accessor.
     *
     * @param accessor - The accessor containing new vertex data
     * @param resourceHandle - The handle of the vertex buffer to update
     * @throws Error if no WebGL context is available or VBO not found
     */
    updateVertexBuffer(accessor: Accessor, resourceHandle: number): void;
    /**
     * Creates a new vertex array object (VAO).
     *
     * @returns The handle of the created VAO or undefined if creation failed
     * @throws Error if no WebGL context is available
     */
    createVertexArray(): number | undefined;
    /**
     * Binds a 2D texture to the specified texture slot.
     *
     * @param textureSlotIndex - The texture slot index to bind to
     * @param textureUid - The handle of the texture to bind
     */
    bindTexture2D(textureSlotIndex: Index, textureUid: CGAPIResourceHandle): void;
    /**
     * Binds a texture sampler to the specified texture slot.
     *
     * @param textureSlotIndex - The texture slot index to bind to
     * @param samplerUid - The handle of the sampler to bind, or -1 to unbind
     */
    bindTextureSampler(textureSlotIndex: Index, samplerUid: CGAPIResourceHandle): void;
    /**
     * Binds a cube texture to the specified texture slot.
     *
     * @param textureSlotIndex - The texture slot index to bind to
     * @param textureUid - The handle of the cube texture to bind
     */
    bindTextureCube(textureSlotIndex: Index, textureUid: CGAPIResourceHandle): void;
    /**
     * Binds a 2D texture array to the specified texture slot.
     *
     * @param textureSlotIndex - The texture slot index to bind to
     * @param textureUid - The handle of the 2D texture array to bind
     */
    bindTexture2DArray(textureSlotIndex: Index, textureUid: CGAPIResourceHandle): void;
    /**
     * Creates vertex buffers and index buffers for a primitive and returns handles for them.
     * This method processes all vertex attributes of the primitive and creates corresponding VBOs.
     *
     * @param primitive - The primitive object containing vertex and index data
     * @returns VertexHandles object containing all created buffer handles and metadata
     */
    createVertexBufferAndIndexBuffer(primitive: Primitive): VertexHandles;
    /**
     * Updates existing vertex buffers and index buffers with new data from a primitive.
     *
     * @param primitive - The primitive object containing updated vertex and index data
     * @param vertexHandles - The handles of the buffers to update
     */
    updateVertexBufferAndIndexBuffer(primitive: Primitive, vertexHandles: VertexHandles): void;
    /**
     * Creates and compiles a shader program from vertex and fragment shader source code.
     * This method handles shader compilation, linking, and error reporting.
     *
     * @param params - Configuration object for shader program creation
     * @param params.material - The material associated with this shader program
     * @param params.primitive - The primitive that will use this shader program
     * @param params.vertexShaderStr - The vertex shader source code
     * @param params.fragmentShaderStr - The fragment shader source code
     * @param params.attributeNames - Array of vertex attribute names
     * @param params.attributeSemantics - Array of vertex attribute semantics
     * @param params.onError - Optional error callback function
     * @returns The handle of the created shader program, or InvalidCGAPIResourceUid on failure
     * @throws Error if no WebGL context is available
     */
    createShaderProgram({ material, primitive, vertexShaderStr, fragmentShaderStr, attributeNames, attributeSemantics, onError, }: {
        material: Material;
        primitive: Primitive;
        vertexShaderStr: string;
        fragmentShaderStr: string;
        attributeNames: AttributeNames;
        attributeSemantics: VertexAttributeEnum[];
        onError?: (message: string) => void;
    }): WebGPUResourceHandle;
    /**
     * Validates shader compilation status and logs errors if compilation fails.
     *
     * @param materialTypeName - The name of the material type for error context
     * @param shader - The compiled shader object to check
     * @param shaderText - The shader source code for error reporting
     * @param onError - Optional error callback function
     * @returns True if compilation succeeded, false otherwise
     */
    private __checkShaderCompileStatus;
    /**
     * Validates shader program linking status and logs errors if linking fails.
     *
     * @param materialTypeName - The name of the material type for error context
     * @param shaderProgram - The linked shader program to check
     * @param vertexShaderText - The vertex shader source code for error reporting
     * @param fragmentShaderText - The fragment shader source code for error reporting
     * @returns True if linking succeeded, false otherwise
     */
    private __checkShaderProgramLinkStatus;
    /**
     * Sets up uniform locations for a shader program based on shader semantics information.
     * This method extracts uniform locations from the compiled shader program and stores them
     * for efficient access during rendering.
     *
     * @param shaderProgramUid - The handle of the shader program
     * @param infoArray - Array of shader semantics information
     * @param isUniformOnlyMode - Whether to set up only uniform locations
     * @returns The WebGL program object with configured uniform locations
     */
    setupUniformLocations(shaderProgramUid: WebGLResourceHandle, infoArray: ShaderSemanticsInfo[], isUniformOnlyMode: boolean): WebGLProgram;
    /**
     * Sets up basic uniform locations required for data texture operations.
     *
     * @param shaderProgramUid - The handle of the shader program to configure
     */
    setupBasicUniformLocations(shaderProgramUid: WebGLResourceHandle): void;
    /**
     * Sets a uniform value for texture binding and binds the texture to the appropriate slot.
     *
     * @param shaderProgram_ - The shader program to set the uniform for
     * @param semanticStr - The semantic string identifying the uniform
     * @param value - The value array containing texture slot index and texture data
     */
    setUniform1iForTexture(shaderProgram_: WebGLProgram, semanticStr: string, value: any): void;
    /**
     * Sets a uniform value in the shader program with automatic type detection and conversion.
     * This method handles various composition types including matrices, vectors, and textures.
     *
     * @param shaderProgram_ - The shader program to set the uniform for
     * @param semanticStr - The semantic string identifying the uniform
     * @param firstTime - Whether this is the first time setting this uniform
     * @param value - The value to set (can be scalar, vector, matrix, or texture data)
     * @returns True if the uniform was successfully set, false otherwise
     */
    setUniformValue(shaderProgram_: WebGLProgram, semanticStr: string, _firstTime: boolean, value: any): boolean;
    /**
     * Binds textures and samplers based on the composition type information.
     * This method handles different texture types including 2D, cube, and texture arrays.
     *
     * @param info - The shader semantics info containing composition type details
     * @param value - Array containing texture slot, texture object, and sampler
     */
    bindTexture(info: ShaderSemanticsInfo, value: [number, AbstractTexture, Sampler]): void;
    /**
     * Internal method for setting uniform values with proper WebGL calls based on data type.
     * This method handles the actual WebGL uniform* calls with appropriate type conversion.
     *
     * @param shaderProgram - The shader program to set the uniform for
     * @param semanticStr - The semantic string identifying the uniform
     * @param info - The shader semantics information
     * @param isMatrix - Whether the value is a matrix
     * @param componentNumber - Number of components in the value
     * @param isVector - Whether the value is a vector/array
     * @param param6 - Object containing the value components
     * @param param6.x - Primary value component
     * @param param6.y - Second value component (optional)
     * @param param6.z - Third value component (optional)
     * @param param6.w - Fourth value component (optional)
     * @returns True if the uniform was successfully set, false if location not found
     */
    setUniformValueInner(shaderProgram: WebGLProgram, semanticStr: string, info: ShaderSemanticsInfo, isMatrix: boolean, componentNumber: number, isVector: boolean, { x, y, z, w, }: {
        x: number | ArrayType | boolean;
        y?: number | boolean;
        z?: number | boolean;
        w?: number | boolean;
    }): boolean;
    /**
     * Configures vertex data for rendering by setting up VAO with VBOs and IBO.
     * This method binds vertex arrays, index buffers, and configures vertex attribute pointers.
     *
     * @param handles - Object containing VAO, IBO, and VBO handles
     * @param handles.vaoHandle - Handle to the vertex array object
     * @param handles.iboHandle - Handle to the index buffer object (optional)
     * @param handles.vboHandles - Array of vertex buffer object handles
     * @param primitive - The primitive object containing vertex attribute information
     * @param instanceIDBufferUid - Handle to instance ID buffer for instanced rendering (optional)
     * @throws Error if required buffers are not found
     */
    setVertexDataToPipeline({ vaoHandle, iboHandle, vboHandles, }: {
        vaoHandle: WebGLResourceHandle;
        iboHandle?: WebGLResourceHandle;
        vboHandles: Array<WebGLResourceHandle>;
    }, primitive: Primitive, instanceIDBufferUid?: WebGLResourceHandle): void;
    /**
     * Creates a 2D texture with immutable storage using texStorage2D.
     * This method allocates texture storage with the specified parameters.
     *
     * @param params - Configuration object for texture creation
     * @param params.levels - Number of mipmap levels to allocate
     * @param params.internalFormat - Internal format of the texture
     * @param params.width - Width of the texture
     * @param params.height - Height of the texture
     * @returns The handle of the created texture
     */
    createTexStorage2D({ levels, internalFormat, width, height, }: {
        levels: Index;
        internalFormat: TextureParameterEnum | PixelFormatEnum;
        width: Size;
        height: Size;
    }): WebGLResourceHandle;
    /**
     * Creates a new texture sampler with the specified filtering and wrapping parameters.
     *
     * @param params - Configuration object for sampler creation
     * @param params.magFilter - Magnification filter mode
     * @param params.minFilter - Minification filter mode
     * @param params.wrapS - Wrapping mode for S coordinate
     * @param params.wrapT - Wrapping mode for T coordinate
     * @param params.wrapR - Wrapping mode for R coordinate
     * @param params.anisotropy - Whether to enable anisotropic filtering
     * @param params.shadowCompareMode - Whether to enable shadow comparison mode
     * @returns The handle of the created sampler
     */
    createTextureSampler({ magFilter, minFilter, wrapS, wrapT, wrapR, anisotropy, shadowCompareMode, }: {
        magFilter: TextureParameterEnum;
        minFilter: TextureParameterEnum;
        wrapS: TextureParameterEnum;
        wrapT: TextureParameterEnum;
        wrapR: TextureParameterEnum;
        anisotropy: boolean;
        shadowCompareMode: boolean;
    }): number;
    /**
     * Creates or returns an existing texture sampler with clamp-to-edge wrapping and linear filtering.
     * This method implements a singleton pattern for commonly used sampler configurations.
     *
     * @returns The handle of the clamp-to-edge linear sampler
     */
    createOrGetTextureSamplerClampToEdgeLinear(): number;
    /**
     * Creates or returns an existing texture sampler with clamp-to-edge wrapping and nearest filtering.
     * This method implements a singleton pattern for commonly used sampler configurations.
     *
     * @returns The handle of the clamp-to-edge nearest sampler
     */
    createOrGetTextureSamplerClampToEdgeNearest(): number;
    /**
     * Creates or returns an existing texture sampler with repeat wrapping and nearest filtering.
     * This method implements a singleton pattern for commonly used sampler configurations.
     *
     * @returns The handle of the repeat nearest sampler
     */
    createOrGetTextureSamplerRepeatNearest(): number;
    /**
     * Creates or returns an existing texture sampler with repeat wrapping and linear filtering.
     * This method implements a singleton pattern for commonly used sampler configurations.
     *
     * @returns The handle of the repeat linear sampler
     */
    createOrGetTextureSamplerRepeatLinear(): number;
    /**
     * Creates or returns an existing texture sampler with repeat wrapping and trilinear filtering.
     * This method implements a singleton pattern for commonly used sampler configurations.
     *
     * @returns The handle of the repeat trilinear sampler
     */
    createOrGetTextureSamplerRepeatTriLinear(): number;
    /**
     * Creates or returns an existing texture sampler configured for shadow mapping.
     * This sampler uses nearest filtering and enables shadow comparison functionality.
     *
     * @returns The handle of the shadow sampler
     */
    createOrGetTextureSamplerShadow(): number;
    /**
     * Creates or returns an existing texture sampler with repeat wrapping, anisotropic filtering, and linear filtering.
     * This method implements a singleton pattern for commonly used sampler configurations.
     *
     * @returns The handle of the repeat anisotropy linear sampler
     */
    createOrGetTextureSamplerRepeatAnisotropyLinear(): number;
    /**
     * Creates a 2D texture from ImageBitmap data with specified parameters.
     * This method allocates texture storage and uploads the image data to the GPU.
     *
     * @param imageData - The ImageBitmap or ImageBitmapSource data to upload
     * @param params - Configuration object for texture creation
     * @param params.internalFormat - Internal format of the texture
     * @param params.width - Width of the texture
     * @param params.height - Height of the texture
     * @param params.format - Pixel format of the source data
     * @param params.type - Data type of the source data
     * @param params.generateMipmap - Whether to generate mipmaps automatically
     * @returns Promise that resolves to the handle of the created texture
     */
    createTextureFromImageBitmapData(imageData: ImageBitmapData, { internalFormat, width, height, format, type, generateMipmap, }: {
        internalFormat: TextureFormatEnum;
        width: Size;
        height: Size;
        format: PixelFormatEnum;
        type: ComponentTypeEnum;
        generateMipmap: boolean;
    }): Promise<WebGLResourceHandle>;
    /**
     * Internal helper method for common texture setup operations.
     * This method handles mipmap generation and texture parameter setup.
     *
     * @param gl - The WebGL2 rendering context
     * @param width - Width of the texture
     * @param height - Height of the texture
     * @param generateMipmap - Whether to generate mipmaps
     */
    private __createTextureInner;
    /**
     * Creates a 2D texture from an HTML image element with specified parameters.
     * This method allocates texture storage and uploads the image data to the GPU.
     *
     * @param imageData - The HTML image element containing the image data
     * @param params - Configuration object for texture creation
     * @param params.internalFormat - Internal format of the texture
     * @param params.width - Width of the texture
     * @param params.height - Height of the texture
     * @param params.format - Pixel format of the source data
     * @param params.type - Data type of the source data
     * @param params.generateMipmap - Whether to generate mipmaps automatically
     * @returns Promise that resolves to the handle of the created texture
     */
    createTextureFromHTMLImageElement(imageData: HTMLImageElement, { internalFormat, width, height, format, type, generateMipmap, }: {
        internalFormat: TextureParameterEnum;
        width: Size;
        height: Size;
        format: PixelFormatEnum;
        type: ComponentTypeEnum;
        generateMipmap: boolean;
    }): Promise<WebGLResourceHandle>;
    /**
     * Creates a 2D texture array with specified dimensions and format.
     * Texture arrays allow storing multiple texture layers in a single texture object.
     *
     * @param width - Width of each texture layer
     * @param height - Height of each texture layer
     * @param arrayLength - Number of texture layers in the array
     * @param mipLevelCount - Number of mipmap levels
     * @param internalFormat - Internal format of the texture
     * @param format - Pixel format of the source data
     * @param type - Data type of the source data
     * @param imageData - Typed array containing the texture data
     * @returns The handle of the created texture array
     */
    createTextureArray(width: Size, height: Size, arrayLength: Size, mipLevelCount: Size, internalFormat: TextureFormatEnum, format: PixelFormatEnum, type: ComponentTypeEnum, imageData: TypedArray): CGAPIResourceHandle;
    /**
     * Allocates texture storage without uploading any image data.
     * This method creates an empty texture with the specified format and dimensions.
     *
     * @param params - Configuration object for texture allocation
     * @param params.format - Internal format of the texture
     * @param params.width - Width of the texture
     * @param params.height - Height of the texture
     * @param params.mipLevelCount - Number of mipmap levels to allocate
     * @returns The handle of the allocated texture
     */
    allocateTexture({ format, width, height, mipLevelCount, }: {
        format: TextureFormatEnum;
        width: Size;
        height: Size;
        mipLevelCount: Count;
    }): WebGLResourceHandle;
    /**
     * Loads image data to a specific mip level of an existing 2D texture.
     * This method supports uploading data with row padding, extracting only the relevant pixels.
     *
     * @param params - Configuration object for image loading
     * @param params.mipLevel - The mip level to load the image to
     * @param params.textureUid - The handle of the target texture
     * @param params.format - The format of the image
     * @param params.type - The data type of the image
     * @param params.xOffset - X offset of the copy region
     * @param params.yOffset - Y offset of the copy region
     * @param params.width - Width of the image to copy
     * @param params.height - Height of the image to copy
     * @param params.rowSizeByPixel - Size of each row in pixels (including padding)
     * @param params.data - The typed array containing the image data
     */
    loadImageToMipLevelOfTexture2D({ mipLevel, textureUid, format, type, xOffset, yOffset, width, height, rowSizeByPixel, data, }: {
        mipLevel: Index;
        textureUid: WebGLResourceHandle;
        format: TextureFormatEnum;
        type: ComponentTypeEnum;
        xOffset: number;
        yOffset: number;
        width: number;
        height: number;
        rowSizeByPixel: number;
        data: TypedArray;
    }): void;
    /**
     * Creates a 2D texture from a typed array with specified parameters.
     * This method is useful for creating textures from raw pixel data.
     *
     * @param imageData - The typed array containing the pixel data
     * @param params - Configuration object for texture creation
     * @param params.internalFormat - Internal format of the texture
     * @param params.width - Width of the texture
     * @param params.height - Height of the texture
     * @param params.format - Pixel format of the source data
     * @param params.type - Data type of the source data
     * @param params.generateMipmap - Whether to generate mipmaps automatically
     * @returns The handle of the created texture
     */
    createTextureFromTypedArray(imageData: TypedArray, { internalFormat, width, height, format, type, generateMipmap, }: {
        internalFormat: TextureFormatEnum;
        width: Size;
        height: Size;
        format: PixelFormatEnum;
        type: ComponentTypeEnum;
        generateMipmap: boolean;
    }): WebGLResourceHandle;
    /**
     * Creates a compressed texture from pre-transcoded texture data for multiple mip levels.
     * This method handles various compressed texture formats and uploads the data to GPU.
     *
     * @param textureDataArray - Array of texture data for each mipmap level
     * @param compressionTextureType - The compression format type (e.g., DXT, ETC, ASTC)
     * @returns Promise that resolves to the handle of the created compressed texture
     */
    createCompressedTexture(textureDataArray: TextureData[], compressionTextureType: CompressionTextureTypeEnum): Promise<WebGLResourceHandle>;
    /**
     * Creates a compressed texture from a Basis Universal file.
     * This method automatically detects the best compression format supported by the hardware
     * and transcodes the Basis file accordingly.
     *
     * @param basisFile - The Basis Universal file containing the compressed texture data
     * @param params - Configuration object for texture creation
     * @param params.border - Border width (must be 0 in WebGL)
     * @returns The handle of the created compressed texture
     */
    createCompressedTextureFromBasis(basisFile: BasisFile, { border, }: {
        border: Size;
    }): WebGLResourceHandle;
    /**
     * Decodes a specific image and mip level from a Basis Universal file to the target compression format.
     * This method handles the transcoding process from Basis format to hardware-specific formats.
     *
     * @param basisFile - The Basis Universal file containing the texture data
     * @param basisCompressionType - The target compression format to transcode to
     * @param imageIndex - Index of the image to decode (for texture arrays)
     * @param levelIndex - Mip level index to decode
     * @returns Uint8Array containing the transcoded texture data
     */
    private decodeBasisImage;
    /**
     * Creates a new framebuffer object for off-screen rendering.
     * Framebuffers are used for render-to-texture operations and post-processing effects.
     *
     * @returns The handle of the created framebuffer object
     */
    createFrameBufferObject(): number;
    /**
     * Attaches a color buffer (texture or renderbuffer) to a framebuffer object.
     * This method supports both regular textures and multiview VR textures.
     *
     * @param framebuffer - The framebuffer to attach to
     * @param attachmentIndex - The color attachment index (0-based)
     * @param renderable - The texture or renderbuffer to attach
     */
    attachColorBufferToFrameBufferObject(framebuffer: FrameBuffer, attachmentIndex: Index, renderable: IRenderable): void;
    /**
     * Attaches a specific layer of a texture array to a framebuffer object.
     * This method is useful for rendering to individual layers of a texture array.
     *
     * @param framebuffer - The framebuffer to attach to
     * @param attachmentIndex - The color attachment index (0-based)
     * @param renderable - The texture array to attach
     * @param layerIndex - The layer index within the texture array
     * @param mipLevel - The mip level to attach
     */
    attachColorBufferLayerToFrameBufferObject(framebuffer: FrameBuffer, attachmentIndex: Index, renderable: IRenderable, layerIndex: Index, mipLevel: Index): void;
    /**
     * Attaches a specific face of a cube texture to a framebuffer object.
     * This method is used for rendering to individual faces of cube maps.
     *
     * @param framebuffer - The framebuffer to attach to
     * @param attachmentIndex - The color attachment index (0-based)
     * @param faceIndex - The cube face index (0-5: +X, -X, +Y, -Y, +Z, -Z)
     * @param mipLevel - The mip level to attach
     * @param renderable - The cube texture to attach
     */
    attachColorBufferCubeToFrameBufferObject(framebuffer: FrameBuffer, attachmentIndex: Index, faceIndex: Index, mipLevel: Index, renderable: IRenderable): void;
    /**
     * Attaches a depth buffer to a framebuffer object.
     *
     * @param framebuffer - The framebuffer to attach to
     * @param renderable - The depth texture or renderbuffer to attach
     */
    attachDepthBufferToFrameBufferObject(framebuffer: FrameBuffer, renderable: IRenderable): void;
    /**
     * Attaches a stencil buffer to a framebuffer object.
     *
     * @param framebuffer - The framebuffer to attach to
     * @param renderable - The stencil texture or renderbuffer to attach
     */
    attachStencilBufferToFrameBufferObject(framebuffer: FrameBuffer, renderable: IRenderable): void;
    /**
     * Attaches a combined depth-stencil buffer to a framebuffer object.
     *
     * @param framebuffer - The framebuffer to attach to
     * @param renderable - The depth-stencil texture or renderbuffer to attach
     */
    attachDepthStencilBufferToFrameBufferObject(framebuffer: FrameBuffer, renderable: IRenderable): void;
    /**
     * Internal method for attaching depth or stencil buffers to framebuffers.
     * This method handles the common logic for depth, stencil, and depth-stencil attachments.
     *
     * @param framebuffer - The framebuffer to attach to
     * @param renderable - The texture or renderbuffer to attach
     * @param attachmentType - The WebGL attachment type constant
     */
    private __attachDepthOrStencilBufferToFrameBufferObject;
    /**
     * create Renderbuffer
     */
    createRenderBuffer(width: Size, height: Size, internalFormat: TextureParameterEnum, isMSAA: boolean, sampleCountMSAA: Count): number;
    /**
     * set drawTargets
     * @param framebuffer
     */
    setDrawTargets(renderPass: RenderPass): void;
    /**
     * bind Framebuffer
     * @param framebuffer
     */
    bindFramebuffer(framebuffer?: FrameBuffer): void;
    /**
     * unbind Framebuffer
     */
    unbindFramebuffer(): void;
    /**
     * create a RenderTargetTexture
     * @param param0
     * @returns
     */
    createRenderTargetTexture({ width, height, mipLevelCount, format, }: {
        width: Size;
        height: Size;
        mipLevelCount: Count;
        format: TextureParameterEnum;
    }): number;
    /**
     * create a RenderTargetTextureArray
     * @param param0
     * @returns
     */
    createRenderTargetTextureArray({ width, height, internalFormat, arrayLength, }: {
        width: Size;
        height: Size;
        internalFormat: TextureParameterEnum;
        arrayLength: Count;
    }): WebGLResourceHandle;
    /**
     * create a RenderTargetTextureCube
     * @param param0
     * @returns
     */
    createRenderTargetTextureCube({ width, height, mipLevelCount, format, }: {
        width: Size;
        height: Size;
        mipLevelCount: Size;
        format: TextureParameterEnum;
    }): number;
    /**
     * create a CubeTexture
     *
     * @param mipLevelCount
     * @param images
     * @param width
     * @param height
     * @returns resource handle
     */
    createCubeTexture(mipLevelCount: Count, images: Array<{
        posX: DirectTextureData;
        negX: DirectTextureData;
        posY: DirectTextureData;
        negY: DirectTextureData;
        posZ: DirectTextureData;
        negZ: DirectTextureData;
    }>, width: Size, height: Size): [number, Sampler];
    /**
     * Create Cube Texture from image files.
     * @param baseUri the base uri to load images;
     * @param mipLevelCount the number of mip levels (include root level). if no mipmap, the value should be 1;
     * @returns the WebGLResourceHandle for the generated Cube Texture
     */
    createCubeTextureFromFiles(baseUri: string, mipLevelCount: Count, isNamePosNeg: boolean, hdriFormat: HdriFormatEnum): Promise<[number, Sampler]>;
    createCubeTextureFromBasis(basisFile: BasisFile, { magFilter, minFilter, wrapS, wrapT, border, }: {
        magFilter?: TextureParameterEnum | undefined;
        minFilter?: TextureParameterEnum | undefined;
        wrapS?: TextureParameterEnum | undefined;
        wrapT?: TextureParameterEnum | undefined;
        border?: number | undefined;
    }): number;
    createDummyBlackCubeTexture(): [number, Sampler];
    createDummyCubeTexture(rgbaStr?: string): [number, Sampler];
    setWebGLTextureDirectly(webGLTexture: WebGLTexture): number;
    createTextureFromDataUri(dataUri: string, { internalFormat, format, type, generateMipmap, }: {
        internalFormat: TextureParameterEnum;
        format: PixelFormatEnum;
        type: ComponentTypeEnum;
        generateMipmap: boolean;
    }): Promise<WebGLResourceHandle>;
    updateLevel0TextureAndGenerateMipmap(textureUid: WebGLResourceHandle, textureData: DirectTextureData, { width, height, format, type, }: {
        width: Size;
        height: Size;
        format: PixelFormatEnum;
        type: ComponentTypeEnum;
    }): void;
    updateTexture(textureUid: WebGLResourceHandle, textureData: DirectTextureData, { level, width, height, format, type, }: {
        level: Index;
        width: Size;
        height: Size;
        format: PixelFormatEnum;
        type: ComponentTypeEnum;
    }): void;
    deleteFrameBufferObject(frameBufferObjectHandle: WebGLResourceHandle): void;
    deleteRenderBuffer(renderBufferUid: WebGLResourceHandle): void;
    deleteTexture(textureHandle: WebGLResourceHandle): void;
    createDummyTexture(rgbaStr?: string): Promise<number>;
    createDummyBlackTexture(): number;
    createDummyWhiteTexture(): number;
    createDummyNormalTexture(): number;
    __createDummyTextureInner(base64: string): number;
    generateMipmaps2d(textureHandle: WebGLResourceHandle, _width: number, _height: number): void;
    generateMipmapsCube(textureHandle: WebGLResourceHandle, _width: number, _height: number): void;
    getTexturePixelData(_textureHandle: WebGLResourceHandle, width: number, height: number, frameBufferUid: WebGLResourceHandle, colorAttachmentIndex: number): Promise<Uint8Array>;
    createUniformBuffer(bufferView: TypedArray | DataView): number;
    updateUniformBuffer(uboUid: WebGLResourceHandle, typedArray: TypedArray, offsetByte: Byte$1, arrayLength: Byte$1): void;
    bindUniformBlock(shaderProgramUid: WebGLResourceHandle, blockName: string, blockIndex: Index): void;
    bindUniformBufferBase(blockIndex: Index, uboUid: WebGLResourceHandle): void;
    deleteUniformBuffer(uboUid: WebGLResourceHandle): void;
    setupUniformBufferDataArea(typedArray?: TypedArray): number;
    getGlslRenderTargetBeginString(renderTargetNumber: number): string;
    getGlslDataUBODefinitionString(): string;
    getGlslDataUBOVec4SizeString(): string;
    createMultiviewFramebuffer(width: number, height: number, samples: number): [WebGLResourceHandle, WebGLResourceHandle];
    createTransformFeedback(): number;
    deleteTransformFeedback(transformFeedbackUid: WebGLResourceHandle): void;
    setViewport(viewport?: Vector4): void;
    clearFrameBuffer(renderPass: RenderPass): void;
    deleteVertexDataResources(vertexHandles: VertexHandles): void;
    deleteVertexArray(vaoHandle: WebGLResourceHandle): void;
    deleteVertexBuffer(vboUid: WebGLResourceHandle): void;
    resizeCanvas(width: Size, height: Size): void;
    getCanvasSize(): [Size, Size];
    switchDepthTest(flag: boolean): void;
    rebuildProgramBySpector(this: RnWebGLProgram, updatedVertexSourceCode: string, // The new vertex shader source
    updatedFragmentSourceCode: string, // The new fragment shader source
    onCompiled: (program: WebGLProgram) => void, // Callback triggered by your engine when the compilation is successful. It needs to send back the new linked program.
    onError: (message: string) => void): boolean;
    getPixelDataFromTexture(texUid: WebGLResourceHandle, x: number, y: number, width: number, height: number): Uint8Array<ArrayBuffer>;
    setWebGLStateToDefault(): void;
    unbindTextureSamplers(): void;
    isSupportMultiViewVRRendering(): boolean;
    blitToTexture2dFromTexture2dArray(srcTextureUid: WebGLResourceHandle, dstFboUid: WebGLResourceHandle, dstWidth: number, dstHeight: number): void;
    blitToTexture2dFromTexture2dArrayFake(srcTextureUid: WebGLResourceHandle, dstFboUid: WebGLResourceHandle, dstWidth: number, dstHeight: number): void;
    blitToTexture2dFromTexture2dArray2(srcTextureUid: WebGLResourceHandle, dstTextureUid: WebGLResourceHandle, dstWidth: number, dstHeight: number): void;
}

type Attributes = Map<VertexAttributeSemanticsJoinedString, Accessor>;
interface IAnyPrimitiveDescriptor {
    /** attach a rhodonite material to this plane(the default material is the classicUberMaterial */
    material?: Material;
}
interface PrimitiveDescriptor extends IAnyPrimitiveDescriptor {
    attributes: TypedArray[];
    attributeSemantics: VertexAttributeSemanticsJoinedString[];
    primitiveMode: PrimitiveModeEnum;
    indices?: TypedArray;
}
/**
 * Represents a geometric primitive with vertex attributes, materials, and rendering data.
 * A primitive is the basic building block for rendering 3D geometry.
 */
declare class Primitive extends RnObject {
    private __mode;
    private static __defaultMaterial?;
    private __material;
    private __materialVariants;
    private __currentVariantName;
    _prevMaterial: WeakRef<Material>;
    private __attributes;
    private __oIndices;
    private static __primitiveCount;
    private __primitiveUid;
    private __aabb;
    private __targets;
    private __vertexHandles?;
    private __mesh?;
    private static __primitives;
    _sortkey: PrimitiveSortKey;
    _viewDepth: number;
    private static __primitiveUidIdxHasMorph;
    private static __idxPrimitiveUidHasMorph;
    private static __primitiveCountHasMorph;
    private static __tmpVec3_0;
    private __latestPositionAccessorVersion;
    private __positionAccessorVersion;
    private static __variantUpdateCount;
    private __fingerPrint;
    /**
     * Creates a new Primitive instance.
     * Initializes the primitive with a default material if none exists.
     */
    constructor();
    /**
     * Calculates a unique fingerprint string for the primitive based on its properties.
     * The fingerprint includes mode, indices, targets, and attributes configuration.
     * This is used for efficient primitive comparison and caching.
     */
    calcFingerPrint(): void;
    /**
     * Gets the cached fingerprint string of the primitive.
     * @returns The fingerprint string used for primitive identification
     */
    _getFingerPrint(): string;
    /**
     * Gets the index of a primitive with morph targets by its UID.
     * @param primitiveUid - The unique identifier of the primitive
     * @returns The index if the primitive has morph targets, otherwise undefined
     */
    static getPrimitiveIdxHasMorph(primitiveUid: PrimitiveUID): Index | undefined;
    /**
     * Gets a primitive with morph targets by its index.
     * @param primitiveIdx - The index of the primitive in the morph targets collection
     * @returns The primitive if found and still exists, otherwise undefined
     */
    static getPrimitiveHasMorph(primitiveIdx: Index): Primitive | undefined;
    /**
     * Determines the bit size required for indices based on the index accessor type.
     * @returns 'uint16' for unsigned short/byte indices, 'uint32' for unsigned int indices
     * @throws Error if no index accessor exists or the component type is unsupported
     */
    getIndexBitSize(): 'uint16' | 'uint32';
    /**
     * Gets the vertex handles associated with this primitive for GPU resources.
     * @returns The vertex handles if they exist, otherwise undefined
     */
    get _vertexHandles(): VertexHandles | undefined;
    /**
     * Gets the current count of material variant updates across all primitives.
     * This counter is incremented whenever material variants are modified.
     * @returns The number of material variant updates since application start
     */
    static get variantUpdateCount(): number;
    /**
     * Registers a material variant for this primitive with a specific name.
     * Material variants allow switching between different materials at runtime.
     * @param variantName - The unique name for this material variant
     * @param material - The material to associate with the variant name
     */
    setMaterialVariant(variantName: string, material: Material): void;
    /**
     * Applies a previously registered material variant by its name.
     * Changes the current material to the variant if it exists.
     * @param variantName - The name of the variant to apply
     */
    applyMaterialVariant(variantName: string): void;
    /**
     * Gets the name of the currently applied material variant.
     * @returns The name of the active variant, or an empty string if no variant is active
     */
    getCurrentVariantName(): string;
    /**
     * Gets all registered variant names for this primitive.
     * @returns An array containing all variant names
     */
    getVariantNames(): string[];
    /**
     * Gets the material associated with a specific variant name.
     * @param variantName - The name of the variant to look up
     * @returns The material for the variant, or undefined if the variant doesn't exist
     */
    getVariantMaterial(variantName: string): Material | undefined;
    /**
     * Sets the material for this primitive and updates rendering sort keys.
     * The sort key is updated based on material properties for efficient rendering order.
     * @param mat - The material to assign to this primitive
     */
    set material(mat: Material);
    /**
     * Gets the current material assigned to this primitive.
     * @returns The material currently in use
     */
    get material(): Material;
    /**
     * Updates the sort key by setting a specific bit range with a value.
     * Sort keys are used to optimize rendering order for transparency and material batching.
     * @param offset - The bit offset position where to start writing
     * @param length - The number of bits to write
     * @param value - The value to encode in the specified bit range
     */
    setSortKey(offset: PrimitiveSortKeyOffset, length: PrimitiveSortKeyLength, value: number): void;
    /**
     * Associates this primitive with a parent mesh.
     * This establishes the hierarchical relationship between mesh and primitive.
     * @param mesh - The mesh that this primitive belongs to
     * @internal
     */
    _belongToMesh(mesh: Mesh): void;
    /**
     * Gets the mesh that this primitive belongs to.
     * @returns The parent mesh if it exists, otherwise undefined
     */
    get mesh(): IMesh | undefined;
    /**
     * Creates a backup of the current material for later restoration.
     * Used internally for material switching operations.
     * @internal
     */
    _backupMaterial(): void;
    /**
     * Restores the previously backed-up material if it still exists.
     * Used internally for reverting material changes.
     * @internal
     */
    _restoreMaterial(): void;
    /**
     * Retrieves a primitive instance by its unique identifier.
     * @param primitiveUid - The unique identifier of the primitive to find
     * @returns The primitive if found and still exists, otherwise undefined
     */
    static getPrimitive(primitiveUid: PrimitiveUID): Primitive | undefined;
    /**
     * Gets the total number of primitives created in the application.
     * @returns The total count of primitives
     */
    static getPrimitiveCount(): number;
    /**
     * Notifies the primitive that its position accessor has been updated.
     * This triggers recalculation of bounding boxes and mesh updates.
     * @param accessorVersion - The new version number of the updated accessor
     */
    onAccessorUpdated(accessorVersion: number): void;
    /**
     * Sets the vertex and index data for this primitive.
     * This is the main method for configuring primitive geometry and rendering properties.
     * @param attributes - Map of vertex attributes with their semantic meanings
     * @param mode - The primitive rendering mode (triangles, triangle strip, etc.)
     * @param material - Optional material to assign (uses default if not provided)
     * @param indicesAccessor - Optional index accessor for indexed rendering
     */
    setData(attributes: Attributes, mode: PrimitiveModeEnum, material?: Material, indicesAccessor?: Accessor): void;
    /**
     * Copies vertex data from a descriptor into this primitive.
     * Creates appropriate buffers and accessors for the provided data.
     * @param desc - Descriptor containing arrays of vertex data and configuration
     */
    copyVertexData({ attributes, attributeSemantics, primitiveMode, indices, material }: PrimitiveDescriptor): void;
    /**
     * Creates a new primitive from a descriptor containing vertex data.
     * This is a factory method that creates and initializes a primitive in one step.
     * @param desc - The primitive descriptor with vertex data and configuration
     * @returns A new primitive instance with the specified data
     */
    static createPrimitive(desc: PrimitiveDescriptor): Primitive;
    /**
     * Gets the index accessor for this primitive.
     * @returns The index accessor if indices are used, otherwise undefined
     */
    get indicesAccessor(): Accessor | undefined;
    /**
     * Gets the vertex count for indexed primitives.
     * For indexed rendering, this returns the number of indices.
     * @returns The number of indices if indexed, otherwise the vertex count
     */
    getVertexCountAsIndicesBased(): number;
    /**
     * Gets the vertex count based on vertex buffer data.
     * @returns The number of vertices in the vertex buffers
     */
    getVertexCountAsVerticesBased(): Count;
    /**
     * Calculates the triangle count for indexed primitives.
     * The count depends on the primitive mode (triangles, triangle strip, etc.).
     * @returns The number of triangles that will be rendered with indices
     */
    getTriangleCountAsIndicesBased(): Count;
    /**
     * Calculates the triangle count for non-indexed primitives.
     * The count depends on the primitive mode and vertex count.
     * @returns The number of triangles that will be rendered from vertices
     */
    getTriangleCountAsVerticesBased(): Count;
    /**
     * Checks if this primitive uses index-based rendering.
     * @returns True if the primitive has an index buffer, false otherwise
     */
    hasIndices(): boolean;
    /**
     * Gets all vertex attribute accessors for this primitive.
     * @returns An array of all attribute accessors
     */
    get attributeAccessors(): Array<Accessor>;
    /**
     * Gets a specific vertex attribute by its semantic meaning.
     * @param semantic - The semantic identifier for the attribute
     * @returns The accessor for the attribute, or undefined if not found
     */
    getAttribute(semantic: VertexAttributeSemanticsJoinedString): Accessor | undefined;
    /**
     * Gets all vertex attribute semantic identifiers.
     * @returns An array of all attribute semantic strings
     */
    get attributeSemantics(): Array<VertexAttributeSemanticsJoinedString>;
    /**
     * Gets an iterator for all attribute entries (semantic, accessor pairs).
     * @returns An iterator over attribute map entries
     */
    get attributeEntries(): MapIterator<[VertexAttributeSemanticsJoinedString, Accessor]>;
    /**
     * Gets the composition types of all vertex attributes.
     * @returns An array of composition types (Vec2, Vec3, Vec4, Scalar, etc.)
     */
    get attributeCompositionTypes(): Array<CompositionTypeEnum>;
    /**
     * Gets the component types of all vertex attributes.
     * @returns An array of component types (Float, UnsignedByte, etc.)
     */
    get attributeComponentTypes(): Array<ComponentTypeEnum>;
    /**
     * Gets the primitive rendering mode.
     * @returns The primitive mode enum (Triangles, TriangleStrip, etc.)
     */
    get primitiveMode(): PrimitiveModeEnum;
    /**
     * Gets the unique identifier for this primitive.
     * @returns The primitive's UID
     */
    get primitiveUid(): PrimitiveUID;
    /**
     * Gets the version number of the position accessor.
     * Used to track when position data has been updated.
     * @returns The current position accessor version
     */
    get positionAccessorVersion(): number;
    /**
     * Gets the axis-aligned bounding box for this primitive.
     * The AABB is calculated from position data and cached until positions change.
     * @returns The bounding box containing all vertices
     */
    get AABB(): AABB;
    /**
     * Sets or updates a vertex attribute for this primitive.
     * @param accessor - The accessor containing the attribute data
     * @param vertexSemantic - The semantic meaning of the attribute
     */
    setVertexAttribute(accessor: Accessor, vertexSemantic: VertexAttributeSemanticsJoinedString): void;
    /**
     * Removes the index buffer from this primitive, converting it to non-indexed rendering.
     */
    removeIndices(): void;
    /**
     * Sets the index buffer for this primitive, enabling indexed rendering.
     * @param accessor - The accessor containing index data
     */
    setIndices(accessor: Accessor): void;
    /**
     * Sets blend shape (morph) targets for this primitive.
     * Blend shapes allow vertex animation by interpolating between target positions.
     * @param targets - Array of attribute maps representing morph targets
     */
    setBlendShapeTargets(targets: Array<Attributes>): void;
    /**
     * Gets a copy of the blend shape targets for this primitive.
     * @returns A copy of the morph target array
     */
    getBlendShapeTargets(): Attributes[];
    /**
     * Gets the blend shape targets array.
     * @returns The array of morph target attributes
     */
    get targets(): Array<Attributes>;
    /**
     * Checks if this primitive uses blending (transparency) for rendering.
     * @returns True if the material has blending enabled, false otherwise
     */
    isBlend(): boolean;
    /**
     * Checks if this primitive is opaque (not transparent).
     * @returns True if the primitive is opaque, false if it uses blending
     */
    isOpaque(): boolean;
    /**
     * Creates GPU vertex and index buffers for this primitive.
     * This prepares the primitive for rendering by uploading data to the GPU.
     * @returns True if buffers were created, false if they already exist
     */
    create3DAPIVertexData(): boolean;
    /**
     * Updates the GPU vertex and index buffers with current data.
     * Used when vertex data has been modified and needs to be re-uploaded.
     * @returns True if buffers were updated, false if no buffers exist
     */
    update3DAPIVertexData(): boolean;
    /**
     * Deletes the GPU vertex and index buffers for this primitive.
     * Frees GPU memory when the primitive is no longer needed.
     * @returns True if buffers were deleted, false if no buffers exist
     */
    delete3DAPIVertexData(): boolean;
    /**
     * Gets the GPU resource handles for this primitive.
     * @returns The vertex handles for GPU resources, or undefined if not created
     */
    get vertexHandles(): VertexHandles | undefined;
    /**
     * Converts this indexed primitive to non-indexed geometry.
     * Expands vertex data by duplicating vertices according to indices.
     * This can increase memory usage but simplifies some rendering operations.
     */
    convertToUnindexedGeometry(): void;
    /**
     * Performs ray casting against this primitive's geometry.
     * Tests intersection between a ray and the triangles of this primitive.
     * @param origVec3 - The origin point of the ray
     * @param dirVec3 - The direction vector of the ray (should be normalized)
     * @param isFrontFacePickable - Whether front-facing triangles can be hit
     * @param isBackFacePickable - Whether back-facing triangles can be hit
     * @param dotThreshold - Threshold for determining front/back face orientation
     * @param hasFaceNormal - Whether to use face normals for culling
     * @returns Ray casting result with intersection data or failure indication
     */
    castRay(origVec3: IVector3, dirVec3: IVector3, isFrontFacePickable: boolean, isBackFacePickable: boolean, dotThreshold: number, hasFaceNormal: boolean): RaycastResultEx1;
    /**
     * Internal ray-triangle intersection test using Tomas Mller algorithm.
     * @param origVec3 - Ray origin
     * @param dirVec3 - Ray direction
     * @param i - Triangle index
     * @param pos0IndexBase - First vertex index
     * @param pos1IndexBase - Second vertex index
     * @param pos2IndexBase - Third vertex index
     * @param isFrontFacePickable - Whether front faces are pickable
     * @param isBackFacePickable - Whether back faces are pickable
     * @param dotThreshold - Normal dot product threshold
     * @param hasFaceNormal - Whether to use face normals
     * @returns Intersection result with barycentric coordinates
     * @private
     */
    private __castRayInnerTomasMoller;
    /**
     * Calculates the normal vector from UV coordinates
     * @param pos0IndexBase Index of first position
     * @param pos1IndexBase Index of second position
     * @param pos2IndexBase Index of third position
     * @param u U coordinate
     * @param v V coordinate
     * @returns The calculated normal vector
     */
    private __calcNormalFromUV;
}

/**
 * The Mesh class.
 * This mesh object has primitives (geometries) or a reference of 'original mesh'.
 * If the latter, this mesh object is an 'instanced mesh', which has no primitives.
 * Instanced meshes refer original mesh's primitives when drawing.
 */
declare class Mesh implements IMesh {
    private readonly __meshUID;
    static readonly invalidateMeshUID = -1;
    static __mesh_uid_count: number;
    private __primitives;
    private __opaquePrimitives;
    private __translucentPrimitives;
    private __blendWithZWritePrimitives;
    private __blendWithoutZWritePrimitives;
    private __morphPrimitives;
    private __localAABB;
    private __vaoUids;
    private __variationVBOUid;
    private __latestPrimitivePositionAccessorVersionForAABB;
    private __latestPrimitivePositionAccessorVersionForSetUpDone;
    private __belongToEntities;
    /**
     * Specification of when calculate the tangent of a vertex to apply Normal texture (for pbr/MToon shader)
     * 0: Not calculate tangent (not apply normal texture)
     * 1: (default) Use original tangent in a vertex, if a vertex has tangent attribute. If a vertex does not have it, calculate a tangent in a shader.
     * 2: Use original tangent in a vertex, if a vertex has tangent attribute. If a vertex does not have it, precalculate a tangent in the javascript.
     * 3: Calculate all tangent in a shader.
     * 4: Precalculate all tangent in the javascript
     */
    tangentCalculationMode: Index;
    private __hasFaceNormal;
    private static __tmpVec3_0;
    private static __tmpVec3_1;
    private static __tmpVec3_2;
    private static __tmpVec3_3;
    private static __tmpVec3_4;
    private static __tmpVec3_5;
    private static __tmpVec3_6;
    private static __tmpVec3_7;
    private static __tmpVec3_8;
    private static __tmpVec3_9;
    private static __tmpVec3_10;
    private static __tmpVec3_11;
    private static __tmpReturnVec3_0;
    private static __tmpReturnVec3_1;
    private static __tmpReturnVec3_2;
    private __primitivePositionUpdateCount;
    /**
     * Constructor
     */
    constructor();
    /**
     * Gets the VAO (Vertex Array Object) UID for the specified index.
     * @param index - The index of the primitive
     * @returns The VAO resource handle
     */
    getVaoUids(index: Index): CGAPIResourceHandle;
    /**
     * Gets the VAO (Vertex Array Object) UID for the specified primitive UID.
     * @param primitiveUid - The UID of the primitive
     * @returns The VAO resource handle
     */
    getVaoUidsByPrimitiveUid(primitiveUid: Index): CGAPIResourceHandle;
    /**
     * Gets the inner mesh entities that belong to this mesh.
     * @returns Array of mesh entities
     */
    get meshEntitiesInner(): IMeshEntity[];
    /**
     * Registers this mesh as belonging to a mesh component.
     * @param meshComponent - The mesh component that owns this mesh
     * @internal
     */
    _belongToMeshComponent(meshComponent: MeshComponent): void;
    /**
     * Adds primitive.
     * @param primitive The primitive object.
     */
    addPrimitive(primitive: Primitive): void;
    /**
     * Sets the array of primitives for this mesh.
     * @param primitives - Array of primitives to set
     * @private
     */
    private __setPrimitives;
    /**
     * Checks if this mesh has opaque primitives.
     * @returns True if opaque primitives exist, false otherwise
     */
    isExistOpaque(): boolean;
    /**
     * Checks if this mesh has translucent primitives.
     * @returns True if translucent primitives exist, false otherwise
     */
    isExistTranslucent(): boolean;
    /**
     * Checks if this mesh has blend-with-z-write primitives.
     * @returns True if blend-with-z-write primitives exist, false otherwise
     */
    isExistBlendWithZWrite(): boolean;
    /**
     * Checks if this mesh has blend-without-z-write primitives.
     * @returns True if blend-without-z-write primitives exist, false otherwise
     */
    isExistBlendWithoutZWrite(): boolean;
    /**
     * Gets the primitive at the specified index.
     * @param i - The index of the primitive to retrieve
     * @returns The primitive at the specified index
     */
    getPrimitiveAt(i: number): Primitive;
    /**
     * Gets the total number of primitives in this mesh.
     * @returns The number of primitives
     */
    getPrimitiveNumber(): number;
    /**
     * Updates the variation VBO (Vertex Buffer Object) for instancing.
     * @returns True if updated, false if not changed (not dirty)
     * @internal
     */
    updateVariationVBO(): boolean;
    /**
     * Deletes the variation VBO (Vertex Buffer Object).
     * @returns True if updated, false if not changed (not dirty)
     * @internal
     */
    deleteVariationVBO(): boolean;
    /**
     * Updates the VAO (Vertex Array Object) for all primitives in this mesh.
     */
    updateVAO(): void;
    /**
     * Deletes all VAO (Vertex Array Object) resources for this mesh.
     */
    deleteVAO(): void;
    /**
     * Performs ray casting against this mesh to find intersection points.
     * @param srcPointInLocal - The ray origin point in local space
     * @param directionInLocal - The ray direction in local space
     * @param dotThreshold - The dot product threshold for back-face culling (default: 0)
     * @returns Ray casting result with intersection information
     */
    castRay(srcPointInLocal: IVector3, directionInLocal: IVector3, dotThreshold?: number): RaycastResultEx1;
    /**
     * Gets the array of primitives in this mesh.
     * @returns Array of primitives
     */
    get primitives(): Primitive[];
    /**
     * Gets the unique identifier for this mesh.
     * @returns The mesh UID
     */
    get meshUID(): number;
    /**
     * Gets the variation VBO UID for internal use.
     * @returns The variation VBO resource handle
     * @internal
     */
    get _variationVBOUid(): CGAPIResourceHandle;
    /**
     * Called when primitive position data is updated.
     * Updates the position update counter and moves related entities to Load stage.
     * @internal
     */
    _onPrimitivePositionUpdated(): void;
    /**
     * Gets the primitive position update count.
     * @returns The number of times primitive positions have been updated
     */
    get primitivePositionUpdateCount(): number;
    /**
     * Gets AABB in local space.
     */
    get AABB(): AABB;
    /**
     * Calculates morph target primitives by blending vertex attributes.
     * @private
     */
    private __calcMorphPrimitives;
    /**
     * @internal
     */
    _calcTangents(): void;
    /**
     * Calculates tangent vectors for a triangle consisting of 3 vertices.
     * @param i - The starting vertex index
     * @param pos0 - Position of the first vertex
     * @param pos1 - Position of the second vertex
     * @param pos2 - Position of the third vertex
     * @param uv0 - UV coordinates of the first vertex
     * @param uv1 - UV coordinates of the second vertex
     * @param uv2 - UV coordinates of the third vertex
     * @param norm0 - Normal vector of the first vertex
     * @param tangentAccessor - Accessor for writing tangent data
     * @param indicesAccessor - Optional indices accessor
     * @private
     * @internal
     */
    private __calcTangentFor3Vertices;
    /**
     * Calculates the tangent vector for a single vertex.
     * @param pos0Vec3 - Position of the target vertex
     * @param pos1Vec3 - Position of the second vertex
     * @param pos2Vec3 - Position of the third vertex
     * @param uv0Vec2 - UV coordinates of the target vertex
     * @param uv1Vec2 - UV coordinates of the second vertex
     * @param uv2Vec2 - UV coordinates of the third vertex
     * @param norm0Vec3 - Normal vector of the target vertex
     * @param returnVec3 - Mutable vector to store the result
     * @returns The calculated tangent vector
     * @private
     */
    private __calcTangentPerVertex;
    /**
     * Determines whether to use pre-calculated tangent vectors based on the tangent calculation mode.
     * @returns True if tangent vectors should be pre-calculated, false otherwise
     * @private
     */
    private __usePreCalculatedTangent;
    /**
     * Calculates barycentric coordinates for all primitives in this mesh.
     * @internal
     */
    _calcBaryCentricCoord(): void;
    /**
     * Calculates face normals for primitives that don't have normal attributes.
     * @internal
     */
    _calcFaceNormalsIfNonNormal(): void;
    /**
     * Calculates face normals for a triangle consisting of 3 vertices.
     * @param i - The starting vertex index
     * @param pos0 - Position of the first vertex
     * @param pos1 - Position of the second vertex
     * @param pos2 - Position of the third vertex
     * @param normalAccessor - Accessor for writing normal data
     * @param indicesAccessor - Optional indices accessor
     * @private
     */
    private __calcFaceNormalFor3Vertices;
    /**
     * Gets the index of a primitive within this mesh.
     * @param primitive - The primitive to find the index of
     * @returns The index of the primitive in the mesh
     */
    getPrimitiveIndexInMesh(primitive: Primitive): number;
    /**
     * Apply a material variant to the mesh
     * @param variantName a variant name
     */
    applyMaterialVariant(variantName: string): void;
    /**
     * Gets the current material variant name applied to this mesh.
     * Returns empty string if no variant is applied or if primitives have different variants.
     * @returns The current variant name or empty string
     */
    getCurrentVariantName(): string;
    /**
     * Gets all available material variant names for this mesh.
     * @returns Array of variant names from all primitives
     */
    getVariantNames(): string[];
    /**
     * Checks if this mesh setup is completed and ready for rendering.
     * @returns True if setup is done, false otherwise
     */
    isSetUpDone(): boolean;
    /**
     * Updates VBO (Vertex Buffer Object) and VAO (Vertex Array Object) for all primitives.
     * @internal
     */
    _updateVBOAndVAO(): void;
    /**
     * Deletes all 3D API vertex data for this mesh.
     */
    delete3DAPIVertexData(): void;
}

/**
 * MeshComponent is a component that manages a mesh geometry for an entity.
 * It provides functionality for mesh management, ray casting, depth calculation,
 * and vertex data updates for 3D rendering.
 */
declare class MeshComponent extends Component {
    private __viewDepth;
    private __mesh?;
    isPickable: boolean;
    private static __tmpVector3_0;
    private static __tmpVector3_1;
    private static __tmpVector3_2;
    private static __returnVector3;
    private static __tmpMatrix44_0;
    private static __latestPrimitivePositionAccessorVersion;
    /**
     * Gets the component type identifier for MeshComponent.
     * @returns The component type ID for mesh components
     */
    static get componentTID(): ComponentTID;
    /**
     * Gets the component type identifier for this instance.
     * @returns The component type ID for mesh components
     */
    get componentTID(): ComponentTID;
    /**
     * Associates a mesh with this component.
     * @param mesh - The mesh to be assigned to this component
     */
    setMesh(mesh: Mesh): void;
    /**
     * Removes the mesh association from this component.
     * @returns True if a mesh was successfully unset, false if no mesh was set
     */
    unsetMesh(): boolean;
    /**
     * Gets the mesh associated with this component.
     * @returns The mesh instance, or undefined if no mesh is set
     */
    get mesh(): Mesh | undefined;
    /**
     * Calculates the view depth of the mesh center from the given camera's perspective.
     * This is used for depth sorting and rendering order determination.
     * @param cameraComponent - The camera component to calculate depth from
     * @returns The depth value in view space (negative Z value), or Number.MAX_VALUE if no mesh is set
     */
    calcViewDepth(cameraComponent: CameraComponent): number;
    /**
     * Gets the cached view depth value.
     * @returns The current view depth value
     */
    get viewDepth(): number;
    /**
     * Logs a debug message when no mesh is set on a MeshComponent.
     * @param meshComponent - The mesh component instance to log about
     */
    static alertNoMeshSet(meshComponent: MeshComponent): void;
    /**
     * Performs ray casting against the mesh geometry in world space.
     * @param srcPointInWorld - The ray origin point in world coordinates
     * @param directionInWorld - The ray direction vector in world coordinates
     * @param dotThreshold - The dot product threshold for face culling (default: 0)
     * @returns Ray casting result with intersection information
     */
    castRay(srcPointInWorld: Vector3, directionInWorld: Vector3, dotThreshold?: number): RaycastResultEx1;
    /**
     * Performs ray casting from screen coordinates against the mesh in local space.
     * @param x - The X coordinate in screen space
     * @param y - The Y coordinate in screen space
     * @param camera - The camera component for projection calculations
     * @param viewport - The viewport dimensions as Vector4 (x, y, width, height)
     * @param dotThreshold - The dot product threshold for face culling (default: 0)
     * @returns Ray casting result with intersection information in local space
     */
    castRayFromScreenInLocal(x: number, y: number, camera: CameraComponent, viewport: Vector4, dotThreshold?: number): RaycastResultEx1;
    /**
     * Performs ray casting from screen coordinates against the mesh in world space.
     * @param x - The X coordinate in screen space
     * @param y - The Y coordinate in screen space
     * @param camera - The camera component for projection calculations
     * @param viewport - The viewport dimensions as Vector4 (x, y, width, height)
     * @param dotThreshold - The dot product threshold for face culling (default: 0)
     * @returns Ray casting result with intersection information in world space
     */
    castRayFromScreenInWorld(x: number, y: number, camera: CameraComponent, viewport: Vector4, dotThreshold?: number): RaycastResultEx1;
    /**
     * Loads and initializes the mesh data, performing necessary calculations.
     * This method calculates tangents, face normals, and barycentric coordinates
     * if blend shapes are present, then moves to the Logic processing stage.
     */
    $load(): void;
    /**
     * Updates the 3D API vertex data by recreating VBO and VAO.
     * This is called internally when vertex data needs to be refreshed.
     * @private
     */
    private __update3DAPIVertexData;
    /**
     * Calculates barycentric coordinates for all mesh primitives.
     * This converts indexed geometry to unindexed geometry and updates
     * the 3D API vertex data afterwards.
     */
    calcBaryCentricCoord(): void;
    /**
     * Logic processing stage method. Currently empty but can be overridden
     * for custom logic processing during the component's lifecycle.
     */
    $logic(): void;
    /**
     * Performs a shallow copy of data from another MeshComponent.
     * @param component_ - The source component to copy from
     * @protected
     */
    _shallowCopyFrom(component_: Component): void;
    /**
     * Destroys the component and cleans up resources.
     * @protected
     */
    _destroy(): void;
    /**
     * Gets the entity which has this component with proper typing.
     * @returns The entity which has this component as an IMeshEntity
     */
    get entity(): IMeshEntity;
    /**
     * Adds this component to an entity by extending the entity class with mesh-specific methods.
     * This method applies mixins to add getMesh() method to the target entity.
     * @param base - The target entity to extend
     * @param _componentClass - The component class to add (not used but required by interface)
     * @returns The extended entity with mesh component methods
     * @template EntityBase - The base entity type
     * @template SomeComponentClass - The component class type
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBase, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBase;
}

interface IMeshEntityMethods {
    getMesh(): MeshComponent;
}

/**
 * MeshRendererComponent is a component that manages the rendering of a mesh entity.
 * It handles mesh rendering pipeline, IBL (Image-Based Lighting) cube maps, frustum culling,
 * and rendering optimization through various strategies.
 */
declare class MeshRendererComponent extends Component {
    private __diffuseCubeMap?;
    private __specularCubeMap?;
    private __sheenCubeMap?;
    private __diffuseCubeMapContribution;
    private __specularCubeMapContribution;
    private __rotationOfCubeMap;
    private static __cgApiRenderingStrategy?;
    static isDepthMaskTrueForBlendPrimitives: boolean;
    static __shaderProgramHandleOfPrimitiveObjectUids: Map<ObjectUID, CGAPIResourceHandle>;
    private __updateCount;
    private static __updateCount;
    static _isFrustumCullingEnabled: boolean;
    private __fingerPrint;
    /**
     * Creates a new MeshRendererComponent instance.
     * @param entityUid - The unique identifier of the entity this component belongs to
     * @param componentSid - The component's system identifier
     * @param entityRepository - The repository managing entities
     * @param isReUse - Whether this component is being reused from a pool
     */
    constructor(entityUid: EntityUID, componentSid: ComponentSID, entityRepository: EntityRepository, isReUse: boolean);
    /**
     * Gets the component type ID for MeshRendererComponent.
     * @returns The component type ID
     */
    static get componentTID(): ComponentTID;
    /**
     * Gets the component type ID for this instance.
     * @returns The component type ID
     */
    get componentTID(): ComponentTID;
    /**
     * Gets the diffuse cube map used for IBL lighting.
     * @returns The diffuse cube map texture or undefined if not set
     */
    get diffuseCubeMap(): CubeTexture | RenderTargetTextureCube | undefined;
    /**
     * Gets the specular cube map used for IBL lighting.
     * @returns The specular cube map texture or undefined if not set
     */
    get specularCubeMap(): CubeTexture | RenderTargetTextureCube | undefined;
    /**
     * Gets the sheen cube map used for IBL lighting.
     * @returns The sheen cube map texture or undefined if not set
     */
    get sheenCubeMap(): CubeTexture | RenderTargetTextureCube | undefined;
    /**
     * Gets the update count for this component instance.
     * @returns The current update count
     */
    get updateCount(): number;
    /**
     * Gets the global update count for all MeshRendererComponent instances.
     * @returns The global update count
     */
    static get updateCount(): number;
    /**
     * Gets the contribution factor for the diffuse cube map in IBL calculations.
     * @returns The diffuse cube map contribution factor (0.0 to 1.0)
     */
    get diffuseCubeMapContribution(): number;
    /**
     * Sets the contribution factor for the diffuse cube map in IBL calculations.
     * @param contribution - The contribution factor (0.0 to 1.0)
     */
    set diffuseCubeMapContribution(contribution: number);
    /**
     * Gets the contribution factor for the specular cube map in IBL calculations.
     * @returns The specular cube map contribution factor (0.0 to 1.0)
     */
    get specularCubeMapContribution(): number;
    /**
     * Sets the contribution factor for the specular cube map in IBL calculations.
     * @param contribution - The contribution factor (0.0 to 1.0)
     */
    set specularCubeMapContribution(contribution: number);
    /**
     * Gets the rotation angle of the cube map in radians.
     * @returns The rotation angle in radians
     */
    get rotationOfCubeMap(): number;
    /**
     * Sets the rotation angle of the cube map in radians.
     * @param rotation - The rotation angle in radians
     */
    set rotationOfCubeMap(rotation: number);
    /**
     * Calculates and updates the fingerprint for this component based on current cube map settings.
     * The fingerprint is used for caching and optimization purposes.
     */
    calcFingerPrint(): void;
    /**
     * Gets the current fingerprint of this component.
     * @returns The fingerprint string
     */
    getFingerPrint(): string;
    /**
     * Sets the IBL (Image-Based Lighting) cube maps for this mesh renderer.
     * @param diffuseCubeTexture - The diffuse cube map texture for IBL
     * @param specularCubeTexture - The specular cube map texture for IBL
     * @param sheenCubeTexture - Optional sheen cube map texture for IBL
     */
    setIBLCubeMap(diffuseCubeTexture: CubeTexture | RenderTargetTextureCube, specularCubeTexture: CubeTexture | RenderTargetTextureCube, sheenCubeTexture?: CubeTexture | RenderTargetTextureCube): void;
    /**
     * Common loading method that initializes the rendering strategy based on the process approach.
     * This method sets up either WebGPU or WebGL rendering strategies.
     * @param processApproach - The graphics API approach to use (WebGPU or WebGL)
     */
    static common_$load({ processApproach }: {
        processApproach: ProcessApproachEnum;
    }): void;
    /**
     * Loads and initializes this mesh renderer component.
     * Sets up the component for rendering by loading the associated mesh.
     */
    $load(): void;
    /**
     * Sorts and filters mesh components for rendering based on camera frustum and material properties.
     * Performs frustum culling and sorts primitives by render order and depth.
     * @param renderPass - The render pass containing mesh components and rendering context
     * @returns Array of primitive UIDs sorted for optimal rendering
     */
    static sort_$render(renderPass: RenderPass): ComponentSID[];
    /**
     * Performs frustum culling on mesh components using the camera's view frustum.
     * Filters out mesh components that are not visible from the camera's perspective.
     * @param cameraComponent - The camera component used for frustum culling
     * @param meshComponents - Array of mesh components to be culled
     * @returns Array of primitives that passed the frustum culling test
     */
    private static __cullingWithViewFrustum;
    /**
     * Common pre-rendering setup method that prepares the rendering strategy.
     * Initializes the rendering strategy if not already set and calls its prerender method.
     */
    static common_$prerender(): void;
    /**
     * Common rendering method that executes the actual rendering of primitives.
     * Delegates to the appropriate rendering strategy (WebGL or WebGPU).
     * @param renderPass - The render pass context
     * @param processStage - The current process stage
     * @param renderPassTickCount - The tick count for this render pass
     * @param primitiveUids - Array of primitive UIDs to render
     * @returns True if rendering was successful, false otherwise
     */
    static common_$render({ renderPass, renderPassTickCount, primitiveUids, }: {
        renderPass: RenderPass;
        renderPassTickCount: Count;
        primitiveUids: PrimitiveUID[];
    }): boolean;
    /**
     * Instance-specific render method for this mesh renderer component.
     * Currently empty as rendering is handled by the static common_$render method.
     * @param i - The index of this component in the render queue
     * @param renderPass - The render pass context
     * @param renderPassTickCount - The tick count for this render pass
     */
    $render(): void;
    /**
     * Performs a shallow copy of properties from another MeshRendererComponent.
     * Copies cube map settings and contributions without deep cloning the textures.
     * @param component_ - The source component to copy from
     */
    _shallowCopyFrom(component_: Component): void;
    /**
     * Destroys this component and cleans up its resources.
     * Clears cube map references and calls the parent destroy method.
     */
    _destroy(): void;
    /**
     * Adds the MeshRenderer component functionality to an entity class.
     * This method extends the entity base class with mesh renderer specific methods.
     * @param base - The target entity base class
     * @param _componentClass - The component class to add (unused parameter for type safety)
     * @returns The enhanced entity class with mesh renderer methods
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBase, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBase;
}

interface IMeshRendererEntityMethods {
    getMeshRenderer(): MeshRendererComponent;
}

interface PhysicsStrategy {
    update(): void;
}

/**
 * PhysicsComponent is a component that manages the physics simulation for an entity.
 * It provides integration with physics engines through the strategy pattern and handles
 * physics updates during the logic processing stage.
 */
declare class PhysicsComponent extends Component {
    private __strategy?;
    /**
     * Creates a new PhysicsComponent instance.
     * @param entityUid - The unique identifier of the entity this component belongs to
     * @param componentSid - The component's serial identifier
     * @param entityComponent - The entity repository managing this component
     * @param isReUse - Whether this component is being reused from a pool
     */
    constructor(entityUid: EntityUID, componentSid: ComponentSID, entityComponent: EntityRepository, isReUse: boolean);
    /**
     * Gets the component type identifier for PhysicsComponent.
     * @returns The component type ID for physics components
     */
    static get componentTID(): ComponentTID;
    /**
     * Gets the component type identifier for this instance.
     * @returns The component type ID for physics components
     */
    get componentTID(): ComponentTID;
    /**
     * Sets the physics strategy for this component.
     * The strategy defines how physics calculations and updates are performed.
     * @param strategy - The physics strategy to use for this component
     */
    setStrategy(strategy: PhysicsStrategy): void;
    /**
     * Gets the current physics strategy used by this component.
     * @returns The physics strategy instance, or undefined if none is set
     */
    get strategy(): PhysicsStrategy | undefined;
    /**
     * Common logic method that updates the global physics simulation.
     * This is called once per frame for all physics components and handles
     * the overall physics world update using the Oimo physics engine.
     */
    static common_$logic(): void;
    /**
     * Instance-specific logic method that updates this component's physics.
     * Called during the logic processing stage to update individual physics entities.
     */
    $logic(): void;
    /**
     * Destroys this physics component and cleans up resources.
     * Calls the parent destroy method and clears the physics strategy reference.
     * @override
     */
    _destroy(): void;
    /**
     * Adds physics functionality to an entity by mixing in physics-specific methods.
     * This method extends the base entity class with physics-related capabilities,
     * allowing the entity to access its physics component through a convenient getter.
     * @template EntityBase - The base entity type to extend
     * @template SomeComponentClass - The component class type
     * @param base - The target entity to add physics functionality to
     * @param _componentClass - The component class being added (used for type inference)
     * @returns The enhanced entity with physics methods and the original entity functionality
     * @override
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBase, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBase;
}

interface IPhysicsEntityMethods {
    getPhysics(): PhysicsComponent;
}

interface ISceneGraphEntityMethods {
    getSceneGraph(): SceneGraphComponent;
    parent?: SceneGraphComponent;
    matrix: IMatrix44;
    matrixInner: IMatrix44;
    position: IVector3;
    positionRest: IVector3;
    scale: IVector3;
    eulerAngles: IVector3;
    rotation: IQuaternion;
    rotationRest: IQuaternion;
    addChild(sg: SceneGraphComponent): void;
    children: SceneGraphComponent[];
    removeChild(sg: SceneGraphComponent): void;
}

interface ISkeletalEntityMethods {
    getSkeletal(): SkeletalComponent;
}

/**
 * Expression class manages the rendering pipeline by defining the order and sequence of render passes.
 * It acts as a container that orchestrates multiple render passes to create complex rendering effects.
 *
 * @example
 * ```typescript
 * const expression = new Expression();
 * expression.addRenderPasses([shadowPass, mainPass, postProcessPass]);
 * ```
 */
declare class Expression extends RnObject {
    private __renderPasses;
    /**
     * Creates a deep copy of this Expression instance.
     * All render passes are cloned individually to ensure complete independence.
     *
     * @returns A new Expression instance with cloned render passes
     */
    clone(): Expression;
    /**
     * Appends multiple render passes to the end of the current render pass sequence.
     * The order of render passes determines the rendering pipeline execution order.
     *
     * @param renderPasses - Array of RenderPass instances to be added
     */
    addRenderPasses(renderPasses: RenderPass[]): void;
    /**
     * Removes all render passes from this expression.
     * This effectively resets the expression to an empty state.
     */
    clearRenderPasses(): void;
    /**
     * Gets a read-only reference to the array of render passes in this expression.
     * The render passes are returned in the order they will be executed.
     *
     * @returns Array of RenderPass instances in execution order
     */
    get renderPasses(): RenderPass[];
    /**
     * Sets the viewport dimensions for all render passes in this expression.
     * This is a convenience method to apply the same viewport to all passes at once.
     *
     * @param viewport - Vector4 containing viewport coordinates (x, y, width, height)
     */
    setViewport(viewport: IVector4): void;
}

declare class Bloom {
    private __mapReducedFramebuffer;
    private __mapDetectHighLuminanceFramebuffer;
    private __mapSynthesizeFramebuffer;
    /**
     * Creates a complete bloom effect expression with all required render passes.
     *
     * The bloom effect consists of three main stages:
     * 1. Detect high luminance areas in the input texture
     * 2. Apply multiple levels of Gaussian blur to create a glow effect
     * 3. Synthesize the original texture with the blurred high luminance areas
     *
     * @param params - Configuration object for the bloom effect
     * @param params.textureToBloom - The source texture to apply bloom effect to
     * @param params.parameters - Bloom effect parameters
     * @param params.parameters.luminanceCriterion - Threshold for detecting high luminance areas (default: 1.0)
     * @param params.parameters.gaussianBlurLevelHighLuminance - Number of blur levels to apply (default: 4)
     * @param params.parameters.gaussianKernelSize - Size of the Gaussian blur kernel (default: 10)
     * @param params.parameters.gaussianVariance - Variance of the Gaussian distribution (default: 10)
     * @param params.parameters.synthesizeCoefficient - Blend coefficients for combining blur levels (default: computed array)
     * @returns Object containing the bloom expression and the final render target texture
     */
    createBloomExpression({ textureToBloom, parameters: { luminanceCriterion, gaussianBlurLevelHighLuminance, gaussianKernelSize, gaussianVariance, synthesizeCoefficient, }, }: {
        textureToBloom: AbstractTexture;
        parameters: {
            luminanceCriterion?: number;
            gaussianBlurLevelHighLuminance?: number;
            gaussianKernelSize?: number;
            gaussianVariance?: number;
            synthesizeCoefficient?: [number, number, number, number, number, number];
        };
    }): {
        bloomExpression: Expression;
        bloomedRenderTarget: RenderTargetTexture;
    };
    /**
     * Creates a render pass that detects high luminance areas in the input texture.
     *
     * This is the first stage of the bloom effect where pixels with luminance above
     * the specified criterion are extracted for further processing.
     *
     * @param texture - The input texture to analyze for high luminance areas
     * @param luminanceCriterion - The threshold value for detecting high luminance pixels
     * @returns A render pass configured to detect high luminance areas
     * @private
     */
    private __createRenderPassDetectHighLuminance;
    /**
     * Creates multiple render passes for applying Gaussian blur to high luminance areas.
     *
     * This method generates a series of blur passes with progressively reduced resolution
     * to create a multi-level bloom effect. Each level applies horizontal and vertical
     * blur passes to achieve a 2D Gaussian blur.
     *
     * @param renderPassHighLuminance - The render pass containing high luminance detection results
     * @param gaussianBlurLevelHighLuminance - Number of blur levels to generate
     * @param gaussianKernelSize - Size of the Gaussian blur kernel
     * @param gaussianVariance - Variance parameter for the Gaussian distribution
     * @param maxResolutionWidth - Maximum width for blur calculations
     * @param maxResolutionHeight - Maximum height for blur calculations
     * @returns Array of render passes for multi-level Gaussian blur
     * @private
     */
    private __createRenderPassesBlurredHighLuminance;
    /**
     * Creates a single Gaussian blur render pass.
     *
     * This method creates either a horizontal or vertical blur pass using a Gaussian
     * kernel. Two passes (horizontal + vertical) are typically combined to achieve
     * a full 2D Gaussian blur effect.
     *
     * @param renderPassBlurTarget - The source render pass to blur
     * @param gaussianKernelSize - Size of the Gaussian blur kernel
     * @param gaussianVariance - Variance parameter for the Gaussian distribution
     * @param isHorizontal - Whether this is a horizontal (true) or vertical (false) blur pass
     * @param resolutionWidthBlur - Width of the blur render target
     * @param resolutionHeightBlur - Height of the blur render target
     * @returns A configured Gaussian blur render pass
     * @private
     */
    private __createRenderPassGaussianBlur;
    /**
     * Creates a render pass that synthesizes the original texture with blurred high luminance areas.
     *
     * This is the final stage of the bloom effect where the original image is combined
     * with multiple levels of blurred high luminance areas using specified blend coefficients.
     * The result is a bloomed image with HDR-like glow effects.
     *
     * @param texture - The original input texture
     * @param renderPassesBlurredHighLuminance - Array of render passes containing blurred luminance data
     * @param synthesizeCoefficient - Blend coefficients for combining different blur levels
     * @returns A render pass that produces the final bloomed image
     * @private
     */
    private __createRenderPassSynthesizeImage;
    /**
     * Destroys all 3D API resources used by this Bloom instance.
     *
     * This method cleans up all cached framebuffers and their associated GPU resources.
     * It should be called when the Bloom instance is no longer needed to prevent
     * memory leaks and properly release graphics resources.
     *
     * @public
     */
    destroy3DAPIResources(): void;
}

/**
 * A helper class for creating Gaussian blur effects on textures.
 * This class provides functionality to apply multi-pass Gaussian blur
 * with customizable parameters including blur levels, kernel size, and variance.
 */
declare class GaussianBlur {
    private __mapReducedFramebuffer;
    private __mapSynthesizeFramebuffer;
    /**
     * Creates a complete Gaussian blur expression with multiple blur passes and synthesis.
     * This method generates a series of render passes that apply Gaussian blur at different
     * resolution levels and synthesizes them into a final blurred image.
     *
     * @param config - Configuration object containing the texture to blur and parameters
     * @param config.textureToBlur - The source texture to apply Gaussian blur to
     * @param config.parameters - Blur configuration parameters
     * @param config.parameters.blurPassLevel - Number of blur passes (default: 4)
     * @param config.parameters.gaussianKernelSize - Size of the Gaussian kernel (default: 10)
     * @param config.parameters.gaussianVariance - Variance for Gaussian distribution (default: 10)
     * @param config.parameters.synthesizeCoefficient - Coefficients for blending blur levels (default: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0])
     * @param config.parameters.isReduceBuffer - Whether to reduce buffer size for each pass (default: true)
     * @param config.parameters.textureFormat - Format for intermediate textures (default: RGBA16F)
     * @param config.parameters.outputFrameBuffer - Optional output framebuffer (default: undefined)
     * @param config.parameters.outputFrameBufferLayerIndex - Layer index for output framebuffer (default: 0)
     *
     * @returns An object containing the blur expression, blurred render target, and render passes
     */
    createGaussianBlurExpression({ textureToBlur, parameters: { blurPassLevel, gaussianKernelSize, gaussianVariance, synthesizeCoefficient, isReduceBuffer, textureFormat, outputFrameBuffer, outputFrameBufferLayerIndex, }, }: {
        textureToBlur: AbstractTexture;
        parameters: {
            blurPassLevel?: number;
            gaussianKernelSize?: number;
            gaussianVariance?: number;
            synthesizeCoefficient?: [number, number, number, number, number, number];
            isReduceBuffer?: boolean;
            textureFormat?: TextureFormatEnum;
            outputFrameBuffer?: FrameBuffer;
            outputFrameBufferLayerIndex?: number;
        };
    }): {
        blurExpression: Expression;
        blurredRenderTarget: RenderTargetTexture;
        renderPassesBlurred: RenderPass[];
    };
    /**
     * Creates a series of blur render passes with horizontal and vertical blur operations.
     * Each blur level can optionally use reduced resolution for performance optimization.
     *
     * @param frameBufferToBlur - The source texture or framebuffer to blur
     * @param blurPassLevel - Number of blur passes to create
     * @param gaussianKernelSize - Size of the Gaussian blur kernel
     * @param gaussianVariance - Variance parameter for Gaussian distribution
     * @param maxResolutionWidth - Maximum width for blur textures
     * @param maxResolutionHeight - Maximum height for blur textures
     * @param isReduceBuffer - Whether to reduce buffer resolution for each pass
     * @param textureFormat - Format for intermediate blur textures
     *
     * @returns Array of render passes for horizontal and vertical blur operations
     */
    private __createBlurPasses;
    /**
     * Creates a render pass that synthesizes the original texture with multiple blur levels.
     * This method combines the original image with various blur intensities using
     * specified synthesis coefficients to create the final blurred result.
     *
     * @param texture - The original texture to synthesize with
     * @param renderPassesBlurredHighLuminance - Array of blur render passes to synthesize
     * @param synthesizeCoefficient - Coefficients for blending each blur level
     * @param textureFormat - Format for the synthesis output texture
     * @param outputFrameBuffer - Optional specific output framebuffer
     * @param outputFrameBufferLayerIndex - Layer index for multi-layer output framebuffers
     *
     * @returns Render pass that performs the synthesis operation
     */
    private __createRenderPassSynthesizeImage;
    /**
     * Creates a single Gaussian blur render pass for either horizontal or vertical blur direction.
     * This method sets up the material with appropriate Gaussian kernel parameters and
     * creates the necessary framebuffer for the blur operation.
     *
     * @param textureToBlur - The input texture to apply blur to
     * @param gaussianKernelSize - Size of the Gaussian blur kernel
     * @param gaussianVariance - Variance parameter for Gaussian distribution calculation
     * @param isHorizontal - Whether to apply horizontal (true) or vertical (false) blur
     * @param resolutionWidthBlur - Width of the blur output texture
     * @param resolutionHeightBlur - Height of the blur output texture
     * @param textureFormat - Format for the blur output texture
     *
     * @returns Configured render pass for Gaussian blur operation
     */
    private __createRenderPassGaussianBlur;
    /**
     * Destroys all 3D API resources associated with this GaussianBlur instance.
     * This method cleans up all cached framebuffers and their associated GPU resources
     * to prevent memory leaks. Should be called when the GaussianBlur instance is no longer needed.
     */
    destroy3DAPIResources(): void;
}

type Vrm1_Materials_MToon = {
    specVersion: string;
    transparentWithZWrite: boolean;
    renderQueueOffsetNumber: number;
    shadeColorFactor: [number, number, number];
    shadeMultiplyTexture: {
        index: number;
        texCoord?: number;
        scale?: number;
        texture?: RnM2Texture;
    };
    shadingShiftFactor: number;
    shadingShiftTexture: {
        index: number;
        texCoord?: number;
        scale?: number;
        texture?: RnM2Texture;
    };
    shadingToonyFactor: number;
    giEqualizationFactor: number;
    matcapFactor: [number, number, number];
    matcapTexture: {
        index: number;
        texCoord?: number;
        scale?: number;
        texture?: RnM2Texture;
    };
    parametricRimColorFactor: [number, number, number];
    parametricRimFresnelPowerFactor: number;
    parametricRimLiftFactor: number;
    rimMultiplyTexture: {
        index: number;
        texCoord?: number;
        scale?: number;
        texture?: RnM2Texture;
    };
    rimLightingMixFactor: number;
    outlineColorFactor: [number, number, number];
    outlineLightingMixFactor: number;
    outlineWidthFactor: number;
    outlineWidthMode: 'none' | 'worldCoordinates' | 'screenCoordinates';
    outlineWidthMultiplyTexture: {
        index: number;
        texture?: RnM2Texture;
    };
    uvAnimationMaskTexture: {
        index: number;
        texCoord?: number;
        texture?: RnM2Texture;
    };
    uvAnimationRotationSpeedFactor: number;
    uvAnimationScrollXSpeedFactor: number;
    uvAnimationScrollYSpeedFactor: number;
};
interface Vrm1_Material extends RnM2Material {
    extensions: {
        VRMC_materials_mtoon: Vrm1_Materials_MToon;
    };
}

/**
 * Descriptor for loading image data to a specific mip level of a texture.
 */
interface LoadImageToMipLevelDescriptor {
    /** Mip level to load the image data to */
    mipLevel: Index;
    /** X offset in the texture to copy data */
    xOffset: Offset;
    /** Y offset in the texture to copy data */
    yOffset: Offset;
    /** Width in the texture to copy */
    width: Size;
    /** Height in the texture to copy */
    height: Size;
    /** Image data in TypedArray format */
    data: TypedArray;
    /** Row size by pixel of the image data */
    rowSizeByPixel: Size;
    /** Component type of the image data */
    type: ComponentTypeEnum;
}
/**
 * A 2D texture class that extends AbstractTexture and provides functionality for
 * creating, loading, and managing textures from various sources including images,
 * compressed formats (Basis, KTX2), and raw data.
 *
 * This class supports:
 * - Loading textures from URLs, HTML image elements, and data URIs
 * - Compressed texture formats (Basis Universal, KTX2)
 * - Mipmap generation and management
 * - Automatic memory management with finalization registry
 * - Both WebGL and WebGPU backends
 *
 * @example
 * ```typescript
 * // Load texture from URL
 * const texture = await Texture.loadFromUrl('path/to/image.jpg');
 *
 * // Create texture from image element
 * const texture2 = new Texture();
 * await texture2.generateTextureFromImage(imageElement);
 *
 * // Generate 1x1 solid color texture
 * const whiteTexture = new Texture();
 * await whiteTexture.generate1x1TextureFrom('rgba(255,255,255,1)');
 * ```
 */
declare class Texture extends AbstractTexture implements Disposable {
    /** Whether to automatically detect transparency in loaded images */
    autoDetectTransparency: boolean;
    private static __loadedBasisFunc;
    private static __basisLoadPromise?;
    private static __BasisFile?;
    private __optionsToLoadLazy?;
    private static managedRegistry;
    /**
     * Sets the texture resource UID and registers it for automatic cleanup.
     * @param textureResourceUid - The texture resource handle from the graphics API
     * @param uniqueName - Unique name for debugging and logging purposes
     */
    private __setTextureResourceUid;
    /**
     * Generates a texture from Basis Universal compressed data.
     * Basis Universal is a supercompressed GPU texture codec that supports multiple formats.
     *
     * @param uint8Array - The Basis Universal compressed data
     * @param options - Configuration options for texture generation
     * @param options.level - Mip level (default: 0)
     * @param options.internalFormat - Internal texture format (default: RGBA8)
     * @param options.format - Pixel format (default: RGBA)
     * @param options.type - Component type (default: UnsignedByte)
     * @param options.generateMipmap - Whether to generate mipmaps (default: true)
     * @returns Promise that resolves when texture is ready
     *
     * @example
     * ```typescript
     * const texture = new Texture();
     * const basisData = new Uint8Array(basisFileBuffer);
     * await texture.generateTextureFromBasis(basisData);
     * ```
     */
    generateTextureFromBasis(uint8Array: Uint8Array, options: {
        level?: Count;
        internalFormat?: TextureParameterEnum;
        format?: PixelFormatEnum;
        type?: ComponentTypeEnum;
        generateMipmap?: boolean;
    }): Promise<void>;
    /**
     * Internal method to set up a Basis texture with the transcoder.
     * @param uint8Array - The Basis Universal compressed data
     * @param options - Texture generation options with defaults
     */
    private __setBasisTexture;
    /**
     * Generates a texture from KTX2 compressed data.
     * KTX2 is a container format for GPU textures that supports various compression formats.
     *
     * @param uint8Array - The KTX2 compressed data
     * @returns Promise that resolves when texture is ready
     *
     * @example
     * ```typescript
     * const texture = new Texture();
     * const ktx2Data = new Uint8Array(ktx2FileBuffer);
     * await texture.generateTextureFromKTX2(ktx2Data);
     * ```
     */
    generateTextureFromKTX2(uint8Array: Uint8Array): Promise<void>;
    /**
     * Generates a texture from an HTML image element.
     *
     * @param image - The HTML image element to create texture from
     * @param options - Configuration options for texture generation
     * @param options.level - Mip level (default: 0)
     * @param options.internalFormat - Internal texture format (default: RGBA8)
     * @param options.format - Pixel format (default: RGBA)
     * @param options.type - Component type (default: UnsignedByte)
     * @param options.generateMipmap - Whether to generate mipmaps (default: true)
     * @returns Promise that resolves when texture is ready
     *
     * @example
     * ```typescript
     * const texture = new Texture();
     * const img = document.getElementById('myImage') as HTMLImageElement;
     * await texture.generateTextureFromImage(img, { generateMipmap: false });
     * ```
     */
    generateTextureFromImage(image: HTMLImageElement, { level, internalFormat, format, type, generateMipmap, }?: {
        level?: number | undefined;
        internalFormat?: TextureFormatEnum | undefined;
        format?: EnumIO | undefined;
        type?: {
            readonly __webgpu: string;
            readonly __wgsl: string;
            readonly __sizeInBytes: number;
            readonly __dummyStr: "UNSIGNED_BYTE";
            readonly wgsl: string;
            readonly webgpu: string;
            getSizeInBytes(): number;
            isFloatingPoint(): boolean;
            isInteger(): boolean;
            isUnsignedInteger(): boolean;
            readonly index: number;
            readonly symbol: symbol;
            readonly str: string;
            toString(): string;
            toJSON(): number;
        } | undefined;
        generateMipmap?: boolean | undefined;
    }): Promise<void>;
    /**
     * Generates a texture by loading an image from a URL.
     * Supports both regular URLs and data URIs. For external URLs, CORS is handled automatically.
     *
     * @param imageUri - The URL or data URI of the image to load
     * @param options - Configuration options for texture generation
     * @param options.level - Mip level (default: 0)
     * @param options.internalFormat - Internal texture format (default: RGBA8)
     * @param options.format - Pixel format (default: RGBA)
     * @param options.type - Component type (default: UnsignedByte)
     * @param options.generateMipmap - Whether to generate mipmaps (default: true)
     * @returns Promise that resolves when texture is loaded and ready
     *
     * @example
     * ```typescript
     * const texture = new Texture();
     * await texture.generateTextureFromUrl('https://example.com/image.jpg');
     * ```
     */
    generateTextureFromUrl(imageUri: string, { level, internalFormat, format, type, generateMipmap, }?: {
        level?: number | undefined;
        internalFormat?: TextureFormatEnum | undefined;
        format?: EnumIO | undefined;
        type?: {
            readonly __webgpu: string;
            readonly __wgsl: string;
            readonly __sizeInBytes: number;
            readonly __dummyStr: "UNSIGNED_BYTE";
            readonly wgsl: string;
            readonly webgpu: string;
            getSizeInBytes(): number;
            isFloatingPoint(): boolean;
            isInteger(): boolean;
            isUnsignedInteger(): boolean;
            readonly index: number;
            readonly symbol: symbol;
            readonly str: string;
            toString(): string;
            toJSON(): number;
        } | undefined;
        generateMipmap?: boolean | undefined;
    }): Promise<void>;
    /**
     * Generates a 1x1 pixel texture with a solid color.
     * Useful for creating placeholder textures or solid color materials.
     *
     * @param rgbaStr - CSS color string in rgba format (default: 'rgba(255,255,255,1)')
     * @returns Promise that resolves when texture is ready
     *
     * @example
     * ```typescript
     * const texture = new Texture();
     * await texture.generate1x1TextureFrom('rgba(255,0,0,1)'); // Red texture
     * ```
     */
    generate1x1TextureFrom(rgbaStr?: string): Promise<void>;
    /**
     * Generates a sheen lookup table texture from embedded data URI.
     * This is used for physically-based rendering (PBR) sheen calculations.
     * Requires the PBR module to be loaded.
     *
     * @returns Promise that resolves when texture is ready
     * @throws Error if PBR module is not available
     */
    generateSheenLutTextureFromDataUri(): Promise<void>;
    /**
     * Allocates an empty texture with specified dimensions and format.
     * The texture can be filled with data later using loadImageToMipLevel.
     *
     * @param desc - Texture allocation descriptor
     * @param desc.mipLevelCount - Number of mip levels (auto-calculated if not provided)
     * @param desc.width - Texture width in pixels
     * @param desc.height - Texture height in pixels
     * @param desc.format - Texture format
     *
     * @example
     * ```typescript
     * const texture = new Texture();
     * texture.allocate({
     *   width: 512,
     *   height: 512,
     *   format: TextureFormat.RGBA8
     * });
     * ```
     */
    allocate(desc: {
        mipLevelCount?: Count;
        width: number;
        height: number;
        format: TextureFormatEnum;
    }): void;
    /**
     * Loads image data to a specific mip level of an allocated texture.
     * The texture must be allocated first using the allocate method.
     *
     * @param desc - Descriptor containing image data and target location
     * @returns Promise that resolves when data is loaded
     *
     * @example
     * ```typescript
     * await texture.loadImageToMipLevel({
     *   mipLevel: 0,
     *   xOffset: 0,
     *   yOffset: 0,
     *   width: 256,
     *   height: 256,
     *   data: imageData,
     *   rowSizeByPixel: 256,
     *   type: ComponentType.UnsignedByte
     * });
     * ```
     */
    loadImageToMipLevel(desc: LoadImageToMipLevelDescriptor): Promise<void>;
    /**
     * Generates a compressed texture from raw typed array data.
     *
     * @param typedArray - The compressed texture data
     * @param width - Texture width in pixels
     * @param height - Texture height in pixels
     * @param compressionTextureType - Type of compression used
     * @returns Promise that resolves when texture is ready
     *
     * @example
     * ```typescript
     * const texture = new Texture();
     * await texture.generateCompressedTextureFromTypedArray(
     *   compressedData,
     *   512,
     *   512,
     *   CompressionTextureType.S3TC_DXT1
     * );
     * ```
     */
    generateCompressedTextureFromTypedArray(typedArray: TypedArray, width: number, height: number, compressionTextureType: CompressionTextureTypeEnum): Promise<void>;
    /**
     * Generates a compressed texture with mipmaps from an array of texture data.
     * Each TextureData object represents a different mip level.
     *
     * @param textureDataArray - Array of texture data for different mip levels
     * @param compressionTextureType - Type of compression used
     * @returns Promise that resolves when texture is ready
     * @throws Error if level 0 texture data is not found
     *
     * @example
     * ```typescript
     * const texture = new Texture();
     * const mipmapData = [
     *   { level: 0, width: 512, height: 512, buffer: level0Data },
     *   { level: 1, width: 256, height: 256, buffer: level1Data },
     *   // ... more levels
     * ];
     * await texture.generateCompressedTextureWithMipmapFromTypedArray(
     *   mipmapData,
     *   CompressionTextureType.S3TC_DXT1
     * );
     * ```
     */
    generateCompressedTextureWithMipmapFromTypedArray(textureDataArray: TextureData[], compressionTextureType: CompressionTextureTypeEnum): Promise<void>;
    /**
     * Generates mipmaps for the texture automatically.
     * The texture must already be loaded and ready before calling this method.
     *
     * @example
     * ```typescript
     * const texture = new Texture();
     * await texture.generateTextureFromUrl('image.jpg', { generateMipmap: false });
     * texture.generateMipmaps(); // Generate mipmaps manually
     * ```
     */
    generateMipmaps(): void;
    /**
     * Imports an existing WebGL texture directly without copying data.
     * This is useful for integrating with external WebGL code or libraries.
     *
     * @param webGLTexture - The WebGL texture object to import
     * @param width - Texture width in pixels (default: 0)
     * @param height - Texture height in pixels (default: 0)
     *
     * @example
     * ```typescript
     * const texture = new Texture();
     * const webglTexture = gl.createTexture();
     * // ... set up webglTexture
     * texture.importWebGLTextureDirectly(webglTexture, 512, 512);
     * ```
     */
    importWebGLTextureDirectly(webGLTexture: WebGLTexture, width?: number, height?: number): void;
    /**
     * Destroys the 3D API resources associated with this texture.
     * This releases GPU memory and invalidates the texture.
     *
     * @returns Always returns true
     */
    destroy3DAPIResources(): boolean;
    /**
     * Internal method to delete a texture resource from the graphics API.
     * @param textureResourceUid - The texture resource handle to delete
     */
    private static __deleteInternalTexture;
    /**
     * Symbol.dispose implementation for automatic resource cleanup.
     * Called automatically when using 'using' declarations in TypeScript 5.2+.
     */
    [Symbol.dispose](): void;
    /**
     * Destroys the texture and releases all associated resources.
     * This includes GPU memory, finalization registry entries, and other cleanup.
     * After calling this method, the texture should not be used.
     */
    destroy(): void;
    /**
     * Static factory method to create and load a texture from a URL.
     * This is a convenience method that combines texture creation and loading.
     *
     * @param uri - The URL or data URI of the image to load
     * @param options - Configuration options for texture generation
     * @param options.level - Mip level (default: 0)
     * @param options.internalFormat - Internal texture format (default: RGBA8)
     * @param options.format - Pixel format (default: RGBA)
     * @param options.type - Component type (default: UnsignedByte)
     * @param options.generateMipmap - Whether to generate mipmaps (default: true)
     * @returns Promise that resolves to the loaded texture
     *
     * @example
     * ```typescript
     * const texture = await Texture.loadFromUrl('https://example.com/image.jpg', {
     *   generateMipmap: false,
     *   format: PixelFormat.RGB
     * });
     * ```
     */
    static loadFromUrl(uri: string, { level, internalFormat, format, type, generateMipmap, }?: {
        level?: number | undefined;
        internalFormat?: TextureFormatEnum | undefined;
        format?: EnumIO | undefined;
        type?: {
            readonly __webgpu: string;
            readonly __wgsl: string;
            readonly __sizeInBytes: number;
            readonly __dummyStr: "UNSIGNED_BYTE";
            readonly wgsl: string;
            readonly webgpu: string;
            getSizeInBytes(): number;
            isFloatingPoint(): boolean;
            isInteger(): boolean;
            isUnsignedInteger(): boolean;
            readonly index: number;
            readonly symbol: symbol;
            readonly str: string;
            toString(): string;
            toJSON(): number;
        } | undefined;
        generateMipmap?: boolean | undefined;
    }): Promise<Texture>;
}

/**
 * Creates a new material with the specified material content and maximum instances.
 * This function automatically manages material grouping when instance limits are reached.
 *
 * @param materialContent - The material content that defines the material's properties and shaders
 * @param maxInstancesNumber - The maximum number of instances that can use this material
 * @returns A newly created Material instance
 * @throws Error if material creation fails after exhausting all groups
 */
declare function createMaterial(materialContent: AbstractMaterialContent, maxInstancesNumber?: Count): Material;
/**
 * Forces recreation of a material with the specified content, bypassing compatibility checks.
 * Use this when you need to ensure a completely fresh material instance.
 *
 * @param materialContent - The material content for the new material
 * @param maxInstancesNumber - The maximum number of instances for the material
 * @returns A newly recreated Material instance
 */
declare function recreateMaterial(materialContent: AbstractMaterialContent, maxInstancesNumber?: Count): Material;
/**
 * Creates a PBR (Physically Based Rendering) Uber material with extensive feature support.
 * This is a comprehensive material that supports various PBR extensions and features.
 *
 * @param options - Configuration object for the PBR material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.isMorphing - Enable morph target animation support
 * @param options.isSkinning - Enable skeletal animation support
 * @param options.isLighting - Enable lighting calculations
 * @param options.isOcclusion - Enable ambient occlusion texture support
 * @param options.isEmissive - Enable emissive texture support
 * @param options.isClearCoat - Enable clear coat extension (KHR_materials_clearcoat)
 * @param options.isTransmission - Enable transmission extension (KHR_materials_transmission)
 * @param options.isVolume - Enable volume extension (KHR_materials_volume)
 * @param options.isSheen - Enable sheen extension (KHR_materials_sheen)
 * @param options.isSpecular - Enable specular extension (KHR_materials_specular)
 * @param options.isIridescence - Enable iridescence extension (KHR_materials_iridescence)
 * @param options.isAnisotropy - Enable anisotropy extension (KHR_materials_anisotropy)
 * @param options.isDispersion - Enable dispersion extension (KHR_materials_dispersion)
 * @param options.isEmissiveStrength - Enable emissive strength extension
 * @param options.isDiffuseTransmission - Enable diffuse transmission extension
 * @param options.isShadow - Enable shadow mapping support
 * @param options.useTangentAttribute - Use tangent attributes for normal mapping
 * @param options.useNormalTexture - Enable normal texture support
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured PBR Uber Material instance
 */
declare function createPbrUberMaterial({ additionalName, isMorphing, isSkinning, isLighting, isOcclusion, isEmissive, isClearCoat, isTransmission, isVolume, isSheen, isSpecular, isIridescence, isAnisotropy, isDispersion, isEmissiveStrength, isDiffuseTransmission, isShadow, useNormalTexture, maxInstancesNumber, }?: {
    additionalName?: string | undefined;
    isMorphing?: boolean | undefined;
    isSkinning?: boolean | undefined;
    isLighting?: boolean | undefined;
    isOcclusion?: boolean | undefined;
    isEmissive?: boolean | undefined;
    isClearCoat?: boolean | undefined;
    isTransmission?: boolean | undefined;
    isVolume?: boolean | undefined;
    isSheen?: boolean | undefined;
    isSpecular?: boolean | undefined;
    isIridescence?: boolean | undefined;
    isAnisotropy?: boolean | undefined;
    isDispersion?: boolean | undefined;
    isEmissiveStrength?: boolean | undefined;
    isDiffuseTransmission?: boolean | undefined;
    isShadow?: boolean | undefined;
    useNormalTexture?: boolean | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a Classic Uber material for traditional non-PBR rendering.
 * This material is suitable for classic shading models and legacy content.
 *
 * @param options - Configuration object for the Classic material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.isSkinning - Enable skeletal animation support
 * @param options.isLighting - Enable lighting calculations
 * @param options.isMorphing - Enable morph target animation support
 * @param options.isShadow - Enable shadow mapping support
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured Classic Uber Material instance
 */
declare function createClassicUberMaterial({ additionalName, isSkinning, isLighting, isMorphing, isShadow, maxInstancesNumber, }?: {
    additionalName?: string | undefined;
    isSkinning?: boolean | undefined;
    isLighting?: boolean | undefined;
    isMorphing?: boolean | undefined;
    isShadow?: boolean | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a material for encoding depth moments in paraboloid projection.
 * This material is used for omnidirectional shadow mapping with paraboloid projections.
 *
 * @param options - Configuration object for the paraboloid depth material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.isSkinning - Enable skeletal animation support
 * @param options.isMorphing - Enable morph target animation support
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured Paraboloid Depth Moment Encode Material instance
 */
declare function createParaboloidDepthMomentEncodeMaterial({ additionalName, isSkinning, isMorphing, maxInstancesNumber, }?: {
    additionalName?: string | undefined;
    isSkinning?: boolean | undefined;
    isMorphing?: boolean | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a material for encoding depth moments for variance shadow mapping.
 * This material generates depth and depth-squared values for soft shadow techniques.
 *
 * @param options - Configuration object for the depth moment material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.isSkinning - Enable skeletal animation support
 * @param options.isMorphing - Enable morph target animation support
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured Depth Moment Encode Material instance
 */
declare function createDepthMomentEncodeMaterial({ additionalName, isSkinning, isMorphing, maxInstancesNumber, }?: {
    additionalName?: string | undefined;
    isSkinning?: boolean | undefined;
    isMorphing?: boolean | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a flat shading material with uniform color rendering.
 * This material renders objects with flat, unlit colors without lighting calculations.
 *
 * @param options - Configuration object for the flat material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.isSkinning - Enable skeletal animation support
 * @param options.isMorphing - Enable morph target animation support
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured Flat Material instance
 */
declare function createFlatMaterial({ additionalName, isSkinning, isMorphing, maxInstancesNumber, }?: {
    additionalName?: string | undefined;
    isSkinning?: boolean | undefined;
    isMorphing?: boolean | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a material for rendering environment constant colors.
 * This material is typically used for skyboxes or environment background rendering.
 *
 * @param options - Configuration object for the environment material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @param options.makeOutputSrgb - Whether to convert output to sRGB color space
 * @returns A configured Environment Constant Material instance
 */
declare function createEnvConstantMaterial({ additionalName, maxInstancesNumber, makeOutputSrgb }?: {
    additionalName?: string | undefined;
    maxInstancesNumber?: number | undefined;
    makeOutputSrgb?: boolean | undefined;
}): Material;
/**
 * Creates a FXAA (Fast Approximate Anti-Aliasing) post-processing material.
 * This material applies FXAA3 quality anti-aliasing to reduce edge aliasing.
 *
 * @param options - Configuration object for the FXAA material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured FXAA3 Quality Material instance
 */
declare function createFXAA3QualityMaterial({ additionalName, maxInstancesNumber }?: {
    additionalName?: string | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a furnace test material for validating material energy conservation.
 * This material is used for testing purposes to ensure materials conserve energy properly.
 *
 * @param options - Configuration object for the furnace test material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured Furnace Test Material instance
 */
declare function createFurnaceTestMaterial({ additionalName, maxInstancesNumber }?: {
    additionalName?: string | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a material for encoding depth values into color channels.
 * This material is used for depth-based effects and shadow mapping.
 *
 * @param options - Configuration object for the depth encode material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.isSkinning - Enable skeletal animation support
 * @param options.depthPow - Power value for depth encoding (affects depth precision)
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured Depth Encode Material instance
 */
declare function createDepthEncodeMaterial({ additionalName, isSkinning, depthPow, maxInstancesNumber, }?: {
    additionalName?: string | undefined;
    isSkinning?: boolean | undefined;
    depthPow?: number | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a material for decoding classic shadow maps in the rendering pipeline.
 * This material applies shadow mapping techniques to create realistic shadows.
 *
 * @param options - Configuration object for the shadow map decode material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.isMorphing - Enable morph target animation support
 * @param options.isSkinning - Enable skeletal animation support
 * @param options.isLighting - Enable lighting calculations
 * @param options.isDebugging - Enable debugging features
 * @param options.colorAttachmentsNumber - Number of color attachments
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @param depthEncodeRenderPass - The render pass that encodes depth information
 * @returns A configured Shadow Map Decode Classic Material instance
 */
declare function createShadowMapDecodeClassicSingleMaterial({ additionalName, isMorphing, isSkinning, isLighting, isDebugging, colorAttachmentsNumber, maxInstancesNumber, }: {
    additionalName?: string | undefined;
    isMorphing?: boolean | undefined;
    isSkinning?: boolean | undefined;
    isLighting?: boolean | undefined;
    isDebugging?: boolean | undefined;
    colorAttachmentsNumber?: number | undefined;
    maxInstancesNumber?: number | undefined;
}, depthEncodeRenderPass: RenderPass): Material;
/**
 * Creates a material for Gaussian blur applied to encoded depth textures.
 * This material is used for creating soft shadows by blurring depth maps.
 *
 * @param options - Configuration object for the Gaussian blur material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured Gaussian Blur for Encoded Depth Material instance
 */
declare function createGaussianBlurForEncodedDepthMaterial({ additionalName, maxInstancesNumber }?: {
    additionalName?: string | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a material for decoding variance shadow maps with classic single-pass rendering.
 * This material implements variance shadow mapping for soft shadow effects.
 *
 * @param options - Configuration object for the variance shadow map material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.isMorphing - Enable morph target animation support
 * @param options.isSkinning - Enable skeletal animation support
 * @param options.isDebugging - Enable debugging features
 * @param options.isLighting - Enable lighting calculations
 * @param options.colorAttachmentsNumberDepth - Number of depth color attachments
 * @param options.colorAttachmentsNumberSquareDepth - Number of squared depth color attachments
 * @param options.depthCameraComponent - Camera component for depth calculations
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @param encodedDepthRenderPasses - Array of render passes that encode depth information
 * @returns A configured Variance Shadow Map Decode Classic Material instance
 */
declare function createVarianceShadowMapDecodeClassicSingleMaterial({ additionalName, isMorphing, isSkinning, isDebugging, isLighting, colorAttachmentsNumberDepth, colorAttachmentsNumberSquareDepth, depthCameraComponent, maxInstancesNumber, }: {
    additionalName?: string;
    isMorphing?: boolean;
    isSkinning?: boolean;
    isDebugging?: boolean;
    isLighting?: boolean;
    colorAttachmentsNumberDepth?: Count;
    colorAttachmentsNumberSquareDepth?: Count;
    depthCameraComponent?: CameraComponent;
    maxInstancesNumber?: Count;
}, encodedDepthRenderPasses: RenderPass[]): Material;
/**
 * Creates a material for detecting high luminance areas in textures.
 * This material is typically used in HDR rendering pipelines for bloom effects.
 *
 * @param options - Configuration object for the high luminance detection material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @param textureToDetectHighLuminance - The texture to analyze for high luminance areas
 * @returns A configured Detect High Luminance Material instance
 */
declare function createDetectHighLuminanceMaterial({ additionalName, maxInstancesNumber }: {
    additionalName?: string | undefined;
    maxInstancesNumber?: number | undefined;
}, textureToDetectHighLuminance: AbstractTexture): Material;
/**
 * Creates a material for Gaussian blur post-processing effects.
 * This material applies Gaussian blur for various effects like depth of field or bloom.
 *
 * @param options - Configuration object for the Gaussian blur material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured Gaussian Blur Material instance
 */
declare function createGaussianBlurMaterial({ additionalName, maxInstancesNumber }?: {
    additionalName?: string | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a material for synthesizing HDR (High Dynamic Range) textures.
 * This material combines multiple textures to create HDR content for advanced lighting.
 *
 * @param options - Configuration object for the HDR synthesis material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @param synthesizeTextures - Array of textures to synthesize into HDR
 * @returns A configured Synthesize HDR Material instance
 */
declare function createSynthesizeHDRMaterial({ additionalName, maxInstancesNumber, }: {
    additionalName?: string;
    maxInstancesNumber?: Count;
}, synthesizeTextures: AbstractTexture[]): Material;
/**
 * Creates a material for color grading using LUT (Look-Up Table) textures.
 * This material applies color correction and grading effects using 3D LUT textures.
 *
 * @param options - Configuration object for the color grading material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.colorAttachmentsNumber - Number of color attachments
 * @param options.uri - URI path to the LUT texture
 * @param options.texture - Pre-loaded LUT texture
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @param targetRenderPass - The render pass to apply color grading to
 * @returns A configured Color Grading using LUTs Material instance
 */
declare function createColorGradingUsingLUTsMaterial({ additionalName, colorAttachmentsNumber, uri, texture, maxInstancesNumber, }: {
    additionalName?: string;
    colorAttachmentsNumber?: Count;
    uri?: string;
    texture?: Texture;
    maxInstancesNumber?: Count;
}, targetRenderPass: RenderPass): Material;
/**
 * Creates a material for gamma correction post-processing.
 * This material applies gamma correction to convert linear color space to sRGB.
 *
 * @param options - Configuration object for the gamma correction material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured Gamma Correction Material instance
 */
declare function createGammaCorrectionMaterial({ additionalName, maxInstancesNumber }?: {
    additionalName?: string | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a material for tone mapping HDR content to LDR display.
 * This material converts high dynamic range colors to displayable range using tone mapping algorithms.
 *
 * @param options - Configuration object for the tone mapping material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured Tone Mapping Material instance
 */
declare function createToneMappingMaterial({ additionalName, maxInstancesNumber }?: {
    additionalName?: string | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a material for generating summed area tables from textures.
 * This material is used for efficient area sampling and filtering operations.
 *
 * @param options - Configuration object for the summed area table material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured Summed Area Table Material instance
 */
declare function createSummedAreaTableMaterial({ additionalName, maxInstancesNumber }?: {
    additionalName?: string | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a material for converting panoramic textures to cube map format.
 * This material transforms equirectangular panoramic images into cube map textures.
 *
 * @param options - Configuration object for the panorama to cube material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured Panorama to Cube Material instance
 */
declare function createPanoramaToCubeMaterial({ additionalName, maxInstancesNumber }?: {
    additionalName?: string | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a material for prefiltering IBL (Image-Based Lighting) environment maps.
 * This material generates prefiltered mipmap levels for environment map reflections.
 *
 * @param options - Configuration object for the IBL prefilter material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured Prefilter IBL Material instance
 */
declare function createPrefilterIBLMaterial({ additionalName, maxInstancesNumber }?: {
    additionalName?: string | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates a Material Capture (MatCap) material for stylized lighting effects.
 * This material uses a material capture texture to simulate lighting without actual light sources.
 *
 * @param options - Configuration object for the MatCap material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.isSkinning - Enable skeletal animation support
 * @param options.uri - URI path to the MatCap texture
 * @param options.texture - Pre-loaded MatCap texture
 * @param options.sampler - Texture sampler for the MatCap texture
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured MatCap Material instance
 */
declare function createMatCapMaterial({ additionalName, isSkinning, uri, texture, sampler, maxInstancesNumber, }: {
    additionalName?: string;
    isSkinning?: boolean;
    uri?: string;
    texture?: Texture;
    sampler?: Sampler;
    maxInstancesNumber?: Count;
}): Material;
/**
 * Creates a material for outputting entity unique identifiers to render targets.
 * This material is used for object picking and selection by rendering entity IDs.
 *
 * @param options - Configuration object for the entity UID output material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @returns A configured Entity UID Output Material instance
 */
declare function createEntityUIDOutputMaterial({ additionalName, maxInstancesNumber }?: {
    additionalName?: string | undefined;
    maxInstancesNumber?: number | undefined;
}): Material;
/**
 * Creates an MToon 0.x material for VRM character rendering with toon shading.
 * This material implements the MToon 0.x specification for anime/toon-style rendering.
 *
 * @param options - Configuration object for the MToon 0.x material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.isMorphing - Enable morph target animation support
 * @param options.isSkinning - Enable skeletal animation support
 * @param options.isLighting - Enable lighting calculations
 * @param options.useTangentAttribute - Use tangent attributes for normal mapping
 * @param options.isOutline - Enable outline rendering
 * @param options.materialProperties - MToon material property definitions
 * @param options.textures - Array of textures used by the material
 * @param options.samplers - Array of texture samplers
 * @param options.debugMode - Debug mode settings
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @param options.makeOutputSrgb - Whether to convert output to sRGB color space
 * @returns A configured MToon 0.x Material instance
 */
declare function createMToon0xMaterial({ additionalName, isMorphing, isSkinning, isLighting, useTangentAttribute, isOutline, materialProperties, textures, samplers, debugMode, maxInstancesNumber, makeOutputSrgb, }: {
    additionalName?: string;
    isMorphing?: boolean;
    isSkinning?: boolean;
    isLighting?: boolean;
    useTangentAttribute?: boolean;
    isOutline?: boolean;
    materialProperties?: Vrm0xMaterialProperty;
    textures?: any[];
    samplers?: Sampler[];
    debugMode?: any;
    maxInstancesNumber?: Count;
    makeOutputSrgb?: boolean;
}): Material;
/**
 * Creates an MToon 1.0 material for VRM 1.0 character rendering with enhanced toon shading.
 * This material implements the MToon 1.0 specification with improved features over 0.x.
 *
 * @param options - Configuration object for the MToon 1.0 material
 * @param options.additionalName - Additional name suffix for the material
 * @param options.isMorphing - Enable morph target animation support
 * @param options.isSkinning - Enable skeletal animation support
 * @param options.isLighting - Enable lighting calculations
 * @param options.useTangentAttribute - Use tangent attributes for normal mapping
 * @param options.isOutline - Enable outline rendering
 * @param options.materialJson - MToon 1.0 material JSON definition
 * @param options.textures - Array of textures used by the material
 * @param options.samplers - Array of texture samplers
 * @param options.debugMode - Debug mode settings
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @param options.makeOutputSrgb - Whether to convert output to sRGB color space
 * @returns A configured MToon 1.0 Material instance
 */
declare function createMToon1Material({ additionalName, isMorphing, isSkinning, isLighting, isOutline, materialJson, maxInstancesNumber, makeOutputSrgb, }: {
    additionalName?: string;
    isMorphing?: boolean;
    isSkinning?: boolean;
    isLighting?: boolean;
    useTangentAttribute?: boolean;
    isOutline?: boolean;
    materialJson: Vrm1_Material;
    textures?: any[];
    samplers?: Sampler[];
    debugMode?: any;
    maxInstancesNumber?: Count;
    makeOutputSrgb?: boolean;
}): Material;
/**
 * Reuses an existing custom material or recreates it with new shader code.
 * This function optimizes performance by reusing materials when possible while allowing shader updates.
 *
 * @param currentMaterial - The existing material to potentially reuse
 * @param vertexShaderStr - Vertex shader source code string
 * @param pixelShaderStr - Pixel/fragment shader source code string
 * @param options - Configuration object for the custom material
 * @param options.maxInstancesNumber - Maximum number of material instances
 * @param options.isSkinning - Enable skeletal animation support
 * @param options.isLighting - Enable lighting calculations
 * @param options.isMorphing - Enable morph target animation support
 * @returns A reused or newly created Custom Material instance
 */
declare function reuseOrRecreateCustomMaterial(currentMaterial: Material, vertexShaderStr: string, pixelShaderStr: string, { maxInstancesNumber, isSkinning, isLighting, isMorphing, }?: {
    maxInstancesNumber?: number | undefined;
    isSkinning?: boolean | undefined;
    isLighting?: boolean | undefined;
    isMorphing?: boolean | undefined;
}): Material;
/**
 * Changes the material assigned to a specific primitive on an entity.
 * This function updates the primitive's material and triggers necessary render state updates.
 *
 * @param entity - The mesh renderer entity containing the primitive
 * @param primitive - The primitive to change the material for
 * @param material - The new material to assign to the primitive
 */
declare function changeMaterial(entity: IMeshRendererEntityMethods, primitive: Primitive, material: Material): void;
declare const MaterialHelper: Readonly<{
    createMaterial: typeof createMaterial;
    recreateMaterial: typeof recreateMaterial;
    reuseOrRecreateCustomMaterial: typeof reuseOrRecreateCustomMaterial;
    createClassicUberMaterial: typeof createClassicUberMaterial;
    createDepthMomentEncodeMaterial: typeof createDepthMomentEncodeMaterial;
    createParaboloidDepthMomentEncodeMaterial: typeof createParaboloidDepthMomentEncodeMaterial;
    createFlatMaterial: typeof createFlatMaterial;
    createPbrUberMaterial: typeof createPbrUberMaterial;
    createEnvConstantMaterial: typeof createEnvConstantMaterial;
    createFXAA3QualityMaterial: typeof createFXAA3QualityMaterial;
    createDepthEncodeMaterial: typeof createDepthEncodeMaterial;
    createShadowMapDecodeClassicSingleMaterial: typeof createShadowMapDecodeClassicSingleMaterial;
    createGammaCorrectionMaterial: typeof createGammaCorrectionMaterial;
    createToneMappingMaterial: typeof createToneMappingMaterial;
    createPanoramaToCubeMaterial: typeof createPanoramaToCubeMaterial;
    createPrefilterIBLMaterial: typeof createPrefilterIBLMaterial;
    createSummedAreaTableMaterial: typeof createSummedAreaTableMaterial;
    createVarianceShadowMapDecodeClassicSingleMaterial: typeof createVarianceShadowMapDecodeClassicSingleMaterial;
    createEntityUIDOutputMaterial: typeof createEntityUIDOutputMaterial;
    createMToon0xMaterial: typeof createMToon0xMaterial;
    createMToon1Material: typeof createMToon1Material;
    createFurnaceTestMaterial: typeof createFurnaceTestMaterial;
    createGaussianBlurForEncodedDepthMaterial: typeof createGaussianBlurForEncodedDepthMaterial;
    createDetectHighLuminanceMaterial: typeof createDetectHighLuminanceMaterial;
    createGaussianBlurMaterial: typeof createGaussianBlurMaterial;
    createSynthesizeHDRMaterial: typeof createSynthesizeHDRMaterial;
    createColorGradingUsingLUTsMaterial: typeof createColorGradingUsingLUTsMaterial;
    createMatCapMaterial: typeof createMatCapMaterial;
    changeMaterial: typeof changeMaterial;
}>;

declare abstract class IShape extends Primitive {
    abstract generate(desc: IAnyPrimitiveDescriptor): void;
}

/**
 * Descriptor interface for creating an Axis shape
 * @public
 */
interface AxisDescriptor extends IAnyPrimitiveDescriptor {
    /**
     * The length of each axis line
     * @defaultValue 1
     */
    length?: Size;
}
/**
 * A 3D coordinate axis shape that displays X, Y, and Z axes with different colors.
 * The X axis is rendered in red, Y axis in green, and Z axis in blue.
 * Each axis extends from the origin (0,0,0) to the specified length.
 * @public
 */
declare class Axis extends IShape {
    /**
     * Generates vertex data for a 3D coordinate axis with colored lines
     * representing X (red), Y (green), and Z (blue) axes.
     *
     * @param _desc - Configuration object containing axis properties
     * @param _desc.length - The length of each axis line (defaults to 1)
     * @param _desc.material - Material to be applied to the axis
     *
     * @remarks
     * This method creates three colored lines extending from the origin:
     * - X axis: Red line from (0,0,0) to (length,0,0)
     * - Y axis: Green line from (0,0,0) to (0,length,0)
     * - Z axis: Blue line from (0,0,0) to (0,0,length)
     *
     * The generated geometry uses LINE primitive mode for rendering.
     *
     * @public
     */
    generate(_desc: AxisDescriptor): void;
}

type PhysicsShapeTypeEnum = EnumIO;

/**
 * Symbol for getting a 1-component vector from an array
 */
declare const get1: unique symbol;
/**
 * Symbol for getting a 1-component vector from an array at a specific offset
 */
declare const get1_offset: unique symbol;
/**
 * Symbol for getting a 1-component vector from an array at a specific composition offset
 */
declare const get1_offsetAsComposition: unique symbol;
/**
 * Symbol for getting a 2-component vector from an array
 */
declare const get2: unique symbol;
/**
 * Symbol for getting a 2-component vector from an array at a specific offset
 */
declare const get2_offset: unique symbol;
/**
 * Symbol for getting a 2-component vector from an array at a specific composition offset
 */
declare const get2_offsetAsComposition: unique symbol;
/**
 * Symbol for getting a 3-component vector from an array
 */
declare const get3: unique symbol;
/**
 * Symbol for getting a 3-component vector from an array at a specific offset
 */
declare const get3_offset: unique symbol;
/**
 * Symbol for getting a 3-component vector from an array at a specific composition offset
 */
declare const get3_offsetAsComposition: unique symbol;
/**
 * Symbol for getting a 4-component vector from an array
 */
declare const get4: unique symbol;
/**
 * Symbol for getting a 4-component vector from an array at a specific offset
 */
declare const get4_offset: unique symbol;
/**
 * Symbol for getting a 4-component vector from an array at a specific composition offset
 */
declare const get4_offsetAsComposition: unique symbol;
/**
 * Symbol for getting an N-component vector from an array at a specific offset
 */
declare const getN_offset: unique symbol;
/**
 * Symbol for getting an N-component vector from an array at a specific composition offset
 */
declare const getN_offsetAsComposition: unique symbol;
/**
 * Symbol for adding two 2-component vectors
 */
declare const add2: unique symbol;
/**
 * Symbol for adding two 2-component vectors at specific offsets
 */
declare const add2_offset: unique symbol;
/**
 * Symbol for adding two 3-component vectors
 */
declare const add3: unique symbol;
/**
 * Symbol for adding two 3-component vectors at specific offsets
 */
declare const add3_offset: unique symbol;
/**
 * Symbol for adding two 4-component vectors
 */
declare const add4: unique symbol;
/**
 * Symbol for multiplying a 3-component vector by a scalar at a specific offset
 */
declare const mulArray3WithScalar_offset: unique symbol;
/**
 * Symbol for multiplying a 4-component vector by a scalar at a specific offset
 */
declare const mulArray4WithScalar_offset: unique symbol;
/**
 * Symbol for multiplying an N-component vector by a scalar at a specific offset
 */
declare const mulArrayNWithScalar_offset: unique symbol;
/**
 * Symbol for multiplying two 4x4 matrices and storing the result in an output array
 */
declare const mulThatAndThisToOutAsMat44_offsetAsComposition: unique symbol;
/**
 * Symbol for adding two 4-component vectors at specific offsets
 */
declare const add4_offset: unique symbol;
/**
 * Symbol for quaternion spherical linear interpolation at specific composition offsets
 */
declare const qlerp_offsetAsComposition: unique symbol;
/**
 * Symbol for scalar linear interpolation at specific composition offsets
 */
declare const scalar_lerp_offsetAsComposition: unique symbol;
/**
 * Symbol for 2-component vector linear interpolation at specific composition offsets
 */
declare const array2_lerp_offsetAsComposition: unique symbol;
/**
 * Symbol for 3-component vector linear interpolation at specific composition offsets
 */
declare const array3_lerp_offsetAsComposition: unique symbol;
/**
 * Symbol for 4-component vector linear interpolation at specific composition offsets
 */
declare const array4_lerp_offsetAsComposition: unique symbol;
/**
 * Symbol for N-component vector linear interpolation at specific composition offsets
 */
declare const arrayN_lerp_offsetAsComposition: unique symbol;
/**
 * Symbol for normalizing a 4-component vector
 */
declare const normalizeArray4: unique symbol;
/**
 * Mathematical extension methods for array types.
 * These methods provide efficient operations for vectors, matrices, and quaternions.
 */
declare global {
    interface Extension {
        /**
         * Gets a 1-component vector from the beginning of the array
         * @returns A new Array1 containing the first element
         */
        [get1](this: ArrayType): Array1<number>;
        /**
         * Gets a 1-component vector from the array at a specific offset
         * @param offset - The index offset to start reading from
         * @returns A new Array1 containing one element at the specified offset
         */
        [get1_offset](this: ArrayType, offset: number): Array1<number>;
        /**
         * Gets a 1-component vector from the array at a specific composition offset
         * @param offsetAsComposition - The composition index (element index = offsetAsComposition * 1)
         * @returns A new Array1 containing one element at the specified composition offset
         */
        [get1_offsetAsComposition](this: ArrayType, offsetAsComposition: number): Array1<number>;
        /**
         * Gets a 2-component vector from the beginning of the array
         * @returns A new Array2 containing the first two elements
         */
        [get2](this: ArrayType): Array2<number>;
        /**
         * Gets a 2-component vector from the array at a specific offset
         * @param offset - The index offset to start reading from
         * @returns A new Array2 containing two elements starting at the specified offset
         */
        [get2_offset](this: ArrayType, offset: number): Array2<number>;
        /**
         * Gets a 2-component vector from the array at a specific composition offset
         * @param offsetAsComposition - The composition index (element index = offsetAsComposition * 2)
         * @returns A new Array2 containing two elements at the specified composition offset
         */
        [get2_offsetAsComposition](this: ArrayType, offsetAsComposition: number): Array2<number>;
        /**
         * Gets a 3-component vector from the beginning of the array
         * @returns A new Array3 containing the first three elements
         */
        [get3](this: ArrayType): Array3<number>;
        /**
         * Gets a 3-component vector from the array at a specific offset
         * @param offset - The index offset to start reading from
         * @returns A new Array3 containing three elements starting at the specified offset
         */
        [get3_offset](this: ArrayType, offset: number): Array3<number>;
        /**
         * Gets a 3-component vector from the array at a specific composition offset
         * @param offsetAsComposition - The composition index (element index = offsetAsComposition * 3)
         * @returns A new Array3 containing three elements at the specified composition offset
         */
        [get3_offsetAsComposition](this: ArrayType, offsetAsComposition: number): Array3<number>;
        /**
         * Gets a 4-component vector from the beginning of the array
         * @returns A new Array4 containing the first four elements
         */
        [get4](this: ArrayType): Array4<number>;
        /**
         * Gets a 4-component vector from the array at a specific offset
         * @param offset - The index offset to start reading from
         * @returns A new Array4 containing four elements starting at the specified offset
         */
        [get4_offset](this: ArrayType, offset: number): Array4<number>;
        /**
         * Gets a 4-component vector from the array at a specific composition offset
         * @param offsetAsComposition - The composition index (element index = offsetAsComposition * 4)
         * @returns A new Array4 containing four elements at the specified composition offset
         */
        [get4_offsetAsComposition](this: ArrayType, offsetAsComposition: number): Array4<number>;
        /**
         * Gets an N-component vector from the array at a specific offset
         * @param offset - The index offset to start reading from
         * @param componentN - The number of components to read
         * @returns A new Array containing N elements starting at the specified offset
         */
        [getN_offset](this: ArrayType, offset: number, componentN: number): Array<number>;
        /**
         * Gets an N-component vector from the array at a specific composition offset
         * @param offsetAsComposition - The composition index (element index = offsetAsComposition * componentN)
         * @param componentN - The number of components to read
         * @returns A new Array containing N elements at the specified composition offset
         */
        [getN_offsetAsComposition](this: ArrayType, offsetAsComposition: number, componentN: number): Array<number>;
        /**
         * Adds a 2-component vector to this array in-place
         * @param array - The array to add
         * @returns The modified array (this)
         */
        [add2](this: ArrayType, array: ArrayType): ArrayType;
        /**
         * Adds a 2-component vector to this array in-place at specific offsets
         * @param array - The array to add
         * @param selfOffset - The offset in this array
         * @param argOffset - The offset in the argument array
         * @returns The modified array (this)
         */
        [add2_offset](this: ArrayType, array: ArrayType, selfOffset: number, argOffset: number): ArrayType;
        /**
         * Adds a 3-component vector to this array in-place
         * @param array - The array to add
         * @returns The modified array (this)
         */
        [add3](this: ArrayType, array: ArrayType): ArrayType;
        /**
         * Adds a 3-component vector to this array in-place at specific offsets
         * @param array - The array to add
         * @param selfOffset - The offset in this array
         * @param argOffset - The offset in the argument array
         * @returns The modified array (this)
         */
        [add3_offset](this: ArrayType, array: ArrayType, selfOffset: number, argOffset: number): ArrayType;
        /**
         * Adds a 4-component vector to this array in-place
         * @param array - The array to add
         * @returns The modified array (this)
         */
        [add4](this: ArrayType, array: ArrayType): ArrayType;
        /**
         * Adds a 4-component vector to this array in-place at specific offsets
         * @param array - The array to add
         * @param selfOffset - The offset in this array
         * @param argOffset - The offset in the argument array
         * @returns The modified array (this)
         */
        [add4_offset](this: ArrayType, array: ArrayType, selfOffset: number, argOffset: number): ArrayType;
        /**
         * Multiplies a 3-component vector by a scalar in-place at a specific offset
         * @param offset - The offset in the array
         * @param value - The scalar value to multiply by
         * @returns The modified array (this)
         */
        [mulArray3WithScalar_offset](this: ArrayType, offset: number, value: number): Array4<number>;
        /**
         * Multiplies a 4-component vector by a scalar in-place at a specific offset
         * @param offset - The offset in the array
         * @param value - The scalar value to multiply by
         * @returns The modified array (this)
         */
        [mulArray4WithScalar_offset](this: ArrayType, offset: number, value: number): Array4<number>;
        /**
         * Multiplies an N-component vector by a scalar in-place at a specific offset
         * @param offset - The offset in the array
         * @param componentN - The number of components to multiply
         * @param value - The scalar value to multiply by
         * @returns The modified array (this)
         */
        [mulArrayNWithScalar_offset](this: ArrayType, offset: number, componentN: number, value: number): Array4<number>;
        /**
         * Multiplies two 4x4 matrices and stores the result in an output array
         * @param thisOffsetAsComposition - The composition offset for this matrix
         * @param that - The other matrix array
         * @param thatOffsetAsComposition - The composition offset for the other matrix
         * @param out - The output array to store the result
         * @returns The output array
         */
        [mulThatAndThisToOutAsMat44_offsetAsComposition](this: ArrayType, thisOffsetAsComposition: number, that: ArrayType, thatOffsetAsComposition: number, out: ArrayType): ArrayType;
        /**
         * Performs quaternion spherical linear interpolation (SLERP) at specific composition offsets
         * @param array - The target quaternion array
         * @param ratio - The interpolation ratio (0.0 to 1.0)
         * @param selfOffsetAsComposition - The composition offset for this quaternion
         * @param argOffsetAsComposition - The composition offset for the target quaternion
         * @returns A new Array4 containing the interpolated quaternion
         */
        [qlerp_offsetAsComposition](this: ArrayType, array: ArrayType, ratio: number, selfOffsetAsComposition: number, argOffsetAsComposition: number): Array4<number>;
        /**
         * Performs scalar linear interpolation at specific offsets
         * @param array - The target scalar array
         * @param ratio - The interpolation ratio (0.0 to 1.0)
         * @param selfOffset - The offset in this array
         * @param argOffset - The offset in the target array
         * @returns The interpolated scalar value
         */
        [scalar_lerp_offsetAsComposition](this: ArrayType, array: ArrayType, ratio: number, selfOffset: number, argOffset: number): number;
        /**
         * Performs 2-component vector linear interpolation at specific composition offsets
         * @param array - The target vector array
         * @param ratio - The interpolation ratio (0.0 to 1.0)
         * @param selfOffsetAsComposition - The composition offset for this vector
         * @param argOffsetAsComposition - The composition offset for the target vector
         * @returns A new Array2 containing the interpolated vector
         */
        [array2_lerp_offsetAsComposition](this: ArrayType, array: ArrayType, ratio: number, selfOffsetAsComposition: number, argOffsetAsComposition: number): Array2<number>;
        /**
         * Performs 3-component vector linear interpolation at specific composition offsets
         * @param array - The target vector array
         * @param ratio - The interpolation ratio (0.0 to 1.0)
         * @param selfOffsetAsComposition - The composition offset for this vector
         * @param argOffsetAsComposition - The composition offset for the target vector
         * @returns A new Array3 containing the interpolated vector
         */
        [array3_lerp_offsetAsComposition](this: ArrayType, array: ArrayType, ratio: number, selfOffsetAsComposition: number, argOffsetAsComposition: number): Array3<number>;
        /**
         * Performs 4-component vector linear interpolation at specific composition offsets
         * @param array - The target vector array
         * @param ratio - The interpolation ratio (0.0 to 1.0)
         * @param selfOffsetAsComposition - The composition offset for this vector
         * @param argOffsetAsComposition - The composition offset for the target vector
         * @returns A new Array4 containing the interpolated vector
         */
        [array4_lerp_offsetAsComposition](this: ArrayType, array: ArrayType, ratio: number, selfOffsetAsComposition: number, argOffsetAsComposition: number): Array4<number>;
        /**
         * Performs N-component vector linear interpolation at specific composition offsets
         * @param array - The target vector array
         * @param componentN - The number of components in the vectors
         * @param ratio - The interpolation ratio (0.0 to 1.0)
         * @param selfOffsetAsComposition - The composition offset for this vector
         * @param argOffsetAsComposition - The composition offset for the target vector
         * @returns A new Array containing the interpolated vector
         */
        [arrayN_lerp_offsetAsComposition](this: ArrayType, array: ArrayType, componentN: number, ratio: number, selfOffsetAsComposition: number, argOffsetAsComposition: number): Array<number>;
        /**
         * Normalizes a 4-component vector in-place
         * @returns The normalized vector (this)
         */
        [normalizeArray4](this: Array4<number>): Array4<number>;
    }
    interface Array<T> extends Extension {
    }
    interface ReadonlyArray<T> extends Extension {
    }
    interface Float32Array extends Extension {
    }
}

/**
 * Interface for math number types that are based on ArrayBuffer.
 * This interface provides functionality to check if the underlying ArrayBuffer
 * is the same as a given ArrayBuffer, which is useful for memory management
 * and avoiding unnecessary data copying operations.
 */
interface IArrayBufferBasedMathNumber {
    /**
     * Checks whether the underlying ArrayBuffer of this math number object
     * is the same as the provided ArrayBuffer.
     *
     * @param arrayBuffer - The ArrayBuffer to compare with the underlying buffer
     * @returns true if the ArrayBuffer is the same instance, false otherwise
     */
    isTheSourceSame(arrayBuffer: ArrayBuffer): boolean;
}

/**
 * Abstract base class for math number implementations that are backed by ArrayBuffer.
 * This class provides common functionality for typed array-based mathematical objects.
 *
 * @abstract
 */
declare abstract class AbstractArrayBufferBaseMathNumber implements IArrayBufferBasedMathNumber {
    _v: TypedArray;
    /**
     * Checks if the internal typed array is backed by the same ArrayBuffer as the provided one.
     * This is useful for determining if two math objects share the same underlying memory.
     *
     * @param arrayBuffer - The ArrayBuffer to compare against
     * @returns True if the internal typed array uses the same ArrayBuffer, false otherwise
     */
    isTheSourceSame(arrayBuffer: ArrayBuffer): boolean;
}

/**
 * A 3x3 identity matrix implementation that represents the multiplicative identity for 3x3 matrices.
 * This matrix has 1s on the main diagonal and 0s elsewhere:
 * ```
 * [1 0 0]
 * [0 1 0]
 * [0 0 1]
 * ```
 *
 * This class is optimized for identity matrix operations and provides constant-time
 * access to matrix elements without storing the actual matrix data.
 */
declare class IdentityMatrix33 extends AbstractMatrix implements IMatrix, IMatrix33 {
    /** Shared Float32Array containing the identity matrix values [1,0,0,0,1,0,0,0,1] */
    static readonly __v: Float32Array<ArrayBuffer>;
    /**
     * Creates a new 3x3 identity matrix instance.
     * Uses a shared static array for memory efficiency.
     */
    constructor();
    /**
     * Returns a string representation of the identity matrix in a readable format.
     * @returns A formatted string showing the 3x3 identity matrix
     */
    toString(): string;
    /**
     * Returns an approximate string representation of the matrix.
     * For identity matrix, this is identical to toString() since all values are exact.
     * @returns A formatted string showing the 3x3 identity matrix
     */
    toStringApproximately(): string;
    /**
     * Returns the matrix elements as a flattened array in row-major order.
     * @returns An array containing [1,0,0,0,1,0,0,0,1]
     */
    flattenAsArray(): number[];
    /**
     * Indicates whether this matrix is a dummy/placeholder matrix.
     * Identity matrices are never considered dummy matrices.
     * @returns Always false for identity matrices
     */
    isDummy(): boolean;
    /**
     * Checks if another matrix is approximately equal to this identity matrix within a tolerance.
     * @param mat - The matrix to compare against
     * @param delta - The tolerance for floating-point comparison (default: Number.EPSILON)
     * @returns True if the matrix is approximately an identity matrix
     */
    isEqual(mat: IMatrix33, delta?: number): boolean;
    /**
     * Checks if another matrix is strictly equal to this identity matrix (exact comparison).
     * Note: This method appears to have a bug - it checks 16 elements instead of 9 for a 3x3 matrix.
     * @param mat - The matrix to compare against
     * @returns True if the matrix is exactly an identity matrix
     */
    isStrictEqual(mat: IMatrix33): boolean;
    /**
     * Gets the matrix element at the specified row and column.
     * For identity matrix: returns 1 if row equals column, 0 otherwise.
     * @param row_i - The row index (0-2)
     * @param column_i - The column index (0-2)
     * @returns The matrix element value
     */
    at(row_i: number, column_i: number): number;
    /**
     * Calculates the determinant of the identity matrix.
     * The determinant of any identity matrix is always 1.
     * @returns Always returns 1
     */
    determinant(): number;
    /**
     * Multiplies this identity matrix with a vector.
     * Since this is an identity matrix, the result is the original vector unchanged.
     * @param vec - The vector to multiply
     * @returns The same vector (identity operation)
     */
    multiplyVector(vec: IVector): IVector;
    /**
     * Multiplies this identity matrix with a vector and stores the result in an output vector.
     * Since this is an identity matrix, this copies the input vector to the output vector.
     * @param vec - The input vector to multiply
     * @param outVec - The output vector to store the result
     * @returns The output vector containing the result
     */
    multiplyVectorTo(vec: IVector, outVec: IMutableVector): IMutableVector;
    /**
     * Gets the scale components from this matrix.
     * For identity matrix, all scale components are 1.
     * @returns A Vector3 with components [1, 1, 1]
     */
    getScale(): IVector;
    /**
     * Gets the scale components from this matrix and stores them in an output vector.
     * For identity matrix, all scale components are 1.
     * @param outVec - The output vector to store the scale values
     * @returns The output vector containing [1, 1, 1]
     */
    getScaleTo(outVec: IMutableVector): IMutableVector;
    /**
     * Creates a copy of this identity matrix.
     * @returns A new IdentityMatrix33 instance
     */
    clone(): IMatrix33;
    /**
     * Extracts the rotation part of this matrix.
     * For identity matrix, the rotation is also identity (no rotation).
     * @returns A new IdentityMatrix33 instance representing no rotation
     */
    getRotate(): IMatrix33;
    /** Gets the matrix element at row 0, column 0 */
    get m00(): number;
    /** Gets the matrix element at row 1, column 0 */
    get m10(): number;
    /** Gets the matrix element at row 2, column 0 */
    get m20(): number;
    /** Gets the matrix element at row 3, column 0 (not applicable for 3x3 matrix) */
    get m30(): number;
    /** Gets the matrix element at row 0, column 1 */
    get m01(): number;
    /** Gets the matrix element at row 1, column 1 */
    get m11(): number;
    /** Gets the matrix element at row 2, column 1 */
    get m21(): number;
    /** Gets the matrix element at row 3, column 1 (not applicable for 3x3 matrix) */
    get m31(): number;
    /** Gets the matrix element at row 0, column 2 */
    get m02(): number;
    /** Gets the matrix element at row 1, column 2 */
    get m12(): number;
    /** Gets the matrix element at row 1, column 2 */
    get m22(): number;
    /** Gets the matrix element at row 3, column 2 (not applicable for 3x3 matrix) */
    get m32(): number;
    /** Gets the matrix element at row 0, column 3 (not applicable for 3x3 matrix) */
    get m03(): number;
    /** Gets the matrix element at row 1, column 3 (not applicable for 3x3 matrix) */
    get m13(): number;
    /** Gets the matrix element at row 2, column 3 (not applicable for 3x3 matrix) */
    get m23(): number;
    /** Gets the matrix element at row 3, column 3 (not applicable for 3x3 matrix) */
    get m33(): number;
    /** Gets the class name for debugging and reflection purposes */
    get className(): string;
    /** Gets the composition type for this matrix class */
    static get compositionType(): {
        readonly __numberOfComponents: number;
        readonly __glslStr: string;
        readonly __hlslStr: string;
        readonly __webgpuStr: string;
        readonly __wgslStr: string;
        readonly __isArray: boolean;
        readonly __vec4SizeOfProperty: IndexOf16Bytes;
        readonly __dummyStr: "MAT3";
        readonly webgpu: string;
        readonly wgsl: string;
        getNumberOfComponents(): Count;
        getGlslStr(componentType: ComponentTypeEnum): string;
        getGlslInitialValue(componentType: ComponentTypeEnum): string;
        getWgslInitialValue(componentType: ComponentTypeEnum): string;
        toWGSLType(componentType: ComponentTypeEnum): string;
        getVec4SizeOfProperty(): IndexOf16Bytes;
        readonly index: number;
        readonly symbol: symbol;
        readonly str: string;
        toString(): string;
        toJSON(): number;
    };
    /** Indicates that this is an identity matrix class implementation */
    get isIdentityMatrixClass(): boolean;
}

/**
 * Represents a logarithm of a quaternion, which provides a more compact representation
 * for quaternion interpolation and mathematical operations. A log quaternion stores
 * only the x, y, z components as the w component is implicitly 1.
 */
declare class LogQuaternion implements ILogQuaternion {
    _v: Float32Array;
    /**
     * Creates a new LogQuaternion instance.
     * @param x - Float32Array containing the x, y, z components
     */
    constructor(x: Float32Array);
    /**
     * Gets the x component of the log quaternion.
     * @returns The x component value
     */
    get x(): number;
    /**
     * Gets the y component of the log quaternion.
     * @returns The y component value
     */
    get y(): number;
    /**
     * Gets the z component of the log quaternion.
     * @returns The z component value
     */
    get z(): number;
    /**
     * Gets the w component of the log quaternion. Always returns 1 for log quaternions.
     * @returns Always returns 1
     */
    get w(): number;
    /**
     * Creates a LogQuaternion from an existing Float32Array.
     * @param array - Float32Array containing the x, y, z components
     * @returns A new LogQuaternion instance
     */
    static fromFloat32Array(array: Float32Array): LogQuaternion;
    /**
     * Creates a LogQuaternion from a 3-element array by copying the values.
     * @param array - Array of 3 numbers representing x, y, z components
     * @returns A new Quaternion instance (note: this should return LogQuaternion)
     */
    static fromCopyArray3(array: Array3<number>): Quaternion;
    /**
     * Creates a LogQuaternion from an array by copying the first 3 values.
     * @param array - Array of numbers (only first 3 elements are used)
     * @returns A new Quaternion instance (note: this should return LogQuaternion)
     */
    static fromCopyArray(array: Array<number>): Quaternion;
    /**
     * Creates a LogQuaternion from individual x, y, z component values.
     * @param x - The x component
     * @param y - The y component
     * @param z - The z component
     * @returns A new Quaternion instance (note: this should return LogQuaternion)
     */
    static fromCopy3(x: number, y: number, z: number): Quaternion;
    /**
     * Creates a LogQuaternion by copying from another LogQuaternion.
     * @param quat - The source LogQuaternion to copy from
     * @returns A new Quaternion instance (note: this should return LogQuaternion)
     */
    static fromCopyLogQuaternion(quat: ILogQuaternion): Quaternion;
    /**
     * Creates a LogQuaternion from a 3D vector by copying its components.
     * @param vec - The source IVector3 to copy from
     * @returns A new Quaternion instance (note: this should return LogQuaternion)
     */
    static fromCopyVector4(vec: IVector3): Quaternion;
    /**
     * Converts a regular quaternion to its logarithmic form.
     * Uses the formula: log(q) = (/sin()) * (x, y, z) where  = acos(w)
     * @param x - The source quaternion to convert
     * @returns A new LogQuaternion representing the logarithm of the input quaternion
     */
    static fromCopyQuaternion(x: IQuaternion): LogQuaternion;
    /**
     * Gets the class name identifier.
     * @returns The string 'LogQuaternion'
     */
    get className(): string;
}

/**
 * Utility class providing various mathematical operations and conversions for vector, matrix, and quaternion types.
 * This class contains static methods for converting between different mathematical representations,
 * performing arithmetic operations, and manipulating mathematical objects.
 */
declare class MathClassUtil {
    private static __tmpVector4_0;
    private static __tmpVector4_1;
    /**
     * Converts an array of numbers to the appropriate Vector type based on array length.
     * @param element - Array of numbers to convert
     * @returns Vector2, Vector3, or Vector4 instance based on array length, or the original element if not an array
     */
    static arrayToVector(element: Array<number>): Vector4 | Vector3 | Vector2;
    /**
     * Converts an array of numbers to the appropriate Vector or Matrix type based on array length.
     * Supports conversion to Matrix44, Matrix33, Vector4, Vector3, or Vector2.
     * @param element - Array of numbers to convert
     * @returns Matrix44, Matrix33, Vector4, Vector3, or Vector2 instance based on array length, or the original element if not an array
     */
    static arrayToVectorOrMatrix(element: Array<number>): Vector4 | Matrix44 | Vector3 | Matrix33 | Vector2;
    /**
     * Gets the immutable value class constructor for a given composition type.
     * @param compositionType - The composition type enum value
     * @returns Constructor function for the corresponding immutable math class, or undefined if not supported
     */
    static getImmutableValueClass(compositionType: CompositionTypeEnum): Function | undefined;
    /**
     * Gets the mutable value class constructor for a given composition type.
     * @param compositionType - The composition type enum value
     * @returns Constructor function for the corresponding mutable math class, or undefined if not supported
     */
    static getMutableValueClass(compositionType: CompositionTypeEnum): Function | undefined;
    /**
     * Creates a deep clone of mathematical objects (matrices and vectors).
     * @param element - The mathematical object to clone
     * @returns A cloned instance of the input object, or the original element if it's not a mathematical object
     */
    static cloneOfMathObjects(element: any): any;
    /**
     * Checks if an array is suitable for quaternion conversion (has 4 elements).
     * @param element - Array to check
     * @returns True if the array has 4 elements and can be converted to a quaternion
     */
    static isAcceptableArrayForQuaternion(element: Array<number>): boolean;
    /**
     * Converts a 4-element array to a Quaternion instance.
     * @param element - Array of 4 numbers representing quaternion components [x, y, z, w]
     * @returns Quaternion instance created from the array elements
     */
    static arrayToQuaternion(element: Array<number>): Quaternion;
    /**
     * Creates a sub-array with the specified number of components from the beginning of the input array.
     * @param array - Source array to extract elements from
     * @param componentN - Number of components to extract (1-4)
     * @returns Sub-array with the specified number of elements, or single element if componentN is 1
     */
    static makeSubArray(array: Array<any>, componentN: number): any;
    /**
     * Converts vector instances to arrays of their component values.
     * @param element - Vector2, Vector3, Vector4, or Quaternion instance
     * @returns Array representation of the vector components, or the original element if not a vector
     */
    static vectorToArray(element: Vector2 | Vector3 | Vector4 | Quaternion): number[];
    /**
     * Determines the number of components in a vector instance or array.
     * @param element - Vector instance or array to analyze
     * @returns Number of components (2 for Vector2, 3 for Vector3, 4 for Vector4/Quaternion, array length for arrays, 0 for unsupported types)
     */
    static componentNumberOfVector(element: Vector2 | Vector3 | Vector4 | Quaternion | Array<any>): number;
    /**
     * Packs a normalized 4D vector into a 2D vector using a grid-based encoding scheme.
     * Input values must be in the range [-1, 1] and are converted to [0, 1] internally.
     * @param x - X component of the 4D vector (must be in range [-1, 1])
     * @param y - Y component of the 4D vector (must be in range [-1, 1])
     * @param z - Z component of the 4D vector (must be in range [-1, 1])
     * @param w - W component of the 4D vector (must be in range [-1, 1])
     * @param criteria - Grid resolution for encoding (determines precision)
     * @returns Array of 2 values representing the packed vector
     */
    static packNormalizedVec4ToVec2(x: number, y: number, z: number, w: number, criteria: number): number[];
    /**
     * Unprojects a window coordinate to world space using the inverse projection-view matrix.
     * Converts 2D screen coordinates with depth to 3D world coordinates.
     * @param windowPosX - X coordinate in window space
     * @param windowPosY - Y coordinate in window space
     * @param windowPosZ - Z coordinate (depth) in window space
     * @param inversePVMat44 - Inverse of the projection-view matrix
     * @param viewportVec4 - Viewport parameters [x, y, width, height]
     * @param out - Output vector to store the result
     * @returns The unprojected 3D world position
     */
    static unProjectTo(windowPosX: number, windowPosY: number, windowPosZ: number, inversePVMat44: Matrix44, viewportVec4: Vector4, out: MutableVector3): IMutableVector3;
    /**
     * Performs addition operation on various mathematical types.
     * Supports numbers, vectors, quaternions, and arrays.
     * @param lhs - Left-hand side operand
     * @param rhs - Right-hand side operand
     * @returns Result of the addition operation, type depends on input types
     */
    static add(lhs: any, rhs: any): any;
    /**
     * Performs subtraction operation on various mathematical types.
     * Supports numbers, vectors, quaternions, and arrays.
     * @param lhs - Left-hand side operand (minuend)
     * @param rhs - Right-hand side operand (subtrahend)
     * @returns Result of the subtraction operation, type depends on input types
     */
    static subtract(lhs: any, rhs: any): number | number[] | Vector4 | Vector3 | Quaternion | Vector2 | undefined;
    /**
     * Multiplies various mathematical types by a scalar number.
     * Supports numbers, vectors, quaternions, and arrays.
     * @param lhs - Mathematical object to multiply
     * @param rhs - Scalar multiplier
     * @returns Result of the scalar multiplication, type depends on input type
     */
    static multiplyNumber(lhs: any, rhs: number): number | number[] | Vector4 | Vector3 | Quaternion | Vector2 | undefined;
    /**
     * Divides various mathematical types by a scalar number.
     * Supports numbers, vectors, quaternions, and arrays.
     * @param lhs - Mathematical object to divide
     * @param rhs - Scalar divisor
     * @returns Result of the scalar division, type depends on input type
     */
    static divideNumber(lhs: any, rhs: number): number | number[] | Vector4 | Vector3 | Quaternion | Vector2 | undefined;
    /**
     * Initializes a mathematical object of the same type as the input with a scalar value.
     * For vectors and arrays, all components are set to the scalar value.
     * For quaternions, creates an identity quaternion.
     * @param objForDetectType - Object used to determine the target type
     * @param val - Scalar value to initialize with
     * @returns New instance of the same type as objForDetectType initialized with val
     */
    static initWithScalar(objForDetectType: any, val: number): number | number[] | Vector4 | Vector3 | Quaternion | Vector2 | undefined;
    /**
     * Initializes a mutable mathematical object from a value using a provided Float32Array as storage.
     * This method efficiently reuses memory by using the provided array as the backing store.
     * @param val - Value to initialize from (can be various mathematical types)
     * @param floatArray - Float32Array to use as backing storage
     * @returns Mutable mathematical object using the provided array as storage
     */
    static initWithFloat32Array(val: any, floatArray: Float32Array): any;
    /**
     * Forcefully sets the internal values of a mathematical object to match another object's values.
     * This method directly modifies the internal array representation for performance.
     * Performs equality check to avoid unnecessary operations.
     * @param objForDetectType - Target object to modify
     * @param val - Source object or value to copy from
     * @returns True if values were changed, false if they were already equal
     */
    static _setForce(objForDetectType: any, val: any): boolean;
}

/**
 * Converts radians to degrees.
 * @param rad - The angle in radians
 * @returns The angle in degrees
 */
declare function radianToDegree(rad: number): number;
/**
 * Converts degrees to radians.
 * @param deg - The angle in degrees
 * @returns The angle in radians
 */
declare function degreeToRadian(deg: number): number;
/**
 * Checks whether a number is a power of two.
 * @param x - The number to check
 * @returns True if the number is a power of two, false otherwise
 */
declare function isPowerOfTwo(x: number): boolean;
/**
 * Checks whether the given texture dimensions are both powers of two.
 * @param width - The width of the texture
 * @param height - The height of the texture
 * @returns True if both dimensions are powers of two, false otherwise
 */
declare function isPowerOfTwoTexture(width: Size, height: Size): boolean;
/**
 * Packs a normalized 4D vector into a 2D vector using a specific encoding scheme.
 * All input values must be in the range [-1, 1].
 * @param x - The x component of the vector (range: [-1, 1])
 * @param y - The y component of the vector (range: [-1, 1])
 * @param z - The z component of the vector (range: [-1, 1])
 * @param w - The w component of the vector (range: [-1, 1])
 * @param criteria - The encoding criteria/resolution
 * @returns A 2-element array containing the packed values
 */
declare function packNormalizedVec4ToVec2(x: number, y: number, z: number, w: number, criteria: number): number[];
/**
 * Calculates the cumulative distribution function (CDF) for a Gaussian distribution.
 * @param x - The value at which to evaluate the CDF
 * @param mu - The mean of the Gaussian distribution
 * @param sigma - The standard deviation of the Gaussian distribution
 * @returns The cumulative probability up to x
 */
declare function gaussianCdf(x: number, mu: number, sigma: number): number;
/**
 * Calculates the inverse cumulative distribution function (inverse CDF) for a Gaussian distribution.
 * @param U - The cumulative probability (should be in range [0, 1])
 * @param mu - The mean of the Gaussian distribution
 * @param sigma - The standard deviation of the Gaussian distribution
 * @returns The value x such that CDF(x) = U
 */
declare function invGaussianCdf(U: number, mu: number, sigma: number): number;
/**
 * Computes eigenvalues and eigenvectors of a 3x3 symmetric matrix using the Jacobi method.
 * @param A - The input 3x3 symmetric matrix (will be modified during computation)
 * @param Q - The output matrix that will contain the eigenvectors
 * @param w - The output vector that will contain the eigenvalues
 * @returns 0 on success, -1 if maximum iterations exceeded
 */
declare function computeEigenValuesAndVectors(A: MutableMatrix33, Q: MutableMatrix33, w: MutableVector3): -1 | 0;
/**
 * Converts a numeric value to a string formatted for GLSL float literals.
 * Ensures that integer values are suffixed with ".0" for proper GLSL syntax.
 * @param value - The numeric value to convert
 * @returns A string representation suitable for GLSL float literals
 */
declare function convertToStringAsGLSLFloat(value: number): string;
/**
 * Rounds very small values to zero and values very close to 1 to exactly 1.
 * This helps reduce floating-point precision errors in calculations.
 * @param value - The value to normalize
 * @returns The normalized value with small errors corrected
 */
declare function nearZeroToZero(value: number): number;
/**
 * Formats a numeric value as a fixed-width financial string with 7 decimal places.
 * Positive values are prefixed with a space for alignment.
 * @param val - The numeric value to format
 * @returns A formatted string with consistent width for financial display
 */
declare function financial(val: number | string): string;
/**
 * Rounds a floating-point number to 7 decimal places to reduce precision errors.
 * @param value - The value to round
 * @returns The rounded value
 */
declare function roundAsFloat(value: number): number;
/**
 * Performs linear interpolation between two values.
 * @param a - The starting value
 * @param b - The ending value
 * @param t - The interpolation parameter (0 returns a, 1 returns b)
 * @returns The interpolated value
 */
declare function lerp(a: number, b: number, t: number): number;
/**
 * Computes a normalized discrete Gaussian distribution where the sum of all ratios equals 1.
 * The sampling points are positioned at integer intervals around the mean.
 *
 * @param params - Configuration object for the Gaussian distribution
 * @param params.kernelSize - Number of sampling points in the distribution
 * @param params.variance - Variance of the Gaussian distribution
 * @param params.mean - Mean of the Gaussian distribution (default: 0)
 * @param params.effectiveDigit - Number of decimal places for precision (default: 4)
 * @returns An array of normalized ratios that sum to 1
 *
 * @example
 * // For kernelSize = 2 (mean=0): sampling points are at -0.5 and 0.5
 * // For kernelSize = 3 (mean=1): sampling points are at 0.0, 1.0, and 2.0
 */
declare function computeGaussianDistributionRatioWhoseSumIsOne({ kernelSize, variance, mean, effectiveDigit, }: {
    kernelSize: Count;
    variance: number;
    mean?: number;
    effectiveDigit?: Count;
}): number[];
/**
 * A utility class containing various mathematical functions and operations.
 * This class provides static methods for common mathematical computations including:
 * - Angle conversions (radians/degrees)
 * - Floating point operations and conversions
 * - Power-of-two checks
 * - Vector packing utilities
 * - Statistical functions (Gaussian distributions, error functions)
 * - Matrix eigenvalue computations
 * - Interpolation and formatting utilities
 */
declare const MathUtil: Readonly<{
    radianToDegree: typeof radianToDegree;
    degreeToRadian: typeof degreeToRadian;
    toHalfFloat: () => ((val: number) => number);
    isPowerOfTwo: typeof isPowerOfTwo;
    isPowerOfTwoTexture: typeof isPowerOfTwoTexture;
    packNormalizedVec4ToVec2: typeof packNormalizedVec4ToVec2;
    convertToStringAsGLSLFloat: typeof convertToStringAsGLSLFloat;
    nearZeroToZero: typeof nearZeroToZero;
    gaussianCdf: typeof gaussianCdf;
    invGaussianCdf: typeof invGaussianCdf;
    computeEigenValuesAndVectors: typeof computeEigenValuesAndVectors;
    computeGaussianDistributionRatioWhoseSumIsOne: typeof computeGaussianDistributionRatioWhoseSumIsOne;
    roundAsFloat: typeof roundAsFloat;
    financial: typeof financial;
    lerp: typeof lerp;
}>;

/**
 * A mutable 2x2 matrix class that extends Matrix22 and provides modification capabilities.
 * This class allows in-place operations for matrix transformations, making it suitable
 * for performance-critical applications where object creation overhead should be minimized.
 *
 * The matrix is stored in column-major order as a Float32Array, compatible with WebGL.
 * Matrix layout:
 * ```
 * | m00 m01 |
 * | m10 m11 |
 * ```
 *
 * @example
 * ```typescript
 * const matrix = MutableMatrix22.identity();
 * matrix.rotate(Math.PI / 4); // Rotate 45 degrees
 * matrix.scale(Vector2.fromCopyArray([2, 3])); // Scale by 2x and 3y
 * ```
 */
declare class MutableMatrix22 extends Matrix22 implements IMutableMatrix, IMutableMatrix22 {
    /**
     * Sets the value at position (0,0) of the matrix.
     *
     * @param val - The value to set
     */
    set m00(val: number);
    /**
     * Gets the value at position (0,0) of the matrix.
     *
     * @returns The value at position (0,0)
     */
    get m00(): number;
    /**
     * Sets the value at position (1,0) of the matrix.
     *
     * @param val - The value to set
     */
    set m10(val: number);
    /**
     * Gets the value at position (1,0) of the matrix.
     *
     * @returns The value at position (1,0)
     */
    get m10(): number;
    /**
     * Sets the value at position (0,1) of the matrix.
     *
     * @param val - The value to set
     */
    set m01(val: number);
    /**
     * Gets the value at position (0,1) of the matrix.
     *
     * @returns The value at position (0,1)
     */
    get m01(): number;
    /**
     * Sets the value at position (1,1) of the matrix.
     *
     * @param val - The value to set
     */
    set m11(val: number);
    /**
     * Gets the value at position (1,1) of the matrix.
     *
     * @returns The value at position (1,1)
     */
    get m11(): number;
    /**
     * Gets the class name for debugging purposes.
     *
     * @returns The class name "MutableMatrix22"
     */
    get className(): string;
    /**
     * Creates a new zero matrix where all elements are 0.
     *
     * @returns A new MutableMatrix22 instance with all zero values
     */
    static zero(): MutableMatrix22;
    /**
     * Creates a new 2x2 identity matrix.
     *
     * @returns A new MutableMatrix22 identity matrix
     */
    static identity(): MutableMatrix22;
    /**
     * Creates a dummy matrix for placeholder purposes.
     *
     * @returns A new MutableMatrix22 dummy instance
     */
    static dummy(): MutableMatrix22;
    /**
     * Creates a new matrix that is the transpose of the input matrix.
     *
     * @param mat - The matrix to transpose
     * @returns A new MutableMatrix22 containing the transposed matrix
     */
    static transpose(mat: Matrix22): MutableMatrix22;
    /**
     * Creates a new matrix that is the inverse of the input matrix.
     *
     * @param mat - The matrix to invert
     * @returns A new MutableMatrix22 containing the inverted matrix
     * @throws Error if the matrix is not invertible (determinant is 0)
     */
    static invert(mat: Matrix22): MutableMatrix22;
    /**
     * Creates a new rotation matrix for the given angle.
     *
     * @param radian - The rotation angle in radians
     * @returns A new MutableMatrix22 representing the rotation transformation
     */
    static rotate(radian: number): MutableMatrix22;
    /**
     * Creates a new scale matrix from a 2D vector.
     *
     * @param vec - Vector2 containing the scale factors for x and y axes
     * @returns A new MutableMatrix22 representing the scale transformation
     */
    static scale(vec: Vector2): MutableMatrix22;
    /**
     * Multiplies two matrices and returns a new matrix with the result.
     *
     * @param l_mat - The left matrix operand
     * @param r_mat - The right matrix operand
     * @returns A new MutableMatrix22 containing the multiplication result
     */
    static multiply(l_mat: Matrix22, r_mat: Matrix22): MutableMatrix22;
    /**
     * Creates a deep copy of this matrix.
     *
     * @returns A new MutableMatrix22 instance with the same values
     */
    clone(): MutableMatrix22;
    /**
     * Gets the raw Float32Array containing the matrix data.
     *
     * @returns The internal Float32Array in column-major order
     */
    raw(): Float32Array<ArrayBufferLike>;
    /**
     * Sets the value at the specified row and column position.
     *
     * @param row_i - The row index (0-1)
     * @param column_i - The column index (0-1)
     * @param value - The value to set
     * @returns This matrix instance for method chaining
     */
    setAt(row_i: number, column_i: number, value: number): this;
    /**
     * Sets all matrix components directly.
     *
     * @param m00 - Value for position (0,0)
     * @param m01 - Value for position (0,1)
     * @param m10 - Value for position (1,0)
     * @param m11 - Value for position (1,1)
     * @returns This matrix instance for method chaining
     */
    setComponents(m00: number, m01: number, m10: number, m11: number): MutableMatrix22;
    /**
     * Copies the 2x2 portion of another matrix into this matrix.
     * Works with Matrix22, Matrix33, or Matrix44 sources.
     *
     * @param mat - The source matrix to copy from
     * @returns This matrix instance for method chaining
     */
    copyComponents(mat: Matrix22 | Matrix33 | Matrix44): this;
    /**
     * Sets this matrix to a zero matrix (all elements are 0).
     *
     * @returns This matrix instance for method chaining
     */
    zero(): MutableMatrix22;
    /**
     * Sets this matrix to an identity matrix.
     *
     * @returns This matrix instance for method chaining
     */
    identity(): MutableMatrix22;
    /**
     * Internal helper method to swap two elements in the matrix array.
     *
     * @param l - Index of the first element
     * @param r - Index of the second element
     */
    _swap(l: Index, r: Index): void;
    /**
     * Transposes this matrix in place (swaps rows and columns).
     *
     * @returns This matrix instance for method chaining
     */
    transpose(): this;
    /**
     * Inverts this matrix in place.
     *
     * @returns This matrix instance for method chaining
     * @throws Error if the matrix is not invertible (determinant is 0)
     */
    invert(): MutableMatrix22;
    /**
     * Sets this matrix to a rotation matrix for the given angle.
     *
     * @param radian - The rotation angle in radians
     * @returns This matrix instance for method chaining
     */
    rotate(radian: number): MutableMatrix22;
    /**
     * Sets this matrix to a scale matrix from a 2D vector.
     *
     * @param vec - Vector2 containing the scale factors for x and y axes
     * @returns This matrix instance for method chaining
     */
    scale(vec: Vector2): MutableMatrix22;
    /**
     * Multiplies this matrix by a scale transformation in place.
     *
     * @param vec - Vector2 containing the scale factors for x and y axes
     * @returns This matrix instance for method chaining
     */
    multiplyScale(vec: Vector2): this;
    /**
     * Multiplies this matrix by another matrix from the right side (this * mat).
     *
     * @param mat - The matrix to multiply with
     * @returns This matrix instance for method chaining
     */
    multiply(mat: Matrix22): MutableMatrix22;
    /**
     * Multiplies this matrix by another matrix from the left side (mat * this).
     *
     * @param mat - The matrix to multiply with from the left
     * @returns This matrix instance for method chaining
     */
    multiplyByLeft(mat: Matrix22): MutableMatrix22;
    /**
     * Creates a new matrix from values provided in row-major order.
     * This is more intuitive for manual input as values are specified
     * in the same order they appear visually in the matrix.
     *
     * @param m00 - Value for position (0,0)
     * @param m01 - Value for position (0,1)
     * @param m10 - Value for position (1,0)
     * @param m11 - Value for position (1,1)
     * @returns A new MutableMatrix22 instance
     */
    static fromCopy4RowMajor(m00: number, m01: number, m10: number, m11: number): MutableMatrix22;
    /**
     * Creates a new matrix from values provided in column-major order.
     * This matches the internal storage format used by WebGL.
     *
     * @param m00 - Value for position (0,0)
     * @param m10 - Value for position (1,0)
     * @param m01 - Value for position (0,1)
     * @param m11 - Value for position (1,1)
     * @returns A new MutableMatrix22 instance
     */
    static fromCopy4ColumnMajor(m00: number, m10: number, m01: number, m11: number): MutableMatrix22;
    /**
     * Creates a new matrix using the provided Float32Array directly (no copy).
     * The array is expected to be in column-major order.
     *
     * @param float32Array - Float32Array containing matrix data in column-major order
     * @returns A new MutableMatrix22 instance sharing the provided array
     */
    static fromFloat32ArrayColumnMajor(float32Array: Float32Array): MutableMatrix22;
    /**
     * Creates a new matrix by copying from a Float32Array in column-major order.
     *
     * @param float32Array - Float32Array containing matrix data in column-major order
     * @returns A new MutableMatrix22 instance with copied data
     */
    static fromCopyFloat32ArrayColumnMajor(float32Array: Float32Array): MutableMatrix22;
    /**
     * Creates a new matrix by copying from a Float32Array in row-major order.
     *
     * @param array - Float32Array containing matrix data in row-major order
     * @returns A new MutableMatrix22 instance with converted data
     */
    static fromCopyFloat32ArrayRowMajor(array: Float32Array): MutableMatrix22;
    /**
     * Creates a new matrix by copying from another Matrix22 instance.
     *
     * @param mat - The source Matrix22 to copy from
     * @returns A new MutableMatrix22 instance with copied data
     */
    static fromCopyMatrix22(mat: IMatrix22): MutableMatrix22;
    /**
     * Creates a new matrix from a 4-element array in column-major order.
     *
     * @param array - Array4 containing matrix data in column-major order
     * @returns A new MutableMatrix22 instance with copied data
     */
    static fromCopyArray9ColumnMajor(array: Array4<number>): MutableMatrix22;
    /**
     * Creates a new matrix from an array in column-major order.
     *
     * @param array - Array containing matrix data in column-major order
     * @returns A new MutableMatrix22 instance with copied data
     */
    static fromCopyArrayColumnMajor(array: Array<number>): MutableMatrix22;
    /**
     * Creates a new matrix from a 4-element array in row-major order.
     *
     * @param array - Array4 containing matrix data in row-major order
     * @returns A new MutableMatrix22 instance with converted data
     */
    static fromCopyArray9RowMajor(array: Array4<number>): MutableMatrix22;
    /**
     * Creates a new matrix from an array in row-major order.
     *
     * @param array - Array containing matrix data in row-major order
     * @returns A new MutableMatrix22 instance with converted data
     */
    static fromCopyArrayRowMajor(array: Array<number>): MutableMatrix22;
}

/**
 * A 2x2 matrix class for 2D transformations and linear algebra operations.
 *
 * This immutable matrix class supports common 2D transformations including
 * rotation, scaling, and general linear transformations. The matrix data
 * is stored in column-major order as a Float32Array for WebGL compatibility.
 *
 * Matrix layout:
 * ```
 * | m00 m01 |
 * | m10 m11 |
 * ```
 *
 * @example
 * ```typescript
 * // Create identity matrix
 * const identity = Matrix22.identity();
 *
 * // Create rotation matrix
 * const rotation = Matrix22.rotate(Math.PI / 4);
 *
 * // Create scale matrix
 * const scale = Matrix22.scale(Vector2.fromCopyArray2([2, 3]));
 * ```
 */
declare class Matrix22 extends AbstractMatrix implements IMatrix22 {
    /**
     * Creates a new Matrix22 instance.
     *
     * @param m - Float32Array containing matrix values in column-major order
     */
    constructor(m: Float32Array);
    /**
     * Gets the matrix element at row 0, column 0.
     *
     * @returns The m00 component of the matrix
     */
    get m00(): number;
    /**
     * Gets the matrix element at row 1, column 0.
     *
     * @returns The m10 component of the matrix
     */
    get m10(): number;
    /**
     * Gets the matrix element at row 0, column 1.
     *
     * @returns The m01 component of the matrix
     */
    get m01(): number;
    /**
     * Gets the matrix element at row 1, column 1.
     *
     * @returns The m11 component of the matrix
     */
    get m11(): number;
    /**
     * Gets the class name for this matrix type.
     *
     * @returns The string 'Matrix22'
     */
    get className(): string;
    /**
     * Gets the composition type for this matrix.
     *
     * @returns The CompositionType.Mat2 enum value
     */
    static get compositionType(): {
        readonly __numberOfComponents: number;
        readonly __glslStr: string;
        readonly __hlslStr: string;
        readonly __webgpuStr: string;
        readonly __wgslStr: string;
        readonly __isArray: boolean;
        readonly __vec4SizeOfProperty: IndexOf16Bytes;
        readonly __dummyStr: "MAT2";
        readonly webgpu: string;
        readonly wgsl: string;
        getNumberOfComponents(): Count;
        getGlslStr(componentType: ComponentTypeEnum): string;
        getGlslInitialValue(componentType: ComponentTypeEnum): string;
        getWgslInitialValue(componentType: ComponentTypeEnum): string;
        toWGSLType(componentType: ComponentTypeEnum): string;
        getVec4SizeOfProperty(): IndexOf16Bytes;
        readonly index: number;
        readonly symbol: symbol;
        readonly str: string;
        toString(): string;
        toJSON(): number;
    };
    /**
     * Creates a 2x2 zero matrix.
     *
     * @returns A new Matrix22 with all elements set to 0
     *
     * @example
     * ```typescript
     * const zero = Matrix22.zero();
     * // Returns:
     * // | 0 0 |
     * // | 0 0 |
     * ```
     */
    static zero(): Matrix22;
    /**
     * Creates a 2x2 identity matrix.
     *
     * @returns A new Matrix22 identity matrix
     *
     * @example
     * ```typescript
     * const identity = Matrix22.identity();
     * // Returns:
     * // | 1 0 |
     * // | 0 1 |
     * ```
     */
    static identity(): Matrix22;
    /**
     * Creates a dummy matrix with empty data.
     * Used as a placeholder when no valid matrix data is available.
     *
     * @returns A new Matrix22 with empty Float32Array
     */
    static dummy(): Matrix22;
    /**
     * Creates the transpose of the given matrix.
     * The transpose swaps rows and columns: (i,j) becomes (j,i).
     *
     * @param mat - The matrix to transpose
     * @returns A new Matrix22 that is the transpose of the input matrix
     *
     * @example
     * ```typescript
     * const mat = Matrix22.fromCopy4RowMajor(1, 2, 3, 4);
     * const transposed = Matrix22.transpose(mat);
     * // Original:    Transposed:
     * // | 1 2 |  ->  | 1 3 |
     * // | 3 4 |      | 2 4 |
     * ```
     */
    static transpose(mat: Matrix22): Matrix22;
    /**
     * Creates the inverse of the given matrix.
     *
     * For a 2x2 matrix, the inverse is calculated using the formula:
     * A^(-1) = (1/det(A)) * | d -b |
     *                        |-c  a |
     * where A = | a b | and det(A) = ad - bc
     *           | c d |
     *
     * @param mat - The matrix to invert
     * @returns A new Matrix22 that is the inverse of the input matrix
     * @throws Error if the matrix is singular (determinant is 0)
     *
     * @example
     * ```typescript
     * const mat = Matrix22.fromCopy4RowMajor(2, 0, 0, 2);
     * const inverse = Matrix22.invert(mat);
     * // Returns:
     * // | 0.5   0 |
     * // |   0 0.5 |
     * ```
     */
    static invert(mat: Matrix22): Matrix22;
    /**
     * Calculates the inverse of the given matrix and stores the result in the output matrix.
     * This method avoids creating a new matrix instance for better performance.
     *
     * @param mat - The matrix to invert
     * @param outMat - The mutable matrix to store the result
     * @returns The output matrix containing the inverse
     * @throws Error if the matrix is singular (determinant is 0)
     */
    static invertTo(mat: Matrix22, outMat: MutableMatrix22): MutableMatrix22;
    /**
     * Creates a 2D rotation matrix for the given angle.
     *
     * The rotation matrix is:
     * | cos() -sin() |
     * | sin()  cos() |
     *
     * @param radian - The rotation angle in radians (positive values rotate counter-clockwise)
     * @returns A new Matrix22 representing the rotation transformation
     *
     * @example
     * ```typescript
     * // 90-degree counter-clockwise rotation
     * const rotation = Matrix22.rotate(Math.PI / 2);
     * ```
     */
    static rotate(radian: number): Matrix22;
    /**
     * Creates a 2D scaling matrix from a 2D vector.
     *
     * The scaling matrix is:
     * | sx  0 |
     * |  0 sy |
     *
     * @param vec - A Vector2 containing the scale factors for x and y axes
     * @returns A new Matrix22 representing the scaling transformation
     *
     * @example
     * ```typescript
     * const scale = Matrix22.scale(Vector2.fromCopyArray2([2, 3]));
     * // Creates a matrix that scales x by 2 and y by 3
     * ```
     */
    static scale(vec: Vector2): Matrix22;
    /**
     * Multiplies two 2x2 matrices and returns the result.
     * Matrix multiplication is not commutative: A * B  B * A in general.
     *
     * @param l_mat - The left matrix operand
     * @param r_mat - The right matrix operand
     * @returns A new Matrix22 containing the product l_mat * r_mat
     *
     * @example
     * ```typescript
     * const a = Matrix22.scale(Vector2.fromCopyArray2([2, 2]));
     * const b = Matrix22.rotate(Math.PI / 4);
     * const result = Matrix22.multiply(a, b); // Scale then rotate
     * ```
     */
    static multiply(l_mat: Matrix22, r_mat: Matrix22): Matrix22;
    /**
     * Multiplies two matrices and stores the result in the output matrix.
     * This method avoids creating a new matrix instance for better performance.
     *
     * Note: The parameter types suggest Matrix33, but this appears to be a bug
     * as this should operate on Matrix22 instances.
     *
     * @param l_mat - The left matrix operand
     * @param r_mat - The right matrix operand
     * @param outMat - The mutable matrix to store the result
     * @returns The output matrix containing the product
     */
    static multiplyTo(l_mat: Matrix33, r_mat: Matrix33, outMat: MutableMatrix22): MutableMatrix22;
    /**
     * Returns a string representation of the matrix in a readable format.
     *
     * @returns A string showing the matrix in 2x2 layout
     *
     * @example
     * ```typescript
     * const mat = Matrix22.identity();
     * console.log(mat.toString());
     * // Output:
     * // 1 0
     * // 0 1
     * ```
     */
    toString(): string;
    /**
     * Returns an approximate string representation of the matrix with rounded values.
     * Uses financial rounding for cleaner display of floating-point numbers.
     *
     * @returns A string showing the matrix with rounded values
     */
    toStringApproximately(): string;
    /**
     * Returns the matrix elements as a flat array in column-major order.
     *
     * @returns An array containing [m00, m10, m01, m11]
     */
    flattenAsArray(): number[];
    /**
     * Checks if this is a dummy matrix (empty data).
     *
     * @returns True if the matrix has no data, false otherwise
     */
    isDummy(): boolean;
    /**
     * Checks if this matrix is approximately equal to another matrix within a tolerance.
     *
     * @param mat - The matrix to compare with
     * @param delta - The tolerance for comparison (default: Number.EPSILON)
     * @returns True if all corresponding elements are within the tolerance
     */
    isEqual(mat: Matrix22, delta?: number): boolean;
    /**
     * Checks if this matrix is exactly equal to another matrix.
     * Uses strict equality comparison for all elements.
     *
     * @param mat - The matrix to compare with
     * @returns True if all corresponding elements are exactly equal
     */
    isStrictEqual(mat: Matrix22): boolean;
    /**
     * Gets the matrix element at the specified row and column.
     *
     * @param row_i - The row index (0 or 1)
     * @param column_i - The column index (0 or 1)
     * @returns The matrix element at the specified position
     *
     * @example
     * ```typescript
     * const mat = Matrix22.identity();
     * const m01 = mat.at(0, 1); // Returns 0
     * ```
     */
    at(row_i: number, column_i: number): number;
    /**
     * Calculates the determinant of this 2x2 matrix.
     *
     * For a 2x2 matrix | a b |, the determinant is ad - bc.
     *                   | c d |
     *
     * @returns The determinant value
     *
     * @example
     * ```typescript
     * const mat = Matrix22.fromCopy4RowMajor(2, 3, 1, 4);
     * const det = mat.determinant(); // Returns 2*4 - 3*1 = 5
     * ```
     */
    determinant(): number;
    /**
     * Multiplies this matrix by a 2D vector and returns the result.
     *
     * @param vec - The 2D vector to multiply
     * @returns A new Vector2 containing the transformed vector
     *
     * @example
     * ```typescript
     * const rotation = Matrix22.rotate(Math.PI / 2);
     * const vec = Vector2.fromCopyArray2([1, 0]);
     * const result = rotation.multiplyVector(vec); // Rotates (1,0) to (0,1)
     * ```
     */
    multiplyVector(vec: Vector2): Vector2;
    /**
     * Multiplies this matrix by a 2D vector and stores the result in the output vector.
     * This method avoids creating a new vector instance for better performance.
     *
     * @param vec - The 2D vector to multiply
     * @param outVec - The mutable vector to store the result
     * @returns The output vector containing the transformed vector
     */
    multiplyVectorTo(vec: Vector2, outVec: MutableVector2): MutableVector2;
    /**
     * Extracts the scale factors from this transformation matrix.
     * Calculates the length of each column vector to determine the scale.
     *
     * @returns A Vector2 containing the scale factors for x and y axes
     *
     * @example
     * ```typescript
     * const scaleAndRotation = Matrix22.multiply(
     *   Matrix22.scale(Vector2.fromCopyArray2([2, 3])),
     *   Matrix22.rotate(Math.PI / 4)
     * );
     * const scale = scaleAndRotation.getScale(); // Returns approximately [2, 3]
     * ```
     */
    getScale(): Vector2;
    /**
     * Extracts the scale factors from this transformation matrix and stores them in the output vector.
     * This method avoids creating a new vector instance for better performance.
     *
     * @param outVec - The mutable vector to store the scale factors
     * @returns The output vector containing the scale factors
     */
    getScaleTo(outVec: MutableVector2): MutableVector2;
    /**
     * Creates a deep copy of this matrix.
     *
     * @returns A new Matrix22 instance with the same values
     */
    clone(): any;
    /**
     * Creates a new Matrix22 from individual components in row-major order.
     *
     * Row-major means you specify values as they appear visually:
     * ```
     * | m00 m01 |
     * | m10 m11 |
     * ```
     *
     * Note: Internally, WebGL matrices are stored in column-major order.
     *
     * @param m00 - Element at row 0, column 0
     * @param m01 - Element at row 0, column 1
     * @param m10 - Element at row 1, column 0
     * @param m11 - Element at row 1, column 1
     * @returns A new Matrix22 with the specified values
     *
     * @example
     * ```typescript
     * const mat = Matrix22.fromCopy4RowMajor(1, 2, 3, 4);
     * // Creates:
     * // | 1 2 |
     * // | 3 4 |
     * ```
     */
    static fromCopy4RowMajor(m00: number, m01: number, m10: number, m11: number): Matrix22;
    /**
     * Creates a new Matrix22 from individual components in column-major order.
     *
     * Column-major means you specify values column by column:
     * First column: m00, m10
     * Second column: m01, m11
     *
     * Note: WebGL matrices are stored in column-major order internally.
     *
     * @param m00 - Element at row 0, column 0
     * @param m10 - Element at row 1, column 0
     * @param m01 - Element at row 0, column 1
     * @param m11 - Element at row 1, column 1
     * @returns A new Matrix22 with the specified values
     */
    static fromCopy4ColumnMajor(m00: number, m10: number, m01: number, m11: number): Matrix22;
    /**
     * Creates a new Matrix22 that directly uses the provided Float32Array.
     * The array is used as-is without copying, so modifications to the array
     * will affect the matrix.
     *
     * @param float32Array - Float32Array containing matrix values in column-major order
     * @returns A new Matrix22 using the provided array
     */
    static fromFloat32ArrayColumnMajor(float32Array: Float32Array): Matrix22;
    /**
     * Creates a new Matrix22 by copying values from a Float32Array in column-major order.
     *
     * @param float32Array - Float32Array containing matrix values in column-major order
     * @returns A new Matrix22 with copied values
     */
    static fromCopyFloat32ArrayColumnMajor(float32Array: Float32Array): Matrix22;
    /**
     * Creates a new Matrix22 by copying values from a Float32Array in row-major order.
     *
     * @param array - Float32Array containing matrix values in row-major order
     * @returns A new Matrix22 with values converted to column-major order
     */
    static fromCopyFloat32ArrayRowMajor(array: Float32Array): Matrix22;
    /**
     * Creates a new Matrix22 by copying values from another IMatrix22.
     *
     * @param mat - The matrix to copy from
     * @returns A new Matrix22 with copied values
     */
    static fromCopyMatrix22(mat: IMatrix22): Matrix22;
    /**
     * Creates a new Matrix22 from a 4-element array in column-major order.
     *
     * @param array - Array4 containing exactly 4 numbers in column-major order
     * @returns A new Matrix22 with the array values
     */
    static fromCopyArray9ColumnMajor(array: Array4<number>): Matrix22;
    /**
     * Creates a new Matrix22 from a variable-length array in column-major order.
     * Only the first 4 elements are used.
     *
     * @param array - Array containing matrix values in column-major order
     * @returns A new Matrix22 with the first 4 array values
     */
    static fromCopyArrayColumnMajor(array: Array<number>): Matrix22;
    /**
     * Creates a new Matrix22 from a 4-element array in row-major order.
     *
     * @param array - Array4 containing exactly 4 numbers in row-major order
     * @returns A new Matrix22 with values converted to column-major order
     */
    static fromCopyArray9RowMajor(array: Array4<number>): Matrix22;
    /**
     * Creates a new Matrix22 from a variable-length array in row-major order.
     * Only the first 4 elements are used.
     *
     * @param array - Array containing matrix values in row-major order
     * @returns A new Matrix22 with values converted to column-major order
     */
    static fromCopyArrayRowMajor(array: Array<number>): Matrix22;
}

/**
 * A mutable RGB color class that extends MutableVector3.
 * Represents a color with red, green, and blue components, with alpha always set to 1.
 * This class provides both vector-based operations and color-specific accessors.
 */
declare class MutableColorRgb extends MutableVector3 implements IMutableVector3, IMutableColorRgb {
    /**
     * Gets the X component (same as red component).
     * @returns The X/red component value
     */
    get x(): number;
    /**
     * Sets the X component (same as red component).
     * @param val - The value to set for X/red component
     */
    set x(val: number);
    /**
     * Gets the Y component (same as green component).
     * @returns The Y/green component value
     */
    get y(): number;
    /**
     * Sets the Y component (same as green component).
     * @param val - The value to set for Y/green component
     */
    set y(val: number);
    /**
     * Gets the Z component (same as blue component).
     * @returns The Z/blue component value
     */
    get z(): number;
    /**
     * Sets the Z component (same as blue component).
     * @param val - The value to set for Z/blue component
     */
    set z(val: number);
    /**
     * Gets the W component (always 1 for RGB colors).
     * @returns Always returns 1
     */
    get w(): number;
    /**
     * Gets the red color component.
     * @returns The red component value (0.0 to 1.0)
     */
    get r(): number;
    /**
     * Sets the red color component.
     * @param val - The red component value (typically 0.0 to 1.0)
     */
    set r(val: number);
    /**
     * Gets the green color component.
     * @returns The green component value (0.0 to 1.0)
     */
    get g(): number;
    /**
     * Sets the green color component.
     * @param val - The green component value (typically 0.0 to 1.0)
     */
    set g(val: number);
    /**
     * Gets the blue color component.
     * @returns The blue component value (0.0 to 1.0)
     */
    get b(): number;
    /**
     * Sets the blue color component.
     * @param val - The blue component value (typically 0.0 to 1.0)
     */
    set b(val: number);
    /**
     * Gets the alpha component (always 1 for RGB colors).
     * @returns Always returns 1
     */
    get a(): number;
    /**
     * Creates a new MutableColorRgb with all components set to zero (black).
     * @returns A new MutableColorRgb instance with RGB values [0, 0, 0]
     */
    static zero(): MutableColorRgb;
    /**
     * Creates a new MutableColorRgb with all components set to one (white).
     * @returns A new MutableColorRgb instance with RGB values [1, 1, 1]
     */
    static one(): MutableColorRgb;
    /**
     * Creates a dummy MutableColorRgb instance for placeholder purposes.
     * @returns A new MutableColorRgb instance for dummy use
     */
    static dummy(): MutableColorRgb;
    /**
     * Creates a normalized version of the given vector as a MutableColorRgb.
     * @param vec - The vector to normalize
     * @returns A new normalized MutableColorRgb instance
     */
    static normalize(vec: IVector3): MutableColorRgb;
    /**
     * Adds two vectors component-wise and returns the result as a MutableColorRgb.
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new MutableColorRgb with the sum of the input vectors
     */
    static add(l_vec: IVector3, r_vec: IVector3): MutableColorRgb;
    /**
     * Subtracts the right vector from the left vector component-wise.
     * @param l_vec - The left operand vector (minuend)
     * @param r_vec - The right operand vector (subtrahend)
     * @returns A new MutableColorRgb with the difference of the input vectors
     */
    static subtract(l_vec: IVector3, r_vec: IVector3): MutableColorRgb;
    /**
     * Multiplies a vector by a scalar value.
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @returns A new MutableColorRgb with the scaled vector
     */
    static multiply(vec: IVector3, value: number): MutableColorRgb;
    /**
     * Multiplies two vectors component-wise.
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new MutableColorRgb with the component-wise product
     */
    static multiplyVector(l_vec: IVector3, r_vec: IVector3): MutableColorRgb;
    /**
     * Divides a vector by a scalar value.
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @returns A new MutableColorRgb with the divided vector
     */
    static divide(vec: IVector3, value: number): MutableColorRgb;
    /**
     * Divides two vectors component-wise.
     * @param l_vec - The left operand vector (dividend)
     * @param r_vec - The right operand vector (divisor)
     * @returns A new MutableColorRgb with the component-wise division
     */
    static divideVector(l_vec: IVector3, r_vec: IVector3): MutableColorRgb;
    /**
     * Computes the cross product of two vectors.
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new MutableColorRgb with the cross product result
     */
    static cross(l_vec: IVector3, r_vec: IVector3): MutableColorRgb;
    /**
     * Creates a deep copy of this MutableColorRgb instance.
     * @returns A new MutableColorRgb instance with the same RGB values
     */
    clone(): MutableColorRgb;
}

/**
 * A mutable RGBA color class that extends MutableVector4.
 * Represents a color with red, green, blue, and alpha components.
 * This class provides both vector-like (x, y, z, w) and color-specific (r, g, b, a) accessors.
 */
declare class MutableColorRgba extends MutableVector4 implements IMutableVector4, IMutableColorRgba {
    /**
     * Gets the x component (equivalent to red component).
     * @returns The x/red value
     */
    get x(): number;
    /**
     * Sets the x component (equivalent to red component).
     * @param val - The value to set
     */
    set x(val: number);
    /**
     * Gets the y component (equivalent to green component).
     * @returns The y/green value
     */
    get y(): number;
    /**
     * Sets the y component (equivalent to green component).
     * @param val - The value to set
     */
    set y(val: number);
    /**
     * Gets the z component (equivalent to blue component).
     * @returns The z/blue value
     */
    get z(): number;
    /**
     * Sets the z component (equivalent to blue component).
     * @param val - The value to set
     */
    set z(val: number);
    /**
     * Gets the w component (equivalent to alpha component).
     * @returns The w/alpha value
     */
    get w(): number;
    /**
     * Sets the w component (equivalent to alpha component).
     * @param val - The value to set
     */
    set w(val: number);
    /**
     * Gets the red component.
     * @returns The red value
     */
    get r(): number;
    /**
     * Sets the red component.
     * @param val - The red value to set
     */
    set r(val: number);
    /**
     * Gets the green component.
     * @returns The green value
     */
    get g(): number;
    /**
     * Sets the green component.
     * @param val - The green value to set
     */
    set g(val: number);
    /**
     * Gets the blue component.
     * @returns The blue value
     */
    get b(): number;
    /**
     * Sets the blue component.
     * @param val - The blue value to set
     */
    set b(val: number);
    /**
     * Gets the alpha component.
     * @returns The alpha value
     */
    get a(): number;
    /**
     * Sets the alpha component.
     * @param val - The alpha value to set
     */
    set a(val: number);
    /**
     * Creates a new MutableColorRgba with all components set to zero.
     * @returns A new MutableColorRgba instance with values [0, 0, 0, 0]
     */
    static zero(): MutableColorRgba;
    /**
     * Creates a new MutableColorRgba with all components set to one.
     * @returns A new MutableColorRgba instance with values [1, 1, 1, 1]
     */
    static one(): MutableColorRgba;
    /**
     * Creates a dummy MutableColorRgba instance.
     * @returns A new MutableColorRgba instance for placeholder purposes
     */
    static dummy(): MutableColorRgba;
    /**
     * Creates a normalized version of the given vector.
     * @param vec - The vector to normalize
     * @returns A new MutableColorRgba with normalized values
     */
    static normalize(vec: IVector4): MutableColorRgba;
    /**
     * Adds two vectors component-wise.
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new MutableColorRgba containing the sum
     */
    static add(l_vec: IVector4, r_vec: IVector4): MutableColorRgba;
    /**
     * Subtracts the right vector from the left vector component-wise.
     * @param l_vec - The left operand vector (minuend)
     * @param r_vec - The right operand vector (subtrahend)
     * @returns A new MutableColorRgba containing the difference
     */
    static subtract(l_vec: IVector4, r_vec: IVector4): MutableColorRgba;
    /**
     * Multiplies a vector by a scalar value.
     * @param vec - The vector to multiply
     * @param value - The scalar value to multiply by
     * @returns A new MutableColorRgba containing the scaled result
     */
    static multiply(vec: IVector4, value: number): MutableColorRgba;
    /**
     * Multiplies two vectors component-wise.
     * @param l_vec - The left operand vector
     * @param r_vec - The right operand vector
     * @returns A new MutableColorRgba containing the component-wise product
     */
    static multiplyVector(l_vec: IVector4, r_vec: IVector4): MutableColorRgba;
    /**
     * Divides a vector by a scalar value.
     * @param vec - The vector to divide
     * @param value - The scalar value to divide by
     * @returns A new MutableColorRgba containing the divided result
     */
    static divide(vec: IVector4, value: number): MutableColorRgba;
    /**
     * Divides the left vector by the right vector component-wise.
     * @param l_vec - The left operand vector (dividend)
     * @param r_vec - The right operand vector (divisor)
     * @returns A new MutableColorRgba containing the component-wise quotient
     */
    static divideVector(l_vec: IVector4, r_vec: IVector4): MutableColorRgba;
    /**
     * Creates a deep copy of this MutableColorRgba instance.
     * @returns A new MutableColorRgba instance with the same values
     */
    clone(): MutableColorRgba;
}

/**
 * Abstract base class for scalar values using typed arrays.
 * Provides common functionality for both 32-bit and 64-bit floating-point scalar implementations.
 * @template T - The typed array constructor type
 * @internal
 */
declare class Scalar_<T extends TypedArrayConstructor> extends AbstractVector {
    /**
     * Creates a new scalar instance.
     * @param v - The typed array containing the scalar value
     * @param options - Configuration object containing the array type
     * @param options.type - The typed array constructor type
     */
    constructor(v: TypedArray, _options: {
        type: T;
    });
    /**
     * Gets the scalar value as a number.
     * @returns The scalar value
     */
    getValue(): number;
    /**
     * Gets the scalar value wrapped in an array.
     * @returns An array containing the scalar value
     */
    getValueInArray(): number[];
    /**
     * Gets the scalar value (alias for x component).
     * @returns The scalar value
     */
    get x(): number;
    /**
     * Gets the raw typed array containing the scalar value.
     * @returns The underlying typed array
     */
    get raw(): TypedArray;
    /**
     * Performs strict equality comparison with another scalar.
     * Uses exact floating-point comparison without tolerance.
     * @param scalar - The scalar to compare with
     * @returns True if the scalars are exactly equal, false otherwise
     */
    isStrictEqual(scalar: Scalar_<T>): boolean;
    /**
     * Performs approximate equality comparison with another scalar within a tolerance.
     * @param scalar - The scalar to compare with
     * @param delta - The tolerance for comparison (default: Number.EPSILON)
     * @returns True if the scalars are equal within the specified tolerance
     */
    isEqual(scalar: Scalar_<T>, delta?: number): boolean;
    /**
     * Gets the scalar value as a GLSL-compatible float string.
     * @returns The scalar value formatted as a GLSL float literal
     */
    get glslStrAsFloat(): string;
    /**
     * Gets the scalar value as a GLSL-compatible integer string.
     * @returns The scalar value formatted as a GLSL integer literal
     */
    get glslStrAsInt(): string;
    /**
     * Gets the scalar value as a WGSL-compatible float string.
     * @returns The scalar value formatted as a WGSL float literal
     */
    get wgslStrAsFloat(): string;
    /**
     * Gets the scalar value as a WGSL-compatible integer string.
     * @returns The scalar value formatted as a WGSL integer literal
     */
    get wgslStrAsInt(): string;
    /**
     * Creates a new scalar instance from a number value.
     * @param value - The numeric value to create the scalar from
     * @param type - The typed array constructor to use
     * @returns A new scalar instance
     * @protected
     */
    static _fromCopyNumber(value: number, type: FloatTypedArrayConstructor): Scalar_<FloatTypedArrayConstructor>;
    /**
     * Creates a dummy (uninitialized) scalar instance.
     * @param type - The typed array constructor to use
     * @returns A new dummy scalar instance
     * @protected
     */
    static _dummy(type: FloatTypedArrayConstructor): Scalar_<FloatTypedArrayConstructor>;
    /**
     * Gets the composition type for scalar values.
     * @returns The scalar composition type
     */
    static get compositionType(): {
        readonly __numberOfComponents: number;
        readonly __glslStr: string;
        readonly __hlslStr: string;
        readonly __webgpuStr: string;
        readonly __wgslStr: string;
        readonly __isArray: boolean;
        readonly __vec4SizeOfProperty: IndexOf16Bytes;
        readonly __dummyStr: "SCALAR";
        readonly webgpu: string;
        readonly wgsl: string;
        getNumberOfComponents(): Count;
        getGlslStr(componentType: ComponentTypeEnum): string;
        getGlslInitialValue(componentType: ComponentTypeEnum): string;
        getWgslInitialValue(componentType: ComponentTypeEnum): string;
        toWGSLType(componentType: ComponentTypeEnum): string;
        getVec4SizeOfProperty(): IndexOf16Bytes;
        readonly index: number;
        readonly symbol: symbol;
        readonly str: string;
        toString(): string;
        toJSON(): number;
    };
    /**
     * Gets the number of bytes per component in the underlying typed array.
     * @returns The number of bytes per element
     */
    get bytesPerComponent(): number;
}
/**
 * Immutable scalar class using 32-bit floating-point precision.
 * Represents a single floating-point value with various utility methods
 * for mathematical operations and format conversions.
 */
declare class Scalar extends Scalar_<Float32ArrayConstructor> implements IScalar {
    /**
     * Creates a new 32-bit float scalar instance.
     * @param x - The typed array containing the scalar value
     */
    constructor(x: TypedArray);
    /**
     * Creates a new scalar from a numeric value.
     * @param value - The numeric value to create the scalar from
     * @returns A new Scalar instance
     */
    static fromCopyNumber(value: number): Scalar;
    /**
     * Creates a scalar with value zero.
     * @returns A new Scalar instance with value 0
     */
    static zero(): Scalar;
    /**
     * Creates a scalar with value one.
     * @returns A new Scalar instance with value 1
     */
    static one(): Scalar;
    /**
     * Creates a dummy (uninitialized) scalar instance.
     * @returns A new dummy Scalar instance
     */
    static dummy(): Scalar;
    /**
     * Gets the class name for debugging and reflection purposes.
     * @returns The string "Scalar"
     */
    get className(): string;
    /**
     * Converts the scalar to a string representation.
     * @returns A string representation of the scalar in the format "(value)"
     */
    toString(): string;
    /**
     * Creates a deep copy of this scalar.
     * @returns A new Scalar instance with the same value
     */
    clone(): Scalar;
}
/**
 * Immutable scalar class using 64-bit floating-point precision.
 * Provides higher precision than the standard Scalar class for applications
 * requiring double-precision arithmetic.
 */
declare class Scalard extends Scalar_<Float64ArrayConstructor> {
    /**
     * Creates a new 64-bit float scalar instance.
     * @param x - The typed array containing the scalar value
     */
    constructor(x: TypedArray);
    /**
     * Creates a new double-precision scalar from a numeric value.
     * @param value - The numeric value to create the scalar from
     * @returns A new Scalard instance
     */
    static fromCopyNumber(value: number): Scalard;
    /**
     * Creates a double-precision scalar with value zero.
     * @returns A new Scalard instance with value 0
     */
    static zero(): Scalard;
    /**
     * Creates a double-precision scalar with value one.
     * @returns A new Scalard instance with value 1
     */
    static one(): Scalard;
    /**
     * Creates a dummy (uninitialized) double-precision scalar instance.
     * @returns A new dummy Scalard instance
     */
    static dummy(): Scalard;
    /**
     * Creates a deep copy of this double-precision scalar.
     * @returns A new Scalard instance with the same value
     */
    clone(): Scalard;
}
/**
 * Type alias for the standard 32-bit float Scalar class.
 * Provides convenient naming for float-precision scalar operations.
 */
type Scalarf = Scalar;

/**
 * Base class for mutable scalar values with typed array backing.
 * This class extends the immutable Scalar_ class to provide mutable operations.
 * @template T - The typed array constructor type (Float32Array, Float64Array, etc.)
 * @internal
 */
declare class MutableScalar_<T extends TypedArrayConstructor> extends Scalar_<T> {
    /**
     * Creates a new mutable scalar with the specified value and type.
     * @param x - The typed array containing the scalar value
     * @param options - Configuration object containing the array type
     * @param options.type - The typed array constructor to use
     */
    constructor(x: TypedArray, { type }: {
        type: T;
    });
    /**
     * Copies the components from another scalar to this scalar.
     * @param vec - The source scalar to copy from
     */
    copyComponents(vec: Scalar_<T>): void;
    /**
     * Gets the x component (scalar value).
     * @returns The scalar value
     */
    get x(): number;
    /**
     * Sets the x component (scalar value).
     * @param x - The new scalar value
     */
    set x(x: number);
    /**
     * Gets the y component (always 0 for scalars).
     * @returns Always returns 0
     */
    get y(): number;
    /**
     * Gets the z component (always 0 for scalars).
     * @returns Always returns 0
     */
    get z(): number;
    /**
     * Gets the w component (always 1 for scalars).
     * @returns Always returns 1
     */
    get w(): number;
    /**
     * Converts the scalar to a string representation.
     * @returns A string representation of the scalar in the format "(value)"
     */
    toString(): string;
    /**
     * Sets the scalar value.
     * @param value - The new scalar value
     * @returns This scalar instance for method chaining
     */
    setValue(value: number): this;
    /**
     * Gets the composition type for this scalar.
     * @returns The scalar composition type
     */
    static get compositionType(): {
        readonly __numberOfComponents: number;
        readonly __glslStr: string;
        readonly __hlslStr: string;
        readonly __webgpuStr: string;
        readonly __wgslStr: string;
        readonly __isArray: boolean;
        readonly __vec4SizeOfProperty: IndexOf16Bytes;
        readonly __dummyStr: "SCALAR";
        readonly webgpu: string;
        readonly wgsl: string;
        getNumberOfComponents(): Count;
        getGlslStr(componentType: ComponentTypeEnum): string;
        getGlslInitialValue(componentType: ComponentTypeEnum): string;
        getWgslInitialValue(componentType: ComponentTypeEnum): string;
        toWGSLType(componentType: ComponentTypeEnum): string;
        getVec4SizeOfProperty(): IndexOf16Bytes;
        readonly index: number;
        readonly symbol: symbol;
        readonly str: string;
        toString(): string;
        toJSON(): number;
    };
    /**
     * Gets the number of bytes per component in the underlying typed array.
     * @returns The number of bytes per element
     */
    get bytesPerComponent(): number;
}
/**
 * Mutable scalar class with 32-bit float components.
 * This class provides a mutable scalar value backed by a Float32Array.
 */
declare class MutableScalar extends MutableScalar_<Float32ArrayConstructor> {
    /**
     * Creates a new mutable scalar with 32-bit float precision.
     * @param x - The typed array containing the scalar value
     */
    constructor(x: TypedArray);
    /**
     * Creates a copy of this scalar.
     * @returns A new MutableScalar instance with the same value
     */
    clone(): MutableScalar;
    /**
     * Creates a scalar with value 1.
     * @returns A new MutableScalar instance with value 1
     */
    static one(): MutableScalar;
    /**
     * Creates a dummy scalar with no data.
     * @returns A new MutableScalar instance with empty array
     */
    static dummy(): MutableScalar;
    /**
     * Creates a scalar with value 0.
     * @returns A new MutableScalar instance with value 0
     */
    static zero(): MutableScalar;
    /**
     * Gets the class name for debugging and serialization purposes.
     * @returns The string "MutableScalar"
     */
    get className(): string;
}
/**
 * Mutable scalar class with 64-bit float components.
 * This class provides a mutable scalar value backed by a Float64Array for higher precision.
 */
declare class MutableScalard extends MutableScalar_<Float64ArrayConstructor> {
    /**
     * Creates a new mutable scalar with 64-bit float precision.
     * @param x - The typed array containing the scalar value
     */
    constructor(x: TypedArray);
    /**
     * Creates a copy of this scalar.
     * @returns A new MutableScalard instance with the same value
     */
    clone(): MutableScalard;
    /**
     * Creates a scalar with value 1.
     * @returns A new MutableScalard instance with value 1
     */
    static one(): MutableScalard;
    /**
     * Creates a dummy scalar with no data.
     * @returns A new MutableScalard instance with empty array
     */
    static dummy(): MutableScalard;
    /**
     * Creates a scalar with value 0.
     * @returns A new MutableScalard instance with value 0
     */
    static zero(): MutableScalard;
}
/**
 * Type alias for MutableScalar (32-bit float precision).
 * Provides backward compatibility and clearer naming.
 */
type MutableScalarf = MutableScalar;

/**
 * Represents a 3D transformation containing position, rotation, and scale components.
 * This class provides a convenient way to handle 3D object transformations with
 * automatic matrix composition and decomposition capabilities.
 *
 * @example
 * ```typescript
 * const transform = new Transform3D();
 * transform.position = Vector3.fromCopyArray([1, 2, 3]);
 * transform.scale = Vector3.fromCopyArray([2, 2, 2]);
 * transform.rotation = Quaternion.fromEulerAngles(0, Math.PI / 4, 0);
 * const matrix = transform.matrix;
 * ```
 */
declare class Transform3D {
    private __position;
    private __scale;
    private __rotation;
    private __updateCount;
    private static __tmpMatrix44_0;
    private static __tmpVector3_0;
    private static __tmpVector3_1;
    private static __tmpVector3_2;
    private static __tmpQuaternion_0;
    /**
     * Creates a new Transform3D instance.
     * @param transform - Optional Transform3D instance to copy from
     */
    constructor();
    constructor(Transform3D: Transform3D);
    /**
     * Checks if this transform is equal to another transform within a given tolerance.
     * @param rhs - The transform to compare against
     * @param delta - The tolerance for comparison (default: Number.EPSILON)
     * @returns True if the transforms are equal within the specified tolerance
     */
    isEqual(rhs: Transform3D, delta?: number): boolean;
    /**
     * Creates a deep copy of this transform.
     * @returns A new Transform3D instance with the same values
     */
    clone(): Transform3D;
    /**
     * Sets the position of the transform.
     * @param vec - The new position vector
     */
    set position(vec: IVector3);
    /**
     * Sets the position using an array of three numbers.
     * @param array - Array containing [x, y, z] position values
     */
    setPositionAsArray3(array: Array3<number>): void;
    /**
     * Gets a copy of the local position vector.
     * @returns A cloned MutableVector3 representing the position
     */
    get position(): MutableVector3;
    /**
     * Gets the internal position vector (direct reference).
     * @returns The internal MutableVector3 position object
     */
    get positionInner(): MutableVector3;
    /**
     * Sets the rotation using Euler angles (XYZ order).
     * @param vec - Vector containing rotation angles in radians [x, y, z]
     */
    set eulerAngles(vec: IVector3);
    /**
     * Gets a copy of the rotation as Euler angles (XYZ order).
     * @returns A cloned Vector3 containing rotation angles in radians [x, y, z]
     */
    get eulerAngles(): IVector3;
    /**
     * Gets the rotation as Euler angles (XYZ order) - direct reference.
     * @returns A Vector3 containing rotation angles in radians [x, y, z]
     */
    get eulerAnglesInner(): Vector3;
    /**
     * Sets the scale of the transform.
     * @param vec - The new scale vector
     */
    set scale(vec: IVector3);
    /**
     * Sets the scale using an array of three numbers.
     * @param array - Array containing [x, y, z] scale values
     */
    setScaleAsArray3(array: Array3<number>): void;
    /**
     * Gets a copy of the local scale vector.
     * @returns A cloned MutableVector3 representing the scale
     */
    get scale(): IVector3;
    /**
     * Gets the internal scale vector (direct reference).
     * @returns The internal MutableVector3 scale object
     */
    get scaleInner(): MutableVector3;
    /**
     * Sets the rotation using a quaternion.
     * @param quat - The new rotation quaternion
     */
    set rotation(quat: IQuaternion);
    /**
     * Sets the rotation using an array of four numbers representing a quaternion.
     * @param array - Array containing [x, y, z, w] quaternion values
     */
    setRotationAsArray4(array: Array4<number>): void;
    /**
     * Gets a copy of the local rotation quaternion.
     * @returns A cloned Quaternion representing the rotation
     */
    get rotation(): IQuaternion;
    /**
     * Gets the internal rotation quaternion (direct reference).
     * @returns The internal Quaternion rotation object
     */
    get rotationInner(): Quaternion;
    /**
     * Internal method to increment the update counter when transform changes.
     * @private
     */
    __updateTransform(): void;
    /**
     * Sets the transform from a 4x4 transformation matrix.
     * Decomposes the matrix into position, rotation, and scale components.
     * @param mat - The transformation matrix to decompose
     */
    set matrix(mat: IMatrix44);
    /**
     * Gets a copy of the local transformation matrix.
     * @returns A new Matrix44 representing the composed transformation
     */
    get matrix(): IMatrix44;
    /**
     * Gets the local transformation matrix composed from position, rotation, and scale.
     * The matrix is computed as: Translation * Rotation * Scale
     * @returns A MutableMatrix44 representing the composed transformation
     */
    get matrixInner(): MutableMatrix44;
    /**
     * Efficiently computes the transformation matrix and stores it in the provided matrix.
     * This method avoids memory allocation by reusing an existing matrix object.
     * @param mat - The target matrix to store the result in
     */
    getMatrixInnerTo(mat: MutableMatrix44): void;
    /**
     * Gets the number of times this transform has been updated.
     * This can be useful for optimization and caching purposes.
     * @returns The update count as a number
     */
    get updateCount(): number;
    /**
     * Sets the rotation using a 4x4 rotation matrix.
     * @param rotateMatrix - The rotation matrix to extract rotation from
     */
    set rotateMatrix44(rotateMatrix: IMatrix44);
    /**
     * Gets the rotation as a 4x4 rotation matrix.
     * @returns A Matrix44 representing only the rotation component
     */
    get rotateMatrix44(): IMatrix44;
    /**
     * Sets transform properties from a JSON object.
     * Supports setting position, scale, rotation (as quaternion), and matrix properties.
     * @param arg - JSON object or JSON string containing transform properties
     */
    setPropertiesFromJson(arg: JSON): void;
    /**
     * Sets the rotation to align with specified up and front vectors.
     * Creates a coordinate system where the Y-axis aligns with the up vector
     * and the Z-axis aligns with the front vector.
     * @param UpVec - The desired up direction (Y-axis)
     * @param FrontVec - The desired front direction (Z-axis)
     */
    setRotationFromNewUpAndFront(UpVec: IVector3, FrontVec: IVector3): void;
    /**
     * Rotates the transform to face from one direction to another.
     * Calculates the rotation needed to align the 'from' direction with the 'to' direction.
     * @param fromVec - The current forward direction
     * @param toVec - The target direction to face towards
     */
    headToDirection(fromVec: Vector3, toVec: Vector3): void;
    /**
     * Sets multiple transform components at once for optimal performance.
     * This method reduces the cost of automatically updating transform matrices
     * by setting all components in a single operation. Useful for animation and
     * batch updates where performance is critical.
     *
     * Note: The provided transform components must be mutually consistent.
     * For example, if a matrix is provided, its decomposed translate, rotate, and scale
     * components should match the individual component arguments.
     *
     * @param translate - The position component
     * @param scale - The scale component
     * @param rotation - The rotation component as a quaternion
     */
    setTransform(translate: MutableVector3, scale: MutableVector3, rotation: MutableQuaternion): void;
}

/**
 * VectorN represents an N-dimensional vector with arbitrary length.
 * This class provides basic vector operations using TypedArray for efficient memory usage.
 */
declare class VectorN {
    _v: TypedArray;
    /**
     * Creates a new VectorN instance.
     * @param typedArray - The typed array containing the vector components
     */
    constructor(typedArray: TypedArray);
    /**
     * Creates a deep copy of this vector.
     * @returns A new VectorN instance with the same components as this vector
     */
    clone(): VectorN;
}

/**
 * A scalar value that can be animated using animation samplers.
 * This class extends Scalar and implements both IScalar and IAnimatedValue interfaces.
 * It supports blending between two animation tracks and can be configured to loop.
 */
declare class AnimatedScalar extends Scalar implements IScalar, IAnimatedValue {
    private __animationSamplers;
    private __firstActiveAnimationTrackName;
    private __firstActiveAnimationSampler;
    private __secondActiveAnimationTrackName?;
    private __secondActiveAnimationSampler?;
    private __blendingRatio;
    private __time?;
    private __lastTime;
    isLoop: boolean;
    /**
     * Creates a new AnimatedScalar instance.
     * @param animationSamplers - A map of animation track names to their corresponding samplers
     * @param activeAnimationTrackName - The name of the initially active animation track
     * @throws {Error} If the specified animation track is not found in the samplers
     */
    constructor(animationSamplers: AnimationSamplers, activeAnimationTrackName: AnimationTrackName);
    /**
     * Returns the scalar value as an array of numbers.
     * @returns An array containing the scalar value
     */
    getNumberArray(): number[];
    /**
     * Sets the internal Float32Array and triggers an update.
     * @param array - The new Float32Array to set
     */
    setFloat32Array(array: Float32Array): void;
    /**
     * Sets a specific time for animation playback.
     * @param time - The time value to set for animation sampling
     */
    setTime(time: number): void;
    /**
     * Switches to using global time from AnimationComponent instead of a specific time.
     */
    useGlobalTime(): void;
    /**
     * Sets the blending ratio between the first and second animation tracks.
     * @param value - The blending ratio (0.0 = first track only, 1.0 = second track only)
     */
    set blendingRatio(value: number);
    /**
     * Gets the current blending ratio between animation tracks.
     * @returns The current blending ratio
     */
    get blendingRatio(): number;
    /**
     * Gets the current scalar value, updating the animation if necessary.
     * @returns The current scalar value
     */
    get x(): number;
    /**
     * Updates the animated scalar value based on the current time and active animation tracks.
     * This method interpolates between keyframes and handles blending between two tracks if configured.
     * The update is skipped if the time hasn't changed since the last update.
     */
    update(): void;
    /**
     * Sets the first active animation track by name.
     * @param animationTrackName - The name of the animation track to set as the first active track
     */
    setFirstActiveAnimationTrackName(animationTrackName: AnimationTrackName): void;
    /**
     * Sets the second active animation track by name for blending purposes.
     * @param animationTrackName - The name of the animation track to set as the second active track
     */
    setSecondActiveAnimationTrackName(animationTrackName: AnimationTrackName): void;
    /**
     * Gets the name of the first active animation track.
     * @returns The name of the first active animation track
     */
    getFirstActiveAnimationTrackName(): string;
    /**
     * Gets the name of the second active animation track.
     * @returns The name of the second active animation track, or undefined if not set
     */
    getSecondActiveAnimationTrackName(): string | undefined;
    /**
     * Gets the minimum start time from the input keyframes of the specified animation track.
     * @param trackName - The name of the animation track
     * @returns The minimum start time of the animation track
     * @throws {Error} If the specified animation track is not found
     */
    getMinStartInputTime(trackName: AnimationTrackName): number;
    /**
     * Gets the maximum end time from the input keyframes of the specified animation track.
     * @param trackName - The name of the animation track
     * @returns The maximum end time of the animation track
     * @throws {Error} If the specified animation track is not found
     */
    getMaxEndInputTime(trackName: AnimationTrackName): number;
    /**
     * Gets an array of all available animation track names.
     * @returns An array containing all animation track names
     */
    getAllTrackNames(): string[];
    /**
     * Gets the animation sampler for the specified track name.
     * @param trackName - The name of the animation track
     * @returns The animation sampler for the specified track
     * @throws {Error} If the specified animation track is not found
     */
    getAnimationSampler(trackName: AnimationTrackName): AnimationSampler;
    /**
     * Deletes an animation sampler for the specified track name.
     * @param trackName - The name of the animation track to delete
     */
    deleteAnimationSampler(trackName: AnimationTrackName): void;
    /**
     * Sets or updates an animation sampler for the specified track name.
     * @param animationTrackName - The name of the animation track
     * @param animationSampler - The animation sampler to associate with the track
     */
    setAnimationSampler(animationTrackName: AnimationTrackName, animationSampler: AnimationSampler): void;
}

/**
 * An animated 2D vector that can interpolate between animation keyframes over time.
 * This class extends Vector2 and implements both IVector2 and IAnimatedValue interfaces,
 * providing support for animation blending, looping, and time-based value updates.
 */
declare class AnimatedVector2 extends Vector2 implements IVector2, IAnimatedValue {
    private __animationSamplers;
    private __firstActiveAnimationTrackName;
    private __firstActiveAnimationSampler;
    private __secondActiveAnimationTrackName?;
    private __secondActiveAnimationSampler?;
    private __blendingRatio;
    private __time?;
    private __lastTime;
    isLoop: boolean;
    /**
     * Creates a new AnimatedVector2 instance.
     * @param animationSamplers - A map of animation track names to their corresponding samplers
     * @param activeAnimationTrackName - The name of the initial active animation track
     * @throws {Error} When the specified animation track is not found in the samplers
     */
    constructor(animationSamplers: AnimationSamplers, activeAnimationTrackName: AnimationTrackName);
    /**
     * Returns the current vector values as a regular JavaScript array.
     * @returns An array containing the x and y components of the vector
     */
    getNumberArray(): number[];
    /**
     * Sets the internal Float32Array and triggers an update.
     * @param array - The new Float32Array to use for the vector components
     */
    setFloat32Array(array: Float32Array): void;
    /**
     * Sets a specific time for animation evaluation instead of using global time.
     * @param time - The time value to use for animation sampling
     */
    setTime(time: number): void;
    /**
     * Switches back to using the global animation time instead of a specific time.
     * This will cause the vector to use AnimationComponent.globalTime for updates.
     */
    useGlobalTime(): void;
    /**
     * Sets the blending ratio between the first and second active animation tracks.
     * @param value - The blending ratio (0.0 = first track only, 1.0 = second track only)
     */
    set blendingRatio(value: number);
    /**
     * Gets the current blending ratio between animation tracks.
     * @returns The current blending ratio
     */
    get blendingRatio(): number;
    /**
     * Gets the x component of the vector, updating the animation if necessary.
     * @returns The x component value
     */
    get x(): number;
    /**
     * Gets the y component of the vector, updating the animation if necessary.
     * @returns The y component value
     */
    get y(): number;
    /**
     * Gets the z component of the vector, updating the animation if necessary.
     * Note: This always returns the z component even though this is a 2D vector.
     * @returns The z component value
     */
    get z(): number;
    /**
     * Updates the vector values based on the current time and active animation tracks.
     * Handles looping, blending between tracks, and caching to avoid redundant calculations.
     */
    update(): void;
    /**
     * Sets the first (primary) active animation track.
     * @param animationTrackName - The name of the animation track to set as primary
     * @throws {Error} When the specified animation track is not found (logged as info instead)
     */
    setFirstActiveAnimationTrackName(animationTrackName: AnimationTrackName): void;
    /**
     * Sets the second (secondary) active animation track for blending.
     * @param animationTrackName - The name of the animation track to set as secondary
     * @throws {Error} When the specified animation track is not found (logged as info instead)
     */
    setSecondActiveAnimationTrackName(animationTrackName: AnimationTrackName): void;
    /**
     * Gets the name of the first (primary) active animation track.
     * @returns The name of the first active animation track
     */
    getFirstActiveAnimationTrackName(): string;
    /**
     * Gets the name of the second (secondary) active animation track.
     * @returns The name of the second active animation track, or undefined if not set
     */
    getSecondActiveAnimationTrackName(): string | undefined;
    /**
     * Gets the minimum start time for a specific animation track.
     * @param trackName - The name of the animation track
     * @returns The minimum start time (first input value) of the specified track
     * @throws {Error} When the specified animation track is not found
     */
    getMinStartInputTime(trackName: AnimationTrackName): number;
    /**
     * Gets the maximum end time for a specific animation track.
     * @param trackName - The name of the animation track
     * @returns The maximum end time (last input value) of the specified track
     * @throws {Error} When the specified animation track is not found
     */
    getMaxEndInputTime(trackName: AnimationTrackName): number;
    /**
     * Gets all available animation track names.
     * @returns An array containing all animation track names
     */
    getAllTrackNames(): string[];
    /**
     * Gets the animation sampler for a specific track.
     * @param trackName - The name of the animation track
     * @returns The animation sampler for the specified track
     * @throws {Error} When the specified animation track is not found
     */
    getAnimationSampler(trackName: AnimationTrackName): AnimationSampler;
    /**
     * Removes an animation sampler from the available tracks.
     * @param trackName - The name of the animation track to remove
     */
    deleteAnimationSampler(trackName: AnimationTrackName): void;
    /**
     * Adds or updates an animation sampler for a specific track.
     * @param animationTrackName - The name of the animation track
     * @param animationSampler - The animation sampler to associate with the track
     */
    setAnimationSampler(animationTrackName: AnimationTrackName, animationSampler: AnimationSampler): void;
}

/**
 * An animated 3D vector that interpolates values based on animation tracks.
 *
 * This class extends Vector3 to provide animation capabilities, allowing the vector
 * to change its values over time based on animation samplers. It supports blending
 * between two animation tracks and can operate in looped or non-looped modes.
 *
 * @example
 * ```typescript
 * const samplers = new Map();
 * const animatedVector = new AnimatedVector3(samplers, "track1");
 * animatedVector.setTime(1.5);
 * console.log(animatedVector.x, animatedVector.y, animatedVector.z);
 * ```
 */
declare class AnimatedVector3 extends Vector3 implements IVector3, IAnimatedValue {
    private __animationSamplers;
    private __firstActiveAnimationTrackName;
    private __firstActiveAnimationSampler;
    private __secondActiveAnimationTrackName?;
    private __secondActiveAnimationSampler?;
    private __blendingRatio;
    private __time?;
    private __lastTime;
    isLoop: boolean;
    /**
     * Creates a new AnimatedVector3 instance.
     *
     * @param animationSamplers - A map containing animation samplers keyed by track names
     * @param activeAnimationTrackName - The name of the initial active animation track
     * @throws {Error} When the specified animation track is not found in the samplers
     */
    constructor(animationSamplers: AnimationSamplers, activeAnimationTrackName: AnimationTrackName);
    /**
     * Returns the vector components as a regular JavaScript array.
     *
     * @returns An array containing the x, y, and z components
     */
    getNumberArray(): number[];
    /**
     * Sets the vector values from a Float32Array and triggers an update.
     *
     * @param array - A Float32Array containing the new x, y, z values
     */
    setFloat32Array(array: Float32Array): void;
    /**
     * Sets the current animation time and triggers an update.
     *
     * When a specific time is set, the vector will use this time instead of
     * the global animation time for interpolation calculations.
     *
     * @param time - The time value in seconds
     */
    setTime(time: number): void;
    /**
     * Switches back to using the global animation time instead of a specific time.
     *
     * After calling this method, the vector will use AnimationComponent.globalTime
     * for animation interpolation.
     */
    useGlobalTime(): void;
    /**
     * Sets the blending ratio between the first and second animation tracks.
     *
     * @param value - A value between 0 and 1, where 0 means only the first track
     *                is used and 1 means only the second track is used
     */
    set blendingRatio(value: number);
    /**
     * Gets the current blending ratio between animation tracks.
     *
     * @returns The blending ratio between 0 and 1
     */
    get blendingRatio(): number;
    /**
     * Gets the X component of the vector.
     *
     * This getter automatically triggers an update to ensure the value
     * reflects the current animation state.
     *
     * @returns The current X component value
     */
    get x(): number;
    /**
     * Gets the Y component of the vector.
     *
     * This getter automatically triggers an update to ensure the value
     * reflects the current animation state.
     *
     * @returns The current Y component value
     */
    get y(): number;
    /**
     * Gets the Z component of the vector.
     *
     * This getter automatically triggers an update to ensure the value
     * reflects the current animation state.
     *
     * @returns The current Z component value
     */
    get z(): number;
    /**
     * Updates the vector values based on the current animation state.
     *
     * This method interpolates values from the active animation tracks using
     * the current time. If two tracks are active, it blends them according
     * to the blending ratio. The method handles looping and caches results
     * to avoid unnecessary recalculations.
     */
    update(): void;
    /**
     * Sets the first (primary) active animation track.
     *
     * @param animationTrackName - The name of the animation track to set as primary
     */
    setFirstActiveAnimationTrackName(animationTrackName: AnimationTrackName): void;
    /**
     * Sets the second (secondary) active animation track for blending.
     *
     * @param animationTrackName - The name of the animation track to set as secondary
     */
    setSecondActiveAnimationTrackName(animationTrackName: AnimationTrackName): void;
    /**
     * Gets the name of the first (primary) active animation track.
     *
     * @returns The name of the first active animation track
     */
    getFirstActiveAnimationTrackName(): string;
    /**
     * Gets the name of the second (secondary) active animation track.
     *
     * @returns The name of the second active animation track, or undefined if not set
     */
    getSecondActiveAnimationTrackName(): string | undefined;
    /**
     * Gets the minimum start time from the input data of the specified animation track.
     *
     * @param trackName - The name of the animation track
     * @returns The minimum input time value
     * @throws {Error} When the specified animation track is not found
     */
    getMinStartInputTime(trackName: AnimationTrackName): number;
    /**
     * Gets the maximum end time from the input data of the specified animation track.
     *
     * @param trackName - The name of the animation track
     * @returns The maximum input time value
     * @throws {Error} When the specified animation track is not found
     */
    getMaxEndInputTime(trackName: AnimationTrackName): number;
    /**
     * Gets all available animation track names.
     *
     * @returns An array containing all animation track names
     */
    getAllTrackNames(): string[];
    /**
     * Gets the animation sampler for the specified track.
     *
     * @param trackName - The name of the animation track
     * @returns The animation sampler for the specified track
     * @throws {Error} When the specified animation track is not found
     */
    getAnimationSampler(trackName: AnimationTrackName): AnimationSampler;
    /**
     * Removes an animation sampler for the specified track.
     *
     * @param trackName - The name of the animation track to remove
     */
    deleteAnimationSampler(trackName: AnimationTrackName): void;
    /**
     * Sets or updates an animation sampler for the specified track.
     *
     * @param animationTrackName - The name of the animation track
     * @param animationSampler - The animation sampler to associate with the track
     */
    setAnimationSampler(animationTrackName: AnimationTrackName, animationSampler: AnimationSampler): void;
}

/**
 * An animated 4D vector that interpolates between keyframe values over time.
 * This class extends Vector4 and provides animation capabilities by sampling
 * from animation tracks and optionally blending between two tracks.
 *
 * @example
 * ```typescript
 * const samplers = new Map();
 * const animatedVector = new AnimatedVector4(samplers, 'track1');
 * animatedVector.setTime(2.5);
 * console.log(animatedVector.x, animatedVector.y, animatedVector.z, animatedVector.w);
 * ```
 */
declare class AnimatedVector4 extends Vector4 implements IVector4, IAnimatedValue {
    private __animationSamplers;
    private __firstActiveAnimationTrackName;
    private __firstActiveAnimationSampler;
    private __secondActiveAnimationTrackName?;
    private __secondActiveAnimationSampler?;
    private __blendingRatio;
    private __time?;
    private __lastTime;
    isLoop: boolean;
    /**
     * Creates a new AnimatedVector4 instance.
     *
     * @param animationSamplers - Map containing animation samplers keyed by track names
     * @param activeAnimationTrackName - The name of the initial active animation track
     * @throws {Error} When the specified animation track is not found in the samplers
     */
    constructor(animationSamplers: AnimationSamplers, activeAnimationTrackName: AnimationTrackName);
    /**
     * Returns the vector components as a regular JavaScript array.
     *
     * @returns An array containing the x, y, z, and w components
     */
    getNumberArray(): number[];
    /**
     * Sets the internal Float32Array data and triggers an update.
     *
     * @param array - The Float32Array to set as the internal data
     */
    setFloat32Array(array: Float32Array): void;
    /**
     * Sets the animation time for this vector. When set, this overrides the global time.
     *
     * @param time - The time value in seconds
     */
    setTime(time: number): void;
    /**
     * Switches back to using the global animation time instead of a custom time.
     * This removes any previously set custom time.
     */
    useGlobalTime(): void;
    /**
     * Sets the blending ratio between the first and second animation tracks.
     * A value of 0 means only the first track is used, 1 means only the second track,
     * and values in between create a linear blend.
     *
     * @param value - The blending ratio (typically between 0 and 1)
     */
    set blendingRatio(value: number);
    /**
     * Gets the current blending ratio between animation tracks.
     *
     * @returns The current blending ratio
     */
    get blendingRatio(): number;
    /**
     * Gets the x component of the vector, updating the animation if necessary.
     *
     * @returns The current x component value
     */
    get x(): number;
    /**
     * Gets the y component of the vector, updating the animation if necessary.
     *
     * @returns The current y component value
     */
    get y(): number;
    /**
     * Gets the z component of the vector, updating the animation if necessary.
     *
     * @returns The current z component value
     */
    get z(): number;
    /**
     * Gets the w component of the vector, updating the animation if necessary.
     *
     * @returns The current w component value
     */
    get w(): number;
    /**
     * Updates the vector values by interpolating the animation samplers at the current time.
     * This method handles looping, blending between tracks, and caching to avoid
     * unnecessary recalculations.
     *
     * @private
     */
    update(): void;
    /**
     * Sets the first (primary) active animation track.
     *
     * @param animationTrackName - The name of the animation track to set as primary
     */
    setFirstActiveAnimationTrackName(animationTrackName: AnimationTrackName): void;
    /**
     * Sets the second (secondary) active animation track for blending.
     *
     * @param animationTrackName - The name of the animation track to set as secondary
     */
    setSecondActiveAnimationTrackName(animationTrackName: AnimationTrackName): void;
    /**
     * Gets the name of the first (primary) active animation track.
     *
     * @returns The name of the first active animation track
     */
    getFirstActiveAnimationTrackName(): string;
    /**
     * Gets the name of the second (secondary) active animation track.
     *
     * @returns The name of the second active animation track, or undefined if not set
     */
    getSecondActiveAnimationTrackName(): string | undefined;
    /**
     * Gets the minimum start time of the specified animation track.
     *
     * @param trackName - The name of the animation track
     * @returns The minimum start time of the track
     * @throws {Error} When the specified animation track is not found
     */
    getMinStartInputTime(trackName: AnimationTrackName): number;
    /**
     * Gets the maximum end time of the specified animation track.
     *
     * @param trackName - The name of the animation track
     * @returns The maximum end time of the track
     * @throws {Error} When the specified animation track is not found
     */
    getMaxEndInputTime(trackName: AnimationTrackName): number;
    /**
     * Gets an array of all available animation track names.
     *
     * @returns An array containing all animation track names
     */
    getAllTrackNames(): string[];
    /**
     * Gets the animation sampler for the specified track.
     *
     * @param trackName - The name of the animation track
     * @returns The animation sampler for the specified track
     * @throws {Error} When the specified animation track is not found
     */
    getAnimationSampler(trackName: AnimationTrackName): AnimationSampler;
    /**
     * Removes an animation sampler for the specified track.
     *
     * @param trackName - The name of the animation track to remove
     */
    deleteAnimationSampler(trackName: AnimationTrackName): void;
    /**
     * Sets or adds an animation sampler for the specified track.
     *
     * @param animationTrackName - The name of the animation track
     * @param animationSampler - The animation sampler to set for this track
     */
    setAnimationSampler(animationTrackName: AnimationTrackName, animationSampler: AnimationSampler): void;
}

/**
 * An animated vector class that extends VectorN and implements animation interpolation.
 * This class manages multiple animation tracks and supports blending between them.
 * It can interpolate vector values over time using animation samplers.
 */
declare class AnimatedVectorN extends VectorN implements IAnimatedValue {
    private __animationSamplers;
    private __firstActiveAnimationTrackName;
    private __firstActiveAnimationSampler;
    private __secondActiveAnimationTrackName?;
    private __secondActiveAnimationSampler?;
    private __blendingRatio;
    private __time?;
    private __lastTime;
    isLoop: boolean;
    /**
     * Creates a new AnimatedVectorN instance.
     * @param animationSamplers - Map of animation track names to their corresponding samplers
     * @param activeAnimationTrackName - The name of the initially active animation track
     * @throws {Error} When the specified animation track is not found
     */
    constructor(animationSamplers: AnimationSamplers, activeAnimationTrackName: AnimationTrackName);
    /**
     * Gets the vector components as a plain number array.
     * @returns A new array containing the vector components
     */
    getNumberArray(): number[];
    /**
     * Sets the internal Float32Array and updates the animation state.
     * @param array - The new Float32Array to set
     */
    setFloat32Array(array: Float32Array): void;
    /**
     * Sets a specific time for animation evaluation instead of using global time.
     * @param time - The time value to set for animation evaluation
     */
    setTime(time: number): void;
    /**
     * Switches back to using the global animation time instead of a specific time.
     */
    useGlobalTime(): void;
    /**
     * Sets the blending ratio between the first and second active animation tracks.
     * @param value - The blending ratio (0.0 = first track only, 1.0 = second track only)
     */
    set blendingRatio(value: number);
    /**
     * Gets the current blending ratio between animation tracks.
     * @returns The current blending ratio
     */
    get blendingRatio(): number;
    /**
     * Updates the vector values based on the current time and active animation tracks.
     * Handles time looping, interpolation, and blending between multiple tracks.
     */
    update(): void;
    /**
     * Sets the first active animation track by name.
     * @param animationTrackName - The name of the animation track to set as first active
     */
    setFirstActiveAnimationTrackName(animationTrackName: AnimationTrackName): void;
    /**
     * Sets the second active animation track by name for blending purposes.
     * @param animationTrackName - The name of the animation track to set as second active
     */
    setSecondActiveAnimationTrackName(animationTrackName: AnimationTrackName): void;
    /**
     * Gets the name of the first active animation track.
     * @returns The name of the first active animation track
     */
    getFirstActiveAnimationTrackName(): string;
    /**
     * Gets the name of the second active animation track.
     * @returns The name of the second active animation track, or undefined if not set
     */
    getSecondActiveAnimationTrackName(): string | undefined;
    /**
     * Gets the minimum start time for a specific animation track.
     * @param trackName - The name of the animation track
     * @returns The minimum start input time for the track
     * @throws {Error} When the animation track is not found
     */
    getMinStartInputTime(trackName: AnimationTrackName): number;
    /**
     * Gets the maximum end time for a specific animation track.
     * @param trackName - The name of the animation track
     * @returns The maximum end input time for the track
     * @throws {Error} When the animation track is not found
     */
    getMaxEndInputTime(trackName: AnimationTrackName): number;
    /**
     * Gets all available animation track names.
     * @returns An array containing all animation track names
     */
    getAllTrackNames(): string[];
    /**
     * Gets the animation sampler for a specific track.
     * @param trackName - The name of the animation track
     * @returns The animation sampler for the specified track
     * @throws {Error} When the animation track is not found
     */
    getAnimationSampler(trackName: AnimationTrackName): AnimationSampler;
    /**
     * Removes an animation sampler from the available tracks.
     * @param trackName - The name of the animation track to remove
     */
    deleteAnimationSampler(trackName: AnimationTrackName): void;
    /**
     * Adds or updates an animation sampler for a specific track.
     * @param animationTrackName - The name of the animation track
     * @param animationSampler - The animation sampler to set for the track
     */
    setAnimationSampler(animationTrackName: AnimationTrackName, animationSampler: AnimationSampler): void;
}

/**
 * An animated quaternion that can be driven by animation samplers.
 * This class extends the base Quaternion class to provide animation capabilities,
 * allowing quaternion values to be interpolated over time using animation tracks.
 * Supports blending between multiple animation tracks and both local and global time management.
 */
declare class AnimatedQuaternion extends Quaternion implements IQuaternion, IAnimatedValue {
    private __animationSamplers;
    private __firstActiveAnimationTrackName;
    private __firstActiveAnimationSampler;
    private __secondActiveAnimationTrackName?;
    private __secondActiveAnimationSampler?;
    private __blendingRatio;
    private __time?;
    private __lastTime;
    isLoop: boolean;
    /**
     * Creates a new AnimatedQuaternion instance.
     * @param animationSamplers - Map of animation samplers keyed by track names
     * @param activeAnimationTrackName - The initial active animation track name
     * @throws {Error} When the specified animation track is not found in the samplers
     */
    constructor(animationSamplers: AnimationSamplers, activeAnimationTrackName: AnimationTrackName);
    /**
     * Returns the quaternion values as a number array.
     * @returns Array containing the x, y, z, w components of the quaternion
     */
    getNumberArray(): number[];
    /**
     * Sets the quaternion values from a Float32Array.
     * @param array - Float32Array containing the quaternion components [x, y, z, w]
     */
    setFloat32Array(array: Float32Array): void;
    /**
     * Sets the local animation time for this quaternion.
     * When set, this time will be used instead of the global animation time.
     * @param time - The animation time in seconds
     */
    setTime(time: number): void;
    /**
     * Switches to using global animation time instead of local time.
     * Resets the local time and triggers an update.
     */
    useGlobalTime(): void;
    /**
     * Sets the blending ratio between the first and second active animation tracks.
     * @param value - Blending ratio (0.0 = first track only, 1.0 = second track only)
     */
    set blendingRatio(value: number);
    /**
     * Gets the current blending ratio between animation tracks.
     * @returns The current blending ratio
     */
    get blendingRatio(): number;
    /**
     * Gets the x component of the quaternion.
     * Triggers an update before returning the value.
     * @returns The x component
     */
    get x(): number;
    /**
     * Gets the y component of the quaternion.
     * Triggers an update before returning the value.
     * @returns The y component
     */
    get y(): number;
    /**
     * Gets the z component of the quaternion.
     * Triggers an update before returning the value.
     * @returns The z component
     */
    get z(): number;
    /**
     * Gets the w component of the quaternion.
     * Triggers an update before returning the value.
     * @returns The w component
     */
    get w(): number;
    /**
     * Updates the quaternion values based on the current animation time and active tracks.
     * This method interpolates values from animation samplers and handles blending between tracks.
     * If looping is enabled, the time will wrap around the animation duration.
     */
    update(): void;
    /**
     * Sets the first active animation track.
     * @param animationTrackName - The name of the animation track to set as the first active track
     */
    setFirstActiveAnimationTrackName(animationTrackName: AnimationTrackName): void;
    /**
     * Sets the second active animation track for blending.
     * @param animationTrackName - The name of the animation track to set as the second active track
     */
    setSecondActiveAnimationTrackName(animationTrackName: AnimationTrackName): void;
    /**
     * Gets the name of the first active animation track.
     * @returns The first active animation track name
     */
    getFirstActiveAnimationTrackName(): string;
    /**
     * Gets the name of the second active animation track.
     * @returns The second active animation track name, or undefined if not set
     */
    getSecondActiveAnimationTrackName(): string | undefined;
    /**
     * Gets the minimum start time for the specified animation track.
     * @param trackName - The animation track name
     * @returns The start time of the animation track
     * @throws {Error} When the specified animation track is not found
     */
    getMinStartInputTime(trackName: AnimationTrackName): number;
    /**
     * Gets the maximum end time for the specified animation track.
     * @param trackName - The animation track name
     * @returns The end time of the animation track
     * @throws {Error} When the specified animation track is not found
     */
    getMaxEndInputTime(trackName: AnimationTrackName): number;
    /**
     * Gets all available animation track names.
     * @returns Array of all animation track names
     */
    getAllTrackNames(): string[];
    /**
     * Gets the animation sampler for the specified track.
     * @param trackName - The animation track name
     * @returns The animation sampler for the track
     * @throws {Error} When the specified animation track is not found
     */
    getAnimationSampler(trackName: AnimationTrackName): AnimationSampler;
    /**
     * Deletes an animation sampler for the specified track.
     * @param trackName - The animation track name to delete
     */
    deleteAnimationSampler(trackName: AnimationTrackName): void;
    /**
     * Sets or updates an animation sampler for the specified track.
     * @param animationTrackName - The animation track name
     * @param animationSampler - The animation sampler to set
     */
    setAnimationSampler(animationTrackName: AnimationTrackName, animationSampler: AnimationSampler): void;
}

/**
 * Internal physics property configuration containing detailed shape and physics parameters.
 * This type defines the complete set of properties needed for physics simulation.
 */
type PhysicsPropertyInner = {
    /** The type of physics shape (box, sphere, capsule, etc.) */
    type: PhysicsShapeTypeEnum;
    /** The size/dimensions of the physics shape in 3D space */
    size: IVector3;
    /** The position offset of the physics shape relative to the entity */
    position: IVector3;
    /** The rotation of the physics shape in Euler angles */
    rotation: IVector3;
    /** Whether the physics body can move (dynamic) or is static */
    move: boolean;
    /** The density of the physics body, affecting its mass */
    density: number;
    /** The friction coefficient for surface interactions (0.0 to 1.0) */
    friction: number;
    /** The restitution (bounciness) coefficient for collisions (0.0 to 1.0) */
    restitution: number;
};
/**
 * Simplified physics property configuration for basic physics setup.
 * This type provides a minimal interface for enabling physics on entities.
 */
type PhysicsProperty = {
    /** Whether physics simulation is enabled for this entity */
    use: boolean;
    /** Whether the physics body can move (dynamic) or is static */
    move: boolean;
    /** The density of the physics body, affecting its mass */
    density: number;
    /** The friction coefficient for surface interactions (0.0 to 1.0) */
    friction: number;
    /** The restitution (bounciness) coefficient for collisions (0.0 to 1.0) */
    restitution: number;
};

/**
 * Descriptor interface for creating a cube primitive
 */
interface CubeDescriptor extends IAnyPrimitiveDescriptor {
    /** three width (width, height, depth) in (x, y, z) */
    widthVector?: IVector3;
    /** color */
    color?: IColorRgba;
    physics?: PhysicsProperty;
}
/**
 * The Cube Primitive class for generating 3D cube geometry
 *
 * This class provides functionality to create cube primitives with customizable
 * dimensions, colors, and materials. The cube is generated with proper vertex
 * attributes including positions, normals, texture coordinates, and optional colors.
 */
declare class Cube extends IShape {
    /**
     * Generates a cube primitive with specified parameters
     *
     * Creates a cube geometry with 24 vertices (4 per face) and 12 triangles (2 per face).
     * The cube is centered at the origin and extends in both positive and negative
     * directions along each axis based on the width vector.
     *
     * @param _desc - The cube descriptor containing generation parameters
     * @param _desc.widthVector - The dimensions of the cube in x, y, z directions (defaults to 1,1,1)
     * @param _desc.color - Optional color to apply to all vertices of the cube
     * @param _desc.material - Material to assign to the generated cube primitive
     *
     * @example
     * ```typescript
     * const cube = new Cube();
     * cube.generate({
     *   widthVector: Vector3.fromCopy3(2, 1, 1),
     *   color: { r: 1, g: 0, b: 0, a: 1 },
     *   material: myMaterial
     * });
     * ```
     */
    generate(_desc: CubeDescriptor): void;
}

/**
 * Configuration interface for creating a grid shape
 * @interface GridDescriptor
 * @extends IAnyPrimitiveDescriptor
 */
interface GridDescriptor extends IAnyPrimitiveDescriptor {
    /** The length of each axis from center to edge */
    length?: Size;
    /** The number of divisions along each axis */
    division?: Size;
    /** Whether to generate grid lines on the XZ plane */
    isXZ?: boolean;
    /** Whether to generate grid lines on the XY plane */
    isXY?: boolean;
    /** Whether to generate grid lines on the YZ plane */
    isYZ?: boolean;
}
/**
 * A 3D grid shape generator that creates line-based grid structures
 * Can generate grids on XY, XZ, and YZ planes with configurable divisions
 * @class Grid
 * @extends IShape
 */
declare class Grid extends IShape {
    /**
     * Generates a 3D grid with lines based on the provided configuration
     * Creates evenly spaced grid lines on the specified planes (XY, XZ, YZ)
     *
     * @param _desc - Configuration object defining grid properties
     * @param _desc.length - Half-length of the grid from center to edge (default: 1)
     * @param _desc.division - Number of divisions between grid lines (default: 10)
     * @param _desc.isXY - Generate grid lines on XY plane (default: true)
     * @param _desc.isXZ - Generate grid lines on XZ plane (default: true)
     * @param _desc.isYZ - Generate grid lines on YZ plane (default: true)
     * @param _desc.material - Material to apply to the grid
     *
     * @example
     * ```typescript
     * const grid = new Grid();
     * grid.generate({
     *   length: 5,
     *   division: 20,
     *   isXZ: true,
     *   isXY: false,
     *   isYZ: false
     * });
     * ```
     */
    generate(_desc: GridDescriptor): void;
}

type JointDescriptor = IAnyPrimitiveDescriptor;
/**
 * The Joint class represents a 3D joint visualization that creates an arrow-like shape
 * connecting two world positions, typically used for displaying skeletal connections
 * or hierarchical relationships in 3D space.
 */
declare class Joint extends IShape {
    /** The world position of this joint (the starting point of the arrow) */
    private __worldPositionOfThisJoint;
    /** The world position of the parent joint (the ending point of the arrow) */
    private __worldPositionOfParentJoint;
    /** The width of the arrow shape */
    private __width;
    /**
     * Generates a 3D joint visualization as an arrow-like shape connecting two points.
     * The joint is rendered as a combination of pyramidal shapes and connecting lines,
     * creating a visual representation of the connection between this joint and its parent.
     *
     * @param desc - The primitive descriptor containing material and other rendering properties
     *
     * @remarks
     * The generated shape consists of:
     * - A long pyramid extending from this joint towards the parent
     * - A connecting plane section
     * - A short pyramid at the parent joint position
     * All rendered as line segments for wireframe visualization
     */
    generate(desc: JointDescriptor): void;
}

/**
 * Descriptor interface for configuring Line geometry generation
 */
interface LineDescriptor extends IAnyPrimitiveDescriptor {
    /** the start position */
    startPos?: IVector3;
    /** the end position */
    endPos?: IVector3;
    /** whether it has the terminal mark */
    hasTerminalMark?: boolean;
}
/**
 * A geometric shape class for creating line primitives with optional terminal markers.
 * Extends IShape to provide line-specific geometry generation capabilities.
 */
declare class Line extends IShape {
    /**
     * Generates a line geometry with optional terminal markers at both endpoints.
     * Creates a line between two points with small cross-shaped markers to indicate
     * the start and end positions when hasTerminalMark is enabled.
     *
     * @param _desc - Configuration object containing line parameters
     * @param _desc.startPos - Starting position of the line (defaults to origin)
     * @param _desc.endPos - Ending position of the line (defaults to (1,0,0))
     * @param _desc.hasTerminalMark - Whether to add cross markers at endpoints (defaults to true)
     * @param _desc.material - Material to apply to the generated geometry
     *
     * @example
     * ```typescript
     * const line = new Line();
     * line.generate({
     *   startPos: Vector3.fromCopy3(0, 0, 0),
     *   endPos: Vector3.fromCopy3(5, 0, 0),
     *   hasTerminalMark: true,
     *   material: myMaterial
     * });
     * ```
     */
    generate(_desc: LineDescriptor): void;
}

/**
 * Interface describing the configuration options for creating a plane geometry
 * @interface PlaneDescriptor
 * @extends IAnyPrimitiveDescriptor
 */
interface PlaneDescriptor extends IAnyPrimitiveDescriptor {
    /** the length of U(X)-axis direction */
    width?: Size;
    /** the length of V(Y)-axis direction */
    height?: Size;
    /** number of spans in U(X)-axis direction */
    uSpan?: Size;
    /** number of spans in V(Y)-axis direction */
    vSpan?: Size;
    /** draw uSpan times vSpan number of textures */
    isUVRepeat?: boolean;
    /** draw textures by flipping on the V(Y)-axis */
    flipTextureCoordinateY?: boolean;
}
/**
 * A class for generating plane geometry with customizable dimensions and tessellation
 *
 * The Plane class creates a rectangular mesh that lies in the XZ plane (Y=0) by default.
 * It supports various configuration options including size, subdivision, and texture mapping.
 *
 * @class Plane
 * @extends IShape
 */
declare class Plane extends IShape {
    /**
     * Generates a plane geometry with the specified parameters
     *
     * Creates a rectangular plane mesh with configurable width, height, and tessellation.
     * The plane is generated in the XZ plane with Y=0, centered at the origin.
     * Supports texture coordinate generation with optional UV repetition and Y-axis flipping.
     *
     * @param _desc - Configuration object containing plane generation parameters
     * @param _desc.width - The width of the plane along the X-axis (default: 1)
     * @param _desc.height - The height of the plane along the Z-axis (default: 1)
     * @param _desc.uSpan - Number of subdivisions along the U(X)-axis (default: 1)
     * @param _desc.vSpan - Number of subdivisions along the V(Z)-axis (default: 1)
     * @param _desc.isUVRepeat - Whether to repeat texture coordinates instead of normalizing (default: false)
     * @param _desc.flipTextureCoordinateY - Whether to flip texture coordinates along the V-axis (default: false)
     * @param _desc.material - Optional material to assign to the generated geometry
     *
     * @returns void
     *
     * @example
     * ```typescript
     * const plane = new Plane();
     * plane.generate({
     *   width: 2,
     *   height: 2,
     *   uSpan: 4,
     *   vSpan: 4,
     *   isUVRepeat: false,
     *   flipTextureCoordinateY: true
     * });
     * ```
     */
    generate(_desc: PlaneDescriptor): void;
}

/**
 * The argument descriptor for Sphere primitives
 */
interface SphereDescriptor extends IAnyPrimitiveDescriptor {
    /**
     * The radius of the sphere.
     * @default 1
     */
    radius?: number;
    /**
     * The number of segments that define the sphere's width (horizontal divisions).
     * @default 10
     */
    widthSegments?: Count;
    /**
     * The number of segments that define the sphere's height (vertical divisions).
     * @default 10
     */
    heightSegments?: Count;
    /**
     * Indicates whether to invert the normals of the sphere's surface.
     * @default false
     */
    inverseNormal?: boolean;
    /**
     * Physics properties associated with the sphere, such as mass and collision settings.
     */
    physics?: PhysicsProperty;
}
/**
 * Sphere class for generating spherical geometry with customizable parameters
 */
declare class Sphere extends IShape {
    /**
     * Generates sphere geometry with the specified parameters
     *
     * @param _desc - The sphere descriptor containing generation parameters
     * @param _desc.radius - The radius of the sphere (default: 1)
     * @param _desc.widthSegments - The number of horizontal segments (default: 10)
     * @param _desc.heightSegments - The number of vertical segments (default: 10)
     * @param _desc.material - The material to apply to the sphere
     * @param _desc.inverseNormal - Whether to invert the normals (default: false)
     *
     * @remarks
     * This method generates vertex positions, texture coordinates, normals, and indices
     * for a UV sphere using spherical coordinates. The sphere is centered at the origin.
     *
     * If the radius is zero or nearly zero, it will be clamped to 0.001 for safety.
     * A small shift value is applied to avoid singularities at the poles.
     *
     * The texture coordinates are mapped so that u ranges from 0 to 1 (longitude)
     * and v ranges from 0 to 1 (latitude).
     *
     * @example
     * ```typescript
     * const sphere = new Sphere();
     * sphere.generate({
     *   radius: 2.0,
     *   widthSegments: 20,
     *   heightSegments: 20,
     *   material: myMaterial
     * });
     * ```
     */
    generate(_desc: SphereDescriptor): void;
}

/**
 * Creates a mesh entity from a primitive shape.
 * This is a utility function used internally by other creation methods.
 *
 * @param primitive - The primitive shape to convert into a mesh entity
 * @returns A mesh entity containing the primitive shape
 *
 * @example
 * ```typescript
 * const customPrimitive = new CustomShape();
 * customPrimitive.generate(config);
 * const entity = createShape(customPrimitive);
 * ```
 */
declare function createShape(primitive: IShape): IMeshEntity;
declare const MeshHelper: Readonly<{
    createPlane: (desc?: PlaneDescriptor & {
        direction?: "xz" | "xy" | "yz";
    }) => IMeshEntity;
    createLine: (desc?: LineDescriptor) => IMeshEntity;
    createGrid: (desc?: GridDescriptor) => IMeshEntity;
    createCube: (desc?: CubeDescriptor) => IMeshEntity;
    createCubes: (numberToCreate: number, desc?: CubeDescriptor) => IMeshEntity[];
    createSphere: (desc?: SphereDescriptor) => IMeshEntity;
    createSpheres: (numberToCreate: number, desc?: SphereDescriptor) => IMeshEntity[];
    createJoint: (desc?: JointDescriptor) => IMeshEntity;
    createAxis: (desc?: AxisDescriptor) => IMeshEntity;
    createShape: typeof createShape;
}>;

/**
 * A render buffer class that represents a renderable texture buffer used for off-screen rendering.
 * This class manages GPU resources for render targets, depth buffers, and MSAA (Multi-Sample Anti-Aliasing) buffers.
 * It implements the IRenderable interface and extends RnObject for resource management.
 */
declare class RenderBuffer extends RnObject implements IRenderable {
    /** The width of the render buffer in pixels */
    width: number;
    /** The height of the render buffer in pixels */
    height: number;
    /** The internal texture format of the render buffer */
    private __internalFormat;
    /** The unique identifier for the texture resource in the graphics API */
    _textureResourceUid: CGAPIResourceHandle;
    /** The unique identifier for the texture view resource */
    _textureViewResourceUid: CGAPIResourceHandle;
    /** The unique identifier for the texture view used as a render target */
    _textureViewAsRenderTargetResourceUid: CGAPIResourceHandle;
    /** The associated frame buffer object */
    private __fbo?;
    /** Flag indicating whether MSAA (Multi-Sample Anti-Aliasing) is enabled */
    private __isMSAA;
    /** The number of samples used for MSAA */
    private __sampleCountMSAA;
    /**
     * Sets the associated frame buffer object.
     * @param fbo - The frame buffer object to associate with this render buffer
     */
    set _fbo(fbo: FrameBuffer);
    /**
     * Gets the associated frame buffer object.
     * @returns The frame buffer object or undefined if not set
     */
    get fbo(): FrameBuffer | undefined;
    /**
     * Gets the MSAA sample count for this render buffer.
     * @returns The number of samples used for multi-sample anti-aliasing
     */
    get sampleCount(): number;
    /**
     * Creates and initializes the render buffer with the specified parameters.
     * This method allocates GPU resources and sets up the render buffer for rendering operations.
     *
     * @param width - The width of the render buffer in pixels
     * @param height - The height of the render buffer in pixels
     * @param internalFormat - The internal texture format for the render buffer
     * @param options - Optional configuration object
     * @param options.isMSAA - Whether to enable multi-sample anti-aliasing (default: false)
     * @param options.sampleCountMSAA - The number of MSAA samples (default: current sample count)
     */
    create(width: Size, height: Size, internalFormat: TextureParameterEnum, { isMSAA, sampleCountMSAA }?: {
        isMSAA?: boolean | undefined;
        sampleCountMSAA?: number | undefined;
    }): void;
    /**
     * Creates a cube texture view as a render target for a specific face and mip level.
     * This method is currently not implemented and serves as a placeholder for future functionality.
     *
     * @param faceIdx - The index of the cube face (0-5)
     * @param mipLevel - The mip level to create the view for
     */
    createCubeTextureViewAsRenderTarget(_faceIdx: Index, _mipLevel: Index): void;
    /**
     * Resizes the render buffer to new dimensions.
     * This method destroys the current GPU resources and recreates them with the new size,
     * preserving the original format and MSAA settings.
     *
     * @param width - The new width in pixels
     * @param height - The new height in pixels
     */
    resize(width: Size, height: Size): void;
    /**
     * Destroys all GPU resources associated with this render buffer.
     * This method releases the allocated graphics API resources and resets the buffer state.
     * Should be called when the render buffer is no longer needed to prevent memory leaks.
     *
     * @returns True if the resources were successfully destroyed
     */
    destroy3DAPIResources(): boolean;
}

/**
 * A 2D texture array that can be used as a render target.
 * This class extends AbstractTexture and implements IRenderable to provide
 * functionality for creating and managing 2D texture arrays that can be
 * rendered to in graphics pipelines.
 */
declare class RenderTargetTexture2DArray extends AbstractTexture implements IRenderable {
    private __fbo?;
    private __arrayLength;
    /**
     * Creates and initializes the 2D texture array with the specified parameters.
     * @param params - Configuration object for texture creation
     * @param params.width - Width of the texture in pixels
     * @param params.height - Height of the texture in pixels
     * @param params.level - Mipmap level (default: 0)
     * @param params.internalFormat - Internal format of the texture (default: RGB8)
     * @param params.format - Pixel format of the texture (default: RGBA)
     * @param params.type - Component type of the texture data (default: UnsignedByte)
     * @param params.arrayLength - Number of layers in the texture array
     */
    create({ width, height, level, internalFormat, format, type, arrayLength, }: {
        width: Size;
        height: Size;
        level: number;
        internalFormat: TextureFormatEnum;
        format: PixelFormatEnum;
        type: ComponentTypeEnum;
        arrayLength: number;
    }): void;
    /**
     * Sets the framebuffer object associated with this render target.
     * @param fbo - The framebuffer object to associate with this texture
     */
    set _fbo(fbo: FrameBuffer);
    /**
     * Gets the framebuffer object associated with this render target.
     * @returns The associated framebuffer object, or undefined if not set
     */
    get fbo(): FrameBuffer | undefined;
    /**
     * Gets the number of layers in the texture array.
     * @returns The array length (number of layers)
     */
    get arrayLength(): number;
    /**
     * Creates the underlying graphics API resources for the render target texture array.
     * This method handles both WebGL and WebGPU resource creation.
     * @private
     */
    private __createRenderTargetTextureArray;
    /**
     * Changes the render target layer for WebGPU rendering.
     * This method creates a new texture view targeting a specific layer of the array.
     * @param layerIndex - The index of the layer to target for rendering
     */
    changeRenderTargetLayerWebGPU(layerIndex: Index): void;
    /**
     * Resizes the texture array to new dimensions.
     * This destroys the existing resources and recreates them with the new size.
     * @param width - New width in pixels
     * @param height - New height in pixels
     */
    resize(width: Size, height: Size): void;
    /**
     * Destroys all graphics API resources associated with this texture.
     * This should be called when the texture is no longer needed to free GPU memory.
     * @returns True if resources were successfully destroyed
     */
    destroy3DAPIResources(): boolean;
    /**
     * Retrieves the pixel data from the texture as a byte array.
     * This is an asynchronous operation that reads back data from the GPU.
     * @returns Promise that resolves to a Uint8Array containing the pixel data
     */
    getTexturePixelData(): Promise<Uint8Array<ArrayBufferLike>>;
    /**
     * Downloads the texture pixel data as a PNG image file.
     * This method creates a canvas, draws the texture data to it, and triggers
     * a download of the resulting image.
     */
    downloadTexturePixelData(): Promise<void>;
    /**
     * Gets the pixel value at a specific coordinate in the texture.
     * The coordinate system has its origin at the bottom-left corner.
     * @param x - Horizontal pixel position (0 is left)
     * @param y - Vertical pixel position (0 is bottom)
     * @param argByteArray - Optional pre-fetched pixel data array. If not provided, data will be fetched from GPU
     * @returns Promise that resolves to a Vector4 containing the RGBA pixel values
     */
    getPixelValueAt(x: Index, y: Index, argByteArray?: Uint8Array): Promise<Vector4>;
    /**
     * Generates mipmaps for the texture.
     * This creates lower resolution versions of the texture for improved rendering performance
     * and quality when the texture is viewed at different distances.
     */
    generateMipmaps(): void;
    /**
     * Blits (copies) data from this texture array to a 2D texture.
     * This operation copies the first layer of the array to the target texture.
     * @param targetTexture2D - The target 2D texture to copy data to
     */
    blitToTexture2dFromTexture2dArray(targetTexture2D: RenderTargetTexture2DArray): void;
    /**
     * Performs a fake blit operation from this texture array to a 2D texture.
     * This is likely a fallback or alternative implementation for specific use cases.
     * @param targetTexture2D - The target 2D texture to copy data to
     */
    blitToTexture2dFromTexture2dArrayFake(targetTexture2D: RenderTargetTexture2DArray): void;
    /**
     * Alternative blit implementation from texture array to 2D texture.
     * This version uses a different approach and scales the target to half width.
     * @param targetTexture2D - The target 2D texture to copy data to
     */
    blitToTexture2dFromTexture2dArray2(targetTexture2D: RenderTargetTexture2DArray): void;
    /**
     * Creates a cube texture view as a render target for a specific face and mip level.
     * Currently this method is not implemented (empty body).
     * @param faceIdx - The index of the cube face to target
     * @param mipLevel - The mipmap level to target
     */
    createCubeTextureViewAsRenderTarget(_faceIdx: Index, _mipLevel: Index): void;
}

/**
 * Configuration options for VideoTexture creation and processing.
 */
type VideoTextureArguments = {
    level: number;
    internalFormat: PixelFormatEnum;
    format: PixelFormatEnum;
    type: ComponentTypeEnum;
    magFilter: TextureParameterEnum;
    minFilter: TextureParameterEnum;
    wrapS: TextureParameterEnum;
    wrapT: TextureParameterEnum;
    generateMipmap: boolean;
    anisotropy: boolean;
    isPremultipliedAlpha?: boolean;
    mutedAutoPlay: boolean;
    playButtonDomElement?: HTMLElement;
};
/**
 * A texture class that handles video content as texture data.
 * Extends AbstractTexture to provide video-specific functionality including
 * video loading, playback control, and real-time texture updates.
 *
 * @example
 * ```typescript
 * const videoTexture = new VideoTexture();
 * await videoTexture.generateTextureFromUri('path/to/video.mp4');
 * videoTexture.play();
 * ```
 */
declare class VideoTexture extends AbstractTexture {
    #private;
    private __imageData?;
    autoResize: boolean;
    autoDetectTransparency: boolean;
    private static __loadedBasisFunc;
    private static __basisLoadPromise?;
    /**
     * Creates a resized canvas from an image, maintaining aspect ratio and ensuring power-of-two dimensions.
     * Optionally detects transparency in the image data.
     *
     * @param image - The source image to resize
     * @param maxSize - Maximum size constraint for the output canvas
     * @returns A canvas element containing the resized image
     * @private
     */
    private __getResizedCanvas;
    /**
     * Generates a texture from an existing HTMLVideoElement.
     * Sets up the video element for playback and creates the corresponding WebGL texture.
     *
     * @param video - The HTMLVideoElement to use as texture source
     * @param options - Configuration options for texture generation
     * @param options.level - Mipmap level (default: 0)
     * @param options.internalFormat - Internal pixel format (default: RGBA8)
     * @param options.format - Pixel format (default: RGBA)
     * @param options.type - Component type (default: UnsignedByte)
     * @param options.generateMipmap - Whether to generate mipmaps (default: false)
     * @param options.mutedAutoPlay - Whether to enable muted autoplay (default: true)
     *
     * @example
     * ```typescript
     * const video = document.getElementById('myVideo') as HTMLVideoElement;
     * await videoTexture.generateTextureFromVideo(video, {
     *   generateMipmap: true,
     *   mutedAutoPlay: false
     * });
     * ```
     */
    generateTextureFromVideo(video: HTMLVideoElement, { level, internalFormat, format, type, generateMipmap, mutedAutoPlay, }?: {
        level?: number | undefined;
        internalFormat?: TextureFormatEnum | undefined;
        format?: EnumIO | undefined;
        type?: {
            readonly __webgpu: string;
            readonly __wgsl: string;
            readonly __sizeInBytes: number;
            readonly __dummyStr: "UNSIGNED_BYTE";
            readonly wgsl: string;
            readonly webgpu: string;
            getSizeInBytes(): number;
            isFloatingPoint(): boolean;
            isInteger(): boolean;
            isUnsignedInteger(): boolean;
            readonly index: number;
            readonly symbol: symbol;
            readonly str: string;
            toString(): string;
            toJSON(): number;
        } | undefined;
        generateMipmap?: boolean | undefined;
        mutedAutoPlay?: boolean | undefined;
    }): Promise<void>;
    /**
     * Generates a texture from a video file URI.
     * Creates a video element, loads the specified video, and sets up texture generation.
     * Supports both automatic playback and manual playback via a play button.
     *
     * @param videoUri - URI of the video file to load
     * @param options - Configuration options for texture generation
     * @param options.level - Mipmap level (default: 0)
     * @param options.internalFormat - Internal pixel format (default: RGBA8)
     * @param options.format - Pixel format (default: RGBA)
     * @param options.type - Component type (default: UnsignedByte)
     * @param options.generateMipmap - Whether to generate mipmaps (default: false)
     * @param options.mutedAutoPlay - Whether to enable muted autoplay (default: true)
     * @param options.playButtonDomElement - Optional button element to trigger manual playback
     * @returns Promise that resolves when the texture is ready
     *
     * @example
     * ```typescript
     * const playButton = document.getElementById('playBtn');
     * await videoTexture.generateTextureFromUri('video.mp4', {
     *   mutedAutoPlay: false,
     *   playButtonDomElement: playButton
     * });
     * ```
     */
    generateTextureFromUri(videoUri: string, { level, internalFormat, format, type, generateMipmap, mutedAutoPlay, playButtonDomElement, }?: {
        level?: number | undefined;
        internalFormat?: TextureFormatEnum | undefined;
        format?: EnumIO | undefined;
        type?: {
            readonly __webgpu: string;
            readonly __wgsl: string;
            readonly __sizeInBytes: number;
            readonly __dummyStr: "UNSIGNED_BYTE";
            readonly wgsl: string;
            readonly webgpu: string;
            getSizeInBytes(): number;
            isFloatingPoint(): boolean;
            isInteger(): boolean;
            isUnsignedInteger(): boolean;
            readonly index: number;
            readonly symbol: symbol;
            readonly str: string;
            toString(): string;
            toJSON(): number;
        } | undefined;
        generateMipmap?: boolean | undefined;
        mutedAutoPlay?: boolean | undefined;
        playButtonDomElement?: undefined;
    }): Promise<void>;
    /**
     * Updates the texture with the current video frame.
     * Should be called regularly (e.g., in a render loop) to keep the texture
     * synchronized with the video playback.
     *
     * @example
     * ```typescript
     * // In render loop
     * function render() {
     *   videoTexture.updateTexture();
     *   // ... other rendering code
     *   requestAnimationFrame(render);
     * }
     * ```
     */
    updateTexture(): void;
    /**
     * Retrieves the pixel data of the current video frame.
     * Useful for image processing or analysis of video content.
     *
     * @returns A tuple containing [pixelData, width, height] where pixelData is a Uint8Array
     *          of RGBA values, or [undefined, width, height] if texture is not ready
     *
     * @example
     * ```typescript
     * const [pixels, width, height] = videoTexture.getCurrentFramePixelData();
     * if (pixels) {
     *   // Process pixel data
     *   console.log(`Frame size: ${width}x${height}, pixels: ${pixels.length}`);
     * }
     * ```
     */
    getCurrentFramePixelData(): (number | Uint8Array<ArrayBufferLike> | undefined)[];
    /**
     * Sets the playback rate of the video.
     *
     * @param value - Playback rate multiplier (1.0 = normal speed, 2.0 = double speed, 0.5 = half speed)
     *
     * @example
     * ```typescript
     * videoTexture.playbackRate = 2.0; // Play at double speed
     * ```
     */
    set playbackRate(value: number);
    /**
     * Gets the current playback rate of the video.
     *
     * @returns The current playback rate, or 1 if no video element is available
     *
     * @example
     * ```typescript
     * const currentRate = videoTexture.playbackRate;
     * console.log(`Current playback rate: ${currentRate}`);
     * ```
     */
    get playbackRate(): number;
    /**
     * Starts or resumes video playback.
     *
     * @example
     * ```typescript
     * videoTexture.play();
     * ```
     */
    play(): void;
    /**
     * Pauses video playback.
     *
     * @example
     * ```typescript
     * videoTexture.pause();
     * ```
     */
    pause(): void;
}

/**
 * Parameters for texture configuration
 */
interface TextureParameters {
    /** Mip level of the texture */
    level: number;
    /** Texture format parameter */
    format: TextureParameterEnum;
}
/**
 * Descriptor for creating a standard frame buffer with color and optional depth attachments
 */
interface FrameBufferDescriptor {
    /** Width of the frame buffer in pixels */
    width: number;
    /** Height of the frame buffer in pixels */
    height: number;
    /** Number of color texture attachments */
    textureNum: number;
    /** Array of texture formats for each color attachment */
    textureFormats: TextureFormatEnum[];
    /** Number of mip levels to generate (optional) */
    mipLevelCount?: number;
    /** Whether to create a depth buffer attachment */
    createDepthBuffer: boolean;
    /** Format for the depth texture (optional, defaults to Depth32F) */
    depthTextureFormat?: TextureFormatEnum;
}
/**
 * Creates a standard frame buffer with the specified configuration
 * @param desc - Frame buffer descriptor containing width, height, texture formats, and other options
 * @returns A configured FrameBuffer instance with color and optional depth attachments
 */
declare function createFrameBuffer(desc: FrameBufferDescriptor): FrameBuffer;
/**
 * Descriptor for creating a multi-sample anti-aliasing (MSAA) frame buffer
 */
interface FrameBufferMSAADescriptor {
    /** Width of the frame buffer in pixels */
    width: number;
    /** Height of the frame buffer in pixels */
    height: number;
    /** Number of color buffer attachments */
    colorBufferNum: number;
    /** Array of color buffer formats */
    colorFormats: TextureFormatEnum[];
    /** Number of samples for MSAA */
    sampleCountMSAA: number;
    /** Format for the depth buffer */
    depthBufferFormat: TextureFormatEnum;
}
/**
 * Creates a frame buffer with multi-sample anti-aliasing (MSAA) support
 * @param desc - MSAA frame buffer descriptor containing dimensions, sample count, and buffer formats
 * @returns A configured FrameBuffer instance with MSAA render buffers
 */
declare function createFrameBufferMSAA(desc: FrameBufferMSAADescriptor): FrameBuffer;
/**
 * Descriptor for creating a frame buffer with 2D texture array attachment
 */
interface FrameBufferTextureArrayDescriptor {
    /** Width of the frame buffer in pixels */
    width: number;
    /** Height of the frame buffer in pixels */
    height: number;
    /** Number of array layers in the texture */
    arrayLength: number;
    /** Mip level to use */
    level: number;
    /** Internal format of the texture */
    internalFormat: TextureFormatEnum;
    /** Pixel format of the texture */
    format: PixelFormatEnum;
    /** Component type of the texture data */
    type: ComponentTypeEnum;
}
/**
 * Creates a frame buffer with a 2D texture array attachment
 * @param desc - Texture array frame buffer descriptor
 * @returns A tuple containing the FrameBuffer and RenderTargetTexture2DArray
 */
declare function createFrameBufferTextureArray(desc: FrameBufferTextureArrayDescriptor): [FrameBuffer, RenderTargetTexture2DArray];
/**
 * Descriptor for creating a frame buffer with texture array for multi-view rendering
 */
interface FrameBufferTextureArrayForMultiViewDescriptor {
    /** Width of the frame buffer in pixels */
    width: number;
    /** Height of the frame buffer in pixels */
    height: number;
    /** Number of array layers for multi-view rendering */
    arrayLength: number;
    /** Mip level to use */
    level: number;
    /** Internal format of the color texture */
    internalFormat: TextureFormatEnum;
    /** Pixel format of the color texture */
    format: PixelFormatEnum;
    /** Component type of the texture data */
    type: ComponentTypeEnum;
}
/**
 * Creates a frame buffer with texture arrays for multi-view rendering (e.g., VR/AR stereo rendering)
 * @param desc - Multi-view frame buffer descriptor
 * @returns A configured FrameBuffer with color and depth-stencil texture arrays
 */
declare function createFrameBufferTextureArrayForMultiView(desc: FrameBufferTextureArrayForMultiViewDescriptor): FrameBuffer;
/**
 * Descriptor for creating a cube map frame buffer
 */
interface FrameBufferCubeMapDescriptor {
    /** Width of each cube face in pixels */
    width: number;
    /** Height of each cube face in pixels */
    height: number;
    /** Texture format for the cube map */
    textureFormat: TextureFormatEnum;
    /** Number of mip levels to generate (optional) */
    mipLevelCount?: number;
}
/**
 * Creates a frame buffer with a cube map texture attachment for environment mapping or shadow mapping
 * @param desc - Cube map frame buffer descriptor
 * @returns A tuple containing the FrameBuffer and RenderTargetTextureCube
 */
declare function createFrameBufferCubeMap(desc: FrameBufferCubeMapDescriptor): [FrameBuffer, RenderTargetTextureCube];
/**
 * Creates a depth-only frame buffer for depth testing or shadow mapping
 * @param width - Width of the depth buffer in pixels
 * @param height - Height of the depth buffer in pixels
 * @param options - Configuration options for the depth buffer
 * @param options.level - Mip level to use (default: 0)
 * @param options.internalFormat - Internal format for the depth texture (default: Depth32F)
 * @returns A FrameBuffer configured with only a depth attachment
 */
declare function createDepthBuffer(width: number, height: number, { _level, internalFormat }: {
    _level?: number | undefined;
    internalFormat?: TextureFormatEnum | undefined;
}): FrameBuffer;
/**
 * Utility helper for creating various types of frame buffers and render targets
 */
declare const RenderableHelper: Readonly<{
    createFrameBuffer: typeof createFrameBuffer;
    createFrameBufferMSAA: typeof createFrameBufferMSAA;
    createFrameBufferTextureArray: typeof createFrameBufferTextureArray;
    createFrameBufferTextureArrayForMultiView: typeof createFrameBufferTextureArrayForMultiView;
    createFrameBufferCubeMap: typeof createFrameBufferCubeMap;
    createDepthBuffer: typeof createDepthBuffer;
}>;

/**
 * Creates a RenderPass optimized for full-screen rendering without depth testing.
 * This render pass is configured to skip color and depth buffer clearing,
 * disable depth testing, and use buffer-less full-screen rendering for optimal performance.
 *
 * @param material - The material to be used for rendering. Should contain appropriate shaders for screen-space operations.
 * @returns A configured RenderPass instance ready for full-screen rendering operations.
 *
 * @example
 * ```typescript
 * const material = new Material();
 * const renderPass = RenderPassHelper.createScreenDrawRenderPass(material);
 * ```
 */
declare function createScreenDrawRenderPass(material: Material): RenderPass;
/**
 * Creates a RenderPass for full-screen rendering with a base color texture.
 * This method automatically sets up texture sampling with linear filtering and clamp-to-edge wrapping.
 * A default sampler is created and cached for reuse if no custom sampler is provided.
 *
 * @param material - The material to be used for rendering. The base color texture will be bound to this material.
 * @param texture - The texture to be used as the base color texture for rendering.
 * @param sampler - Optional custom sampler for texture sampling. If not provided, a default linear sampler with clamp-to-edge wrapping will be used.
 * @returns A configured RenderPass instance with the texture properly bound to the material.
 *
 * @example
 * ```typescript
 * const material = new Material();
 * const texture = new Texture2D();
 * const renderPass = RenderPassHelper.createScreenDrawRenderPassWithBaseColorTexture(material, texture);
 *
 * // With custom sampler
 * const customSampler = new Sampler({ magFilter: TextureParameter.Nearest });
 * const renderPassWithCustomSampler = RenderPassHelper.createScreenDrawRenderPassWithBaseColorTexture(
 *   material,
 *   texture,
 *   customSampler
 * );
 * ```
 */
declare function createScreenDrawRenderPassWithBaseColorTexture(material: Material, texture: AbstractTexture, sampler?: Sampler): RenderPass;
/**
 * A collection of utility functions for creating and configuring RenderPass instances.
 * This helper provides convenient methods for common rendering scenarios, particularly
 * full-screen post-processing effects and screen-space operations.
 *
 * @namespace RenderPassHelper
 */
declare const RenderPassHelper: Readonly<{
    createScreenDrawRenderPass: typeof createScreenDrawRenderPass;
    createScreenDrawRenderPassWithBaseColorTexture: typeof createScreenDrawRenderPassWithBaseColorTexture;
}>;

/**
 * A shadow mapping utility class that handles the creation and management of shadow maps
 * using moment-based shadow mapping techniques. This class provides functionality to
 * generate shadow moment data by rendering scene entities from a light source perspective
 * and storing the depth information in a specialized framebuffer for later shadow calculations.
 *
 * The shadow map uses RG16F texture format to store depth moments, which allows for
 * better shadow quality and soft shadow effects compared to traditional shadow mapping.
 */
declare class ShadowMap {
    private __shadowMomentFramebuffer;
    private __shadowMomentMaterial;
    /**
     * Creates a new ShadowMap instance with initialized framebuffer and material for shadow mapping.
     * Sets up a 1024x1024 framebuffer with RG16F texture format for storing shadow moments
     * and creates a depth moment encode material for rendering shadows.
     */
    constructor();
    /**
     * Creates and returns render passes for shadow mapping from the perspective of a light source.
     * The render pass renders the provided entities using the light entity's camera view
     * to generate shadow moment data stored in the shadow framebuffer.
     *
     * @param entities - Array of scene graph entities to be rendered for shadow generation
     * @param lightEntity - Light entity that implements both light and camera functionality
     *                      used as the shadow map camera viewpoint
     * @returns Array containing a single render pass configured for shadow moment rendering
     */
    getRenderPasses(entities: ISceneGraphEntity[], lightEntity: ISceneGraphEntity & ILightEntityMethods & ICameraEntityMethods): RenderPass[];
    /**
     * Returns the framebuffer containing the rendered shadow moment data.
     * This framebuffer stores the depth moments in RG16F format and can be used
     * for shadow calculations in subsequent rendering passes.
     *
     * @returns The shadow moment framebuffer containing depth moment texture data
     */
    getShadowMomentFramebuffer(): FrameBuffer;
}

/**
 * A helper class for managing point light shadow mapping using paraboloid depth moment encoding.
 * This class handles the creation and management of shadow map framebuffers and materials
 * for omnidirectional shadow mapping from point lights.
 */
declare class PointShadowMap {
    private __shadowMomentFramebuffer;
    private __shadowMomentFrontMaterials;
    private __shadowMomentBackMaterials;
    /**
     * Creates a new PointShadowMap instance.
     * Initializes the shadow moment framebuffer and creates materials for front and back hemisphere rendering.
     * The framebuffer uses RGBA16F format for storing depth moments and a 32-bit depth buffer.
     */
    constructor();
    /**
     * Generates render passes for creating shadow maps from a point light source.
     * Creates two render passes: one for the front hemisphere and one for the back hemisphere
     * of the paraboloid shadow mapping technique.
     *
     * @param entities - Array of scene graph entities to be rendered for shadow map generation
     * @param lightEntity - The point light entity that casts shadows
     * @returns An array containing two render passes: [frontRenderPass, backRenderPass]
     */
    getRenderPasses(entities: ISceneGraphEntity[], lightEntity: ISceneGraphEntity & ILightEntityMethods): RenderPass[];
    /**
     * Gets the framebuffer used for storing shadow moment data.
     * This framebuffer contains the encoded depth moments for variance shadow mapping.
     *
     * @returns The shadow moment framebuffer containing RGBA16F texture for depth moments
     */
    getShadowMomentFramebuffer(): FrameBuffer;
}

/**
 * A system for managing shadow mapping operations in the rendering pipeline.
 * Handles both directional/spot light shadows and point light shadows with Gaussian blur post-processing.
 */
declare class ShadowSystem {
    private __shadowMap;
    private __pointShadowMap;
    private __gaussianBlur;
    private __shadowMapArrayFramebuffer;
    private __pointShadowMapArrayFramebuffer;
    private __lightTypes;
    private __lightEnables;
    private __lightCastShadows;
    /**
     * Creates a new ShadowSystem instance with the specified shadow map resolution.
     * Initializes shadow map and point shadow map systems, along with framebuffers for texture arrays.
     * @param shadowMapSize - The resolution (width and height) of shadow maps in pixels
     */
    constructor(shadowMapSize: number);
    /**
     * Generates rendering expressions for shadow mapping based on the provided entities and active lights.
     * Creates shadow map render passes for each shadow-casting light and applies Gaussian blur post-processing.
     * @param entities - Array of scene graph entities to be rendered for shadow mapping
     * @returns Array of Expression objects containing the shadow mapping render passes
     */
    getExpressions(entities: ISceneGraphEntity[]): Expression[];
    /**
     * Sets the blurred shadow map texture for directional and spot lights on all entity materials.
     * Creates a linear sampler and assigns the shadow map texture to the 'depthTexture' parameter.
     * @param blurredRenderTarget - The blurred shadow map render target texture
     * @param entities - Array of scene graph entities to apply the shadow map to
     * @private
     */
    private __setBlurredShadowMap;
    /**
     * Sets the blurred paraboloid shadow map texture for point lights on all entity materials.
     * Creates a linear sampler and assigns the shadow map texture to the 'paraboloidDepthTexture' parameter.
     * Also sets the UV scale parameter for point light shadow mapping.
     * @param blurredRenderTarget - The blurred paraboloid shadow map render target texture
     * @param entities - Array of scene graph entities to apply the shadow map to
     * @private
     */
    private __setParaboloidBlurredShadowMap;
    /**
     * Sets the depth texture index list parameter on all entity materials.
     * This parameter maps each light to its corresponding shadow map texture index.
     * @param entities - Array of scene graph entities to apply the index list to
     * @param depthTextureIndexList - Array of indices mapping lights to shadow map textures (-1 for no shadow)
     * @private
     */
    private __setDepthTextureIndexList;
    /**
     * Sets the depth bias projection-view matrices for shadow mapping on all PBR materials.
     * Calculates and applies bias matrices for directional and spot lights to reduce shadow acne.
     * @param entities - Array of scene graph entities to apply the bias matrices to
     */
    setDepthBiasPV(entities: ISceneGraphEntity[]): void;
    /**
     * Checks if the light configuration has changed since the last update.
     * Compares the current light types, enable states, and shadow casting states with cached values.
     * @returns True if any light has changed its type, enable state, or shadow casting state; false otherwise
     */
    isLightChanged(): boolean;
}

/**
 * Asset loader configuration interface
 */
interface AssetLoaderConfig {
    /** Limit on the number of concurrent loads */
    maxConcurrentLoads?: number;
    /** Timeout duration (in milliseconds). Set to 0 or negative value to disable timeout */
    timeout?: number;
}
/**
 * Helper type to infer the result object type from the promise object type
 */
type AwaitedObject<T> = {
    [K in keyof T]: T[K] extends Promise<infer U> ? U : T[K];
};
/**
 * Type-safe asset loader class
 *
 * @example
 * ```typescript
 * // Default configuration with 60 second timeout
 * const assetLoader = new AssetLoader();
 *
 * // Configuration with custom settings
 * const customLoader = new AssetLoader({
 *   maxConcurrentLoads: 5,
 *   timeout: 30000 // 30 seconds
 * });
 *
 * // Disable timeout (wait indefinitely)
 * const noTimeoutLoader = new AssetLoader({
 *   timeout: 0 // or any negative value
 * });
 *
 * // Load promises in object format
 * const assets = await assetLoader.load({
 *   environment: Rn.CubeTexture.fromUrl({
 *     baseUrl: '/path/to/environment',
 *     mipmapLevelNumber: 1,
 *     isNamePosNeg: true,
 *     hdriFormat: Rn.HdriFormat.HDR_LINEAR,
 *   }),
 *   specular: Rn.CubeTexture.fromUrl({
 *     baseUrl: '/path/to/specular',
 *     mipmapLevelNumber: 10,
 *     isNamePosNeg: true,
 *     hdriFormat: Rn.HdriFormat.RGBE_PNG,
 *   }),
 *   diffuse: Rn.CubeTexture.fromUrl({
 *     baseUrl: '/path/to/diffuse',
 *     mipmapLevelNumber: 1,
 *     isNamePosNeg: true,
 *     hdriFormat: Rn.HdriFormat.RGBE_PNG,
 *   })
 * });
 *
 * console.log(assets.environment); // CubeTexture
 * console.log(assets.specular); // CubeTexture
 * console.log(assets.diffuse); // CubeTexture
 * ```
 */
declare class AssetLoader {
    private config;
    private loadingQueue;
    private activeLoads;
    /**
     * Creates a new AssetLoader instance with the specified configuration.
     *
     * @param config - Configuration options for the asset loader
     * @param config.maxConcurrentLoads - Maximum number of concurrent loads (default: 3)
     * @param config.timeout - Timeout duration in milliseconds (default: 60000). Set to 0 or negative to disable
     *
     * @example
     * ```typescript
     * // Default configuration
     * const loader = new AssetLoader();
     *
     * // Custom configuration
     * const customLoader = new AssetLoader({
     *   maxConcurrentLoads: 5,
     *   timeout: 30000
     * });
     * ```
     */
    constructor(config?: AssetLoaderConfig);
    /**
     * Loads multiple promises organized as an object with named keys.
     * The result preserves the same structure with resolved values.
     *
     * @template T - Object type where values are promises
     * @param promiseObject - Object containing promises to be loaded
     * @returns Promise that resolves to an object with the same keys but resolved values
     *
     * @example
     * ```typescript
     * const assets = await loader.load({
     *   texture: loadTexture('path/to/texture.jpg'),
     *   model: loadModel('path/to/model.gltf'),
     *   audio: loadAudio('path/to/sound.mp3')
     * });
     *
     * // Type-safe access to resolved values
     * console.log(assets.texture); // Texture
     * console.log(assets.model);   // Model
     * console.log(assets.audio);   // AudioBuffer
     * ```
     */
    load<T extends Record<string, Promise<any>>>(promiseObject: T): Promise<AwaitedObject<T>>;
    /**
     * Loads a single promise with queue management, timeout, and concurrency control.
     *
     * @template T - The type of value the promise resolves to
     * @param promise - The promise to be loaded
     * @returns Promise that resolves to the same value as the input promise
     *
     * @example
     * ```typescript
     * const texture = await loader.loadSingle(loadTexture('texture.jpg'));
     * const model = await loader.loadSingle(loadModel('model.gltf'));
     * ```
     */
    loadSingle<T>(promise: Promise<T>): Promise<T>;
    /**
     * Loads a single promise with automatic retry using fallback factories.
     * If the first promise fails, it will try the next factory in order.
     *
     * @template T - The type of value the promise resolves to
     * @param promiseFactories - Array of factory functions that create promises, ordered by priority
     * @returns Promise that resolves to the value from the first successful factory
     *
     * @throws {Error} When no promise factories are provided
     *
     * @example
     * ```typescript
     * const texture = await loader.loadWithRetrySingle([
     *   () => loadTexture('high-quality.jpg'),    // Try first
     *   () => loadTexture('medium-quality.jpg'),  // Fallback 1
     *   () => loadTexture('low-quality.jpg')      // Fallback 2
     * ]);
     * ```
     */
    loadWithRetrySingle<T>(promiseFactories: Array<() => Promise<T>>): Promise<T>;
    /**
     * Loads multiple promises in bulk as an array.
     * Supports both homogeneous arrays and heterogeneous tuples with type safety.
     *
     * @template T - The type of values in the array or tuple
     * @param promises - Array or tuple of promises to be loaded
     * @returns Promise that resolves to an array or tuple of resolved values with preserved types
     *
     * @example
     * ```typescript
     * // Homogeneous array
     * const textures = await loader.loadArray([
     *   loadTexture('texture1.jpg'),
     *   loadTexture('texture2.jpg'),
     *   loadTexture('texture3.jpg')
     * ]);
     *
     * // Heterogeneous tuple with type safety
     * const [texture, model, audio] = await loader.loadArray([
     *   loadTexture('texture.jpg'),
     *   loadModel('model.gltf'),
     *   loadAudio('sound.mp3')
     * ] as const);
     * ```
     */
    loadArray<T>(promises: Promise<T>[]): Promise<T[]>;
    loadArray<T extends readonly unknown[]>(promises: readonly [...{
        [K in keyof T]: Promise<T[K]>;
    }]): Promise<T>;
    /**
     * Loads multiple promises with retry capabilities for each one.
     * Each promise has its own set of factory functions for retry attempts.
     *
     * @template T - The type of values the promises resolve to
     * @param promiseFactories - Array where each element is an array of factory functions for one promise
     * @returns Promise that resolves to an array of resolved values
     *
     * @example
     * ```typescript
     * const assets = await loader.loadWithRetryArray([
     *   [
     *     () => loadTexture('high-res.jpg'),
     *     () => loadTexture('low-res.jpg')
     *   ],
     *   [
     *     () => loadModel('detailed.gltf'),
     *     () => loadModel('simple.gltf')
     *   ]
     * ]);
     * ```
     */
    loadWithRetryArray<T>(promiseFactories: Array<Array<() => Promise<T>>>): Promise<T[]>;
    /**
     * Loads multiple promises with retry capabilities organized as an object.
     * Combines the structure of `load()` with the retry functionality of `loadWithRetryArray()`.
     *
     * @template T - Object type where values are promises
     * @param promiseFactories - Object where each value is an array of factory functions
     * @returns Promise that resolves to an object with the same keys but resolved values
     *
     * @example
     * ```typescript
     * const assets = await loader.loadWithRetry({
     *   texture: [
     *     () => loadTexture('high-res.jpg'),
     *     () => loadTexture('low-res.jpg')
     *   ],
     *   model: [
     *     () => loadModel('detailed.gltf'),
     *     () => loadModel('simple.gltf')
     *   ]
     * });
     *
     * console.log(assets.texture); // Texture (from successful factory)
     * console.log(assets.model);   // Model (from successful factory)
     * ```
     */
    loadWithRetry<T extends Record<string, Promise<any>>>(promiseFactories: {
        [K in keyof T]: Array<() => T[K]>;
    }): Promise<AwaitedObject<T>>;
    /**
     * Internal method to load a single promise with multiple retry factories.
     * Handles the retry logic when the initial promise fails.
     *
     * @private
     * @template T - The type of value the promise resolves to
     * @param initialPromise - The first promise to attempt
     * @param retryFactories - Array of factory functions to use for retries
     * @returns Promise that resolves to the value from the first successful attempt
     */
    private loadSingleWithMultipleRetries;
    /**
     * Internal method to process the loading queue.
     * Manages concurrency limits and handles retry logic for failed loads.
     *
     * @private
     * @returns Promise that resolves when queue processing is complete
     */
    private processQueue;
    /**
     * Internal method to execute the actual loading process with timeout handling.
     * Races the promise against a timeout if configured.
     *
     * @private
     * @template T - The type of value the promise resolves to
     * @param request - The load request to execute
     * @returns Promise that resolves to the loaded value
     *
     * @throws {Error} When the load times out (if timeout is configured)
     */
    private executeLoad;
    /**
     * Gets the current loading status including active and queued loads.
     * Useful for monitoring loading progress and debugging.
     *
     * @returns Object containing the number of active and queued loads
     *
     * @example
     * ```typescript
     * const status = loader.getLoadingStatus();
     * console.log(`Active: ${status.active}, Queued: ${status.queued}`);
     * ```
     */
    getLoadingStatus(): {
        active: number;
        queued: number;
    };
    /**
     * Waits until all currently active and queued loads are complete.
     * Useful for ensuring all assets are loaded before proceeding.
     *
     * @returns Promise that resolves when all loads are complete
     *
     * @example
     * ```typescript
     * // Start multiple loads
     * loader.loadSingle(loadTexture('texture.jpg'));
     * loader.loadSingle(loadModel('model.gltf'));
     *
     * // Wait for all to complete
     * await loader.waitForAllLoads();
     * console.log('All assets loaded!');
     * ```
     */
    waitForAllLoads(): Promise<void>;
}
/**
 * Default asset loader instance with standard configuration.
 * Provides a convenient singleton for most use cases.
 *
 * @example
 * ```typescript
 * import { defaultAssetLoader } from './AssetLoader';
 *
 * const assets = await defaultAssetLoader.load({
 *   texture: loadTexture('texture.jpg'),
 *   model: loadModel('model.gltf')
 * });
 * ```
 */
declare const defaultAssetLoader: AssetLoader;

/**
 * TransformComponent is a component that manages the transform of an entity.
 * It handles position, rotation, scale, and transformation matrices for 3D objects.
 * This component provides both current transform state and rest pose functionality.
 */
declare class TransformComponent extends Component {
    private __rest;
    private __pose;
    private __updateCountAtLastLogic;
    private static __updateCount;
    /**
     * Gets the number of rendered properties for this component type.
     * @returns null as this component doesn't have rendered properties
     */
    static get renderedPropertyCount(): null;
    /**
     * Gets the component type identifier for TransformComponent.
     * @returns The transform component type ID
     */
    static get componentTID(): ComponentTID;
    /**
     * Gets the component type identifier for this instance.
     * @returns The transform component type ID
     */
    get componentTID(): ComponentTID;
    /**
     * Gets the rest transform if available, otherwise returns the current pose.
     * @returns The rest transform or current pose
     */
    get restOrPose(): Transform3D;
    /**
     * Gets the global update counter for all transform components.
     * @returns The current update count
     */
    static get updateCount(): number;
    /**
     * Backs up the current transform as the rest pose.
     * Creates a rest pose snapshot and marks the scene graph world matrix as dirty.
     * @internal
     */
    _backupTransformAsRest(): void;
    /**
     * Restores the transform from the previously backed up rest pose.
     * @internal
     */
    _restoreTransformFromRest(): void;
    /**
     * Gets the local transform of this entity.
     * @returns The current local transform
     */
    get localTransform(): Transform3D;
    /**
     * Sets the local transform of this entity.
     * @param transform - The new transform to apply
     */
    set localTransform(transform: Transform3D);
    /**
     * Gets the local transform rest pose.
     * @returns The rest pose or current pose if no rest pose is set
     */
    get localTransformRest(): Transform3D;
    /**
     * Sets the local transform rest pose.
     * @param transform - The transform to set as rest pose
     */
    set localTransformRest(transform: Transform3D);
    /**
     * Sets the local position of this entity and updates physics if applicable.
     * @param vec - The new position vector
     */
    set localPosition(vec: IVector3);
    /**
     * Sets the local position without updating physics simulation.
     * @param vec - The new position vector
     */
    set localPositionWithoutPhysics(vec: IVector3);
    /**
     * Sets the local position using a 3-element array.
     * @param array - Array containing [x, y, z] position values
     */
    setLocalPositionAsArray3(array: Array3<number>): void;
    /**
     * Gets a copy of the local position vector.
     * @returns A copy of the local position
     */
    get localPosition(): IVector3;
    /**
     * Gets the internal mutable local position vector.
     * @returns The internal mutable position vector
     */
    get localPositionInner(): MutableVector3;
    /**
     * Sets the local position as rest pose.
     * @param vec - The position vector to set as rest
     */
    set localPositionRest(vec: IVector3);
    /**
     * Gets a copy of the local position rest vector.
     * @returns A copy of the rest position
     */
    get localPositionRest(): IVector3;
    /**
     * Gets the internal mutable local position rest vector.
     * @returns The internal mutable rest position vector
     */
    get localPositionRestInner(): MutableVector3;
    /**
     * Sets the local rotation using Euler angles and updates physics if applicable.
     * @param vec - The Euler angles vector (XYZ order)
     */
    set localEulerAngles(vec: IVector3);
    /**
     * Sets the local Euler angles without updating physics simulation.
     * @param vec - The Euler angles vector (XYZ order)
     */
    set localEulerAnglesWithoutPhysics(vec: IVector3);
    /**
     * Gets a copy of the local Euler angles vector.
     * @returns A copy of the local rotation as Euler angles (XYZ order)
     */
    get localEulerAngles(): IVector3;
    /**
     * Gets the internal mutable local Euler angles vector.
     * @returns The internal mutable Euler angles vector
     */
    get localEulerAnglesInner(): Vector3;
    /**
     * Sets the local Euler angles as rest pose.
     * @param vec - The Euler angles vector to set as rest (XYZ order)
     */
    set localEulerAnglesRest(vec: IVector3);
    /**
     * Gets a copy of the local Euler angles rest vector.
     * @returns A copy of the rest rotation as Euler angles (XYZ order)
     */
    get localEulerAnglesRest(): IVector3;
    /**
     * Gets the internal mutable local Euler angles rest vector.
     * @returns The internal mutable rest Euler angles vector
     */
    get localEulerAnglesRestInner(): Vector3;
    /**
     * Sets the local scale and updates physics if applicable.
     * @param vec - The new scale vector
     */
    set localScale(vec: IVector3);
    /**
     * Sets the local scale without updating physics simulation.
     * @param vec - The new scale vector
     */
    set localScaleWithoutPhysics(vec: IVector3);
    /**
     * Sets the local scale using a 3-element array.
     * @param array - Array containing [x, y, z] scale values
     */
    setLocalScaleAsArray3(array: Array3<number>): void;
    /**
     * Gets a copy of the local scale vector.
     * @returns A copy of the local scale
     */
    get localScale(): IVector3;
    /**
     * Gets the internal mutable local scale vector.
     * @returns The internal mutable scale vector
     */
    get localScaleInner(): MutableVector3;
    /**
     * Sets the local scale as rest pose.
     * @param vec - The scale vector to set as rest
     */
    set localScaleRest(vec: IVector3);
    /**
     * Gets a copy of the local scale rest vector.
     * @returns A copy of the rest scale
     */
    get localScaleRest(): IVector3;
    /**
     * Gets the internal mutable local scale rest vector.
     * @returns The internal mutable rest scale vector
     */
    get localScaleRestInner(): MutableVector3;
    /**
     * Sets the local rotation using a quaternion and updates physics if applicable.
     * @param quat - The new rotation quaternion
     */
    set localRotation(quat: IQuaternion);
    /**
     * Sets the local rotation without updating physics simulation.
     * @param quat - The new rotation quaternion
     */
    set localRotationWithoutPhysics(quat: IQuaternion);
    /**
     * Sets the local rotation using a 4-element array.
     * @param array - Array containing [x, y, z, w] quaternion values
     */
    setLocalRotationAsArray4(array: Array4<number>): void;
    /**
     * Gets a copy of the local rotation quaternion.
     * @returns A copy of the local rotation quaternion
     */
    get localRotation(): IQuaternion;
    /**
     * Gets the internal local rotation quaternion.
     * @returns The internal rotation quaternion
     */
    get localRotationInner(): Quaternion;
    /**
     * Sets the local rotation as rest pose.
     * @param quat - The rotation quaternion to set as rest
     */
    set localRotationRest(quat: IQuaternion);
    /**
     * Gets a copy of the local rotation rest quaternion.
     * @returns A copy of the rest rotation quaternion
     */
    get localRotationRest(): IQuaternion;
    /**
     * Gets the internal local rotation rest quaternion.
     * @returns The internal rest rotation quaternion
     */
    get localRotationRestInner(): Quaternion;
    /**
     * Sets the local transformation matrix.
     * @param mat - The new transformation matrix
     */
    set localMatrix(mat: IMatrix44);
    /**
     * Gets a copy of the local transformation matrix.
     * @returns A copy of the local transform matrix
     */
    get localMatrix(): IMatrix44;
    /**
     * Gets the internal local transformation matrix.
     * @returns The internal local transform matrix
     */
    get localMatrixInner(): MutableMatrix44;
    /**
     * Copies the local transformation matrix to the provided matrix object.
     * @param mat - The target matrix to copy the local matrix into
     */
    getLocalMatrixInnerTo(mat: MutableMatrix44): void;
    /**
     * Sets the local transformation matrix as rest pose.
     * @param mat - The transformation matrix to set as rest
     */
    set localMatrixRest(mat: IMatrix44);
    /**
     * Gets a copy of the local transformation matrix rest pose.
     * @returns A copy of the rest transform matrix
     */
    get localMatrixRest(): IMatrix44;
    /**
     * Gets the internal local transformation matrix rest pose.
     * @returns The internal rest transform matrix
     */
    get localMatrixRestInner(): MutableMatrix44;
    /**
     * Loads the component and moves it to the Logic processing stage.
     * @internal
     */
    $load(): void;
    /**
     * Executes logic processing for the component.
     * Checks if the transform has been updated and marks the world matrix as dirty if needed.
     * @internal
     */
    $logic(): void;
    /**
     * Performs a shallow copy from another TransformComponent.
     * @param component_ - The source component to copy from
     * @internal
     */
    _shallowCopyFrom(component_: Component): void;
    /**
     * Gets the entity that owns this component.
     * @returns The entity which has this component
     */
    get entity(): ITransformEntity;
    /**
     * Destroys the component and cleans up resources.
     * @internal
     */
    _destroy(): void;
    /**
     * Adds this component to the specified entity by creating a mixin class.
     * This method extends the entity class with transform-related methods and properties.
     * @param base - The target entity to extend
     * @param _componentClass - The component class to add (not used but required for interface)
     * @returns The extended entity with transform capabilities
     * @template EntityBase - The base entity type
     * @template SomeComponentClass - The component class type
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBase, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBase;
}

interface ITransformEntityMethods {
    getTransform(): TransformComponent;
    localPosition: IVector3;
    localScale: IVector3;
    localEulerAngles: IVector3;
    localRotation: IQuaternion;
    localMatrix: IMatrix44;
    localPositionInner: IVector3;
    localScaleInner: IVector3;
    localEulerAnglesInner: IVector3;
    localRotationInner: IQuaternion;
    localMatrixInner: IMatrix44;
    localPositionRest: IVector3;
    localScaleRest: IVector3;
    localEulerAnglesRest: IVector3;
    localRotationRest: IQuaternion;
    localMatrixRest: IMatrix44;
    localPositionRestInner: IVector3;
    localScaleRestInner: IVector3;
    localEulerAnglesRestInner: IVector3;
    localRotationRestInner: IQuaternion;
    localMatrixRestInner: IMatrix44;
}

type VrmExpressionName = string;
type VrmExpressionMorphBind = {
    entityIdx: Index;
    blendShapeIdx: Index;
    weight: number;
};
type VrmExpression = {
    name: VrmExpressionName;
    isBinary: boolean;
    binds: VrmExpressionMorphBind[];
};
/**
 * VrmComponent is a component that manages VRM model expressions and their associated blend shapes.
 * This component handles the mapping between VRM expressions and the underlying blend shape components,
 * allowing for facial expressions and other morphing effects in VRM models.
 */
declare class VrmComponent extends Component {
    private __expressions;
    private __weights;
    private __blendShapeComponent?;
    _version: string;
    /**
     * Creates a new VrmComponent instance.
     * @param entityUid - Unique identifier for the entity this component belongs to
     * @param componentSid - Unique identifier for this component instance
     * @param entityComponent - The entity repository managing this component
     * @param isReUse - Whether this component is being reused from a pool
     */
    constructor(entityUid: EntityUID, componentSid: ComponentSID, entityComponent: EntityRepository, isReUse: boolean);
    /**
     * Gets the component type identifier for VrmComponent.
     * @returns The component type ID for VrmComponent
     */
    static get componentTID(): ComponentTID;
    /**
     * Gets the component type identifier for this VrmComponent instance.
     * @returns The component type ID for VrmComponent
     */
    get componentTID(): ComponentTID;
    /**
     * Sets the VRM expressions for this component.
     * This method initializes the expressions map and sets initial weights to 0.
     * @param expressions - Array of VRM expressions to register
     */
    setVrmExpressions(expressions: VrmExpression[]): void;
    /**
     * Sets the weight for a specific VRM expression.
     * This method updates the expression weight and applies it to all associated blend shape binds.
     * @param expressionName - The name of the expression to modify
     * @param weight - The weight value to apply (typically between 0 and 1)
     */
    setExpressionWeight(expressionName: VrmExpressionName, weight: number): void;
    /**
     * Gets the current weight of a specific VRM expression.
     * @param expressionName - The name of the expression to query
     * @returns The current weight of the expression, or undefined if the expression doesn't exist
     */
    getExpressionWeight(expressionName: VrmExpressionName): number | undefined;
    /**
     * Gets all available expression names registered in this component.
     * @returns An array of all expression names
     */
    getExpressionNames(): string[];
    /**
     * Creates a shallow copy of this component from another VrmComponent.
     * This method copies the expressions, weights, and version information.
     * @param component - The source component to copy from
     * @protected
     */
    _shallowCopyFrom(component: Component): void;
    /**
     * Destroys this component and cleans up resources.
     * @protected
     */
    _destroy(): void;
    /**
     * Adds this VrmComponent to an entity by extending the entity with VRM-specific methods.
     * This method uses mixins to add a getVrm() method to the target entity.
     * @param base - The target entity to extend
     * @param _componentClass - The component class being added
     * @returns The extended entity with VRM functionality
     * @template EntityBase - The base entity type
     * @template SomeComponentClass - The component class type
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBase, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBase;
}

interface IVrmEntityMethods {
    getVrm(): VrmComponent;
}

type ComponentMixinFunction = <EntityBaseClass extends MixinBase>(baseClass: EntityBaseClass, components: (typeof Component)[]) => {
    entityClass: MixinBase;
    components: (typeof Component)[];
};
type AllWellKnownComponentMethodsTypes = IAnimationStateEntityMethods | IAnimationEntityMethods | ITransformEntityMethods | ISceneGraphEntityMethods | IMeshEntityMethods | IMeshRendererEntityMethods | ILightEntityMethods | ICameraEntityMethods | ICameraControllerEntityMethods | ISkeletalEntityMethods | IBlendShapeEntityMethods | IPhysicsEntityMethods | IEffekseerEntityMethods | IVrmEntityMethods;
type IsThisAnimationState<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof AnimationStateComponent ? IAnimationStateEntityMethods : Exclude<Possibles, IAnimationStateEntityMethods>;
type IsThisAnimation<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof AnimationComponent ? IAnimationEntityMethods : Exclude<Possibles, IAnimationEntityMethods>;
type IsThisTransform<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof TransformComponent ? ITransformEntityMethods : Exclude<Possibles, ITransformEntityMethods>;
type IsThisSceneGraph<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof SceneGraphComponent ? ISceneGraphEntityMethods : Exclude<Possibles, ISceneGraphEntityMethods>;
type IsThisMesh<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof MeshComponent ? IMeshEntityMethods : Exclude<Possibles, IMeshEntityMethods>;
type IsThisMeshRenderer<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof MeshRendererComponent ? IMeshRendererEntityMethods : Exclude<Possibles, IMeshRendererEntityMethods>;
type IsThisCameraController<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof CameraControllerComponent ? ICameraControllerEntityMethods : Exclude<Possibles, ICameraControllerEntityMethods>;
type IsThisCamera<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof CameraComponent ? ICameraEntityMethods : Exclude<Possibles, ICameraEntityMethods>;
type IsThisLight<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof LightComponent ? ILightEntityMethods : Exclude<Possibles, ILightEntityMethods>;
type IsThisSkeletal<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof SkeletalComponent ? ISkeletalEntityMethods : Exclude<Possibles, ISkeletalEntityMethods>;
type IsThisBlendShape<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof BlendShapeComponent ? IBlendShapeEntityMethods : Exclude<Possibles, IBlendShapeEntityMethods>;
type IsThisPhysics<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof PhysicsComponent ? IPhysicsEntityMethods : Exclude<Possibles, IPhysicsEntityMethods>;
type IsThisEffekseer<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof EffekseerComponent ? IEffekseerEntityMethods : Exclude<Possibles, IEffekseerEntityMethods>;
type IsThisVrm<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof VrmComponent ? IVrmEntityMethods : Exclude<Possibles, IVrmEntityMethods>;
type IsThisConstraint<T extends typeof Component, Possibles extends AllWellKnownComponentMethodsTypes> = T extends typeof ConstraintComponent ? IConstraintEntityMethods : Exclude<Possibles, IConstraintEntityMethods>;
type ComponentToComponentMethods<T extends typeof Component> = IsThisConstraint<T, IsThisVrm<T, IsThisEffekseer<T, IsThisPhysics<T, IsThisBlendShape<T, IsThisSkeletal<T, IsThisLight<T, IsThisCamera<T, IsThisCameraController<T, IsThisMeshRenderer<T, IsThisMesh<T, IsThisSceneGraph<T, IsThisTransform<T, IsThisAnimation<T, IsThisAnimationState<T, AllWellKnownComponentMethodsTypes>>>>>>>>>>>>>>>;

declare class EffekseerComponent extends Component {
    static readonly ANIMATION_EVENT_PLAY = 0;
    static readonly ANIMATION_EVENT_PAUSE = 1;
    static readonly ANIMATION_EVENT_END = 2;
    static Unzip?: any;
    uri?: string;
    arrayBuffer?: ArrayBuffer;
    type: string;
    playJustAfterLoaded: boolean;
    isLoop: boolean;
    isPause: boolean;
    static wasmModuleUri: undefined;
    randomSeed: number;
    isImageLoadWithCredential: boolean;
    private __effect?;
    private __context?;
    private __handle?;
    private __speed;
    private __timer?;
    private __isInitialized;
    private static __tmp_identityMatrix_0;
    private static __tmp_identityMatrix_1;
    private isLoadEffect;
    static get componentTID(): ComponentTID;
    cancelLoop(): void;
    isPlay(): boolean;
    play(): boolean;
    continue(): void;
    pause(): void;
    stop(): void;
    set playSpeed(val: number);
    get playSpeed(): number;
    setTime(targetSec: Second): boolean;
    set translate(vec: IVector3);
    get translate(): IVector3;
    set rotate(vec: IVector3);
    get rotate(): IVector3;
    set scale(vec: IVector3);
    get scale(): IVector3;
    private __createEffekseerContext;
    $load(): void;
    $logic(): void;
    _destroy(): void;
    $render(): void;
    static sort_$render(renderPass: RenderPass): ComponentSID[];
    /**
     * @override
     * Add this component to the entity
     * @param base the target entity
     * @param _componentClass the component class to add
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBase, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBase;
}
interface IEffekseerEntityMethods {
    getEffekseer(): EffekseerComponent;
}

declare const Effekseer: Readonly<{
    EffekseerComponent: typeof EffekseerComponent;
    createEffekseerEntity: () => IEntity & ITransformEntityMethods & ISceneGraphEntityMethods & IEffekseerEntityMethods;
}>;

/**
 * The Interface for an Entity.
 */
interface IEntity extends IRnObject {
    entityUID: EntityUID;
    _isAlive: boolean;
    _myLatestCopyEntityUID: EntityUID;
    /**
     * Retrieves a component of the specified type from this entity.
     * @param componentType - The constructor/class of the component to retrieve
     * @returns The component instance if found, undefined otherwise
     */
    getComponent(componentType: typeof Component): Component | undefined;
    /**
     * Retrieves a component by its unique component type identifier.
     * @param componentTID - The component type identifier
     * @returns The component instance if found, undefined otherwise
     */
    getComponentByComponentTID(componentTID: ComponentTID): Component | undefined;
    /**
     * Sets a component on this entity.
     * @param componentType - The constructor/class of the component
     * @param com - The component instance to set
     * @internal
     */
    _setComponent(componentType: typeof Component, com: Component): void;
    /**
     * Checks whether this entity has a component of the specified type.
     * @param componentType - The constructor/class of the component to check
     * @returns True if the entity has the component, false otherwise
     */
    hasComponent(componentType: typeof Component): boolean;
    /**
     * Removes a component from this entity.
     * @param componentTID - The component type identifier to remove
     * @internal
     */
    _removeComponent(componentTID: ComponentTID): void;
    /**
     * Attempts to retrieve the BlendShapeComponent from this entity.
     * @returns The BlendShapeComponent if present, undefined otherwise
     */
    tryToGetBlendShape(): BlendShapeComponent | undefined;
    /**
     * Attempts to retrieve the CameraComponent from this entity.
     * @returns The CameraComponent if present, undefined otherwise
     */
    tryToGetCamera(): CameraComponent | undefined;
    /**
     * Attempts to retrieve the CameraControllerComponent from this entity.
     * @returns The CameraControllerComponent if present, undefined otherwise
     */
    tryToGetCameraController(): CameraControllerComponent | undefined;
    /**
     * Attempts to retrieve the LightComponent from this entity.
     * @returns The LightComponent if present, undefined otherwise
     */
    tryToGetLight(): LightComponent | undefined;
    /**
     * Attempts to retrieve the MeshComponent from this entity.
     * @returns The MeshComponent if present, undefined otherwise
     */
    tryToGetMesh(): MeshComponent | undefined;
    /**
     * Attempts to retrieve the MeshRendererComponent from this entity.
     * @returns The MeshRendererComponent if present, undefined otherwise
     */
    tryToGetMeshRenderer(): MeshRendererComponent | undefined;
    /**
     * Attempts to retrieve the PhysicsComponent from this entity.
     * @returns The PhysicsComponent if present, undefined otherwise
     */
    tryToGetPhysics(): PhysicsComponent | undefined;
    /**
     * Attempts to retrieve the SceneGraphComponent from this entity.
     * @returns The SceneGraphComponent if present, undefined otherwise
     */
    tryToGetSceneGraph(): SceneGraphComponent | undefined;
    /**
     * Attempts to retrieve the SkeletalComponent from this entity.
     * @returns The SkeletalComponent if present, undefined otherwise
     */
    tryToGetSkeletal(): SkeletalComponent | undefined;
    /**
     * Attempts to retrieve the TransformComponent from this entity.
     * @returns The TransformComponent if present, undefined otherwise
     */
    tryToGetTransform(): TransformComponent | undefined;
    /**
     * Attempts to retrieve the AnimationComponent from this entity.
     * @returns The AnimationComponent if present, undefined otherwise
     */
    tryToGetAnimation(): AnimationComponent | undefined;
    /**
     * Attempts to retrieve the AnimationStateComponent from this entity.
     * @returns The AnimationStateComponent if present, undefined otherwise
     */
    tryToGetAnimationState(): AnimationStateComponent | undefined;
    /**
     * Attempts to retrieve the VrmComponent from this entity.
     * @returns The VrmComponent if present, undefined otherwise
     */
    tryToGetVrm(): VrmComponent | undefined;
    /**
     * Attempts to retrieve the ConstraintComponent from this entity.
     * @returns The ConstraintComponent if present, undefined otherwise
     */
    tryToGetConstraint(): ConstraintComponent | undefined;
    /**
     * Attempts to retrieve the EffekseerComponent from this entity.
     * @returns The EffekseerComponent if present, undefined otherwise
     */
    tryToGetEffekseer(): EffekseerComponent | undefined;
    /**
     * Destroys this entity and releases all associated resources.
     * @internal
     */
    _destroy(): void;
}
/**
 * The class that represents an entity.
 *
 * @remarks
 * The Rhodonite Entity Class which are an entities that exists in space.
 * Entities can acquire various functions by having components on themselves.
 */
declare class Entity extends RnObject implements IEntity {
    /** The Unique ID of Entity */
    private readonly ___entity_uid;
    /** The Map of components. All components must be managed in this map */
    protected __components: Map<ComponentTID, Component>;
    /** Invalid Entity UID constant value */
    static readonly invalidEntityUID = -1;
    _myLatestCopyEntityUID: number;
    /** No use yet */
    _isAlive: boolean;
    /**
     * Creates a new Entity instance.
     *
     * @remarks
     * When creating an Entity, use the createEntity method of the EntityRepository class
     * instead of directly calling this constructor.
     *
     * @param entityUID - The unique identifier for this entity
     * @param isAlive - Whether this entity is alive or not
     * @param components - Optional map of existing components to initialize with
     */
    constructor(entityUID: EntityUID, isAlive: boolean, components?: Map<ComponentTID, Component>);
    /**
     * Gets the unique identifier of this entity.
     * @returns The entity's unique ID
     */
    get entityUID(): number;
    /**
     * Sets a component on this entity.
     *
     * @remarks
     * This method associates a component instance with this entity using the component's type ID.
     * If a component of the same type already exists, it will be replaced.
     *
     * @param componentType - The constructor/class of the component to set
     * @param component - The component instance to attach to this entity
     *
     * @internal
     */
    _setComponent(componentType: typeof Component, component: Component): void;
    /**
     * Checks whether this entity has a component of the specified type.
     *
     * @param componentType - The constructor/class of the component to check for
     * @returns True if the entity has a component of the specified type, false otherwise
     */
    hasComponent(componentType: typeof Component): boolean;
    /**
     * Retrieves a component of the specified type from this entity.
     *
     * @param componentType - The constructor/class of the component to retrieve
     * @returns The component instance if found, undefined if the entity doesn't have this component type
     */
    getComponent(componentType: typeof Component): Component | undefined;
    /**
     * Retrieves a component by its unique component type identifier.
     *
     * @param componentTID - The component type identifier to look up
     * @returns The component instance if found, undefined otherwise
     */
    getComponentByComponentTID(componentTID: ComponentTID): Component | undefined;
    /**
     * Removes a component from this entity by its component type identifier.
     *
     * @param componentTID - The component type identifier of the component to remove
     *
     * @internal
     */
    _removeComponent(componentTID: ComponentTID): void;
    /**
     * Attempts to retrieve the AnimationComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the AnimationComponent
     * without requiring explicit type casting.
     *
     * @returns The AnimationComponent if this entity has one, undefined otherwise
     */
    tryToGetAnimation(): AnimationComponent | undefined;
    /**
     * Attempts to retrieve the AnimationStateComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the AnimationStateComponent
     * without requiring explicit type casting.
     *
     * @returns The AnimationStateComponent if this entity has one, undefined otherwise
     */
    tryToGetAnimationState(): AnimationStateComponent | undefined;
    /**
     * Attempts to retrieve the BlendShapeComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the BlendShapeComponent
     * without requiring explicit type casting.
     *
     * @returns The BlendShapeComponent if this entity has one, undefined otherwise
     */
    tryToGetBlendShape(): BlendShapeComponent | undefined;
    /**
     * Attempts to retrieve the CameraComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the CameraComponent
     * without requiring explicit type casting.
     *
     * @returns The CameraComponent if this entity has one, undefined otherwise
     */
    tryToGetCamera(): CameraComponent | undefined;
    /**
     * Attempts to retrieve the CameraControllerComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the CameraControllerComponent
     * without requiring explicit type casting.
     *
     * @returns The CameraControllerComponent if this entity has one, undefined otherwise
     */
    tryToGetCameraController(): CameraControllerComponent | undefined;
    /**
     * Attempts to retrieve the LightComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the LightComponent
     * without requiring explicit type casting.
     *
     * @returns The LightComponent if this entity has one, undefined otherwise
     */
    tryToGetLight(): LightComponent | undefined;
    /**
     * Attempts to retrieve the MeshComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the MeshComponent
     * without requiring explicit type casting.
     *
     * @returns The MeshComponent if this entity has one, undefined otherwise
     */
    tryToGetMesh(): MeshComponent | undefined;
    /**
     * Attempts to retrieve the MeshRendererComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the MeshRendererComponent
     * without requiring explicit type casting.
     *
     * @returns The MeshRendererComponent if this entity has one, undefined otherwise
     */
    tryToGetMeshRenderer(): MeshRendererComponent | undefined;
    /**
     * Attempts to retrieve the PhysicsComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the PhysicsComponent
     * without requiring explicit type casting.
     *
     * @returns The PhysicsComponent if this entity has one, undefined otherwise
     */
    tryToGetPhysics(): PhysicsComponent | undefined;
    /**
     * Attempts to retrieve the SceneGraphComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the SceneGraphComponent
     * without requiring explicit type casting.
     *
     * @returns The SceneGraphComponent if this entity has one, undefined otherwise
     */
    tryToGetSceneGraph(): SceneGraphComponent | undefined;
    /**
     * Attempts to retrieve the SkeletalComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the SkeletalComponent
     * without requiring explicit type casting.
     *
     * @returns The SkeletalComponent if this entity has one, undefined otherwise
     */
    tryToGetSkeletal(): SkeletalComponent | undefined;
    /**
     * Attempts to retrieve the TransformComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the TransformComponent
     * without requiring explicit type casting.
     *
     * @returns The TransformComponent if this entity has one, undefined otherwise
     */
    tryToGetTransform(): TransformComponent | undefined;
    /**
     * Attempts to retrieve the VrmComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the VrmComponent
     * without requiring explicit type casting.
     *
     * @returns The VrmComponent if this entity has one, undefined otherwise
     */
    tryToGetVrm(): VrmComponent | undefined;
    /**
     * Attempts to retrieve the ConstraintComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the ConstraintComponent
     * without requiring explicit type casting.
     *
     * @returns The ConstraintComponent if this entity has one, undefined otherwise
     */
    tryToGetConstraint(): ConstraintComponent | undefined;
    /**
     * Attempts to retrieve the EffekseerComponent from this entity.
     *
     * @remarks
     * This is a convenience method that provides type-safe access to the EffekseerComponent
     * without requiring explicit type casting.
     *
     * @returns The EffekseerComponent if this entity has one, undefined otherwise
     */
    tryToGetEffekseer(): EffekseerComponent | undefined;
    /**
     * Destroys this entity and releases all associated resources.
     *
     * @remarks
     * This method calls the destroy method on all components attached to this entity
     * and marks the entity as no longer alive. After calling this method, the entity
     * should not be used.
     */
    _destroy(): void;
}

/** Event type that can be either a string or symbol */
type EventType = string | symbol;
/** Index of an event subscriber in the subscribers array */
type EventSubscriberIndex = number;
/** Number of subscribers that were called during event publishing */
type CalledSubscriberNumber = number;
/** Event handler function that processes events */
type EventHandler = (event: unknown) => void;
/**
 * Interface for event publish-subscribe pattern implementation
 * Provides methods for subscribing to events, unsubscribing, and publishing events
 */
interface IEventPubSub {
    /**
     * Subscribe to an event type with a handler function
     * @param type - The event type to subscribe to
     * @param handler - The function to call when the event is published
     * @returns The index of the subscriber for later unsubscription
     */
    subscribe(type: EventType, handler: EventHandler): EventSubscriberIndex;
    /**
     * Unsubscribe a specific handler by its index
     * @param type - The event type to unsubscribe from
     * @param index - The index of the subscriber to remove
     */
    unsubscribe(type: EventType, index: EventSubscriberIndex): void;
    /**
     * Unsubscribe all handlers for a specific event type
     * @param type - The event type to unsubscribe all handlers from
     * @param handler - The handler function to remove (all instances)
     */
    unsubscribeAll(type: EventType, handler: EventHandler): void;
    /**
     * Publish an event asynchronously to all subscribers
     * @param type - The event type to publish
     * @param event - Optional event data to pass to handlers
     * @returns The number of subscribers that were called
     */
    publishAsync(type: EventType, event?: any): CalledSubscriberNumber;
    /**
     * Publish an event synchronously to all subscribers
     * @param type - The event type to publish
     * @param event - Optional event data to pass to handlers
     * @returns The number of subscribers that were called
     */
    publishSync(type: EventType, event?: any): CalledSubscriberNumber;
}
/**
 * Event publish-subscribe system implementation
 *
 * This class provides a centralized event system where components can subscribe to events
 * and publish events to notify subscribers. It supports both synchronous and asynchronous
 * event publishing patterns.
 *
 * @example
 * ```typescript
 * const eventSystem = new EventPubSub();
 *
 * // Subscribe to an event
 * const index = eventSystem.subscribe('user-login', (userData) => {
 *   console.log('User logged in:', userData);
 * });
 *
 * // Publish an event
 * eventSystem.publishSync('user-login', { userId: 123, name: 'John' });
 *
 * // Unsubscribe
 * eventSystem.unsubscribe('user-login', index);
 * ```
 */
declare class EventPubSub implements IEventPubSub {
    /** Map storing event types and their corresponding subscriber arrays */
    private __subscriberMap;
    /**
     * Subscribe to an event type with a handler function
     *
     * @param type - The event type to subscribe to (string or symbol)
     * @param handler - The callback function to execute when the event is published
     * @returns The index of the subscriber in the array, used for unsubscription
     *
     * @example
     * ```typescript
     * const index = eventPubSub.subscribe('data-updated', (data) => {
     *   console.log('Data changed:', data);
     * });
     * ```
     */
    subscribe(type: EventType, handler: EventHandler): EventSubscriberIndex;
    /**
     * Unsubscribe a specific handler by its index
     *
     * @param type - The event type to unsubscribe from
     * @param index - The index of the subscriber to remove (returned from subscribe)
     *
     * @example
     * ```typescript
     * const index = eventPubSub.subscribe('my-event', handler);
     * eventPubSub.unsubscribe('my-event', index);
     * ```
     */
    unsubscribe(type: EventType, index: EventSubscriberIndex): void;
    /**
     * Remove all subscribers for a specific event type
     *
     * @param type - The event type to clear all subscribers from
     *
     * @example
     * ```typescript
     * eventPubSub.unsubscribeAll('my-event');
     * ```
     */
    unsubscribeAll(type: EventType): void;
    /**
     * Publish an event asynchronously to all subscribers
     *
     * Each subscriber is called asynchronously using setTimeout, allowing the current
     * execution context to complete before handlers are invoked. This prevents blocking
     * the main thread and allows for better performance in scenarios with many subscribers.
     *
     * @param type - The event type to publish
     * @param event - Optional event data to pass to all handlers
     * @returns The number of subscribers that were scheduled to be called
     *
     * @example
     * ```typescript
     * const count = eventPubSub.publishAsync('user-action', { action: 'click', target: 'button' });
     * console.log(`Scheduled ${count} handlers`);
     * ```
     */
    publishAsync(type: EventType, event?: any): CalledSubscriberNumber;
    /**
     * Publish an event synchronously to all subscribers
     *
     * All subscribers are called immediately in the order they were registered.
     * This method blocks until all handlers have completed execution.
     *
     * @param type - The event type to publish
     * @param event - Optional event data to pass to all handlers
     * @returns The number of subscribers that were called
     *
     * @example
     * ```typescript
     * const count = eventPubSub.publishSync('data-changed', newData);
     * console.log(`Called ${count} handlers synchronously`);
     * ```
     */
    publishSync(type: EventType, event?: any): CalledSubscriberNumber;
}

interface IAnimationRetarget {
    retargetQuaternion(dstEntity: ISceneGraphEntity): IQuaternion;
    retargetTranslate(dstEntity: ISceneGraphEntity): IVector3;
    retargetScale(dstEntity: ISceneGraphEntity): IVector3;
    getEntity(): ISceneGraphEntity;
}

/**
 * Global retargeting implementation for animation retargeting.
 * This class handles retargeting of animations from one entity to another using global space transformations.
 */
declare class GlobalRetarget implements IAnimationRetarget {
    private __srcEntity;
    /**
     * Creates a new GlobalRetarget instance.
     * @param srcEntity - The source entity to retarget animations from
     */
    constructor(srcEntity: ISceneGraphEntity);
    /**
     * Gets the source entity for retargeting.
     * @returns The source scene graph entity
     */
    getEntity(): ISceneGraphEntity;
    /**
     * Gets the parent's global rest quaternion for the source entity.
     * This is used to transform from local space to global space for the source.
     * @param srcEntity - The source entity to get parent global rest quaternion for
     * @returns The parent's global rest quaternion, or identity if no parent exists
     */
    getSrcPGRestQ(srcEntity: ISceneGraphEntity): IQuaternion;
    /**
     * Gets the parent's global rest quaternion for the destination entity.
     * This is used to transform from global space to local space for the destination.
     * @param dstEntity - The destination entity to get parent global rest quaternion for
     * @returns The parent's global rest quaternion, or identity if no parent exists
     */
    getDstPGRestQ(dstEntity: ISceneGraphEntity): IQuaternion;
    /**
     * Retargets rotation from the source entity to the destination entity.
     * The method extracts the global animation quaternion from the source and applies it to the destination.
     * @param dstEntity - The destination entity to apply the retargeted rotation to
     * @returns The retargeted local rotation quaternion for the destination entity
     */
    retargetQuaternion(dstEntity: ISceneGraphEntity): IQuaternion;
    /**
     * Retargets translation from the source entity to the destination entity.
     * The method extracts the global animation translation from the source, scales it appropriately,
     * and applies it to the destination entity.
     * @param dstEntity - The destination entity to apply the retargeted translation to
     * @returns The retargeted local position vector for the destination entity
     */
    retargetTranslate(dstEntity: ISceneGraphEntity): IVector3;
    /**
     * Retargets scale from the source entity to the destination entity.
     * Currently returns the source entity's local scale directly without modification.
     * @param dstEntity - The destination entity (not used in current implementation)
     * @returns The source entity's local scale vector
     */
    retargetScale(_dstEntity: ISceneGraphEntity): IVector3;
}

/**
 * Global retarget reverse implementation for animation retargeting.
 * This class handles the reverse retargeting of animations from source to destination entities
 * with global coordinate system considerations and 180-degree rotation reversal.
 */
declare class GlobalRetargetReverse implements IAnimationRetarget {
    private __srcEntity;
    static readonly __rev: Quaternion;
    /**
     * Creates a new GlobalRetargetReverse instance.
     * @param srcEntity - The source entity from which animation data will be retargeted
     */
    constructor(srcEntity: ISceneGraphEntity);
    /**
     * Gets the source entity used for retargeting.
     * @returns The source scene graph entity
     */
    getEntity(): ISceneGraphEntity;
    /**
     * Gets the parent global rest quaternion for the source entity.
     * This method traverses up the hierarchy to find the parent's rest rotation
     * for entities that have VRM components.
     * @param srcEntity - The source entity to get parent global rest quaternion for
     * @returns The parent global rest quaternion, or identity quaternion if no parent exists
     */
    getSrcPGRestQ(srcEntity: ISceneGraphEntity): IQuaternion;
    /**
     * Gets the parent global rest quaternion for the destination entity.
     * This method traverses up the hierarchy to find the parent's rest rotation
     * for entities that have VRM components.
     * @param dstEntity - The destination entity to get parent global rest quaternion for
     * @returns The parent global rest quaternion, or identity quaternion if no parent exists
     */
    getDstPGRestQ(dstEntity: ISceneGraphEntity): IQuaternion;
    /**
     * Retargets the quaternion rotation from source entity to destination entity.
     * This method extracts the global animation quaternion from the source entity,
     * then applies it to the destination entity's local coordinate system with
     * a 180-degree Y-axis rotation reversal.
     * @param dstEntity - The destination entity to apply the retargeted rotation to
     * @returns The retargeted quaternion with reverse rotation applied
     */
    retargetQuaternion(dstEntity: ISceneGraphEntity): IQuaternion;
    /**
     * Retargets the translation from source entity to destination entity.
     * This method extracts the global animation translation from the source entity,
     * scales it according to the destination entity's proportions, then applies
     * a 180-degree Y-axis rotation reversal.
     * @param dstEntity - The destination entity to apply the retargeted translation to
     * @returns The retargeted translation vector with reverse rotation applied
     */
    retargetTranslate(dstEntity: ISceneGraphEntity): IVector3;
    /**
     * Retargets the scale from source entity to destination entity.
     * Currently, this method simply returns the source entity's local scale
     * without any modifications or transformations.
     * @param dstEntity - The destination entity (currently unused)
     * @returns The source entity's local scale vector
     */
    retargetScale(_dstEntity: ISceneGraphEntity): IVector3;
}

/**
 * Animation retargeting implementation that uses absolute transform values.
 * This class directly returns the source entity's transform values without any modifications.
 */
declare class AbsoluteAnimation implements IAnimationRetarget {
    private __srcEntity;
    /**
     * Creates a new AbsoluteAnimation instance.
     * @param srcEntity - The source entity whose transform values will be used for retargeting
     */
    constructor(srcEntity: ISceneGraphEntity);
    /**
     * Gets the source entity associated with this animation retarget.
     * @returns The source scene graph entity
     */
    getEntity(): ISceneGraphEntity;
    /**
     * Retargets rotation by returning the source entity's local rotation quaternion.
     * @param dstEntity - The destination entity (unused in absolute animation)
     * @returns The source entity's local rotation quaternion
     */
    retargetQuaternion(_dstEntity: ISceneGraphEntity): IQuaternion;
    /**
     * Retargets translation by returning the source entity's local position.
     * @param dstEntity - The destination entity (unused in absolute animation)
     * @returns The source entity's local position vector
     */
    retargetTranslate(_dstEntity: ISceneGraphEntity): IVector3;
    /**
     * Retargets scale by returning the source entity's local scale.
     * @param dstEntity - The destination entity (unused in absolute animation)
     * @returns The source entity's local scale vector
     */
    retargetScale(_dstEntity: ISceneGraphEntity): IVector3;
}

declare function createSkeletalEntity(): ISkeletalEntity;

/**
 * A component that manages animation data and applies animation transformations to entities.
 * This component handles various types of animations including transform, blend shape, material,
 * light, camera, and Effekseer particle system animations.
 */
declare class AnimationComponent extends Component {
    private __animationBlendingRatio;
    private __animationTrack;
    static __animationGlobalInfo: Map<AnimationTrackName, AnimationInfo>;
    private __isEffekseerState;
    private __isAnimating;
    static isAnimating: boolean;
    isLoop: boolean;
    useGlobalTime: boolean;
    static globalTime: number;
    time: number;
    static readonly Event: {
        ChangeAnimationInfo: symbol;
        PlayEnd: symbol;
    };
    private static __tmpQuat;
    private static __tmpPos;
    private static __tmpScale;
    private static __pubsub;
    /**
     * Component load lifecycle method. Moves the component to the Logic process stage.
     */
    $load(): void;
    /**
     * Component logic lifecycle method. Applies animation if animation is enabled.
     */
    $logic(): void;
    /**
     * Sets the animation blending ratio and applies the animation.
     * @param value - The blending ratio value between 0 and 1
     */
    set animationBlendingRatio(value: number);
    /**
     * Gets the current animation blending ratio.
     * @returns The blending ratio value between 0 and 1
     */
    get animationBlendingRatio(): number;
    /**
     * Applies animation to the entity based on the current time and animation tracks.
     * Handles various animation types including transform, blend shape, material, light, camera, and Effekseer.
     * @private
     */
    private __applyAnimation;
    private __applyChannelAnimation;
    private __applyTransformAnimation;
    private __applyBlendShapeAnimation;
    private __applyMaterialAnimation;
    private __applyLightAnimation;
    private __applyCameraAnimation;
    private __applyEffekseerAnimation;
    /**
     * Subscribes to animation component events.
     * @param type - The type of event to subscribe to
     * @param handler - The event handler function
     */
    static subscribe(type: AnimationComponentEventType, handler: EventHandler): void;
    /**
     * Sets whether this animation component is animating.
     * @param flg - True to enable animation, false to disable
     */
    setIsAnimating(flg: boolean): void;
    /**
     * Sets the active animation track for all animation components.
     * @param animationTrackName - The name of the animation track to activate
     */
    static setActiveAnimationForAll(animationTrackName: AnimationTrackName): void;
    /**
     * Sets the active animation track for this component.
     * @param animationTrackName - The name of the animation track to activate
     */
    setActiveAnimationTrack(animationTrackName: AnimationTrackName): void;
    /**
     * Sets the second active animation track for blending purposes.
     * @param animationTrackName - The name of the second animation track to activate
     */
    setSecondActiveAnimationTrack(animationTrackName: AnimationTrackName): void;
    /**
     * Gets the name of the currently active animation track.
     * @returns The name of the active animation track
     * @throws Error if no active animation track is found
     */
    getActiveAnimationTrack(): string;
    /**
     * Checks if this component has a specific animation for the given track and path.
     * @param trackName - The animation track name to check
     * @param pathName - The animation path name to check
     * @returns True if the animation exists, false otherwise
     */
    hasAnimation(trackName: AnimationTrackName, pathName: AnimationPathName): boolean;
    /**
     * Sets an animation channel for the specified path. If a channel already exists for the path,
     * it merges the new animation data with the existing one.
     * @param pathName - The name of the animation path (e.g., 'translate', 'rotate', 'scale')
     * @param animatedValueArg - The animated value containing animation data
     */
    setAnimation(pathName: AnimationPathName, animatedValueArg: IAnimatedValue): void;
    /**
     * Gets the animated value for the specified animation path.
     * @param pathName - The name of the animation path
     * @returns The animated value or undefined if not found
     */
    getAnimation(pathName: AnimationPathName): IAnimatedValue | undefined;
    /**
     * Gets the start input time value for the specified animation track.
     * @param animationTrackName - The name of the animation track
     * @returns The minimum start input time value
     */
    getStartInputValueOfAnimation(animationTrackName: string): number;
    /**
     * Gets the end input time value for the specified animation track.
     * @param animationTrackName - The name of the animation track
     * @returns The maximum end input time value
     */
    getEndInputValueOfAnimation(animationTrackName: string): number;
    /**
     * Gets an array of all available animation track names.
     * @returns Array of animation track names
     */
    static getAnimationList(): AnimationTrackName[];
    /**
     * Gets the animation information for all tracks.
     * @returns A map containing animation track names and their corresponding information
     */
    static getAnimationInfo(): Map<AnimationTrackName, AnimationInfo>;
    /**
     * Gets all animation track names associated with this component.
     * @returns An array of animation track names
     */
    getAnimationTrackNames(): AnimationTrackName[];
    /**
     * Gets the animation channels of the animation track.
     * @returns The channel maps of the animation track
     */
    getAnimationChannelsOfTrack(): AnimationTrack;
    /**
     * Gets whether this component is currently animating.
     * @returns True if animating, false otherwise
     */
    get isAnimating(): boolean;
    /**
     * Gets the global start input value for all animation components.
     * @returns The start input value
     */
    static get startInputValue(): number;
    /**
     * Gets the global end input value for all animation components.
     * @returns The end input value
     */
    static get endInputValue(): number;
    /**
     * Gets the component type identifier for AnimationComponent.
     * @returns The component type identifier
     */
    static get componentTID(): ComponentTID;
    /**
     * Gets the component type identifier for this instance.
     * @returns The component type identifier
     */
    get componentTID(): ComponentTID;
    /**
     * Gets the entity that owns this animation component.
     * @returns The entity which has this component
     */
    get entity(): IAnimationEntity;
    /**
     * Adds this animation component to an entity, extending the entity with animation methods.
     * @param base - The target entity to add this component to
     * @param _componentClass - The component class to add
     * @returns The entity extended with animation component methods
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBase, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBase;
    /**
     * Adds a keyframe to the specified animation track at the given frame.
     * @param trackName - The name of the animation track
     * @param pathName - The name of the animation path
     * @param frameToInsert - The frame number where to insert the keyframe
     * @param fps - The frames per second rate
     * @returns True if the keyframe was successfully added, false otherwise
     */
    addKeyFrame(trackName: AnimationTrackName, pathName: AnimationPathName, frameToInsert: Index, fps: number): boolean;
    /**
     * Adds a keyframe with a specific value to the specified animation track at the given frame.
     * @param trackName - The name of the animation track
     * @param pathName - The name of the animation path
     * @param frameToInsert - The frame number where to insert the keyframe
     * @param output - The array of output values for the keyframe
     * @param fps - The frames per second rate
     * @returns True if the keyframe was successfully added, false otherwise
     */
    addKeyFrameWithValue(trackName: AnimationTrackName, pathName: AnimationPathName, frameToInsert: Index, output: Array<number>, fps: number): boolean;
    /**
     * Deletes keyframes at the specified frame for the given animation track and path.
     * @param trackName - The name of the animation track
     * @param pathName - The name of the animation path
     * @param frameToDelete - The frame number where to delete keyframes
     * @param fps - The frames per second rate
     * @returns True if keyframes were successfully deleted, false otherwise
     */
    deleteKeysAtFrame(trackName: AnimationTrackName, pathName: AnimationPathName, frameToDelete: Index, fps: number): boolean;
    /**
     * Checks if keyframes exist at the specified frame for the given animation track and path.
     * @param trackName - The name of the animation track
     * @param pathName - The name of the animation path
     * @param frame - The frame number to check
     * @param fps - The frames per second rate
     * @returns True if keyframes exist at the frame, false otherwise
     */
    hasKeyFramesAtFrame(trackName: AnimationTrackName, pathName: AnimationPathName, frame: Index, fps: number): boolean;
    /**
     * Sets the global animation state for all animation components.
     * @param flag - True to enable animation globally, false to disable
     */
    static setIsAnimating(flag: boolean): void;
    /**
     * Performs a shallow copy of another animation component's data into this component.
     * @param component_ - The source animation component to copy from
     * @override
     */
    _shallowCopyFrom(component_: Component): void;
    /**
     * Sets up animation retargeting from a source entity to this entity.
     * @param retarget - The retargeting interface that defines how to map animations
     * @param postfixToTrackName - Optional postfix to append to track names
     * @returns An array of created track names
     * @private
     */
    _setRetarget(retarget: IAnimationRetarget, postfixToTrackName?: string): string[];
    /**
     * Resets all animation tracks, clearing all animation data from this component.
     */
    resetAnimationTracks(): void;
    /**
     * Resets a specific animation track by removing its animation sampler data.
     * @param trackName - The name of the animation track to reset
     */
    resetAnimationTrack(trackName: string): void;
    /**
     * Resets all animation tracks that have names ending with the specified postfix.
     * @param postfix - The postfix to match against track names
     */
    resetAnimationTrackByPostfix(postfix: string): void;
    /**
     * Destroys this component, cleaning up resources and clearing animation data.
     * @override
     */
    _destroy(): void;
}

interface IAnimationEntityMethods {
    getAnimation(): AnimationComponent;
}

/**
 * An entity that has transform capabilities.
 * Combines basic entity interface with transform methods.
 */
type ITransformEntity = IEntity & ITransformEntityMethods;
/**
 * An entity that exists in the scene graph hierarchy.
 * Extends transform entity with scene graph operations.
 */
type ISceneGraphEntity = ITransformEntity & ISceneGraphEntityMethods;
/**
 * An entity that can render meshes.
 * Combines scene graph entity with mesh and mesh renderer capabilities.
 */
type IMeshEntity = ISceneGraphEntity & IMeshEntityMethods & IMeshRendererEntityMethods;
/**
 * An entity that represents a camera in the scene.
 * Extends scene graph entity with camera-specific methods.
 */
type ICameraEntity = ISceneGraphEntity & ICameraEntityMethods;
/**
 * An entity that can control camera behavior.
 * Combines camera entity with camera controller capabilities.
 */
type ICameraControllerEntity = ICameraEntity & ICameraControllerEntityMethods;
/**
 * An entity that supports skeletal animation.
 * Extends scene graph entity with skeletal system methods.
 */
type ISkeletalEntity = ISceneGraphEntity & ISkeletalEntityMethods;
/**
 * An entity that can emit light.
 * Extends scene graph entity with lighting capabilities.
 */
type ILightEntity = ISceneGraphEntity & ILightEntityMethods;
/**
 * An entity that participates in physics simulation.
 * Extends scene graph entity with physics methods.
 */
type IPhysicsEntity = ISceneGraphEntity & IPhysicsEntityMethods;
/**
 * An entity that supports blend shape animation.
 * Combines mesh entity with blend shape capabilities.
 */
type IBlendShapeEntity = IMeshEntity & IBlendShapeEntityMethods;
/**
 * An entity that can apply constraints.
 * Extends scene graph entity with constraint methods.
 */
type IConstraintEntity = ISceneGraphEntity & IConstraintEntityMethods;
/**
 * An entity that can play animations.
 * Extends scene graph entity with animation playback capabilities.
 */
interface IAnimationEntity extends ISceneGraphEntity, IAnimationEntityMethods {
}
/**
 * An entity that manages animation states.
 * Extends scene graph entity with animation state management.
 */
interface IAnimationStateEntity extends ISceneGraphEntity, IAnimationStateEntityMethods {
}
/**
 * Creates a special entity that combines both light and camera functionality.
 * The camera component is automatically synchronized with the light component,
 * meaning the camera will follow the light's position and orientation.
 * This is useful for creating shadow-casting lights or spotlight effects.
 *
 * @returns A combined light and camera entity with synchronized behavior
 *
 * @example
 * ```typescript
 * const lightCameraEntity = createLightWithCameraEntity();
 * // The camera will automatically sync to the light's transform
 * lightCameraEntity.getLight().intensity = 2.0;
 * lightCameraEntity.getCamera().fovy = Math.PI / 4;
 * ```
 */
declare function createLightWithCameraEntity(): ILightEntity & ICameraEntityMethods;

type RnM2 = {
    extensionsUsed: string[];
    extensionsRequired: string[];
    accessors: RnM2Accessor[];
    animations: RnM2Animation[];
    asset: RnM2Asset;
    buffers: RnM2Buffer[];
    bufferViews: RnM2BufferView[];
    cameras: RnM2Camera[];
    images: RnM2Image[];
    materials: RnM2Material[];
    meshes: RnM2Mesh[];
    nodes: RnM2Node[];
    samplers: RnM2TextureSampler[];
    scene: number;
    scenes: RnM2Scene[];
    skins: RnM2Skin[];
    textures: RnM2Texture[];
    extensions: Gltf2AnyObject;
    extras: {
        rnEntities: ISceneGraphEntity[];
        rnEntitiesByNames: Map<string, ISceneGraphEntity>;
        [key: string]: any;
    };
};
interface RnM2Scene extends Gltf2Scene {
    nodesObjects?: RnM2Node[];
    sceneObject?: RnM2Node;
}
type RnM2AttributesObject = {
    [s: string]: RnM2Accessor;
};
type RnM2Attributes = {
    [s: string]: number;
};
type RnM2AttributeAccessors = {
    [s: string]: RnM2Accessor;
};
type RnM2AttributeBlendShapes = RnM2Attributes[];
type RnM2AttributeBlendShapesAccessors = RnM2AttributeAccessors[];
type RnM2MaterialVariant = {
    materialObject: RnM2Material;
    material: number;
    variants: string[];
};
interface RnM2Primitive extends Gltf2Primitive {
    attributesObjects?: RnM2AttributeAccessors;
    attributesNames?: {
        [s: string]: string;
    };
    indicesObject?: RnM2Accessor;
    materialObject?: RnM2Material;
    materialVariants?: RnM2MaterialVariant[];
    materialName?: string;
    targetsObjects?: RnM2AttributeBlendShapesAccessors;
    targets?: RnM2AttributeBlendShapes;
}
interface RnM2Mesh extends Gltf2Mesh {
    primitives: RnM2Primitive[];
}
interface RnM2Node extends Gltf2Node {
    cameraObject?: RnM2Camera;
    childrenObjects?: RnM2Node[];
    parent?: number;
    parentObject?: RnM2Node;
    skinObject?: RnM2Skin;
    skinName?: string;
    meshObject?: RnM2Mesh;
    meshNames?: string[];
}
interface RnM2Skin extends Gltf2Skin {
    inverseBindMatricesObject?: RnM2Accessor;
    skeletonObject?: RnM2Node;
    jointsObjects: RnM2Node[];
}
interface RnM2TextureInfo extends Gltf2TextureInfo {
    texture?: RnM2Texture;
}
interface RnM2OcclusionTextureInfo extends Gltf2OcclusionTextureInfo {
    texture?: RnM2Texture;
}
interface RnM2NormalTextureInfo extends Gltf2NormalTextureInfo {
    texture?: RnM2Texture;
}
interface RnM2PbrMetallicRoughness extends Gltf2PbrMetallicRoughness {
    baseColorTexture?: RnM2TextureInfo;
    metallicRoughnessTexture?: RnM2TextureInfo;
}
interface RnM2Material extends Gltf2Material {
    pbrMetallicRoughness?: RnM2PbrMetallicRoughness;
    normalTexture?: RnM2NormalTextureInfo;
    occlusionTexture?: RnM2OcclusionTextureInfo;
    emissiveTexture?: RnM2TextureInfo;
}
interface RnM2CameraOrthographic extends Gltf2CameraOrthographic {
}
interface RnM2CameraPerspective extends Gltf2CameraPerspective {
}
interface RnM2Camera extends Gltf2Camera {
}
interface RnM2Image extends Gltf2Image {
}
interface RnM2AnimationChannelTarget extends Gltf2AnimationChannelTarget {
    nodeObject?: RnM2Node;
}
interface RnM2AnimationChannel extends Gltf2AnimationChannel {
    target: RnM2AnimationChannelTarget;
    samplerObject?: RnM2AnimationSampler;
}
interface RnM2AnimationSampler extends Gltf2AnimationSampler {
    inputObject?: RnM2Accessor;
    outputObject?: RnM2Accessor;
}
interface RnM2Animation extends Gltf2Animation {
    channels: RnM2AnimationChannel[];
    samplers: RnM2AnimationSampler[];
    parameters: {
        [s: string]: any;
    };
}
interface RnM2Texture extends Gltf2Texture {
    samplerObject?: RnM2TextureSampler;
    sourceObject?: RnM2Image;
}
interface RnM2TextureSampler extends Gltf2TextureSampler {
}
interface RnM2SparseValues extends Gltf2SparseValues {
    bufferViewObject: RnM2BufferView;
}
interface RnM2SparseIndices extends Gltf2SparseIndices {
    bufferViewObject: RnM2BufferView;
}
interface RnM2Sparse extends Gltf2Sparse {
    indices?: RnM2SparseIndices;
    values?: RnM2SparseValues;
}
interface RnM2Accessor extends Gltf2Accessor {
    bufferViewObject?: RnM2BufferView;
    bufferViewName?: string;
    sparse?: RnM2Sparse;
    accessor?: Accessor;
    extras?: {
        typedDataArray?: Float32Array;
        componentN?: number;
        componentBytes?: number;
        dataViewMethod?: string;
        weightsArrayLength?: number;
        quaternionIfVec4?: boolean;
    };
}
interface RnM2Buffer extends Gltf2Buffer {
    bufferPromise?: RnPromise<ArrayBuffer>;
}
interface RnM2BufferView extends Gltf2BufferView {
    bufferObject?: RnM2Buffer;
    bufferName?: string;
    rnAccessor?: Accessor;
}
interface RnM2Asset extends Gltf2Asset {
    extras?: {
        rnLoaderOptions?: GltfLoadOption;
        rnEntities?: ISceneGraphEntity[];
        rnMaterials?: {
            [s: string]: Material;
        };
        version?: string;
        fileType?: string;
    };
}
type RnM2ExtensionEffekseer = {
    effects: RnM2ExtensionsEffekseerEffect[];
};
type RnM2ExtensionsEffekseerEffect = {
    node: number;
    name?: string;
    uri?: string;
    bufferView?: number;
    timelines?: RnM2ExtensionsEffekseerTimeline[];
};
type RnM2ExtensionsEffekseerTimeline = {
    name?: string;
    values: RnM2ExtensionsEffekseerTimelineItem[];
};
type RnM2ExtensionsEffekseerTimelineItem = {
    input: number;
    event: 'play' | 'stop' | 'pause';
};

interface ILoaderExtension {
    generateMaterial?(materialJson: RnM2Material): Material;
    isNeededToUseThisMaterial?(gltfJson: RnM2): boolean;
    setTextures?(gltfJson: RnM2, materialJson: RnM2Material): void;
    setupMaterial?(gltfJson: RnM2, materialJson: RnM2Material, material: Material): void;
    setUVTransformToTexture?(material: Material, samplerJson: RnM2TextureSampler): void;
    loadExtensionInfoAndSetToRootGroup?(rootGroup: ISceneGraphEntity, json: RnM2): void;
}

interface Gltf2AnyObject {
    [s: string]: any;
}
type Gltf2 = {
    asset: Gltf2Asset;
    buffers?: Gltf2Buffer[];
    scenes?: Gltf2Scene[];
    scene?: number;
    meshes?: Gltf2Mesh[];
    nodes?: Gltf2Node[];
    skins?: Gltf2Skin[];
    materials?: Gltf2Material[];
    cameras?: Gltf2Camera[];
    images?: Gltf2Image[];
    animations?: Gltf2Animation[];
    textures?: Gltf2Texture[];
    samplers?: Gltf2TextureSampler[];
    accessors?: Gltf2Accessor[];
    bufferViews?: Gltf2BufferView[];
    extensionsUsed?: string[];
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
interface Gltf2Asset {
    copyright?: string;
    generator?: string;
    version: string;
    minVersion?: string;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
}
type Gltf2Scene = {
    name?: string;
    scene?: number;
    nodes?: number[];
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type AttributeName = 'POSITION' | 'NORMAL' | 'TANGENT' | 'TEXCOORD_0' | 'TEXCOORD_1' | 'TEXCOORD_2' | 'COLOR_0' | 'JOINTS_0' | 'WEIGHTS_0';
type Gltf2AccessorComponentTypeNumber = typeof GL_DATA_BYTE | typeof GL_DATA_UNSIGNED_BYTE | typeof GL_DATA_SHORT | typeof GL_DATA_UNSIGNED_SHORT | typeof GL_DATA_INT | typeof GL_DATA_UNSIGNED_INT | typeof GL_DATA_FLOAT;
type Gltf2AnimationAccessorCompositionTypeString = 'SCALAR' | 'VEC2' | 'VEC3' | 'VEC4';
type Gltf2AccessorCompositionTypeString = 'SCALAR' | 'VEC2' | 'VEC3' | 'VEC4' | 'MAT2' | 'MAT3' | 'MAT4';
type Gltf2AccessorIndex = number;
type Gltf2Attributes = {
    [s: string]: number;
};
type Gltf2AttributeAccessors = Map<string, Gltf2Accessor>;
type Gltf2AttributeBlendShapes = Gltf2Attributes[];
type Gltf2AttributeBlendShapesAccessors = Gltf2AttributeAccessors[];
type Gltf2Primitive = {
    attributes: Gltf2Attributes;
    indices?: number;
    material?: number;
    mode?: number;
    targets?: Gltf2AttributeBlendShapes;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2Mesh = {
    primitives: Gltf2Primitive[];
    weights?: number[];
    name?: string;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2Node = {
    camera?: number;
    children?: number[];
    skin?: number;
    matrix?: number[];
    mesh?: number;
    rotation?: number[];
    scale?: number[];
    translation?: number[];
    weights?: number[];
    name?: string;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2Skin = {
    inverseBindMatrices?: number;
    bindShapeMatrix?: number[];
    skeleton?: number;
    joints: number[];
    name?: string;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2TextureInfo = {
    index: number;
    texCoord?: number;
    texture?: Gltf2Texture;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2OcclusionTextureInfo = {
    index: number;
    texCoord?: number;
    texture?: Gltf2Texture;
    strength?: number;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2NormalTextureInfo = {
    index: number;
    texCoord?: number;
    texture?: Gltf2Texture;
    scale?: number;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2PbrMetallicRoughness = {
    baseColorFactor?: Array4<number>;
    baseColorTexture?: Gltf2TextureInfo;
    metallicFactor?: number;
    roughnessFactor?: number;
    metallicRoughnessTexture?: Gltf2TextureInfo;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2Material = {
    pbrMetallicRoughness?: Gltf2PbrMetallicRoughness;
    normalTexture?: Gltf2NormalTextureInfo;
    occlusionTexture?: Gltf2OcclusionTextureInfo;
    emissiveTexture?: Gltf2TextureInfo;
    emissiveFactor?: Array3<number>;
    alphaMode?: string;
    alphaCutoff?: number;
    doubleSided?: boolean;
    name?: string;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2CameraOrthographic = {
    xmag: number;
    ymag: number;
    zfar: number;
    znear: number;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2CameraPerspective = {
    aspectRatio?: number;
    yfov: number;
    zfar?: number;
    znear: number;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2Camera = {
    orthographic?: Gltf2CameraOrthographic;
    perspective?: Gltf2CameraPerspective;
    type: string;
    name?: string;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2Image = {
    uri?: string;
    mimeType?: string;
    bufferView?: number;
    image?: HTMLImageElement;
    basis?: Uint8Array;
    ktx2?: Uint8Array;
    name?: string;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2AnimationPathName = 'translation' | 'rotation' | 'scale' | 'weights' | 'pointer' | 'effekseer';
type Gltf2AnimationChannelTarget = {
    node?: number;
    path: Gltf2AnimationPathName;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2AnimationSamplerIndex = number;
type Gltf2AnimationChannel = {
    sampler: Gltf2AnimationSamplerIndex;
    target: Gltf2AnimationChannelTarget;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2AnimationSamplerInterpolation = 'LINEAR' | 'STEP' | 'CUBICSPLINE';
type Gltf2AnimationSampler = {
    input: Gltf2AccessorIndex;
    output: Gltf2AccessorIndex;
    interpolation: Gltf2AnimationSamplerInterpolation;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2Animation = {
    channels: Gltf2AnimationChannel[];
    samplers: Gltf2AnimationSampler[];
    name?: string;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2Texture = {
    sampler?: number;
    source?: number;
    name?: string;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2TextureSampler = {
    magFilter?: number;
    minFilter?: number;
    wrapS?: number;
    wrapT?: number;
    name?: string;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2SparseValues = {
    bufferView: number;
    byteOffset?: number;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2SparseIndices = {
    bufferView: number;
    byteOffset?: number;
    componentType: number;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2Sparse = {
    count: number;
    indices?: Gltf2SparseIndices;
    values?: Gltf2SparseValues;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
type Gltf2Buffer = {
    uri?: string;
    byteLength: number;
    buffer?: Uint8Array;
    dataUri?: string;
    name?: string;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
};
interface Gltf2BufferView {
    buffer?: number;
    byteOffset?: number;
    byteLength: number;
    byteStride?: number;
    target?: number;
    name?: string;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
}
interface Gltf2Accessor {
    bufferView?: number;
    byteOffset?: number;
    byteStride?: number;
    componentType: Gltf2AccessorComponentTypeNumber;
    normalized?: boolean;
    count: number;
    type: Gltf2AccessorCompositionTypeString;
    max?: number[];
    min?: number[];
    sparse?: Gltf2Sparse;
    name?: string;
    extensions?: Gltf2AnyObject;
    extras?: Gltf2AnyObject;
}
type PointType = 'directional' | 'point' | 'spot';
type KHR_lights_punctual_Light = {
    color: Array3<number>;
    type: PointType;
    name?: string;
    intensity?: number;
    range: number;
    spot?: {
        innerConeAngle?: number;
        outerConeAngle?: number;
    };
};
type KHR_lights_punctual = {
    lights: KHR_lights_punctual_Light[];
};
type GltfFileBuffers = {
    [s: string]: ArrayBuffer;
};
type GltfLoadOption = {
    files?: GltfFileBuffers;
    loaderExtensionName?: string;
    loaderExtension?: ILoaderExtension;
    defaultMaterialHelperName?: string;
    defaultMaterialHelperArgumentArray?: any[];
    statesOfElements?: [
        {
            targets: any[];
            states: {
                enable: any[];
                functions: object;
            };
            isTransparent: boolean;
            opacity: number;
            isTextureImageToLoadPreMultipliedAlpha: boolean;
        }
    ];
    alphaMode?: string;
    ignoreLists?: [];
    autoDetectTextureTransparency?: boolean;
    tangentCalculationMode?: Index;
    extendedJson?: string | Object | ArrayBuffer;
    maxMorphTargetNumber?: number;
    defaultTextures?: {
        basePath: string;
        textureInfos: {
            shaderSemantics: ShaderSemanticsEnum;
            fileName: string;
            image?: Gltf2Image;
            sampler?: any;
        }[];
    };
    cameraComponent?: CameraComponent;
    fileType?: string;
    expression?: Expression;
    transmission?: boolean;
    shadow?: boolean;
    __isImportVRM0x?: boolean;
    __importedType?: 'gltf2' | 'glb2' | 'vrm0x' | 'vrm1' | 'draco' | 'undefined';
};
declare const TagGltf2NodeIndex = "gltf_node_index";
declare function isSameGlTF2TextureSampler(lhs: Gltf2TextureSampler, rhs: Gltf2TextureSampler): boolean;

interface ComponentTypeEnum extends EnumIO {
    wgsl: string;
    webgpu: string;
    getSizeInBytes(): number;
    isFloatingPoint(): boolean;
    isInteger(): boolean;
}
declare class ComponentTypeClass<TypeName extends string> extends EnumClass implements ComponentTypeEnum {
    readonly __webgpu: string;
    readonly __wgsl: string;
    readonly __sizeInBytes: number;
    readonly __dummyStr: TypeName;
    constructor({ index, str, sizeInBytes, wgsl, webgpu, }: {
        index: number;
        str: TypeName;
        sizeInBytes: number;
        wgsl: string;
        webgpu: string;
    });
    get wgsl(): string;
    get webgpu(): string;
    getSizeInBytes(): number;
    isFloatingPoint(): boolean;
    isInteger(): boolean;
    isUnsignedInteger(): boolean;
}
declare const Byte: ComponentTypeClass<"BYTE">;
declare const UnsignedByte: ComponentTypeClass<"UNSIGNED_BYTE">;
declare const Short: ComponentTypeClass<"SHORT">;
declare const UnsignedShort: ComponentTypeClass<"UNSIGNED_SHORT">;
declare const Int: ComponentTypeClass<"INT">;
declare const UnsignedInt: ComponentTypeClass<"UNSIGNED_INT">;
declare const Float: ComponentTypeClass<"FLOAT">;
declare function from(index: number): ComponentTypeEnum;
declare function fromString(str: string): ComponentTypeEnum;
declare function fromTypedArray(typedArray: TypedArray): ComponentTypeEnum;
declare function toTypedArray(componentType: ComponentTypeEnum): TypedArrayConstructor | undefined;
declare function fromWgslString(str_: string): ComponentTypeEnum;
declare function fromGlslString(str_: string): ComponentTypeEnum;
type Gltf2AccessorComponentType = typeof Byte | typeof UnsignedByte | typeof Short | typeof UnsignedShort | typeof Int | typeof UnsignedInt | typeof Float;
declare function toGltf2AccessorComponentType(componentTypeForGltf2: ComponentTypeEnum): Gltf2AccessorComponentTypeNumber;
declare const ComponentType: Readonly<{
    Unknown: ComponentTypeClass<"UNKNOWN">;
    Byte: ComponentTypeClass<"BYTE">;
    UnsignedByte: ComponentTypeClass<"UNSIGNED_BYTE">;
    Short: ComponentTypeClass<"SHORT">;
    UnsignedShort: ComponentTypeClass<"UNSIGNED_SHORT">;
    Int: ComponentTypeClass<"INT">;
    UnsignedInt: ComponentTypeClass<"UNSIGNED_INT">;
    Float: ComponentTypeClass<"FLOAT">;
    Double: ComponentTypeClass<"DOUBLE">;
    Bool: ComponentTypeClass<"BOOL">;
    HalfFloat: ComponentTypeClass<"HALF_FLOAT">;
    from: typeof from;
    fromTypedArray: typeof fromTypedArray;
    toTypedArray: typeof toTypedArray;
    toGltf2AccessorComponentType: typeof toGltf2AccessorComponentType;
    fromString: typeof fromString;
    fromGlslString: typeof fromGlslString;
    fromWgslString: typeof fromWgslString;
}>;

/**
 * MemoryManager is a singleton class that manages the memory allocation and buffers for the Rhodonite library.
 * It handles different types of buffers including CPU generic data, GPU instance data, and GPU vertex data.
 */
declare class MemoryManager {
    private static __instance;
    private __buffers;
    private __buffersOnDemand;
    private __memorySizeRatios;
    /**
     * Private constructor to ensure singleton pattern.
     * Initializes memory size ratios for different buffer types.
     * @param cpuGeneric - Memory size ratio for CPU generic data
     * @param gpuInstanceData - Memory size ratio for GPU instance data
     * @param gpuVertexData - Memory size ratio for GPU vertex data
     */
    private constructor();
    /**
     * Creates a MemoryManager instance if it doesn't exist, or returns the existing instance.
     * This method enforces the singleton pattern.
     * @param config - Configuration object containing memory size ratios
     * @param config.cpuGeneric - Memory size ratio for CPU generic data
     * @param config.gpuInstanceData - Memory size ratio for GPU instance data
     * @param config.gpuVertexData - Memory size ratio for GPU vertex data
     * @returns The MemoryManager singleton instance
     */
    static createInstanceIfNotCreated({ cpuGeneric, gpuInstanceData, gpuVertexData, }: {
        cpuGeneric: number;
        gpuInstanceData: number;
        gpuVertexData: number;
    }): MemoryManager;
    /**
     * Ensures the memory size is a multiple of 4 bytes for proper alignment.
     * @param memorySize - The original memory size in bytes
     * @returns The adjusted memory size that is a multiple of 4 bytes
     */
    private __makeMultipleOf4byteSize;
    /**
     * Gets the singleton instance of MemoryManager.
     * @returns The MemoryManager instance
     * @throws Error if the instance has not been created yet
     */
    static getInstance(): MemoryManager;
    /**
     * Calculates the total memory size based on buffer dimensions and data format.
     * @returns The total memory size in bytes (width  height  4 channels  4 bytes per channel)
     */
    getMemorySize(): number;
    /**
     * Creates a new buffer for the specified buffer use type.
     * Sets appropriate byte alignment based on buffer type (4 bytes for CPU, 16 bytes for GPU).
     * @param bufferUse - The type of buffer to create
     * @returns The newly created Buffer instance
     */
    private __createBuffer;
    /**
     * Retrieves an existing buffer for the specified buffer use type.
     * @param bufferUse - The type of buffer to retrieve
     * @returns The Buffer instance if it exists, undefined otherwise
     */
    getBuffer(bufferUse: BufferUseEnum): Buffer | undefined;
    /**
     * Gets an existing buffer or creates a new one if it doesn't exist.
     * @param bufferUse - The type of buffer to retrieve or create
     * @returns The Buffer instance (existing or newly created)
     */
    createOrGetBuffer(bufferUse: BufferUseEnum): Buffer;
    /**
     * Creates a buffer on-demand with custom size and alignment for a specific object.
     * These buffers are typically used for UBOs (Uniform Buffer Objects).
     * @param size - The size of the buffer in bytes
     * @param object - The RnObject that will own this buffer
     * @param byteAlign - The byte alignment requirement for the buffer
     * @returns The newly created Buffer instance
     */
    createBufferOnDemand(size: Byte$1, object: RnObject, byteAlign: Byte$1): Buffer;
    /**
     * Retrieves an on-demand buffer associated with a specific object.
     * @param object - The RnObject whose buffer to retrieve
     * @returns The Buffer instance if it exists, undefined otherwise
     */
    getBufferOnDemand(object: RnObject): Buffer | undefined;
    /**
     * Gets the buffer width length from the configuration.
     * @returns The data texture width from Config
     */
    static get bufferWidthLength(): Size;
    /**
     * Gets the buffer height length from the configuration.
     * @returns The data texture height from Config
     */
    static get bufferHeightLength(): Size;
    /**
     * Prints memory usage statistics for all managed buffers to the console.
     * Shows used bytes, total bytes, and usage percentage for each buffer type.
     */
    printMemoryUsage(): void;
    /**
     * Dumps the contents of a buffer to a downloadable file for debugging purposes.
     * @param bufferUse - The type of buffer to dump
     * @returns The Buffer instance that was dumped, or undefined if the buffer doesn't exist
     */
    dumpBuffer(bufferUse: BufferUseEnum): Buffer | undefined;
}

/**
 * Component is a functional unit that can be added to an Entity instance.
 * This is the base class for all components in the ECS (Entity-Component-System) architecture.
 * Components provide specific functionality and data to entities.
 */
declare class Component extends RnObject {
    private _component_sid;
    _isAlive: boolean;
    protected __currentProcessStage: ProcessStageEnum;
    private static __bufferViews;
    private static __accessors;
    private static __byteLengthSumOfMembers;
    private static __memberInfo;
    private static __members;
    private __byteOffsetOfThisComponent;
    /** the entity unique Id which this component belongs to  */
    protected __entityUid: EntityUID;
    /** the instance of MemoryManager */
    protected __memoryManager: MemoryManager;
    /** the instance of EntityRepository */
    protected __entityRepository: EntityRepository;
    /** the MaxComponent Number of entities */
    private __maxComponentNumber;
    static readonly _processStages: Array<ProcessStageEnum>;
    /**
     * The constructor of the Component class.
     * When creating a Component, use the createComponent method of the ComponentRepository class
     * instead of directly calling this constructor.
     *
     * @param entityUid - Unique ID of the corresponding entity
     * @param componentSid - Scoped ID of the Component
     * @param entityRepository - The instance of the EntityRepository class (Dependency Injection)
     * @param isReUse - Whether this component is being reused from a pool
     */
    constructor(entityUid: EntityUID, componentSid: ComponentSID, entityRepository: EntityRepository, _isReUse: boolean);
    /**
     * Transitions the component to a different process stage.
     * This affects which update methods will be called during the frame processing.
     *
     * @param processStage - The target stage to move to
     */
    moveStageTo(processStage: ProcessStageEnum): void;
    /**
     * Sets the maximum number of components of this type that can exist.
     * This method is intended to be called by component classes only.
     *
     * @internal
     * @param value - The maximum number of components
     */
    _setMaxNumberOfComponent(value: number): void;
    /**
     * Gets the maximum number of components of this type that can exist.
     *
     * @returns The maximum number of components
     */
    get maxNumberOfComponent(): number;
    /**
     * Gets the Type ID of the Component class.
     * This is overridden by concrete component classes to provide unique type identification.
     *
     * @returns The component type ID (default: 0)
     */
    static get componentTID(): number;
    /**
     * Gets the Type ID of this Component instance.
     * This is overridden by concrete component classes to provide unique type identification.
     *
     * @returns The component type ID (default: 0)
     */
    get componentTID(): number;
    /**
     * Gets the Scoped ID of this Component instance.
     * The SID is unique within the component type and represents the instance index.
     *
     * @returns The component scoped ID
     */
    get componentSID(): number;
    /**
     * Gets the unique ID of the entity that owns this component.
     *
     * @returns The entity unique ID
     */
    get entityUID(): number;
    /**
     * Gets the current process stage of the component.
     * This determines which update methods are currently being called.
     *
     * @returns The current process stage
     */
    get currentProcessStage(): ProcessStageEnum;
    /**
     * Checks whether the specified ProcessStage method exists in the given Component class.
     * This is used to determine if a component can handle a particular process stage.
     *
     * @param componentType - The component class to check
     * @param processStage - The process stage to check for
     * @returns True if the method exists, false otherwise
     */
    static doesTheProcessStageMethodExist(componentType: typeof Component, processStage: ProcessStageEnum): boolean;
    /**
     * Checks whether the specified ProcessStage method exists in this Component instance.
     * This is used to determine if this component can handle a particular process stage.
     *
     * @param processStage - The process stage to check for
     * @returns True if the method exists, false otherwise
     */
    isExistProcessStageMethod(processStage: ProcessStageEnum): boolean;
    /**
     * Processes all components of a given type for a specific process stage.
     * This method iterates through all components of the specified type and calls
     * their corresponding process stage method if they are in that stage.
     *
     * @param componentType - The component class to process
     * @param processStage - The process stage to execute
     */
    static process(componentType: typeof Component, processStage: ProcessStageEnum): void;
    /**
     * Updates components specifically for the render stage with render pass context.
     * This method calls the sort_$render method of the component class to handle
     * render-specific processing and sorting.
     *
     * @param componentClass - The component class to update
     * @param processStage - The render process stage
     * @param renderPass - The current render pass context
     * @returns The result of the sort_$render method
     */
    static updateComponentsForRenderStage(componentClass: typeof Component, _processStage: ProcessStageEnum, renderPass: RenderPass): any;
    /**
     * Gets the total byte length of all member fields for a specific buffer use type
     * in the given component class.
     *
     * @param bufferUse - The buffer use type
     * @param componentClass - The component class
     * @returns The total byte length of members
     */
    static getByteLengthSumOfMembers(bufferUse: BufferUseEnum, componentClass: Function): number;
    /**
     * Registers a dependency relationship with another component.
     * This method is intended for future use in managing component dependencies.
     *
     * @param component - The component to depend on
     * @param isMust - Whether this dependency is required
     * @todo This method is not used yet and needs implementation
     */
    registerDependency(_component: Component, _isMust: boolean): void;
    /**
     * Allocates memory for a specific member field of this component instance.
     * This method takes one memory slot from the shared memory pool for the specified member.
     *
     * @param memberName - The name of the member field
     * @param dataClassType - The data class type for the member
     * @param initValues - Initial values to set for the member
     * @param isReUse - Whether to reuse an existing memory slot
     * @param componentSid - The component scoped ID
     * @returns null on success
     */
    takeOne(memberName: string, dataClassType: any, initValues: number[], isReUse: boolean, componentSid: ComponentSID): any;
    /**
     * Gets the memory accessor for a specific member field of a component class.
     * The accessor provides access to the underlying typed array data.
     *
     * @param memberName - The name of the member field
     * @param componentClass - The component class
     * @returns The accessor for the member field
     */
    static getAccessor(memberName: string, componentClass: Function): Accessor;
    /**
     * Creates and configures a memory accessor for a specific member field.
     * This method allocates buffer memory and creates an accessor for efficient data access.
     *
     * @param bufferUse - The intended use of the buffer
     * @param memberName - The name of the member field
     * @param componentClass - The component class
     * @param compositionType - The composition type (e.g., Vec3, Mat4)
     * @param componentType - The component data type (e.g., Float32, Int32)
     * @param count - The number of components to allocate for
     * @returns Result containing the accessor or an error
     */
    static takeAccessor(bufferUse: BufferUseEnum, memberName: string, componentClass: Function, compositionType: CompositionTypeEnum, componentType: ComponentTypeEnum, count: Count): Result<Accessor, undefined>;
    /**
     * Gets the byte offset of the component type's data within the buffer.
     *
     * @param bufferUse - The buffer use type
     * @param componentClass - The component class
     * @returns The byte offset in the buffer
     */
    static getByteOffsetOfThisComponentTypeInBuffer(bufferUse: BufferUseEnum, componentClass: Function): Byte$1;
    /**
     * Gets the byte offset of the first element of a specific member field within the buffer.
     *
     * @param memberName - The name of the member field
     * @param componentClass - The component class
     * @returns The byte offset in the buffer
     */
    static getByteOffsetOfFirstOfThisMemberInBuffer(memberName: string, componentClass: Function): Byte$1;
    /**
     * Gets the byte offset of the first element of a specific member field within the buffer view.
     *
     * @param memberName - The name of the member field
     * @param componentClass - The component class
     * @returns The byte offset in the buffer view
     */
    static getByteOffsetOfFirstOfThisMemberInBufferView(memberName: string, componentClass: Function): Byte$1;
    /**
     * Registers a member field of the component class for memory allocation.
     * This method defines the memory layout and characteristics of component data members.
     *
     * @param bufferUse - The intended purpose/type of buffer use
     * @param memberName - The name of the member field
     * @param dataClassType - The class type of the data
     * @param componentType - The primitive data type (e.g., Float32, Int32)
     * @param initValues - Initial values for the member field
     */
    registerMember(bufferUse: BufferUseEnum, memberName: string, dataClassType: unknown, componentType: ComponentTypeEnum, initValues: number[]): void;
    /**
     * Allocates memory for all member fields of this component instance.
     * This method is called during component initialization to set up memory layout
     * and allocate space for the specified number of entities.
     *
     * @param count - The number of entities to allocate memory for
     * @param isReUse - Whether to reuse existing memory allocations
     */
    submitToAllocation(count: Count, isReUse: boolean): void;
    /**
     * Gets the entity that owns this component.
     * This provides access to the entity and its other components.
     *
     * @returns The entity instance that owns this component
     */
    get entity(): IEntity;
    /**
     * Gets detailed byte information about a specific member field of a component.
     * This includes offsets, lengths, and location information for GPU access.
     *
     * @param component - The component instance to analyze
     * @param memberName - The name of the member field
     * @returns Detailed byte information object
     */
    static getDataByteInfoInner(component: Component, memberName: string): {
        byteLength: number;
        byteOffsetInBuffer: number;
        byteOffsetInThisComponent: any;
        locationOffsetInBuffer: number;
        locationOffsetInThisComponent: any;
        thisComponentByteOffsetInBuffer: number;
        thisComponentLocationOffsetInBuffer: number;
        componentNumber: number;
    };
    /**
     * Gets detailed byte information about a specific member field of this component.
     * This includes offsets, lengths, and location information for GPU access.
     *
     * @param memberName - The name of the member field
     * @returns Detailed byte information object
     */
    getDataByteInfo(memberName: string): {
        byteLength: number;
        byteOffsetInBuffer: number;
        byteOffsetInThisComponent: any;
        locationOffsetInBuffer: number;
        locationOffsetInThisComponent: any;
        thisComponentByteOffsetInBuffer: number;
        thisComponentLocationOffsetInBuffer: number;
        componentNumber: number;
    };
    /**
     * Gets detailed byte information about a member field by Component SID.
     * This is a static version that looks up the component by its scoped ID.
     *
     * @param componentType - The component class type
     * @param componentSID - The scoped ID of the component
     * @param memberName - The name of the member field
     * @returns Detailed byte information object or undefined if component not found
     */
    static getDataByteInfoByComponentSID(componentType: typeof Component, componentSID: ComponentSID, memberName: string): {
        byteLength: number;
        byteOffsetInBuffer: number;
        byteOffsetInThisComponent: any;
        locationOffsetInBuffer: number;
        locationOffsetInThisComponent: any;
        thisComponentByteOffsetInBuffer: number;
        thisComponentLocationOffsetInBuffer: number;
        componentNumber: number;
    } | undefined;
    /**
     * Gets the pixel location offset in the buffer for a specific member of a component type.
     * This is useful for GPU texture-based data access where locations are measured in pixels.
     *
     * @param componentType - The component class type
     * @param memberName - The name of the member field
     * @returns The pixel location offset in the buffer
     */
    static getLocationOffsetOfMemberOfComponent(componentType: typeof Component, memberName: string): number;
    /**
     * Adds this component to an entity, extending the entity with component-specific methods.
     * This is a virtual method that should be overridden by concrete component classes.
     *
     * @virtual
     * @param base - The target entity to add this component to
     * @param _componentClass - The component class being added
     * @returns The entity extended with component methods
     * @throws Error indicating invalid calling of virtual method
     */
    addThisComponentToEntity<EntityBase extends IEntity, SomeComponentClass extends typeof Component>(_base: EntityBase, _componentClass: SomeComponentClass): EntityBase & ComponentToComponentMethods<SomeComponentClass>;
    /**
     * Gets the CompositionType of a specific member field in a component class.
     * This is useful for understanding the data structure of component members.
     *
     * @param memberName - The name of the member field
     * @param componentClass - The component class to query
     * @returns The CompositionType of the member or undefined if not found
     */
    static getCompositionTypeOfMember(memberName: string, componentClass: Function): CompositionTypeEnum | undefined;
    /**
     * Gets the ComponentType of a specific member field in a component class.
     * This is useful for understanding the primitive data type of component members.
     *
     * @param memberName - The name of the member field
     * @param componentClass - The component class to query
     * @returns The ComponentType of the member or undefined if not found
     */
    static getComponentTypeOfMember(memberName: string, componentClass: Function): ComponentTypeEnum | undefined;
    /**
     * Marks this component as destroyed and no longer alive.
     * This is used internally to manage component lifecycle.
     *
     * @internal
     */
    _destroy(): void;
    /**
     * Performs a shallow copy of data from another component of the same type.
     * This method should be implemented by concrete component classes as needed.
     *
     * @param component - The source component to copy from
     */
    _shallowCopyFrom(_component: Component): void;
}

/**
 * The view frustum class.
 * Represents a truncated pyramid (frustum) used for view culling in 3D graphics.
 * Contains six planes (top, bottom, left, right, near, far) and eight corner vertices.
 */
declare class Frustum {
    top: MutableVector4;
    bottom: MutableVector4;
    right: MutableVector4;
    left: MutableVector4;
    zNear: MutableVector4;
    zFar: MutableVector4;
    private __updated;
    private __vp;
    private __invProjMat;
    private __invViewMat;
    private __tmp_vec4_0;
    private __tmp_vec4_1;
    private __tmp_vec4_array;
    private __hCorners;
    corners: Vector4[];
    /**
     * Updates this view frustum data from the view and projection matrices.
     * Calculates the six frustum planes and eight corner vertices in world space.
     * This method should be called whenever the camera's view or projection matrix changes.
     *
     * @param viewMatrix - The view matrix that transforms from world space to view space
     * @param projectionMatrix - The projection matrix that transforms from view space to clip space
     *
     * @remarks
     * The frustum planes are calculated using the combined view-projection matrix.
     * Corner vertices are computed by transforming normalized device coordinates back to world space.
     * The planes are stored as Vector4 where (x,y,z) is the normal and w is the distance from origin.
     */
    update(viewMatrix: Matrix44, projectionMatrix: Matrix44): void;
    /**
     * Performs frustum culling test against a mesh component's bounding box.
     * Uses optimized frustum-AABB intersection algorithm to determine visibility.
     *
     * @param meshComponent - The mesh component to test for culling
     * @returns `false` if the mesh is completely outside the frustum (should be culled),
     *          `true` if the mesh is inside or intersects the frustum (should be rendered)
     *
     * @remarks
     * This method uses a two-phase approach:
     * 1. Tests if the AABB is completely outside any frustum plane
     * 2. Tests if all frustum corners are outside any AABB face
     *
     * The algorithm is based on the optimized frustum culling technique described at:
     * https://iquilezles.org/articles/frustumcorrect/
     *
     * @example
     * ```typescript
     * const frustum = new Frustum();
     * frustum.update(viewMatrix, projectionMatrix);
     *
     * if (frustum.culling(meshComponent)) {
     *   // Render the mesh
     *   renderMesh(meshComponent);
     * }
     * // Otherwise, skip rendering (culled)
     * ```
     */
    culling(meshComponent: MeshComponent): boolean;
    /**
     * Retrieves a specific frustum plane by index.
     *
     * @param i - The plane index (0-5)
     *   - 0: Top plane
     *   - 1: Bottom plane
     *   - 2: Right plane
     *   - 3: Left plane
     *   - 4: Near plane
     *   - 5: Far plane
     *
     * @returns The plane as a Vector4 where (x,y,z) represents the plane normal
     *          and w represents the distance from the origin
     *
     * @throws {Error} Throws an error if the plane index is invalid (not 0-5)
     *
     * @example
     * ```typescript
     * const frustum = new Frustum();
     * const topPlane = frustum.getPlane(0);    // Get top plane
     * const nearPlane = frustum.getPlane(4);   // Get near plane
     * ```
     */
    getPlane(i: Index): MutableVector4;
}

/**
 * The Component that represents a camera.
 *
 * @remarks
 * The camera is defined such that the local +X axis is to the right,
 * the "lens" looks towards the local -Z axis,
 * and the top of the camera is aligned with the local +Y axis.
 */
declare class CameraComponent extends Component {
    private static readonly _eye;
    private _eyeInner;
    private _direction;
    private _directionInner;
    private _up;
    private _upInner;
    private _filmWidth;
    private _filmHeight;
    private _focalLength;
    private primitiveMode;
    private _corner;
    private _cornerInner;
    private _parameters;
    private _parametersInner;
    private __type;
    private _projectionMatrix;
    private __isProjectionMatrixUpToDate;
    private _viewMatrix;
    private __isViewMatrixUpToDate;
    private static __current;
    private static returnVector3;
    private static __globalDataRepository;
    private static __tmpVector3_0;
    private static __tmpVector3_1;
    private static __tmpVector3_2;
    private static __tmpMatrix44_0;
    private static __tmpMatrix44_1;
    private static __biasMatrixWebGL;
    private static __biasMatrixWebGPU;
    _xrLeft: boolean;
    _xrRight: boolean;
    isSyncToLight: boolean;
    private __frustum;
    private __updateCount;
    private __lastUpdateCount;
    private __lastTransformComponentsUpdateCount;
    private __lastLightComponentsUpdateCount;
    private __lastCameraControllerComponentsUpdateCount;
    /**
     * Creates a new CameraComponent instance.
     *
     * @param entityUid - The unique identifier of the entity this component belongs to
     * @param componentSid - The component system identifier
     * @param entityRepository - The entity repository instance
     * @param isReUse - Whether this component is being reused from a pool
     */
    constructor(entityUid: EntityUID, componentSid: ComponentSID, entityRepository: EntityRepository, isReUse: boolean);
    /**
     * Sets the current active camera component.
     *
     * @param componentSID - The component system identifier of the camera to set as current
     */
    static set current(componentSID: ComponentSID);
    /**
     * Gets the current active camera component ID.
     *
     * @returns The component system identifier of the current active camera
     */
    static get current(): ComponentSID;
    /**
     * Gets the update count for this camera component.
     *
     * @returns The number of times this camera has been updated
     */
    get updateCount(): number;
    /**
     * Gets the update count of the current active camera.
     *
     * @returns The update count of the current camera, or 0 if no camera is active
     */
    static get currentCameraUpdateCount(): number;
    /**
     * Sets the camera type (perspective, orthographic, or frustum).
     *
     * @param type - The camera type to set
     */
    set type(type: CameraTypeEnum);
    /**
     * Gets the camera type.
     *
     * @returns The current camera type
     */
    get type(): CameraTypeEnum;
    /**
     * Gets the camera eye position (always (0,0,0) in Rhodonite).
     *
     * @returns The eye position vector (always zero)
     */
    get eye(): Vector3;
    /**
     * Attempts to set the eye position (throws error as this is not supported).
     *
     * @param noUseVec - The vector to set (not used)
     * @throws Always throws an error as eye positioning should use TransformComponent
     */
    set eye(_noUseVec: Vector3);
    /**
     * Gets the internal eye position.
     *
     * @returns The internal eye position vector
     */
    get eyeInner(): Vector3;
    /**
     * Sets the internal eye position.
     *
     * @param vec - The vector to set as the internal eye position
     * @internal
     */
    set eyeInner(vec: Vector3);
    /**
     * Sets the internal up vector.
     *
     * @param vec - The vector to set as the internal up direction
     */
    set upInner(vec: Vector3);
    /**
     * Sets the up vector of the camera.
     *
     * @param vec - The vector to set as the up direction
     */
    set up(vec: Vector3);
    /**
     * Gets the up vector of the camera.
     *
     * @returns A copy of the up vector
     */
    get up(): Vector3;
    /**
     * Gets the internal up vector.
     *
     * @returns The internal up vector
     */
    get upInner(): Vector3;
    /**
     * Sets the direction vector of the camera and automatically adjusts the up vector to remain orthogonal.
     *
     * @param vec - The new direction vector for the camera
     */
    set direction(vec: Vector3);
    /**
     * Sets the internal direction vector.
     *
     * @param vec - The vector to set as the internal direction
     */
    set directionInner(vec: Vector3);
    /**
     * Gets the direction vector of the camera.
     *
     * @returns A copy of the direction vector
     */
    get direction(): Vector3;
    /**
     * Gets the internal direction vector.
     *
     * @returns The internal direction vector
     */
    get directionInner(): Vector3;
    /**
     * Sets the corner parameters (left, right, top, bottom) for frustum camera.
     *
     * @param vec - The corner vector (x: left, y: right, z: top, w: bottom)
     */
    set corner(vec: Vector4);
    /**
     * Gets the corner parameters.
     *
     * @returns A copy of the corner vector
     */
    get corner(): Vector4;
    /**
     * Sets the left clipping plane position.
     *
     * @param value - The left clipping plane position
     */
    set left(value: number);
    /**
     * Sets the internal left clipping plane position.
     *
     * @param value - The internal left clipping plane position
     */
    set leftInner(value: number);
    /**
     * Gets the left clipping plane position.
     *
     * @returns The left clipping plane position
     */
    get left(): number;
    /**
     * Sets the right clipping plane position.
     *
     * @param value - The right clipping plane position
     */
    set right(value: number);
    /**
     * Sets the internal right clipping plane position.
     *
     * @param value - The internal right clipping plane position
     */
    set rightInner(value: number);
    /**
     * Gets the right clipping plane position.
     *
     * @returns The right clipping plane position
     */
    get right(): number;
    /**
     * Sets the top clipping plane position.
     *
     * @param value - The top clipping plane position
     */
    set top(value: number);
    /**
     * Sets the internal top clipping plane position.
     *
     * @param value - The internal top clipping plane position
     */
    set topInner(value: number);
    /**
     * Gets the top clipping plane position.
     *
     * @returns The top clipping plane position
     */
    get top(): number;
    /**
     * Sets the bottom clipping plane position.
     *
     * @param value - The bottom clipping plane position
     */
    set bottom(value: number);
    /**
     * Sets the internal bottom clipping plane position.
     *
     * @param value - The internal bottom clipping plane position
     */
    set bottomInner(value: number);
    /**
     * Gets the bottom clipping plane position.
     *
     * @returns The bottom clipping plane position
     */
    get bottom(): number;
    /**
     * Sets the internal corner parameters.
     *
     * @param vec - The internal corner vector
     */
    set cornerInner(vec: Vector4);
    /**
     * Gets the internal corner parameters.
     *
     * @returns The internal corner vector
     */
    get cornerInner(): Vector4;
    /**
     * Sets the internal camera parameters.
     *
     * @param vec - The internal parameters vector
     */
    set parametersInner(vec: Vector4);
    /**
     * Gets the internal camera parameters.
     *
     * @returns The internal parameters vector
     */
    get parametersInner(): Vector4;
    /**
     * Gets the camera parameters.
     *
     * @returns A copy of the parameters vector
     */
    get parameters(): Vector4;
    /**
     * Sets the near clipping plane distance.
     *
     * @param val - The near clipping plane distance
     */
    set zNear(val: number);
    /**
     * Sets the internal near clipping plane distance.
     *
     * @param val - The internal near clipping plane distance
     */
    set zNearInner(val: number);
    /**
     * Gets the internal near clipping plane distance.
     *
     * @returns The internal near clipping plane distance
     */
    get zNearInner(): number;
    /**
     * Gets the near clipping plane distance.
     *
     * @returns The near clipping plane distance
     */
    get zNear(): number;
    /**
     * Sets the focal length and automatically calculates the field of view.
     *
     * @param val - The focal length in millimeters
     */
    set focalLength(val: number);
    /**
     * Gets the focal length.
     *
     * @returns The focal length in millimeters
     */
    get focalLength(): number;
    /**
     * Sets the internal focal length and calculates the field of view.
     *
     * @param val - The internal focal length
     */
    set focalLengthInner(val: number);
    /**
     * Gets the internal focal length.
     *
     * @returns The internal focal length
     */
    get focalLengthInner(): number;
    /**
     * Sets the far clipping plane distance.
     *
     * @param val - The far clipping plane distance
     */
    set zFar(val: number);
    /**
     * Sets the internal far clipping plane distance.
     *
     * @param val - The internal far clipping plane distance
     */
    set zFarInner(val: number);
    /**
     * Gets the internal far clipping plane distance.
     *
     * @returns The internal far clipping plane distance
     */
    get zFarInner(): number;
    /**
     * Gets the far clipping plane distance.
     *
     * @returns The far clipping plane distance
     */
    get zFar(): number;
    /**
     * Sets the field of view and adjusts the film size accordingly.
     *
     * @param degree - The field of view in degrees
     */
    setFovyAndChangeFilmSize(degree: number): void;
    /**
     * Sets the field of view and adjusts the focal length accordingly.
     *
     * @param degree - The field of view in degrees
     */
    setFovyAndChangeFocalLength(degree: number): void;
    /**
     * Gets the field of view.
     *
     * @returns The field of view in degrees
     */
    get fovy(): number;
    /**
     * Sets the internal field of view.
     *
     * @param val - The internal field of view in degrees
     */
    set fovyInner(val: number);
    /**
     * Sets the aspect ratio and adjusts the film width accordingly.
     *
     * @param val - The aspect ratio (width/height)
     */
    set aspect(val: number);
    /**
     * Sets the internal aspect ratio.
     *
     * @param val - The internal aspect ratio
     */
    set aspectInner(val: number);
    /**
     * Gets the internal aspect ratio.
     *
     * @returns The internal aspect ratio
     */
    get aspectInner(): number;
    /**
     * Gets the aspect ratio.
     *
     * @returns The aspect ratio
     */
    get aspect(): number;
    /**
     * Sets the X magnification for orthographic projection.
     *
     * @param val - The X magnification value
     */
    set xMag(val: number);
    /**
     * Gets the X magnification for orthographic projection.
     *
     * @returns The X magnification value
     */
    get xMag(): number;
    /**
     * Sets the Y magnification for orthographic projection.
     *
     * @param val - The Y magnification value
     */
    set yMag(val: number);
    /**
     * Gets the Y magnification for orthographic projection.
     *
     * @returns The Y magnification value
     */
    get yMag(): number;
    /**
     * Gets the component type identifier for camera components.
     *
     * @returns The camera component type identifier
     */
    static get componentTID(): ComponentTID;
    /**
     * Gets the component type identifier for this camera component.
     *
     * @returns The camera component type identifier
     */
    get componentTID(): ComponentTID;
    /**
     * Calculates and returns the projection matrix based on camera parameters.
     *
     * @returns The calculated projection matrix
     */
    calcProjectionMatrix(): MutableMatrix44;
    /**
     * Calculates and returns the view matrix based on camera position and orientation.
     *
     * @returns The calculated view matrix
     */
    calcViewMatrix(): MutableMatrix44;
    /**
     * Gets the view matrix.
     *
     * @returns The view matrix
     */
    get viewMatrix(): Matrix44;
    /**
     * Sets the view matrix.
     *
     * @param viewMatrix - The view matrix to set
     */
    set viewMatrix(viewMatrix: Matrix44);
    /**
     * Gets the projection matrix, considering XR mode if applicable.
     *
     * @returns The projection matrix (may be XR-specific matrix if in XR mode)
     */
    get projectionMatrix(): Matrix44;
    /**
     * Sets the projection matrix.
     *
     * @param projectionMatrix - The projection matrix to set
     */
    set projectionMatrix(projectionMatrix: Matrix44);
    /**
     * Gets the combined view-projection matrix.
     *
     * @returns The view-projection matrix
     */
    get viewProjectionMatrix(): MutableMatrix44;
    /**
     * Gets the bias view-projection matrix for shadow mapping.
     *
     * @returns The bias view-projection matrix adjusted for the current graphics API
     */
    get biasViewProjectionMatrix(): MutableMatrix44;
    /**
     * Sets only the matrix values to the global data repository.
     */
    setValuesToGlobalDataRepositoryOnlyMatrices(): void;
    /**
     * Sets camera values (matrices and position) to the global data repository.
     */
    setValuesToGlobalDataRepository(): void;
    /**
     * Gets the world position of the camera.
     *
     * @returns The world position vector
     */
    get worldPosition(): MutableVector3;
    /**
     * Updates the camera frustum based on current view and projection matrices.
     */
    updateFrustum(): void;
    /**
     * Gets the camera frustum for culling operations.
     *
     * @returns The camera frustum
     */
    get frustum(): Frustum;
    /**
     * Loads the camera component and moves it to the logic stage.
     *
     * @internal
     */
    $load(): void;
    /**
     * Executes the logic update for the camera component.
     * Updates view and projection matrices, handles light synchronization, and manages XR mode.
     *
     * @internal
     */
    $logic(): void;
    /**
     * Gets the entity that has the current active camera component.
     *
     * @returns The entity with the current camera component
     */
    static getCurrentCameraEntity(): ICameraEntity;
    /**
     * Gets the entity which has this camera component.
     *
     * @returns The entity which has this component
     */
    get entity(): ICameraEntity;
    /**
     * Adds this camera component to an entity, extending it with camera-specific methods.
     *
     * @param base - The target entity
     * @param _componentClass - The component class to add
     * @returns The entity extended with camera component methods
     * @override
     */
    addThisComponentToEntity<EntityBaseClass extends IEntity, SomeComponentClass extends typeof Component>(base: EntityBaseClass, _componentClass: SomeComponentClass): ComponentToComponentMethods<SomeComponentClass> & EntityBaseClass;
}

/**
 * AbstractCameraController is an abstract class that defines the interface for camera controllers.
 *
 * @internal
 */
declare abstract class AbstractCameraController {
    zNearMax: number;
    zFarScalingFactor: number;
    autoCalculateZNearAndZFar: boolean;
    protected abstract __targetEntities: ISceneGraphEntity[];
    /**
     * Calculates the near clipping plane (zNear) for the camera based on the target entities' bounding boxes.
     * This method is used when autoCalculateZNearAndZFar is enabled and there are target entities.
     * @param camera - The camera component to update.
     * @param eyePosition - The position of the camera's eye in world space.
     * @param eyeDirection - The direction the camera is facing.
     */
    protected _calcZNearInner(camera: CameraComponent, eyePosition: Vector3, eyeDirection: Vector3): void;
    /**
     * Calculates the far clipping plane (zFar) for the camera based on the near clipping plane and a scaling factor.
     * This method is used when autoCalculateZNearAndZFar is enabled.
     * @param camera - The camera component to update.
     */
    protected _calcZFarInner(camera: CameraComponent): void;
    abstract setTarget(targetEntity: ISceneGraphEntity): void;
    abstract setTargets(targetEntities: ISceneGraphEntity[]): void;
    abstract getTargets(): ISceneGraphEntity[];
}

/**
 * OrbitCameraController is a camera controller that allows the user to orbit around a target.
 *
 */
declare class OrbitCameraController extends AbstractCameraController implements ICameraController {
    dollyScale: number;
    scaleOfLengthCenterToCamera: number;
    moveSpeed: number;
    followTargetAABB: boolean;
    autoUpdate: boolean;
    private __updated;
    private __updateCount;
    private __fixedLengthOfCenterToEye;
    private __isMouseDown;
    private __lastMouseDownTimeStamp;
    private __lastMouseUpTimeStamp;
    private __originalY;
    private __originalX;
    private __buttonNumber;
    private __mouse_translate_y;
    private __mouse_translate_x;
    private __efficiency;
    private __lengthOfCenterToEye;
    private __fovyBias;
    private __scaleOfTranslation;
    private __mouseTranslateVec;
    private __newEyeVec;
    private __newCenterVec;
    private __newUpVec;
    private __newTangentVec;
    private __isSymmetryMode;
    private __rot_bgn_x;
    private __rot_bgn_y;
    private __rot_x;
    private __rot_y;
    private __dolly;
    private __eyeVec;
    private __centerVec;
    private __upVec;
    protected __targetEntities: ISceneGraphEntity[];
    private __scaleOfZNearAndZFar;
    private __doPreventDefault;
    private __isPressingShift;
    private __isPressingCtrl;
    private __pinchInOutControl;
    private __pinchInOutOriginalDistance?;
    private __maximum_y?;
    private __minimum_y?;
    private __resetDollyTouchTime;
    private __initialTargetAABB?;
    aabbWithSkeletal: boolean;
    useInitialTargetAABBForLength: boolean;
    private __mouseDownFunc;
    private __mouseUpFunc;
    private __mouseMoveFunc;
    private __touchDownFunc;
    private __touchUpFunc;
    private __touchMoveFunc;
    private __pinchInOutFunc;
    private __pinchInOutEndFunc;
    private __mouseWheelFunc;
    private __mouseDblClickFunc;
    private __contextMenuFunc;
    private __pressShiftFunc;
    private __releaseShiftFunc;
    private __pressCtrlFunc;
    private __releaseCtrlFunc;
    private __resetDollyAndPositionFunc;
    private static readonly __tmp_up;
    private static __tmpVec3_0;
    private static __tmpVec3_1;
    private static __tmpVec3_2;
    private static __tmp_rotateM_X;
    private static __tmp_rotateM_Y;
    private static __tmp_rotateM;
    private static __tmp_rotateM_Reset;
    private static __tmp_rotateM_Revert;
    private static __tmpMat44_0;
    private __cameraControllerComponent;
    constructor(cameraControllerComponent: CameraControllerComponent);
    /**
     * Gets the current update count.
     * @returns The current update count
     */
    get updateCount(): number;
    /**
     * Updates the update count and notifies the camera controller component.
     * @internal
     */
    private _updateCount;
    /**
     * Resets the dolly and translation values to their default state.
     */
    resetDollyAndTranslation(): void;
    /**
     * Sets a single target entity for the camera to focus on.
     * @param targetEntity - The entity to set as target
     */
    setTarget(targetEntity: ISceneGraphEntity): void;
    /**
     * Sets multiple target entities for the camera to focus on.
     * @param targetEntities - Array of entities to set as targets
     */
    setTargets(targetEntities: ISceneGraphEntity[]): void;
    /**
     * Gets the current target entities.
     * @returns Array of target entities
     */
    getTargets(): ISceneGraphEntity[];
    /**
     * Sets whether to prevent default behavior on events.
     * @param flag - True to prevent default, false otherwise
     */
    set doPreventDefault(flag: boolean);
    /**
     * Gets whether default behavior is prevented on events.
     * @returns True if default is prevented, false otherwise
     */
    get doPreventDefault(): boolean;
    /**
     * Handles mouse down events.
     * @param e - The mouse event
     * @internal
     */
    __mouseDown(e: MouseEvent): void;
    /**
     * Handles mouse move events for camera control.
     * @param e - The mouse event
     * @internal
     */
    __mouseMove(e: MouseEvent): void;
    /**
     * Handles mouse up events.
     * @param e - The mouse event
     * @internal
     */
    __mouseUp(e: MouseEvent): void;
    /**
     * Handles touch down events.
     * @param e - The touch event
     * @internal
     */
    __touchDown(e: TouchEvent): void;
    /**
     * Handles touch move events for camera control.
     * @param e - The touch event
     * @internal
     */
    __touchMove(e: TouchEvent): void;
    /**
     * Handles touch up events.
     * @param e - The touch event
     * @internal
     */
    __touchUp(e: TouchEvent): void;
    /**
     * Sets the X-axis rotation value.
     * @param value - The rotation value in degrees
     */
    set rotX(value: number);
    /**
     * Gets the X-axis rotation value.
     * @returns The rotation value in degrees
     */
    get rotX(): number;
    /**
     * Sets the Y-axis rotation value.
     * @param value - The rotation value in degrees
     */
    set rotY(value: number);
    /**
     * Gets the Y-axis rotation value.
     * @returns The rotation value in degrees
     */
    get rotY(): number;
    /**
     * Sets the maximum Y rotation angle limit.
     * @param maximum_y - The maximum Y rotation angle
     */
    set maximumY(maximum_y: number);
    /**
     * Sets the minimum Y rotation angle limit.
     * @param minimum_y - The minimum Y rotation angle
     */
    set minimumY(minimum_y: number);
    /**
     * Controls rotation based on mouse/touch movement.
     * @param originalX - Original X position
     * @param originalY - Original Y position
     * @param currentX - Current X position
     * @param currentY - Current Y position
     * @internal
     */
    __rotateControl(originalX: Size, originalY: Size, currentX: Size, currentY: Size): void;
    /**
     * Controls zoom/dolly based on mouse movement.
     * @param originalValue - Original position value
     * @param currentValue - Current position value
     * @internal
     */
    __zoomControl(originalValue: Size, currentValue: Size): void;
    /**
     * Controls parallel translation based on mouse/touch movement.
     * @param originalX - Original X position
     * @param originalY - Original Y position
     * @param currentX - Current X position
     * @param currentY - Current Y position
     * @internal
     */
    __parallelTranslateControl(originalX: Size, originalY: Size, currentX: Size, currentY: Size): void;
    /**
     * Calculates the distance between two touch points.
     * @param e - The touch event
     * @returns The distance between touch points
     * @internal
     */
    __getTouchesDistance(e: TouchEvent): number;
    /**
     * Handles pinch in/out gestures for zoom control.
     * @param e - The touch event
     * @internal
     */
    __pinchInOut(e: TouchEvent): void;
    /**
     * Handles the end of pinch in/out gestures.
     * @param e - The touch event
     * @internal
     */
    __pinchInOutEnd(e: TouchEvent): void;
    /**
     * Tries to prevent default behavior if configured to do so.
     * @param evt - The event to prevent default on
     * @internal
     */
    private __tryToPreventDefault;
    /**
     * Handles mouse wheel events for zoom control.
     * @param evt - The wheel event
     * @internal
     */
    __mouseWheel(evt: WheelEvent): void;
    /**
     * Handles context menu events.
     * @param evt - The context menu event
     * @internal
     */
    __contextMenu(evt: Event): void;
    /**
     * Sets the dolly (zoom) value with gamma correction.
     * @param value - The dolly value (0-1)
     */
    set dolly(value: number);
    /**
     * Gets the dolly (zoom) value with gamma correction.
     * @returns The dolly value (0-1)
     */
    get dolly(): number;
    /**
     * Handles mouse double-click events for resetting camera state.
     * @param evt - The mouse event
     * @internal
     */
    __mouseDblClick(evt: MouseEvent): void;
    /**
     * Resets dolly and position on double tap for touch devices.
     * @param e - The touch event
     * @internal
     */
    __resetDollyAndPosition(e: TouchEvent): void;
    /**
     * Handles shift key press events.
     * @param e - The keyboard event
     * @internal
     */
    __pressShift(e: KeyboardEvent): void;
    /**
     * Handles shift key release events.
     * @param e - The keyboard event
     * @internal
     */
    __releaseShift(e: KeyboardEvent): void;
    /**
     * Handles ctrl key press events.
     * @param e - The keyboard event
     * @internal
     */
    __pressCtrl(e: KeyboardEvent): void;
    /**
     * Handles ctrl key release events.
     * @param e - The keyboard event
     * @internal
     */
    __releaseCtrl(e: KeyboardEvent): void;
    /**
     * Registers event listeners for mouse, touch, and keyboard events.
     */
    registerEventListeners(): void;
    /**
     * Unregisters all event listeners.
     */
    unregisterEventListeners(): void;
    /**
     * Gets the field of view Y value from the camera component.
     * @param camera - The camera component
     * @returns The fovy value in degrees
     * @internal
     */
    __getFovyFromCamera(camera: CameraComponent): number;
    /**
     * Main logic method that updates the camera based on controller state.
     * @param cameraComponent - The camera component to update
     */
    logic(cameraComponent: CameraComponent): void;
    /**
     * Gets the target AABB (Axis-Aligned Bounding Box) for a target entity.
     * @param targetEntity - The target entity
     * @returns The AABB of the target entity
     * @internal
     */
    private __getTargetAABB;
    /**
     * update center, eye and up vectors of OrbitCameraController
     * @internal
     */
    __updateTargeting(camera: CameraComponent): void;
    /**
     * calculate up, eye, center and tangent vector with controller influence
     * @internal
     */
    __calculateInfluenceOfController(): void;
    /**
     * Updates the camera component with new calculated values.
     * @param camera - The camera component to update
     * @internal
     */
    __updateCameraComponent(camera: CameraComponent): void;
    /**
     * Sets the scale factor for zNear and zFar calculations.
     * @param value - The scale factor
     */
    set scaleOfZNearAndZFar(value: number);
    /**
     * Gets the scale factor for zNear and zFar calculations.
     * @returns The scale factor
     */
    get scaleOfZNearAndZFar(): number;
    /**
     * Gets whether the mouse is currently pressed down.
     * @returns True if mouse is down, false otherwise
     */
    get isMouseDown(): boolean;
    /**
     * Gets the timestamp of the last mouse down event.
     * @returns The timestamp in milliseconds
     */
    get lastMouseDownTimeStamp(): number;
    /**
     * Gets the timestamp of the last mouse up event.
     * @returns The timestamp in milliseconds
     */
    get lastMouseUpTimeStamp(): number;
}

/**
 * WalkThroughCameraController is a camera controller that allows the user to walk through a scene.
 *
 */
declare class WalkThroughCameraController extends AbstractCameraController implements ICameraController {
    private __updateCount;
    private _horizontalSpeed;
    private _verticalSpeed;
    private _turnSpeed;
    private _mouseWheelSpeedScale;
    private _inverseVerticalRotating;
    private _inverseHorizontalRotating;
    private _onKeydown;
    private _isKeyDown;
    private _isMouseDrag;
    private _lastKeyCode;
    private _onKeyup;
    private _currentDir;
    private _currentPos;
    private _currentCenter;
    private _currentHorizontalDir;
    private _newDir;
    private _isMouseDown;
    private _clickedMouseXOnCanvas;
    private _clickedMouseYOnCanvas;
    private _draggedMouseXOnCanvas;
    private _draggedMouseYOnCanvas;
    private _deltaMouseXOnCanvas;
    private _deltaMouseYOnCanvas;
    private _mouseXAdjustScale;
    private _mouseYAdjustScale;
    private _deltaY;
    private _deltaX;
    private _mouseUpBind;
    private _mouseDownBind;
    private _mouseMoveBind;
    private _mouseWheelBind;
    private _eventTargetDom?;
    private __doPreventDefault;
    private _needInitialize;
    protected __targetEntities: ISceneGraphEntity[];
    private static __tmpInvMat;
    private static __tmpRotateMat;
    private static __tmp_Vec3_0;
    private static __tmp_Vec3_1;
    aabbWithSkeletal: boolean;
    private __cameraControllerComponent;
    constructor(cameraControllerComponent: CameraControllerComponent, options?: {
        eventTargetDom: Document;
        verticalSpeed: number;
        horizontalSpeed: number;
        turnSpeed: number;
        mouseWheelSpeedScale: number;
        inverseVerticalRotating: boolean;
        inverseHorizontalRotating: boolean;
    });
    /**
     * Updates the internal counter and notifies the camera controller component.
     * @private
     */
    private _updateCount;
    /**
     * Gets the current update count.
     * @returns The current update count
     */
    get updateCount(): number;
    /**
     * Registers event listeners for mouse and keyboard input handling.
     * @param eventTargetDom - The DOM element to attach event listeners to, defaults to document
     */
    registerEventListeners(eventTargetDom?: Document): void;
    /**
     * Unregisters all event listeners for this camera controller.
     */
    unregisterEventListeners(): void;
    /**
     * Attempts to prevent default behavior of events if configured to do so.
     * @param evt - The event to potentially prevent default on
     * @private
     */
    private __tryToPreventDefault;
    /**
     * Handles mouse wheel events for camera movement.
     * @param e - The wheel event
     * @private
     */
    _mouseWheel(e: WheelEvent): void;
    /**
     * Handles mouse down events.
     * @param evt - The mouse event
     * @private
     */
    _mouseDown(evt: MouseEvent): boolean;
    /**
     * Handles mouse move events for camera rotation during drag.
     * @param evt - The mouse event
     * @private
     */
    _mouseMove(evt: MouseEvent): void;
    /**
     * Handles mouse up events to stop dragging.
     * @param evt - The mouse event
     * @private
     */
    _mouseUp(evt: MouseEvent): void;
    /**
     * Attempts to reset the controller state. Currently not implemented.
     */
    tryReset(): void;
    /**
     * Resets the camera controller to its initial state.
     */
    reset(): void;
    /**
     * Main logic method that updates the camera component based on input.
     * @param cameraComponent - The camera component to update
     */
    logic(cameraComponent: CameraComponent): void;
    /**
     * Updates the camera component with new position, direction, and other properties.
     * @param camera - The camera component to update
     * @private
     */
    private __updateCameraComponent;
    /**
     * Gets the current camera direction.
     * @returns The current direction vector or null if not available
     */
    getDirection(): MutableVector3 | null;
    /**
     * Sets the horizontal movement speed.
     * @param value - The new horizontal speed value
     */
    set horizontalSpeed(value: number);
    /**
     * Gets the current horizontal movement speed.
     * @returns The current horizontal speed
     */
    get horizontalSpeed(): number;
    /**
     * Sets the vertical movement speed.
     * @param value - The new vertical speed value
     */
    set verticalSpeed(value: number);
    /**
     * Gets the current vertical movement speed.
     * @returns The current vertical speed
     */
    get verticalSpeed(): number;
    /**
     * Sets the mouse wheel speed scale.
     * @param value - The new mouse wheel speed scale
     */
    set mouseWheelSpeed(value: number);
    /**
     * Gets the current mouse wheel speed scale.
     * @returns The current mouse wheel speed scale
     */
    get mouseWheelSpeed(): number;
    /**
     * Sets a single target entity for the camera to focus on.
     * @param targetEntity - The entity to set as the target
     */
    setTarget(targetEntity: ISceneGraphEntity): void;
    /**
     * Gets the axis-aligned bounding box for a target entity.
     * @param targetEntity - The entity to get the AABB for
     * @returns The AABB of the target entity
     * @private
     */
    private __getTargetAABB;
    /**
     * Sets multiple target entities for the camera to focus on.
     * Automatically adjusts movement speeds based on the size of the targets.
     * @param targetEntities - Array of entities to set as targets
     */
    setTargets(targetEntities: ISceneGraphEntity[]): void;
    /**
     * Gets the current target entities.
     * @returns Array of current target entities
     */
    getTargets(): ISceneGraphEntity[];
    /**
     * Gets all camera controller information for serialization.
     * @returns Object containing all controller state information
     */
    get allInfo(): any;
    /**
     * Sets all camera controller information from serialized data.
     * @param arg - Object or JSON string containing controller state information
     */
    set allInfo(arg: any);
}

declare const defaultAnimationTrackName = "Default";

declare function createCameraEntity(): ICameraEntity;

declare function createCameraControllerEntity(): ICameraControllerEntity;

declare function createLightEntity(): ILightEntity;

declare function createMeshEntity(): IMeshEntity;

declare function createPhysicsEntity(): IPhysicsEntity;

declare function createGroupEntity(): ISceneGraphEntity;

/**
 * Collects children and itself from specified sceneGraphComponent.
 * @param sceneGraphComponent collects children and itself from the sceneGraphComponent
 * @param isJointMode collects joints only
 */
declare function flattenHierarchy(sceneGraphComponent: SceneGraphComponent, isJointMode: boolean): SceneGraphComponent[];

declare function createTransformEntity(): ITransformEntity;

declare const WellKnownComponentTIDs: Readonly<{
    AnimationStateComponentTID: 1;
    AnimationComponentTID: 2;
    TransformComponentTID: 3;
    SceneGraphComponentTID: 4;
    MeshComponentTID: 5;
    MeshRendererComponentTID: 6;
    LightComponentTID: 7;
    CameraControllerComponentTID: 8;
    CameraComponentTID: 9;
    SkeletalComponentTID: 10;
    BlendShapeComponentTID: 11;
    PhysicsComponentTID: 12;
    EffekseerComponentTID: 13;
    VrmComponentTID: 14;
    ConstraintComponentTID: 15;
    maxWellKnownTidNumber: 15;
}>;

/**
 * The repository class that manages all component classes and their instances.
 * This class provides functionality to register component classes, create component instances,
 * and manage the lifecycle of components within the ECS (Entity-Component-System) architecture.
 */
declare class ComponentRepository {
    private static __component_sid_count_map;
    private static __components;
    static __componentClasses: Map<ComponentTID, typeof Component>;
    private static __componentTIDs;
    private static __renderingComponentTIDs;
    static readonly invalidComponentSID = -1;
    /**
     * Registers a component class with the repository.
     * This method associates a component class with its unique ComponentTID for later instantiation.
     *
     * @param componentClass - The component class constructor to register
     * @throws {Error} If the component class is invalid or already registered
     *
     * @example
     * ```typescript
     * ComponentRepository.registerComponentClass(MyCustomComponent);
     * ```
     */
    static registerComponentClass(componentClass: typeof Component): void;
    /**
     * Unregisters a component class from the repository.
     * This removes the component class associated with the given ComponentTID.
     *
     * @param componentTID - The ComponentTID of the component class to unregister
     *
     * @example
     * ```typescript
     * ComponentRepository.deregisterComponentClass(MyComponent.componentTID);
     * ```
     */
    static deregisterComponentClass(componentTID: ComponentTID): void;
    /**
     * Retrieves the component class constructor associated with the specified ComponentTID.
     *
     * @param componentTid - The ComponentTID to look up
     * @returns The component class constructor, or undefined if not found
     *
     * @example
     * ```typescript
     * const ComponentClass = ComponentRepository.getComponentClass(componentTID);
     * if (ComponentClass) {
     *   // Use the component class
     * }
     * ```
     */
    static getComponentClass(componentTid: ComponentTID): typeof Component | undefined;
    /**
     * Creates a new component instance for the specified entity.
     * This method handles ComponentSID allocation, including reusing SIDs from deleted components.
     *
     * @param componentTid - The ComponentTID of the component type to create
     * @param entityUid - The EntityUID of the entity that will own this component
     * @param entityRepository - Reference to the entity repository for entity management
     * @returns The newly created component instance
     * @throws {Error} If the component class is not registered or invalid
     *
     * @example
     * ```typescript
     * const component = ComponentRepository.createComponent(
     *   MyComponent.componentTID,
     *   entityUID,
     *   entityRepository
     * );
     * ```
     */
    static createComponent(componentTid: ComponentTID, entityUid: EntityUID, entityRepository: EntityRepository): Component;
    /**
     * Deletes a component instance from the repository.
     * This marks the component's slot as available for reuse and removes it from the active components.
     *
     * @param component - The component instance to delete
     *
     * @example
     * ```typescript
     * ComponentRepository.deleteComponent(myComponent);
     * ```
     */
    static deleteComponent(component: Component): void;
    /**
     * Retrieves a specific component instance by its class and ComponentSID.
     *
     * @param componentClass - The component class to search for
     * @param componentSid - The ComponentSID of the specific component instance
     * @returns The component instance, or undefined if not found
     *
     * @example
     * ```typescript
     * const component = ComponentRepository.getComponent(MyComponent, componentSID);
     * ```
     */
    static getComponent(componentClass: typeof Component, componentSid: ComponentSID): Component | undefined;
    /**
     * Retrieves a specific component instance by ComponentTID and ComponentSID.
     *
     * @param componentTid - The ComponentTID of the component type
     * @param componentSid - The ComponentSID of the specific component instance
     * @returns The component instance, or undefined if not found
     *
     * @example
     * ```typescript
     * const component = ComponentRepository.getComponentFromComponentTID(componentTID, componentSID);
     * ```
     */
    static getComponentFromComponentTID(componentTid: ComponentTID, componentSid: ComponentSID): Component | undefined;
    /**
     * Gets an array of all component instances of the specified type.
     * This is an internal method that includes undefined slots in the array.
     *
     * @internal
     * @param componentClass - The component class to retrieve instances for
     * @returns Array of component instances with potential undefined elements, or undefined if type not found
     */
    static _getComponents(componentClass: typeof Component): Array<Component> | undefined;
    /**
     * Gets an array of all component instances including deleted/dead components.
     * This internal method provides access to the raw component array with undefined slots.
     *
     * @internal
     * @param componentClass - The component class to retrieve instances for
     * @returns Array of component instances including dead components, or undefined if type not found
     */
    static _getComponentsIncludingDead(componentClass: typeof Component): Array<Component> | undefined;
    /**
     * Calculates the memory begin index for a given component type.
     * This is used for memory layout calculations in the component system.
     *
     * @param componentTid - The ComponentTID to calculate the memory index for
     * @returns The starting memory index for the component type
     *
     * @example
     * ```typescript
     * const memoryIndex = ComponentRepository.getMemoryBeginIndex(componentTID);
     * ```
     */
    static getMemoryBeginIndex(componentTid: ComponentTID): number;
    /**
     * Retrieves all active (non-null) component instances of the specified type.
     * This method filters out deleted components and returns only valid instances.
     *
     * @param componentType - The component class to retrieve instances for
     * @returns Array of active component instances (never includes undefined elements)
     *
     * @example
     * ```typescript
     * const activeComponents = ComponentRepository.getComponentsWithType(MyComponent);
     * activeComponents.forEach(component => {
     *   // Process each active component
     * });
     * ```
     */
    static getComponentsWithType(componentType: typeof Component): Array<Component>;
    /**
     * Updates the internal lists of component type IDs and rendering component type IDs.
     * This method maintains sorted arrays of ComponentTIDs for efficient iteration and processing.
     *
     * @private
     */
    private static __updateComponentTIDs;
    /**
     * Retrieves all registered component type IDs in sorted order.
     * This provides access to all ComponentTIDs that have been registered with the repository.
     *
     * @returns Array of all ComponentTIDs currently registered, sorted in ascending order
     *
     * @example
     * ```typescript
     * const allComponentTIDs = ComponentRepository.getComponentTIDs();
     * console.log(`Total component types: ${allComponentTIDs.length}`);
     * ```
     */
    static getComponentTIDs(): Array<ComponentTID>;
    /**
     * Retrieves all rendering-related component type IDs.
     * This returns ComponentTIDs for components that are involved in the rendering pipeline.
     *
     * @returns Array of ComponentTIDs for rendering components
     *
     * @example
     * ```typescript
     * const renderingTIDs = ComponentRepository.getRenderingComponentTIDs();
     * // Process rendering components during render loop
     * ```
     */
    static getRenderingComponentTIDs(): Array<ComponentTID>;
}

/**
 * Config.ts is a configuration file that contains the configuration for the library.
 */
/**
 * Config is a configuration object that contains the configuration for the library.
 */
declare const Config: {
    /**The maximum number of entities that Rhodonite can handle*/
    maxEntityNumber: number;
    /**The maximum number of lights that Rhodonite can handle */
    maxLightNumber: number;
    /**The maximum number of morph targets that Rhodonite can handle */
    maxMorphTargetNumber: number;
    /**The maximum number of morph primitives that Rhodonite can handle in WebGPU */
    maxMorphPrimitiveNumberInWebGPU: number;
    /**
     * Number of instances of each material type to be placed consecutively in memory.
     * This is on the memory layout, and the number of material instances that can be generated is not limited by this setting.
     * If this limit is exceeded, the material type is internally treated as a separate material type.
     */
    maxMaterialInstanceForEachType: number;
    /**The data type of the bone */
    boneDataType: EnumIO;
    /**The maximum number of skeletons that Rhodonite can handle */
    maxSkeletonNumber: number;
    /**The maximum number of cameras that Rhodonite can handle */
    maxCameraNumber: number;
    /**The maximum number of bones of each skeleton that Rhodonite can handle */
    maxSkeletalBoneNumber: number;
    /**The maximum number of bones of each skeleton that Rhodonite can handle for Uniform Mode */
    maxSkeletalBoneNumberForUniformMode: number;
    /**The width of the data texture */
    dataTextureWidth: number;
    /**The height of the data texture */
    dataTextureHeight: number;
    /**Whether the UBO is enabled */
    isUboEnabled: boolean;
    /**The event target DOM for mouse operation */
    eventTargetDom: HTMLElement | undefined;
    /**Whether to cache the WebGPU render bundles */
    cacheWebGpuRenderBundles: boolean;
    /**Whether to output the CG API debug console */
    cgApiDebugConsoleOutput: boolean;
    /**Whether to enable multi-view extension for WebVR */
    multiViewForWebVR: boolean;
    /**The scale of the physics time interval */
    physicsTimeIntervalScale: number;
    /**Whether the device is a mobile device */
    isMobile: boolean;
};

type GlobalPropertyStruct = {
    shaderSemanticsInfo: ShaderSemanticsInfo;
    values: any[];
    maxCount: Count;
    accessor: Accessor;
};
/**
 * The repository class that manages global data used throughout the rendering pipeline.
 * This singleton class handles global properties such as camera matrices, lighting data,
 * bone transformations for skeletal animation, and other shared rendering state.
 */
declare class GlobalDataRepository {
    private static __instance;
    private __fields;
    private constructor();
    /**
     * Initializes the GlobalDataRepository with all required global properties.
     * Sets up data structures for camera matrices, lighting, skeletal animation,
     * and other rendering parameters based on the specified process approach.
     *
     * @param approach - The processing approach that determines
     *                   how data is organized and accessed in shaders
     */
    initialize(approach: ProcessApproachEnum): void;
    /**
     * Returns the singleton instance of GlobalDataRepository.
     * Creates a new instance if it doesn't exist yet.
     *
     * @returns The singleton instance of GlobalDataRepository
     */
    static getInstance(): GlobalDataRepository;
    /**
     * Registers a new global property with its semantic information and maximum count.
     * Creates the necessary buffer memory allocation and accessor for the property.
     *
     * @param semanticInfo - The shader semantic information defining the property structure
     * @param maxCount - The maximum number of instances this property can have
     * @private
     */
    private __registerProperty;
    /**
     * Allocates and returns a new instance of the specified global property.
     * Initializes the property with its default value and adds it to the internal tracking.
     *
     * @param shaderSemantic - The name of the shader semantic property to allocate
     * @returns The newly allocated property value object, or undefined if the property doesn't exist
     */
    takeOne(shaderSemantic: ShaderSemanticsName): any;
    /**
     * Sets the value of a specific instance of a global property.
     * Updates the underlying memory buffer with the new value.
     *
     * @param shaderSemantic - The name of the shader semantic property to update
     * @param countIndex - The index of the specific instance to update
     * @param value - The new value to set for this property instance
     */
    setValue(shaderSemantic: ShaderSemanticsName, countIndex: Index, value: any): void;
    /**
     * Retrieves the value of a specific instance of a global property.
     *
     * @param shaderSemantic - The name of the shader semantic property to retrieve
     * @param countIndex - The index of the specific instance to retrieve
     * @returns The value object for the specified property instance, or undefined if not found
     */
    getValue(shaderSemantic: ShaderSemanticsName, countIndex: Index): any;
    /**
     * Retrieves the complete global property structure for a given property name.
     * This includes semantic information, values array, max count, and accessor.
     *
     * @param propertyName - The name of the property to retrieve
     * @returns The GlobalPropertyStruct for the specified property, or undefined if not found
     */
    getGlobalPropertyStruct(propertyName: ShaderSemanticsName): GlobalPropertyStruct | undefined;
    /**
     * Returns an array of all registered global property structures.
     * Useful for iterating over all available global properties.
     *
     * @returns An array containing all GlobalPropertyStruct instances
     */
    getGlobalProperties(): GlobalPropertyStruct[];
    /**
     * Sets up uniform locations for all global properties when using uniform mode.
     * This is used internally by the WebGL resource repository for shader program setup.
     *
     * @param shaderProgramUid - The unique identifier of the shader program
     * @internal
     */
    _setUniformLocationsForUniformModeOnly(shaderProgramUid: CGAPIResourceHandle): void;
    /**
     * Sets up uniform locations for properties that need uniform access in data texture mode.
     * Only sets up uniforms for properties marked with needUniformInDataTextureMode flag.
     *
     * @param shaderProgramUid - The unique identifier of the shader program
     * @internal
     */
    _setUniformLocationsForDataTextureModeOnly(shaderProgramUid: CGAPIResourceHandle): void;
    /**
     * Sets uniform values for all global properties in the specified shader program.
     * Iterates through all registered properties and uploads their current values to the GPU.
     *
     * @param shaderProgram - The WebGL shader program to set uniform values for
     */
    setUniformValues(shaderProgram: WebGLProgram): void;
    /**
     * Gets the memory location offset of a global property in 16-byte aligned units.
     * This is used for data texture mode to determine where properties are stored in memory.
     *
     * @param propertyName - The name of the property to get the offset for
     * @returns The offset in 16-byte units, or -1 if the property is not found
     */
    getLocationOffsetOfProperty(propertyName: ShaderSemanticsName): IndexOf16Bytes;
    /**
     * Returns the current number of allocated instances for a specific property.
     * This represents how many instances of the property have been created with takeOne().
     *
     * @param propertyName - The name of the property to get the count for
     * @returns The number of currently allocated instances, or 0 if the property doesn't exist
     */
    getCurrentDataNumberOfTheProperty(propertyName: ShaderSemanticsName): number;
    /**
     * Adds global property declarations to vertex and pixel shader code strings.
     * This method is used during shader compilation to inject the necessary uniform
     * declarations for all registered global properties.
     *
     * @param vertexPropertiesStr - The string to append vertex shader property declarations to
     * @param pixelPropertiesStr - The string to append pixel shader property declarations to
     * @param propertySetter - The function used to generate property declaration code
     * @param isWebGL2 - Whether the target is WebGL 2.0 (affects syntax generation)
     * @returns A tuple containing the updated vertex and pixel shader property strings
     * @internal
     */
    _addPropertiesStr(vertexPropertiesStr: string, pixelPropertiesStr: string, propertySetter: getShaderPropertyFunc, isWebGL2: boolean): string[];
}

declare const GetComponentFromEntities: unique symbol;
declare function getComponentFromEntities<T extends typeof Component>(this: EnhancedArrayMethods, ComponentClass: T): InstanceType<T>[];
interface ArrayAsRn<_T> {
    Rn: EnhancedArrayMethods & IEnhancedArrayMethods;
}
interface IEnhancedArrayMethods {
    getComponentFromEntities: typeof getComponentFromEntities;
}
declare class EnhancedArrayMethods {
    __raw: unknown[];
    constructor(__raw: unknown[]);
}
declare const enhanceArray: () => void;

declare const GLTF2_EXPORT_GLTF = "glTF";
declare const GLTF2_EXPORT_GLB = "glTF-Binary";
declare const GLTF2_EXPORT_DRACO = "glTF-Draco";
declare const GLTF2_EXPORT_EMBEDDED = "glTF-Embedded";
declare const GLTF2_EXPORT_NO_DOWNLOAD = "No-Download";
/**
 * glTF2 Export Type definitions
 */
type Gltf2ExportType = typeof GLTF2_EXPORT_GLTF | typeof GLTF2_EXPORT_GLB | typeof GLTF2_EXPORT_DRACO | typeof GLTF2_EXPORT_EMBEDDED | typeof GLTF2_EXPORT_NO_DOWNLOAD;
/**
 * Configuration options for glTF2 export process
 */
interface Gltf2ExporterArguments {
    /** Target entities to export. If specified, includes their descendants in the output */
    entities?: ISceneGraphEntity[];
    /** Export format type */
    type: Gltf2ExportType;
    /** Tags to exclude from export */
    excludeTags?: Tag[];
}
/**
 * The glTF2 format Exporter class.
 *
 * This class provides functionality to export Rhodonite scene data to glTF 2.0 format.
 * It supports various export formats including .gltf, .glb, and embedded formats.
 */
declare class Gltf2Exporter {
    private constructor();
    /**
     * Exports scene data from the Rhodonite system in glTF2 format.
     *
     * This is the main entry point for glTF2 export functionality. It processes
     * the scene graph, materials, animations, and other data to create a complete
     * glTF2 output in the specified format.
     *
     * @param filename - The target output filename (without extension)
     * @param option - Export configuration options
     * @returns Promise that resolves to the generated glTF2 ArrayBuffer
     *
     * @example
     * ```typescript
     * const buffer = await Gltf2Exporter.export('myScene', {
     *   type: GLTF2_EXPORT_GLB,
     *   entities: [rootEntity]
     * });
     * ```
     */
    static export(filename: string, option?: Gltf2ExporterArguments): Promise<ArrayBuffer>;
    /**
     * Removes empty arrays from the glTF2 JSON to optimize output size.
     *
     * According to glTF2 specification, empty arrays should be omitted rather than
     * included as empty arrays to reduce file size and improve parsing performance.
     *
     * @param json - The glTF2 JSON object to clean up
     */
    private static __deleteEmptyArrays;
    /**
     * Collects target entities for export, including their descendants.
     *
     * This method processes the entity hierarchy to determine which entities should
     * be included in the export. It handles tag-based filtering and ensures that
     * hierarchical relationships are preserved.
     *
     * @param option - Export configuration options containing entity filters
     * @returns Object containing collected entities and top-level entities
     */
    private static __collectEntities;
    /**
     * Creates the base structure of the glTF2 JSON document.
     *
     * Initializes the fundamental glTF2 structure with required fields like asset,
     * buffers, and empty arrays for various glTF2 components. Sets up the metadata
     * and prepares the document for content population.
     *
     * @param filename - Target output filename for generating URIs
     * @returns Object containing the initialized JSON structure and processed filename
     */
    private static __createJsonBase;
    /**
     * Creates glTF2 BufferViews and Accessors for all geometry and animation data.
     *
     * This method processes mesh geometry, animation data, and skeletal information
     * to create the necessary buffer views and accessors required for glTF2 format.
     * It handles data deduplication and proper memory layout.
     *
     * @param json - The glTF2 JSON document to populate
     * @param entities - Array of entities to process for buffer creation
     */
    static __createBufferViewsAndAccessors(json: Gltf2Ex, entities: ISceneGraphEntity[]): void;
    /**
     * Creates glTF2 nodes representing the scene graph structure.
     *
     * Converts Rhodonite entities into glTF2 nodes, preserving hierarchical relationships,
     * transformations, and component associations (meshes, cameras, skins). Handles
     * special cases like billboard nodes and blend shape weights.
     *
     * @param json - The glTF2 JSON document to populate with nodes
     * @param entities - All entities to convert to nodes
     * @param topLevelEntities - Root-level entities for the scene
     */
    static __createNodes(json: Gltf2Ex, entities: ISceneGraphEntity[], topLevelEntities: ISceneGraphEntity[]): void;
    /**
     * Creates glTF2 materials and textures from Rhodonite materials.
     *
     * Processes all materials used by mesh entities, converting Rhodonite material
     * properties to glTF2 PBR format. Handles texture extraction, optimization,
     * and proper format conversion including support for various material extensions.
     *
     * @param json - The glTF2 JSON document to populate with materials
     * @param entities - Mesh entities containing materials to convert
     * @param option - Export options affecting material processing
     * @returns Promise that resolves when all materials and textures are processed
     */
    static __createMaterials(json: Gltf2Ex, entities: IMeshEntity[], option: Gltf2ExporterArguments): Promise<any[]>;
    private static __processMeshPrimitives;
    private static __createMaterialFromRhodonite;
    private static __setupMaterialBasicProperties;
    private static __setupMaterialTextures;
    private static __processTextureParameters;
    /**
     * Creates the binary buffer containing all mesh, animation, and texture data.
     *
     * Consolidates all buffer views into a single binary buffer with proper
     * alignment and padding according to glTF2 specification. Handles data
     * copying and memory layout optimization.
     *
     * @param json - The glTF2 JSON document containing buffer view definitions
     * @returns ArrayBuffer containing the consolidated binary data
     */
    private static __createBinary;
    /**
     * Initiates download of the exported glTF2 data as a .glb file.
     *
     * Creates a downloadable .glb file containing the complete glTF2 scene
     * in binary format. Uses browser download API to save the file locally.
     *
     * @param json - The glTF2 JSON document
     * @param filename - Base filename for the download
     * @param arraybuffer - Binary data buffer containing the .glb file
     */
    static __downloadGlb(_json: Gltf2, filename: string, arraybuffer: ArrayBuffer): void;
    /**
     * Placeholder method for future glTF2 ArrayBuffer export functionality.
     *
     * This method is reserved for implementing glTF2 export that returns
     * an ArrayBuffer without triggering a download.
     */
    exportGlbAsArrayBuffer(): void;
    /**
     * Initiates download of the exported glTF2 data as separate .gltf and .bin files.
     *
     * Creates downloadable .gltf (JSON) and .bin (binary) files representing
     * the complete glTF2 scene in text format with external binary references.
     *
     * @param json - The glTF2 JSON document
     * @param filename - Base filename for the downloads
     * @param arraybuffer - Binary data buffer for the .bin file
     */
    static __downloadGltf(json: Gltf2, filename: string, arraybuffer: ArrayBuffer): void;
}

/**
 * Creates and adds Effekseer extension data to the glTF 2.0 export JSON.
 * This function processes all entities with Effekseer components and exports their
 * effect data, including buffer views for effect files and animation timelines.
 *
 * @param json - The glTF 2.0 export JSON object to modify
 * @param entities - Array of scene graph entities to process for Effekseer components
 */
declare function createEffekseer(json: Gltf2Ex, entities: ISceneGraphEntity[]): void;

interface ISemanticVertexAttribute {
    semantic: VertexAttributeEnum;
    getScalarAsArray: (i: Index, option: IndicesAccessOption) => Array1<number>;
    getVec2AsArray: (i: Index, option: IndicesAccessOption) => Array2<number>;
    getVec3AsArray: (i: Index, option: IndicesAccessOption) => Array3<number>;
    getVec4AsArray: (i: Index, option: IndicesAccessOption) => Array4<number>;
}

/**
 * A complex vertex attribute that manages multiple accessors for different components (X, Y, Z, W)
 * of a vertex attribute. This class allows vertex attributes to be stored across multiple
 * data sources while providing a unified interface for accessing them.
 */
declare class ComplexVertexAttribute implements ISemanticVertexAttribute {
    private __semantic;
    private __components;
    private __offsets;
    /**
     * Creates a new ComplexVertexAttribute instance.
     *
     * @param semanticAttribute - The semantic type of this vertex attribute (e.g., position, normal, UV)
     * @param attributes - A map of attribute names to their corresponding accessors
     */
    constructor(semanticAttribute: VertexAttributeEnum, attributes: Attributes);
    /**
     * Gets the semantic type of this vertex attribute.
     *
     * @returns The vertex attribute semantic enum
     */
    get semantic(): VertexAttributeEnum;
    /**
     * Retrieves a single scalar value as a 1-element array from the vertex attribute at the specified index.
     *
     * @param i - The vertex index to access
     * @param option - Options for accessing the data (e.g., handling out-of-bounds indices)
     * @returns A 1-element array containing the scalar value
     */
    getScalarAsArray(i: Index, option: IndicesAccessOption): Array1<number>;
    /**
     * Retrieves a 2-component vector (Vec2) as an array from the vertex attribute at the specified index.
     *
     * @param i - The vertex index to access
     * @param option - Options for accessing the data (e.g., handling out-of-bounds indices)
     * @returns A 2-element array containing the X and Y components
     */
    getVec2AsArray(i: Index, option: IndicesAccessOption): Array2<number>;
    /**
     * Retrieves a 3-component vector (Vec3) as an array from the vertex attribute at the specified index.
     *
     * @param i - The vertex index to access
     * @param option - Options for accessing the data (e.g., handling out-of-bounds indices)
     * @returns A 3-element array containing the X, Y, and Z components
     */
    getVec3AsArray(i: Index, option: IndicesAccessOption): Array3<number>;
    /**
     * Retrieves a 4-component vector (Vec4) as an array from the vertex attribute at the specified index.
     *
     * @param i - The vertex index to access
     * @param option - Options for accessing the data (e.g., handling out-of-bounds indices)
     * @returns A 4-element array containing the X, Y, Z, and W components
     */
    getVec4AsArray(i: Index, option: IndicesAccessOption): Array4<number>;
}

/**
 * A simple implementation of vertex attribute that provides access to vertex data
 * with semantic information. This class wraps an Accessor and associates it with
 * a specific vertex attribute semantic.
 */
declare class SimpleVertexAttribute implements ISemanticVertexAttribute {
    private __semantic;
    private __accessor;
    /**
     * Creates a new SimpleVertexAttribute instance.
     * @param semanticAttribute - The semantic type of this vertex attribute (e.g., POSITION, NORMAL, TEXCOORD)
     * @param accessor - The accessor that provides access to the underlying vertex data
     */
    constructor(semanticAttribute: VertexAttributeEnum, accessor: Accessor);
    /**
     * Gets the semantic type of this vertex attribute.
     * @returns The vertex attribute semantic enum value
     */
    get semantic(): VertexAttributeEnum;
    /**
     * Retrieves a scalar value at the specified index as a single-element array.
     * @param i - The index of the vertex data to retrieve
     * @param option - Options for accessing indexed data
     * @returns A single-element array containing the scalar value
     */
    getScalarAsArray(i: Index, option: IndicesAccessOption): Array1<number>;
    /**
     * Retrieves a 2-component vector value at the specified index as an array.
     * @param i - The index of the vertex data to retrieve
     * @param option - Options for accessing indexed data
     * @returns A 2-element array containing the vector components [x, y]
     */
    getVec2AsArray(i: Index, option: IndicesAccessOption): Array2<number>;
    /**
     * Retrieves a 3-component vector value at the specified index as an array.
     * @param i - The index of the vertex data to retrieve
     * @param option - Options for accessing indexed data
     * @returns A 3-element array containing the vector components [x, y, z]
     */
    getVec3AsArray(i: Index, option: IndicesAccessOption): Array3<number>;
    /**
     * Retrieves a 4-component vector value at the specified index as an array.
     * @param i - The index of the vertex data to retrieve
     * @param option - Options for accessing indexed data
     * @returns A 4-element array containing the vector components [x, y, z, w]
     */
    getVec4AsArray(i: Index, option: IndicesAccessOption): Array4<number>;
}

/**
 * Abstract Gizmo class that provides a foundation for creating interactive gizmo objects
 * in 3D scenes. Gizmos are typically used for manipulation tools like transform handles,
 * rotation rings, or other interactive visual aids.
 */
declare abstract class Gizmo extends RnObject {
    /**
     * The top entity of this gizmo group.
     * A programmer who implements a gizmo class has to make this entity
     * a child of the target entity's scene graph component
     * that the gizmo will belong to manually.
     */
    protected __topEntity?: IMeshEntity | ISceneGraphEntity;
    /** the target entity which this gizmo belong to */
    protected __target: ISceneGraphEntity;
    protected __isVisible: boolean;
    /**
     * Creates a new Gizmo instance
     * @param target - The entity that this gizmo will be associated with and manipulate
     */
    constructor(target: ISceneGraphEntity);
    /**
     * Sets the visibility state of the gizmo
     * @param flg - True to make the gizmo visible, false to hide it
     */
    set isVisible(flg: boolean);
    /**
     * Gets the current visibility state of the gizmo
     * @returns True if the gizmo is visible, false otherwise
     */
    get isVisible(): boolean;
    /**
     * Internal method to set the visibility of the gizmo and all its child entities
     * @param flg - True to show the gizmo, false to hide it
     */
    protected __setVisible(flg: boolean): void;
    /**
     * Indicates whether the gizmo has been set up and is ready for use
     * Must be implemented by concrete gizmo classes
     */
    abstract isSetup: boolean;
    /**
     * Sets up the entities and components required for the gizmo
     * This method is called internally and should only be executed once
     * @internal
     */
    abstract _setup(): void;
    /**
     * Updates the gizmo's transform, appearance, and other properties
     * This method is typically called every frame to keep the gizmo synchronized
     * with its target entity
     * @internal
     */
    abstract _update(): void;
    /**
     * Cleans up and destroys the gizmo, releasing all associated resources
     * @internal
     */
    abstract _destroy(): void;
    /**
     * Determines whether the gizmo setup should be skipped
     * @returns True if setup should be skipped, false otherwise
     */
    protected __toSkipSetup(): boolean;
    /**
     * Applies appropriate tags to the gizmo entities for identification and categorization
     * This method ensures that all gizmo entities are properly tagged for rendering
     * and processing pipelines
     */
    protected setGizmoTag(): void;
}

/**
 * AABB Gizmo class that visualizes the Axis-Aligned Bounding Box of a target entity.
 * This gizmo renders a wireframe box around the target entity showing its spatial boundaries.
 */
declare class AABBGizmo extends Gizmo {
    private static __mesh?;
    /**
     * Checks if the gizmo has been properly set up and initialized.
     * @returns True if the gizmo is set up and ready to render, false otherwise
     */
    get isSetup(): boolean;
    /**
     * Initializes the gizmo entities and mesh components if not already done.
     * Creates the wireframe mesh entity, sets up the primitive geometry,
     * and attaches it to the target entity's scene graph.
     * @internal
     */
    _setup(): void;
    /**
     * Generates the wireframe primitive geometry for the AABB visualization.
     * Creates a unit cube with line primitives that form the edges of the bounding box.
     * The cube vertices are arranged from -1 to +1 in each axis and will be scaled
     * appropriately during rendering.
     * @returns A primitive object containing the wireframe geometry for the AABB
     */
    private static generatePrimitive;
    /**
     * Updates the gizmo's transform to match the target entity's current AABB.
     * Repositions and rescales the wireframe to accurately represent the target's
     * world-space bounding box including skeletal deformations.
     * @internal
     */
    _update(): void;
    /**
     * Destroys the gizmo and cleans up all associated resources.
     * Removes the gizmo entity from the scene graph and frees memory.
     * @internal
     */
    _destroy(): void;
}

/**
 * Locator Gizmo class that provides visual coordinate axes for 3D objects.
 * Displays X (red), Y (green), and Z (blue) axis lines to help visualize object orientation and position.
 */
declare class LocatorGizmo extends Gizmo {
    private static __mesh;
    private static __length;
    /**
     * Gets whether the gizmo has been properly set up and initialized.
     * @returns True if the gizmo is set up, false otherwise
     */
    get isSetup(): boolean;
    /**
     * Sets the length of the axis lines displayed by the gizmo.
     * @param val - The length value for the axis lines
     */
    set length(val: number);
    /**
     * Gets the current length of the axis lines displayed by the gizmo.
     * @returns The current axis line length
     */
    get length(): number;
    /**
     * Sets up the gizmo entities and mesh if not already done.
     * Creates the coordinate axis visualization with colored lines representing X, Y, and Z axes.
     * @internal
     */
    _setup(): void;
    /**
     * Updates the gizmo's transform properties to match the target object.
     * Positions the gizmo at the target's center point and scales it based on the target's bounding box.
     * @internal
     */
    _update(): void;
    /**
     * Generates the primitive geometry for the coordinate axes visualization.
     * Creates three colored lines: red for X-axis, green for Y-axis, and blue for Z-axis.
     * @returns The primitive object containing the axis line geometry and colors
     */
    private static __generatePrimitive;
    /**
     * Destroys the gizmo and cleans up its resources.
     * Removes the gizmo entity and frees associated memory.
     */
    _destroy(): void;
}

declare class LightGizmo extends Gizmo {
    private static __mesh;
    private static __length;
    /**
     * Checks whether the gizmo has been properly initialized and set up.
     * @returns True if the gizmo's top entity exists and setup is complete, false otherwise
     */
    get isSetup(): boolean;
    /**
     * Initializes the gizmo entities and visual representation if not already done.
     * Creates a mesh entity with a light gizmo primitive and attaches it to the target entity.
     * @internal
     */
    _setup(): void;
    /**
     * Updates the transform properties (position, rotation, scale) of the gizmo to match the target entity.
     * The gizmo's position is set to either the target's position or the center of its bounding box,
     * and its scale is adjusted based on the target's bounding box size.
     * @internal
     */
    _update(): void;
    /**
     * Destroys the gizmo and cleans up its resources.
     * Removes the top entity and all associated components from the scene.
     * @internal
     */
    _destroy(): void;
    /**
     * Generates the primitive geometry for the light gizmo visualization.
     * Creates a line-based representation showing a directional arrow pointing in the negative Z direction,
     * which is commonly used to represent light direction in 3D graphics.
     * @returns A primitive object containing the line geometry for the light gizmo
     * @private
     */
    private static __generatePrimitive;
}

/**
 * Scale Gizmo class for handling object scaling operations in 3D space
 * Provides interactive handles for scaling objects along individual axes (X, Y, Z)
 * or within specific planes (XY, YZ, ZX) in both local and world coordinate spaces
 */
declare class ScaleGizmo extends Gizmo {
    private static __groupEntity;
    private static __xCubeEntity;
    private static __yCubeEntity;
    private static __zCubeEntity;
    private static __xCubeMesh;
    private static __yCubeMesh;
    private static __zCubeMesh;
    private static __xCubePrimitive;
    private static __yCubePrimitive;
    private static __zCubePrimitive;
    private static __xEdgeCubeEntity;
    private static __yEdgeCubeEntity;
    private static __zEdgeCubeEntity;
    private static __xEdgeCubeMesh;
    private static __yEdgeCubeMesh;
    private static __zEdgeCubeMesh;
    private static __xEdgeCubePrimitive;
    private static __yEdgeCubePrimitive;
    private static __zEdgeCubePrimitive;
    private static __xCubeMaterial;
    private static __yCubeMaterial;
    private static __zCubeMaterial;
    private static __xyPlaneEntity;
    private static __yzPlaneEntity;
    private static __zxPlaneEntity;
    private static __xyPlaneMesh;
    private static __yzPlaneMesh;
    private static __zxPlaneMesh;
    private static __xyPlanePrimitive;
    private static __yzPlanePrimitive;
    private static __zxPlanePrimitive;
    private static __xyPlaneMaterial;
    private static __yzPlaneMaterial;
    private static __zxPlaneMaterial;
    private static __originalX;
    private static __originalY;
    private __pickStatedPoint;
    private __deltaPoint;
    private __targetScaleBackup;
    private __isPointerDown;
    private static __activeAxis;
    private static __space;
    private static __latestTargetEntity?;
    private static __length;
    private __onPointerDownFunc;
    private __onPointerMoveFunc;
    private __onPointerUpFunc;
    /**
     * Checks if the gizmo has been properly set up and initialized
     * @returns True if the gizmo is set up, false otherwise
     */
    get isSetup(): boolean;
    /**
     * Sets the length of the gizmo handles
     * @param val - The length value to set
     */
    set length(val: number);
    /**
     * Gets the current length of the gizmo handles
     * @returns The current length value
     */
    get length(): number;
    /**
     * Sets the visibility of the gizmo and manages input event registration
     * @param flg - True to show the gizmo, false to hide it
     */
    set isVisible(flg: boolean);
    /**
     * Sets the coordinate space for gizmo operations
     * @param space - The coordinate space to use ('local' or 'world')
     */
    setSpace(space: 'local' | 'world'): void;
    /**
     * Gets the current visibility state of the gizmo
     * @returns True if the gizmo is visible, false otherwise
     */
    get isVisible(): boolean;
    /**
     * @internal
     * Sets up the gizmo entities and their visual components if not already done
     * Creates all necessary meshes, materials, and entity hierarchies for the scale gizmo
     */
    _setup(): void;
    /**
     * Creates the ZX plane entity for plane-based scaling operations
     * @private
     */
    private zxPlane;
    /**
     * Creates the YZ plane entity for plane-based scaling operations
     * @private
     */
    private yzPlane;
    /**
     * Creates the XY plane entity for plane-based scaling operations
     * @private
     */
    private xyPlane;
    /**
     * Creates the Z-axis scaling handle mesh and entity
     * @private
     */
    private zMesh;
    /**
     * Creates the Y-axis scaling handle mesh and entity
     * @private
     */
    private yMesh;
    /**
     * Creates the X-axis scaling handle mesh and entity
     * @private
     */
    private xMesh;
    /**
     * Creates the X-axis edge cube for enhanced visual feedback
     * @private
     */
    private xEdgeMesh;
    /**
     * Creates the Y-axis edge cube for enhanced visual feedback
     * @private
     */
    private yEdgeMesh;
    /**
     * Creates the Z-axis edge cube for enhanced visual feedback
     * @private
     */
    private zEdgeMesh;
    /**
     * @internal
     * Updates the gizmo's transform, scale, and position based on the target entity
     * Called each frame to maintain proper gizmo positioning and scaling behavior
     */
    _update(): void;
    /**
     * Generates a primitive for line-based gizmo visualization
     * @returns A primitive containing position and color data for axis lines
     * @private
     */
    private static __generatePrimitive;
    /**
     * Handles pointer down events for initiating scaling operations
     * @param evt - The pointer event containing input information
     * @private
     */
    private __onPointerDown;
    /**
     * Handles pointer move events for performing real-time scaling
     * @param evt - The pointer event containing current pointer position
     * @private
     */
    private __onPointerMove;
    /**
     * Handles pointer up events for finalizing scaling operations
     * @param evt - The pointer event indicating the end of interaction
     * @private
     */
    private __onPointerUp;
    /**
     * Performs ray casting against the entire gizmo group entity
     * @param evt - The pointer event containing screen coordinates
     * @returns Ray casting result for the group entity
     * @private
     */
    private static castRay2;
    /**
     * Performs ray casting against individual axis entities to determine interaction
     * @param evt - The pointer event containing screen coordinates
     * @returns Object containing ray casting results for X, Y, and Z axes
     * @private
     */
    private static castRay;
    /**
     * Destroys the gizmo and cleans up associated resources
     * @internal
     */
    _destroy(): void;
}

/**
 * Translation Gizmo class
 * Provides an interactive 3D translation gizmo for manipulating object positions in 3D space.
 * The gizmo displays colored axes (red for X, green for Y, blue for Z) that can be dragged
 * to translate objects along specific axes or planes.
 */
declare class TranslationGizmo extends Gizmo {
    private static __groupEntity;
    private static __xCubeEntity;
    private static __yCubeEntity;
    private static __zCubeEntity;
    private static __xCubeMesh;
    private static __yCubeMesh;
    private static __zCubeMesh;
    private static __xCubePrimitive;
    private static __yCubePrimitive;
    private static __zCubePrimitive;
    private static __xCubeMaterial;
    private static __yCubeMaterial;
    private static __zCubeMaterial;
    private static __xyPlaneEntity;
    private static __yzPlaneEntity;
    private static __zxPlaneEntity;
    private static __xyPlaneMesh;
    private static __yzPlaneMesh;
    private static __zxPlaneMesh;
    private static __xyPlanePrimitive;
    private static __yzPlanePrimitive;
    private static __zxPlanePrimitive;
    private static __xyPlaneMaterial;
    private static __yzPlaneMaterial;
    private static __zxPlaneMaterial;
    private static __originalX;
    private static __originalY;
    private __pickStatedPoint;
    private __deltaPoint;
    private __targetPointBackup;
    private __isPointerDown;
    private static __activeAxis;
    private static __space;
    private __latestTargetEntity?;
    private __onPointerDownFunc;
    private __onPointerMoveFunc;
    private __onPointerUpFunc;
    private static __length;
    /**
     * Indicates whether the gizmo has been properly set up and initialized.
     * @returns True if the gizmo is set up and ready to use, false otherwise
     */
    get isSetup(): boolean;
    /**
     * Sets the length/scale of the gizmo axes.
     * @param val - The length value for the gizmo axes
     */
    set length(val: number);
    /**
     * Gets the current length/scale of the gizmo axes.
     * @returns The current length value of the gizmo axes
     */
    get length(): number;
    /**
     * Sets the visibility of the gizmo and manages input event registration.
     * When set to visible, registers pointer event handlers and adds the gizmo to the scene.
     * When set to invisible, unregisters events and resets gizmo state.
     * @param flg - True to show the gizmo, false to hide it
     */
    set isVisible(flg: boolean);
    /**
     * Sets the coordinate space for gizmo operations.
     * @param space - Either 'local' for object-relative coordinates or 'world' for global coordinates
     */
    setSpace(space: 'local' | 'world'): void;
    /**
     * Gets the current visibility state of the gizmo.
     * @returns True if the gizmo is currently visible, false otherwise
     */
    get isVisible(): boolean;
    /**
     * Sets up the gizmo entities and geometry if not already initialized.
     * Creates the visual components (cubes for axes, planes for multi-axis movement)
     * and configures their materials, positioning, and hierarchy.
     * @internal
     */
    _setup(): void;
    /**
     * Updates the gizmo's transform and visual state each frame.
     * Positions the gizmo at the target's location, scales it appropriately,
     * and applies any ongoing translation operations.
     * @internal
     */
    _update(): void;
    /**
     * Generates a primitive for line-based gizmo visualization.
     * Creates geometry for X, Y, and Z axis lines with appropriate colors.
     * @returns A primitive containing the line geometry for the gizmo axes
     */
    private static __generatePrimitive;
    /**
     * Handles pointer down events for starting gizmo interaction.
     * Determines which axis was clicked, sets up the initial state for dragging,
     * and configures the coordinate space transformation matrices.
     * @param evt - The pointer event containing click information
     */
    private __onPointerDown;
    /**
     * Handles pointer move events during gizmo interaction.
     * Calculates the translation delta based on mouse movement and the active axis,
     * performs coordinate space transformations, and updates the target object's position.
     * @param evt - The pointer event containing movement information
     */
    private __onPointerMove;
    /**
     * Handles pointer up events to end gizmo interaction.
     * Resets the gizmo state, re-enables camera controls, and finalizes
     * the translation operation.
     * @param evt - The pointer event containing release information
     */
    private __onPointerUp;
    /**
     * Performs ray casting against the entire gizmo group entity.
     * Used for general intersection testing with the gizmo.
     * @param evt - The pointer event to cast a ray from
     * @returns Ray casting result containing intersection information
     */
    private static castRay2;
    /**
     * Performs ray casting against individual gizmo axis entities.
     * Tests intersection with X, Y, and Z axis cubes separately to determine
     * which axis was clicked for translation.
     * @param evt - The pointer event to cast a ray from
     * @returns Object containing ray casting results for each axis (xResult, yResult, zResult)
     */
    private static castRay;
    /**
     * Destroys the gizmo and cleans up its resources.
     * Removes the gizmo from the scene and frees associated memory.
     * @internal
     */
    _destroy(): void;
}

type Vrm1HumanBone = {
    node: number;
};
type Vrm1_MeshAnnotation = {
    node: number;
    type: 'thirdPersonOnly' | 'firstPersonOnly' | 'both' | 'auto';
};
type Vrm1MorphTargetBind = {
    index: number;
    node: number;
    weight: number;
};
type Vrm1MaterialColorBind = {
    material: number;
    type: string;
    targetValue: [number, number, number, number];
};
type Vrm1TextureTransformBind = {
    material: number;
    scale: [number, number];
    offset: [number, number];
};
type Vrm1OverrideType = 'none' | 'block' | 'blend';
interface VRMC {
    specVersion: string;
    humanoid: {
        humanBones: Vrm1HumanBone[];
        armStretch: number;
        legStretch: number;
        upperArmTwist: number;
        lowerArmTwist: number;
        upperLegTwist: number;
        lowerLegTwist: number;
        feetSpacing: number;
        hasTranslationDoF: false;
    };
    meta: {
        version: string;
        author: string;
        contactInformation: string;
        reference: string;
        title: string;
        texture: 30;
        allowedUserName: string;
        violentUsageName: string;
        sexualUsageName: string;
        commercialUsageName: string;
        otherPermissionUrl: string;
        licenseName: string;
        otherLicenseUrl: string;
    };
    firstPerson: {
        meshAnnotations: Vrm1_MeshAnnotation[];
    };
    expressions: {
        preset: {
            [key: string]: {
                isBinary: boolean;
                morphTargetBinds: Vrm1MorphTargetBind[];
                materialColorBinds: Vrm1MaterialColorBind[];
                textureTransformBinds: Vrm1TextureTransformBind[];
                overrideBlink: Vrm1OverrideType;
                overrideLookAt: Vrm1OverrideType;
                overrideMouth: Vrm1OverrideType;
            };
        };
    };
    lookAt: {
        type: 'bone' | 'expression';
        offsetFromHeadBone: [number, number, number];
        rangeMapHorizontalInner: {
            inputMaxValue: number;
            outputScale: number;
        };
        rangeMapHorizontalOuter: {
            inputMaxValue: number;
            outputScale: number;
        };
        rangeMapVerticalDown: {
            inputMaxValue: number;
            outputScale: number;
        };
        rangeMapVerticalUp: {
            inputMaxValue: number;
            outputScale: number;
        };
    };
}

interface VRMC_node_constraint {
    node: RnM2Node;
    constraint: {
        roll?: {
            source: number;
            rollAxis: string;
            weight?: number;
        };
        aim?: {
            source: number;
            aimAxis: string;
            weight?: number;
        };
        rotation?: {
            source: number;
            weight?: number;
        };
    };
}

type Vrm1SpringBone_Collider = {
    node: number;
    shape: {
        sphere?: {
            offset: [number, number, number];
            radius: number;
        };
        capsule?: {
            offset: [number, number, number];
            radius: number;
            tail: [number, number, number];
        };
    };
};
type Vrm1SpringBone_ColliderGroup = {
    name: string;
    colliders: number[];
};
type Vrm1SpringBone_Spring = {
    colliderGroups: number[];
    joints: Vrm1SpringBone_Joint[];
    name: string;
    center: number;
};
type Vrm1SpringBone_Joint = {
    node: number;
    hitRadius: number;
    stiffness: number;
    gravityPower: number;
    gravityDir: [number, number, number];
    dragForce: number;
};
interface VRMC_springBone {
    specVersions: string;
    colliderGroups: Vrm1SpringBone_ColliderGroup[];
    colliders: Vrm1SpringBone_Collider[];
    springs: Vrm1SpringBone_Spring[];
}

interface VRM extends RnM2 {
    materials: Vrm1_Material[];
    extensions: {
        VRM?: VRM0x_Extension;
        VRMC_vrm?: VRMC;
        VRMC_springBone?: VRMC_springBone;
        VRMC_node_constraint?: VRMC_node_constraint;
    };
}

interface Vrm1 extends RnM2 {
    materials: Vrm1_Material[];
    extensions: {
        VRMC_vrm: VRMC;
        VRMC_springBone?: VRMC_springBone;
        VRMC_node_constraint?: VRMC_node_constraint;
    };
}

type RetargetMode = 'none' | 'global' | 'absolute';
declare class AnimationAssigner {
    private static __instance;
    /**
     * Assigns animation data from a glTF model to a root entity with optional retargeting.
     * This method handles both same-skeleton and cross-skeleton animation assignment.
     *
     * @param rootEntity - The root entity of the model to which animation will be assigned
     * @param gltfModel - The glTF model containing animation data
     * @param vrmModel - The corresponding VRM model that provides humanoid bone mapping
     * @param isSameSkeleton - Whether the source and target skeletons are identical
     * @param retargetMode - The retargeting mode: 'none' for direct assignment, 'global' for global retargeting, 'absolute' for absolute animation
     * @returns The root entity with assigned animations
     */
    assignAnimation(rootEntity: ISceneGraphEntity, gltfModel: RnM2, vrmModel: VRM | Vrm1 | Vrm0x, isSameSkeleton: boolean, retargetMode: RetargetMode): ISceneGraphEntity;
    /**
     * Assigns animation data from a VRMA (VRM Animation) model to a root entity.
     * This method specifically handles VRM animation format with humanoid bone mapping.
     *
     * @param rootEntity - The root entity of the model to which animation will be assigned
     * @param vrmaModel - The VRMA model containing animation data and humanoid bone mappings
     * @param postfixToTrackName - Optional postfix to append to animation track names for identification
     * @returns An array of animation track names that were created
     */
    assignAnimationWithVrma(rootEntity: ISceneGraphEntity, vrmaModel: RnM2Vrma, postfixToTrackName?: string): string[];
    private constructor();
    /**
     * Resets animation tracks and restores entities to their rest pose.
     * This method recursively processes all child entities.
     *
     * @param rootEntity - The root entity to reset
     * @param postfixToTrackName - Optional postfix to identify specific animation tracks to reset
     */
    private __resetAnimationAndPose;
    /**
     * Gets the singleton instance of the AnimationAssigner class.
     * Creates a new instance if one doesn't exist.
     *
     * @returns The singleton instance of AnimationAssigner
     */
    static getInstance(): AnimationAssigner;
    /**
     * Finds the corresponding entity in the target skeleton for a given node in the source model.
     * Handles both same-skeleton matching (by name) and cross-skeleton matching (by humanoid bone mapping).
     *
     * @param rootEntity - The root entity of the target skeleton
     * @param gltfModel - The source glTF model
     * @param vrmModel - The VRM model containing humanoid bone mappings
     * @param nodeIndex - The index of the node in the source model
     * @param nodeName - The name of the node in the source model
     * @param isSameSkeleton - Whether the source and target skeletons are identical
     * @returns The corresponding entity in the target skeleton, or undefined if not found
     */
    private __getCorrespondingEntity;
    /**
     * Finds the corresponding entity in the target skeleton for a VRMA animation node.
     * Uses humanoid bone name mapping from the VRMA model to match bones.
     *
     * @param rootEntity - The root entity of the target skeleton
     * @param gltfModel - The VRMA model containing animation data
     * @param nodeIndex - The index of the node in the VRMA model
     * @returns The corresponding entity in the target skeleton, or undefined if not found
     */
    private __getCorrespondingEntityWithVrma;
    /**
     * Determines whether a given node represents the hips bone in the humanoid skeleton.
     * This is used for special handling of hip translation animations.
     *
     * @param rootEntity - The root entity containing humanoid bone mappings
     * @param vrmModel - The VRM model with humanoid bone definitions
     * @param nodeIndex - The index of the node to check
     * @returns True if the node represents the hips bone, false otherwise
     */
    private __isHips;
    /**
     * Sets up animation components and data for entities with the same skeleton structure.
     * Processes all animation channels and applies them to corresponding entities with optional retargeting.
     *
     * @param rootEntity - The root entity of the target skeleton
     * @param gltfModel - The source glTF model containing animation data
     * @param vrmModel - The VRM model with humanoid bone mappings
     * @param isSameSkeleton - Whether the source and target skeletons are identical
     * @param retargetMode - The retargeting mode to apply
     */
    private __setupAnimationForSameSkeleton;
}

/**
 * The Draco Point Cloud Importer class for importing and decoding Draco compressed point cloud files.
 * This class provides functionality to import Draco files and convert them to glTF2 format or Rhodonite primitives.
 * Currently supports point cloud geometry only - mesh types, WEIGHTS_0, and JOINTS_0 attributes are not supported.
 */
declare class DrcPointCloudImporter {
    private static __instance;
    /**
     * Private constructor to enforce singleton pattern.
     */
    private constructor();
    /**
     * Imports a Draco point cloud file from a URI and converts it to glTF2 format.
     * This method supports both direct file URIs and file collections passed through options.
     *
     * @param uri - The URI of the .drc file to import
     * @param options - Optional loading configuration including file collections and processing options
     * @returns A Promise that resolves to a Result containing the glTF2 JSON or an error
     *
     * @example
     * ```typescript
     * const importer = DrcPointCloudImporter.getInstance();
     * const result = await importer.importPointCloud('path/to/pointcloud.drc');
     * if (result.isOk()) {
     *   const gltfJson = result.get();
     *   // Process the glTF JSON
     * }
     * ```
     */
    importPointCloud(uri: string, options?: GltfLoadOption): Promise<Result<RnM2, Err<ArrayBuffer, unknown>>>;
    /**
     * Imports a Draco point cloud from an ArrayBuffer and converts it to glTF2 format.
     * This method is useful when you already have the file data in memory.
     *
     * @param uri - The original URI of the file (used for base path calculation)
     * @param arrayBuffer - The ArrayBuffer containing the Draco file data
     * @param options - Optional loading configuration
     * @returns A Promise that resolves to the glTF2 JSON or rejects with an error
     *
     * @example
     * ```typescript
     * const importer = DrcPointCloudImporter.getInstance();
     * const buffer = await fetch('pointcloud.drc').then(r => r.arrayBuffer());
     * const gltfJson = await importer.importArrayBuffer('pointcloud.drc', buffer);
     * ```
     */
    importArrayBuffer(uri: string, arrayBuffer: ArrayBuffer, options?: GltfLoadOption): Promise<void | RnM2>;
    /**
     * Internal method to load and process ArrayBuffer data.
     * Determines whether the data is binary glTF or text JSON format and processes accordingly.
     *
     * @param arrayBuffer - The ArrayBuffer containing the file data
     * @param defaultOptions - Default loading options
     * @param basePath - Base path for resolving relative URIs
     * @param options - Additional loading options
     * @returns A Promise that resolves to the processed glTF JSON
     * @private
     */
    private __loadFromArrayBuffer;
    /**
     * Merges default options with JSON-embedded options and user-provided options.
     * Priority: user options > JSON embedded options > default options.
     *
     * @param defaultOptions - The default loading options
     * @param json - The glTF JSON that may contain embedded options
     * @param options - User-provided options
     * @returns The merged options object
     * @private
     */
    _getOptions(defaultOptions: any, json: RnM2, options: any): GltfLoadOption;
    /**
     * Processes binary glTF data by extracting JSON chunk and binary data.
     * Validates the glTF binary format and delegates to appropriate loading methods.
     *
     * @param dataView - DataView for reading binary data
     * @param isLittleEndian - Whether the data is in little-endian format
     * @param arrayBuffer - The complete ArrayBuffer containing the glTF data
     * @param options - Loading options
     * @param defaultOptions - Default loading options
     * @param basePath - Base path for resolving relative URIs
     * @returns A Promise that resolves to the processed glTF JSON
     * @private
     */
    _loadAsBinaryJson(dataView: DataView, isLittleEndian: boolean, arrayBuffer: ArrayBuffer, options: GltfLoadOption, defaultOptions: GltfLoadOption, basePath: string): Promise<any>;
    /**
     * Processes text-based glTF JSON data.
     * Sets up asset information and delegates to internal loading methods.
     *
     * @param gltfJson - The parsed glTF JSON object
     * @param options - Loading options
     * @param defaultOptions - Default loading options
     * @param basePath - Base path for resolving relative URIs
     * @returns A Promise that resolves to the processed glTF JSON
     * @private
     */
    _loadAsTextJson(gltfJson: RnM2, options: GltfLoadOption, defaultOptions: GltfLoadOption, basePath: string): Promise<RnM2>;
    /**
     * Internal loading method that coordinates resource loading and JSON content processing.
     * Runs resource loading and JSON processing in parallel for better performance.
     *
     * @param uint8array - Binary data for embedded resources (optional)
     * @param basePath - Base path for resolving relative URIs
     * @param gltfJson - The glTF JSON object to process
     * @param options - Loading options
     * @returns A Promise that resolves when all loading is complete
     * @private
     */
    _loadInner(uint8array: Uint8Array | undefined, basePath: string, gltfJson: RnM2, options: GltfLoadOption): Promise<(void | (void | ArrayBuffer)[])[]>;
    /**
     * Processes glTF JSON content by loading dependencies for all major components.
     * This method establishes object references between different glTF components.
     *
     * @param gltfJson - The glTF JSON object to process
     * @param options - Loading options
     * @private
     */
    _loadJsonContent(gltfJson: RnM2, _options: GltfLoadOption): void;
    /**
     * Establishes object references between scenes and their nodes.
     * Populates the nodesObjects array with actual node objects.
     *
     * @param gltfJson - The glTF JSON object containing scenes
     * @private
     */
    _loadDependenciesOfScenes(gltfJson: RnM2): void;
    /**
     * Establishes object references for nodes including hierarchy, meshes, skins, cameras, and lights.
     * This method creates the complete node dependency graph.
     *
     * @param gltfJson - The glTF JSON object containing nodes
     * @private
     */
    _loadDependenciesOfNodes(gltfJson: RnM2): void;
    /**
     * Establishes object references for meshes and their primitives.
     * Links materials, attributes, indices, and morph targets to their respective objects.
     *
     * @param gltfJson - The glTF JSON object containing meshes
     * @private
     */
    _loadDependenciesOfMeshes(gltfJson: RnM2): void;
    /**
     * Checks if Rhodonite-specific glTF loader options exist in the asset extras.
     *
     * @param gltfModel - The glTF model to check
     * @returns True if Rhodonite loader options exist, false otherwise
     * @private
     */
    private _checkRnGltfLoaderOptionsExist;
    /**
     * Establishes object references for materials and their textures.
     * Links PBR textures, normal maps, occlusion maps, and emissive textures.
     * Also handles extension-specific texture processing.
     *
     * @param gltfJson - The glTF JSON object containing materials
     * @private
     */
    _loadDependenciesOfMaterials(gltfJson: RnM2): void;
    /**
     * Establishes object references for textures, linking samplers and image sources.
     *
     * @param gltfJson - The glTF JSON object containing textures
     * @private
     */
    _loadDependenciesOfTextures(gltfJson: RnM2): void;
    /**
     * Establishes object references for skeletal animation joints and skins.
     * Links skeleton nodes, inverse bind matrices, and joint hierarchies.
     *
     * @param gltfJson - The glTF JSON object containing skins
     * @private
     */
    _loadDependenciesOfJoints(gltfJson: RnM2): void;
    /**
     * Establishes object references for animations, channels, and samplers.
     * Links animation data with target nodes and handles special cases for rotations and weights.
     *
     * @param gltfJson - The glTF JSON object containing animations
     * @private
     */
    _loadDependenciesOfAnimations(gltfJson: RnM2): void;
    /**
     * Establishes object references for accessors and their buffer views.
     * Also handles sparse accessor data if present.
     *
     * @param gltfJson - The glTF JSON object containing accessors
     * @private
     */
    _loadDependenciesOfAccessors(gltfJson: RnM2): void;
    /**
     * Establishes object references between buffer views and their underlying buffers.
     *
     * @param gltfJson - The glTF JSON object containing buffer views
     * @private
     */
    _loadDependenciesOfBufferViews(gltfJson: RnM2): void;
    /**
     * Merges extended JSON data into the main glTF JSON object.
     * Supports ArrayBuffer, string, or object formats for extended data.
     *
     * @param gltfJson - The main glTF JSON object to merge into
     * @param extendedData - Additional data to merge (ArrayBuffer, string, or object)
     * @private
     */
    _mergeExtendedJson(gltfJson: RnM2, extendedData: any): void;
    /**
     * Loads external resources (buffers and images) referenced by the glTF JSON.
     * Handles various URI formats including data URIs, file references, and embedded binary data.
     *
     * @param uint8Array - Binary data for embedded resources
     * @param basePath - Base path for resolving relative URIs
     * @param gltfJson - The glTF JSON object containing resource references
     * @param options - Loading options including file collections
     * @param resources - Object to store loaded resources
     * @returns A Promise that resolves when all resources are loaded
     * @private
     */
    _loadResources(uint8Array: Uint8Array, basePath: string, gltfJson: RnM2, options: GltfLoadOption, resources: {
        shaders: any[];
        buffers: any[];
        images: any[];
    }): Promise<void | (void | ArrayBuffer)[]>;
    /**
     * Gets the singleton instance of the DrcPointCloudImporter.
     * Creates a new instance if one doesn't exist.
     *
     * @returns The singleton instance of DrcPointCloudImporter
     */
    static getInstance(): DrcPointCloudImporter;
    /**
     * Decodes a Draco compressed file and converts it to glTF2 format.
     * This is the main entry point for Draco decoding operations.
     *
     * @param arrayBuffer - The ArrayBuffer containing Draco compressed data
     * @param defaultOptions - Default loading options
     * @param basePath - Base path for resolving relative URIs
     * @param options - Additional loading options
     * @returns A Promise that resolves to the glTF2 JSON object
     * @private
     */
    private __decodeDraco;
    /**
     * Decodes a Draco compressed buffer and extracts geometry data.
     * Handles both point cloud and mesh geometry types, but only supports point clouds.
     *
     * @param arrayBuffer - The ArrayBuffer containing Draco compressed data
     * @returns A Promise that resolves to the decoded geometry data as JSON
     * @private
     */
    private __decodeBuffer;
    /**
     * Converts decoded Draco buffer data to glTF2 JSON format.
     * Creates a complete glTF2 structure with nodes, scenes, materials, and geometry data.
     *
     * @param buffer - The decoded Float32Array containing vertex data
     * @param numPoints - Number of points in the point cloud
     * @param attributeNames - Array of attribute names (POSITION, COLOR, etc.)
     * @param attributeComponents - Array of component counts for each attribute
     * @returns A Promise that resolves to the glTF2 JSON object
     * @private
     */
    private __decodedBufferToJSON;
    /**
     * Sets buffer data in the glTF JSON by converting the Float32Array to a data URI.
     *
     * @param buffer - The Float32Array containing vertex data
     * @param json - The glTF JSON object to modify
     * @returns A Promise that resolves when the buffer is set
     * @private
     */
    private __setBuffersToJSON;
    /**
     * Converts an ArrayBuffer to a data URI for embedding in glTF JSON.
     *
     * @param arrayBuffer - The ArrayBuffer to convert
     * @returns A Promise that resolves to the data URI string
     * @private
     */
    private __convertBufferToURI;
    /**
     * Creates accessor and buffer view definitions for the glTF JSON.
     * Defines how to interpret the binary data for each vertex attribute.
     *
     * @param numPoints - Number of points in the point cloud
     * @param attributeNames - Array of attribute names
     * @param attributeComponents - Array of component counts for each attribute
     * @param json - The glTF JSON object to modify
     * @private
     */
    private __setAccessorsAndBufferViewsToJSON;
    /**
     * Creates mesh definitions for the glTF JSON with point cloud primitives.
     * Maps Draco attribute names to glTF attribute semantics.
     *
     * @param attributeNames - Array of attribute names from Draco
     * @param json - The glTF JSON object to modify
     * @private
     */
    private __setMeshesToJSON;
    /**
     * Imports a Draco point cloud file and converts it directly to a Rhodonite Primitive.
     * This method bypasses glTF conversion for direct primitive creation.
     *
     * @param uri - The URI of the .drc file to import
     * @returns A Promise that resolves to a Rhodonite Primitive object
     *
     * @example
     * ```typescript
     * const importer = DrcPointCloudImporter.getInstance();
     * const primitive = await importer.importPointCloudToPrimitive('path/to/pointcloud.drc');
     * // Use the primitive directly in Rhodonite
     * ```
     */
    importPointCloudToPrimitive(uri: string): Promise<Primitive>;
    /**
     * Decodes a Draco compressed ArrayBuffer directly to a Rhodonite Primitive.
     * This method provides the most direct path from Draco data to Rhodonite geometry.
     * Note: Tangent attributes are not currently supported.
     *
     * @param arrayBuffer - The ArrayBuffer containing Draco compressed data
     * @returns The decoded Rhodonite Primitive
     * @private
     */
    private __decodeDracoToPrimitive;
    /**
     * Extracts and validates Draco geometry from a compressed buffer.
     * Supports both triangular mesh and point cloud geometry types.
     *
     * @param draco - The Draco decoder module instance
     * @param decoder - The Draco decoder instance
     * @param arrayBuffer - The ArrayBuffer containing compressed geometry
     * @returns The decoded Draco geometry object, or undefined if decoding fails
     * @private
     */
    private __getGeometryFromDracoBuffer;
    /**
     * Extracts position attribute data from Draco geometry.
     * Position data is required for all point clouds.
     *
     * @param draco - The Draco decoder module instance
     * @param decoder - The Draco decoder instance
     * @param dracoGeometry - The decoded Draco geometry
     * @param attributeCompositionTypes - Array to store composition types
     * @param attributeSemantics - Array to store attribute semantics
     * @param attributes - Array to store attribute data
     * @returns The extracted position data as Float32Array
     * @private
     */
    private __getPositions;
    /**
     * Extracts color attribute data from Draco geometry if present.
     * Handles both RGB and RGBA color formats, ensuring RGBA output.
     *
     * @param draco - The Draco decoder module instance
     * @param decoder - The Draco decoder instance
     * @param dracoGeometry - The decoded Draco geometry
     * @param attributeCompositionTypes - Array to store composition types
     * @param attributeSemantics - Array to store attribute semantics
     * @param attributes - Array to store attribute data
     * @returns The extracted color data as Float32Array, or null if not present
     * @private
     */
    private __getColors;
    /**
     * Extracts normal attribute data from Draco geometry if present.
     * Normal vectors are used for lighting calculations.
     *
     * @param draco - The Draco decoder module instance
     * @param decoder - The Draco decoder instance
     * @param dracoGeometry - The decoded Draco geometry
     * @param attributeCompositionTypes - Array to store composition types
     * @param attributeSemantics - Array to store attribute semantics
     * @param attributes - Array to store attribute data
     * @returns The extracted normal data as Float32Array, or null if not present
     * @private
     */
    private __getNormals;
    /**
     * Extracts texture coordinate attribute data from Draco geometry if present.
     * Texture coordinates are used for mapping textures onto geometry.
     *
     * @param draco - The Draco decoder module instance
     * @param decoder - The Draco decoder instance
     * @param dracoGeometry - The decoded Draco geometry
     * @param attributeCompositionTypes - Array to store composition types
     * @param attributeSemantics - Array to store attribute semantics
     * @param attributes - Array to store attribute data
     * @returns The extracted texture coordinate data as Float32Array, or null if not present
     * @private
     */
    private __getTextureCoords;
}

/**
 * Detects the file format based on file extensions from a collection of ArrayBuffers.
 *
 * @param files - An object containing filename-ArrayBuffer pairs
 * @returns The detected file type as FileTypeEnum, or FileType.Unknown if no supported format is detected
 *
 * @example
 * ```typescript
 * const files = { 'model.gltf': arrayBuffer };
 * const format = detectFormatByArrayBuffers(files);
 * console.log(format); // FileType.Gltf
 * ```
 */
declare function detectFormatByArrayBuffers(files: {
    [s: string]: ArrayBuffer;
}): FileTypeEnum;
/**
 * Detects the file format based on the URI's file extension.
 *
 * @param uri - The URI string to analyze for format detection
 * @returns A string representing the detected format name, or 'Unknown' if no supported format is detected
 *
 * @example
 * ```typescript
 * const format = detectFormatByUri('path/to/model.gltf');
 * console.log(format); // 'glTF'
 * ```
 */
declare function detectFormatByUri(uri: string): string;
/**
 * Checks the version of a glTF file by analyzing its ArrayBuffer content.
 * Supports both binary (.glb) and text (.gltf) formats.
 *
 * @param arrayBuffer - The ArrayBuffer containing the glTF file data
 * @returns A string indicating the glTF format and version (e.g., 'glTF2.0', 'glTF1.0')
 *
 * @internal
 * This function distinguishes between binary glTF (GLB) and regular glTF by checking
 * the magic number at the beginning of the file. For GLB files, it reads the version
 * directly from the header. For regular glTF files, it parses the JSON to extract
 * the version from the asset.version field.
 */
declare function checkVersionOfGltf(arrayBuffer: ArrayBuffer): string;

/**
 * The glTF2 Importer class for loading and processing glTF 2.0 files.
 * Supports both .gltf (JSON) and .glb (binary) formats with comprehensive
 * extension support and resource loading capabilities.
 */
declare class Gltf2Importer {
    private constructor();
    /**
     * Imports a glTF2 file from a URL and processes it into RnM2 format.
     * Automatically detects whether the file is in .gltf or .glb format.
     *
     * @param url - The URL of the glTF file to import
     * @param options - Optional configuration for the loading process
     * @returns A Promise that resolves to the processed glTF2 data in RnM2 format
     * @throws Will reject if the file cannot be fetched or processed
     *
     * @example
     * ```typescript
     * const gltfData = await Gltf2Importer.importFromUrl('path/to/model.gltf', {
     *   cameraComponent: CameraComponent,
     *   lightComponent: LightComponent
     * });
     * ```
     */
    static importFromUrl(url: string, options?: GltfLoadOption): Promise<RnM2>;
    /**
     * Imports glTF2 data from a collection of ArrayBuffer files.
     * Automatically identifies the main glTF or GLB file from the provided files.
     *
     * @param files - A collection of file buffers where keys are filenames and values are ArrayBuffers
     * @param options - Optional configuration for the loading process
     * @returns A Promise that resolves to the processed glTF2 data in RnM2 format
     * @throws Will reject if no glTF or GLB file is found in the provided files
     *
     * @example
     * ```typescript
     * const files = {
     *   'model.gltf': gltfBuffer,
     *   'texture.jpg': textureBuffer
     * };
     * const gltfData = await Gltf2Importer.importFromArrayBuffers(files);
     * ```
     */
    static importFromArrayBuffers(files: GltfFileBuffers, options?: GltfLoadOption): Promise<RnM2>;
    /**
     * Internal method to import glTF2 data from ArrayBuffer, handling both .gltf and .glb formats.
     * Determines the file format by checking the magic number and processes accordingly.
     *
     * @param arrayBuffer - The main glTF/GLB file as ArrayBuffer
     * @param otherFiles - Additional resource files (textures, bins) as ArrayBuffers
     * @param options - Optional configuration for the loading process
     * @param uri - Optional URI of the glTF file for resolving relative paths
     * @returns A Result containing the processed RnM2 data or an error
     *
     * @internal
     */
    static _importGltfOrGlbFromArrayBuffers(arrayBuffer: ArrayBuffer, otherFiles: GltfFileBuffers, options?: GltfLoadOption, uri?: string): Promise<Result<RnM2, undefined>>;
    /**
     * Merges default options with glTF asset extras and user-provided options.
     * Handles loader extension initialization based on the extension name.
     *
     * @param defaultOptions - The base default options to merge into
     * @param json - The glTF JSON data that may contain loader options in asset.extras
     * @param options - User-provided options to override defaults
     * @returns The merged and processed options object
     *
     * @internal
     */
    static _getOptions(defaultOptions: GltfLoadOption, json: RnM2, options: GltfLoadOption): GltfLoadOption;
    /**
     * Imports and processes a binary glTF (.glb) file from ArrayBuffer.
     * Validates the GLB format, extracts JSON and binary chunks, and processes the content.
     *
     * @param arrayBuffer - The GLB file data as ArrayBuffer
     * @param files - Additional resource files for resolving dependencies
     * @param options - Configuration options for the loading process
     * @returns A Promise that resolves to the processed glTF2 data in RnM2 format
     * @throws Will throw if the GLB format is invalid or unsupported
     *
     * @internal
     */
    static _importGlb(arrayBuffer: ArrayBuffer, files: GltfFileBuffers, options: GltfLoadOption): Promise<RnM2>;
    /**
     * Imports and processes a JSON glTF (.gltf) file with external resources.
     * Handles resource loading from external files and applies processing options.
     *
     * @param gltfJson - The parsed glTF JSON data
     * @param fileArrayBuffers - Collection of external resource files
     * @param options - Configuration options for the loading process
     * @param uri - Optional base URI for resolving relative resource paths
     * @param callback - Optional callback for progress tracking
     * @returns A Promise that resolves to the processed glTF2 data in RnM2 format
     *
     * @internal
     */
    static _importGltf(gltfJson: RnM2, fileArrayBuffers: GltfFileBuffers, options: GltfLoadOption, uri?: string, callback?: RnPromiseCallback): Promise<RnM2>;
    /**
     * Orchestrates the loading of resources and JSON content processing.
     * Creates promises for both resource loading and JSON dependency resolution.
     *
     * @param gltfJson - The glTF JSON data to process
     * @param files - Collection of resource files
     * @param options - Loading configuration options
     * @param uint8arrayOfGlb - Optional binary data from GLB file
     * @param basePath - Optional base path for resolving relative URIs
     * @param callback - Optional progress callback
     * @returns A Promise that resolves when all loading operations complete
     *
     * @internal
     */
    static _loadInner(gltfJson: RnM2, files: GltfFileBuffers, options: GltfLoadOption, uint8arrayOfGlb?: Uint8Array, basePath?: string, callback?: RnPromiseCallback): RnPromise<any[]>;
    /**
     * Processes the glTF JSON content by resolving all internal dependencies.
     * Sets up object references between scenes, nodes, meshes, materials, textures, etc.
     *
     * @param gltfJson - The glTF JSON data to process
     *
     * @internal
     */
    static _loadJsonContent(gltfJson: RnM2): void;
    /**
     * Resolves dependencies for glTF scenes by linking node references.
     * Creates nodesObjects array with direct references to node objects.
     *
     * @param gltfJson - The glTF JSON data containing scenes
     *
     * @internal
     */
    static _loadDependenciesOfScenes(gltfJson: RnM2): void;
    /**
     * Resolves dependencies for glTF nodes including hierarchy, meshes, skins, cameras, and lights.
     * Establishes parent-child relationships and links to associated objects.
     *
     * @param gltfJson - The glTF JSON data containing nodes
     *
     * @internal
     */
    static _loadDependenciesOfNodes(gltfJson: RnM2): void;
    /**
     * Resolves dependencies for glTF meshes including materials, attributes, indices, and morph targets.
     * Handles material variants and creates direct object references for efficient access.
     *
     * @param gltfJson - The glTF JSON data containing meshes
     *
     * @internal
     */
    static _loadDependenciesOfMeshes(gltfJson: RnM2): void;
    /**
     * Checks if the glTF model contains Rhodonite-specific loader options in asset extras.
     *
     * @param gltfModel - The glTF model to check
     * @returns True if rnLoaderOptions exist in asset.extras, false otherwise
     *
     * @internal
     */
    private static _checkRnGltfLoaderOptionsExist;
    /**
     * Resolves dependencies for glTF materials including all texture references.
     * Handles PBR textures, normal maps, occlusion, emissive, and various extensions
     * like clearcoat, transmission, sheen, specular, iridescence, anisotropy, and MToon.
     *
     * @param gltfJson - The glTF JSON data containing materials
     *
     * @internal
     */
    static _loadDependenciesOfMaterials(gltfJson: RnM2): void;
    private static _loadBasicMaterialTextures;
    private static _loadMaterialExtensions;
    private static _loadKHRExtensions;
    private static _loadVRMCExtensions;
    /**
     * Resolves dependencies for glTF textures including samplers and image sources.
     * Handles KHR_texture_basisu extension for Basis Universal texture compression.
     *
     * @param gltfJson - The glTF JSON data containing textures
     *
     * @internal
     */
    static _loadDependenciesOfTextures(gltfJson: RnM2): void;
    /**
     * Resolves dependencies for glTF skins including skeleton, joints, and inverse bind matrices.
     * Sets up the skeletal animation structure with proper object references.
     *
     * @param gltfJson - The glTF JSON data containing skins
     *
     * @internal
     */
    static _loadDependenciesOfJoints(gltfJson: RnM2): void;
    /**
     * Resolves dependencies for glTF animations including channels, samplers, and targets.
     * Handles different interpolation modes and sets up animation data structures.
     *
     * @param gltfJson - The glTF JSON data containing animations
     *
     * @internal
     */
    static _loadDependenciesOfAnimations(gltfJson: RnM2): void;
    /**
     * Resolves dependencies for glTF accessors including buffer views and sparse data.
     * Links accessors to their underlying buffer data for vertex attributes and indices.
     *
     * @param gltfJson - The glTF JSON data containing accessors
     *
     * @internal
     */
    static _loadDependenciesOfAccessors(gltfJson: RnM2): void;
    /**
     * Resolves dependencies for glTF buffer views by linking them to their buffers.
     * Establishes the connection between buffer views and the actual buffer data.
     *
     * @param gltfJson - The glTF JSON data containing buffer views
     *
     * @internal
     */
    static _loadDependenciesOfBufferViews(gltfJson: RnM2): void;
    /**
     * Merges extended JSON data into the main glTF JSON structure.
     * Supports ArrayBuffer, string, or object formats for extended data.
     *
     * @param gltfJson - The main glTF JSON to merge into
     * @param extendedData - Additional data to merge (ArrayBuffer, string, or object)
     *
     * @internal
     */
    static _mergeExtendedJson(gltfJson: RnM2, extendedData: ArrayBuffer | string | object): void;
    /**
     * Loads all external resources referenced by the glTF file including buffers and images.
     * Handles various URI formats including data URIs, file references, and embedded data.
     * Supports multiple image formats including Basis Universal and KTX2 compression.
     *
     * @param uint8ArrayOfGlb - Binary data from GLB file (if applicable)
     * @param gltfJson - The glTF JSON data containing resource references
     * @param files - Collection of external files to load from
     * @param options - Loading configuration options
     * @param basePath - Base path for resolving relative URIs
     * @param callback - Optional progress callback
     * @returns A Promise that resolves when all resources are loaded
     *
     * @internal
     */
    static _loadResources(uint8ArrayOfGlb: Uint8Array, gltfJson: RnM2, files: GltfFileBuffers, _options: GltfLoadOption, basePath?: string, callback?: RnPromiseCallback): RnPromise<any[]>;
    /**
     * Checks if a specific filename exists in the provided files collection.
     * Compares only the filename part, ignoring directory paths.
     *
     * @param optionsFiles - Collection of files to search in
     * @param filename - The filename to search for
     * @returns True if the filename is found, false otherwise
     *
     * @private
     * @internal
     */
    private static __containsFileName;
    /**
     * Retrieves the full path of a file by its filename from the files collection.
     * Returns the complete key (path) that corresponds to the given filename.
     *
     * @param optionsFiles - Collection of files to search in
     * @param filename - The filename to find the full path for
     * @returns The full path if found, undefined otherwise
     *
     * @private
     * @internal
     */
    private static __getFullPathOfFileName;
    /**
     * Loads an image from a URI and processes it based on the image format.
     * Supports standard images, Basis Universal (.basis), and KTX2 compressed textures.
     * Handles both direct URIs and data embedded in the files collection.
     *
     * @param imageUri - The URI of the image to load
     * @param imageJson - The glTF image object to populate with loaded data
     * @param files - Collection of files that may contain the image data
     * @returns A Promise that resolves to the populated image object
     *
     * @private
     * @internal
     */
    private static __loadImageUri;
}

/**
 * Importer class which can import GLTF and VRM files.
 * Supports multiple formats including glTF 1.0/2.0, GLB, VRM 0.x/1.0, and Draco compressed files.
 */
declare class GltfImporter {
    /**
     * Private constructor to prevent direct instantiation.
     * This class is designed to be used as a static utility class.
     */
    private constructor();
    /**
     * Import GLTF or VRM file from a URL.
     * Automatically detects the file format and uses the appropriate importer.
     *
     * @param url - The URL of the glTF/VRM file to import
     * @param options - Optional loading configuration. The files property is ignored for URL imports
     * @param callback - Optional callback function for progress tracking
     * @returns A Promise that resolves to an Expression containing:
     *          - renderPasses[0]: model entities
     *          - renderPasses[1]: model outlines (if applicable)
     * @throws Will reject the promise if the file cannot be fetched or parsed
     */
    static importFromUrl(url: string, options?: GltfLoadOption, callback?: RnPromiseCallback): Promise<Expression>;
    /**
     * Import GLTF or VRM from pre-loaded ArrayBuffers.
     * Useful when you have already loaded the file data and want to avoid additional network requests.
     *
     * @param files - A map of file names to ArrayBuffers. File names should include extensions and match URIs used in the glTF
     * @param options - Optional loading configuration. If using the files option, keys must match the URIs of the ArrayBuffer values
     * @param callback - Optional callback function for progress tracking
     * @returns A Promise that resolves to an Expression containing:
     *          - renderPasses[0]: model entities
     *          - renderPasses[1]: model outlines (if applicable)
     * @throws Will reject the promise if the files cannot be parsed or are in an unsupported format
     */
    static importFromArrayBuffers(files: GltfFileBuffers, options?: GltfLoadOption, callback?: RnPromiseCallback): Promise<Expression>;
    /**
     * Initialize and validate the loading options.
     * Sets default values for missing options and performs necessary transformations.
     *
     * @param options - The original options object, may be undefined
     * @returns A fully initialized GltfLoadOption object with all required properties
     * @private
     */
    private static __initOptions;
    /**
     * Set render passes to the expression object.
     * Creates a new expression if one doesn't exist, or updates the existing one.
     *
     * @param renderPasses - Array of render passes to add to the expression
     * @param options - Loading options containing the optional expression
     * @returns The expression object with render passes configured
     * @private
     */
    private static __setRenderPassesToExpression;
    /**
     * Check if the given file extension is supported by the importer.
     *
     * @param fileExtension - The file extension to validate (without the dot)
     * @returns True if the extension is supported (gltf, glb, vrm, drc), false otherwise
     * @private
     */
    private static __isValidExtension;
    /**
     * Determine if an ArrayBuffer contains GLB (binary glTF) data.
     * Checks the magic number at the beginning of the buffer.
     *
     * @param arrayBuffer - The ArrayBuffer to examine
     * @returns True if the buffer contains GLB data, false otherwise
     * @private
     */
    private static __isGlb;
    /**
     * Extract the glTF version from a GLB ArrayBuffer.
     * Reads the version field from the GLB header.
     *
     * @param glbArrayBuffer - The GLB ArrayBuffer to examine
     * @returns The glTF version number (typically 1 or 2)
     * @private
     */
    private static __getGlbVersion;
    /**
     * Determine the glTF version from parsed JSON data.
     * Examines the asset.version field to determine if it's glTF 1.0 or 2.0.
     *
     * @param gltfJson - The parsed glTF JSON object
     * @returns 2 for glTF 2.0, 1 for glTF 1.0 or older versions
     * @private
     */
    private static __getGltfVersion;
    /**
     * Detect the model file type and import using the appropriate importer.
     * Handles different file formats including glTF, GLB, VRM, and Draco compressed files.
     *
     * @param fileName - Name of the file being imported
     * @param renderPasses - Array of render passes to add imported entities to
     * @param options - Loading options and configuration
     * @param uri - URI of the file for reference
     * @param callback - Optional callback for progress tracking
     * @returns A Result indicating success or failure of the import operation
     * @private
     */
    private static __detectTheModelFileTypeAndImport;
    /**
     * Determine the file type from the file name and options.
     * Uses either the explicitly provided file type or auto-detects from the file content.
     *
     * @param fileName - Name of the file to analyze
     * @param options - Loading options containing file data
     * @param optionalFileType - Optional explicit file type override
     * @returns The detected or specified FileType
     * @private
     */
    private static __getFileTypeFromFilePromise;
}

/**
 * A converter class from glTF2 model to Rhodonite Native data
 */
declare class ModelConverter {
    private constructor();
    /**
     * Generates a group entity for the glTF model
     * @param gltfModel - The glTF model data
     * @returns A scene graph entity configured as a group
     */
    private static __generateGroupEntity;
    /**
     * Adds source type and version tags to an entity based on the glTF model
     * @param entity - The entity to add tags to
     * @param gltfModel - The glTF model containing asset information
     */
    private static addTags;
    /**
     * Generates a mesh entity for the glTF model
     * @param gltfModel - The glTF model data
     * @returns A mesh entity with appropriate tags
     */
    private static __generateMeshEntity;
    /**
     * Generates a camera entity for the glTF model
     * @param gltfModel - The glTF model data
     * @returns A camera entity with appropriate tags
     */
    private static __generateCameraEntity;
    /**
     * Generates a light entity for the glTF model
     * @param gltfModel - The glTF model data
     * @returns A light entity with appropriate tags
     */
    private static __generateLightEntity;
    /**
     * Sets up materials from the glTF model
     * @param gltfModel - The glTF model data
     * @param rnTextures - Array of Rhodonite textures
     * @param rnSamplers - Array of Rhodonite samplers
     * @returns Array of configured Rhodonite materials
     */
    private static __setupMaterials;
    /**
     * Sets up textures from the glTF model asynchronously
     * @param gltfModel - The glTF model data
     * @returns Promise resolving to array of Rhodonite textures
     */
    private static __setupTextures;
    /**
     * Creates samplers from the glTF model
     * @param gltfModel - The glTF model data
     * @returns Array of Rhodonite samplers
     */
    private static __createSamplers;
    /**
     * Converts a glTF model to Rhodonite objects synchronously (without texture loading)
     * @param gltfModel - The glTF model data to convert
     * @returns The root group entity containing the converted scene
     */
    static convertToRhodoniteObjectSimple(gltfModel: RnM2): ISceneGraphEntity;
    /**
     * Converts a glTF model to Rhodonite objects asynchronously (with full texture loading)
     * @param gltfModel - The glTF model data to convert
     * @returns Promise resolving to the root group entity containing the converted scene
     */
    static convertToRhodoniteObject(gltfModel: RnM2): Promise<ISceneGraphEntity>;
    /**
     * Creates Rhodonite buffers from glTF buffer data
     * @param gltfModel - The glTF model containing buffer data
     * @returns Array of Rhodonite Buffer objects
     */
    private static __createRnBuffer;
    /**
     * Sets up transform properties for entities from glTF node data
     * @param gltfModel - The glTF model data
     * @param groups - Array of scene graph entities to apply transforms to
     */
    static _setupTransform(gltfModel: RnM2, groups: ISceneGraphEntity[]): void;
    /**
     * Sets up the hierarchy relationships between entities based on glTF node structure
     * @param gltfModel - The glTF model data
     * @param rnEntities - Array of Rhodonite entities to organize in hierarchy
     */
    static _setupHierarchy(gltfModel: RnM2, rnEntities: ISceneGraphEntity[]): void;
    /**
     * Sets up animation data from glTF animations
     * @param gltfModel - The glTF model data
     * @param rnEntities - Array of Rhodonite entities
     * @param rnBuffers - Array of Rhodonite buffers
     * @param rootGroup - The root group entity
     * @param rnMaterials - Array of Rhodonite materials
     * @internal
     */
    static _setupAnimation(gltfModel: RnM2, rnEntities: ISceneGraphEntity[], rnBuffers: Buffer[], rootGroup: ISceneGraphEntity, rnMaterials: Material[]): void;
    /**
     * Sets up pointer-based animation for materials, nodes, lights, and cameras
     * @param rnEntities - Array of Rhodonite entities
     * @param channel - Animation channel data
     * @param samplerObject - Animation sampler object
     * @param animation - Animation data
     * @param animInputArray - Input time values
     * @param animOutputArray - Output animation values
     * @param interpolation - Interpolation method
     * @param animationAttributeType - Type of animation attribute
     * @param rnMaterials - Array of Rhodonite materials
     * @param gltfModel - The glTF model data
     */
    private static __setPointerAnimation;
    /**
     * Sets up pointer animation for camera properties
     * @param match - Regex match result containing camera index
     * @param rnEntities - Array of Rhodonite entities
     * @param pointer - Animation pointer string
     * @param samplerObject - Animation sampler object
     * @param animation - Animation data
     * @param animInputArray - Input time values
     * @param animOutputArray - Output animation values
     * @param interpolation - Interpolation method
     * @param animationAttributeType - Type of animation attribute
     * @param gltfModel - The glTF model data
     */
    private static __setPointerAnimationCameras;
    /**
     * Sets up pointer animation for light properties
     * @param match - Regex match result containing light index
     * @param rnEntities - Array of Rhodonite entities
     * @param pointer - Animation pointer string
     * @param samplerObject - Animation sampler object
     * @param animation - Animation data
     * @param animInputArray - Input time values
     * @param animOutputArray - Output animation values
     * @param interpolation - Interpolation method
     * @param animationAttributeType - Type of animation attribute
     * @param gltfModel - The glTF model data
     */
    private static __setPointerAnimationLights;
    /**
     * Sets up pointer animation for node properties (transform, weights)
     * @param match - Regex match result containing node index
     * @param rnEntities - Array of Rhodonite entities
     * @param pointer - Animation pointer string
     * @param samplerObject - Animation sampler object
     * @param animation - Animation data
     * @param animInputArray - Input time values
     * @param animOutputArray - Output animation values
     * @param interpolation - Interpolation method
     * @param animationAttributeType - Type of animation attribute
     */
    private static __setPointerAnimationNodes;
    /**
     * Sets up pointer animation for material properties
     * @param match - Regex match result containing material index
     * @param rnMaterials - Array of Rhodonite materials
     * @param pointer - Animation pointer string
     * @param samplerObject - Animation sampler object
     * @param animation - Animation data
     * @param animInputArray - Input time values
     * @param animOutputArray - Output animation values
     * @param interpolation - Interpolation method
     * @param animationAttributeType - Type of animation attribute
     */
    private static __setPointerAnimationMaterials;
    /**
     * Sets up standard animation (non-pointer based) for transform properties
     * @param rnEntities - Array of Rhodonite entities
     * @param channel - Animation channel data
     * @param samplerObject - Animation sampler object
     * @param animation - Animation data
     * @param animInputArray - Input time values
     * @param animOutputArray - Output animation values
     * @param interpolation - Interpolation method
     * @param animationAttributeType - Type of animation attribute
     */
    private static __setNormalAnimation;
    /**
     * Sets up skeletal animation and joint hierarchies from glTF skin data
     * @param gltfModel - The glTF model data
     * @param rnEntities - Array of Rhodonite entities
     * @param rnBuffers - Array of Rhodonite buffers
     */
    static _setupSkeleton(gltfModel: RnM2, rnEntities: ISceneGraphEntity[], rnBuffers: Buffer[]): void;
    /**
     * Sets up all objects (meshes, cameras, lights, groups) from glTF nodes
     * @param gltfModel - The glTF model data
     * @param rnBuffers - Array of Rhodonite buffers
     * @param rnMaterials - Array of Rhodonite materials
     * @param rnTextures - Array of Rhodonite textures
     * @param rnSamplers - Array of Rhodonite samplers
     * @returns Object containing arrays of entities and entities by name
     */
    private static __setupObjects;
    /**
     * Checks if a node has morphing (blend shape) capabilities
     * @param node - The glTF node to check
     * @param gltfModel - The glTF model data
     * @returns True if the node supports morphing
     */
    private static __isMorphing;
    /**
     * Sets up a light entity from glTF light data
     * @param light - The glTF light data
     * @param gltfModel - The glTF model data
     * @returns Configured light entity
     */
    private static __setupLight;
    /**
     * Sets up a camera entity from glTF camera data
     * @param camera - The glTF camera data
     * @param gltfModel - The glTF model data
     * @returns Configured camera entity
     */
    private static __setupCamera;
    /**
     * Sets up a mesh entity from glTF mesh data
     * @param mesh - The glTF mesh data
     * @param meshIndex - Index of the mesh in the glTF model
     * @param rnBuffers - Array of Rhodonite buffers
     * @param gltfModel - The glTF model data
     * @param rnMaterials - Array of Rhodonite materials
     * @param rnTextures - Array of Rhodonite textures
     * @param rnSamplers - Array of Rhodonite samplers
     * @returns Configured mesh entity
     */
    private static __setupMesh;
    /**
     * Sets sparse accessor data by applying sparse indices and values to the base accessor
     * @param accessor - The glTF accessor with sparse data
     * @param rnAccessor - The Rhodonite accessor to modify
     */
    static setSparseAccessor(accessor: RnM2Accessor, rnAccessor: Accessor): void;
    /**
     * Sets up VRM 1.0 material properties
     * @param gltfModel - The glTF model data
     * @param materialJson - The material JSON data
     * @param rnLoaderOptions - Loader options
     * @returns Configured material or undefined if not VRM 1.0
     */
    private static __setVRM1Material;
    /**
     * Sets MToon texture parameters for VRM materials
     * @param textures - Array of textures
     * @param materialProperties - VRM material properties
     * @param material - The material to configure
     * @param samplers - Array of samplers
     */
    private static setMToonTextures;
    /**
     * Sets up VRM 0.x material properties
     * @param gltfModel - The glTF model data
     * @param materialJson - The material JSON data
     * @param rnLoaderOptions - Loader options
     * @returns Configured material or undefined if not VRM 0.x
     */
    private static __setVRM0xMaterial;
    /**
     * Generates an appropriate material based on glTF material data and loader options
     * @param gltfModel - The glTF model data
     * @param materialJson - The material JSON data (optional)
     * @returns Generated material
     */
    private static __generateAppropriateMaterial;
    /**
     * Determines if lighting should be enabled for a material
     * @param gltfModel - The glTF model data
     * @param materialJson - The material JSON data (optional)
     * @returns True if lighting should be enabled
     */
    private static __isLighting;
    /**
     * Determines if tangent attributes should be used for a primitive
     * @param gltfModel - The glTF model data
     * @param primitive - The glTF primitive data
     * @returns True if tangent attributes should be used
     */
    private static __useTangentAttribute;
    private static __useNormalTexture;
    private static __makeOutputSrgb;
    private static __setupMaterial;
    private static setParametersToMaterial;
    static _createSampler(sampler: RnM2TextureSampler): Sampler;
    static _createTexture(image: RnM2Image, gltfModel: RnM2, { autoDetectTransparency }?: {
        autoDetectTransparency?: boolean | undefined;
    }): Promise<Texture>;
    private static __needResizeToPowerOfTwoOnWebGl1;
    private static __sizeIsPowerOfTwo;
    private static __needParameterInitialization;
    private static _checkRnGltfLoaderOptionsExist;
    private static __rewrapWithTypedArray;
    static _checkBytesPerComponent(accessor: RnM2Accessor | RnM2SparseIndices): number;
    static _checkComponentNumber(accessor: RnM2Accessor): number;
    static _checkDataViewMethod(accessor: RnM2Accessor | RnM2SparseIndices): string;
    static _isSystemLittleEndian(): boolean;
    static _readBinaryFromAccessorAndSetItToAccessorExtras(accessor: RnM2Accessor, rnBuffers?: Buffer[]): Float32Array;
    /**
     * normalize values of TypedArray to Float32Array
     * See: the last part of 3.11.Animation at https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#animations
     * @param dataViewMethod
     * @param numberArray
     * @returns
     */
    private static __normalizeTypedArrayToFloat32Array;
    private static __addOffsetToIndices;
    /**
     * Take a Rn.Accessor from the Rn.Buffer
     *  from the information of the Gltf2Buffer, Gltf2BufferView, and Gltf2Accessor.
     * @param accessor
     * @param rnBuffer
     * @returns
     */
    private static __getRnAccessor;
    /**
     * Take a Rn.BufferView and a Rn.Accessor from the Rn.Buffer
     *  from the information of the Gltf2Buffer, Gltf2BufferView, and Gltf2Accessor.
     * @param accessor
     * @param rnBuffer
     * @returns
     */
    private static __getRnBufferViewAndRnAccessor;
    private static __copyRnAccessorAndBufferView;
    private static __takeRnBufferViewAndRnAccessorForDraco;
    private static __getRnBufferView;
    private static __getGeometryFromDracoBuffer;
    static __getIndicesFromDraco(draco: any, decoder: any, dracoGeometry: any, triangleStripDrawMode: boolean): Uint32Array<ArrayBufferLike> | undefined;
    private static __decodeDraco;
    static _setupTextureTransform(textureJson: RnM2TextureInfo, rnMaterial: Material, textureTransformScaleShaderSemantic: ShaderSemanticsName, textureTransformOffsetShaderSemantic: ShaderSemanticsName, textureTransformRotationShaderSemantic: ShaderSemanticsName): void;
    private static __createBufferForDecompressedData;
}

/**
 * Extension class for importing Rhodonite-specific features from RnM2 format files.
 * Handles billboard and Effekseer effect imports.
 */
declare class RhodoniteImportExtension {
    private static __instance;
    /**
     * Imports billboard configuration from RnM2 format and applies it to scene graph entities.
     * Processes the RHODONITE_billboard extension to enable billboard rendering for specified nodes.
     *
     * @param gltfJson - The RnM2 format JSON data containing billboard extension information
     * @param groups - Array of scene graph entities corresponding to nodes in the RnM2 data
     */
    static importBillboard(gltfJson: RnM2, groups: ISceneGraphEntity[]): void;
    /**
     * Imports Effekseer effects from RnM2 format and creates corresponding Effekseer components.
     * Processes the RHODONITE_effekseer extension to load particle effects with their configurations.
     *
     * @param gltfJson - The RnM2 format JSON data containing Effekseer extension information
     * @param rootGroup - The root scene graph entity that contains all imported entities
     */
    static importEffect(gltfJson: RnM2, rootGroup: ISceneGraphEntity): void;
}

/**
 * The VRM 0.x format importer class.
 * This class provides functionality to import and process VRM 0.x files,
 * including humanoid bone mapping, spring bone physics, and expression blending.
 * It extends the GLTF2 importer with VRM-specific features.
 */
declare class Vrm0xImporter {
    private constructor();
    /**
     * Imports a VRM file from the specified URL and converts it to Rhodonite scene graph entities.
     * This method handles the complete VRM import pipeline including textures, materials,
     * spring bone physics, humanoid mapping, and expression setup.
     *
     * @param url - The URL of the VRM file to import
     * @param options - Optional loading configuration including material helpers and render states
     * @returns A promise that resolves to an array of scene graph entities (main + optional outline)
     */
    static importFromUrl(url: string, options?: GltfLoadOption): Promise<Result<ISceneGraphEntity[], Err<RnM2, undefined>>>;
    /**
     * Imports only the JSON data from a VRM file without creating scene graph entities.
     * This is useful for extracting VRM metadata, humanoid bone mappings, and other
     * configuration data without the overhead of full scene construction.
     *
     * @param uri - The URI of the VRM file to import
     * @param options - Optional loading configuration
     * @returns A promise that resolves to the VRM JSON data structure
     */
    static importJsonOfVRM(uri: string, options?: GltfLoadOption): Promise<Vrm0x>;
    /**
     * Internal method for importing VRM 0.x data into existing render passes.
     * This method handles the complete VRM processing pipeline including material setup,
     * outline rendering, spring bone physics, and humanoid configuration.
     *
     * @param gltfModel - The loaded GLTF model data with VRM extensions
     * @param renderPasses - Array of render passes to add the VRM entities to
     */
    static __importVRM0x(gltfModel: RnM2, renderPasses: RenderPass[]): Promise<void>;
    /**
     * Processes VRM blend shape groups and converts them to Rhodonite VRM expressions.
     * This method extracts facial expressions, eye blinks, and other morph target animations
     * from the VRM blend shape master and creates the corresponding VRM component.
     *
     * @param gltfModel - The VRM model data containing blend shape information
     * @param rootEntity - The root entity to attach the VRM component to
     */
    static _readBlendShapeGroup(gltfModel: Vrm0x, rootEntity: ISceneGraphEntity): void;
    /**
     * Extracts and processes VRM humanoid bone mapping information.
     * This method creates a mapping between VRM standard bone names and the actual
     * scene graph nodes, which is essential for animation retargeting and IK.
     *
     * @param gltfModel - The VRM model data containing humanoid bone definitions
     * @param rootEntity - Optional root entity to attach the bone mapping metadata to
     */
    static _readVRMHumanoidInfo(gltfModel: Vrm0x, rootEntity?: ISceneGraphEntity): void;
    /**
     * Processes VRM spring bone physics configuration and creates the physics simulation setup.
     * This method handles collider groups, spring bone chains, and physics parameters
     * to enable realistic secondary motion for hair, clothing, and accessories.
     *
     * @param gltfModel - The VRM model data containing spring bone and collider definitions
     */
    static _readSpringBone(gltfModel: Vrm0x): void;
    /**
     * Recursively adds spring bone physics to a bone chain and its children.
     * This method traverses the bone hierarchy and applies spring physics parameters
     * to create natural secondary motion effects.
     *
     * @param vrmSpring - The VRM spring bone group to add bones to
     * @param entity - The current entity in the bone hierarchy
     * @param boneGroup - The VRM bone group configuration data
     * @param addedEntities - Array to track already processed entities to avoid duplicates
     */
    private static __addSpringBoneRecursively;
    /**
     * Adds a physics component with VRM spring bone strategy to an entity.
     * This method sets up the physics simulation for spring bone motion,
     * attaching the appropriate strategy and configuration.
     *
     * @param boneGroup - The VRM spring bone group containing physics parameters
     * @param sg - The scene graph component to attach physics to
     */
    private static __addPhysicsComponent;
    /**
     * Creates Rhodonite texture objects from GLTF texture data.
     * This method processes all textures in the GLTF model and creates additional
     * dummy textures (white and black) commonly used in VRM materials.
     *
     * @param gltfModel - The GLTF model containing texture definitions
     * @returns A promise that resolves to an array of created textures
     */
    static _createTextures(gltfModel: RnM2): Promise<Texture[]>;
    /**
     * Creates Rhodonite sampler objects from GLTF sampler data.
     * This method processes texture sampling configuration and creates additional
     * dummy samplers for textures that don't specify sampling parameters.
     *
     * @param gltfModel - The GLTF model containing sampler definitions
     * @returns An array of created sampler objects
     */
    static _createSamplers(gltfModel: RnM2): Sampler[];
    /**
     * Checks if any materials in the VRM have outline rendering enabled.
     * This method examines material properties to determine if a separate
     * outline render pass is needed for toon-style rendering effects.
     *
     * @param extensionsVRM - The VRM extension data containing material properties
     * @returns True if outline materials are present, false otherwise
     */
    static _existOutlineMaterial(extensionsVRM: any): boolean;
    /**
     * Initializes VRM material properties with default values for missing parameters.
     * This method ensures all VRM materials have complete property sets,
     * particularly for MToon shader materials commonly used in VRM models.
     *
     * @param gltfModel - The GLTF model to process materials for
     * @param texturesLength - The total number of textures for dummy texture indexing
     */
    static _initializeMaterialProperties(gltfModel: RnM2, texturesLength: number): void;
    /**
     * Initializes MToon material properties with comprehensive default values.
     * MToon is the standard toon shader for VRM, and this method ensures all
     * required properties are set with appropriate defaults for proper rendering.
     *
     * @param gltfModel - The GLTF model containing MToon materials
     * @param texturesLength - The total number of textures for dummy texture assignment
     */
    private static __initializeMToonMaterialProperties;
    /**
     * Sets a default value for an object property if it's currently undefined.
     * This utility method is used throughout material initialization to ensure
     * all required properties have valid values.
     *
     * @param object - The object to check and potentially modify
     * @param propertyName - The name of the property to check
     * @param initialValue - The default value to set if the property is undefined
     */
    private static __initializeForUndefinedProperty;
    /**
     * Processes and validates GLTF load options for VRM import.
     * This method handles file extension conversion (.vrm to .glb), sets up
     * default material helpers, and configures VRM-specific import flags.
     *
     * @param options - The input load options to process
     * @returns Processed and validated load options with VRM-specific defaults
     */
    static _getOptions(options?: GltfLoadOption): GltfLoadOption;
}

/**
 * A utility class for importing and processing VRM (Virtual Reality Model) files.
 * This class handles the conversion of VRM data into Rhodonite's internal representation,
 * including materials, spring bones, expressions, constraints, and humanoid structures.
 */
declare class VrmImporter {
    private constructor();
    /**
     * Imports a VRM model from a glTF structure and sets up all VRM-specific components.
     * This method processes materials, spring bones, expressions, constraints, and humanoid data.
     *
     * @param gltfModel - The parsed glTF model containing VRM extensions
     * @param renderPasses - Array of render passes to add the imported model to
     * @returns Promise that resolves when the import process is complete
     */
    static __importVRM(gltfModel: RnM2, renderPasses: RenderPass[]): Promise<void>;
    /**
     * Reads and processes VRM constraint data from the model.
     * Supports roll, aim, and rotation constraints as defined in the VRMC_node_constraint extension.
     *
     * @param gltfModel - The VRM model containing constraint data
     */
    static _readConstraints(gltfModel: Vrm1): void;
    /**
     * Reads and processes VRM facial expressions (blend shapes) from the model.
     * Creates VrmExpression objects and attaches them to the root entity's VrmComponent.
     *
     * @param gltfModel - The VRM model containing expression data
     * @param rootEntity - The root entity to attach the VRM component to
     */
    static _readExpressions(gltfModel: Vrm1, rootEntity: ISceneGraphEntity): void;
    /**
     * Reads and processes VRM humanoid bone mapping information.
     * Creates a mapping between bone names and node indices for humanoid structure.
     *
     * @param gltfModel - The VRM model containing humanoid data
     * @param rootEntity - Optional root entity to tag with humanoid information
     */
    static _readVRMHumanoidInfo(gltfModel: Vrm1, rootEntity?: ISceneGraphEntity): void;
    /**
     * Reads and processes VRM spring bone physics data from the model.
     * Sets up collider groups, spring bones, and physics components for dynamic hair and cloth simulation.
     *
     * @param gltfModel - The VRM model containing spring bone data
     */
    static _readSpringBone(gltfModel: Vrm1): void;
    /**
     * Recursively adds spring bone components to all child entities in the hierarchy.
     * This ensures that all bones in a spring bone chain are properly configured.
     *
     * @param vrmSpring - The VRM spring object to add bones to
     * @param entity - The current entity to process
     * @param addedEntities - Array of entities that have already been processed
     */
    private static __addSpringBoneRecursively;
    /**
     * Adds a physics component with VRM spring bone strategy to an entity.
     * This enables physics simulation for the spring bone system.
     *
     * @param spring - The VRM spring configuration
     * @param sg - The scene graph component to add physics to
     */
    private static __addPhysicsComponent;
    /**
     * Creates texture objects from the glTF model data.
     * Also generates dummy white and black textures for default material properties.
     *
     * @param gltfModel - The glTF model containing texture data
     * @returns Promise resolving to an array of created Texture objects
     */
    static _createTextures(gltfModel: RnM2): Promise<Texture[]>;
    /**
     * Creates sampler objects from the glTF model data.
     * Also generates dummy samplers for default texture sampling configuration.
     *
     * @param gltfModel - The glTF model containing sampler data
     * @returns Array of created Sampler objects
     */
    static _createSamplers(gltfModel: RnM2): Sampler[];
    /**
     * Initializes MToon material properties and determines if outline rendering is needed.
     * MToon is the standard toon shader used in VRM models.
     *
     * @param gltfModel - The glTF model containing material data
     * @param texturesLength - The number of textures in the model
     * @returns True if any material requires outline rendering, false otherwise
     */
    private static __initializeMToonMaterialProperties;
    /**
     * Processes and validates import options for VRM files.
     * Converts .vrm file extensions to .glb and sets up default material helper arguments.
     *
     * @param options - Optional import configuration
     * @returns Processed and validated import options
     */
    static _getOptions(options?: GltfLoadOption): GltfLoadOption;
    /**
     * Imports only the JSON data structure of a VRM file without processing the full model.
     * This is useful for extracting metadata and structure information without full rendering setup.
     *
     * @param uri - The URI or path to the VRM file
     * @param options - Optional import configuration
     * @returns Promise resolving to the VRM JSON structure
     */
    static importJsonOfVRM(uri: string, options?: GltfLoadOption): Promise<Vrm1>;
}

/**
 * A utility class for importing VRMA (VRM Animation) files.
 *
 * VRMA is an extension format for VRM that adds animation capabilities,
 * allowing for the import and processing of humanoid animation data.
 * This class provides static methods to import VRMA files from various sources
 * and processes the humanoid bone mapping for efficient animation playback.
 *
 * @remarks
 * This class extends the functionality of Gltf2Importer to handle VRMA-specific
 * features, particularly the VRMC_vrm_animation extension that contains
 * humanoid bone definitions and animation data.
 *
 * @example
 * ```typescript
 * // Import from URL
 * const vrmaData = await VrmaImporter.importFromUrl('https://example.com/animation.vrma');
 *
 * // Import from file buffer
 * const fileBuffer = await file.arrayBuffer();
 * const vrmaData = await VrmaImporter.importFromArrayBuffer(fileBuffer);
 * ```
 */
declare class VrmaImporter {
    /**
     * Imports a VRMA (VRM Animation) file from a URL.
     *
     * @param url - The URL of the VRMA file to import
     * @returns A Promise that resolves to the imported VRMA data structure
     * @throws Will reject the promise if the import fails or the URL is invalid
     *
     * @example
     * ```typescript
     * const vrmaData = await VrmaImporter.importFromUrl('https://example.com/animation.vrma');
     * ```
     */
    static importFromUrl(url: string): Promise<RnM2Vrma>;
    /**
     * Imports a VRMA (VRM Animation) file from an ArrayBuffer.
     *
     * @param arrayBuffer - The ArrayBuffer containing the VRMA file data
     * @returns A Promise that resolves to the imported VRMA data structure
     * @throws Will reject the promise if the import fails or the ArrayBuffer is invalid
     *
     * @example
     * ```typescript
     * const fileBuffer = await file.arrayBuffer();
     * const vrmaData = await VrmaImporter.importFromArrayBuffer(fileBuffer);
     * ```
     */
    static importFromArrayBuffer(arrayBuffer: ArrayBuffer): Promise<RnM2Vrma>;
    /**
     * Reads and processes the humanoid bone data from a VRMA file.
     * Creates a mapping between node IDs and human bone names for easier bone lookup.
     *
     * @param rnm - The RnM2Vrma object containing the VRMA data
     * @returns void - This method modifies the input object in place
     *
     * @remarks
     * This method extracts humanoid bone information from the VRMC_vrm_animation extension
     * and creates a reverse mapping from node IDs to bone names for efficient bone queries.
     * If no humanoid bones are found, the method returns early without processing.
     */
    static readHumanoid(rnm: RnM2Vrma): void;
}

/**
 * Union type representing all possible default values that can be assigned to a Socket.
 * Includes mathematical types like vectors, scalars, and matrices.
 */
type SocketDefaultValue = Vector4 | Vector3 | Vector2 | Scalar | Matrix44 | Matrix33;
/**
 * Represents a socket in the material system that defines an input/output connection point
 * for shader parameters. A socket has a name, composition type, component type, and optional default value.
 *
 * @template Name - The string literal type for the socket name
 * @template N - The composition type enum value (e.g., Scalar, Vec2, Vec3, etc.)
 * @template T - The component type enum value (e.g., Float, Int, Bool, etc.)
 * @template V - The default value type that extends SocketDefaultValue
 */
declare class Socket<Name extends string, N extends CompositionTypeEnum, T extends ComponentTypeEnum, V extends SocketDefaultValue> {
    readonly name: Name;
    readonly compositionType: N;
    readonly componentType: T;
    readonly defaultValue?: V | undefined;
    /**
     * Creates a new Socket instance with the specified name, types, and optional default value.
     *
     * @param name - The unique identifier name for this socket
     * @param compositionType - The composition type that defines the structure (scalar, vector, matrix)
     * @param componentType - The component type that defines the data type (float, int, bool, etc.)
     * @param defaultValue - Optional default value for the socket when no input is connected
     */
    constructor(name: Name, compositionType: N, componentType: T, defaultValue?: V | undefined);
}

/**
 * Abstract base class that provides common shader functionality for both WebGL and WebGPU rendering approaches.
 * This class handles shader code generation, vertex/fragment shader prerequisites, and cross-platform compatibility
 * between WebGL and WebGPU shader languages (GLSL and WGSL).
 */
declare abstract class CommonShaderPart {
    static __instance: CommonShaderPart;
    __webglResourceRepository?: WebGLResourceRepository;
    /**
     * Generates the main function beginning code for vertex or fragment shaders.
     * Handles differences between WebGL (GLSL) and WebGPU (WGSL) shader languages.
     *
     * @param isVertexStage - True if generating code for vertex shader, false for fragment shader
     * @returns The shader code string for the main function beginning
     */
    static getMainBegin(isVertexStage: boolean): string;
    /**
     * Generates the main function ending code for vertex or fragment shaders.
     * Handles differences between WebGL (GLSL) and WebGPU (WGSL) shader languages.
     *
     * @param isVertexStage - True if generating code for vertex shader, false for fragment shader
     * @returns The shader code string for the main function ending
     */
    static getMainEnd(isVertexStage: boolean): "\n  return output;\n}\n" | "\n  return rt0;\n}\n" | "\n}\n    ";
    /**
     * Generates vertex shader prerequisites including definitions, vertex inputs, and uniform declarations.
     * Creates appropriate code for both WebGL (GLSL) and WebGPU (WGSL) based on the current process approach.
     *
     * @param shaderNodes - Array of shader nodes used to generate varying variables for WebGPU
     * @returns The complete vertex shader prerequisites code string
     */
    static getVertexPrerequisites(shaderNodes: AbstractShaderNode[]): string;
    /**
     * Creates varying variables declaration string for WebGPU shaders.
     * Analyzes shader node connections to determine which variables need to be passed from vertex to fragment stage.
     *
     * @param shaderNodes - Array of shader nodes to analyze for varying variables
     * @returns WGSL varying variables declaration string
     * @private
     */
    private static __makeVaryingVariablesWGSL;
    /**
     * Generates fragment/pixel shader prerequisites including definitions and varying variable declarations.
     * Creates appropriate code for both WebGL (GLSL) and WebGPU (WGSL) based on the current process approach.
     *
     * @param shaderNodes - Array of shader nodes used to generate varying variables for WebGPU
     * @returns The complete fragment shader prerequisites code string
     */
    static getPixelPrerequisites(shaderNodes: AbstractShaderNode[]): string;
    /**
     * Generates the main prerequisites section placeholder for shader code.
     * This is used by the shaderity system to inject additional prerequisites.
     *
     * @returns The main prerequisites placeholder string
     */
    static getMainPrerequisites(): string;
    /**
     * Generates variable assignment statement with proper type declaration.
     * Creates appropriate syntax for both WebGL (GLSL) and WebGPU (WGSL) based on the current process approach.
     *
     * @param varName - The name of the variable to declare
     * @param inputSocket - The socket containing type and default value information
     * @returns The variable assignment statement string
     */
    static getAssignmentStatement(varName: string, inputSocket: Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue>): string;
    /**
     * Generates varying variable assignment statement for fragment/pixel shaders.
     * Creates code to read varying variables passed from vertex shader with proper type declaration.
     *
     * @param varName - The name of the variable to declare
     * @param inputSocket - The socket containing type information
     * @param inputNode - The shader node that provides the varying variable
     * @returns The varying variable assignment statement string for fragment shader
     */
    static getAssignmentVaryingStatementInPixelShader(varName: string, inputSocket: Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue>, inputNode: AbstractShaderNode): string;
    /**
     * Generates varying variable assignment statement for vertex shaders.
     * Creates code to write varying variables that will be passed to fragment shader.
     *
     * @param inputNode - The shader node that provides the varying variable
     * @param varNames - Array of variable names to assign
     * @param j - Index of the current variable in the varNames array
     * @returns The varying variable assignment statement string for vertex shader
     */
    static getAssignmentVaryingStatementInVertexShader(inputNode: AbstractShaderNode, varNames: string[], j: number): string;
    /**
     * Gets the attribute names used by this shader part.
     * Must be implemented by concrete subclasses to define which vertex attributes are used.
     *
     * @returns Object containing attribute name mappings
     */
    abstract get attributeNames(): AttributeNames;
    /**
     * Gets the vertex attribute semantics used by this shader part.
     * Must be implemented by concrete subclasses to define the semantic meaning of each attribute.
     *
     * @returns Array of vertex attribute enums defining the semantics
     */
    abstract get attributeSemantics(): Array<VertexAttributeEnum>;
    /**
     * Gets the composition types for each vertex attribute used by this shader part.
     * Must be implemented by concrete subclasses to define the data composition (scalar, vec2, vec3, etc.).
     *
     * @returns Array of composition type enums defining the data structure
     */
    abstract get attributeCompositions(): Array<CompositionTypeEnum>;
    /**
     * Gets the vertex shader definitions code.
     * Must be implemented by concrete subclasses to provide shader-specific definitions.
     *
     * @returns Vertex shader definitions code string
     */
    abstract get vertexShaderDefinitions(): string;
    /**
     * Gets the pixel/fragment shader definitions code.
     * Must be implemented by concrete subclasses to provide shader-specific definitions.
     *
     * @returns Fragment shader definitions code string
     */
    abstract get pixelShaderDefinitions(): string;
}

type ShaderAttributeOrSemanticsOrString = string | VertexAttributeEnum | ShaderSemanticsEnum;
type ShaderSocket = {
    compositionType: CompositionTypeEnum;
    componentType: ComponentTypeEnum;
    name: ShaderAttributeOrSemanticsOrString;
    isClosed?: boolean;
};
type ShaderNodeUID = number;
type ShaderNodeInputConnectionType = {
    shaderNodeUid: number;
    outputNameOfPrev: string;
    inputNameOfThis: string;
};
type ShaderStage = 'Neutral' | 'Vertex' | 'Fragment';
/**
 * AbstractShaderNode is an abstract class that represents a shader node in a node-based shader system.
 * It provides the foundation for creating custom shader nodes with inputs, outputs, and connections.
 */
declare abstract class AbstractShaderNode extends RnObject {
    static _shaderNodes: AbstractShaderNode[];
    protected __shaderFunctionName: string;
    protected __inputs: Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue>[];
    protected __outputs: Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue>[];
    protected __inputConnections: ShaderNodeInputConnectionType[];
    private static __invalidShaderNodeCount;
    protected __shaderNodeUid: ShaderNodeUID;
    private __codeGLSL?;
    private __codeWGSL?;
    protected __commonPart?: CommonShaderPart;
    private _shaderStage;
    /**
     * Creates a new AbstractShaderNode instance.
     * @param shaderNodeName - The name identifier for this shader node
     * @param shader - The shader configuration object containing GLSL/WGSL code or common shader parts
     * @param shader.codeGLSL - Optional GLSL shader code for this node
     * @param shader.codeWGSL - Optional WGSL shader code for this node
     * @param shader.commonPart - Optional common shader part containing reusable shader definitions
     */
    constructor(shaderNodeName: string, shader: {
        codeGLSL?: string;
        codeWGSL?: string;
        commonPart?: CommonShaderPart;
    });
    /**
     * Sets the shader stage for this node (Neutral, Vertex, or Fragment).
     * @param stage - The shader stage to assign to this node
     */
    setShaderStage(stage: ShaderStage): void;
    /**
     * Gets the current shader stage of this node.
     * @returns The current shader stage
     */
    getShaderStage(): ShaderStage;
    /**
     * Retrieves a shader node by its unique identifier.
     * @param uid - The unique identifier of the shader node
     * @returns The shader node with the specified UID
     */
    static getShaderNodeByUid(uid: ShaderNodeUID): AbstractShaderNode;
    /**
     * Adds an input connection to this node from another shader node.
     * This establishes a data flow connection between the output of one node and the input of this node.
     * @param inputShaderNode - The source shader node to connect from
     * @param outputSocketOfInput - The output socket of the source node
     * @param inputSocketOfThis - The input socket of this node to connect to
     * @template N - The composition type enum
     * @template T - The component type enum
     */
    addInputConnection<N extends CompositionTypeEnum, T extends ComponentTypeEnum>(inputShaderNode: AbstractShaderNode, outputSocketOfInput: Socket<string, N, T, SocketDefaultValue>, inputSocketOfThis: Socket<string, N, T, SocketDefaultValue>): void;
    /**
     * Gets the shader function name for this node.
     * @returns The function name used in shader code
     */
    get shaderFunctionName(): string;
    /**
     * Gets the derivative shader function name for this node.
     * By default, returns the same as the regular function name.
     * @returns The derivative function name used in shader code
     */
    getShaderFunctionNameDerivative(): string;
    /**
     * Retrieves the shader code for the specified shader stage.
     * Returns appropriate code based on the current rendering approach (WebGL/WebGPU).
     * @param shaderStage - The shader stage (vertex or fragment) to get code for
     * @returns The shader code string for the specified stage
     */
    getShaderCode(shaderStage: ShaderTypeEnum): string;
    /**
     * Gets the unique identifier for this shader node.
     * @returns The unique node identifier
     */
    get shaderNodeUid(): ShaderNodeUID;
    /**
     * Finds and returns an input socket by name.
     * @param name - The name of the input socket to find
     * @returns The input socket if found, undefined otherwise
     */
    getInput(name: string): Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue> | undefined;
    /**
     * Gets all input sockets for this node.
     * @returns An array of all input sockets
     */
    getInputs(): Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue>[];
    /**
     * Finds and returns an output socket by name.
     * @param name - The name of the output socket to find
     * @returns The output socket if found, undefined otherwise
     */
    getOutput(name: string): Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue> | undefined;
    /**
     * Gets all output sockets for this node.
     * @returns An array of all output sockets
     */
    getOutputs(): Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue>[];
    /**
     * Gets all input connections for this node.
     * @returns An array of input connection configurations
     */
    get inputConnections(): ShaderNodeInputConnectionType[];
    /**
     * Generates a function call statement for this shader node in the final shader code.
     * This method constructs the appropriate function call syntax with proper parameter passing
     * for both WebGL and WebGPU rendering approaches.
     * @param i - The index of this node in the execution order
     * @param shaderNode - The shader node to generate the call for
     * @param functionName - The name of the function to call
     * @param varInputNames - Array of input variable names for each node
     * @param varOutputNames - Array of output variable names for each node
     * @returns The generated function call statement string
     */
    makeCallStatement(i: number, shaderNode: AbstractShaderNode, functionName: string, varInputNames: string[][], varOutputNames: string[][]): string;
}

/**
 * Repository class for managing material types and instances.
 * Handles registration, creation, and lifecycle management of materials.
 */
declare class MaterialRepository {
    private static __materialMap;
    private static __instances;
    private static __materialTids;
    private static __materialInstanceCountOfType;
    private static __materialNodes;
    private static __maxInstances;
    private static __bufferViews;
    private static __accessors;
    private static __materialTidCount;
    private static __materialUidCount;
    /**
     * Registers a new material type with the repository.
     * This method creates the necessary data structures and allocates memory for the material type.
     * If the material type is already registered, the registration will be skipped.
     *
     * @param materialTypeName - The unique name identifier for the material type
     * @param materialNode - The material content definition containing shader semantics and properties
     * @param maxInstanceNumber - The maximum number of instances that can be created for this material type
     * @returns True if the material type was successfully registered, false if it was already registered
     */
    static registerMaterial(materialTypeName: string, materialNode: AbstractMaterialContent, maxInstanceNumber?: number): boolean;
    /**
     * Forcibly registers a material type, overwriting any existing registration.
     * This method bypasses the duplicate check and always performs the registration.
     * Use with caution as it can replace existing material type definitions.
     *
     * @param materialTypeName - The unique name identifier for the material type
     * @param materialNode - The material content definition containing shader semantics and properties
     * @param maxInstanceNumber - The maximum number of instances that can be created for this material type
     * @returns Always returns true as the registration is forced
     */
    static forceRegisterMaterial(materialTypeName: string, materialNode: AbstractMaterialContent, maxInstanceNumber?: number): boolean;
    /**
     * Checks if a material type is already registered in the repository.
     *
     * @param materialTypeName - The name of the material type to check
     * @returns True if the material type is registered, false otherwise
     */
    static isRegisteredMaterialType(materialTypeName: string): boolean;
    /**
     * Retrieves a material instance by its unique identifier.
     * Returns undefined if the material doesn't exist or has been garbage collected.
     *
     * @param materialUid - The unique identifier of the material to retrieve
     * @returns The material instance if found and still alive, undefined otherwise
     */
    static getMaterialByMaterialUid(materialUid: MaterialSID): Material | undefined;
    /**
     * Gets all currently active material instances from the repository.
     * Returns an array of WeakRef objects that may contain undefined values
     * if materials have been garbage collected.
     *
     * @returns Array of WeakRef objects pointing to all registered materials
     */
    static getAllMaterials(): WeakRef<Material>[];
    /**
     * Creates a new material instance of the specified type.
     * The material type must be registered before calling this method.
     * This method handles instance counting and initialization.
     *
     * @param materialTypeName - The name of the registered material type
     * @param materialNode - The material content definition for this specific instance
     * @returns A new Material instance with proper initialization
     * @throws Error if the material type is not registered or maximum instances exceeded
     */
    static createMaterial(materialTypeName: string, materialNode: AbstractMaterialContent): Material;
    /**
     * Checks if the maximum number of instances for a material type has been reached or exceeded.
     * This is useful for preventing memory overflow by limiting material instance creation.
     *
     * @param materialTypeName - The name of the material type to check
     * @returns True if the material type has reached or exceeded its maximum instance count
     */
    static isFullOrOverOfThisMaterialType(materialTypeName: string): boolean;
    /**
     * Determines if a new material node is compatible with an existing material.
     * Compatibility is checked by comparing shader semantics information arrays.
     * Materials are compatible if they have identical shader semantic structures.
     *
     * @param currentMaterial - The existing material to compare against
     * @param newMaterialNode - The new material node to check for compatibility
     * @returns True if the materials are compatible, false otherwise
     */
    static isMaterialCompatible(currentMaterial: Material, newMaterialNode: AbstractMaterialContent): boolean;
    /**
     * Initializes a newly created material instance with proper data structures and memory allocation.
     * This method sets up the material's shader variables, semantic information, and registers
     * the material in the repository's tracking maps.
     *
     * @param material - The material instance to initialize
     * @param countOfThisType - The current count of instances for this material type
     * @private
     */
    private static __initializeMaterial;
    /**
     * Gets the memory location offset for a specific property of a material type.
     * The offset is calculated in 16-byte aligned units for GPU buffer access.
     * This is used for efficient GPU memory access in shaders.
     *
     * @param materialTypeName - The name of the material type
     * @param propertyName - The shader semantic name of the property
     * @returns The byte offset divided by 16 (IndexOf16Bytes) for the property location
     */
    static getLocationOffsetOfMemberOfMaterial(materialTypeName: string, propertyName: ShaderSemanticsName): IndexOf16Bytes;
    /**
     * Internal method that performs the actual material type registration.
     * This method sets up the material type ID, allocates buffer views,
     * and initializes all necessary data structures.
     *
     * @param materialTypeName - The unique name identifier for the material type
     * @param materialNode - The material content definition
     * @param maxInstanceNumber - The maximum number of instances allowed
     * @private
     */
    private static __registerInner;
    /**
     * Allocates GPU buffer memory for a material type based on its shader semantics.
     * This method calculates the total memory requirements, creates buffer views,
     * and sets up accessors for efficient GPU data access.
     *
     * @param materialTypeName - The name of the material type to allocate memory for
     * @param materialNode - The material node containing semantic information
     * @returns The allocated BufferView for the material type
     * @private
     */
    private static __allocateBufferView;
    /**
     * Invalidates all shader programs for all registered materials.
     * This method is typically called when global shader settings change
     * and all materials need to recompile their shaders.
     *
     * @internal
     */
    static _makeShaderInvalidateToAllMaterials(): void;
}

/**
 * ShaderGraphResolver is a class that resolves the shader node graph and generates shader code.
 * It provides functionality to convert a graph of shader nodes into complete vertex and fragment shaders.
 */
declare class ShaderGraphResolver {
    /**
     * Creates a complete vertex shader code from the given vertex and varying nodes.
     * This method performs topological sorting of nodes, generates function definitions,
     * and constructs the main shader body with proper variable declarations and connections.
     *
     * @param vertexNodes - Array of shader nodes that contribute to vertex processing
     * @param varyingNodes - Array of shader nodes that pass data from vertex to fragment stage
     * @param isFullVersion - Whether to generate a full version with all prerequisites and boilerplate
     * @returns Complete vertex shader code as a string, or undefined if generation fails
     */
    static createVertexShaderCode(vertexNodes: AbstractShaderNode[], varyingNodes: AbstractShaderNode[], isFullVersion?: boolean): string | undefined;
    /**
     * Creates a complete fragment/pixel shader code from the given pixel nodes.
     * This method performs topological sorting, generates function definitions,
     * and constructs the main shader body for fragment processing.
     *
     * @param pixelNodes - Array of shader nodes that contribute to fragment processing
     * @param isFullVersion - Whether to generate a full version with all prerequisites and boilerplate
     * @returns Complete fragment shader code as a string, or undefined if generation fails
     */
    static createPixelShaderCode(pixelNodes: AbstractShaderNode[], isFullVersion?: boolean): string | undefined;
    /**
     * Validates that all shader nodes have their required input connections properly set.
     * This is a validation step to ensure the shader graph is complete before code generation.
     *
     * @param shaderNodes - Array of shader nodes to validate
     * @returns True if all nodes are valid, false if any node has missing required connections
     * @private
     */
    private static __validateShaderNodes;
    /**
     * Performs topological sorting on shader nodes to determine the correct execution order.
     * Uses Kahn's algorithm (BFS-based) to sort nodes based on their dependencies.
     * This ensures that nodes are processed in the correct order during shader execution.
     *
     * @param shaderNodes - Array of shader nodes to sort
     * @returns Array of shader nodes sorted in topological order
     * @throws Error if the graph contains cycles
     * @private
     */
    private static __sortTopologically;
    /**
     * Generates function definitions for all unique shader nodes.
     * Collects shader function code from each node type and removes duplicates
     * to create the function definition section of the shader.
     *
     * @param shaderNodes - Array of shader nodes to generate functions for
     * @param shaderType - Type of shader (vertex or fragment) being generated
     * @returns String containing all function definitions
     * @private
     */
    private static __getFunctionDefinition;
    /**
     * Defines varying variables for vertex-to-fragment communication.
     * @private
     */
    private static __defineVaryingVariables;
    /**
     * Collects input and output variable names for shader nodes.
     * @private
     */
    private static __collectVariableNames;
    /**
     * Collects input variables for a specific node.
     * @private
     */
    private static __collectInputsForNode;
    /**
     * Gets default value for an input socket.
     * @private
     */
    private static __getDefaultInputValue;
    /**
     * Processes an input connection and returns variable name and shader statement.
     * @private
     */
    private static __processInputConnection;
    /**
     * Collects output variables for a specific node.
     * @private
     */
    private static __collectOutputsForNode;
    /**
     * Generates shader code for the nodes.
     * @private
     */
    private static __generateShaderCode;
    /**
     * Handles vertex-to-fragment data passing in vertex stage.
     * @private
     */
    private static __handleVertexToFragmentPassing;
    /**
     * Constructs the main shader body with proper variable declarations, connections, and function calls.
     * This is the core method that generates the actual shader execution logic by:
     * - Declaring varying variables for vertex-to-fragment communication
     * - Collecting input/output variable names for each node
     * - Generating function call statements in topological order
     * - Handling vertex-to-fragment data passing
     *
     * @param shaderNodes - Array of shader nodes sorted in topological order
     * @param isVertexStage - True for vertex shader generation, false for fragment
     * @param isFullVersion - Whether to include full shader boilerplate
     * @returns Complete shader main function body as a string
     * @throws Error if shader construction fails
     * @private
     */
    private static __constructShaderWithNodes;
    /**
     * Generates complete vertex and fragment shader code from a JSON shader node graph definition.
     * This is the main entry point for converting a serialized shader graph into executable shader code.
     * The method performs the full pipeline: node construction, dependency resolution, stage assignment,
     * and final code generation.
     *
     * @param json - JSON representation of the shader node graph containing nodes and connections
     * @returns Object containing both vertex and fragment shader code, or undefined if generation fails
     * @example
     * ```typescript
     * const shaderCode = ShaderGraphResolver.generateShaderCodeFromJson(graphJson);
     * if (shaderCode) {
     *   const { vertexShader, pixelShader } = shaderCode;
     *   // Use the generated shaders...
     * }
     * ```
     */
    static generateShaderCodeFromJson(json: ShaderNodeJson): {
        vertexShader: string;
        pixelShader: string;
    } | undefined;
}

type FillArgsObject = {
    [key: string]: string | object;
};
type VertexAttributesLayout = {
    names: string[];
    semantics: VertexAttributeEnum[];
    compositions: CompositionTypeEnum[];
    components: ComponentTypeEnum[];
};
/**
 * A utility class for processing and managing Shaderity shader objects in WebGL environments.
 *
 * This class provides comprehensive functionality for shader processing including:
 * - Template filling and parameter substitution in shader code
 * - WebGL version compatibility transformations (WebGL 1.0/2.0)
 * - Shader reflection for extracting vertex attribute information
 * - Uniform declaration parsing and semantic information extraction
 * - Initial value parsing and type conversion for shader uniforms
 *
 * The class integrates with the Shaderity library to provide enhanced shader processing
 * capabilities specifically tailored for the Rhodonite rendering engine's WebGL backend.
 * It handles the complex process of analyzing GLSL shader code, extracting metadata
 * from comments, and preparing shader objects for use in the rendering pipeline.
 *
 * All methods are static and the class serves as a namespace for shader utility functions.
 *
 * @example
 * ```typescript
 * // Fill shader template with arguments
 * const filledShader = ShaderityUtilityWebGL.fillTemplate(shaderObject, { color: 'red' });
 *
 * // Transform for WebGL 2.0 compatibility
 * const webgl2Shader = ShaderityUtilityWebGL.transformWebGLVersion(filledShader, true);
 *
 * // Extract vertex attribute information
 * const attributes = ShaderityUtilityWebGL.getAttributeReflection(webgl2Shader);
 * ```
 */
declare class ShaderityUtilityWebGL {
    /**
     * Fills template placeholders in a shader object with provided arguments and WebGL-specific parameters.
     * This method performs a two-step template filling process: first with user-provided arguments,
     * then with WebGL resource repository specific parameters.
     *
     * @param shaderityObject - The shader object containing template placeholders to be filled
     * @param args - Key-value pairs of template arguments to fill in the shader
     * @returns A new ShaderityObject with all template placeholders replaced
     */
    static fillTemplate(shaderityObject: ShaderityObject, args: FillArgsObject): ShaderityObject;
    /**
     * Transforms a shader object to target a specific WebGL version (WebGL 1.0 or 2.0).
     * This method converts GLSL code to be compatible with either GLSL ES 1.0 or 3.0
     * depending on the WebGL version being used.
     *
     * @param shaderityObject - The shader object to transform
     * @param isWebGL2 - Whether to target WebGL 2.0 (true) or WebGL 1.0 (false)
     * @returns A new ShaderityObject with version-appropriate GLSL code
     */
    static transformWebGLVersion(shaderityObject: ShaderityObject, isWebGL2: boolean): ShaderityObject;
    /**
     * Extracts vertex attribute information from a shader object using reflection.
     * This method analyzes the shader code to determine vertex attribute names, semantics,
     * compositions, and component types required for proper vertex buffer binding.
     *
     * @param shaderityObject - The shader object to analyze for vertex attributes
     * @returns An object containing arrays of attribute names, semantics, compositions, and components
     */
    static getAttributeReflection(shaderityObject: ShaderityObject): VertexAttributesLayout;
    /**
     * Sets default semantic mappings for vertex attributes in the reflection object.
     * This private method configures predefined attribute name to semantic mappings
     * that are commonly used in the rendering pipeline.
     *
     * @param reflection - The reflection object to configure with semantic mappings
     * @private
     */
    private static __setDefaultAttributeSemanticMap;
    /**
     * Extracts shader uniform data and semantic information from a shader object.
     * This method parses uniform declarations in the shader code, extracts metadata
     * from comments, and creates semantic information objects for each uniform.
     *
     * @param shaderityObject - The shader object to analyze for uniform declarations
     * @returns An object containing an array of shader semantic info and a modified shader object with uniforms removed
     */
    static getShaderDataReflection(shaderityObject: ShaderityObject): {
        shaderSemanticsInfoArray: ShaderSemanticsInfo[];
        shaderityObject: ShaderityObject;
    };
    /**
     * Creates a deep copy of a ShaderityObject to avoid modifying the original.
     * This utility method ensures that shader transformations don't affect the source object.
     *
     * @param obj - The ShaderityObject to copy
     * @returns A new ShaderityObject with the same properties as the input
     * @private
     */
    private static __copyShaderityObject;
    /**
     * Determines whether a uniform declaration should be ignored based on metadata comments.
     * This method checks for the 'skipProcess=true' directive in shader comments.
     *
     * @param info - The comment string following a uniform declaration
     * @returns True if the uniform should be ignored, false otherwise
     * @private
     */
    private static __ignoreThisUniformDeclaration;
    /**
     * Creates a ShaderSemanticsInfo object from uniform declaration components.
     * This method constructs semantic information including component type, composition type,
     * shader stage, and other metadata for a shader uniform.
     *
     * @param type - The GLSL type string of the uniform (e.g., 'vec3', 'mat4')
     * @param variableName - The name of the uniform variable
     * @param info - The comment string containing metadata about the uniform
     * @param isFragmentShader - Whether this uniform belongs to a fragment shader
     * @returns A complete ShaderSemanticsInfo object for the uniform
     * @private
     */
    private static __createShaderSemanticsInfo;
    /**
     * Parses and sets Rhodonite-specific parameters from shader comment metadata.
     * This method extracts custom parameters like soloDatum, isInternalSetting,
     * initialValue, and needUniformInDataTextureMode from shader comments.
     *
     * @param shaderSemanticsInfo - The semantic info object to populate with parameters
     * @param info - The comment string containing parameter definitions
     * @private
     */
    private static __setRhodoniteOriginalParametersTo;
    /**
     * Parses an initial value from a text string and converts it to the appropriate data type.
     * This method handles various GLSL types including scalars, vectors, matrices, and textures,
     * and creates the corresponding Rhodonite math objects or texture references.
     *
     * @param shaderSemanticsInfo - The semantic info containing type information for validation
     * @param initialValueText - The text representation of the initial value
     * @returns The parsed initial value as the appropriate Rhodonite math type or texture array
     * @private
     */
    private static __getInitialValueFromText;
    /**
     * Provides default initial values for shader uniforms based on their composition type.
     * This method creates zero/identity values for mathematical types and default textures
     * for texture types when no explicit initial value is specified.
     *
     * @param shaderSemanticsInfo - The semantic info containing the composition type
     * @returns The default initial value appropriate for the uniform's type
     * @private
     */
    private static __getDefaultInitialValue;
}

/**
 * TextureArray class represents a 2D texture array that can hold multiple texture layers.
 * This class extends AbstractTexture and implements the Disposable interface for proper resource management.
 * It provides automatic garbage collection cleanup through FinalizationRegistry and supports both WebGL and WebGPU APIs.
 */
declare class TextureArray extends AbstractTexture implements Disposable {
    /**
     * Finalization registry for automatic cleanup of texture resources when objects are garbage collected.
     * This helps prevent memory leaks by automatically releasing GPU resources.
     */
    private static managedRegistry;
    /**
     * Sets the texture resource UID and registers the texture for automatic cleanup.
     * This method is called internally when a texture resource is created.
     *
     * @param textureResourceUid - The unique identifier for the texture resource
     * @param uniqueName - A unique name for the texture used in logging and debugging
     * @private
     */
    private __setTextureResourceUid;
    /**
     * Deletes the internal texture resource from the graphics API.
     * This is a static method used by the finalization registry for cleanup.
     *
     * @param textureResourceUid - The unique identifier of the texture resource to delete
     * @private
     */
    private static __deleteInternalTexture;
    /**
     * Loads a 1x1 texture array with a solid color.
     * This creates a texture array with the specified number of layers (Config.maxLightNumber),
     * each containing a single pixel of the specified color.
     *
     * @param rgbaStr - CSS color string in rgba format (default: 'rgba(0,0,0,1)' for black)
     *
     * @example
     * ```typescript
     * const textureArray = new TextureArray();
     * textureArray.load1x1Texture('rgba(255,0,0,1)'); // Red texture
     * ```
     */
    load1x1Texture(rgbaStr?: string): void;
    /**
     * Destroys the 3D API resources associated with this texture array.
     * This method releases the texture from GPU memory and resets the texture state.
     * After calling this method, the texture cannot be used until reloaded.
     */
    destroy3DAPIResources(): void;
    /**
     * Symbol.dispose implementation for automatic resource cleanup.
     * This method is called when the object is used with 'using' declaration or explicit disposal.
     * It provides a standardized way to clean up resources.
     */
    [Symbol.dispose](): void;
    /**
     * Completely destroys the texture array and all associated resources.
     * This method should be called when the texture is no longer needed to prevent memory leaks.
     * It performs the following cleanup operations:
     * - Destroys 3D API resources
     * - Unregisters from parent class
     * - Unregisters from finalization registry
     */
    destroy(): void;
}

/**
 * A dummy white 1x1 texture used as a fallback for missing textures.
 * This texture provides a safe default when no specific texture is available.
 */
declare const dummyWhiteTexture: Texture;
/**
 * A dummy blue 1x1 texture with RGB values of (127.5, 127.5, 255).
 * Commonly used as a default normal map texture.
 */
declare const dummyBlueTexture: Texture;
/**
 * A dummy black 1x1 texture with RGB values of (0, 0, 0).
 * Used as a fallback for textures that should have no contribution.
 */
declare const dummyBlackTexture: Texture;
/**
 * A dummy black cube texture used as a fallback for environment maps.
 * Provides a default cube texture when no environment map is specified.
 */
declare const dummyBlackCubeTexture: CubeTexture;
/**
 * A dummy transparent 1x1 texture with RGBA values of (0, 0, 0, 0).
 * Used when a completely transparent texture is needed.
 */
declare const dummyZeroTexture: Texture;
/**
 * A lookup texture for sheen calculations in material rendering.
 * Contains pre-computed sheen values for efficient material evaluation.
 */
declare const sheenLutTexture: Texture;
/**
 * A dummy sRGB gray 1x1 texture with RGB values of (186, 186, 186).
 * Provides a neutral gray color in sRGB color space.
 */
declare const dummySRGBGrayTexture: Texture;
/**
 * A dummy anisotropy 1x1 texture with RGB values of (255, 127.5, 255).
 * Used as a default for anisotropic material properties.
 */
declare const dummyAnisotropyTexture: Texture;
/**
 * A dummy depth moment texture array used for variance shadow mapping.
 * Provides default depth and moment values for shadow calculations.
 */
declare const dummyDepthMomentTextureArray: TextureArray;
/**
 * Initializes all default dummy textures with their appropriate data.
 * This function should be called once during application startup to ensure
 * all dummy textures are properly configured and ready for use.
 *
 * @returns A promise that resolves when all textures are initialized
 */
declare function initDefaultTextures(): Promise<void>;
/**
 * A collection of all default textures available in the system.
 * This object provides convenient access to all dummy textures
 * and can be used for texture fallbacks throughout the application.
 */
declare const DefaultTextures: {
    dummyWhiteTexture: Texture;
    dummyBlueTexture: Texture;
    dummyBlackTexture: Texture;
    dummyBlackCubeTexture: CubeTexture;
    dummyZeroTexture: Texture;
    sheenLutTexture: Texture;
    dummySRGBGrayTexture: Texture;
    dummyAnisotropyTexture: Texture;
    dummyDepthMomentTextureArray: TextureArray;
};

/**
 * A shader node that performs addition operations between two input values.
 * Supports scalar, Vec2, Vec3, and Vec4 compositions with appropriate component types.
 *
 * This node creates two input sockets (lhs and rhs) and one output socket,
 * all of the same composition and component type. The node generates shader code
 * for both WebGL (GLSL) and WebGPU (WGSL) backends.
 *
 * @example
 * ```typescript
 * // Create an add node for Vec3 float operations
 * const addNode = new AddShaderNode(CompositionType.Vec3, ComponentType.Float);
 *
 * // Connect inputs and get output
 * const lhsSocket = addNode.getSocketInputLhs();
 * const rhsSocket = addNode.getSocketInputRhs();
 * const outputSocket = addNode.getSocketOutput();
 * ```
 */
declare class AddShaderNode extends AbstractShaderNode {
    /**
     * Creates a new AddShaderNode with the specified composition and component types.
     *
     * @param compositionType - The composition type (Scalar, Vec2, Vec3, or Vec4)
     * @param componentType - The component type (Float, Int, etc.)
     *
     * @throws {Error} Throws an error if the composition type is not supported
     */
    constructor(compositionType: CompositionTypeEnum, componentType: ComponentTypeEnum);
    /**
     * Returns the default value for a given composition type.
     * This is used to initialize input sockets with appropriate zero values.
     *
     * @param compositionType - The composition type to get the default value for
     * @returns The default value (zero) for the specified composition type
     *
     * @throws {Error} Throws an error if the composition type is not implemented
     */
    getDefaultValue(compositionType: CompositionTypeEnum): Vector4 | Vector3 | Vector2 | Scalar;
    /**
     * Gets the left-hand side input socket.
     * This socket represents the first operand in the addition operation.
     *
     * @returns The left-hand side input socket
     */
    getSocketInputLhs(): Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue>;
    /**
     * Gets the right-hand side input socket.
     * This socket represents the second operand in the addition operation.
     *
     * @returns The right-hand side input socket
     */
    getSocketInputRhs(): Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue>;
    /**
     * Gets the output socket that contains the result of the addition operation.
     *
     * @returns The output socket containing the addition result
     */
    getSocketOutput(): Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue>;
    /**
     * Generates the appropriate shader function name derivative based on the current
     * rendering backend and input socket types.
     *
     * For WebGPU, this method generates type-specific function names to handle
     * different combinations of composition and component types. For WebGL,
     * it returns the base shader function name.
     *
     * @returns The shader function name derivative for the current configuration
     *
     * @throws {Error} Throws an error if the input socket type combination is not implemented
     */
    getShaderFunctionNameDerivative(): string;
}

/**
 * A shader node that reads vertex color attributes from the mesh geometry.
 * This node provides access to per-vertex color data in the shader pipeline,
 * allowing for vertex-based coloring effects and material variations.
 *
 * The node outputs a Vec4 color value containing RGBA components that can be
 * used in vertex or fragment shaders for rendering calculations.
 */
declare class AttributeColorShaderNode extends AbstractShaderNode {
    /**
     * Creates a new AttributeColorShaderNode instance.
     * Initializes the node with vertex color attribute shader code for both
     * WebGL (GLSL) and WebGPU (WGSL) backends, and configures the output
     * to provide a Vec4 color value.
     */
    constructor();
}

/**
 * A shader node that provides access to vertex normal attributes.
 * This node outputs the normal vector attribute of vertices for use in shader computations.
 * It supports both WebGL (GLSL) and WebGPU (WGSL) rendering backends.
 *
 * @example
 * ```typescript
 * const normalNode = new AttributeNormalShaderNode();
 * // Use the normal output in other shader nodes
 * const normalOutput = normalNode.getOutput('outValue');
 * ```
 */
declare class AttributeNormalShaderNode extends AbstractShaderNode {
    /**
     * Creates a new AttributeNormalShaderNode instance.
     *
     * Initializes the shader node with vertex stage shader code for both GLSL and WGSL,
     * and sets up a Vec3 float output for the normal vector attribute.
     * The output represents the normal vector in 3D space with floating-point precision.
     */
    constructor();
}

/**
 * A shader node that provides access to vertex position attributes.
 * This node outputs the position attribute data from the vertex buffer,
 * typically used as input for vertex transformations in the rendering pipeline.
 */
declare class AttributePositionShaderNode extends AbstractShaderNode {
    /**
     * Creates a new AttributePositionShaderNode instance.
     * Initializes the node with position attribute shader code for both GLSL and WGSL,
     * sets up the vertex shader stage, and configures the output socket for Vec4 position data.
     */
    constructor();
    /**
     * Gets the output socket of this attribute position node.
     * The output socket provides a Vec4 value representing the vertex position attribute.
     *
     * @returns The output socket containing the position attribute data
     */
    getSocketOutput(): Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue>;
}

/**
 * A shader node that provides texture coordinate attributes from vertex data.
 * This node outputs UV coordinates for texture mapping operations.
 *
 * @extends AbstractShaderNode
 */
declare class AttributeTexcoordShaderNode extends AbstractShaderNode {
    /**
     * Creates a new AttributeTexcoordShaderNode instance.
     * Initializes the node with GLSL and WGSL shader codes for texture coordinate attributes.
     * Sets up the vertex shader stage and configures the output as a Vec3 float value.
     */
    constructor();
}

/**
 * A shader node that marks the beginning of a conditional block in a node-based shader graph.
 * This node acts as a conditional gateway that can pass through multiple values based on a boolean condition.
 * It dynamically manages input and output sockets for different data types and compositions.
 *
 * The node generates GLSL/WGSL code that implements a conditional block start function,
 * where values are passed through to outputs based on the blockStart boolean input.
 *
 * @example
 * ```typescript
 * const blockBeginNode = new BlockBeginShaderNode();
 * blockBeginNode.addInputAndOutput(CompositionType.Vec3, ComponentType.Float);
 * blockBeginNode.addInputAndOutput(CompositionType.Scalar, ComponentType.Int);
 * ```
 */
declare class BlockBeginShaderNode extends AbstractShaderNode {
    /** Array of input sockets for value data (excluding the blockStart boolean input) */
    private __valueInputs;
    /** Array of output sockets corresponding to the value inputs */
    private __valueOutputs;
    /**
     * Creates a new BlockBeginShaderNode instance.
     * Initializes the node with a default boolean input socket named 'blockStart'
     * and sets up the underlying shader function with a unique name.
     */
    constructor();
    /**
     * Dynamically adds a matching input and output socket pair to the node.
     * This allows the node to handle additional data types that should be passed through
     * the conditional block. The input and output will have matching composition and component types.
     *
     * @param compositionType - The composition type (e.g., Scalar, Vec2, Vec3, Vec4, Mat3, Mat4) for the new socket pair
     * @param componentType - The component type (e.g., Float, Int, Bool) for the new socket pair
     *
     * @remarks
     * - Input sockets are named as `value_${index}` where index is the current count of value inputs
     * - Output sockets are named as `outValue_${index}` where index is the current count of value outputs
     * - The sockets are automatically added to both the node's input/output arrays and the internal value arrays
     *
     * @example
     * ```typescript
     * // Add a Vec3 float input/output pair
     * node.addInputAndOutput(CompositionType.Vec3, ComponentType.Float);
     *
     * // Add a scalar integer input/output pair
     * node.addInputAndOutput(CompositionType.Scalar, ComponentType.Int);
     * ```
     */
    addInputAndOutput(compositionType: CompositionTypeEnum, componentType: ComponentTypeEnum): void;
}

/**
 * Represents a block end shader node that manages shader block termination.
 * This node extends AbstractShaderNode and provides functionality to handle
 * the end of shader code blocks with configurable inputs and outputs.
 */
declare class BlockEndShaderNode extends AbstractShaderNode {
    /**
     * Constructs a new BlockEndShaderNode instance.
     * Initializes the node with 'blockEnd' identifier and sets up the shader function
     * with a unique name based on the shader node UID.
     */
    constructor();
    /**
     * Adds a new input-output pair to the shader node with matching composition and component types.
     * This method creates corresponding input and output definitions that can be used
     * for data flow through the shader node.
     *
     * @param compositionType - The composition type enum value that defines the data structure
     * @param componentType - The component type enum value that defines the data component format
     */
    addInputAndOutput(compositionType: CompositionTypeEnum, componentType: ComponentTypeEnum): void;
}

/**
 * Abstract base class for shader nodes that represent constant variables in the shader graph.
 * This node type provides a way to inject constant values into shader programs with specific
 * composition and component types.
 *
 * @template N - The composition type (e.g., Scalar, Vec2, Vec3, Vec4, Mat2, Mat3, Mat4)
 * @template T - The component type (e.g., Float, Int, UnsignedInt, etc.)
 *
 * @example
 * ```typescript
 * // Create a concrete implementation for a Vec3 float constant
 * class Vec3FloatConstantNode extends ConstantVariableShaderNode<CompositionTypeEnum.Vec3, ComponentTypeEnum.Float> {
 *   constructor() {
 *     super('Vec3Constant', CompositionTypeEnum.Vec3, ComponentTypeEnum.Float);
 *   }
 * }
 * ```
 */
declare abstract class ConstantVariableShaderNode<N extends CompositionTypeEnum, T extends ComponentTypeEnum> extends AbstractShaderNode {
    /**
     * Creates a new ConstantVariableShaderNode instance.
     *
     * @param nodeName - The display name for this shader node
     * @param compositionType - The composition type defining the data structure (scalar, vector, matrix)
     * @param componentType - The component type defining the data type of individual elements
     *
     * @remarks
     * This constructor initializes the shader function name with a unique identifier,
     * creates the underlying ConstantVariableShader instance, and sets up the output socket.
     */
    constructor(nodeName: string, compositionType: N, componentType: T);
    /**
     * Sets the default input value for this constant variable node.
     *
     * @param value - The constant value to be used in the shader. Must be compatible with
     *                the node's composition and component types.
     *
     * @remarks
     * This method updates the underlying shader's constant value. The provided value
     * should match the expected dimensionality and type defined by the composition
     * and component types specified during construction.
     *
     * @example
     * ```typescript
     * // For a Vec3 node
     * node.setDefaultInputValue(Vector3.fromCopyArray([1.0, 0.5, 0.2]));
     *
     * // For a scalar node
     * node.setDefaultInputValue(Scalar.fromCopyNumber(3.14));
     * ```
     */
    setDefaultInputValue(value: IVector): void;
    /**
     * Retrieves the output socket of this constant variable node.
     *
     * @returns The output socket that can be connected to other shader nodes
     *
     * @remarks
     * This constant variable node has exactly one output socket that provides the
     * constant value to the shader graph. The socket's type matches the composition
     * and component types specified during construction.
     */
    getSocketOutput(): Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue>;
}

/**
 * A shader node that represents a constant scalar variable.
 * This node extends the base ConstantVariableShaderNode specifically for scalar values,
 * providing functionality to set and manage scalar constant values in shader programs.
 *
 * @template T - The component type enum that defines the data type of the scalar value
 */
declare class ConstantScalarVariableShaderNode<T extends ComponentTypeEnum> extends ConstantVariableShaderNode<typeof CompositionType.Scalar, T> {
    /**
     * Creates a new ConstantScalarVariableShaderNode instance.
     *
     * @param componentType - The component type that defines the data type of the scalar value
     */
    constructor(componentType: T);
    /**
     * Sets the default input value for this constant scalar shader node.
     * This method updates the underlying constant value used by the shader.
     *
     * @param value - The scalar value to set as the constant input value
     */
    setDefaultInputValue(value: IScalar): void;
}

/**
 * A shader node that represents a constant 2D vector variable in shader programs.
 * This node extends the base ConstantVariableShaderNode to provide specific functionality
 * for Vec2 composition types, allowing developers to set and use constant 2D vector values
 * within shader materials.
 *
 * @template T - The component type enum that defines the data type of the vector components
 *
 * @example
 * ```typescript
 * // Create a constant vector2 node with float components
 * const vector2Node = new ConstantVector2VariableShaderNode(ComponentTypeEnum.Float);
 *
 * // Set a default 2D vector value
 * vector2Node.setDefaultInputValue({x: 1.0, y: 0.5});
 * ```
 */
declare class ConstantVector2VariableShaderNode<T extends ComponentTypeEnum> extends ConstantVariableShaderNode<typeof CompositionType.Vec2, T> {
    /**
     * Creates a new ConstantVector2VariableShaderNode instance.
     *
     * @param componentType - The component type that defines the data type of the vector components
     *                       (e.g., float, int, etc.)
     *
     * @example
     * ```typescript
     * const node = new ConstantVector2VariableShaderNode(ComponentTypeEnum.Float);
     * ```
     */
    constructor(componentType: T);
    /**
     * Sets the default input value for this constant vector2 shader node.
     * This value will be used as the constant 2D vector in shader calculations.
     *
     * @param value - A 2D vector object containing x and y components that will be
     *               used as the constant value in the shader
     *
     * @example
     * ```typescript
     * // Set a normalized direction vector
     * node.setDefaultInputValue({x: 0.707, y: 0.707});
     *
     * // Set texture coordinates
     * node.setDefaultInputValue({x: 0.5, y: 0.5});
     * ```
     */
    setDefaultInputValue(value: IVector2): void;
}

/**
 * A shader node that represents a constant 3D vector variable in shader programs.
 * This node extends the base ConstantVariableShaderNode to provide specific functionality
 * for Vec3 composition types, allowing developers to set and use constant 3D vector values
 * within shader materials.
 *
 * @template T - The component type enum that defines the data type of the vector components
 *              (e.g., Float, Int, UnsignedInt, etc.)
 *
 * @example
 * ```typescript
 * // Create a Vec3 constant node with float components
 * const vec3Node = new ConstantVector3VariableShaderNode(ComponentType.Float);
 * vec3Node.setDefaultInputValue(Vector3.fromCopy3(1.0, 0.5, 0.2));
 *
 * // Connect it to other shader nodes in a material graph
 * const multiplyNode = new MultiplyShaderNode(CompositionType.Vec3, ComponentType.Float);
 * multiplyNode.addInputConnection(vec3Node, vec3Node.getSocketOutput(), multiplyNode.getSocketInputLhs());
 * ```
 */
declare class ConstantVector3VariableShaderNode<T extends ComponentTypeEnum> extends ConstantVariableShaderNode<typeof CompositionType.Vec3, T> {
    /**
     * Creates a new ConstantVector3VariableShaderNode instance.
     *
     * @param componentType - The component type that defines the data type of the vector components.
     *                       This determines how the vector values are interpreted and processed
     *                       in the shader (e.g., float, int, uint).
     */
    constructor(componentType: T);
    /**
     * Sets the default input value for this constant Vec3 shader node.
     * This method updates the underlying constant value used by the shader,
     * which will be injected into the generated shader code as a constant.
     *
     * @param value - The 3D vector value to set as the constant input value.
     *               This should be an object implementing IVector3 interface,
     *               typically a Vector3 instance with x, y, and z components.
     *
     * @example
     * ```typescript
     * const node = new ConstantVector3VariableShaderNode(ComponentType.Float);
     * node.setDefaultInputValue(Vector3.fromCopy3(1.0, 0.5, 0.0)); // RGB color or position
     * ```
     */
    setDefaultInputValue(value: IVector3): void;
}

/**
 * A shader node that represents a constant 4D vector variable in shader programs.
 * This node extends the base ConstantVariableShaderNode to provide specific functionality
 * for Vec4 composition types, allowing developers to set and use constant 4D vector values
 * within shader materials. Vec4 values are commonly used for RGBA colors, quaternions,
 * or homogeneous coordinates.
 *
 * @template T - The component type enum that defines the data type of the vector components
 *              (e.g., Float, Int, UnsignedInt, etc.)
 *
 * @example
 * ```typescript
 * // Create a Vec4 constant node with float components for RGBA color
 * const colorNode = new ConstantVector4VariableShaderNode(ComponentType.Float);
 * colorNode.setDefaultInputValue(Vector4.fromCopy4(1.0, 0.5, 0.2, 1.0)); // Orange with full alpha
 *
 * // Connect it to other shader nodes in a material graph
 * const multiplyNode = new MultiplyShaderNode(CompositionType.Vec4, ComponentType.Float);
 * multiplyNode.addInputConnection(colorNode, colorNode.getSocketOutput(), multiplyNode.getSocketInputLhs());
 * ```
 */
declare class ConstantVector4VariableShaderNode<T extends ComponentTypeEnum> extends ConstantVariableShaderNode<typeof CompositionType.Vec4, T> {
    /**
     * Creates a new ConstantVector4VariableShaderNode instance.
     *
     * @param componentType - The component type that defines the data type of the vector components.
     *                       This determines how the vector values are interpreted and processed
     *                       in the shader (e.g., float, int, uint).
     */
    constructor(componentType: T);
    /**
     * Sets the default input value for this constant Vec4 shader node.
     * This method updates the underlying constant value used by the shader,
     * which will be injected into the generated shader code as a constant.
     *
     * @param value - The 4D vector value to set as the constant input value.
     *               This should be an object implementing IVector4 interface,
     *               typically a Vector4 instance with x, y, z, and w components.
     *
     * @example
     * ```typescript
     * const node = new ConstantVector4VariableShaderNode(ComponentType.Float);
     * // Set RGBA color value
     * node.setDefaultInputValue(Vector4.fromCopy4(1.0, 0.0, 0.0, 1.0)); // Red color
     *
     * // Set homogeneous coordinate
     * node.setDefaultInputValue(Vector4.fromCopy4(10.0, 5.0, 2.0, 1.0)); // Position in homogeneous coords
     * ```
     */
    setDefaultInputValue(value: IVector4): void;
}

/**
 * A shader node that performs dot product operations between two vectors.
 * This node computes the dot product of two input vectors and returns a scalar result.
 *
 * The dot product is calculated as the sum of the products of corresponding components
 * of the two input vectors. This is commonly used in graphics programming for lighting
 * calculations, vector projections, and angle computations.
 *
 * @example
 * ```typescript
 * const dotProductNode = new DotProductShaderNode(CompositionType.Vec3, ComponentType.Float);
 * // This creates a node that computes dot product of two Vec3 inputs
 * ```
 */
declare class DotProductShaderNode extends AbstractShaderNode {
    /**
     * Creates a new DotProductShaderNode instance.
     *
     * @param compositionType - The composition type of the input vectors (Vec2, Vec3, or Vec4)
     * @param componentType - The component type of the vector elements (typically Float)
     *
     * @remarks
     * The node sets up two inputs:
     * - `lhs`: Left-hand side vector with the specified composition and component type
     * - `rhs`: Right-hand side vector with the same composition type but Float component type
     *
     * The output is a scalar value with the same component type as the left-hand side input.
     */
    constructor(compositionType: CompositionTypeEnum, componentType: ComponentTypeEnum);
    /**
     * Gets the appropriate shader function name based on the current process approach and input composition type.
     *
     * @returns The shader function name to be used in the generated shader code
     *
     * @throws {Error} Throws an error if the composition type is not supported
     *
     * @remarks
     * For WebGPU, this method returns type-specific function names:
     * - Vec2 inputs: "dotProductVec2f"
     * - Vec3 inputs: "dotProductVec3f"
     * - Vec4 inputs: "dotProductVec4f"
     *
     * For other process approaches (like WebGL), it returns the base shader function name.
     *
     * @example
     * ```typescript
     * const functionName = dotProductNode.getShaderFunctionNameDerivative();
     * // Returns "dotProductVec3f" for Vec3 inputs in WebGPU context
     * ```
     */
    getShaderFunctionNameDerivative(): string;
}

/**
 * A shader node that performs a greater-than comparison operation.
 *
 * This node compares two values and outputs a boolean result indicating whether
 * the left-hand side (lhs) is greater than the right-hand side (rhs).
 * The node accepts a left operand of any composition and component type,
 * and a right operand that must be a float scalar value.
 *
 * @example
 * ```typescript
 * // Create a greater-than comparison node for Vec3 values
 * const greaterNode = new GreaterShaderNode(CompositionType.Vec3, ComponentType.Float);
 * ```
 */
declare class GreaterShaderNode extends AbstractShaderNode {
    /**
     * Creates a new GreaterShaderNode instance.
     *
     * @param compositionType - The composition type of the left-hand side input (e.g., Scalar, Vec2, Vec3, Vec4)
     * @param componentType - The component type of the left-hand side input (e.g., Float, Int, Bool)
     *
     * @remarks
     * The node will have two inputs:
     * - `lhs`: Left-hand side operand with the specified composition and component type
     * - `rhs`: Right-hand side operand, always a float scalar
     *
     * The output is always a boolean scalar indicating the comparison result.
     */
    constructor(compositionType: CompositionTypeEnum, componentType: ComponentTypeEnum);
}

/**
 * A shader node that represents an if statement condition in the shader graph.
 * This node allows for conditional branching in shader execution based on a boolean condition.
 *
 * The node takes a boolean condition as input and provides an output that can be used
 * to control the flow of subsequent shader operations.
 *
 * @example
 * ```typescript
 * const ifNode = new IfStatementShaderNode();
 * // Connect a boolean condition to the 'condition' input
 * // Use the 'ifStart' output to control conditional shader execution
 * ```
 */
declare class IfStatementShaderNode extends AbstractShaderNode {
    /**
     * Creates a new IfStatementShaderNode instance.
     *
     * Initializes the node with:
     * - A boolean 'condition' input that determines whether the if statement should execute
     * - An 'ifStart' output with unknown composition and component types that can be connected to subsequent nodes
     *
     * The node uses IfStatementShader as its underlying shader implementation for generating
     * the appropriate GLSL code for conditional branching.
     */
    constructor();
}

/**
 * A shader node that performs multiplication operations between two inputs.
 * Supports various data types including scalars, vectors, and matrices for both WebGL and WebGPU.
 *
 * @example
 * ```typescript
 * // Create a multiplication node for two Vec3 float values
 * const multiplyNode = new MultiplyShaderNode(CompositionType.Vec3, ComponentType.Float);
 * ```
 */
declare class MultiplyShaderNode extends AbstractShaderNode {
    /**
     * Creates a new MultiplyShaderNode instance.
     *
     * @param compositionType - The composition type (Scalar, Vec2, Vec3, Vec4, Mat2, Mat3, Mat4) for both inputs and output
     * @param componentType - The component type (Float, Int, etc.) for both inputs and output
     *
     * @remarks
     * The node will have two inputs ('lhs' and 'rhs') and one output ('outValue'),
     * all sharing the same composition and component types.
     */
    constructor(compositionType: CompositionTypeEnum, componentType: ComponentTypeEnum);
    /**
     * Gets the platform-specific shader function name for the multiplication operation.
     *
     * @returns The appropriate shader function name based on the current process approach and input types
     *
     * @throws {Error} Throws an error if the combination of composition and component types is not implemented
     *
     * @remarks
     * For WebGPU, returns type-specific function names (e.g., 'multiplyF32F32', 'multiplyVec3fVec3f').
     * For WebGL, returns the generic function name 'multiply'.
     *
     * Supported WebGPU type combinations:
     * - Scalar: Float-Float (F32F32), Int-Int (I32I32)
     * - Vec2, Vec3, Vec4: Float vectors
     * - Mat2, Mat3, Mat4: Float matrices
     */
    getShaderFunctionNameDerivative(): string;
}

/**
 * A shader node that provides access to the normal matrix for transforming normal vectors
 * from local space to world space.
 *
 * The normal matrix is derived from the inverse transpose of the upper-left 3x3 portion
 * of the model matrix (world matrix). It ensures that normal vectors remain perpendicular
 * to surfaces after non-uniform scaling transformations. This matrix is essential for
 * proper lighting calculations in 3D rendering.
 *
 * The node operates in the vertex shader stage and supports both WebGL (GLSL) and
 * WebGPU (WGSL) rendering backends.
 *
 * @example
 * ```typescript
 * const normalMatrixNode = new NormalMatrixShaderNode();
 * // Connect to other shader nodes that require normal transformation
 * const normalMatrixOutput = normalMatrixNode.getOutput('outValue');
 * ```
 */
declare class NormalMatrixShaderNode extends AbstractShaderNode {
    /**
     * Creates a new NormalMatrixShaderNode instance.
     *
     * Initializes the shader node with vertex stage shader code for both GLSL and WGSL,
     * and sets up a Mat3 float output socket for the normal transformation matrix.
     * The output matrix can be used to transform normal vectors from local space to world space
     * while preserving their geometric properties under non-uniform transformations.
     *
     * The node automatically retrieves the normal matrix from the rendering system's
     * uniform buffer based on the current instance ID.
     */
    constructor();
}

/**
 * A shader node that normalizes vectors by dividing each component by the vector's magnitude.
 * This node provides normalize functionality for Vec2, Vec3, and Vec4 compositions,
 * supporting both WebGL (GLSL) and WebGPU (WGSL) shader languages.
 */
declare class NormalizeShaderNode extends AbstractShaderNode {
    /**
     * Creates a new NormalizeShaderNode instance.
     *
     * @param compositionType - The composition type (Vec2, Vec3, or Vec4) of the input and output values
     * @param componentType - The component type (e.g., Float32) of the vector components
     */
    constructor(compositionType: CompositionTypeEnum, componentType: ComponentTypeEnum);
    /**
     * Gets the shader function name derivative based on the current process approach and composition type.
     * For WebGPU, it appends the vector type suffix (Vec2f, Vec3f, Vec4f) to the function name.
     * For other approaches (WebGL), it returns the base function name without modification.
     *
     * @returns The appropriate shader function name for the current context
     * @throws {Error} When an unsupported composition type is used with WebGPU
     */
    getShaderFunctionNameDerivative(): string;
}

/**
 * A shader node that represents the final output color in a shader graph.
 * This node serves as the terminal node for fragment shaders, accepting a Vec4 color value
 * and outputting it as the final rendered color.
 *
 * @example
 * ```typescript
 * const outColorNode = new OutColorShaderNode();
 * // Connect a color input to the node
 * someColorNode.connect(outColorNode.getSocketInput());
 * ```
 */
declare class OutColorShaderNode extends AbstractShaderNode {
    /**
     * Creates a new OutColorShaderNode instance.
     * Initializes the node with an EndShader instance and sets up the input socket
     * for receiving Vec4 color values.
     */
    constructor();
    /**
     * Gets the input socket for connecting color values to this output node.
     * The socket accepts Vec4 values representing RGBA color components.
     *
     * @returns The input socket that accepts Vec4 color values
     */
    getSocketInput(): Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue>;
}

/**
 * A shader node that represents the output position in a shader graph.
 * This node is typically used as a terminal node to define the final position
 * output of a vertex shader, accepting a Vec4 position value.
 */
declare class OutPositionShaderNode extends AbstractShaderNode {
    /**
     * Creates a new OutPositionShaderNode instance.
     * Initializes the node with an 'outPosition' identifier and sets up
     * an input socket for Vec4 position values.
     */
    constructor();
    /**
     * Gets the input socket for this position output node.
     *
     * @returns The input socket that accepts Vec4 position values
     */
    getSocketInput(): Socket<string, CompositionTypeEnum, ComponentTypeEnum, SocketDefaultValue>;
}

/**
 * A shader node that provides access to the projection matrix in shaders.
 * This node outputs a 4x4 projection matrix that can be used for transforming
 * vertices from view space to clip space in the vertex shader.
 *
 * @extends AbstractShaderNode
 */
declare class ProjectionMatrixShaderNode extends AbstractShaderNode {
    /**
     * Creates a new ProjectionMatrixShaderNode instance.
     * Initializes the shader node with projection matrix shader code for both
     * OpenGL (GLSL) and WebGPU (WGSL) backends, and configures the output
     * to provide a 4x4 float matrix.
     */
    constructor();
}

/**
 * A shader node that provides uniform data input functionality.
 * This node wraps UniformDataShader to provide a standardized interface
 * for passing uniform values to shader programs.
 */
declare class UniformDataShaderNode extends AbstractShaderNode {
    /**
     * Creates a new UniformDataShaderNode instance.
     *
     * @param compositionType - The composition type that defines the structure of the data (scalar, vector, matrix, etc.)
     * @param componentType - The component type that defines the data type (float, int, etc.)
     */
    constructor(compositionType: CompositionTypeEnum, componentType: ComponentTypeEnum);
    /**
     * Sets the default input value for the specified input parameter.
     * Currently only supports setting the default value for the 'value' input.
     *
     * @param inputName - The name of the input parameter to set the default value for
     * @param value - The default value to assign to the input parameter
     */
    setDefaultInputValue(inputName: string, value: any): void;
    /**
     * Sets the uniform data variable name in the shader.
     * This name will be used to reference the uniform variable in the generated shader code.
     *
     * @param value - The variable name to use for the uniform data in the shader
     */
    setUniformDataName(value: any): void;
}

/**
 * A shader node that provides view matrix functionality for transforming world coordinates to camera space.
 * This node outputs a 4x4 matrix that represents the view transformation matrix used in vertex shaders.
 * The view matrix transforms vertices from world space to camera/eye space coordinates.
 */
declare class ViewMatrixShaderNode extends AbstractShaderNode {
    /**
     * Creates a new ViewMatrixShaderNode instance.
     * Initializes the shader node with view matrix shader code for both GLSL and WGSL,
     * sets it to operate in the vertex shader stage, and configures the output as a Mat4 float matrix.
     */
    constructor();
}

/**
 * A material node that applies wireframe rendering effects to geometry.
 * This node takes an existing fragment color and a wireframe color as inputs,
 * and outputs a combined color that renders the wireframe effect.
 */
declare class WireframeMaterialNode extends AbstractShaderNode {
    /**
     * Creates a new WireframeMaterialNode instance.
     * Sets up the shader node with wireframe GLSL code and defines input/output parameters:
     * - Inputs: existingFragColor (Vec4), wireframeColor (Vec4)
     * - Output: outColor (Vec4)
     */
    constructor();
}

/**
 * A shader node that provides access to the world transformation matrix.
 * This node outputs a 4x4 matrix representing the object's world space transformation,
 * which transforms vertices from object space to world space coordinates.
 *
 * The world matrix is essential for positioning, rotating, and scaling objects
 * within the 3D world coordinate system.
 */
declare class WorldMatrixShaderNode extends AbstractShaderNode {
    /**
     * Creates a new WorldMatrixShaderNode instance.
     *
     * Initializes the shader node with both GLSL and WGSL code for cross-platform compatibility.
     * Sets up the output as a 4x4 float matrix and configures the node for vertex shader stage usage.
     *
     * @remarks
     * This node is specifically designed for vertex shader operations where world transformation
     * is required. The output matrix can be used to transform vertex positions, normals, or
     * other geometric data from object space to world space.
     */
    constructor();
}

/**
 * A shader node that splits vector inputs into their individual components or smaller vectors.
 * This node can take vec4, vec3, or vec2 inputs and output various combinations of their components
 * including individual scalars (x, y, z, w) and smaller vectors (xy, zw, xyz).
 *
 * Supports both WebGL/GLSL and WebGPU/WGSL shader compilation.
 *
 * @example
 * ```typescript
 * const splitNode = new SplitVectorShaderNode();
 * // Connect a vec4 input to get x, y, z, w components separately
 * // Or connect vec3 input to get xyz, xy components
 * ```
 */
declare class SplitVectorShaderNode extends AbstractShaderNode {
    /**
     * Creates a new SplitVectorShaderNode instance.
     * Sets up input and output connections for vector splitting operations.
     *
     * Inputs:
     * - xyzw: Vec4 input for 4-component vectors
     * - xyz: Vec3 input for 3-component vectors
     * - xy: Vec2 input for 2-component vectors
     *
     * Outputs:
     * - xyz: Vec3 output (first 3 components)
     * - xy: Vec2 output (first 2 components)
     * - zw: Vec2 output (last 2 components of vec4)
     * - x, y, z, w: Individual scalar components
     */
    constructor();
    /**
     * Gets the derivative shader function name based on the connected input type.
     * For WebGPU, returns specialized function names (splitVectorXYZW, splitVectorXYZ, splitVectorXY)
     * based on which input is connected. For WebGL, returns the base function name.
     *
     * @returns The appropriate shader function name for the current input connection and process approach
     * @throws {Error} When no valid input connection is found in WebGPU mode
     */
    getShaderFunctionNameDerivative(): string;
    /**
     * Generates shader code for calling the split vector function with appropriate input and output handling.
     * Creates dummy variables for unused outputs and maps connected outputs to their proper variable names.
     * Handles differences between WebGL/GLSL and WebGPU/WGSL syntax, including reference parameters for WebGPU.
     *
     * @param i - The index of the current shader node call
     * @param shaderNode - The shader node instance (unused in this implementation)
     * @param functionName - The name of the shader function to call
     * @param varInputNames - Array of input variable names for each call
     * @param varOutputNames - Array of output variable names for each call
     * @returns The generated shader code string for the function call
     */
    makeCallStatement(i: number, _shaderNode: AbstractShaderNode, functionName: string, varInputNames: string[][], varOutputNames: string[][]): string;
}

/**
 * A shader node that merges vector components to create various vector outputs.
 *
 * This node provides the capability to combine individual scalar components (x, y, z, w)
 * or smaller vectors (xy, zw, xyz) into larger vector outputs (Vec2, Vec3, Vec4).
 * It supports multiple input configurations and automatically selects the appropriate
 * shader function based on which inputs are connected.
 *
 * @example
 * ```typescript
 * const mergeNode = new MergeVectorShaderNode();
 * // Connect scalar inputs x, y, z, w to create a Vec4 output
 * // Or connect Vec3 xyz and scalar w to create a Vec4 output
 * ```
 */
declare class MergeVectorShaderNode extends AbstractShaderNode {
    /**
     * Creates a new MergeVectorShaderNode instance.
     *
     * Initializes the node with predefined inputs for various vector components
     * and outputs for different vector sizes. The node supports multiple input
     * combinations to create flexible vector merging operations.
     */
    constructor();
    /**
     * Determines the appropriate shader function name based on connected inputs.
     *
     * This method analyzes which input connections are active and returns the
     * corresponding shader function variant. Each combination of inputs requires
     * a different shader function implementation to handle the vector merging logic.
     *
     * Supported input combinations:
     * - XYZ + W: Vec3 input with scalar W component
     * - XY + ZW: Two Vec2 inputs for XY and ZW components
     * - XY + Z + W: Vec2 input with individual Z and W scalars
     * - ZW + X + Y: Vec2 input with individual X and Y scalars
     * - X + Y + Z + W: Four individual scalar components
     *
     * @returns The derivative function name suffix for the shader
     * @throws {Error} When the input connection pattern is not supported
     */
    getShaderFunctionNameDerivative(): string;
    /**
     * Generates the shader function call statement for the merge vector operation.
     *
     * This method creates the appropriate shader code to call the merge vector function
     * with the correct input and output parameters. It handles both WebGL (GLSL) and
     * WebGPU (WGSL) syntax differences and manages dummy variables for unused outputs.
     *
     * The method generates dummy output variables for each possible output (xyzw, xyz, xy, zw)
     * and replaces them with actual output variable names when they are used. This ensures
     * that the shader function signature remains consistent regardless of which outputs
     * are actually connected.
     *
     * @param i - The node index in the shader graph
     * @param shaderNode - The shader node instance (typically this node)
     * @param functionName - The name of the shader function to call
     * @param varInputNames - Array of input variable names for each node
     * @param varOutputNames - Array of output variable names for each node
     * @returns The generated shader code string for the function call
     */
    makeCallStatement(i: number, _shaderNode: AbstractShaderNode, functionName: string, varInputNames: string[][], varOutputNames: string[][]): string;
}

/**
 * Material content for color grading using Look-Up Tables (LUTs).
 * This material applies color correction and grading effects to rendered images
 * using a pre-computed lookup table texture.
 */
declare class ColorGradingUsingLUTsMaterialContent extends AbstractMaterialContent {
    /**
     * Shader semantic for the lookup table texture.
     * This defines the binding point for the LUT texture in the shader.
     */
    static lookupTableTexture: ShaderSemanticsClass;
    /**
     * Creates a new ColorGradingUsingLUTsMaterialContent instance.
     *
     * @param materialName - The name identifier for this material
     * @param targetRenderPass - The render pass to read the source texture from
     * @param colorAttachmentsNumber - The index of the color attachment to use as source
     * @param uri - Optional URL to load the LUT texture from
     * @param texture - Optional pre-existing texture to use as LUT
     *
     * @remarks
     * Either `uri` or `texture` should be provided to specify the lookup table.
     * If neither is provided, a dummy black texture will be used and a warning logged.
     */
    constructor(materialName: string, targetRenderPass: RenderPass, colorAttachmentsNumber: Count, uri?: string, texture?: AbstractTexture);
    /**
     * Sets internal GPU parameters for WebGL rendering per material.
     * This method configures world matrices, view information, and projection matrices
     * required for the color grading shader to render correctly.
     *
     * @param params - The rendering parameters object
     * @param params.material - The material instance being rendered
     * @param params.shaderProgram - The WebGL shader program to configure
     * @param params.firstTime - Whether this is the first time setting up this material
     * @param params.args - WebGL rendering arguments containing matrices and render state
     *
     * @internal
     * This method is called internally during the rendering pipeline.
     */
    _setInternalSettingParametersToGpuWebGLPerMaterial({ shaderProgram, args, }: {
        shaderProgram: WebGLProgram;
        args: RenderingArgWebGL;
    }): void;
}

/**
 * Custom material content class that extends AbstractMaterialContent to provide
 * custom shader handling and rendering capabilities with support for IBL (Image-Based Lighting),
 * morphing, skinning, and various shader semantics.
 */
declare class CustomMaterialContent extends AbstractMaterialContent {
    private static __globalDataRepository;
    private static __diffuseIblCubeMapSampler;
    private static __specularIblCubeMapSampler;
    /**
     * Creates a new CustomMaterialContent instance with custom shaders and configuration.
     *
     * @param params - Configuration object for the custom material
     * @param params.name - The name identifier for this material content
     * @param params.isMorphing - Whether this material supports vertex morphing/blending
     * @param params.isSkinning - Whether this material supports skeletal animation skinning
     * @param params.isLighting - Whether this material uses lighting calculations
     * @param params.vertexShader - Optional vertex shader object for WebGL rendering
     * @param params.pixelShader - Optional pixel/fragment shader object for WebGL rendering
     * @param params.additionalShaderSemanticInfo - Array of additional shader semantic information
     * @param params.vertexShaderWebGpu - Optional vertex shader object for WebGPU rendering
     * @param params.pixelShaderWebGpu - Optional pixel/fragment shader object for WebGPU rendering
     * @param params.definitions - Optional array of preprocessor definitions for shaders
     */
    constructor({ name, isMorphing, isSkinning, isLighting, vertexShader, pixelShader, additionalShaderSemanticInfo, vertexShaderWebGpu, pixelShaderWebGpu, definitions, }: {
        name: string;
        isMorphing: boolean;
        isSkinning: boolean;
        isLighting: boolean;
        vertexShader?: ShaderityObject;
        pixelShader?: ShaderityObject;
        additionalShaderSemanticInfo: ShaderSemanticsInfo[];
        vertexShaderWebGpu?: ShaderityObject;
        pixelShaderWebGpu?: ShaderityObject;
        definitions?: string[];
    });
    /**
     * Sets internal material parameters for WebGPU rendering, including IBL parameters
     * and HDRI format information.
     *
     * @param params - Parameters object
     * @param params.material - The material instance to configure
     * @param params.args - WebGPU rendering arguments containing entity and rendering context
     */
    _setInternalSettingParametersToGpuWebGpu({ material, args, }: {
        material: Material;
        args: RenderingArgWebGpu;
    }): void;
    /**
     * Sets internal material parameters for WebGL rendering on a per-material basis.
     * Configures world/view/projection matrices, lighting, skinning, and IBL parameters.
     *
     * @param params - Parameters object
     * @param params.material - The material instance to configure
     * @param params.shaderProgram - The WebGL shader program to use
     * @param params.firstTime - Whether this is the first time setting up this material
     * @param params.args - WebGL rendering arguments containing matrices, entities, and rendering context
     */
    _setInternalSettingParametersToGpuWebGLPerMaterial({ material, shaderProgram, firstTime, args, }: {
        material: Material;
        shaderProgram: WebGLProgram;
        firstTime: boolean;
        args: RenderingArgWebGL;
    }): void;
    /**
     * Sets internal parameters for WebGL rendering on a per-shader-program basis.
     * Primarily handles IBL environment texture setup including diffuse, specular, and sheen cube maps.
     *
     * @param params - Parameters object
     * @param params.material - The material instance to configure
     * @param params.shaderProgram - The WebGL shader program to use
     * @param params.firstTime - Whether this is the first time setting up this shader program
     * @param params.args - WebGL rendering arguments containing cube map textures and rendering context
     */
    _setInternalSettingParametersToGpuWebGLPerShaderProgram({ material, shaderProgram, args, }: {
        material: Material;
        shaderProgram: WebGLProgram;
        args: RenderingArgWebGL;
    }): void;
    /**
     * Sets internal parameters for WebGL rendering on a per-primitive basis.
     * Handles morph target/blend shape information for vertex animation.
     *
     * @param params - Parameters object
     * @param params.shaderProgram - The WebGL shader program to use
     * @param params.args - WebGL rendering arguments containing entity, mesh, and primitive data
     */
    _setInternalSettingParametersToGpuWebGLPerPrimitive({ shaderProgram, args, }: {
        shaderProgram: WebGLProgram;
        args: RenderingArgWebGL;
    }): void;
    /**
     * Sets up HDRI (High Dynamic Range Imaging) parameters for IBL rendering.
     * Extracts mipmap levels, mesh render component, and HDRI format information
     * from the rendering arguments.
     *
     * @param args - Rendering arguments for either WebGL or WebGPU
     * @returns Object containing mipmap level number, mesh render component, and HDRI format indices
     * @private
     */
    private static __setupHdriParameters;
}

/**
 * Material content for depth encoding functionality.
 * This class handles encoding depth information into textures for shadow mapping and depth-based effects.
 */
declare class DepthEncodeMaterialContent extends AbstractMaterialContent {
    /** Shader semantic for the inner z-near clipping plane value */
    static zNearInner: ShaderSemanticsClass;
    /** Shader semantic for the inner z-far clipping plane value */
    static zFarInner: ShaderSemanticsClass;
    /** Shader semantic to indicate if the light source is a point light */
    static isPointLight: ShaderSemanticsClass;
    /** Shader semantic for the depth power factor used in depth encoding */
    static depthPow: ShaderSemanticsClass;
    /** Cached value of the last z-near plane to avoid unnecessary uniform updates */
    private __lastZNear;
    /** Cached value of the last z-far plane to avoid unnecessary uniform updates */
    private __lastZFar;
    /**
     * Creates a new DepthEncodeMaterialContent instance.
     *
     * @param materialName - The name identifier for this material
     * @param depthPow - The power factor for depth encoding (1.0-2.0 range)
     * @param options - Configuration options for the material
     * @param options.isSkinning - Whether skeletal animation skinning is enabled
     */
    constructor(materialName: string, depthPow: number, { isSkinning }: {
        isSkinning: boolean;
    });
    /**
     * Sets internal shader parameters specific to depth encoding for WebGL rendering.
     * This method configures camera-related parameters and handles uniform updates
     * for the depth encoding shader.
     *
     * @param params - Parameters for setting internal WebGL settings
     * @param params.material - The material instance being configured
     * @param params.shaderProgram - The WebGL shader program to configure
     * @param params.firstTime - Whether this is the first time setting parameters
     * @param params.args - WebGL rendering arguments containing camera and entity data
     */
    _setInternalSettingParametersToGpuWebGLPerMaterial({ material, shaderProgram, firstTime, args, }: {
        material: Material;
        shaderProgram: WebGLProgram;
        firstTime: boolean;
        args: RenderingArgWebGL;
    }): void;
}

/**
 * A material content class that detects high luminance areas in textures and applies correction.
 * This is typically used for bloom effects or tone mapping where bright areas need to be identified.
 */
declare class DetectHighLuminanceMaterialContent extends AbstractMaterialContent {
    /**
     * Shader semantic for the luminance criterion threshold value.
     * This determines the minimum luminance value to be considered as "high luminance".
     */
    static LuminanceCriterion: ShaderSemanticsEnum;
    /**
     * Creates a new DetectHighLuminanceMaterialContent instance.
     *
     * @param materialName - The name identifier for this material
     * @param textureToDetectHighLuminance - The source texture to analyze for high luminance areas
     */
    constructor(materialName: string, textureToDetectHighLuminance: AbstractTexture);
    /**
     * Sets internal GPU parameters for WebGL rendering on a per-material basis.
     * This method configures matrices and camera-related uniforms for the shader.
     *
     * @param params - The parameters object containing material, shader program, and rendering arguments
     * @param params.material - The material instance being rendered
     * @param params.shaderProgram - The WebGL shader program to configure
     * @param params.firstTime - Whether this is the first time setting up this material
     * @param params.args - WebGL rendering arguments including world matrix, render pass, and camera info
     */
    _setInternalSettingParametersToGpuWebGLPerMaterial({ shaderProgram, args, }: {
        shaderProgram: WebGLProgram;
        args: RenderingArgWebGL;
    }): void;
}

/**
 * Material content class for rendering entity UID output.
 * This material is used to output unique identifiers for entities,
 * typically for picking or selection purposes.
 */
declare class EntityUIDOutputMaterialContent extends AbstractMaterialContent {
    /**
     * Creates a new EntityUIDOutputMaterialContent instance.
     *
     * @param materialName - The name of the material
     */
    constructor(materialName: string);
    /**
     * Sets internal parameters to GPU for WebGL rendering per material.
     * This method configures uniform variables and matrices required for entity UID output rendering.
     *
     * @param params - The rendering parameters
     * @param params.material - The material instance
     * @param params.shaderProgram - The WebGL shader program
     * @param params.args - WebGL rendering arguments containing matrices, camera, and entity information
     */
    _setInternalSettingParametersToGpuWebGLPerMaterial({ material, shaderProgram, args, }: {
        material: Material;
        shaderProgram: WebGLProgram;
        args: RenderingArgWebGL;
    }): void;
}

/**
 * Material content for furnace test rendering.
 * This material is used for testing PBR (Physically Based Rendering) materials
 * with controlled lighting conditions similar to a furnace test environment.
 */
declare class FurnaceTestMaterialContent extends AbstractMaterialContent {
    static mode: ShaderSemanticsClass;
    static debugView: ShaderSemanticsClass;
    static g_type: ShaderSemanticsClass;
    static disable_fresnel: ShaderSemanticsClass;
    static f0: ShaderSemanticsClass;
    /**
     * Creates a new FurnaceTestMaterialContent instance.
     *
     * @param materialName - The name identifier for this material
     */
    constructor(materialName: string);
    /**
     * Sets internal rendering parameters to GPU for WebGL per material.
     * This method configures shader uniforms including matrices, camera information,
     * and lighting data required for furnace test rendering.
     *
     * @param params - The rendering parameters object
     * @param params.material - The material instance being rendered
     * @param params.shaderProgram - The WebGL shader program to configure
     * @param params.firstTime - Whether this is the first time setting up this shader program
     * @param params.args - WebGL rendering arguments containing matrices, camera, and lighting data
     */
    _setInternalSettingParametersToGpuWebGLPerMaterial({ material, shaderProgram, firstTime, args, }: {
        material: Material;
        shaderProgram: WebGLProgram;
        firstTime: boolean;
        args: RenderingArgWebGL;
    }): void;
}

/**
 * Material content implementation for MToon 0.x shader.
 * This class handles the creation and configuration of MToon materials,
 * which are commonly used for toon-style rendering in VRM models.
 */
declare class MToon0xMaterialContent extends AbstractMaterialContent {
    private static __diffuseIblCubeMapSampler;
    private static __specularIblCubeMapSampler;
    static readonly _Cutoff: ShaderSemanticsClass;
    static readonly _Color: ShaderSemanticsClass;
    static readonly _ShadeColor: ShaderSemanticsClass;
    static readonly _litColorTexture: ShaderSemanticsClass;
    static readonly _shadeColorTexture: ShaderSemanticsClass;
    static readonly _BumpScale: ShaderSemanticsClass;
    static readonly _normalTexture: ShaderSemanticsClass;
    static readonly _ReceiveShadowRate: ShaderSemanticsClass;
    static readonly _receiveShadowTexture: ShaderSemanticsClass;
    static readonly _ShadingGradeRate: ShaderSemanticsClass;
    static readonly _shadingGradeTexture: ShaderSemanticsClass;
    static readonly _ShadeShift: ShaderSemanticsClass;
    static readonly _ShadeToony: ShaderSemanticsClass;
    static readonly _LightColorAttenuation: ShaderSemanticsClass;
    static readonly _AmbientColor: ShaderSemanticsClass;
    static readonly _IndirectLightIntensity: ShaderSemanticsClass;
    static readonly _rimTexture: ShaderSemanticsClass;
    static readonly _RimColor: ShaderSemanticsClass;
    static readonly _RimLightingMix: ShaderSemanticsClass;
    static readonly _RimFresnelPower: ShaderSemanticsClass;
    static readonly _RimLift: ShaderSemanticsClass;
    static readonly _matCapTexture: ShaderSemanticsClass;
    static readonly _EmissionColor: ShaderSemanticsClass;
    static readonly _emissionTexture: ShaderSemanticsClass;
    static readonly _OutlineWidthTexture: ShaderSemanticsClass;
    static readonly _OutlineWidth: ShaderSemanticsClass;
    static readonly _OutlineScaledMaxDistance: ShaderSemanticsClass;
    static readonly _OutlineColor: ShaderSemanticsClass;
    static readonly _OutlineLightingMix: ShaderSemanticsClass;
    static readonly Aspect: ShaderSemanticsClass;
    static readonly CameraUp: ShaderSemanticsClass;
    static usableBlendEquationModeAlpha?: number;
    private __OutlineWidthModeIsScreen;
    private __floatProperties;
    private __vectorProperties;
    private __textureProperties;
    /**
     * Creates a new MToon 0.x material content instance.
     *
     * @param isOutline - Whether this material is for outline rendering
     * @param materialProperties - VRM material properties from the glTF file
     * @param textures - Array of textures used by the material
     * @param samplers - Array of samplers for texture sampling configuration
     * @param isMorphing - Whether morphing (blend shapes) is enabled
     * @param isSkinning - Whether skeletal animation is enabled
     * @param isLighting - Whether lighting calculations are enabled
     * @param useTangentAttribute - Whether to use tangent attributes for normal mapping
     * @param debugMode - Debug visualization mode (optional)
     * @param makeOutputSrgb - Whether to convert output to sRGB color space
     * @param materialName - Name identifier for the material
     * @param definitions - Additional shader preprocessor definitions
     */
    constructor(isOutline: boolean, materialProperties: Vrm0xMaterialProperty | undefined, textures: any, samplers: Sampler[], isMorphing: boolean, isSkinning: boolean, isLighting: boolean, useTangentAttribute: boolean, debugMode: Count | undefined, makeOutputSrgb: boolean, materialName: string, definitions: string[]);
    /**
     * Sets up dummy textures and their associated shader semantics information.
     * This method configures default texture bindings for various MToon texture slots
     * and adds corresponding shader semantics entries.
     *
     * @param textures - Array of available textures
     * @param samplers - Array of texture samplers
     * @param shaderSemanticsInfoArray - Array to populate with shader semantics information
     * @param isOutline - Whether outline textures should be included
     * @private
     */
    private __setDummyTextures;
    /**
     * Configures material parameters based on MToon properties.
     * This method sets up blending modes, culling, and other rendering states
     * based on the material's MToon properties.
     *
     * @param material - The material instance to configure
     * @param isOutline - Whether this is an outline material
     */
    setMaterialParameters(material: Material, isOutline: boolean): void;
    /**
     * Initializes the usable blend equation mode for alpha blending.
     * This method determines the appropriate blend equation mode based on
     * the current rendering API and available extensions.
     *
     * @private
     */
    private static __initializeUsableBlendEquationModeAlpha;
    /**
     * Sets internal shader parameters for WebGPU rendering.
     * This method configures camera-related and IBL (Image-Based Lighting) parameters
     * that are managed internally by the material system.
     *
     * @param params - Object containing material and rendering arguments
     * @param params.material - The material instance to configure
     * @param params.args - WebGPU rendering arguments
     */
    _setInternalSettingParametersToGpuWebGpu({ material, args, }: {
        material: Material;
        args: RenderingArgWebGpu;
    }): void;
    /**
     * Sets shader-specific internal parameters for WebGL rendering.
     * This method is called once per shader program and sets up
     * IBL environment textures and other program-level uniforms.
     *
     * @param params - Object containing rendering parameters
     * @param params.shaderProgram - The WebGL shader program
     * @param params.args - WebGL rendering arguments
     */
    _setInternalSettingParametersToGpuWebGLPerShaderProgram({ shaderProgram, args, }: {
        shaderProgram: WebGLProgram;
        args: RenderingArgWebGL;
    }): void;
    /**
     * Sets material-specific internal parameters for WebGL rendering.
     * This method is called per material and configures matrices, lighting,
     * morphing, skinning, and other per-material uniforms.
     *
     * @param params - Object containing rendering parameters
     * @param params.material - The material instance
     * @param params.shaderProgram - The WebGL shader program
     * @param params.firstTime - Whether this is the first time setup
     * @param params.args - WebGL rendering arguments
     */
    _setInternalSettingParametersToGpuWebGLPerMaterial({ material, shaderProgram, firstTime, args, }: {
        material: Material;
        shaderProgram: WebGLProgram;
        firstTime: boolean;
        args: RenderingArgWebGL;
    }): void;
    /**
     * Converts Unity blend mode enum values to corresponding WebGL blend constants.
     * This method maps Unity's blend mode enumeration to the appropriate
     * WebGL blend function constants for proper alpha blending.
     *
     * @param enumNumber - Unity blend mode enum value
     * @returns Corresponding WebGL blend constant
     */
    static unityBlendEnumCorrespondence(enumNumber: number): number;
    /**
     * Sets up HDRI (High Dynamic Range Imaging) parameters for IBL.
     * This method extracts and prepares HDRI-related parameters from the
     * rendering arguments for use in image-based lighting calculations.
     *
     * @param args - WebGL or WebGPU rendering arguments
     * @returns Object containing HDRI parameters
     * @private
     */
    private static __setupHdriParameters;
}

/**
 * Material content implementation for MToon 1.0 specification.
 * MToon is a toon shading material specification designed primarily for VRM avatars.
 * This class handles shader compilation, parameter setup, and rendering for MToon materials.
 */
declare class MToon1MaterialContent extends AbstractMaterialContent {
    /** Static sampler for diffuse IBL cube map with linear filtering and edge clamping */
    private static __diffuseIblCubeMapSampler;
    /** Static sampler for specular IBL cube map with mipmap support and edge clamping */
    private static __specularIblCubeMapSampler;
    /**
     * Constructs a new MToon1MaterialContent instance with specified rendering features.
     *
     * @param materialName - The name identifier for this material
     * @param isMorphing - Whether this material supports vertex morphing/blend shapes
     * @param isSkinning - Whether this material supports skeletal animation
     * @param isLighting - Whether this material uses lighting calculations
     * @param isOutline - Whether this material is used for outline rendering
     * @param definitions - Additional shader preprocessor definitions
     */
    constructor(materialName: string, isMorphing: boolean, isSkinning: boolean, isLighting: boolean, isOutline: boolean, definitions: string[]);
    /**
     * Configures material parameters based on MToon material properties and rendering mode.
     * Sets up culling behavior, alpha testing, and other material-specific settings.
     *
     * @param material - The material instance to configure
     * @param isOutline - Whether this material is being used for outline rendering
     * @param materialJson - The MToon material specification from VRM
     */
    setMaterialParameters(material: Material, isOutline: boolean, materialJson: Vrm1_Material): void;
    /**
     * Sets internal parameters for WebGPU rendering pipeline.
     * Configures IBL (Image-Based Lighting) parameters, HDRI format settings,
     * and cube map contributions for physically-based lighting.
     *
     * @param params - Object containing material and rendering arguments
     * @param params.material - The material instance to update
     * @param params.args - WebGPU rendering arguments with entity and environment data
     */
    _setInternalSettingParametersToGpuWebGpu({ material, args, }: {
        material: Material;
        args: RenderingArgWebGpu;
    }): void;
    /**
     * Sets per-shader-program parameters for WebGL rendering.
     * Configures texture bindings for IBL environment maps, setting up diffuse
     * and specular cube maps with appropriate samplers.
     *
     * @param params - Object containing shader program and rendering context
     * @param params.shaderProgram - The compiled WebGL shader program
     * @param params.args - WebGL rendering arguments with cube map textures
     */
    _setInternalSettingParametersToGpuWebGLPerShaderProgram({ shaderProgram, args, }: {
        shaderProgram: WebGLProgram;
        args: RenderingArgWebGL;
    }): void;
    /**
     * Sets per-material parameters for WebGL rendering.
     * Configures transformation matrices, camera parameters, lighting information,
     * skeletal animation data, IBL parameters, and morphing data.
     *
     * @param params - Object containing material, shader program and rendering context
     * @param params.material - The material instance being rendered
     * @param params.shaderProgram - The compiled WebGL shader program
     * @param params.firstTime - Whether this is the first time setting parameters for this material
     * @param params.args - WebGL rendering arguments with entity and environment data
     */
    _setInternalSettingParametersToGpuWebGLPerMaterial({ material, shaderProgram, firstTime, args, }: {
        material: Material;
        shaderProgram: WebGLProgram;
        firstTime: boolean;
        args: RenderingArgWebGL;
    }): void;
    /**
     * Sets up HDRI (High Dynamic Range Imaging) parameters for both WebGL and WebGPU rendering.
     * Extracts mipmap levels, cube map contributions, and format information from the rendering context.
     *
     * @param args - Rendering arguments containing cube map textures and mesh renderer data
     * @returns Object containing processed HDRI parameters
     * @returns returns.mipmapLevelNumber - Number of mipmap levels in the specular cube map
     * @returns returns.meshRenderComponent - The mesh renderer component with cube map settings
     * @returns returns.diffuseHdriType - HDRI format index for diffuse cube map
     * @returns returns.specularHdriType - HDRI format index for specular cube map
     */
    private static __setupHdriParameters;
}

/**
 * Material content implementation for MatCap (Material Capture) rendering.
 * MatCap is a technique that captures material appearance from a sphere under specific lighting conditions
 * and applies it to 3D objects for realistic material representation.
 */
declare class MatCapMaterialContent extends AbstractMaterialContent {
    static MatCapTexture: ShaderSemanticsClass;
    /**
     * Creates a new MatCap material content instance.
     *
     * @param materialName - The name identifier for this material
     * @param isSkinning - Whether this material supports skeletal animation/skinning
     * @param uri - Optional URI to load the MatCap texture from
     * @param texture - Optional pre-existing texture to use as the MatCap texture
     * @param sampler - Optional sampler settings for texture sampling behavior
     */
    constructor(materialName: string, isSkinning: boolean, uri?: string, texture?: AbstractTexture, sampler?: Sampler);
    /**
     * Sets internal GPU parameters specific to MatCap material rendering for WebGL.
     * This method configures uniforms and matrices required for proper MatCap material rendering,
     * including world transformations, camera settings, and skeletal animation support.
     *
     * @param params - Configuration object containing rendering parameters
     * @param params.shaderProgram - The WebGL shader program to configure
     * @param params.args - WebGL rendering arguments containing matrices, camera, and entity data
     */
    _setInternalSettingParametersToGpuWebGLPerMaterial({ shaderProgram, args, }: {
        shaderProgram: WebGLProgram;
        args: RenderingArgWebGL;
    }): void;
}

/**
 * Material content class for decoding shadow maps using the classic shadow mapping technique.
 * This class handles the rendering of shadow maps with proper depth comparison and shadow factor calculations.
 * It supports morphing, skinning, lighting, and debugging modes for comprehensive shadow rendering functionality.
 */
declare class ShadowMapDecodeClassicMaterialContent extends AbstractMaterialContent {
    /** Shader semantic for controlling the color factor applied to shadowed areas */
    static ShadowColorFactor: ShaderSemanticsEnum;
    /** Shader semantic for controlling the alpha value in shadowed regions */
    static ShadowAlpha: ShaderSemanticsEnum;
    /** Shader semantic for controlling the alpha value in non-shadowed regions */
    static NonShadowAlpha: ShaderSemanticsEnum;
    /** Shader semantic for defining the allowable depth error tolerance in shadow calculations */
    static AllowableDepthError: ShaderSemanticsEnum;
    /** Shader semantic for the near clipping plane distance of the inner camera */
    static zNearInner: ShaderSemanticsClass;
    /** Shader semantic for the far clipping plane distance of the inner camera */
    static zFarInner: ShaderSemanticsClass;
    /** Shader semantic for the debug color factor used in debugging mode */
    static DebugColorFactor: ShaderSemanticsEnum;
    /** Shader semantic for the depth texture containing encoded depth information */
    static DepthTexture: ShaderSemanticsEnum;
    /** Shader semantic indicating whether the light source is a point light */
    static IsPointLight: ShaderSemanticsClass;
    /** Cached value of the last used near clipping plane distance for optimization */
    private static __lastZNear;
    /** Cached value of the last used far clipping plane distance for optimization */
    private static __lastZFar;
    /** The render pass that contains the encoded depth information for shadow mapping */
    private __encodedDepthRenderPass;
    /**
     * Creates a new instance of ShadowMapDecodeClassicMaterialContent.
     * This constructor initializes the shadow mapping material with comprehensive configuration options
     * for various rendering features and sets up the necessary shader semantics for shadow decoding.
     *
     * @param materialName - The unique name identifier for this material
     * @param options - Configuration object containing rendering feature flags and settings
     * @param options.isMorphing - Enables morphing/blend shape animation support
     * @param options.isSkinning - Enables skeletal animation support
     * @param options.isLighting - Enables lighting calculations (when false, shows original colors except in shadows)
     * @param options.isDebugging - Enables debug visualization showing areas outside depth map coverage
     * @param options.colorAttachmentsNumber - Index of the color attachment containing encoded depth data
     * @param encodedDepthRenderPass - The render pass containing depth information from DepthEncodeMaterialContent
     */
    constructor(materialName: string, { isMorphing, isSkinning, isLighting, isDebugging, colorAttachmentsNumber, }: {
        isMorphing: boolean;
        isSkinning: boolean;
        isLighting: boolean;
        isDebugging: boolean;
        colorAttachmentsNumber: Count;
    }, encodedDepthRenderPass: RenderPass);
    /**
     * Sets internal shader parameters specific to this material on a per-material basis.
     * This method handles the configuration of shadow mapping parameters, camera settings,
     * and various rendering components such as skinning, lighting, and morphing.
     * It optimizes performance by caching frequently used values and only updating them when necessary.
     *
     * @param params - Configuration object containing all necessary rendering parameters
     * @param params.material - The material instance being configured
     * @param params.shaderProgram - The WebGL shader program to configure
     * @param params.firstTime - Whether this is the first time setting parameters for this material
     * @param params.args - WebGL-specific rendering arguments containing render state and components
     *
     * @internal This method is called internally during the rendering pipeline
     */
    _setInternalSettingParametersToGpuWebGLPerMaterial({ material, shaderProgram, args, }: {
        material: Material;
        shaderProgram: WebGLProgram;
        args: RenderingArgWebGL;
    }): void;
}

/**
 * Material content for synthesizing HDR textures with optional target region masking.
 * This material is commonly used for glare effects and other post-processing operations.
 */
declare class SynthesizeHdrMaterialContent extends AbstractMaterialContent {
    static SynthesizeCoefficient: ShaderSemanticsClass;
    static TargetRegionTexture: ShaderSemanticsClass;
    static SynthesizeTexture0: ShaderSemanticsClass;
    static SynthesizeTexture1: ShaderSemanticsClass;
    static SynthesizeTexture2: ShaderSemanticsClass;
    static SynthesizeTexture3: ShaderSemanticsClass;
    static SynthesizeTexture4: ShaderSemanticsClass;
    static SynthesizeTexture5: ShaderSemanticsClass;
    private textureNumber;
    /**
     * Creates a new SynthesizeHdrMaterialContent instance for HDR texture synthesis.
     *
     * This material node supports texture synthesis operations commonly used for glare effects
     * and other post-processing operations. It can synthesize up to 6 textures simultaneously.
     *
     * **Synthesis Behavior:**
     * - **Without targetRegionTexture**: Synthesizes all input textures across all pixels,
     *   weighted by the corresponding synthesizeCoefficient values.
     * - **With targetRegionTexture**: Applies weighted synthesis only to non-white pixels
     *   (where color != (1.0, 1.0, 1.0, 1.0)). White areas receive the product of
     *   synthesizeTextures[0] and synthesizeCoefficient[0].
     *
     * @param materialName - Unique identifier for this material instance
     * @param synthesizeTextures - Array of textures to be synthesized (supports up to 6 textures)
     *
     * @example
     * ```typescript
     * const synthesizeTextures = [texture1, texture2, texture3];
     * const material = new SynthesizeHdrMaterialContent('GlareMaterial', synthesizeTextures);
     * ```
     */
    constructor(materialName: string, synthesizeTextures: AbstractTexture[]);
    /**
     * Sets internal WebGL-specific parameters for the material during rendering.
     *
     * This method is called during the WebGL rendering pipeline to configure
     * shader uniforms and state specific to this material. It handles matrix
     * transformations and synthesis coefficient updates.
     *
     * @param params - Configuration object containing material and rendering context
     * @param params.material - The material instance being rendered
     * @param params.shaderProgram - WebGL shader program to configure
     * @param params.firstTime - Whether this is the first time setting parameters
     * @param params.args - WebGL rendering arguments and context
     *
     * @internal This method is part of the internal rendering pipeline
     */
    _setInternalSettingParametersToGpuWebGLPerMaterial({ material, shaderProgram, args, }: {
        material: Material;
        shaderProgram: WebGLProgram;
        args: RenderingArgWebGL;
    }): void;
    /**
     * Gets the number of textures configured for synthesis.
     *
     * @returns The count of textures that will be processed during synthesis
     *
     * @example
     * ```typescript
     * const material = new SynthesizeHdrMaterialContent('test', [tex1, tex2]);
     * console.log(material.synthesizeTextureNumber); // 2
     * ```
     */
    get synthesizeTextureNumber(): number;
}

declare class VarianceShadowMapDecodeClassicMaterialContent extends AbstractMaterialContent {
    static IsPointLight: ShaderSemanticsClass;
    static DepthTexture: ShaderSemanticsClass;
    static SquareDepthTexture: ShaderSemanticsClass;
    static DepthAdjustment: ShaderSemanticsClass;
    static TextureDepthAdjustment: ShaderSemanticsClass;
    static MinimumVariance: ShaderSemanticsClass;
    static LightBleedingParameter: ShaderSemanticsClass;
    static ShadowColor: ShaderSemanticsClass;
    static AllowableDepthError: ShaderSemanticsClass;
    static zNearInner: ShaderSemanticsClass;
    static zFarInner: ShaderSemanticsClass;
    static DebugColorFactor: ShaderSemanticsEnum;
    private static __lastZNear;
    private static __lastZFar;
    private __depthCameraComponent?;
    /**
     * Creates a new instance of VarianceShadowMapDecodeClassicMaterialContent for variance shadow mapping.
     * This material content handles the decoding and rendering of variance shadow maps, which provide
     * soft shadows with reduced aliasing compared to traditional shadow mapping techniques.
     *
     * @param materialName - The name identifier for this material
     * @param options - Configuration options for the material
     * @param options.isMorphing - Whether to enable morphing/blend shape support
     * @param options.isSkinning - Whether to enable skeletal animation support
     * @param options.isLighting - Whether to apply lighting calculations. When false, renders original material color except in shadow areas
     * @param options.isDebugging - Whether to enable debug visualization showing areas outside depth map in debug color
     * @param options.colorAttachmentsNumberDepth - Index of the color attachment containing depth information from DepthEncodeMaterialContent
     * @param options.colorAttachmentsNumberSquareDepth - Index of the color attachment containing squared depth information
     * @param options.depthCameraComponent - Optional camera component used for depth rendering. If not provided, uses the current render pass camera
     * @param encodedDepthRenderPasses - Array of exactly 2 render passes containing the encoded depth information (depth and squared depth)
     * @throws Will log an error if encodedDepthRenderPasses length is not exactly 2
     * @throws Will log a warning if depthCameraComponent is not provided
     */
    constructor(materialName: string, { isMorphing, isSkinning, isLighting, isDebugging, colorAttachmentsNumberDepth, colorAttachmentsNumberSquareDepth, depthCameraComponent, }: {
        isMorphing: boolean;
        isSkinning: boolean;
        isLighting: boolean;
        isDebugging: boolean;
        colorAttachmentsNumberDepth: Count;
        colorAttachmentsNumberSquareDepth: Count;
        depthCameraComponent?: CameraComponent;
    }, encodedDepthRenderPasses: RenderPass[]);
    /**
     * Sets internal rendering parameters for the material on a per-material basis.
     * This method configures shader uniforms and parameters specific to variance shadow mapping,
     * including camera matrices, depth information, and various rendering features like skinning and morphing.
     *
     * @param params - The rendering parameters object
     * @param params.material - The material instance being rendered
     * @param params.shaderProgram - The WebGL shader program to configure
     * @param params.args - WebGL-specific rendering arguments containing entity, camera, and rendering context
     *
     * @remarks
     * This method handles:
     * - Setting world, view, and projection matrices
     * - Configuring depth camera parameters (zNear, zFar, view-projection matrix)
     * - Setting up skeletal animation if present
     * - Configuring lighting information
     * - Setting up morph target data if morphing is enabled
     *
     * The method optimizes performance by caching zNear and zFar values to avoid unnecessary uniform updates.
     */
    _setInternalSettingParametersToGpuWebGLPerMaterial({ material, shaderProgram, args, }: {
        material: Material;
        shaderProgram: WebGLProgram;
        args: RenderingArgWebGL;
    }): void;
    /**
     * Sets the depth camera component used for shadow map generation.
     * This camera defines the light's perspective for shadow mapping calculations.
     *
     * @param depthCameraComponent - The camera component representing the light's view for shadow mapping
     *
     * @remarks
     * The depth camera component should be positioned and oriented to match the light source
     * that will cast shadows. Its view-projection matrix will be used to transform vertices
     * into light space for shadow map lookup operations.
     */
    set depthCameraComponent(depthCameraComponent: CameraComponent);
}

/**
 * Configuration properties for a physics world simulation.
 * This type defines the essential parameters needed to initialize and configure
 * a physics world environment.
 */
type PhysicsWorldProperty = {
    /**
     * The gravitational force vector applied to all physics bodies in the world.
     * Typically set to (0, -9.81, 0) for Earth-like gravity pointing downward.
     * @example
     * ```typescript
     * const gravity: IVector3 = { x: 0, y: -9.81, z: 0 };
     * ```
     */
    gravity: IVector3;
    /**
     * Whether to enable randomization in physics calculations.
     * When true, introduces small random variations to improve simulation stability
     * and prevent deterministic artifacts in edge cases.
     * @default false
     */
    random: boolean;
};

/**
 * Physics strategy implementation using the Oimo.js physics engine.
 * This class provides physics simulation capabilities for 3D objects in the scene.
 * It implements the PhysicsStrategy interface to integrate with the Rhodonite framework.
 */
declare class OimoPhysicsStrategy implements PhysicsStrategy {
    /**
     * Global physics world properties shared across all instances.
     * Contains gravity settings and randomization options.
     */
    static __worldProperty: PhysicsWorldProperty;
    /**
     * The shared Oimo physics world instance.
     * All physics bodies are added to this single world for simulation.
     */
    static __world: any;
    /**
     * The Oimo physics body associated with this strategy instance.
     */
    private __body;
    /**
     * The scene graph entity that this physics strategy is attached to.
     */
    private __entity?;
    /**
     * Cached physics properties used for body recreation when needed.
     */
    private __property;
    /**
     * The original local scale of the physics shape before any transformations.
     */
    private __localScale;
    /**
     * Creates a new OimoPhysicsStrategy instance.
     * Initializes the shared Oimo physics world if it doesn't exist yet.
     */
    constructor();
    /**
     * Sets up the physics shape for the given entity with specified properties.
     * Creates a physics body in the Oimo world with the provided configuration.
     *
     * @param prop - The physics properties defining the shape, size, position, and material properties
     * @param entity - The scene graph entity to associate with this physics body
     */
    setShape(prop: PhysicsPropertyInner, entity: ISceneGraphEntity): void;
    /**
     * Updates the associated entity's transform based on the physics body's current state.
     * This method should be called each frame to synchronize the visual representation
     * with the physics simulation results.
     */
    update(): void;
    /**
     * Sets the world position of the physics body.
     * Recreates the physics body with the new position while preserving other properties.
     *
     * @param worldPosition - The new world position to set for the physics body
     */
    setPosition(worldPosition: IVector3): void;
    /**
     * Sets the rotation of the physics body using Euler angles.
     * Recreates the physics body with the new rotation while preserving other properties.
     *
     * @param eulerAngles - The new Euler angles (in radians) to set for the physics body
     */
    setEulerAngle(eulerAngles: IVector3): void;
    /**
     * Sets the scale of the physics body.
     * Recreates the physics body with the new scale applied to the original local scale
     * while preserving other properties.
     *
     * @param scale - The scale factors to apply to the physics body's dimensions
     */
    setScale(scale: IVector3): void;
    /**
     * Advances the physics simulation by one time step.
     * This static method should be called once per frame to update all physics bodies
     * in the shared world. It processes collisions, applies forces, and updates positions.
     */
    static update(): void;
}

/**
 * A capsule-shaped collider used for VRM spring bone physics simulation.
 * The capsule is defined by a position (head), tail position, and radius.
 * It can detect collisions with spherical objects like bones.
 */
declare class CapsuleCollider {
    /** The position of the capsule's head in local space */
    position: Vector3;
    /** The radius of the capsule */
    radius: number;
    /** The position of the capsule's tail in local space */
    tail: Vector3;
    /** The base scene graph component used for world space transformations */
    baseSceneGraph?: SceneGraphComponent;
    /**
     * Calculates collision information between this capsule collider and a spherical bone.
     *
     * @param bonePosition - The world position of the bone
     * @param boneRadius - The radius of the bone sphere
     * @returns An object containing the collision direction vector and penetration distance.
     *          If distance is negative, the bone is penetrating the capsule.
     *          The direction points from the capsule surface towards the bone center.
     */
    collision(bonePosition: Vector3, boneRadius: number): {
        direction: Vector3;
        distance: number;
    };
}

/**
 * A sphere collider used for VRM spring bone physics simulation.
 * This collider represents a spherical collision volume that can interact with bones
 * to prevent them from penetrating through solid objects.
 */
declare class SphereCollider {
    /** The local position of the sphere collider relative to its base scene graph node */
    position: Vector3;
    /** The radius of the sphere collider */
    radius: number;
    /** The base scene graph component that defines the transform space for this collider */
    baseSceneGraph?: SceneGraphComponent;
    private static __tmp_vec3_0;
    private static __tmp_vec3_1;
    private static __tmp_vec3_2;
    /**
     * Calculates collision information between this sphere collider and a bone.
     *
     * @param bonePosition - The world position of the bone
     * @param boneRadius - The radius of the bone for collision detection
     * @returns An object containing the collision direction and penetration distance
     *   - direction: The normalized vector pointing from the sphere center to the bone
     *   - distance: The penetration distance (negative if penetrating, positive if separated)
     */
    collision(bonePosition: Vector3, boneRadius: number): {
        direction: IMutableVector3;
        distance: number;
    };
}

/**
 * A group of colliders used in VRM spring bone physics simulation.
 * This class manages collections of sphere and capsule colliders that can interact
 * with spring bones to provide collision detection and response.
 */
declare class VRMColliderGroup {
    /**
     * Array of sphere colliders in this group.
     * Sphere colliders are used for simple spherical collision detection.
     */
    sphereColliders: SphereCollider[];
    /**
     * Array of capsule colliders in this group.
     * Capsule colliders are used for cylindrical collision detection with rounded ends.
     */
    capsuleColliders: CapsuleCollider[];
}

/**
 * VRM Spring Bone implementation for physics-based bone animation.
 * This class handles the physics simulation of spring bones commonly used in VRM models
 * for secondary animation like hair, clothes, and accessories.
 */
declare class VRMSpringBone extends RnObject {
    /** The stiffness force that controls how quickly the bone returns to its rest position */
    stiffnessForce: number;
    /** The power of gravity affecting the bone movement */
    gravityPower: number;
    /** The direction vector of gravity force */
    gravityDir: Vector3;
    /** The drag force that dampens the bone movement */
    dragForce: number;
    /** The radius used for collision detection */
    hitRadius: number;
    /** The scene graph entity node that this spring bone is attached to */
    node: ISceneGraphEntity;
    /** Current tail position in world space coordinates */
    currentTail: Vector3;
    /** Previous tail position in world space coordinates */
    prevTail: Vector3;
    /** The bone axis direction in local space coordinates */
    boneAxis: Vector3;
    /** The length of the bone in world space units */
    boneLength: number;
    /** The initial local position of the child bone */
    initialLocalChildPosition: Vector3;
    /** Flag indicating whether the spring bone has been initialized */
    initialized: boolean;
    /** Temporary vector for internal calculations */
    private static __tmp_vec3_0;
    /** Temporary vector for internal calculations */
    private static __tmp_vec3_1;
    /** Temporary zero vector for internal calculations */
    private static __tmp_vec3_2_zero;
    /**
     * Creates a new VRM Spring Bone instance.
     * @param node - The scene graph entity node to attach this spring bone to
     */
    constructor(node: ISceneGraphEntity);
    /**
     * Initializes the spring bone with default values and calculates initial positions.
     * This method should be called once before starting the physics simulation.
     * @param center - Optional center component for coordinate transformation
     */
    setup(center?: SceneGraphComponent): void;
    /**
     * Gets the transformation matrix from center space to world space.
     * @param center - Optional center component for coordinate transformation
     * @returns The transformation matrix from center to world space
     */
    _getMatrixCenterToWorld(center?: SceneGraphComponent): IMatrix44;
    /**
     * Gets the transformation matrix from world space to center space.
     * @param center - Optional center component for coordinate transformation
     * @returns The transformation matrix from world to center space
     */
    _getMatrixWorldToCenter(center?: SceneGraphComponent): IMatrix44;
    /**
     * Calculates the bone length in world space coordinates.
     * This method updates the boneLength property based on the current world positions
     * of the bone and its child (or estimated child position).
     */
    _calcWorldSpaceBoneLength(): void;
}

/**
 * Represents a VRM spring bone system that manages physics simulation for character bones.
 * This class handles the configuration and management of spring bones, collider groups,
 * and their interactions within the VRM specification.
 *
 * @example
 * ```typescript
 * const rootBone = sceneGraphComponent;
 * const vrmSpring = new VRMSpring(rootBone);
 * vrmSpring.bones.push(new VRMSpringBone());
 * vrmSpring.colliderGroups.push(new VRMColliderGroup());
 * ```
 */
declare class VRMSpring extends RnObject {
    /** The root bone component that serves as the base for the spring bone system */
    rootBone: SceneGraphComponent;
    /** Array of spring bones that will be affected by physics simulation */
    bones: VRMSpringBone[];
    /** Array of collider groups that define collision boundaries for spring bones */
    colliderGroups: VRMColliderGroup[];
    /** Optional center reference point for spring bone calculations */
    center: SceneGraphComponent | undefined;
    /**
     * Creates a new VRMSpring instance with the specified root bone.
     *
     * @param rootBone - The scene graph component that will serve as the root bone
     *                   for this spring bone system
     */
    constructor(rootBone: SceneGraphComponent);
}

/**
 * Physics strategy implementation for VRM spring bone simulation.
 *
 * This class handles the physics simulation of VRM spring bones, which are used
 * to create realistic secondary animation for hair, clothing, accessories, and other
 * flexible parts of VRM models. The simulation includes:
 * - Inertia and drag forces
 * - Gravity effects
 * - Stiffness constraints
 * - Collision detection and response
 * - Bone length normalization
 *
 * The physics simulation runs per frame and updates the rotation of spring bone nodes
 * based on physical forces and constraints.
 */
declare class VRMSpringBonePhysicsStrategy implements PhysicsStrategy {
    private static __tmp_process_vec3_0;
    private static __tmp_process_vec3_1;
    private static __tmp_process_vec3_2;
    private static __tmp_process_vec3_3;
    private static __tmp_process_vec3_4;
    private static __tmp_process_vec3_5;
    private static __tmp_process_vec3_6;
    private static __tmp_process_vec3_7;
    private static __tmp_process_vec3_8;
    private static __tmp_process_vec3_9;
    private static __tmp_process_quat_0;
    private static __tmp_normalizeBoneLength_vec3_0;
    private static __tmp_normalizeBoneLength_vec3_1;
    private static __tmp_normalizeBoneLength_vec3_2;
    private static __tmp_normalizeBoneLength_vec3_3;
    private static __tmp_normalizeBoneLength_vec3_4;
    private static __tmp_normalizeBoneLength_vec3_5;
    private static __tmp_applyRotation_vec3_0;
    private static __tmp_applyRotation_vec3_1;
    private static __tmp_applyRotation_vec3_2;
    private static __tmp_applyRotation_vec3_3;
    private static __tmp_applyRotation_quat_0;
    private static __tmp_applyRotation_quat_1;
    private static __tmp_applyRotation_quat_2;
    private static __tmp_applyRotation_quat_3;
    private static __tmp_applyRotation_quat_4;
    private static __tmp_getParentRotation_quat_0;
    private static __tmp_getParentRotation_quat_1_identity;
    private static __tmp_collision_vec3_0;
    private static __tmp_collision_vec3_1;
    private static __tmp_collision_vec3_2;
    private static __tmp_collision_vec3_3;
    private __spring;
    /**
     * Gets the parent rotation of the specified scene graph component.
     *
     * @param head - The scene graph component to get the parent rotation for
     * @returns The parent's rotation quaternion, or identity quaternion if no parent exists
     */
    getParentRotation(head: SceneGraphComponent): MutableQuaternion;
    /**
     * Updates the spring bone physics simulation for the current frame.
     *
     * This method is called once per frame and triggers the physics update
     * for all spring bones in the associated VRM spring system.
     */
    update(): void;
    /**
     * Internal update method that processes all spring bones in the system.
     *
     * @param bones - Array of VRM spring bones to update
     * @param spring - The VRM spring system containing configuration and colliders
     */
    updateInner(bones: VRMSpringBone[], spring: VRMSpring): void;
    /**
     * Processes the physics simulation for a single spring bone.
     *
     * This method performs the complete physics simulation pipeline:
     * 1. Calculates inertia from previous frame movement
     * 2. Applies stiffness forces to maintain bone orientation
     * 3. Applies external forces (gravity)
     * 4. Normalizes bone length to maintain constraints
     * 5. Handles collision detection and response
     * 6. Updates bone position and rotation
     *
     * @param collisionGroups - Array of collision groups for collision detection
     * @param bone - The spring bone to process
     * @param center - Optional center transform for coordinate space conversion
     */
    process(collisionGroups: VRMColliderGroup[], bone: VRMSpringBone, center?: SceneGraphComponent): void;
    /**
     * Normalizes the bone length to maintain the original bone length constraint.
     *
     * This method ensures that the spring bone maintains its original length
     * regardless of the forces applied during simulation. It calculates the
     * direction from the bone's head to the target tail position and scales
     * it to match the original bone length.
     *
     * @param nextTail - The target tail position before normalization
     * @param bone - The spring bone to normalize
     * @returns The normalized tail position maintaining the original bone length
     */
    normalizeBoneLength(nextTail: Vector3, bone: VRMSpringBone): IMutableVector3;
    /**
     * Applies the calculated rotation to the spring bone based on the new tail position.
     *
     * This method calculates the rotation needed to orient the bone from its head
     * to the new tail position. It takes into account the parent's rotation and
     * the bone's rest rotation to compute the final local rotation.
     *
     * @param nextTail - The new tail position in world space
     * @param bone - The spring bone to apply rotation to
     * @returns The calculated local rotation quaternion for the bone
     */
    applyRotation(nextTail: Vector3, bone: VRMSpringBone): IMutableQuaternion;
    /**
     * Handles collision detection and response for the spring bone.
     *
     * This method checks for collisions between the spring bone and all colliders
     * in the provided collision groups. It supports both sphere and capsule colliders.
     * When a collision is detected, the bone's tail position is adjusted to resolve
     * the collision, and the bone length is re-normalized.
     *
     * @param collisionGroups - Array of collision groups containing colliders
     * @param nextTail - The target tail position to check for collisions
     * @param boneHitRadius - The radius of the bone for collision detection
     * @param bone - The spring bone being tested for collisions
     * @returns The adjusted tail position after collision resolution
     */
    collision(collisionGroups: VRMColliderGroup[], nextTail: Vector3, boneHitRadius: number, bone: VRMSpringBone): Vector3;
    /**
     * Sets the VRM spring system to be managed by this physics strategy.
     *
     * @param sgs - The VRM spring system containing bones and configuration
     */
    setSpring(sgs: VRMSpring): void;
}

type ColorAttachmentIndex = number;
type InputRenderPassIndex = number;
type RenderPassIndex = number;
/**
 * Frame manages expressions and their input/output dependencies in the rendering pipeline.
 *
 * The Frame class serves as a container for multiple rendering expressions and handles
 * the complex relationships between render passes, including input dependencies and
 * output framebuffer assignments. It provides mechanisms for querying color attachments
 * from input render passes and resolving dependencies between expressions.
 *
 * @example
 * ```typescript
 * const frame = new Frame();
 * frame.addExpression(myExpression, {
 *   inputRenderPasses: [shadowPass, geometryPass],
 *   outputs: [{
 *     renderPass: { index: 0 },
 *     frameBuffer: myFrameBuffer
 *   }]
 * });
 * frame.resolve();
 * ```
 */
declare class Frame extends RnObject {
    private __expressions;
    private __expressionsCache;
    /** Constant identifier for standard framebuffer type */
    static readonly FrameBuffer = "FrameBuffer";
    /** Constant identifier for resolve framebuffer type */
    static readonly ResolveFrameBuffer = "ResolveFrameBuffer";
    /** Constant identifier for secondary resolve framebuffer type */
    static readonly ResolveFrameBuffer2 = "ResolveFrameBuffer2";
    private __expressionQueries;
    /**
     * Adds a rendering expression to this frame with optional input dependencies and output configurations.
     *
     * This method registers an expression within the frame and establishes its relationships
     * with input render passes and output framebuffers. The expression will be executed
     * in the order it was added to the frame.
     *
     * @param expression - The rendering expression to add to this frame
     * @param options - Configuration object for input dependencies and outputs
     * @param options.inputRenderPasses - Array of render passes that this expression depends on
     * @param options.outputs - Array of output configurations specifying which render passes
     *                         should render to which framebuffers
     *
     * @example
     * ```typescript
     * frame.addExpression(lightingExpression, {
     *   inputRenderPasses: [geometryPass, shadowPass],
     *   outputs: [{
     *     renderPass: { index: 0 },
     *     frameBuffer: screenFrameBuffer
     *   }]
     * });
     * ```
     */
    addExpression(expression: Expression, { inputRenderPasses, outputs, }?: {
        inputRenderPasses?: RenderPass[];
        outputs?: {
            renderPass: RequireOne<{
                index?: RenderPassIndex;
                uniqueName?: string;
                instance?: RenderPass;
            }>;
            frameBuffer: FrameBuffer;
        }[];
    }): void;
    /**
     * Retrieves a color attachment render target texture from an input render pass of the specified expression.
     *
     * This method creates a promise-based query system that allows expressions to access
     * color attachment textures from their input render passes. The actual texture retrieval
     * is deferred until the resolve() method is called, enabling proper dependency resolution.
     *
     * @param inputFrom - The expression from which to retrieve the color attachment
     * @param renderPassArg - Configuration object specifying the render pass and attachment details
     * @param renderPassArg.renderPass - Identifier for the target render pass (by index, name, or instance)
     * @param renderPassArg.colorAttachmentIndex - Index of the color attachment to retrieve (default: 0)
     * @param renderPassArg.framebufferType - Type of framebuffer to query (default: 'FrameBuffer')
     *
     * @returns Promise that resolves to the requested RenderTargetTexture
     *
     * @example
     * ```typescript
     * const colorTexture = await frame.getColorAttachmentFromInputOf(geometryExpression, {
     *   renderPass: { index: 0 },
     *   colorAttachmentIndex: 0,
     *   framebufferType: Frame.FrameBuffer
     * });
     * ```
     */
    getColorAttachmentFromInputOf(inputFrom: Expression, renderPassArg?: {
        renderPass: RequireOne<{
            index?: InputRenderPassIndex;
            uniqueName?: string;
            instance?: RenderPass;
        }>;
        colorAttachmentIndex: ColorAttachmentIndex;
        framebufferType: 'FrameBuffer' | 'ResolveFrameBuffer' | 'ResolveFrameBuffer2';
    }): Promise<RenderTargetTexture>;
    /**
     * Resolves all pending expression queries and establishes texture dependencies.
     *
     * This method processes all queued color attachment queries created by
     * getColorAttachmentFromInputOf() calls. It matches expressions with their
     * corresponding render passes and retrieves the requested color attachment
     * textures, fulfilling the associated promises.
     *
     * This method should be called after all expressions have been added and
     * all color attachment queries have been registered, typically before
     * beginning the actual rendering process.
     *
     * @example
     * ```typescript
     * // Add all expressions and set up queries
     * frame.addExpression(expr1);
     * frame.addExpression(expr2);
     * await frame.getColorAttachmentFromInputOf(expr1, {...});
     *
     * // Resolve all dependencies
     * frame.resolve();
     * ```
     */
    resolve(): void;
    /**
     * Removes all expressions from this frame and clears associated caches.
     *
     * This method resets the frame to its initial empty state, removing all
     * registered expressions and clearing internal caches. Any pending
     * expression queries will also be implicitly cleared.
     *
     * @example
     * ```typescript
     * frame.clearExpressions();
     * // Frame is now empty and ready for new expressions
     * ```
     */
    clearExpressions(): void;
    /**
     * Gets a read-only array of all expressions currently registered in this frame.
     *
     * @returns Array of Expression objects in the order they were added
     *
     * @example
     * ```typescript
     * const allExpressions = frame.expressions;
     * console.log(`Frame contains ${allExpressions.length} expressions`);
     * ```
     */
    get expressions(): Expression[];
    /**
     * Sets the viewport for all expressions in this frame.
     *
     * This method propagates the viewport settings to all registered expressions,
     * ensuring consistent rendering dimensions across the entire frame.
     *
     * @param viewport - 4D vector defining the viewport (x, y, width, height)
     *
     * @example
     * ```typescript
     * frame.setViewport(Vector4.fromCopyArray([0, 0, 1920, 1080]));
     * ```
     */
    setViewport(viewport: IVector4): void;
}

/**
 * A forward rendering pipeline that provides advanced rendering features including shadows, bloom, tone mapping, and IBL.
 *
 * @remarks
 * ForwardRenderPipeline is a comprehensive rendering solution that handles multi-pass rendering setups
 * with features like MSAA, shadow mapping, bloom effects, and tone mapping. It supports both regular
 * rendering and WebXR multi-view rendering for VR applications.
 *
 * The pipeline automatically manages frame buffers, render targets, and expression chains to provide
 * a complete rendering solution similar to Unity's Universal Render Pipeline (URP).
 *
 * @example
 * ```typescript
 * const expressions = [...];
 * const matrix = [...];
 *
 * // Create and setup the render pipeline
 * const forwardRenderPipeline = new Rn.ForwardRenderPipeline();
 * await forwardRenderPipeline.setup(1024, 1024, {isShadow: true, isBloom: true});
 *
 * // Configure expressions and IBL
 * forwardRenderPipeline.setExpressions(expressions);
 *
 * const diffuseCubeTexture = new Rn.CubeTexture();
 * diffuseCubeTexture.baseUriToLoad = './../../../assets/ibl/papermill/diffuse/diffuse';
 * diffuseCubeTexture.isNamePosNeg = true;
 * diffuseCubeTexture.hdriFormat = Rn.HdriFormat.RGBE_PNG;
 * diffuseCubeTexture.mipmapLevelNumber = 1;
 *
 * const specularCubeTexture = new Rn.CubeTexture();
 * specularCubeTexture.baseUriToLoad = './../../../assets/ibl/papermill/specular/specular';
 * specularCubeTexture.isNamePosNeg = true;
 * specularCubeTexture.hdriFormat = Rn.HdriFormat.RGBE_PNG;
 * specularCubeTexture.mipmapLevelNumber = 10;
 *
 * forwardRenderPipeline.setIBLTextures(diffuseCubeTexture, specularCubeTexture);
 *
 * // Start the render loop
 * forwardRenderPipeline.startRenderLoop((frame) => {
 *   Rn.System.process(frame);
 * });
 * ```
 */
declare class ForwardRenderPipeline extends RnObject {
    private __width;
    private __height;
    private __isShadow;
    private __isBloom;
    private __isSimple;
    private __shadowMapSize;
    private __oFrame;
    private __oFrameBufferMultiView;
    private __oFrameBufferMultiViewBlit;
    private __oFrameBufferMultiViewBlitBackBuffer;
    private __oFrameBufferMsaa;
    private __oFrameBufferResolve;
    private __oFrameBufferResolveForReference;
    private __oInitialExpression;
    /** main expressions */
    private __expressions;
    private __oGenerateMipmapsExpression;
    private __oMultiViewBlitBackBufferExpression;
    private __oMultiViewBlitExpression;
    private __oBloomExpression;
    private __oToneMappingExpression;
    private __oToneMappingMaterial;
    private __transparentOnlyExpressions;
    private __oWebXRSystem;
    private __oDrawFunc;
    private __oDiffuseCubeTexture;
    private __oSpecularCubeTexture;
    private __oSheenCubeTexture;
    private __oSamplerForBackBuffer;
    private __toneMappingType;
    private __bloomHelper;
    private __oShadowSystem;
    private __shadowExpressions;
    /**
     * Destroys all allocated 3D API resources including frame buffers and textures.
     *
     * @remarks
     * This method is called internally during resize operations and cleanup.
     * It ensures proper resource management by releasing GPU memory.
     *
     * @internal
     */
    private __destroyResources;
    /**
     * Initializes the rendering pipeline with the specified configuration.
     *
     * @param canvasWidth - The width of the rendering canvas in pixels
     * @param canvasHeight - The height of the rendering canvas in pixels
     * @param options - Configuration options for the pipeline
     * @param options.isShadow - Whether to enable shadow mapping (default: false)
     * @param options.isBloom - Whether to enable bloom post-processing effect (default: false)
     * @param options.shadowMapSize - Size of the shadow map texture in pixels (default: 1024)
     * @param options.isSimple - Whether to use simplified rendering without post-processing (default: false)
     *
     * @returns A Result indicating success or failure of the setup operation
     *
     * @remarks
     * This method must be called before using any other pipeline methods. It creates all necessary
     * frame buffers, render targets, and expressions based on the provided configuration.
     *
     * The method automatically detects WebXR capabilities and configures multi-view rendering
     * when appropriate for VR applications.
     *
     * @example
     * ```typescript
     * const result = await pipeline.setup(1920, 1080, {
     *   isShadow: true,
     *   isBloom: true,
     *   shadowMapSize: 2048
     * });
     *
     * if (result.isErr()) {
     *   console.error('Pipeline setup failed:', result.getErr());
     * }
     * ```
     */
    setup(canvasWidth: number, canvasHeight: number, { isShadow, isBloom, shadowMapSize, isSimple }?: {
        isShadow?: boolean | undefined;
        isBloom?: boolean | undefined;
        shadowMapSize?: number | undefined;
        isSimple?: boolean | undefined;
    }): Promise<Err<unknown, undefined> | Ok<unknown, unknown>>;
    /**
     * Gets the main frame buffer used for back buffer operations.
     *
     * @returns The frame buffer for back buffer operations, or None if not available
     *
     * @internal
     */
    private __getMainFrameBufferBackBuffer;
    /**
     * Gets the main frame buffer used for resolve operations.
     *
     * @returns The frame buffer for resolve operations, or None if not available
     *
     * @internal
     */
    private __getMainFrameBufferResolve;
    /**
     * Gets the main frame buffer used for rendering operations.
     *
     * @returns The main frame buffer, or None if not available
     *
     * @internal
     */
    private __getMainFrameBuffer;
    /**
     * Sets the expressions to be rendered by the pipeline.
     *
     * @param expressions - Array of expressions containing render passes and entities to render
     * @param options - Configuration options for expression setup
     * @param options.isTransmission - Whether to enable transmission rendering for transparent objects (default: true)
     *
     * @remarks
     * This method configures the expressions for both opaque and transparent rendering.
     * When transmission is enabled, transparent objects are rendered in a separate pass
     * to support advanced material effects like glass and water.
     *
     * The method automatically clones expressions for transparent rendering and configures
     * shadow expressions if shadow mapping is enabled.
     *
     * @example
     * ```typescript
     * const expressions = [sceneExpression, uiExpression];
     * pipeline.setExpressions(expressions, { isTransmission: true });
     * ```
     */
    setExpressions(expressions: Expression[], options?: {
        isTransmission: boolean;
    }): void;
    /**
     * Starts the main rendering loop with the provided draw function.
     *
     * @param func - Function to be called each frame for rendering operations
     * @returns A Result indicating success or failure of starting the render loop
     *
     * @remarks
     * This method begins the continuous rendering loop using the system's render loop mechanism.
     * The provided function will be called every frame with the current frame object.
     *
     * The method automatically handles shadow system updates, expression management,
     * and frame processing.
     *
     * @example
     * ```typescript
     * const result = pipeline.startRenderLoop((frame) => {
     *   // Update scene
     *   Rn.System.process(frame);
     *
     *   // Custom per-frame logic
     *   updateAnimations();
     *   handleInput();
     * });
     *
     * if (result.isErr()) {
     *   console.error('Failed to start render loop:', result.getErr());
     * }
     * ```
     */
    startRenderLoop(func: (frame: Frame) => void): Err<unknown, undefined> | Ok<unknown, unknown>;
    /**
     * Executes a single frame render using the draw function provided to startRenderLoop.
     *
     * @remarks
     * This method allows manual control over frame rendering instead of using the automatic
     * render loop. It calls the draw function that was provided to startRenderLoop.
     *
     * @example
     * ```typescript
     * // Manual frame rendering
     * pipeline.draw();
     * ```
     */
    draw(): void;
    /**
     * Resizes the rendering pipeline to match new canvas dimensions.
     *
     * @param width - New width of the rendering canvas
     * @param height - New height of the rendering canvas
     * @returns A Result indicating success or failure of the resize operation
     *
     * @remarks
     * This method handles canvas resizing by destroying existing resources and recreating
     * them with the new dimensions. It automatically handles WebXR canvas sizing when
     * in VR mode.
     *
     * The method preserves all current pipeline settings (shadow, bloom, etc.) during resize.
     *
     * @example
     * ```typescript
     * window.addEventListener('resize', () => {
     *   const result = pipeline.resize(window.innerWidth, window.innerHeight);
     *   if (result.isErr()) {
     *     console.error('Resize failed:', result.getErr());
     *   }
     * });
     * ```
     */
    resize(width: Size, height: Size): Err<unknown, undefined> | Ok<unknown, unknown>;
    /**
     * Sets the IBL (Image-Based Lighting) cube textures for realistic lighting.
     *
     * @param diffuse - Diffuse IBL cube texture for ambient lighting
     * @param specular - Specular IBL cube texture for reflections
     * @param sheen - Optional sheen IBL cube texture for fabric-like materials
     *
     * @remarks
     * IBL textures provide realistic lighting by using pre-computed environment maps.
     * The diffuse texture provides ambient lighting, while the specular texture provides
     * reflections and specular highlights.
     *
     * The sheen texture is optional and used for materials with fabric-like properties.
     *
     * @example
     * ```typescript
     * const diffuseCube = new Rn.CubeTexture();
     * diffuseCube.baseUriToLoad = './assets/ibl/diffuse/diffuse';
     * diffuseCube.hdriFormat = Rn.HdriFormat.RGBE_PNG;
     *
     * const specularCube = new Rn.CubeTexture();
     * specularCube.baseUriToLoad = './assets/ibl/specular/specular';
     * specularCube.hdriFormat = Rn.HdriFormat.RGBE_PNG;
     * specularCube.mipmapLevelNumber = 10;
     *
     * pipeline.setIBLTextures(diffuseCube, specularCube);
     * ```
     */
    setIBLTextures(diffuse: CubeTexture, specular: CubeTexture, sheen?: CubeTexture): void;
    /**
     * Gets the initial expression used for buffer clearing and setup.
     *
     * @returns The initial expression, or undefined if not available
     *
     * @remarks
     * The initial expression is automatically created during setup and handles
     * clearing of color and depth buffers before main rendering begins.
     */
    getInitialExpression(): Expression | undefined;
    /**
     * Gets the tone mapping expression used for HDR to LDR conversion.
     *
     * @returns The tone mapping expression, or undefined if not available
     *
     * @remarks
     * The tone mapping expression is created during setup when not in simple mode.
     * It handles the conversion from high dynamic range rendering to low dynamic range
     * output suitable for display devices.
     */
    getToneMappingExpression(): Expression | undefined;
    /**
     * Sets the contribution factor for diffuse IBL lighting.
     *
     * @param value - Contribution factor (0.0 to 1.0 or higher for over-exposure effects)
     *
     * @remarks
     * This method controls how much the diffuse IBL texture contributes to the final lighting.
     * A value of 0.0 disables diffuse IBL, while 1.0 provides full contribution.
     * Values greater than 1.0 can be used for artistic over-exposure effects.
     *
     * @example
     * ```typescript
     * // Reduce ambient lighting
     * pipeline.setDiffuseIBLContribution(0.5);
     *
     * // Disable diffuse IBL
     * pipeline.setDiffuseIBLContribution(0.0);
     *
     * // Over-expose for artistic effect
     * pipeline.setDiffuseIBLContribution(2.0);
     * ```
     */
    setDiffuseIBLContribution(value: number): void;
    /**
     * Sets the contribution factor for specular IBL reflections.
     *
     * @param value - Contribution factor (0.0 to 1.0 or higher for over-exposure effects)
     *
     * @remarks
     * This method controls how much the specular IBL texture contributes to reflections
     * and specular highlights. A value of 0.0 disables specular IBL, while 1.0 provides
     * full contribution. Values greater than 1.0 can create over-exposed reflections.
     *
     * @example
     * ```typescript
     * // Subtle reflections
     * pipeline.setSpecularIBLContribution(0.3);
     *
     * // No reflections
     * pipeline.setSpecularIBLContribution(0.0);
     *
     * // Enhanced reflections
     * pipeline.setSpecularIBLContribution(1.5);
     * ```
     */
    setSpecularIBLContribution(value: number): void;
    /**
     * Sets the rotation of the IBL environment in radians.
     *
     * @param radian - Rotation angle in radians
     *
     * @remarks
     * This method allows rotating the IBL environment to match the desired lighting
     * direction. This is useful when the IBL doesn't align with the scene's lighting
     * requirements or for artistic control over the environment lighting.
     *
     * @example
     * ```typescript
     * // Rotate IBL by 90 degrees
     * pipeline.setIBLRotation(Math.PI / 2);
     *
     * // Rotate IBL by 180 degrees
     * pipeline.setIBLRotation(Math.PI);
     *
     * // Animate IBL rotation
     * let rotation = 0;
     * setInterval(() => {
     *   rotation += 0.01;
     *   pipeline.setIBLRotation(rotation);
     * }, 16);
     * ```
     */
    setIBLRotation(radian: number): void;
    /**
     * Internal method to configure expressions for opaque and blended rendering.
     *
     * @param expressions - Array of expressions to configure
     * @param options - Configuration options
     * @param options.isTransmission - Whether transmission rendering is enabled
     *
     * @internal
     */
    private __setExpressionsInner;
    /**
     * Internal method to configure expressions specifically for transparent object transmission.
     *
     * @param expressions - Array of expressions to configure for transmission
     *
     * @remarks
     * This method sets up expressions for rendering transparent objects with transmission
     * effects like glass and water. It configures back buffer access for refraction effects.
     *
     * @internal
     */
    private __setTransparentExpressionsForTransmission;
    /**
     * Creates and configures the initial expression for buffer clearing.
     *
     * @returns The configured initial expression
     *
     * @internal
     */
    private __setupInitialExpression;
    /**
     * Creates render targets and frame buffers based on canvas dimensions and WebXR support.
     *
     * @param canvasWidth - Width of the canvas
     * @param canvasHeight - Height of the canvas
     *
     * @remarks
     * This method automatically detects WebXR multi-view support and creates appropriate
     * render targets. For VR, it creates texture arrays for multi-view rendering.
     * For regular rendering, it creates MSAA frame buffers with resolve targets.
     *
     * @internal
     */
    private __createRenderTargets;
    /**
     * Sets up an expression for generating mipmaps on resolve frame buffers.
     *
     * @param resolveFramebuffer2 - The frame buffer to generate mipmaps for
     * @returns The configured mipmap generation expression
     *
     * @internal
     */
    private __setupGenerateMipmapsExpression;
    /**
     * Sets up an expression for blitting multi-view rendering to back buffer.
     *
     * @param multiViewFrameBuffer - The multi-view frame buffer to blit from
     * @returns The configured blit expression
     *
     * @internal
     */
    private __setupMultiViewBlitBackBufferExpression;
    /**
     * Sets up an expression for blitting multi-view rendering results.
     *
     * @param multiViewFrameBuffer - The multi-view frame buffer to blit from
     * @returns The configured blit expression
     *
     * @internal
     */
    private __setupMultiViewBlitExpression;
    /**
     * Sets up the tone mapping expression for HDR to LDR conversion.
     *
     * @param toneMappingTargetRenderTargetTexture - The render target texture to apply tone mapping to
     * @returns The configured tone mapping expression
     *
     * @remarks
     * This method creates both regular and VR-specific tone mapping render passes.
     * The tone mapping converts high dynamic range rendering results to low dynamic range
     * output suitable for display devices.
     *
     * @internal
     */
    private __setupToneMappingExpression;
    /**
     * Creates a frame buffer for depth moment shadow mapping.
     *
     * @param shadowMapSize - Size of the shadow map in pixels
     * @returns The configured depth moment frame buffer
     *
     * @internal
     */
    private __setupDepthMomentFramebuffer;
    /**
     * Internal method to apply IBL textures to all expressions.
     *
     * @internal
     */
    private __setIblInner;
    /**
     * Internal method to apply IBL textures to transparent-only expressions.
     *
     * @internal
     */
    private __setIblInnerForTransparentOnly;
    /**
     * Sets the tone mapping algorithm used for HDR to LDR conversion.
     *
     * @param type - The tone mapping algorithm to use
     *
     * @remarks
     * Tone mapping is essential for converting high dynamic range rendering results
     * to low dynamic range output that can be displayed on standard monitors.
     *
     * Available tone mapping algorithms:
     * - KhronosPbrNeutral: Khronos PBR neutral tone mapping
     * - Reinhard: Classic Reinhard tone mapping
     * - GT_ToneMap: GT tone mapping (default)
     * - ACES_Narkowicz: ACES tone mapping by Narkowicz
     * - ACES_Hill: ACES tone mapping by Hill
     * - ACES_Hill_Exposure_Boost: ACES Hill with exposure boost
     *
     * @example
     * ```typescript
     * // Use ACES tone mapping for cinematic look
     * pipeline.setToneMappingType(Rn.ToneMappingType.ACES_Hill);
     *
     * // Use Reinhard for classic look
     * pipeline.setToneMappingType(Rn.ToneMappingType.Reinhard);
     *
     * // Use Khronos PBR neutral for accurate colors
     * pipeline.setToneMappingType(Rn.ToneMappingType.KhronosPbrNeutral);
     * ```
     */
    setToneMappingType(type: ToneMappingTypeEnum): void;
    /**
     * Internal method to set up the frame with all configured expressions.
     *
     * @remarks
     * This method is called automatically during the render loop to configure
     * the frame with all necessary expressions in the correct order:
     * 1. Initial expression (buffer clearing)
     * 2. Shadow expressions
     * 3. Main expressions (opaque rendering)
     * 4. Mipmap generation
     * 5. Multi-view blitting
     * 6. Transparent expressions
     * 7. Bloom effect
     * 8. Tone mapping
     *
     * @internal
     */
    private __setExpressions;
}

/**
 * @fileoverview Common utility methods for rendering operations.
 * This module provides shared functionality used across different rendering components.
 */

/**
 * Determines whether drawing should be skipped for a given material and primitive combination.
 *
 * This function checks if the material has a valid shader program for the specified primitive.
 * If no valid shader program is available (indicated by a UID of -1), drawing should be skipped
 * to avoid rendering errors.
 *
 * @param material - The material to check for shader program availability
 * @param primitive - The primitive that will be rendered with the material
 * @returns `true` if drawing should be skipped (no valid shader program), `false` otherwise
 *
 * @example
 * ```typescript
 * const shouldSkip = isSkipDrawing(myMaterial, myPrimitive);
 * if (!shouldSkip) {
 *   // Proceed with rendering
 *   renderPrimitive(myPrimitive, myMaterial);
 * }
 * ```
 */
declare function isSkipDrawing(material: Material, primitive: Primitive): boolean;

declare const EVENT_MOUSE_DOWN = "mousedown";
declare const EVENT_MOUSE_MOVE = "mousemove";
declare const EVENT_MOUSE_UP = "mouseup";
declare const EVENT_MOUSE_WHEEL = "wheel";
declare const EVENT_MOUSE_ENTER = "mouseenter";
declare const EVENT_MOUSE_LEAVE = "mouseleave";
declare const EVENT_MOUSE_OVER = "mouseover";
declare const EVENT_CLICK = "click";
declare const EVENT_KEY_DOWN = "keydown";
declare const EVENT_KEY_UP = "keyup";
declare const EVENT_KEY_PRESS = "keypress";
declare const EVENT_POINTER_DOWN = "pointerdown";
declare const EVENT_MSPOINTER_DOWN = "MSPointerDown";
declare const EVENT_POINTER_MOVE = "pointermove";
declare const EVENT_MSPOINTER_MOVE = "MSPointerMove";
declare const EVENT_POINTER_UP = "pointerup";
declare const EVENT_MSPOINTER_UP = "MSPointerUp";
declare const EVENT_POINTER_CANCEL = "pointercancel";
declare const EVENT_POINTER_ENTER = "pointerenter";
declare const EVENT_POINTER_LEAVE = "pointerleave";
declare const EVENT_POINTER_OVER = "pointerover";
declare const EVENT_POINTER_OUT = "pointerout";
declare const EVENT_RESIZE = "resize";
declare const EVENT_ORIENTATION_CHANGE = "orientationchange";
declare const EVENT_TOUCH_TAP = "tap";
declare const EVENT_TOUCH_DOUBLE_TAP = "doubletap";
declare const EVENT_TOUCH_LONG_TAP = "longtap";
declare const EVENT_TOUCH_HOLD = "hold";
declare const EVENT_TOUCH_DRAG = "drag";
declare const EVENT_TOUCH_SWIPE = "swipe";
declare const EVENT_TOUCH_PINCH = "pinch";
declare const EVENT_TOUCH_START = "touchstart";
declare const EVENT_TOUCH_MOVE = "touchmove";
declare const EVENT_TOUCH_END = "touchend";
declare const EVENT_TOUCH_CANCEL = "touchcancel";
declare const EVENT_TOUCH_ENTER = "touchenter";
declare const EVENT_TOUCH_LEAVE = "touchleave";
declare const EVENT_TOUCH_OVER = "touchover";
declare const EVENT_TOUCH_OUT = "touchout";
declare global {
    interface Navigator {
        readonly pointerEnabled: boolean;
        readonly msPointerEnabled: boolean;
    }
}
/**
 * Gets the appropriate event name based on device capabilities and event type.
 * Automatically detects whether to use touch, pointer, or mouse events based on device support.
 *
 * @param type - The type of event to get ('start', 'move', 'end', or 'click')
 * @returns The appropriate event name string for the current device
 * @throws Error if called in a non-browser environment
 *
 * @example
 * ```typescript
 * const startEvent = getEvent('start'); // Returns 'touchstart', 'pointerdown', or 'mousedown'
 * element.addEventListener(startEvent, handler);
 * ```
 */
declare function getEvent(type: 'start' | 'move' | 'end' | 'click'): string;
type ClassInstance = any;
/**
 * Information about an input event handler including the event details and target.
 */
interface InputHandlerInfo {
    /** The name of the event to listen for */
    eventName: string;
    /** The event handler function */
    handler: (event: any) => void;
    /** Options for addEventListener */
    options: AddEventListenerOptions;
    /** The class instance that owns this handler */
    classInstance: ClassInstance;
    /** The DOM element to attach the event listener to */
    eventTargetDom: EventTarget;
}
declare const INPUT_HANDLING_STATE_NONE = "None";
declare const INPUT_HANDLING_STATE_CAMERA_CONTROLLER = "CameraController";
declare const INPUT_HANDLING_STATE_GIZMO_TRANSLATION = "GizmoTranslation";
declare const INPUT_HANDLING_STATE_GIZMO_SCALE = "GizmoScale";
/**
 * Represents different input handling states in the application.
 */
type InputHandlingState = typeof INPUT_HANDLING_STATE_NONE | typeof INPUT_HANDLING_STATE_CAMERA_CONTROLLER | typeof INPUT_HANDLING_STATE_GIZMO_TRANSLATION | typeof INPUT_HANDLING_STATE_GIZMO_SCALE;
/**
 * Manages input event handling across different states in the Rhodonite engine.
 *
 * This class provides a centralized way to manage input events for different interaction modes
 * such as camera control, gizmo manipulation, etc. It automatically handles adding and removing
 * event listeners based on the current active state, ensuring that only the appropriate
 * input handlers are active at any given time.
 *
 * The InputManager uses a state-based approach where different input handling states
 * (like camera control or gizmo manipulation) can be registered with their respective
 * event handlers. The manager then activates/deactivates these handlers based on the
 * current application state.
 *
 * @example
 * ```typescript
 * // Register input handlers for camera control
 * InputManager.register(INPUT_HANDLING_STATE_CAMERA_CONTROLLER, [
 *   {
 *     eventName: 'mousedown',
 *     handler: onMouseDown,
 *     options: {},
 *     classInstance: cameraController,
 *     eventTargetDom: canvas
 *   }
 * ]);
 *
 * // Activate camera controller
 * InputManager.setActive(INPUT_HANDLING_STATE_CAMERA_CONTROLLER, true);
 * ```
 */
declare class InputManager {
    /** Map storing input handler information for each input handling state */
    private static __inputHandlingStateMap;
    /**
     * This active information is set externally and does not change state internally.
     * Using this externally set active information, this class will add and remove event listeners as appropriate.
     * As a result, event handling for the entire Rhodonite works properly.
     */
    private static __activeMap;
    /** The currently active input handling state */
    private static __currentState;
    /**
     * Registers input handlers for a specific input handling state.
     *
     * This method associates a set of input event handlers with a particular state.
     * When the state becomes active, these handlers will be automatically attached
     * to their respective DOM elements.
     *
     * @param inputHandlingState - The input handling state to register handlers for
     * @param events - Array of input handler information objects
     *
     * @example
     * ```typescript
     * InputManager.register(INPUT_HANDLING_STATE_CAMERA_CONTROLLER, [
     *   {
     *     eventName: 'mousedown',
     *     handler: (e) => console.log('Mouse down'),
     *     options: { passive: false },
     *     classInstance: this,
     *     eventTargetDom: document.getElementById('canvas')
     *   }
     * ]);
     * ```
     */
    static register(inputHandlingState: InputHandlingState, events: InputHandlerInfo[]): void;
    /**
     * Unregisters and deactivates input handlers for a specific input handling state.
     *
     * This method removes all event handlers associated with the specified state
     * and marks the state as inactive. All event listeners will be removed from
     * their respective DOM elements.
     *
     * @param inputHandlingState - The input handling state to unregister
     *
     * @example
     * ```typescript
     * InputManager.unregister(INPUT_HANDLING_STATE_CAMERA_CONTROLLER);
     * ```
     */
    static unregister(inputHandlingState: InputHandlingState): void;
    /**
     * Sets the active state of a specific input handling state.
     *
     * This method controls whether the input handlers for a particular state
     * should be active or inactive. When set to active, the corresponding event
     * listeners will be attached. When set to inactive, they will be removed.
     *
     * Special handling is implemented for gizmo states - activating one gizmo
     * state will automatically deactivate the other to prevent conflicts.
     *
     * @param inputHandlingState - The input handling state to modify
     * @param active - Whether the state should be active (true) or inactive (false)
     *
     * @example
     * ```typescript
     * // Activate camera controller
     * InputManager.setActive(INPUT_HANDLING_STATE_CAMERA_CONTROLLER, true);
     *
     * // Deactivate camera controller
     * InputManager.setActive(INPUT_HANDLING_STATE_CAMERA_CONTROLLER, false);
     * ```
     */
    static setActive(inputHandlingState: InputHandlingState, active: boolean): void;
    /**
     * Adds event listeners for a specific input handling state.
     *
     * This private method attaches all event handlers associated with the given
     * input handling state to their respective DOM elements.
     *
     * @param inputHandlingState - The input handling state to add listeners for
     * @private
     */
    static __addEventListeners(inputHandlingState: InputHandlingState): void;
    /**
     * Removes event listeners for a specific input handling state.
     *
     * This private method detaches all event handlers associated with the given
     * input handling state from their respective DOM elements.
     *
     * @param inputHandlingState - The input handling state to remove listeners for
     * @private
     */
    static __removeEventListeners(inputHandlingState: InputHandlingState): void;
    /**
     * Processes and manages event listeners based on current active states.
     *
     * This private method handles the logic for determining which event listeners
     * should be active based on the current state configuration. It implements
     * priority rules where gizmo interactions take precedence over camera control,
     * and ensures mutual exclusivity between different gizmo modes.
     *
     * The processing order is:
     * 1. Camera controller (base level)
     * 2. Translation gizmo (overrides camera, excludes scale gizmo)
     * 3. Scale gizmo (overrides camera, excludes translation gizmo)
     *
     * @private
     */
    static __processEventListeners(): void;
    /**
     * Enables the camera controller input handling.
     *
     * This is a convenience method that activates the camera controller state
     * and processes the event listeners accordingly. It's equivalent to calling
     * `setActive(INPUT_HANDLING_STATE_CAMERA_CONTROLLER, true)`.
     *
     * @example
     * ```typescript
     * InputManager.enableCameraController();
     * ```
     */
    static enableCameraController(): void;
    /**
     * Disables the camera controller input handling.
     *
     * This is a convenience method that deactivates the camera controller state
     * and processes the event listeners accordingly. It's equivalent to calling
     * `setActive(INPUT_HANDLING_STATE_CAMERA_CONTROLLER, false)`.
     *
     * @example
     * ```typescript
     * InputManager.disableCameraController();
     * ```
     */
    static disableCameraController(): void;
    /**
     * Gets the current active input handling state.
     *
     * @returns The currently active input handling state
     *
     * @example
     * ```typescript
     * const currentState = InputManager.getCurrentState();
     * if (currentState === INPUT_HANDLING_STATE_CAMERA_CONTROLLER) {
     *   console.log('Camera controller is active');
     * }
     * ```
     */
    static getCurrentState(): string;
}

/**
 * A singleton module manager that handles dynamic loading and management of various modules
 * such as WebGL, WebGPU, Effekseer, PBR, and XR modules.
 *
 * This class provides a centralized way to load modules on-demand and retrieve them when needed,
 * helping to optimize bundle size by enabling code splitting.
 */
declare class ModuleManager {
    private static __instance;
    private __modules;
    private constructor();
    /**
     * Dynamically loads a module by name and stores it in the internal module registry.
     * Supports loading WebGL, WebGPU, Effekseer, PBR, and XR modules with code splitting.
     *
     * @param moduleName - The name of the module to load (case-insensitive).
     *                     Supported modules: 'webgl', 'webgpu', 'effekseer', 'pbr', 'xr'
     * @param options - Optional configuration object for module loading
     * @param options.wasm - WASM module URI, currently used only for Effekseer module
     * @returns A promise that resolves to the loaded module
     * @throws Will throw an error if the module fails to load
     *
     * @example
     * ```typescript
     * const moduleManager = ModuleManager.getInstance();
     * const webglModule = await moduleManager.loadModule('webgl');
     * const effekseerModule = await moduleManager.loadModule('effekseer', {
     *   wasm: '/path/to/effekseer.wasm'
     * });
     * ```
     */
    loadModule(moduleName: string, options?: {
        wasm?: string;
    }): Promise<any>;
    /**
     * Retrieves a previously loaded module from the internal registry.
     *
     * @param moduleName - The name of the module to retrieve
     * @returns The loaded module if found, undefined otherwise
     *
     * @example
     * ```typescript
     * const moduleManager = ModuleManager.getInstance();
     * const webglModule = moduleManager.getModule('webgl');
     * if (webglModule) {
     *   // Use the module
     * }
     * ```
     */
    getModule(moduleName: string): any;
    /**
     * Gets the singleton instance of ModuleManager.
     * Creates a new instance if one doesn't exist.
     *
     * @returns The singleton ModuleManager instance
     *
     * @example
     * ```typescript
     * const moduleManager = ModuleManager.getInstance();
     * ```
     */
    static getInstance(): ModuleManager;
}

/**
 * WebXRSystem class manages WebXR session and rendering for virtual reality experiences.
 * This singleton class handles WebXR session lifecycle, camera setup for stereo rendering,
 * input source management, and coordinate space transformations for VR applications.
 *
 * @example
 * ```typescript
 * const webXRSystem = WebXRSystem.getInstance();
 * await webXRSystem.readyForWebXR(requestButton, '/assets/');
 * const controllers = await webXRSystem.enterWebXR({
 *   initialUserPosition: Vector3.fromCopyArray([0, 1.6, 0]),
 *   callbackOnXrSessionStart: () => console.log('VR started'),
 *   callbackOnXrSessionEnd: () => console.log('VR ended'),
 *   profilePriorities: ['oculus-touch', 'generic-trigger']
 * });
 * ```
 */
declare class WebXRSystem {
    private static __instance;
    private __xrSession?;
    private __xrReferenceSpace?;
    private __webglLayer?;
    private __glw?;
    private __xrViewerPose?;
    private __isWebXRMode;
    private __spaceType;
    private __requestedToEnterWebXR;
    private __isReadyForWebXR;
    private __defaultPositionInLocalSpaceMode;
    private __canvasWidthForVR;
    private __canvasHeightForVR;
    private __viewerEntity;
    private __leftCameraEntity;
    private __rightCameraEntity;
    private __basePath?;
    private __controllerEntities;
    private __xrInputSources;
    private __viewerTranslate;
    private __viewerAzimuthAngle;
    private __viewerOrientation;
    private __viewerScale;
    private __multiviewFramebufferHandle;
    private __multiviewColorTextureHandle;
    private __webglStereoUtil?;
    /**
     * Private constructor for singleton pattern.
     * Initializes the viewer entity and left/right camera entities for stereo rendering.
     * Sets up the scene graph hierarchy with cameras as children of the viewer entity.
     */
    private constructor();
    /**
     * Prepares the WebXR system for VR session initialization.
     * Checks for WebXR support, loads required modules, and sets up the entry point.
     *
     * @param requestButtonDom - HTML element to serve as the VR entry button. If null, creates a default button.
     * @param basePath - Base path for loading controller models and assets.
     * @returns Promise that resolves to an empty array on success.
     * @throws {Error} When not running in a browser environment or WebXR is not supported.
     *
     * @example
     * ```typescript
     * const enterButton = document.getElementById('enter-vr-button');
     * await webXRSystem.readyForWebXR(enterButton, '/assets/controllers/');
     * ```
     */
    readyForWebXR(requestButtonDom: HTMLElement, basePath: string): Promise<never[]>;
    /**
     * Initiates a WebXR VR session with specified configuration.
     * Requests an immersive VR session, sets up reference space, WebGL layer, and input handling.
     *
     * @param options - Configuration object for WebXR session.
     * @param options.initialUserPosition - Initial position of the user in world space. Defaults to [0, 1.1, 0].
     * @param options.callbackOnXrSessionStart - Callback function executed when the XR session starts.
     * @param options.callbackOnXrSessionEnd - Callback function executed when the XR session ends.
     * @param options.profilePriorities - Array of controller profile names in priority order for input mapping.
     * @returns Promise that resolves to an array of controller entities, or undefined on failure.
     *
     * @example
     * ```typescript
     * const controllers = await webXRSystem.enterWebXR({
     *   initialUserPosition: Vector3.fromCopyArray([0, 1.6, 2]),
     *   callbackOnXrSessionStart: () => {
     *     console.log('VR session started');
     *     // Initialize VR-specific UI or game logic
     *   },
     *   callbackOnXrSessionEnd: () => {
     *     console.log('VR session ended');
     *     // Clean up VR-specific resources
     *   },
     *   profilePriorities: ['oculus-touch-v2', 'oculus-touch', 'generic-trigger']
     * });
     * ```
     */
    enterWebXR({ initialUserPosition, callbackOnXrSessionStart, callbackOnXrSessionEnd, profilePriorities, }: {
        initialUserPosition?: Vector3;
        callbackOnXrSessionStart: () => void;
        callbackOnXrSessionEnd: () => void;
        profilePriorities: string[];
    }): Promise<IEntity[] | undefined>;
    /**
     * Exits the current WebXR session and returns to normal rendering mode.
     * Gracefully terminates the XR session, triggering cleanup callbacks.
     *
     * @example
     * ```typescript
     * // Exit VR mode when user clicks a button
     * exitButton.addEventListener('click', async () => {
     *   await webXRSystem.exitWebXR();
     * });
     * ```
     */
    exitWebXR(): Promise<void>;
    /**
     * Gets the canvas width configured for VR rendering.
     *
     * @returns The width of the VR canvas in pixels.
     */
    getCanvasWidthForVr(): number;
    /**
     * Gets the canvas height configured for VR rendering.
     *
     * @returns The height of the VR canvas in pixels.
     */
    getCanvasHeightForVr(): number;
    /**
     * Gets all currently tracked controller entities.
     *
     * @returns Array of scene graph entities representing VR controllers.
     */
    getControllerEntities(): ISceneGraphEntity[];
    /**
     * Gets the view matrix for the left eye camera.
     *
     * @returns The view matrix for left eye rendering.
     */
    get leftViewMatrix(): Matrix44;
    /**
     * Gets the view matrix for the right eye camera.
     *
     * @returns The view matrix for right eye rendering.
     */
    get rightViewMatrix(): Matrix44;
    /**
     * Gets the projection matrix for the left eye.
     * Derived from the XR system's view information.
     *
     * @returns The projection matrix for left eye rendering.
     */
    get leftProjectionMatrix(): MutableMatrix44;
    /**
     * Gets the projection matrix for the right eye.
     * Derived from the XR system's view information.
     *
     * @returns The projection matrix for right eye rendering.
     */
    get rightProjectionMatrix(): MutableMatrix44;
    /**
     * Gets the WebXR framebuffer for rendering.
     *
     * @returns The WebGL framebuffer provided by the XR system, or undefined if not available.
     */
    get framebuffer(): WebGLFramebuffer | undefined;
    /**
     * Checks if multiview rendering is supported and enabled.
     *
     * @returns True if multiview VR rendering is supported.
     */
    isMultiView(): boolean;
    /**
     * Checks if a WebXR session has been requested.
     *
     * @returns True if WebXR session entry has been requested.
     */
    get requestedToEnterWebXR(): boolean;
    /**
     * Gets the current XR session object.
     *
     * @returns The active XRSession, or undefined if no session is active.
     */
    get xrSession(): XRSession | undefined;
    /**
     * Legacy property for backward compatibility.
     *
     * @deprecated Use requestedToEnterWebXR instead.
     * @returns True if WebXR session entry has been requested.
     */
    get requestedToEnterWebVR(): boolean;
    /**
     * Checks if currently in WebXR rendering mode.
     *
     * @returns True if WebXR mode is active.
     */
    get isWebXRMode(): boolean;
    /**
     * Sets the WebXR mode state for this system and the WebGL context.
     *
     * @param mode - Whether WebXR mode should be enabled.
     */
    private __setWebXRMode;
    /**
     * Checks if the system is ready to enter WebXR.
     *
     * @returns True if WebXR initialization is complete and ready for session start.
     */
    get isReadyForWebXR(): boolean;
    /**
     * Gets the singleton instance of WebXRSystem.
     * Creates a new instance if one doesn't exist.
     *
     * @returns The singleton WebXRSystem instance.
     */
    static getInstance(): WebXRSystem;
    /**
     * Gets the view matrix for the specified eye.
     *
     * @internal
     * @param index - Eye index (0: left, 1: right).
     * @returns The view matrix for the specified eye.
     */
    _getViewMatrixAt(index: Index): Matrix44;
    /**
     * Gets the projection matrix for the specified eye.
     *
     * @internal
     * @param index - Eye index (0: left, 1: right).
     * @returns The projection matrix for the specified eye.
     */
    _getProjectMatrixAt(index: Index): MutableMatrix44;
    /**
     * Gets the viewport configuration for the specified eye.
     *
     * @internal
     * @param index - Eye index (0: left, 1: right).
     * @returns The viewport vector (x, y, width, height) for the specified eye.
     */
    _getViewportAt(index: Index): Vector4;
    /**
     * Gets the viewport configuration for the left eye.
     *
     * @internal
     * @returns The viewport vector (x, y, width, height) for the left eye.
     */
    _getLeftViewport(): Vector4;
    /**
     * Gets the viewport configuration for the right eye.
     * Accounts for multiview rendering mode differences.
     *
     * @internal
     * @returns The viewport vector (x, y, width, height) for the right eye.
     */
    _getRightViewport(): Vector4;
    /**
     * Updates camera projection matrices and pushes values to the global data repository.
     * Called during the rendering pipeline to ensure cameras have current XR projection data.
     *
     * @internal
     */
    _setValuesToGlobalDataRepository(): void;
    /**
     * Gets the world position of the specified VR camera.
     * Combines XR pose data with user position offset and viewer transformations.
     *
     * @internal
     * @param displayIdx - Eye index (0: left, 1: right).
     * @returns The world position of the VR camera.
     */
    _getCameraWorldPositionAt(displayIdx: Index): Vector3;
    /**
     * Gets the component SID (System ID) for the specified camera.
     *
     * @internal
     * @param index - Eye index (0: left, 1: right).
     * @returns The SID of the CameraComponent for the specified eye.
     */
    _getCameraComponentSIDAt(index: Index): number;
    /**
     * Gets the camera component for the specified eye.
     *
     * @internal
     * @param index - Eye index (0: left, 1: right).
     * @returns The CameraComponent for the specified eye.
     */
    _getCameraComponentAt(index: Index): CameraComponent;
    /**
     * Performs pre-rendering updates for WebXR.
     * Updates view matrices, input sources, and gamepad states.
     * Called once per frame before rendering begins.
     *
     * @internal
     * @param time - Current time in milliseconds.
     * @param xrFrame - The XRFrame object for this rendering frame.
     */
    _preRender(time: number, xrFrame: XRFrame): void;
    /**
     * Resets all viewer transformation parameters to their default values.
     * Useful for resetting user position and orientation to origin.
     */
    resetViewerTransform(): void;
    /**
     * Performs post-rendering cleanup for WebXR.
     * Currently handles multiview framebuffer operations when enabled.
     * Called once per frame after rendering is complete.
     *
     * @internal
     */
    _postRender(): void;
    /**
     * Handles changes in XR input sources (controllers).
     * Creates motion controller entities for newly added input sources.
     *
     * @private
     * @param event - XRInputSourceChangeEvent containing added/removed input sources.
     * @param resolve - Promise resolve function to return controller entities.
     * @param profilePriorities - Array of controller profile names in priority order.
     */
    private __onInputSourcesChange;
    /**
     * Updates camera information from XR viewer pose data.
     * Calculates and applies transformations for left and right eye cameras based on XR pose.
     *
     * @private
     * @param xrViewerPose - The XRViewerPose containing view and transform data.
     */
    private __setCameraInfoFromXRViews;
    /**
     * Sets up the WebGL layer for XR rendering.
     * Makes the WebGL context XR-compatible and configures the XR session's base layer.
     *
     * @private
     * @param xrSession - The XRSession to configure.
     * @param callbackOnXrSessionStart - Callback to execute when setup is complete.
     */
    private __setupWebGLLayer;
    /**
     * Updates the viewer pose from the current XR frame.
     * Retrieves the current viewer pose and updates camera transformations.
     *
     * @private
     * @param xrFrame - The current XRFrame containing pose data.
     */
    private __updateView;
    /**
     * Updates the transforms and states of XR input sources (controllers).
     * Applies XR pose data to controller entities and updates their visual models.
     *
     * @private
     * @param xrFrame - The current XRFrame containing input source pose data.
     */
    private __updateInputSources;
}

/**
 * Sets up and compiles shader programs for the given material and primitive.
 * Handles shader compilation errors by backing up and restoring valid materials.
 * If shader compilation fails, attempts to restore from a backup and retry.
 *
 * @param material - The material requiring shader setup
 * @param primitive - The primitive that will use the material
 * @param webglStrategy - The WebGL strategy for shader compilation
 */
declare function setupShaderProgram(material: Material, primitive: Primitive, webglStrategy: WebGLStrategy): void;

/**
 * Strategy interface for Computer Graphics API implementations.
 * This interface defines the contract for different graphics API backends
 * (such as WebGL, WebGPU, etc.) to handle mesh loading and rendering operations.
 *
 * @interface CGAPIStrategy
 */
interface CGAPIStrategy {
    /**
     * Loads mesh data into the graphics API backend.
     * This method is responsible for uploading vertex data, indices, and other
     * mesh-related resources to the GPU memory.
     *
     * @param meshComponent - The mesh component containing the geometry data to be loaded
     * @returns True if the mesh was successfully loaded, false otherwise
     */
    $load(meshComponent: MeshComponent): boolean;
    /**
     * Performs pre-rendering setup operations.
     * This method is called before the main rendering loop and is used to
     * set up render states, clear buffers, or perform other preparatory tasks
     * required by the specific graphics API implementation.
     */
    prerender(): void;
    /**
     * Executes the common rendering operations for a set of primitives.
     * This method handles the core rendering logic that is shared across
     * different render passes and primitive types.
     *
     * @param primitiveUids - Array of unique identifiers for the primitives to be rendered
     * @param renderPass - The render pass context containing rendering configuration
     * @param renderPassTickCount - The current tick count for the render pass, used for timing and animation
     * @returns True if the rendering operation was successful, false otherwise
     */
    common_$render(primitiveUids: PrimitiveUID[], renderPass: RenderPass, renderPassTickCount: Count): boolean;
}

/**
 * WebGL rendering strategy implementation that uses data textures for storing shader data.
 * This strategy stores uniform data in textures rather than traditional uniform variables,
 * enabling support for larger amounts of instance data and more efficient batch rendering.
 *
 * @remarks
 * This class implements both CGAPIStrategy and WebGLStrategy interfaces, providing
 * a complete rendering pipeline for WebGL with data texture optimization.
 * The strategy is particularly useful for rendering many instances with unique properties.
 */
declare class WebGLStrategyDataTexture implements CGAPIStrategy, WebGLStrategy {
    private static __instance;
    private __webglResourceRepository;
    private __dataTextureUid;
    private __dataUBOUid;
    private __lastShader;
    private __lastMaterial?;
    private __lastMaterialStateVersion;
    private static __shaderProgram;
    private __lastRenderPassTickCount;
    private __lightComponents?;
    private static __globalDataRepository;
    private static __currentComponentSIDs?;
    _totalSizeOfGPUShaderDataStorageExceptMorphData: number;
    private static __isDebugOperationToDataTextureBufferDone;
    private static __webxrSystem;
    private __lastMaterialsUpdateCount;
    private __lastTransformComponentsUpdateCount;
    private __lastSceneGraphComponentsUpdateCount;
    private __lastCameraComponentsUpdateCount;
    private __lastCameraControllerComponentsUpdateCount;
    /**
     * Private constructor to enforce singleton pattern.
     */
    private constructor();
    /**
     * Initiates the dumping of the data texture buffer for debugging purposes.
     * This method flags the system to export the data texture buffer contents
     * on the next rendering cycle.
     *
     * @remarks
     * The dumped buffer will be downloaded as a binary file named 'Rhodonite_dataTextureBuffer.bin'.
     * This is useful for debugging shader data layout and content issues.
     */
    static dumpDataTextureBuffer(): void;
    /**
     * Generates vertex shader method definitions for data texture access.
     * These methods provide standardized ways to fetch transformation matrices,
     * visibility flags, and other per-instance data from the data texture.
     *
     * @returns A string containing GLSL shader method definitions for data texture access
     *
     * @remarks
     * The generated methods include:
     * - get_worldMatrix: Fetches world transformation matrix
     * - get_normalMatrix: Fetches normal transformation matrix
     * - get_isVisible: Fetches visibility flag
     * - get_isBillboard: Fetches billboard flag
     * - get_position: Fetches morphed vertex positions (if morphing is enabled)
     */
    static getVertexShaderMethodDefinitions_dataTexture(): string;
    /**
     * Sets up a shader program for the specified material and primitive.
     * This method creates and configures the complete shader program including
     * uniform locations and data texture-specific shader definitions.
     *
     * @param material - The material that requires shader setup
     * @param primitive - The primitive geometry that will use this shader
     * @returns The resource handle of the created or retrieved shader program
     *
     * @remarks
     * This method handles:
     * - Creating the WebGL shader program with data texture method definitions
     * - Setting up basic uniform locations for the material
     * - Configuring material node uniform locations
     * - Setting up additional uniform locations for point sprites
     * - Configuring data texture-specific uniform locations
     */
    setupShaderForMaterial(material: Material, primitive: Primitive): CGAPIResourceHandle;
    /**
     * Re-establishes a shader program for a material using updated shader sources.
     * This method is typically called by debugging tools like Spector.js when
     * shader sources are modified at runtime for inspection or debugging.
     *
     * @param material - The material whose shader needs to be re-setup
     * @param primitive - The primitive geometry associated with the shader
     * @param updatedShaderSources - The modified shader source code
     * @param onError - Callback function to handle compilation or linking errors
     * @returns The resource handle of the updated shader program, or InvalidCGAPIResourceUid on failure
     *
     * @remarks
     * This method performs the same setup as setupShaderForMaterial but uses
     * externally provided shader sources instead of generating them. It's primarily
     * used for debugging workflows where shaders are modified at runtime.
     */
    _reSetupShaderForMaterialBySpector(material: Material, primitive: Primitive, updatedShaderSources: ShaderSources, onError: (message: string) => void): CGAPIResourceHandle;
    /**
     * Generates GLSL shader code for accessing material and global properties.
     * This method creates shader functions that can fetch data from either data textures
     * or uniform variables, depending on the property type and rendering configuration.
     *
     * @param materialTypeName - The name of the material type
     * @param info - Detailed information about the shader semantic property
     * @param isGlobalData - Whether this property is global data or material-specific
     * @param isWebGL2 - Whether the target context is WebGL 2.0
     * @returns GLSL shader code string for the property accessor function
     *
     * @remarks
     * This method handles different data types including:
     * - Scalars, vectors, and matrices of various sizes
     * - Array types with proper indexing
     * - Texture samplers
     * - Properties that require explicit uniform variables
     * The generated code optimizes data access based on the property layout in data textures.
     */
    private static __getShaderProperty;
    /**
     * Retrieves the offset position of a property within the shader data layout.
     * This method calculates where a specific property is located in either the
     * global data repository or material-specific data storage.
     *
     * @param isGlobalData - Whether to look in global data or material-specific data
     * @param propertyName - The semantic name of the property to locate
     * @param materialTypeName - The name of the material type (used for material-specific properties)
     * @returns The offset position of the property in the data layout, or -1 if not found
     *
     * @remarks
     * This method is essential for generating correct shader code that can access
     * properties from the data texture at the right memory locations.
     */
    private static getOffsetOfPropertyInShader;
    /**
     * Loads and prepares a mesh component for rendering with the data texture strategy.
     * This method validates the mesh, updates current component SIDs, and ensures
     * the mesh's VBO and VAO are properly set up.
     *
     * @param meshComponent - The mesh component to load and prepare for rendering
     * @returns true if the mesh was successfully loaded, false if there was an error
     *
     * @remarks
     * This method performs several important tasks:
     * - Validates that the mesh component has a valid mesh
     * - Updates the current component SIDs for data texture access
     * - Triggers VBO/VAO setup if the mesh hasn't been set up yet
     * - Deletes and recreates the data texture if needed for mesh updates
     */
    $load(meshComponent: MeshComponent): boolean;
    /**
     * Creates and updates the data texture with current shader data.
     * This is the main entry point for data texture management that handles
     * the complete update process.
     *
     * @remarks
     * This method delegates to __createAndUpdateDataTextureInner with no size limit,
     * ensuring the entire GPU instance data buffer is copied to the data texture.
     */
    private __createAndUpdateDataTexture;
    /**
     * Creates and updates only the camera-related portion of the data texture.
     * This optimized method updates only the camera information part of the data texture,
     * which is useful when only camera data has changed.
     *
     * @remarks
     * This method calculates the position where bone matrix data begins and only
     * updates the data texture up to that point, covering camera-related information.
     * This provides better performance when only camera properties need updating.
     */
    private __createAndUpdateDataTextureForCameraOnly;
    /**
     * Internal implementation for creating and updating the data texture.
     * This method handles the actual texture creation, data copying, and GPU upload.
     *
     * @param _copySizeInByte - Optional limit on how many bytes to copy from the GPU instance data buffer
     *
     * @remarks
     * This method performs several critical operations:
     * - Retrieves the GPU instance data buffer from memory manager
     * - Calculates appropriate texture size based on available data
     * - Handles both texture creation (first time) and texture updates (subsequent calls)
     * - Combines GPU instance data with morph target data for complete texture
     * - Provides debug functionality to dump texture contents
     * - Manages texture alignment and padding requirements
     */
    private __createAndUpdateDataTextureInner;
    /**
     * Deletes the current data texture and frees associated GPU resources.
     * This method should be called when the data texture needs to be recreated
     * or when cleaning up resources.
     *
     * @remarks
     * After calling this method, the data texture UID is reset to an invalid state,
     * and a new data texture will be created on the next rendering cycle.
     */
    deleteDataTexture(): void;
    /**
     * Prepares the rendering pipeline before actual rendering begins.
     * This method updates GPU storage (data texture and UBO) based on component
     * update states and manages light components for the current frame.
     *
     * @remarks
     * This method performs conditional updates based on what has changed:
     * - Full update: When animation, transforms, scene graph, or materials change
     * - Camera-only update: When only camera or camera controller data changes
     * - Also retrieves current light components for the rendering pass
     *
     * The method tracks update counts to avoid unnecessary GPU uploads and
     * provides optimal performance by updating only what has changed.
     */
    prerender(): void;
    /**
     * Determines whether Uniform Buffer Objects (UBO) should be used for data storage.
     * UBOs are only used when both WebGL 2.0 is available and UBO usage is enabled in configuration.
     *
     * @returns true if UBOs should be used, false otherwise
     *
     * @remarks
     * UBOs provide more efficient uniform data transfer for WebGL 2.0 contexts
     * and can store larger amounts of uniform data compared to individual uniforms.
     */
    private __isUboUse;
    /**
     * Creates and updates the Uniform Buffer Object (UBO) with current shader data.
     * This method is only active when UBO usage is enabled and WebGL 2.0 is available.
     *
     * @remarks
     * The UBO stores the same data as the data texture but in a different format
     * optimized for uniform buffer access. This method handles:
     * - Initial UBO creation with proper size allocation
     * - Updating existing UBO with new data from GPU instance buffer
     * - Respecting alignment requirements for uniform buffer layouts
     */
    private __createAndUpdateUBO;
    /**
     * Attaches GPU data for a primitive (placeholder implementation).
     * This method is part of the CGAPIStrategy interface but is not used
     * in the data texture strategy since data is handled through textures.
     *
     * @param primitive - The primitive to attach GPU data for
     */
    attachGPUData(_primitive: Primitive): void;
    /**
     * Internal GPU data attachment (placeholder implementation).
     * This method is part of the interface but not actively used in data texture strategy.
     *
     * @param gl - The WebGL rendering context
     * @param shaderProgram - The shader program to attach data to
     */
    attachGPUDataInner(_gl: WebGLRenderingContext, _shaderProgram: WebGLProgram): void;
    /**
     * Attaches vertex data for a primitive (placeholder implementation).
     * This method is part of the interface but delegates to attachVertexDataInner.
     *
     * @param i - Index parameter (unused in this implementation)
     * @param primitive - The primitive to attach vertex data for
     * @param glw - The WebGL context wrapper
     * @param instanceIDBufferUid - The instance ID buffer resource handle
     */
    attachVertexData(_i: number, _primitive: Primitive, _glw: WebGLContextWrapper, _instanceIDBufferUid: WebGLResourceHandle): void;
    /**
     * Internal implementation for attaching vertex data to the rendering pipeline.
     * This method binds the appropriate Vertex Array Object (VAO) or sets up
     * vertex attribute pointers and element buffer bindings.
     *
     * @param mesh - The mesh containing the vertex data
     * @param primitive - The specific primitive within the mesh
     * @param primitiveIndex - Index of the primitive within the mesh
     * @param glw - The WebGL context wrapper for WebGL operations
     * @param instanceIDBufferUid - Resource handle for instance ID buffer
     *
     * @remarks
     * This method handles two scenarios:
     * - If a VAO exists, it simply binds the VAO (most efficient)
     * - If no VAO exists, it manually sets up vertex attributes and index buffer
     */
    attachVertexDataInner(mesh: Mesh, primitive: Primitive, primitiveIndex: Index, glw: WebGLContextWrapper, _instanceIDBufferUid: WebGLResourceHandle): void;
    /**
     * Gets the singleton instance of WebGLStrategyDataTexture.
     * Creates the instance if it doesn't exist and initializes the WebXR system reference.
     *
     * @returns The singleton instance of WebGLStrategyDataTexture
     *
     * @remarks
     * This method ensures only one instance of the strategy exists throughout the application
     * and properly initializes the WebXR system for VR/AR rendering capabilities.
     */
    static getInstance(): WebGLStrategyDataTexture;
    /**
     * Sets the current component SIDs for each display index in VR/non-VR rendering.
     * This method configures camera component SIDs based on the rendering mode
     * and display configuration.
     *
     * @param renderPass - The current render pass being processed
     * @param displayIdx - The display index (0 or 1 for stereo rendering)
     * @param isVRMainPass - Whether this is a VR main rendering pass
     *
     * @remarks
     * For VR rendering:
     * - Uses WebXR system to get appropriate camera component SID
     * - Handles both multiview and separate eye rendering
     * For non-VR rendering:
     * - Uses the render pass camera or falls back to current camera
     * - Sets camera component SID to -1 if no camera is available
     */
    private __setCurrentComponentSIDsForEachDisplayIdx;
    /**
     * Sets the current component SIDs for each primitive being rendered.
     * This method updates the global component SID array with material-specific information.
     *
     * @param gl - The WebGL rendering context
     * @param material - The material being used for rendering
     * @param shaderProgram - The active shader program
     *
     * @remarks
     * This method ensures the shader has access to the correct material SID
     * and initializes the component SID array if it hasn't been set up yet.
     * The material SID is stored at index 0 of the component SID array.
     */
    private __setCurrentComponentSIDsForEachPrimitive;
    /**
     * Main rendering method that processes all primitives in a render pass.
     * This method handles different primitive types (opaque, translucent, blend)
     * and manages VR/non-VR rendering modes.
     *
     * @param primitiveUids - Array of primitive UIDs to render
     * @param renderPass - The render pass configuration
     * @param renderPassTickCount - Current tick count for the render pass
     * @returns true if any primitives were successfully rendered, false otherwise
     *
     * @remarks
     * This method processes primitives in the following order:
     * 1. Opaque primitives (back-to-front for depth optimization)
     * 2. Translucent primitives (front-to-back for proper blending)
     * 3. Blend primitives with Z-write enabled
     * 4. Blend primitives without Z-write
     *
     * The method also handles buffer-less rendering mode for special cases
     * and manages depth mask settings for different primitive types.
     */
    common_$render(primitiveUids: PrimitiveUID[], renderPass: RenderPass, renderPassTickCount: Count): boolean;
    /**
     * Renders primitives without using vertex/index buffers.
     * This specialized rendering mode is used for certain types of procedural
     * or shader-generated geometry.
     *
     * @param gl - The WebGL 2.0 rendering context
     * @param renderPass - The render pass configuration
     * @param isVRMainPass - Whether this is a VR main rendering pass
     *
     * @remarks
     * This method handles buffer-less rendering by:
     * - Setting up the shader program and data texture binding
     * - Configuring component SIDs and VR state
     * - Setting material parameters directly
     * - Using drawArrays with the specified primitive mode and vertex count
     */
    private __renderWithoutBuffers;
    /**
     * Internal rendering implementation for individual primitives.
     * This method handles the complete rendering pipeline for a single primitive,
     * including shader setup, material configuration, and draw calls.
     *
     * @param primitiveUid - Unique identifier of the primitive to render
     * @param glw - The WebGL context wrapper
     * @param renderPass - The current render pass configuration
     * @param isVRMainPass - Whether this is a VR main rendering pass
     * @param displayCount - Number of displays to render to (1 for normal, 2 for stereo VR)
     * @returns true if the primitive was successfully rendered, false otherwise
     *
     * @remarks
     * This method performs the following operations:
     * - Validates the primitive and retrieves associated mesh and material
     * - Sets up shader program if needed (with caching for performance)
     * - Configures vertex data and VAO/VBO bindings
     * - Sets material parameters and uniforms
     * - Handles per-display rendering for VR stereo
     * - Executes draw calls (instanced rendering for multiple mesh entities)
     *
     * The method optimizes performance by caching shader programs and materials
     * between draw calls and only updating GPU state when necessary.
     */
    private __renderInner;
    /**
     * Binds the data texture to the WebGL context for shader access.
     * This method sets up the texture binding and sampler configuration
     * that allows shaders to access the data texture.
     *
     * @param gl - The WebGL rendering context
     * @param shaderProgram - The shader program that will access the data texture
     *
     * @remarks
     * This method performs the following operations:
     * - Sets the data texture uniform to texture unit 7
     * - Binds the data texture to texture unit 7
     * - Creates and binds a repeat/nearest sampler for optimal data texture access
     *
     * Texture unit 7 is used as a dedicated slot for data texture access
     * to avoid conflicts with regular material textures.
     */
    private bindDataTexture;
}

/**
 * WebGL rendering strategy implementation using uniform-based approach.
 * This strategy uses uniforms to pass per-object data to shaders instead of vertex attributes,
 * which is more suitable for rendering multiple objects with different properties.
 *
 * @implements {CGAPIStrategy}
 * @implements {WebGLStrategy}
 */
declare class WebGLStrategyUniform implements CGAPIStrategy, WebGLStrategy {
    private static __instance;
    private __webglResourceRepository;
    private __dataTextureUid;
    private __lastShader;
    private __lastMaterial?;
    private __lastRenderPassTickCount;
    private __lightComponents?;
    private static __globalDataRepository;
    private static __webxrSystem;
    /**
     * Shader semantics information for component matrices used in uniform rendering strategy.
     * Defines world matrix, normal matrix, billboard flag, and vertex attributes existence array.
     */
    private static readonly componentMatrices;
    /**
     * Private constructor to enforce singleton pattern.
     */
    private constructor();
    /**
     * Vertex shader method definitions for uniform-based rendering.
     * Provides GLSL functions for accessing world matrix, normal matrix, visibility,
     * billboard state, and morphing functionality through uniforms.
     */
    private static __vertexShaderMethodDefinitions_uniform;
    /**
     * Sets up shader program for the given material and primitive in this WebGL strategy.
     * Creates a new shader program if needed and configures uniform locations for rendering.
     *
     * @param material - The material to setup shader program for
     * @param primitive - The primitive geometry to associate with the shader
     * @returns The CGAPIResourceHandle of the created or existing shader program
     */
    setupShaderForMaterial(material: Material, primitive: Primitive): CGAPIResourceHandle;
    /**
     * Re-sets up shader program for the material using updated shader sources from Spector.js.
     * This method is specifically designed for shader debugging and live editing scenarios.
     *
     * @param material - The material to re-setup shader program for
     * @param primitive - The primitive geometry associated with the shader
     * @param updatedShaderSources - The updated shader source code
     * @param onError - Callback function to handle compilation errors
     * @returns The CGAPIResourceHandle of the updated shader program, or InvalidCGAPIResourceUid on failure
     */
    _reSetupShaderForMaterialBySpector(material: Material, primitive: Primitive, updatedShaderSources: ShaderSources, onError: (message: string) => void): CGAPIResourceHandle;
    /**
     * Loads and prepares mesh data for rendering.
     * Sets up VBO (Vertex Buffer Object) and VAO (Vertex Array Object) if not already done.
     *
     * @param meshComponent - The mesh component containing the mesh to load
     * @returns True if the mesh was loaded successfully, false otherwise
     */
    $load(meshComponent: MeshComponent): boolean;
    /**
     * Performs pre-rendering setup operations.
     * Initializes light components, sets up data texture for GPU vertex data,
     * and prepares global rendering state.
     */
    prerender(): void;
    /**
     * Attaches GPU data for the primitive.
     * This method is part of the CGAPIStrategy interface but is a no-op in uniform strategy
     * as GPU data is handled differently through data textures.
     *
     * @param primitive - The primitive to attach GPU data for
     */
    attachGPUData(_primitive: Primitive): void;
    /**
     * Attaches vertex data for rendering.
     * This method is part of the CGAPIStrategy interface but is a no-op in uniform strategy
     * as vertex data attachment is handled in attachVertexDataInner.
     *
     * @param i - Index parameter (unused in uniform strategy)
     * @param primitive - The primitive containing vertex data
     * @param glw - WebGL context wrapper
     * @param instanceIDBufferUid - Instance ID buffer handle (unused in uniform strategy)
     */
    attachVertexData(_i: number, _primitive: Primitive, _glw: WebGLContextWrapper, _instanceIDBufferUid: WebGLResourceHandle): void;
    /**
     * Internal method to attach vertex data for a specific mesh and primitive.
     * Binds the appropriate VAO or sets up vertex data pipeline for rendering.
     *
     * @param mesh - The mesh containing vertex data
     * @param primitive - The primitive geometry to render
     * @param primitiveUid - Unique identifier for the primitive
     * @param glw - WebGL context wrapper
     * @param instanceIDBufferUid - Instance ID buffer handle (unused in uniform strategy)
     */
    attachVertexDataInner(mesh: Mesh, primitive: Primitive, primitiveUid: Index, glw: WebGLContextWrapper, instanceIDBufferUid: WebGLResourceHandle): void;
    /**
     * Detaches vertex data and cleans up OpenGL state after rendering.
     * Unbinds VAO, element array buffer, and array buffer to prevent state leakage.
     *
     * @param glw - WebGL context wrapper used for state cleanup
     */
    dettachVertexData(glw: WebGLContextWrapper): void;
    /**
     * Gets the singleton instance of WebGLStrategyUniform.
     * Initializes the instance and WebXR system if not already created.
     *
     * @returns The singleton instance of WebGLStrategyUniform
     */
    static getInstance(): WebGLStrategyUniform;
    /**
     * Common rendering method that handles the main rendering pipeline.
     * Processes primitives in different rendering phases: opaque, translucent, blend with/without Z-write.
     * Supports buffer-less rendering mode for special cases like post-processing effects.
     *
     * @param primitiveUids - Array of primitive UIDs to render, sorted by rendering order
     * @param renderPass - The render pass configuration containing rendering settings
     * @param renderPassTickCount - Current tick count for the render pass
     * @returns True if any primitives were rendered, false otherwise
     */
    common_$render(primitiveUids: PrimitiveUID[], renderPass: RenderPass, renderPassTickCount: Count): boolean;
    /**
     * Renders primitives without using vertex/index buffers.
     * Used for buffer-less rendering scenarios such as full-screen post-processing effects.
     *
     * @param gl - WebGL2 rendering context
     * @param renderPass - The render pass containing material and rendering configuration
     */
    private __renderWithoutBuffers;
    /**
     * Internal rendering method for processing individual primitives.
     * Handles shader setup, material parameters, lighting, VR rendering, and draw calls
     * for each mesh entity associated with the primitive.
     *
     * @param primitiveUid - Unique identifier of the primitive to render
     * @param glw - WebGL context wrapper
     * @param renderPass - The render pass configuration
     * @param renderPassTickCount - Current tick count for the render pass
     * @returns True if the primitive was rendered successfully, false otherwise
     */
    renderInner(primitiveUid: PrimitiveUID, glw: WebGLContextWrapper, renderPass: RenderPass, _renderPassTickCount: Count): boolean;
    /**
     * Binds the data texture containing vertex data to the shader program.
     * The data texture is used to store and access vertex data in uniform rendering strategy.
     *
     * @param gl - WebGL rendering context
     * @param shaderProgram - The shader program to bind the texture to
     */
    private bindDataTexture;
}

/**
 * A shader part that generates the beginning block of a shader function.
 * This class creates GLSL function definitions with input and output parameters
 * based on the provided shader sockets.
 */
declare class BlockBeginShader extends CommonShaderPart {
    private __functionName;
    private __valueInputs;
    private __valueOutputs;
    /**
     * Creates a new BlockBeginShader instance.
     *
     * @param __functionName - The name of the GLSL function to generate
     * @param __valueInputs - Array of input shader sockets that define function parameters
     * @param __valueOutputs - Array of output shader sockets that define function output parameters
     */
    constructor(__functionName: string, __valueInputs: ShaderSocket[], __valueOutputs: ShaderSocket[]);
    /**
     * Generates the vertex shader function definition.
     * Creates a GLSL function with the specified name, input parameters, and output parameters.
     * The function body assigns input values to corresponding output values.
     *
     * @returns The GLSL function definition string for vertex shader
     */
    get vertexShaderDefinitions(): string;
    /**
     * Generates the pixel shader function definition.
     * Returns the same definition as vertex shader since the function structure is identical.
     *
     * @returns The GLSL function definition string for pixel shader
     */
    get pixelShaderDefinitions(): string;
    /**
     * Gets the attribute names required by this shader part.
     * This shader part doesn't require any specific vertex attributes.
     *
     * @returns An empty array as no attributes are needed
     */
    get attributeNames(): AttributeNames;
    /**
     * Gets the vertex attribute semantics required by this shader part.
     * This shader part doesn't require any specific vertex attribute semantics.
     *
     * @returns An empty array as no attribute semantics are needed
     */
    get attributeSemantics(): Array<VertexAttributeEnum>;
    /**
     * Gets the composition types for vertex attributes required by this shader part.
     * This shader part doesn't require any specific attribute compositions.
     *
     * @returns An empty array as no attribute compositions are needed
     */
    get attributeCompositions(): Array<CompositionTypeEnum>;
}

/**
 * A shader component that generates the ending block of a shader function.
 * This class creates GLSL function definitions that pass input values directly to output values,
 * effectively acting as a pass-through block in shader node graphs.
 */
declare class BlockEndShader extends CommonShaderPart {
    private __functionName;
    private __valueInputs;
    private __valueOutputs;
    /**
     * Creates a new BlockEndShader instance.
     *
     * @param __functionName - The name of the GLSL function to generate
     * @param __valueInputs - Array of input shader sockets that define the function parameters
     * @param __valueOutputs - Array of output shader sockets that define the function return values
     */
    constructor(__functionName: string, __valueInputs: ShaderSocket[], __valueOutputs: ShaderSocket[]);
    /**
     * Generates the vertex shader function definition.
     * Creates a GLSL function that takes input parameters and assigns them directly to output parameters.
     *
     * @returns The GLSL function definition string for vertex shaders
     */
    get vertexShaderDefinitions(): string;
    /**
     * Generates the pixel shader function definition.
     * Returns the same definition as the vertex shader since the logic is identical.
     *
     * @returns The GLSL function definition string for pixel shaders
     */
    get pixelShaderDefinitions(): string;
    /**
     * Gets the attribute names required by this shader component.
     * This block end shader doesn't require any specific vertex attributes.
     *
     * @returns An empty array as no attributes are needed
     */
    get attributeNames(): AttributeNames;
    /**
     * Gets the vertex attribute semantics required by this shader component.
     * This block end shader doesn't require any specific vertex attribute semantics.
     *
     * @returns An empty array as no attribute semantics are needed
     */
    get attributeSemantics(): Array<VertexAttributeEnum>;
    /**
     * Gets the composition types for vertex attributes required by this shader component.
     * This block end shader doesn't require any specific attribute compositions.
     *
     * @returns An empty array as no attribute compositions are needed
     */
    get attributeCompositions(): Array<CompositionTypeEnum>;
}

/**
 * A shader part that implements classic shading models including Lambert, Blinn-Phong, and Phong shading.
 * This class provides GLSL shader code for traditional lighting calculations with support for multiple light types
 * (directional, point, and spot lights) and different shading models.
 *
 * The shader supports:
 * - Lambert diffuse shading
 * - Blinn-Phong specular shading
 * - Phong specular shading
 * - Multiple light sources with configurable intensity and direction
 * - Point lights, directional lights, and spot lights
 *
 * @extends CommonShaderPart
 */
declare class ClassicShadingShader extends CommonShaderPart {
    static __instance: ClassicShadingShader;
    /** The material element type associated with this shader */
    static readonly materialElement: EnumIO;
    /**
     * Private constructor to enforce singleton pattern.
     * Use getInstance() to get the instance of this class.
     */
    private constructor();
    /**
     * Gets the singleton instance of ClassicShadingShader.
     * Creates a new instance if one doesn't exist.
     *
     * @returns The singleton instance of ClassicShadingShader
     */
    static getInstance(): ClassicShadingShader;
    /**
     * Gets the vertex shader definitions.
     * Currently returns an empty string as classic shading calculations are performed in the fragment shader.
     *
     * @returns Empty string for vertex shader definitions
     */
    get vertexShaderDefinitions(): string;
    /**
     * Gets the pixel (fragment) shader definitions including uniforms, structs, and the main shading function.
     * Defines the classic shading function that supports multiple lighting models:
     * - Model 0: No shading (returns diffuse color as-is)
     * - Model 1: Lambert diffuse only
     * - Model 2: Blinn-Phong (diffuse + specular using half-vector)
     * - Model 3: Phong (diffuse + specular using reflection vector)
     *
     * @returns GLSL code string containing shader definitions and the classicShading function
     */
    get pixelShaderDefinitions(): string;
    /**
     * Gets the vertex shader body code.
     * Currently returns an empty string as classic shading is performed in the fragment shader.
     *
     * @returns Empty string for vertex shader body
     */
    vertexShaderBody: string;
    /**
     * Gets the pixel (fragment) shader body code.
     * Currently returns an empty string as the main shading logic is defined in pixelShaderDefinitions.
     *
     * @returns Empty string for pixel shader body
     */
    get pixelShaderBody(): string;
    /**
     * Gets the attribute names required by this shader.
     * Classic shading doesn't require additional vertex attributes beyond the standard ones.
     *
     * @returns Empty array as no additional attributes are needed
     */
    get attributeNames(): AttributeNames;
    /**
     * Gets the vertex attribute semantics required by this shader.
     * Classic shading doesn't require additional vertex attribute semantics.
     *
     * @returns Empty array as no additional attribute semantics are needed
     */
    get attributeSemantics(): Array<VertexAttributeEnum>;
    /**
     * Gets the composition types for vertex attributes required by this shader.
     * Classic shading doesn't require additional vertex attribute compositions.
     *
     * @returns Empty array as no additional attribute compositions are needed
     */
    get attributeCompositions(): Array<CompositionTypeEnum>;
}

/**
 * A shader part that generates constant variable functions for both vertex and pixel shaders.
 * This class creates GLSL/WGSL functions that output constant values of specified composition and component types.
 *
 * @example
 * ```typescript
 * const constantShader = new ConstantVariableShader(
 *   'getConstantColor',
 *   CompositionType.Vec3,
 *   ComponentType.Float
 * );
 * constantShader.setConstantValue(Vector3.fromCopyArray([1.0, 0.5, 0.0]));
 * ```
 */
declare class ConstantVariableShader extends CommonShaderPart {
    private __functionName;
    private __compositionType;
    private __componentType;
    private __constantValueStr;
    /**
     * Creates a new ConstantVariableShader instance.
     *
     * @param __functionName - The name of the generated shader function
     * @param __compositionType - The composition type (scalar, vec2, vec3, vec4, etc.) of the constant
     * @param __componentType - The component type (float, int, bool) of the constant
     */
    constructor(__functionName: string, __compositionType: CompositionTypeEnum, __componentType: ComponentTypeEnum);
    /**
     * Sets the constant value that will be output by the generated shader function.
     * The value is converted to the appropriate GLSL/WGSL string representation based on the component type.
     *
     * @param value - The vector value to be used as the constant. The number of components used
     *                depends on the composition type specified in the constructor.
     *
     * @example
     * ```typescript
     * // For a Vec3 float constant
     * shader.setConstantValue(Vector3.fromCopyArray([1.0, 0.5, 0.0]));
     *
     * // For a scalar int constant
     * shader.setConstantValue(Scalar.fromCopyNumber(42));
     *
     * // For a boolean constant
     * shader.setConstantValue(Scalar.fromCopyNumber(1)); // true
     * ```
     */
    setConstantValue(value: IVector): void;
    /**
     * Generates the vertex shader function definition that outputs the constant value.
     * The generated function takes an output parameter and assigns the constant value to it.
     *
     * @returns The GLSL or WGSL function definition string for the vertex shader,
     *          depending on the current process approach (WebGL or WebGPU).
     *
     * @example
     * Generated GLSL:
     * ```glsl
     * void getConstantColor(out vec3 outValue) {
     *   outValue = vec3(1.0, 0.5, 0.0);
     * }
     * ```
     *
     * Generated WGSL:
     * ```wgsl
     * fn getConstantColor(outValue: ptr<function, vec3<f32>>) {
     *   *outValue = vec3<f32>(1.0, 0.5, 0.0);
     * }
     * ```
     */
    get vertexShaderDefinitions(): string;
    /**
     * Generates the pixel shader function definition that outputs the constant value.
     * This is identical to the vertex shader definition as constant values are the same
     * regardless of shader stage.
     *
     * @returns The GLSL or WGSL function definition string for the pixel shader,
     *          depending on the current process approach (WebGL or WebGPU).
     *
     * @example
     * Generated GLSL:
     * ```glsl
     * void getConstantColor(out vec3 outValue) {
     *   outValue = vec3(1.0, 0.5, 0.0);
     * }
     * ```
     *
     * Generated WGSL:
     * ```wgsl
     * fn getConstantColor(outValue: ptr<function, vec3<f32>>) {
     *   *outValue = vec3<f32>(1.0, 0.5, 0.0);
     * }
     * ```
     */
    get pixelShaderDefinitions(): string;
    /**
     * Returns the attribute names required by this shader part.
     * Since this is a constant variable shader that doesn't use any vertex attributes,
     * it returns an empty array.
     *
     * @returns An empty array as no vertex attributes are needed for constant values.
     */
    get attributeNames(): AttributeNames;
    /**
     * Returns the vertex attribute semantics required by this shader part.
     * Since this is a constant variable shader that doesn't use any vertex attributes,
     * it returns an empty array.
     *
     * @returns An empty array as no vertex attribute semantics are needed for constant values.
     */
    get attributeSemantics(): Array<VertexAttributeEnum>;
    /**
     * Returns the attribute compositions required by this shader part.
     * Since this is a constant variable shader that doesn't use any vertex attributes,
     * it returns an empty array.
     *
     * @returns An empty array as no attribute compositions are needed for constant values.
     */
    get attributeCompositions(): Array<CompositionTypeEnum>;
}

/**
 * EndShader class provides the final output functions for both vertex and fragment shaders.
 * This class handles the final position output in vertex shaders and color output in fragment shaders,
 * supporting both WebGL and WebGPU rendering approaches.
 *
 * @extends CommonShaderPart
 */
declare class EndShader extends CommonShaderPart {
    static __instance: EndShader;
    static readonly materialElement: EnumIO;
    /**
     * Private constructor to enforce singleton pattern.
     */
    private constructor();
    /**
     * Gets the singleton instance of EndShader.
     * Creates a new instance if one doesn't exist.
     *
     * @returns The singleton EndShader instance
     */
    static getInstance(): EndShader;
    /**
     * Gets the vertex shader function definitions for position output.
     * Returns appropriate function definition based on the current process approach (WebGL/WebGPU).
     *
     * @returns Shader code string containing the outPosition function definition
     */
    get vertexShaderDefinitions(): "\n      fn outPosition(inPosition: vec4<f32>) {\n        output.position = inPosition;\n      }\n      " | "\n      void outPosition(in vec4 inPosition) {\n        gl_Position = inPosition;\n      }\n      ";
    /**
     * Gets the vertex shader body code.
     * Currently returns empty string as no additional vertex processing is needed.
     *
     * @returns Empty shader body string
     */
    get vertexShaderBody(): string;
    /**
     * Gets the pixel/fragment shader function definitions for color output.
     * Returns appropriate function definition based on the current process approach (WebGL/WebGPU).
     *
     * @returns Shader code string containing the outColor function definition
     */
    get pixelShaderDefinitions(): "\n      fn outColor(inColor: vec4<f32>) {\n        rt0 = inColor;\n      }\n      " | "\n      void outColor(in vec4 inColor) {\n        rt0 = inColor;\n      }\n      ";
    /**
     * Gets the pixel/fragment shader body code.
     * Currently returns empty string as no additional fragment processing is needed.
     *
     * @returns Empty shader body string
     */
    getPixelShaderBody(): string;
    /**
     * Gets the attribute names required by this shader part.
     * EndShader doesn't require any specific vertex attributes.
     *
     * @returns Empty array of attribute names
     */
    get attributeNames(): AttributeNames;
    /**
     * Gets the vertex attribute semantics required by this shader part.
     * EndShader doesn't require any specific vertex attribute semantics.
     *
     * @returns Empty array of vertex attribute enums
     */
    get attributeSemantics(): Array<VertexAttributeEnum>;
    /**
     * Gets the attribute compositions required by this shader part.
     * EndShader doesn't require any specific attribute compositions.
     *
     * @returns Empty array of composition type enums
     */
    get attributeCompositions(): Array<CompositionTypeEnum>;
}

declare class IfStatementShader extends CommonShaderPart {
    get vertexShaderDefinitions(): string;
    get pixelShaderDefinitions(): string;
    get attributeNames(): AttributeNames;
    get attributeSemantics(): Array<VertexAttributeEnum>;
    get attributeCompositions(): Array<CompositionTypeEnum>;
}

declare class TextureFetchShader extends CommonShaderPart {
    static __instance: TextureFetchShader;
    private __materialNodeUid;
    set materialNodeUid(materialNodeUid: MaterialNodeUID$1);
    vertexShaderBody: string;
    getPixelShaderBody(): string;
    get vertexShaderDefinitions(): string;
    get pixelShaderDefinitions(): string;
    get attributeNames(): AttributeNames;
    get attributeSemantics(): Array<VertexAttributeEnum>;
    get attributeCompositions(): Array<CompositionTypeEnum>;
}

declare class UniformDataShader extends CommonShaderPart {
    private __functionName;
    private __compositionType;
    private __componentType;
    private __variableName;
    private __valueStr;
    constructor(__functionName: string, __compositionType: CompositionTypeEnum, __componentType: ComponentTypeEnum);
    setVariableName(name: any): void;
    setDefaultValue(value: any): void;
    get vertexShaderDefinitions(): string;
    get pixelShaderDefinitions(): string;
    get attributeNames(): AttributeNames;
    get attributeSemantics(): Array<VertexAttributeEnum>;
    get attributeCompositions(): Array<CompositionTypeEnum>;
}

declare class VaryingVariableShader extends CommonShaderPart {
    private __functionName;
    private __compositionType;
    private __componentType;
    private __variableName;
    constructor(__functionName: string, __compositionType: CompositionTypeEnum, __componentType: ComponentTypeEnum);
    setVariableName(name: any): void;
    get vertexShaderDefinitions(): string;
    get pixelShaderDefinitions(): string;
    get attributeNames(): AttributeNames;
    get attributeSemantics(): Array<VertexAttributeEnum>;
    get attributeCompositions(): Array<CompositionTypeEnum>;
}

/**
 * A texture loader for KTX2 format files that handles transcoding of compressed texture data.
 *
 * KTX2 is a container format for GPU textures that supports various compression formats
 * including Basis Universal (ETC1S and UASTC). This loader can transcode KTX2 textures
 * to device-specific formats based on available GPU extensions.
 *
 * The loader supports:
 * - ETC1S and UASTC4x4 compressed formats
 * - Multiple target formats (ASTC, BC, ETC, PVRTC, etc.)
 * - ZSTD supercompression
 * - Mipmap generation
 * - Both WebGL and WebGPU rendering contexts
 *
 * @example
 * ```typescript
 * const loader = KTX2TextureLoader.getInstance();
 * const textureData = await loader.transcode(ktx2ArrayBuffer);
 * ```
 */
declare class KTX2TextureLoader {
    private static __instance;
    private static __mscTranscoderModule;
    private static __zstdDecoder;
    private __mscTranscoderPromise;
    /**
     * Creates a new KTX2TextureLoader instance.
     *
     * Initializes the MSC transcoder module required for texture transcoding.
     * Logs an error if the MSC_TRANSCODER function is not available.
     */
    constructor();
    /**
     * Gets the singleton instance of KTX2TextureLoader.
     *
     * @returns The singleton KTX2TextureLoader instance
     */
    static getInstance(): KTX2TextureLoader;
    /**
     * Transcodes a KTX2 texture from the provided byte array.
     *
     * This method parses the KTX2 container, validates its format constraints,
     * and transcodes the texture data to a format suitable for the current GPU.
     *
     * @param uint8Array - The KTX2 texture data as a Uint8Array
     * @returns A promise that resolves to the transcoded texture data
     * @throws Error if the texture format is not supported (3D textures, array textures, or cube textures)
     *
     * @example
     * ```typescript
     * const ktx2Data = new Uint8Array(buffer);
     * const textureData = await loader.transcode(ktx2Data);
     * ```
     */
    transcode(uint8Array: Uint8Array): Promise<{
        width: number;
        height: number;
        compressionTextureType: CompressionTextureTypeEnum;
        mipmapData: TextureData[];
        needGammaCorrection: boolean;
    }>;
    /**
     * Loads and initializes the MSC (Basis Universal) transcoder module.
     *
     * This method ensures the transcoder is loaded only once and initializes
     * the transcoder functions required for texture decompression.
     *
     * @returns A promise that resolves when the transcoder is ready
     * @private
     */
    private __loadMSCTranscoder;
    /**
     * Determines the optimal transcoding parameters for WebGL contexts.
     *
     * Analyzes available WebGL extensions to select the best compression format
     * and transcoding target based on GPU capabilities. Prioritizes formats in
     * order of quality: ASTC > BPTC > S3TC > PVRTC > ETC2 > ETC1 > RGBA32.
     *
     * @param hasAlpha - Whether the texture contains alpha channel data
     * @returns An object containing the transcoding target string and compression type
     * @private
     */
    private __getDeviceDependentParametersWebGL;
    /**
     * Determines the optimal transcoding parameters for WebGPU contexts.
     *
     * Analyzes available WebGPU texture compression features to select the best
     * compression format and transcoding target. Prioritizes formats in order
     * of quality: ASTC > BC (S3TC) > ETC2 > RGBA32.
     *
     * @param hasAlpha - Whether the texture contains alpha channel data
     * @returns An object containing the transcoding target string and compression type
     * @private
     */
    private __getDeviceDependentParametersWebGPU;
    /**
     * Parses a KTX2 container from the provided byte array.
     *
     * Uses the ktx-parse library to read and validate the KTX2 file format.
     * The parser automatically detects invalid identifiers and throws errors
     * for malformed files.
     *
     * @param uint8Array - The raw KTX2 file data
     * @returns The parsed KTX2 container with all metadata and texture data
     * @private
     */
    private __parse;
    /**
     * Transcodes the texture data from the KTX2 container to the target format.
     *
     * This method handles the core transcoding logic, including:
     * - Determining the source compression format (ETC1S or UASTC4x4)
     * - Selecting the appropriate transcoder and target format
     * - Processing all mipmap levels
     * - Handling ZSTD decompression if needed
     * - Managing Basis Universal palette and table data for ETC1S
     *
     * @param ktx2Container - The parsed KTX2 container
     * @returns The transcoded texture data with all mipmap levels
     * @private
     */
    private __transcodeData;
    /**
     * Determines whether the texture contains alpha channel data.
     *
     * For UASTC4x4 format, checks if the channel ID indicates RGBA data.
     * For ETC1S format, checks if any sample contains alpha channel information.
     *
     * @param dfd - The data format descriptor from the KTX2 container
     * @param compressedTextureFormat - The compression format (ETC1S or UASTC4x4)
     * @returns True if the texture has alpha channel data, false otherwise
     * @private
     */
    private __hasAlpha;
}

/**
 * The argument type for System.init() method.
 */
interface SystemInitDescription {
    approach: ProcessApproachEnum;
    canvas: HTMLCanvasElement;
    memoryUsageOrder?: {
        cpuGeneric: number;
        gpuInstanceData: number;
        gpuVertexData: number;
    };
    webglOption?: WebGLContextAttributes;
    notToDisplayRnInfoAtInit?: boolean;
}
/**
 * The system class is the entry point of the Rhodonite library.
 *
 * @example
 * ```
 * await Rn.System.init({
 *   approach: Rn.ProcessApproach.DataTexture,
 *   canvas: document.getElementById('world') as HTMLCanvasElement,
 * });
 *
 * ... (create something) ...
 *
 * Rn.System.startRenderLoop((time, _myArg1, _myArg2) => {
 *   Rn.System.process([expression]);
 * }, myArg1, myArg2);
 * ```
 */
declare class System {
    private static __expressionForProcessAuto?;
    private static __renderPassForProcessAuto?;
    private static __processApproach;
    private static __cgApiResourceRepository;
    private static __renderPassTickCount;
    private static __animationFrameId;
    private static __renderLoopFunc?;
    private static __args;
    private static __rnXRModule?;
    private static __lastCameraComponentsUpdateCount;
    private static __lastCameraControllerComponentsUpdateCount;
    private static __lastTransformComponentsUpdateCount;
    private static __lastPrimitiveCount;
    private constructor();
    /**
     * Starts a render loop.
     *
     * @example
     * ```
     * Rn.System.startRenderLoop((time, _myArg1, _myArg2) => {
     *   Rn.System.process([expression]);
     * }, myArg1, myArg2);
     * ```
     *
     * @param renderLoopFunc - function to be called in each frame
     * @param args - arguments you want to be passed to renderLoopFunc
     */
    static startRenderLoop(renderLoopFunc: (time: number, ...args: any[]) => void, ...args: any[]): void;
    private static __getAnimationFrameObject;
    /**
     * Stops a existing render loop.
     */
    static stopRenderLoop(): void;
    /**
     * Restart a render loop.
     */
    static restartRenderLoop(): void;
    /**
     * A Simple version of process method
     *
     * @remarks
     * No need to create expressions and renderPasses and to register entities, etc...
     * It's suitable for simple use cases like sample apps.
     *
     * @param clearColor - color to clear the canvas
     */
    static processAuto(clearColor?: Vector4): void;
    /**
     * A process method to render a scene
     *
     * @remarks
     * You need to call this method for rendering.
     *
     * @param frame/expression - a frame/expression object
     */
    static process(frame: Frame): void;
    static process(expressions: Expression[]): void;
    private static _processWebGPU;
    private static _processWebGL;
    static get processTime(): number;
    static get timeAtProcessBegin(): number;
    static get timeAtProcessEnd(): number;
    private static createCamera;
    private static setViewportForNormalRendering;
    private static bindFramebufferWebGL;
    private static __displayRnInfo;
    /**
     * Initialize the Rhodonite system.
     *
     * @remarks
     * Don't forget `await` to use this method.
     *
     * @example
     * ```
     * await Rn.System.init({
     *   approach: Rn.ProcessApproach.DataTexture,
     *   canvas: document.getElementById('world') as HTMLCanvasElement,
     * });
     * ```
     *
     * @param desc
     * @returns
     */
    static init(desc: SystemInitDescription): Promise<void>;
    static get processApproach(): ProcessApproachClass;
    static resizeCanvas(width: number, height: number): void;
    static getCanvasSize(): [number, number];
    static getCurrentWebGLContextWrapper(): WebGLContextWrapper | undefined;
}

/**
 * Global system state object that holds various runtime configuration and state information.
 * This object contains system-wide settings that affect rendering behavior and performance.
 */
declare const SystemState: {
    /**
     * The current process approach being used for rendering operations.
     * Determines whether to use WebGL2 uniform approach, data texture approach, WebGPU, or none.
     */
    currentProcessApproach: ProcessApproachClass;
    /**
     * The aspect ratio of the current viewport (width / height).
     * Used for camera projection calculations and responsive rendering.
     * @default 0
     */
    viewportAspectRatio: number;
    /**
     * Flag indicating whether WebGPU render bundle mode is enabled.
     * Render bundles can improve performance by pre-recording rendering commands.
     * @default false
     */
    webgpuRenderBundleMode: boolean;
    /**
     * Total size in bytes of GPU shader data storage, excluding morph target data.
     * Used for memory management and optimization of GPU resource allocation.
     * @default 0
     */
    totalSizeOfGPUShaderDataStorageExceptMorphData: number;
};

/**
 * Basic WebGPU rendering strategy implementation that handles mesh rendering,
 * storage buffer management, and shader program setup for WebGPU-based rendering pipeline.
 *
 * This class provides a complete rendering solution using WebGPU API, including:
 * - Storage buffer management for efficient GPU data transfer
 * - Shader program compilation and setup
 * - Morph target and blend shape handling
 * - Camera and transform matrix updates
 * - Render pass execution with proper primitive sorting
 *
 * @example
 * ```typescript
 * const strategy = WebGpuStrategyBasic.getInstance();
 * strategy.prerender();
 * strategy.common_$render(primitiveUids, renderPass, tickCount);
 * ```
 */
declare class WebGpuStrategyBasic implements CGAPIStrategy {
    private static __instance;
    private __storageBufferUid;
    private __storageBlendShapeBufferUid;
    private __uniformMorphOffsetsTypedArray?;
    private __uniformMorphWeightsTypedArray?;
    private __lastMaterialsUpdateCount;
    private __lastTransformComponentsUpdateCount;
    private __lastSceneGraphComponentsUpdateCount;
    private __lastCameraComponentsUpdateCount;
    private __lastCameraControllerComponentsUpdateCount;
    private __lastBlendShapeComponentsUpdateCountForWeights;
    private __lastBlendShapeComponentsUpdateCountForBlendData;
    private constructor();
    /**
     * Gets the singleton instance of WebGpuStrategyBasic.
     * Creates a new instance if none exists.
     *
     * @returns The singleton instance of WebGpuStrategyBasic
     */
    static getInstance(): WebGpuStrategyBasic;
    /**
     * Generates vertex shader method definitions for storage buffer access.
     * These methods provide standardized access to transform matrices, visibility flags,
     * and morphing functionality in vertex shaders.
     *
     * @returns WGSL shader code containing helper functions for storage buffer access
     */
    static getVertexShaderMethodDefinitions_storageBuffer(): string;
    /**
     * Generates shader property accessor functions for materials and global data.
     * Creates WGSL functions that can fetch property values from storage buffers
     * based on shader semantics information.
     *
     * @param materialTypeName - The name of the material type
     * @param info - Shader semantics information containing type and binding details
     * @param isGlobalData - Whether this property belongs to global data or material-specific data
     * @returns WGSL shader code for the property accessor function
     */
    private static __getShaderProperty;
    /**
     * Calculates the memory offset of a shader property within storage buffers.
     *
     * @param isGlobalData - Whether to look in global data repository or material repository
     * @param propertyName - The semantic name of the property
     * @param materialTypeName - The material type name for material-specific properties
     * @returns The byte offset of the property in the storage buffer, or -1 if not found
     */
    private static getOffsetOfPropertyInShader;
    /**
     * Loads and prepares a mesh component for rendering.
     * Sets up vertex buffer objects (VBO) and vertex array objects (VAO) if not already done.
     *
     * @param meshComponent - The mesh component to load
     * @returns True if the mesh was successfully loaded, false if the mesh is null
     */
    $load(meshComponent: MeshComponent): boolean;
    /**
     * Performs common loading operations required for the WebGPU strategy.
     * Initializes morph target arrays and updates blend shape storage buffers when needed.
     */
    common_$load(): void;
    /**
     * Sets up shader programs for all primitives in the given mesh component.
     * Iterates through all primitives and ensures their materials have proper shader programs.
     *
     * @param meshComponent - The mesh component containing primitives to setup
     */
    private __setupShaderProgramForMeshComponent;
    /**
     * Sets up a shader program for a specific material and primitive combination.
     * Handles shader compilation errors by falling back to backup materials when necessary.
     *
     * @param material - The material to setup the shader for
     * @param primitive - The primitive that will use this material
     */
    private _setupShaderProgram;
    /**
     * Sets up shader programs for materials using the WebGPU rendering strategy.
     * This method orchestrates the shader compilation process by providing the necessary
     * method definitions and property setters.
     *
     * @param material - The material to create shader programs for
     * @param primitive - The primitive geometry that will use this material
     * @param vertexShaderMethodDefinitions - WGSL code containing vertex shader helper methods
     * @param propertySetter - Function to generate property accessor methods
     */
    setupShaderForMaterial(material: Material, primitive: Primitive, vertexShaderMethodDefinitions: string, propertySetter: getShaderPropertyFunc): void;
    /**
     * Renders a render pass using pre-built render bundles for improved performance.
     * Render bundles allow WebGPU to optimize command encoding by pre-recording draw commands.
     *
     * @param renderPass - The render pass to execute
     * @returns True if the render bundle was successfully executed
     */
    renderWithRenderBundle(renderPass: RenderPass): boolean;
    /**
     * Performs pre-rendering operations required before drawing.
     * Updates storage buffers when components have been modified and handles morph target updates.
     * This method should be called once per frame before any rendering operations.
     */
    prerender(): void;
    /**
     * Main rendering method that draws all primitives in the specified render pass.
     * Handles different primitive types (opaque, translucent, blend) with appropriate depth writing settings.
     *
     * @param primitiveUids - Array of primitive UIDs to render, sorted by rendering order
     * @param renderPass - The render pass configuration containing rendering settings
     * @param renderPassTickCount - Current tick count for animation and timing purposes
     * @returns True if any primitives were successfully rendered
     */
    common_$render(primitiveUids: PrimitiveUID[], renderPass: RenderPass, _renderPassTickCount: number): boolean;
    /**
     * Renders primitives without using vertex/index buffers.
     * This is used for special rendering modes like full-screen effects or procedural geometry.
     *
     * @param renderPass - The render pass containing the material and rendering configuration
     */
    private __renderWithoutBuffers;
    /**
     * Renders a single primitive with the specified material and render settings.
     * Handles shader setup, uniform buffer updates, and the actual draw call.
     *
     * @param primitiveUid - Unique identifier of the primitive to render
     * @param renderPass - Render pass containing rendering configuration
     * @param zWrite - Whether to enable depth buffer writing
     * @returns True if the primitive was successfully rendered
     */
    renderInner(primitiveUid: PrimitiveUID, renderPass: RenderPass, zWrite: boolean): boolean;
    /**
     * Creates or updates the main storage buffer containing all GPU instance data.
     * This buffer holds transform matrices, material properties, and other per-instance data
     * required for rendering all objects in the scene.
     */
    private __createAndUpdateStorageBuffer;
    /**
     * Updates only the camera-related portion of the storage buffer for performance optimization.
     * Used when only camera properties have changed, avoiding unnecessary updates to transform data.
     */
    private __createAndUpdateStorageBufferForCameraOnly;
    /**
     * Creates or updates the storage buffer containing blend shape vertex data.
     * This buffer holds morph target positions and other vertex attributes needed for blend shape animation.
     */
    private __createOrUpdateStorageBlendShapeBuffer;
    /**
     * Updates uniform buffers containing morph target weights for blend shape animation.
     * Copies weight values from blend shape components to GPU-accessible uniform buffers.
     */
    private __updateUniformMorph;
    /**
     * Determines the appropriate camera component SID for the current rendering context.
     * Handles both VR and non-VR rendering scenarios, including multi-view stereo rendering.
     *
     * @param renderPass - The current render pass
     * @param displayIdx - Display index for stereo rendering (0 for left eye, 1 for right eye)
     * @param isVRMainPass - Whether this is a VR main rendering pass
     * @returns The component SID of the appropriate camera, or -1 if no camera is available
     */
    private __getAppropriateCameraComponentSID;
}

/**
 * Data structure for tracking WebXR viewer (user) position and orientation
 */
type WebXRSystemViewerData = {
    /** Current position offset of the viewer */
    viewerTranslate: IMutableVector3;
    /** Current scale factor of the viewer */
    viewerScale: MutableVector3;
    /** Current orientation of the viewer */
    viewerOrientation: IMutableQuaternion;
    /** Current azimuth rotation angle of the viewer */
    viewerAzimuthAngle: MutableScalar;
};
/**
 * Creates and initializes a motion controller for a WebXR input source
 * @param xrInputSource - The WebXR input source to create a controller for
 * @param basePath - Base path for loading controller assets
 * @param profilePriorities - Array of profile names in order of preference
 * @returns Promise that resolves to the root entity of the controller model
 */
declare function createMotionController(xrInputSource: XRInputSource, basePath: string, _profilePriorities: string[]): Promise<ISceneGraphEntity>;
/**
 * Updates all motion controllers' states based on current gamepad input
 * @param timestamp - Current frame timestamp in microseconds
 * @param xrFrame - Current WebXR frame
 * @param viewerData - Current viewer position and orientation data
 */
declare function updateGamePad(timestamp: number, _xrFrame: XRFrame, viewerData: WebXRSystemViewerData): void;
/**
 * Updates the visual state of a motion controller model based on component values
 * Animates button presses, trigger pulls, thumbstick movements, etc.
 * @param entity - The root entity containing the controller model
 * @param motionController - The motion controller with current component states
 */
declare function updateMotionControllerModel(entity: IEntity, motionController: MotionController): void;
/**
 * Retrieves the motion controller associated with a specific XR input source
 * @param xrInputSource - The XR input source to get the motion controller for
 * @returns The motion controller if found, undefined otherwise
 */
declare function getMotionController(xrInputSource: XRInputSource): MotionController | undefined;

declare function getWebXRSystem(): WebXRSystem;

/**
 * WebAR (Augmented Reality) system for managing WebXR AR sessions and camera operations.
 * This singleton class provides functionality to initialize, enter, and manage WebAR sessions,
 * handling camera positioning, view matrices, and rendering operations for AR experiences.
 *
 * @example
 * ```typescript
 * const arSystem = WebARSystem.getInstance();
 * await arSystem.readyForWebAR(buttonElement);
 * await arSystem.enterWebAR({
 *   callbackOnXrSessionStart: () => console.log('AR started'),
 *   callbackOnXrSessionEnd: () => console.log('AR ended')
 * });
 * ```
 */
declare class WebARSystem {
    private static __instance;
    private __oGlw;
    private __isReadyForWebAR;
    private __oArSession;
    private __oWebglLayer;
    private __spaceType;
    private __isWebARMode;
    private __requestedToEnterWebAR;
    private __oArViewerPose;
    private __oArReferenceSpace;
    private __defaultPositionInLocalSpaceMode;
    private __canvasWidthForAR;
    private __canvasHeightForAR;
    private _cameraEntity;
    private __viewerTranslate;
    private __viewerAzimuthAngle;
    private __viewerOrientation;
    private __viewerScale;
    /**
     * Creates a new WebARSystem instance.
     * Initializes the camera entity with default settings for WebAR operations.
     *
     * @private Use getInstance() to get the singleton instance instead.
     */
    constructor();
    /**
     * Gets the singleton instance of WebARSystem.
     * Creates a new instance if one doesn't exist.
     *
     * @returns The singleton WebARSystem instance
     */
    static getInstance(): WebARSystem;
    /**
     * Prepares the system for WebAR by checking device support and setting up the UI.
     * This method must be called before entering WebAR mode.
     *
     * @param requestButtonDom - The HTML element to use as the AR entry button.
     *                          If null, a default button will be created.
     * @returns Promise that resolves to an empty array on success
     * @throws Error if not in browser environment, WebGL context is not ready, or WebAR is not supported
     *
     * @example
     * ```typescript
     * const button = document.getElementById('ar-button');
     * await arSystem.readyForWebAR(button);
     * ```
     */
    readyForWebAR(requestButtonDom: HTMLElement): Promise<never[]>;
    /**
     * Enters WebAR mode by creating an XR session and setting up the AR environment.
     * This method handles session initialization, reference space setup, and render loop management.
     *
     * @param params - Configuration object for AR session
     * @param params.initialUserPosition - Initial position of the user in world space coordinates
     * @param params.callbackOnXrSessionStart - Callback function executed when AR session starts
     * @param params.callbackOnXrSessionEnd - Callback function executed when AR session ends
     * @returns Promise that resolves when AR session is successfully started
     * @throws Error if WebGL context or WebAR readiness is not satisfied
     *
     * @example
     * ```typescript
     * await arSystem.enterWebAR({
     *   initialUserPosition: Vector3.fromCopyArray([0, 0, 0]),
     *   callbackOnXrSessionStart: () => console.log('AR session started'),
     *   callbackOnXrSessionEnd: () => console.log('AR session ended')
     * });
     * ```
     */
    enterWebAR({ initialUserPosition, callbackOnXrSessionStart, callbackOnXrSessionEnd, }: {
        initialUserPosition?: Vector3;
        callbackOnXrSessionStart: () => void;
        callbackOnXrSessionEnd: () => void;
    }): Promise<void>;
    /**
     * Sets up the WebGL layer for the XR session.
     * Configures the rendering context, creates the XR WebGL layer, and updates render state.
     *
     * @private
     * @param xrSession - The active XR session
     * @param callbackOnXrSessionStart - Callback to execute when setup is complete
     * @throws Error if not in browser environment or WebGL context is not ready
     */
    private __setupWebGLLayer;
    /**
     * Exits WebAR mode by ending the current XR session.
     * This will trigger the session end event handlers and cleanup.
     *
     * @returns Promise that resolves when the session is successfully ended
     *
     * @example
     * ```typescript
     * await arSystem.exitWebAR();
     * ```
     */
    exitWebAR(): Promise<void>;
    /**
     * Gets the canvas width configured for AR rendering.
     *
     * @returns The width of the AR canvas in pixels
     */
    getCanvasWidthForVr(): number;
    /**
     * Gets the canvas height configured for AR rendering.
     *
     * @returns The height of the AR canvas in pixels
     */
    getCanvasHeightForVr(): number;
    /**
     * Gets the current view matrix from the camera entity.
     *
     * @returns The current view matrix for rendering
     */
    get viewMatrix(): Matrix44;
    /**
     * Updates the viewer pose and camera information from the XR frame.
     *
     * @private
     * @param xrFrame - The current XR frame containing pose information
     */
    private __updateView;
    /**
     * Updates camera transform information based on XR viewer pose data.
     * Applies position, orientation, and scale transformations to the camera entity.
     *
     * @private
     * @param xrViewerPose - The XR viewer pose containing transform data
     */
    private __setCameraInfoFromXRViews;
    /**
     * Gets the current projection matrix from the XR view.
     *
     * @returns The projection matrix for the current AR view, or identity matrix if no view exists
     */
    get projectionMatrix(): MutableMatrix44;
    /**
     * Pre-render processing for AR frames.
     * Updates view information if in AR mode and frame data is available.
     *
     * @internal
     * @param time - The current time timestamp
     * @param xrFrame - The XR frame object containing pose and view data
     */
    _preRender(_time: number, xrFrame: XRFrame): void;
    /**
     * Post-render processing for AR frames.
     * Handles framebuffer operations and state management after rendering.
     *
     * @internal
     */
    _postRender(): void;
    /**
     * Indicates whether the system is currently in WebAR mode.
     *
     * @returns True if currently in AR mode, false otherwise
     */
    get isWebARMode(): boolean;
    /**
     * Indicates whether the system is ready for WebAR operations.
     *
     * @returns True if ready for AR, false otherwise
     */
    get isReadyForWebAR(): boolean;
    /**
     * Indicates whether a request to enter WebAR has been made.
     *
     * @returns True if AR entry was requested, false otherwise
     */
    get requestedToEnterWebAR(): boolean;
    /**
     * Gets the current AR session instance.
     *
     * @returns The active XR session or undefined if no session exists
     */
    get arSession(): XRSession | undefined;
    /**
     * Gets the current framebuffer for AR rendering.
     *
     * @returns The framebuffer from the base layer, or undefined if not available
     */
    get framebuffer(): WebGLFramebuffer | undefined;
}

declare const XR: Readonly<{
    WebXRSystem: typeof WebXRSystem;
    WebARSystem: typeof WebARSystem;
}>;

type RnXR = typeof XR;

declare const VERSION: any;

export { AABB, AABBGizmo, AbsoluteAnimation, AbstractArrayBufferBaseMathNumber, AbstractCameraController, AbstractMaterialContent, AbstractMatrix, AbstractQuaternion, AbstractShaderNode, AbstractTexture, AbstractVector, Accessor, AddShaderNode, AlphaMode, type AlphaModeEnum, AnimatedQuaternion, AnimatedScalar, AnimatedVector2, AnimatedVector3, AnimatedVector4, AnimatedVectorN, AnimationAssigner, AnimationAttribute, type AnimationAttributeEnum, type AnimationChannel, type AnimationChannelTarget, AnimationComponent, type AnimationComponentEventType, type AnimationInfo, AnimationInterpolation, type AnimationInterpolationEnum, type AnimationPathName, type AnimationSampler, type AnimationSamplers, type AnimationTrack, type AnimationTrackName, type Array1, type Array16, type Array1to4, type Array2, type Array3, type Array4, type Array9, type ArrayAsRn, type ArrayType, AssetLoader, type AssetLoaderConfig, AttributeColorShaderNode, type AttributeName, type AttributeNames, AttributeNormalShaderNode, AttributePositionShaderNode, AttributeTexcoordShaderNode, type Attributes, Axis, type AxisDescriptor, type BASIS_TYPE, BasisCompressionType, type BasisCompressionTypeEnum, type BasisFile, BasisLzEtc1sImageTranscoder, type BasisTranscoder, BlendShapeComponent, BlockBeginShader, BlockBeginShaderNode, BlockEndShader, BlockEndShaderNode, Bloom, BoneDataType, type BoneDataTypeEnum, Buffer, BufferUse, type BufferUseEnum, BufferView, type Byte$1 as Byte, type CGAPIResourceHandle, CGAPIResourceRepository, Cache, type CalledSubscriberNumber, CameraComponent, CameraControllerComponent, CameraControllerType, type CameraControllerTypeEnum, type CameraSID, CameraType, type CameraTypeEnum, CapsuleCollider, type ChangeAnimationInfoEvent, ClassicShadingShader, type ColorComponentLetter, ColorGradingUsingLUTsMaterialContent, ColorRgb, ColorRgba, CommonShaderPart, ComplexVertexAttribute, Component, type ComponentMixinFunction, ComponentRepository, type ComponentSID, type ComponentTID, type ComponentToComponentMethods, ComponentType, type ComponentTypeEnum, CompositionType, type CompositionTypeEnum, CompressionTextureType, type CompressionTextureTypeEnum, Config, ConstRgbaBlack, ConstRgbaWhite, ConstVector2_0_0, ConstVector2_1_1, ConstVector3_0_0_0, ConstVector3_1_1_1, ConstVector4_0_0_0_0, ConstVector4_0_0_0_1, ConstVector4_1_1_1_1, ConstantScalarVariableShaderNode, ConstantVariableShader, ConstantVector2VariableShaderNode, ConstantVector3VariableShaderNode, ConstantVector4VariableShaderNode, type Count, Cube, type CubeDescriptor, CubeTexture, CustomMaterialContent, DataUtil, DefaultTextures, DepthEncodeMaterialContent, DetectHighLuminanceMaterialContent, type DirectTextureData, DotProductShaderNode, DrcPointCloudImporter, EVENT_CLICK, EVENT_KEY_DOWN, EVENT_KEY_PRESS, EVENT_KEY_UP, EVENT_MOUSE_DOWN, EVENT_MOUSE_ENTER, EVENT_MOUSE_LEAVE, EVENT_MOUSE_MOVE, EVENT_MOUSE_OVER, EVENT_MOUSE_UP, EVENT_MOUSE_WHEEL, EVENT_MSPOINTER_DOWN, EVENT_MSPOINTER_MOVE, EVENT_MSPOINTER_UP, EVENT_ORIENTATION_CHANGE, EVENT_POINTER_CANCEL, EVENT_POINTER_DOWN, EVENT_POINTER_ENTER, EVENT_POINTER_LEAVE, EVENT_POINTER_MOVE, EVENT_POINTER_OUT, EVENT_POINTER_OVER, EVENT_POINTER_UP, EVENT_RESIZE, EVENT_TOUCH_CANCEL, EVENT_TOUCH_DOUBLE_TAP, EVENT_TOUCH_DRAG, EVENT_TOUCH_END, EVENT_TOUCH_ENTER, EVENT_TOUCH_HOLD, EVENT_TOUCH_LEAVE, EVENT_TOUCH_LONG_TAP, EVENT_TOUCH_MOVE, EVENT_TOUCH_OUT, EVENT_TOUCH_OVER, EVENT_TOUCH_PINCH, EVENT_TOUCH_START, EVENT_TOUCH_SWIPE, EVENT_TOUCH_TAP, Effekseer, EffekseerComponent, EndShader, Entity, EntityRepository, type EntityUID, EntityUIDOutputMaterialContent, EnumClass, type EnumIO, Err, type EventHandler, EventPubSub, type EventSubscriberIndex, type EventType, Expression, FileType, type FileTypeEnum, type FillArgsObject, type FloatTypedArray, type FloatTypedArrayConstructor, ForwardRenderPipeline, Frame, FrameBuffer, type FrameBufferCubeMapDescriptor, type FrameBufferDescriptor, type FrameBufferMSAADescriptor, type FrameBufferTextureArrayDescriptor, type FrameBufferTextureArrayForMultiViewDescriptor, Frustum, FurnaceTestMaterialContent, GLTF2_EXPORT_DRACO, GLTF2_EXPORT_EMBEDDED, GLTF2_EXPORT_GLB, GLTF2_EXPORT_GLTF, GLTF2_EXPORT_NO_DOWNLOAD, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_TEXTURE, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ALIASED_LINE_WIDTH_RANGE, GL_ALIASED_POINT_SIZE_RANGE, GL_ALPHA, GL_ALPHA_BITS, GL_ALREADY_SIGNALED, GL_ALWAYS, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_ARRAY_BUFFER, GL_ARRAY_BUFFER_BINDING, GL_ATTACHED_SHADERS, GL_BACK, GL_BLEND, GL_BLEND_COLOR, GL_BLEND_DST_ALPHA, GL_BLEND_DST_RGB, GL_BLEND_EQUATION, GL_BLEND_EQUATION_ALPHA, GL_BLEND_EQUATION_RGB, GL_BLEND_SRC_ALPHA, GL_BLEND_SRC_RGB, GL_BLUE_BITS, GL_BOOL, GL_BOOL_VEC2, GL_BOOL_VEC3, GL_BOOL_VEC4, GL_BROWSER_DEFAULT_WEBGL, GL_BUFFER_SIZE, GL_BUFFER_USAGE, GL_CCW, GL_CLAMP_TO_EDGE, GL_COLOR, GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT0_WEBGL, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT10, GL_COLOR_ATTACHMENT10_WEBGL, GL_COLOR_ATTACHMENT11, GL_COLOR_ATTACHMENT11_WEBGL, GL_COLOR_ATTACHMENT12, GL_COLOR_ATTACHMENT12_WEBGL, GL_COLOR_ATTACHMENT13, GL_COLOR_ATTACHMENT13_WEBGL, GL_COLOR_ATTACHMENT14, GL_COLOR_ATTACHMENT14_WEBGL, GL_COLOR_ATTACHMENT15, GL_COLOR_ATTACHMENT15_WEBGL, GL_COLOR_ATTACHMENT1_WEBGL, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT2_WEBGL, GL_COLOR_ATTACHMENT3, GL_COLOR_ATTACHMENT3_WEBGL, GL_COLOR_ATTACHMENT4, GL_COLOR_ATTACHMENT4_WEBGL, GL_COLOR_ATTACHMENT5, GL_COLOR_ATTACHMENT5_WEBGL, GL_COLOR_ATTACHMENT6, GL_COLOR_ATTACHMENT6_WEBGL, GL_COLOR_ATTACHMENT7, GL_COLOR_ATTACHMENT7_WEBGL, GL_COLOR_ATTACHMENT8, GL_COLOR_ATTACHMENT8_WEBGL, GL_COLOR_ATTACHMENT9, GL_COLOR_ATTACHMENT9_WEBGL, GL_COLOR_BUFFER_BIT, GL_COLOR_CLEAR_VALUE, GL_COLOR_WRITEMASK, GL_COMPARE_REF_TO_TEXTURE, GL_COMPILE_STATUS, GL_COMPRESSED_R11_EAC, GL_COMPRESSED_RG11_EAC, GL_COMPRESSED_RGB8_ETC2, GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_RGBA8_ETC2_EAC, GL_COMPRESSED_RGBA_ASTC_10X10_KHR, GL_COMPRESSED_RGBA_ASTC_10X5_KHR, GL_COMPRESSED_RGBA_ASTC_10X6_KHR, GL_COMPRESSED_RGBA_ASTC_10X8_KHR, GL_COMPRESSED_RGBA_ASTC_12X10_KHR, GL_COMPRESSED_RGBA_ASTC_12X12_KHR, GL_COMPRESSED_RGBA_ASTC_4X4_KHR, GL_COMPRESSED_RGBA_ASTC_5X4_KHR, GL_COMPRESSED_RGBA_ASTC_5X5_KHR, GL_COMPRESSED_RGBA_ASTC_6X5_KHR, GL_COMPRESSED_RGBA_ASTC_6X6_KHR, GL_COMPRESSED_RGBA_ASTC_8X5_KHR, GL_COMPRESSED_RGBA_ASTC_8X6_KHR, GL_COMPRESSED_RGBA_ASTC_8X8_KHR, GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL, GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL, GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG, GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG, GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, GL_COMPRESSED_RGBA_S3TC_DXT3_EXT, GL_COMPRESSED_RGBA_S3TC_DXT5_EXT, GL_COMPRESSED_RGB_ATC_WEBGL, GL_COMPRESSED_RGB_ETC1_WEBGL, GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG, GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG, GL_COMPRESSED_RGB_S3TC_DXT1_EXT, GL_COMPRESSED_SIGNED_R11_EAC, GL_COMPRESSED_SIGNED_RG11_EAC, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR, GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, GL_COMPRESSED_SRGB8_ETC2, GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, GL_COMPRESSED_SRGB_S3TC_DXT1_EXT, GL_COMPRESSED_TEXTURE_FORMATS, GL_CONDITION_SATISFIED, GL_CONSTANT_ALPHA, GL_CONSTANT_COLOR, GL_CONTEXT_LOST_WEBGL, GL_COPY_READ_BUFFER, GL_COPY_READ_BUFFER_BINDING, GL_COPY_WRITE_BUFFER, GL_COPY_WRITE_BUFFER_BINDING, GL_CULL_FACE, GL_CULL_FACE_MODE, GL_CURRENT_PROGRAM, GL_CURRENT_QUERY, GL_CURRENT_QUERY_EXT, GL_CURRENT_VERTEX_ATTRIB, GL_CW, GL_DATA_BYTE, GL_DATA_FLOAT, GL_DATA_INT, GL_DATA_SHORT, GL_DATA_UNSIGNED_BYTE, GL_DATA_UNSIGNED_INT, GL_DATA_UNSIGNED_SHORT, GL_DECR, GL_DECR_WRAP, GL_DELETE_STATUS, GL_DEPTH, GL_DEPTH24_STENCIL8, GL_DEPTH32F_STENCIL8, GL_DEPTH_ATTACHMENT, GL_DEPTH_BITS, GL_DEPTH_BUFFER_BIT, GL_DEPTH_CLEAR_VALUE, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32F, GL_DEPTH_FUNC, GL_DEPTH_RANGE, GL_DEPTH_STENCIL, GL_DEPTH_STENCIL_ATTACHMENT, GL_DEPTH_TEST, GL_DEPTH_WRITEMASK, GL_DITHER, GL_DONT_CARE, GL_DRAW_BUFFER0, GL_DRAW_BUFFER0_WEBGL, GL_DRAW_BUFFER1, GL_DRAW_BUFFER10, GL_DRAW_BUFFER10_WEBGL, GL_DRAW_BUFFER11, GL_DRAW_BUFFER11_WEBGL, GL_DRAW_BUFFER12, GL_DRAW_BUFFER12_WEBGL, GL_DRAW_BUFFER13, GL_DRAW_BUFFER13_WEBGL, GL_DRAW_BUFFER14, GL_DRAW_BUFFER14_WEBGL, GL_DRAW_BUFFER15, GL_DRAW_BUFFER15_WEBGL, GL_DRAW_BUFFER1_WEBGL, GL_DRAW_BUFFER2, GL_DRAW_BUFFER2_WEBGL, GL_DRAW_BUFFER3, GL_DRAW_BUFFER3_WEBGL, GL_DRAW_BUFFER4, GL_DRAW_BUFFER4_WEBGL, GL_DRAW_BUFFER5, GL_DRAW_BUFFER5_WEBGL, GL_DRAW_BUFFER6, GL_DRAW_BUFFER6_WEBGL, GL_DRAW_BUFFER7, GL_DRAW_BUFFER7_WEBGL, GL_DRAW_BUFFER8, GL_DRAW_BUFFER8_WEBGL, GL_DRAW_BUFFER9, GL_DRAW_BUFFER9_WEBGL, GL_DRAW_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER_BINDING, GL_DST_ALPHA, GL_DST_COLOR, GL_DYNAMIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, GL_ELEMENT_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER_BINDING, GL_EQUAL, GL_FASTEST, GL_FLOAT_32_UNSIGNED_INT_24_8_REV, GL_FLOAT_MAT2, GL_FLOAT_MAT2X3, GL_FLOAT_MAT2X4, GL_FLOAT_MAT3, GL_FLOAT_MAT3X2, GL_FLOAT_MAT3X4, GL_FLOAT_MAT4, GL_FLOAT_MAT4X2, GL_FLOAT_MAT4X3, GL_FLOAT_VEC2, GL_FLOAT_VEC3, GL_FLOAT_VEC4, GL_FRAGMENT_SHADER, GL_FRAGMENT_SHADER_DERIVATIVE_HINT, GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES, GL_FRAMEBUFFER, GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE, GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT, GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE, GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT, GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE, GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE, GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE, GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE, GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER, GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL, GL_FRAMEBUFFER_BINDING, GL_FRAMEBUFFER_COMPLETE, GL_FRAMEBUFFER_DEFAULT, GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT, GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS, GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT, GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE, GL_FRAMEBUFFER_UNSUPPORTED, GL_FRONT, GL_FRONT_AND_BACK, GL_FRONT_FACE, GL_FUNC_ADD, GL_FUNC_REVERSE_SUBTRACT, GL_FUNC_SUBSTRACT, GL_GENERATE_MIPMAP_HINT, GL_GEQUAL, GL_GPU_DISJOINT_EXT, GL_GREATER, GL_GREEN_BITS, GL_HALF_FLOAT, GL_HALF_FLOAT_OES, GL_HIGH_FLOAT, GL_HIGH_INT, GL_IMPLEMENTATION_COLOR_READ_FORMAT, GL_IMPLEMENTATION_COLOR_READ_TYPE, GL_INCR, GL_INCR_WRAP, GL_INTERLEAVED_ATTRIBS, GL_INT_2_10_10_10_REV, GL_INT_SAMPLER_2D, GL_INT_SAMPLER_2D_ARRAY, GL_INT_SAMPLER_3D, GL_INT_SAMPLER_CUBE, GL_INT_VEC2, GL_INT_VEC3, GL_INT_VEC4, GL_INVALID_ENUM, GL_INVALID_FRAMEBUFFER_OPERATION, GL_INVALID_INDEX, GL_INVALID_OPERATION, GL_INVALID_VALUE, GL_INVERT, GL_KEEP, GL_LEQUAL, GL_LESS, GL_LINEAR, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR_MIPMAP_NEAREST, GL_LINES, GL_LINE_LOOP, GL_LINE_STRIP, GL_LINE_WIDTH, GL_LINK_STATUS, GL_LOW_FLOAT, GL_LOW_INT, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_MAX, GL_MAX_3D_TEXTURE_SIZE, GL_MAX_ARRAY_TEXTURE_LAYERS, GL_MAX_CLIENT_WAIT_TIMEOUT_WEBGL, GL_MAX_COLOR_ATTACHMENTS, GL_MAX_COLOR_ATTACHMENTS_WEBGL, GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS, GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, GL_MAX_COMBINED_UNIFORM_BLOCKS, GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS, GL_MAX_CUBE_MAP_TEXTURE_SIZE, GL_MAX_DRAW_BUFFERS, GL_MAX_DRAW_BUFFERS_WEBGL, GL_MAX_ELEMENTS_INDICES, GL_MAX_ELEMENTS_VERTICES, GL_MAX_ELEMENT_INDEX, GL_MAX_EXT, GL_MAX_FRAGMENT_INPUT_COMPONENTS, GL_MAX_FRAGMENT_UNIFORM_BLOCKS, GL_MAX_FRAGMENT_UNIFORM_COMPONENTS, GL_MAX_FRAGMENT_UNIFORM_VECTORS, GL_MAX_PROGRAM_TEXEL_OFFSET, GL_MAX_RENDERBUFFER_SIZE, GL_MAX_SAMPLES, GL_MAX_SERVER_WAIT_TIMEOUT, GL_MAX_TEXTURE_IMAGE_UNITS, GL_MAX_TEXTURE_LOD_BIAS, GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, GL_MAX_TEXTURE_SIZE, GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS, GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS, GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS, GL_MAX_UNIFORM_BLOCK_SIZE, GL_MAX_UNIFORM_BUFFER_BINDINGS, GL_MAX_VARYING_COMPONENTS, GL_MAX_VARYING_VECTORS, GL_MAX_VERTEX_ATTRIBS, GL_MAX_VERTEX_OUTPUT_COMPONENTS, GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS, GL_MAX_VERTEX_UNIFORM_BLOCKS, GL_MAX_VERTEX_UNIFORM_COMPONENTS, GL_MAX_VERTEX_UNIFORM_VECTORS, GL_MAX_VIEWPORT_DIMS, GL_MEDIUM_FLOAT, GL_MEDIUM_INT, GL_MIN, GL_MIN_EXT, GL_MIN_PROGRAM_TEXEL_OFFSET, GL_MIRRORED_REPEAT, GL_NEAREST, GL_NEAREST_MIPMAP_LINEAR, GL_NEAREST_MIPMAP_NEAREST, GL_NEVER, GL_NICEST, GL_NONE, GL_NOTEQUAL, GL_NO_ERROR, GL_OBJECT_TYPE, GL_ONE, GL_ONE_MINUS_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_COLOR, GL_ONE_MINUS_DST_ALPHA, GL_ONE_MINUS_DST_COLOR, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_SRC_COLOR, GL_OUT_OF_MEMORY, GL_PACK_ALIGNMENT, GL_PACK_ROW_LENGTH, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PIXEL_PACK_BUFFER, GL_PIXEL_PACK_BUFFER_BINDING, GL_PIXEL_UNPACK_BUFFER, GL_PIXEL_UNPACK_BUFFER_BINDING, GL_PIXEL_UNSIGNED_BYTE, GL_PIXEL_UNSIGNED_SHORT_4_4_4_4, GL_PIXEL_UNSIGNED_SHORT_5_5_5_1, GL_PIXEL_UNSIGNED_SHORT_5_6_5, GL_POINTS, GL_POLYGON_OFFSET_FACTOR, GL_POLYGON_OFFSET_FILL, GL_POLYGON_OFFSET_UNITS, GL_QUERY_COUNTER_BITS_EXT, GL_QUERY_RESULT, GL_QUERY_RESULT_AVAILABLE, GL_QUERY_RESULT_AVAILABLE_EXT, GL_QUERY_RESULT_EXT, GL_R11F_G11F_B10F, GL_R16F, GL_R16I, GL_R16UI, GL_R32F, GL_R32I, GL_R32UI, GL_R8, GL_R8I, GL_R8UI, GL_R8_SNORM, GL_RASTERIZER_DISCARD, GL_READ_BUFFER, GL_READ_FRAMEBUFFER, GL_READ_FRAMEBUFFER_BINDING, GL_RED, GL_RED_BITS, GL_RED_INTEGER, GL_RENDERBUFFER, GL_RENDERBUFFER_ALPHA_SIZE, GL_RENDERBUFFER_BINDING, GL_RENDERBUFFER_BLUE_SIZE, GL_RENDERBUFFER_DEPTH_SIZE, GL_RENDERBUFFER_GREEN_SIZE, GL_RENDERBUFFER_HEIGHT, GL_RENDERBUFFER_INTERNAL_FORMAT, GL_RENDERBUFFER_RED_SIZE, GL_RENDERBUFFER_SAMPLES, GL_RENDERBUFFER_STENCIL_SIZE, GL_RENDERBUFFER_WIDTH, GL_RENDERER, GL_REPEAT, GL_REPLACE, GL_RG, GL_RG16F, GL_RG16I, GL_RG16UI, GL_RG32F, GL_RG32I, GL_RG32UI, GL_RG8, GL_RG8I, GL_RG8UI, GL_RG8_SNORM, GL_RGB, GL_RGB10_A2, GL_RGB10_A2UI, GL_RGB16F, GL_RGB16I, GL_RGB16UI, GL_RGB32F, GL_RGB32F_EXT, GL_RGB32I, GL_RGB32UI, GL_RGB565, GL_RGB5_A1, GL_RGB8, GL_RGB8I, GL_RGB8UI, GL_RGB8_SNORM, GL_RGB9_E5, GL_RGBA, GL_RGBA16F, GL_RGBA16I, GL_RGBA16UI, GL_RGBA32F, GL_RGBA32F_EXT, GL_RGBA32I, GL_RGBA32UI, GL_RGBA4, GL_RGBA8, GL_RGBA8I, GL_RGBA8UI, GL_RGBA8_SNORM, GL_RGBA_INTEGER, GL_RGB_INTEGER, GL_RG_INTEGER, GL_SAMPLER_2D, GL_SAMPLER_2D_ARRAY, GL_SAMPLER_2D_ARRAY_SHADOW, GL_SAMPLER_2D_SHADOW, GL_SAMPLER_3D, GL_SAMPLER_BINDING, GL_SAMPLER_CUBE, GL_SAMPLER_CUBE_SHADOW, GL_SAMPLES, GL_SAMPLE_ALPHA_TO_COVERAGE, GL_SAMPLE_BUFFERS, GL_SAMPLE_COVERAGE, GL_SAMPLE_COVERAGE_INVERT, GL_SAMPLE_COVERAGE_VALUE, GL_SCISSOR_BOX, GL_SCISSOR_TEST, GL_SEPARATE_ATTRIBS, GL_SHADER_TYPE, GL_SHADING_LANGUAGE_VERSION, GL_SIGNALED, GL_SIGNED_NORMALIZED, GL_SRC_ALPHA, GL_SRC_ALPHA_SATURATE, GL_SRC_COLOR, GL_SRGB, GL_SRGB8, GL_SRGB8_ALPHA8, GL_SRGB8_ALPHA8_EXT, GL_SRGB_ALPHA_EXT, GL_SRGB_EXT, GL_STATIC_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STENCIL, GL_STENCIL_ATTACHMENT, GL_STENCIL_BACK_FAIL, GL_STENCIL_BACK_FUNC, GL_STENCIL_BACK_PASS_DEPTH_FAIL, GL_STENCIL_BACK_PASS_DEPTH_PASS, GL_STENCIL_BACK_REF, GL_STENCIL_BACK_VALUE_MASK, GL_STENCIL_BACK_WRITEMASK, GL_STENCIL_BITS, GL_STENCIL_BUFFER_BIT, GL_STENCIL_CLEAR_VALUE, GL_STENCIL_FAIL, GL_STENCIL_FUNC, GL_STENCIL_INDEX, GL_STENCIL_INDEX8, GL_STENCIL_PASS_DEPTH_FAIL, GL_STENCIL_PASS_DEPTH_PASS, GL_STENCIL_REF, GL_STENCIL_TEST, GL_STENCIL_VALUE_MASK, GL_STENCIL_WRITEMASK, GL_STREAM_COPY, GL_STREAM_DRAW, GL_STREAM_READ, GL_SUBPIXEL_BITS, GL_SYNC_CONDITION, GL_SYNC_FENCE, GL_SYNC_FLAGS, GL_SYNC_FLUSH_COMMANDS_BIT, GL_SYNC_GPU_COMMANDS_COMPLETE, GL_SYNC_STATUS, GL_TEXTURE, GL_TEXTURE0, GL_TEXTURE1, GL_TEXTURE10, GL_TEXTURE11, GL_TEXTURE12, GL_TEXTURE13, GL_TEXTURE14, GL_TEXTURE15, GL_TEXTURE16, GL_TEXTURE17, GL_TEXTURE18, GL_TEXTURE19, GL_TEXTURE2, GL_TEXTURE20, GL_TEXTURE21, GL_TEXTURE22, GL_TEXTURE23, GL_TEXTURE24, GL_TEXTURE25, GL_TEXTURE26, GL_TEXTURE27, GL_TEXTURE28, GL_TEXTURE29, GL_TEXTURE3, GL_TEXTURE30, GL_TEXTURE31, GL_TEXTURE4, GL_TEXTURE5, GL_TEXTURE6, GL_TEXTURE7, GL_TEXTURE8, GL_TEXTURE9, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BINDING_2D, GL_TEXTURE_BINDING_2D_ARRAY, GL_TEXTURE_BINDING_3D, GL_TEXTURE_BINDING_CUBE_MAP, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_ANISOTROPY_EXT, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_WRAP_R, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TIMEOUT_EXPIRED, GL_TIMEOUT_IGNORED, GL_TIMESTAMP_EXT, GL_TIME_ELAPSED_EXT, GL_TRANSFORM_FEEDBACK, GL_TRANSFORM_FEEDBACK_ACTIVE, GL_TRANSFORM_FEEDBACK_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER_BINDING, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_PAUSED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRIANGLES, GL_TRIANGLE_FAN, GL_TRIANGLE_STRIP, GL_UNIFORM_ARRAY_STRIDE, GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS, GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES, GL_UNIFORM_BLOCK_BINDING, GL_UNIFORM_BLOCK_DATA_SIZE, GL_UNIFORM_BLOCK_INDEX, GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER, GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER, GL_UNIFORM_BUFFER, GL_UNIFORM_BUFFER_BINDING, GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, GL_UNIFORM_BUFFER_SIZE, GL_UNIFORM_BUFFER_START, GL_UNIFORM_IS_ROW_MAJOR, GL_UNIFORM_MATRIX_STRIDE, GL_UNIFORM_OFFSET, GL_UNIFORM_SIZE, GL_UNIFORM_TYPE, GL_UNMASKED_RENDERER_WEBGL, GL_UNMASKED_VENDOR_WEBGL, GL_UNPACK_ALIGNMENT, GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, GL_UNPACK_FLIP_Y_WEBGL, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, GL_UNPACK_ROW_LENGTH, GL_UNPACK_SKIP_IMAGES, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNSIGNALED, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_24_8_WEBGL, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_5_9_9_9_REV, GL_UNSIGNED_INT_SAMPLER_2D, GL_UNSIGNED_INT_SAMPLER_2D_ARRAY, GL_UNSIGNED_INT_SAMPLER_3D, GL_UNSIGNED_INT_SAMPLER_CUBE, GL_UNSIGNED_INT_VEC2, GL_UNSIGNED_INT_VEC3, GL_UNSIGNED_INT_VEC4, GL_UNSIGNED_NORMALIZED, GL_UNSIGNED_NORMALIZED_EXT, GL_VALIDATE_STATUS, GL_VENDOR, GL_VERSION, GL_VERTEX_ARRAY_BINDING, GL_VERTEX_ARRAY_BINDING_OES, GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_POINTER, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_SHADER, GL_VIEWPORT, GL_WAIT_FAILED, GL_ZERO, GaussianBlur, GetComponentFromEntities, type GetInstance, type GetProps, Gizmo, GlobalDataRepository, GlobalRetarget, GlobalRetargetReverse, type Gltf1AnyObject, type Gltf2, type Gltf2Accessor, type Gltf2AccessorComponentType, type Gltf2AccessorComponentTypeNumber, type Gltf2AccessorCompositionType, type Gltf2AccessorCompositionTypeString, type Gltf2AccessorEx, type Gltf2AccessorIndex, type Gltf2Animation, type Gltf2AnimationAccessorCompositionType, type Gltf2AnimationAccessorCompositionTypeString, type Gltf2AnimationChannel, type Gltf2AnimationChannelTarget, type Gltf2AnimationPathName, type Gltf2AnimationSampler, type Gltf2AnimationSamplerInterpolation, type Gltf2AnyObject, type Gltf2Asset, type Gltf2AttributeAccessors, type Gltf2AttributeBlendShapes, type Gltf2AttributeBlendShapesAccessors, type Gltf2Attributes, type Gltf2Buffer, type Gltf2BufferView, type Gltf2BufferViewEx, type Gltf2Camera, type Gltf2CameraOrthographic, type Gltf2CameraPerspective, type Gltf2Ex, type Gltf2ExportType, Gltf2Exporter, type Gltf2ExporterArguments, type Gltf2Image, type Gltf2ImageEx, Gltf2Importer, type Gltf2Material, type Gltf2MaterialEx, type Gltf2Mesh, type Gltf2Node, type Gltf2NormalTextureInfo, type Gltf2OcclusionTextureInfo, type Gltf2PbrMetallicRoughness, type Gltf2PbrMetallicRoughnessEx, type Gltf2Primitive, type Gltf2Scene, type Gltf2Skin, type Gltf2Sparse, type Gltf2SparseIndices, type Gltf2SparseValues, type Gltf2Texture, type Gltf2TextureInfo, type Gltf2TextureSampler, type GltfFileBuffers, GltfImporter, type GltfLoadOption, GreaterShaderNode, Grid, type GridDescriptor, HdriFormat, type HdriFormatEnum, type IAnimationEntity, type IAnimationEntityMethods, type IAnimationRetarget, type IAnimationStateEntity, type IAnyPrimitiveDescriptor, type IArrayBufferBasedMathNumber, type IBlendShapeEntity, type IBlendShapeEntityMethods, type ICGAPIResourceRepository, type ICameraController, type ICameraControllerEntity, type ICameraControllerEntityMethods, type ICameraEntity, type ICameraEntityMethods, type IColorRgb, type IColorRgba, type IConstraintEntity, type IEffekseerEntityMethods, type IEnhancedArrayMethods, type IEntity, type IEventPubSub, type ILightEntity, type ILightEntityMethods, type ILoaderExtension, type ILogQuaternion, type IMatrix, type IMatrix22, type IMatrix33, type IMatrix44, type IMesh, type IMeshEntity, type IMeshEntityMethods, type IMeshRendererEntityMethods, type IMutableColorRgb, type IMutableColorRgba, type IMutableMatrix, type IMutableMatrix22, type IMutableMatrix33, type IMutableMatrix44, type IMutableQuaternion, type IMutableScalar, type IMutableVector, type IMutableVector2, type IMutableVector3, type IMutableVector4, INPUT_HANDLING_STATE_CAMERA_CONTROLLER, INPUT_HANDLING_STATE_GIZMO_SCALE, INPUT_HANDLING_STATE_GIZMO_TRANSLATION, INPUT_HANDLING_STATE_NONE, type IPhysicsEntity, type IPhysicsEntityMethods, type IQuaternion, type IRenderable, type IRnObject, type IScalar, type ISceneGraphEntity, type ISceneGraphEntityMethods, type ISemanticVertexAttribute, IShape, type ISkeletalEntity, type ISkeletalEntityMethods, type ITransformEntity, type ITransformEntityMethods, type IVector, type IVector2, type IVector3, type IVector4, type IVrmEntityMethods, type IWeakOption, IdentityMatrix33, IdentityMatrix44, IfStatementShader, IfStatementShaderNode, type ImageBitmapData, ImageInfo, ImageUtil, type Index, type IndexOf16Bytes, type IndexOf4Bytes, type IndicesAccessOption, type InputHandlerInfo, type InputHandlingState, InputManager, type IntegerTypedArray, Is, IsObj, type IsType, Joint, type JointDescriptor, type KHR_interactivity, type KHR_interactivity_Configuration, type KHR_interactivity_Declaration, type KHR_interactivity_Event, type KHR_interactivity_Flow, type KHR_interactivity_Graph, type KHR_interactivity_Node, type KHR_interactivity_Type, type KHR_interactivity_Value, type KHR_interactivity_Variable, type KHR_interactivity_value_type, type KHR_lights_punctual, type KHR_lights_punctual_Light, KTX2TextureLoader, LightComponent, LightGizmo, LightType, type LightTypeEnum, Line, type LineDescriptor, type LoadImageToMipLevelDescriptor, LocatorGizmo, LogLevel, LogQuaternion, Logger, type MSC_TRANSCODER_TYPE, MToon0xMaterialContent, MToon1MaterialContent, MatCapMaterialContent, Material, MaterialHelper, type MaterialNodeUID$1 as MaterialNodeUID, MaterialRepository, type MaterialSID, type MaterialTID, type MaterialTypeName, type MaterialUID, MathClassUtil, MathUtil, Matrix22, Matrix33, Matrix44, MemoryManager, type MergeCtor, MergeVectorShaderNode, Mesh, MeshComponent, MeshHelper, MeshRendererComponent, type MeshUID, type MilliSecond, MiscUtil, type MixinBase, ModelConverter, ModuleManager, type MscTranscoderModule, MultiplyShaderNode, MutableColorRgb, MutableColorRgba, MutableMatrix22, MutableMatrix33, MutableMatrix44, MutableQuaternion, MutableScalar, MutableScalar_, MutableScalard, type MutableScalarf, MutableVector2, MutableVector2_, MutableVector2d, type MutableVector2f, MutableVector3, MutableVector3_, MutableVector3d, type MutableVector3f, MutableVector4, MutableVector4_, MutableVector4d, type MutableVector4f, None, NormalMatrixShaderNode, NormalizeShaderNode, type ObjectUID, type Offset, OimoPhysicsStrategy, Ok, type Option, OrbitCameraController, OutColorShaderNode, OutPositionShaderNode, type PartialRequire, PhysicsComponent, type PhysicsProperty, type PhysicsPropertyInner, type PhysicsStrategy, type PhysicsWorldProperty, PixelFormat, type PixelFormatEnum, Plane, type PlaneDescriptor, PointShadowMap, type PointType, Primitive, type PrimitiveDescriptor, PrimitiveMode, type PrimitiveModeEnum, type PrimitiveSortKey, type PrimitiveSortKeyLength, type PrimitiveSortKeyOffset, PrimitiveSortKey_BitLength_Depth, PrimitiveSortKey_BitLength_Material, PrimitiveSortKey_BitLength_PrimitiveType, PrimitiveSortKey_BitLength_TranslucencyType, PrimitiveSortKey_BitOffset_Material, PrimitiveSortKey_BitOffset_PrimitiveType, PrimitiveSortKey_BitOffset_TranslucencyType, PrimitiveSortKey_BitOffset_ViewportLayer, type PrimitiveUID, ProcessApproach, ProcessApproachClass, type ProcessApproachEnum, ProcessStage, type ProcessStageEnum, ProjectionMatrixShaderNode, Quaternion, type RaycastResult, type RaycastResultEx1, type RaycastResultEx2, RenderBuffer, RenderBufferTarget, type RenderBufferTargetEnum, RenderPass, RenderPassHelper, type RenderPassUID, RenderTargetTexture, RenderTargetTexture2DArray, RenderTargetTextureCube, RenderableHelper, type RenderingArgWebGL, type RenderingArgWebGpu, type RequireOne, type Result, RhodoniteImportExtension, type RnError, RnException, type RnM2, type RnM2Accessor, type RnM2Animation, type RnM2AnimationChannel, type RnM2AnimationChannelTarget, type RnM2AnimationSampler, type RnM2Asset, type RnM2AttributeAccessors, type RnM2AttributeBlendShapes, type RnM2AttributeBlendShapesAccessors, type RnM2Attributes, type RnM2AttributesObject, type RnM2Buffer, type RnM2BufferView, type RnM2Camera, type RnM2CameraOrthographic, type RnM2CameraPerspective, type RnM2ExtensionEffekseer, type RnM2ExtensionsEffekseerEffect, type RnM2ExtensionsEffekseerTimeline, type RnM2ExtensionsEffekseerTimelineItem, type RnM2Image, type RnM2Material, type RnM2MaterialVariant, type RnM2Mesh, type RnM2Node, type RnM2NormalTextureInfo, type RnM2OcclusionTextureInfo, type RnM2PbrMetallicRoughness, type RnM2Primitive, type RnM2Scene, type RnM2Skin, type RnM2Sparse, type RnM2SparseIndices, type RnM2SparseValues, type RnM2Texture, type RnM2TextureInfo, type RnM2TextureSampler, type RnM2Vrma, RnObject, RnPromise, type RnPromiseCallback, type RnPromiseCallbackObj, type RnTags, type RnWebGLProgram, type RnWebGLTexture, type RnXR, Sampler, type SamplerDescriptor, Scalar, Scalar_, Scalard, type Scalarf, ScaleGizmo, SceneGraphComponent, type Second, type ShaderAttributeOrSemanticsOrString, ShaderGraphResolver, ShaderNode, type ShaderNodeEnum, type ShaderNodeJson, type ShaderNodeJsonConnection, type ShaderNodeJsonNode, type ShaderNodeJsonNodeInput, type ShaderNodeJsonNodeOutput, type ShaderNodeUID, ShaderSemantics, ShaderSemanticsClass, type ShaderSemanticsEnum, type ShaderSemanticsIndex, type ShaderSemanticsInfo, type ShaderSemanticsName, type ShaderSocket, type ShaderSources, ShaderType, type ShaderTypeEnum, type ShaderVariable, ShaderVariableType, type ShaderVariableTypeEnum, ShaderityUtilityWebGL, ShadingModel, type ShadingModelEnum, ShadowMap, ShadowMapDecodeClassicMaterialContent, type ShadowMapEnum, ShadowMapType, ShadowSystem, SimpleVertexAttribute, type Size, SkeletalComponent, Some, Sphere, SphereCollider, type SphereDescriptor, SplitVectorShaderNode, type SquareMatrixComponentN, SymbolWeakMap, SynthesizeHdrMaterialContent, System, SystemState, type Tag, TagGltf2NodeIndex, Texture, type TextureData, TextureDataFloat, TextureFetchShader, TextureFormat, type TextureFormatEnum, TextureParameter, type TextureParameterEnum, type TextureParameters, type TextureUID, Time, ToneMappingType, type ToneMappingTypeEnum, type TranscodeTarget, type TranscodedImage, Transform3D, TransformComponent, TranslationGizmo, type TypedArray, type TypedArrayConstructor, UastcImageTranscoder, UniformDataShader, UniformDataShaderNode, VERSION, type VRM0x_Extension, VRMColliderGroup, VRMSpring, VRMSpringBone, VRMSpringBonePhysicsStrategy, VarianceShadowMapDecodeClassicMaterialContent, VaryingVariableShader, Vector2, Vector2_, Vector2d, type Vector2f, Vector3, Vector3_, Vector3d, type Vector3f, Vector4, Vector4_, Vector4d, type Vector4f, type VectorAndSquareMatrixComponentN, type VectorComponentN, type VectorCompositionTypes, VectorN, VertexAttribute, VertexAttributeClass, type VertexAttributeComponent, type VertexAttributeEnum, type VertexAttributeSemanticsJoinedString, type VertexAttributeTypeName, type VertexAttributesLayout, type VertexHandles, VideoTexture, type VideoTextureArguments, ViewMatrixShaderNode, Visibility, type VisibilityEnum, type Vrm0x, type Vrm0xBlendShapeBind, type Vrm0xBlendShapeGroup, type Vrm0xBoneGroup, type Vrm0xCollider, type Vrm0xColliderGroup, type Vrm0xHumanBone, Vrm0xImporter, type Vrm0xLookAt, type Vrm0xMaterialProperty, VrmComponent, type VrmExpression, type VrmExpressionMorphBind, type VrmExpressionName, VrmImporter, VrmaImporter, WalkThroughCameraController, WeakNone, WeakOption, WeakSome, WebGLContextWrapper, WebGLExtension, type WebGLExtensionEnum, type WebGLResource, type WebGLResourceHandle, WebGLResourceRepository, type WebGLStrategy, WebGLStrategyDataTexture, WebGLStrategyUniform, type WebGPUResourceHandle, WebGpuDeviceWrapper, type WebGpuResource, WebGpuResourceRepository, WebGpuStrategyBasic, WebXRSystem, WellKnownComponentTIDs, WireframeMaterialNode, WorldMatrixShaderNode, _from, _fromString, _fromStringCaseSensitively, _getPropertyIndex2, add2, add2_offset, add3, add3_offset, add4, add4_offset, addLineNumberToCode, applyMixins, array2_lerp_offsetAsComposition, array3_lerp_offsetAsComposition, array4_lerp_offsetAsComposition, arrayN_lerp_offsetAsComposition, assertDoesNotHave, assertExist, assertHas, assertIsErr, assertIsOk, calcAlignedByteLength, checkVersionOfGltf, combineImages, convertHTMLImageElementToCanvas, createCameraControllerEntity, createCameraEntity, createEffekseer, createEntity, createGroupEntity, createLightEntity, createLightWithCameraEntity, createMeshEntity, createMotionController, createPhysicsEntity, createSkeletalEntity, createTransformEntity, deepCopyUsingJsonStringify, defaultAnimationTrackName, defaultAssetLoader, defaultValue, detectFormatByArrayBuffers, detectFormatByUri, downloadArrayBuffer, downloadTypedArray, dummyAnisotropyTexture, dummyBlackCubeTexture, dummyBlackTexture, dummyBlueTexture, dummyDepthMomentTextureArray, dummySRGBGrayTexture, dummyWhiteTexture, dummyZeroTexture, enhanceArray, flattenHierarchy, fromTensorToCompositionType, get1, get1_offset, get1_offsetAsComposition, get2, get2_offset, get2_offsetAsComposition, get3, get3_offset, get3_offsetAsComposition, get4, get4_offset, get4_offsetAsComposition, getEvent, getMotionController, getN_offset, getN_offsetAsComposition, type getShaderPropertyFunc, getWebXRSystem, type glTF1, greaterThan, ifDefinedThen, ifDefinedThenWithReturn, ifExistsThen, ifExistsThenWithReturn, ifNotExistsThen, ifNotExistsThenWithReturn, ifUndefinedThen, ifUndefinedThenWithReturn, initDefaultTextures, isBlend, isBlendWithZWrite, isBlendWithoutZWrite, isOpaque, isSameGlTF2TextureSampler, isSkipDrawing, isTranslucent, lessThan, mulArray3WithScalar_offset, mulArray4WithScalar_offset, mulArrayNWithScalar_offset, mulThatAndThisToOutAsMat44_offsetAsComposition, normalizeArray4, nullishToEmptyArray, nullishToEmptyMap, objectCachify, primitiveCachify1, type primitives, qlerp_offsetAsComposition, scalar_lerp_offsetAsComposition, setupShaderProgram, sheenLutTexture, updateGamePad, updateMotionControllerModel, valueWithCompensation, valueWithDefault };
