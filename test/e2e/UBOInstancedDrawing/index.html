<!doctype html>
<html>

<head>
  <title>Rhodonite Index Buffer example</title>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <style>
    main {
      display: flex;
    }
    section {
      background-color: darkgray;
      padding: 10px;
      margin: 20px;
    }
  </style>
</head>

<body>
  <header>
    <h1 class="header-title">Rhodonite E2E Test - UBO Instanced Drawing</h1>
  </header>
  <main>
    <section class="test">
      <h2>Rendering Test Image</h2>
      <canvas id="world" width="600" height="600"></canvas>
      <div>
        <button onclick="window.isAnimating = true;">Animate</button>
      </div>
    </section>
    <section class="correct">
      <h2>Correct PNG Image</h2>
      <img src="__image_snapshots__/test-js-regression-test-1-snap.png" />
    </section>
  </main>
  <script type="module">

    import Rn from '../../../dist/rhodonite.js';

    function generateEntity() {
      const repo = Rn.EntityRepository.getInstance();
      const entity = repo.createEntity([Rn.TransformComponent.componentTID, Rn.SceneGraphComponent.componentTID, Rn.MeshComponent.componentTID, Rn.MeshRendererComponent.componentTID]);
      return entity;
    }

    function readyBasicVerticesData() {
      const indices = new Uint16Array([
//        0, 1, 2, 2, 3, 0

        3, 1, 0, 2, 1, 3,
        4, 5, 7, 7, 5, 6,
        8, 9, 11, 11, 9, 10,
        15, 13, 12, 14, 13, 15,
        19, 17, 16, 18, 17, 19,
        20, 21, 23, 23, 21, 22
      ]);

      const positions = new Float32Array([
        // -1, -1, 0.0,
        //  1, -1, 0.0,
        //  1, 1, 0.0,
        // -1, 1, 0.0

        // upper
        -1, 1, -1,
        1,  1, -1,
        1,  1, 1,
        -1, 1, 1,
        // lower
        -1, -1, -1,
        1,  -1, -1,
        1,  -1, 1,
        -1, -1, 1,
        // front
        -1, -1, 1,
        1,  -1, 1,
        1,  1, 1,
        -1, 1, 1,
        // back
        -1, -1, -1,
        1,  -1, -1,
        1,  1, -1,
        -1, 1, -1,
        // right
        1, -1, -1,
        1,  -1, 1,
        1,  1, 1,
        1, 1, -1,
        // left
        -1, -1, -1,
        -1,  -1, 1,
        -1,  1, 1,
        -1, 1, -1
      ]);

      const colors = new Float32Array([
        0.0, 1.0, 1.0,
        1.0, 1.0, 0.0,
        1.0, 0.0, 0.0,
        0.0, 0.0, 1.0,

        0.0, 1.0, 1.0,
        1.0, 1.0, 0.0,
        1.0, 0.0, 0.0,
        0.0, 0.0, 1.0,

        0.0, 1.0, 1.0,
        1.0, 1.0, 0.0,
        1.0, 0.0, 0.0,
        0.0, 0.0, 1.0,

        0.0, 1.0, 1.0,
        1.0, 1.0, 0.0,
        1.0, 0.0, 0.0,
        0.0, 0.0, 1.0,

        0.0, 1.0, 1.0,
        1.0, 1.0, 0.0,
        1.0, 0.0, 0.0,
        0.0, 0.0, 1.0,

        0.0, 1.0, 1.0,
        1.0, 1.0, 0.0,
        1.0, 0.0, 0.0,
        0.0, 0.0, 1.0
      ]);

      const primitive = Rn.Primitive.createPrimitive({
        indices: indices,
        attributeCompositionTypes: [Rn.CompositionType.Vec3, Rn.CompositionType.Vec3],
        attributeSemantics: [Rn.VertexAttribute.Position, Rn.VertexAttribute.Color0],
        attributes: [positions, colors],
        material: 0,
        primitiveMode: Rn.PrimitiveMode.Triangles
      });

      return primitive;
    }

    const repo = Rn.WebGLResourceRepository.getInstance();

    const gl = document.getElementById('world').getContext('webgl2');

    repo.addWebGLContext(gl, true);

    gl.enable(gl.DEPTH_TEST);

    gl.viewport(0, 0, 600, 600);

    // 背景描画
    gl.clearColor(0.8, 0.8, 0.8, 1.0);
    // バッファをクリアする
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const primitive = readyBasicVerticesData();

    const entities = [];
    const entityNumber = 1000;
    for (let i=0; i<entityNumber; i++) {
      const sqrtEntityNumber = Math.floor(Math.sqrt(entityNumber));
      const entity = generateEntity();
      entities.push(entity);
      const meshComponent = entity.getComponent(Rn.MeshComponent.componentTID);
      meshComponent.addPrimitive(primitive);
      entity.getTransform().scale = new Rn.Vector3(1/sqrtEntityNumber/2, 1/sqrtEntityNumber/2, 1/sqrtEntityNumber/2);
      entity.getTransform().translate = new Rn.Vector3(1/sqrtEntityNumber * 2 * (i%sqrtEntityNumber) - 1.0 + 1/sqrtEntityNumber, Math.floor(i / sqrtEntityNumber)/sqrtEntityNumber*2 -1.0 + 1/sqrtEntityNumber, 0.0);
    }

    const system = Rn.System.getInstance();
    const startTime = Date.now();
    let p = null;
    const draw = (time)=>{

      if (time != null && p == null ) {
        p = document.createElement('p');
        p.setAttribute("id", "rendered");
        p.innerText = 'Rendered.';
        document.body.appendChild(p);
      }
      const date = new Date();

      if (window.isAnimating) {
        entities.forEach(entity=>{
          entity.getTransform().rotate = new Rn.Vector3(0.001 * (date.getTime() - startTime), 0.001 * (date.getTime() - startTime), 0.001 * (date.getTime() - startTime));
        });
      }

//      console.log(date.getTime());
      system.process();
      requestAnimationFrame(draw);
    }
    
    draw();



  </script>
</body>

</html>
